      );
    if ( b ) {
        NumberSupported = ReturnedByteCount / sizeof(DISK_GEOMETRY);
        }
    else {
        NumberSupported = 0;
        }
    SupportedGeometryCount = NumberSupported;

    return NumberSupported;
}

VOID
PrintGeometry(
    LPSTR lpDriveName,
    PDISK_GEOMETRY lpGeometry
    )
{
    LPSTR MediaType;

    if (lpDriveName) {
        printf("Geometry for Drive %s\n",lpDriveName);
        }

    switch ( lpGeometry->MediaType ) {
        case F5_1Pt2_512:  MediaType = "5.25, 1.2MB,  512 bytes/sector";break;
        case F3_1Pt44_512: MediaType = "3.5,  1.44MB, 512 bytes/sector";break;
        case F3_2Pt88_512: MediaType = "3.5,  2.88MB, 512 bytes/sector";break;
        case F3_20Pt8_512: MediaType = "3.5,  20.8MB, 512 bytes/sector";break;
        case F3_720_512:   MediaType = "3.5,  720KB,  512 bytes/sector";break;
        case F5_360_512:   MediaType = "5.25, 360KB,  512 bytes/sector";break;
        case F5_320_512:   MediaType = "5.25, 320KB,  512 bytes/sector";break;
        case F5_320_1024:  MediaType = "5.25, 320KB,  1024 bytes/sector";break;
        case F5_180_512:   MediaType = "5.25, 180KB,  512 bytes/sector";break;
        case F5_160_512:   MediaType = "5.25, 160KB,  512 bytes/sector";break;
        case RemovableMedia: MediaType = "Removable media other than floppy";break;
        case FixedMedia:   MediaType = "Fixed hard disk media";break;
        default:           MediaType = "Unknown";break;
    }
    printf("    Media Type %s\n",MediaType);
    printf("    Cylinders %d Tracks/Cylinder %d Sectors/Track %d\n",
        lpGeometry->Cylinders.LowPart,
        lpGeometry->TracksPerCylinder,
        lpGeometry->SectorsPerTrack
        );
}

BOOL
LowLevelFormat(
    HANDLE hDisk,
    PDISK_GEOMETRY lpGeometry
    )
{
    FORMAT_PARAMETERS FormatParameters;
    PBAD_TRACK_NUMBER lpBadTrack;
    UINT i;
    BOOL b;
    DWORD ReturnedByteCount;

    FormatParameters.MediaType = lpGeometry->MediaType;
    FormatParameters.StartHeadNumber = 0;
    FormatParameters.EndHeadNumber = lpGeometry->TracksPerCylinder - 1;
    lpBadTrack = (PBAD_TRACK_NUMBER) LocalAlloc(LMEM_ZEROINIT,lpGeometry->TracksPerCylinder*sizeof(*lpBadTrack));

    for (i = 0; i < lpGeometry->Cylinders.LowPart; i++) {

        FormatParameters.StartCylinderNumber = i;
        FormatParameters.EndCylinderNumber = i;

        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_FORMAT_TRACKS,
                &FormatParameters,
                sizeof(FormatParameters),
                lpBadTrack,
                lpGeometry->TracksPerCylinder*sizeof(*lpBadTrack),
                &ReturnedByteCount,
                NULL
                );

        if (!b ) {
            LocalFree(lpBadTrack);
            return b;
            }
        }

    LocalFree(lpBadTrack);

    return TRUE;
}

BOOL
LockVolume(
    HANDLE hDisk
    )
{
    DWORD ReturnedByteCount;

    return DeviceIoControl(
                hDisk,
                FSCTL_LOCK_VOLUME,
                NULL,
                0,
                NULL,
                0,
                &ReturnedByteCount,
                NULL
                );
}

BOOL
UnlockVolume(
    HANDLE hDisk
    )
{
    DWORD ReturnedByteCount;

    return DeviceIoControl(
                hDisk,
                FSCTL_UNLOCK_VOLUME,
                NULL,
                0,
                NULL,
                0,
                &ReturnedByteCount,
                NULL
                );
}

BOOL
DismountVolume(
    HANDLE hDisk
    )
{
    DWORD ReturnedByteCount;

    return DeviceIoControl(
                hDisk,
                FSCTL_DISMOUNT_VOLUME,
                NULL,
                0,
                NULL,
                0,
                &ReturnedByteCount,
                NULL
                );
}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char Drive[MAX_PATH];
    HANDLE hDrive, hDiskImage;
    DISK_GEOMETRY Geometry;
    UINT i;
    char c, *p;
    LPSTR DriveName;
    BOOL fUsage = TRUE;
    BOOL fShowGeometry = FALSE;
    BOOL fDiskImage = FALSE;
    BOOL SourceIsDrive;
    LPSTR Source, Destination, DiskImage;

    if ( argc > 1 ) {
        fUsage = FALSE;
        while (--argc) {
            p = *++argv;
            if (*p == '/' || *p == '-') {
                while (c = *++p)
                switch (toupper( c )) {
                case '?':
                    fUsage = TRUE;
                    break;

                case 'C':
                    fDiskImage = TRUE;
                    argc--, argv++;
                    Source = *argv;
                    argc--, argv++;
                    Destination = *argv;
                    break;

                case 'G':
                    fShowGeometry = TRUE;
                    argc--, argv++;
                    DriveName = *argv;
                    break;

                default:
                    printf("MFMT: Invalid switch - /%c\n", c );
                    fUsage = TRUE;
                    break;
                    }
                }
            }
        }

    if ( fUsage ) {
        printf("usage: MFMT switches \n" );
        printf("            [-?] display this message\n" );
        printf("            [-g drive] shows disk geometry\n" );
        printf("            [-c source destination] produce diskimage\n" );
        ExitProcess(1);
        }

    if ( fShowGeometry ) {
        sprintf(Drive,"\\\\.\\%s",DriveName);
        hDrive = CreateFile(
                    Drive,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hDrive == INVALID_HANDLE_VALUE ) {
            printf("MFMT: Open %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }

        LockVolume(hDrive);

        if ( !GetDiskGeometry(hDrive,&Geometry) ) {
            printf("MFMT: GetDiskGeometry %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }
        PrintGeometry(DriveName,&Geometry);

        if ( !GetSupportedGeometrys(hDrive) ) {
            printf("MFMT: GetSupportedGeometrys %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }
        printf("\nDrive %s supports the following disk geometries\n",DriveName);

        for(i=0;i<SupportedGeometryCount;i++) {
            printf("\n");
            PrintGeometry(NULL,&SupportedGeometry[i]);
            }

        printf("\n");
        ExitProcess(0);
        }

    if ( fDiskImage ) {
        SourceIsDrive = FALSE;
        if ( Source[strlen(Source)-1] == ':' ) {
            SourceIsDrive = TRUE;
            sprintf(Drive,"\\\\.\\%s",Source);
            DiskImage = Destination;
            }
        if ( Destination[strlen(Destination)-1] == ':' ) {
            if ( SourceIsDrive ) {
                printf("MFMT: Source and Destination cannot both be drives\n");
                ExitProcess(1);
                }
            SourceIsDrive = FALSE;
            sprintf(Drive,"\\\\.\\%s",Destination);
            DiskImage = Source;
            }
        else {
            if ( !SourceIsDrive ) {
                printf("MFMT: Either Source or Destination must be a drive\n");
                ExitProcess(1);
                }
            }

        //
        // Open and Lock the drive
        //

        hDrive = CreateFile(
                    Drive,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hDrive == INVALID_HANDLE_VALUE ) {
            printf("MFMT: Open %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }
        LockVolume(hDrive);

        if ( !GetDiskGeometry(hDrive,&Geometry) ) {
            printf("MFMT: GetDiskGeometry %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }

        if ( !GetSupportedGeometrys(hDrive) ) {
            printf("MFMT: GetSupportedGeometrys %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }

        //
        // Open the disk image file
        //

        hDiskImage = CreateFile(
                        DiskImage,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        SourceIsDrive ? CREATE_ALWAYS : OPEN_EXISTING,
                        0,
                        NULL
                        );
        if ( hDiskImage == INVALID_HANDLE_VALUE ) {
            printf("MFMT: Open %s failed %d\n",DiskImage,GetLastError());
            ExitProcess(1);
            }

        //
        // Now do the copy
        //
        {
            LPVOID IoBuffer;
            BOOL b;
            DWORD BytesRead, BytesWritten;
            DWORD FileSize;
            DWORD GeometrySize;

            //
            // If we are copying from floppy to file, just do the copy
            // Otherwise, we might have to format the floppy first
            //

            if ( SourceIsDrive ) {

                //
                // Device reads must be sector aligned. VirtualAlloc will
                // garuntee alignment
                //

                GeometrySize = Geometry.Cylinders.LowPart *
                               Geometry.TracksPerCylinder *
                               Geometry.SectorsPerTrack *
                               Geometry.BytesPerSector;

                IoBuffer = VirtualAlloc(NULL,GeometrySize,MEM_COMMIT,PAGE_READWRITE);

                if ( !IoBuffer ) {
                    printf("MFMT: Buffer Allocation Failed\n");
                    ExitProcess(1);
                    }

                b = ReadFile(hDrive,IoBuffer, GeometrySize, &BytesRead, NULL);
                if (b && BytesRead){
                    b = WriteFile(hDiskImage,IoBuffer, BytesRead, &BytesWritten, NULL);
                    if ( !b || ( BytesRead != BytesWritten ) ) {
                        printf("MFMT: Fatal Write Error %d\n",GetLastError());
                        ExitProcess(1);
                        }
                    }
                else {
                    printf("MFMT: Fatal Read Error %d\n",GetLastError());
                    ExitProcess(1);
                    }
                }
            else {

                //
                // Check to see if the image will fit on the floppy. If it
                // will, then LowLevelFormat the floppy and press on
                //

                FileSize = GetFileSize(hDiskImage,NULL);

                b = FALSE;
                for(i=0;i<SupportedGeometryCount;i++) {
                    GeometrySize = SupportedGeometry[i].Cylinders.LowPart *
                                   SupportedGeometry[i].TracksPerCylinder *
                                   SupportedGeometry[i].SectorsPerTrack *
                                   SupportedGeometry[i].BytesPerSector;
                    if ( GeometrySize >= FileSize ) {

                        IoBuffer = VirtualAlloc(NULL,GeometrySize,MEM_COMMIT,PAGE_READWRITE);

                        if ( !IoBuffer ) {
                            printf("MFMT: Buffer Allocation Failed\n");
                            ExitProcess(1);
                            }

                        //
                        // Format the floppy
                        //

                        LowLevelFormat(hDrive,&SupportedGeometry[i]);

                        b = ReadFile(hDiskImage,IoBuffer, GeometrySize, &BytesRead, NULL);
                        if (b && BytesRead){
                            b = WriteFile(hDrive,IoBuffer, BytesRead, &BytesWritten, NULL);
                            if ( !b || ( BytesRead != BytesWritten ) ) {
                                printf("MFMT: Fatal Write Error %d\n",GetLastError());
                                ExitProcess(1);
                                }
                            }
                        else {
                            printf("MFMT: Fatal Read Error %d\n",GetLastError());
                            ExitProcess(1);
                            }
                        b = TRUE;
                        break;
                        }
                    }

                if ( !b ) {
                    printf("MFMT: FileSize %d is not supported on drive %s\n",FileSize,DriveName);
                    ExitProcess(1);
                    }
                }
        }

        //
        // Dismounting forces the filesystem to re-evaluate the media id
        // and geometry. This is the same as popping the floppy in and out
        // of the disk drive
        //

        DismountVolume(hDrive);
        UnlockVolume(hDrive);

        ExitProcess(0);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\ntwow64b.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntwow64b.h

Abstract:

    This header contains the fake Nt functions in Win32 Base used WOW64 to call
    into 64 bit code.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

    Samer Arafeh (samera)  20-May-2000
    Add Side-by-Side support to wow64

    Jay Krell (a-JayK) July 2000
    big changes to Side-by-Side

--*/

#ifndef _NTWOW64B_
#define _NTWOW64B_

#if _MSC_VER > 1000
#pragma once
#endif

#include "basesxs.h"

extern BOOL RunningInWow64;

//
//  csrbeep.c
//
VOID
NTAPI
NtWow64CsrBasepSoundSentryNotification(
    IN ULONG VideoMode
    );

//
//  csrdlini.c
//
NTSTATUS
NTAPI
NtWow64CsrBasepRefreshIniFileMapping(
    IN PUNICODE_STRING BaseFileName
    );

//
//  csrdosdv.c 
//
NTSTATUS
NTAPI
NtWow64CsrBasepDefineDosDevice(
    IN DWORD dwFlags,
    IN PUNICODE_STRING pDeviceName,
    IN PUNICODE_STRING pTargetPath
    );

//
//  csrpathm.c
//
UINT
NTAPI
NtWow64CsrBasepGetTempFile(
    VOID
    );

//
//  csrpro.c
//

NTSTATUS
NtWow64CsrBasepCreateProcess(
    IN PBASE_CREATEPROCESS_MSG a
    );

VOID
NtWow64CsrBasepExitProcess(
    IN UINT uExitCode
    );

NTSTATUS
NtWow64CsrBasepSetProcessShutdownParam(
    IN DWORD dwLevel,
    IN DWORD dwFlags
    );

NTSTATUS
NtWow64CsrBasepGetProcessShutdownParam(
    OUT LPDWORD lpdwLevel,
    OUT LPDWORD lpdwFlags
    );

//
//  csrterm.c
//
NTSTATUS
NtWow64CsrBasepSetTermsrvAppInstallMode(
    IN BOOL bState
    );

NTSTATUS
NtWow64CsrBasepSetClientTimeZoneInformation(
    IN PBASE_SET_TERMSRVCLIENTTIMEZONE c
    );

//
//  csrthrd.c
//
NTSTATUS
NtWow64CsrBasepCreateThread(
    IN HANDLE ThreadHandle,
    IN CLIENT_ID ClientId
    );

//
//  csrbinit.c
//
NTSTATUS
NtWow64CsrBaseClientConnectToServer(
    IN PWSTR szSessionDir,
    OUT PHANDLE phMutant,
    OUT PBOOLEAN pServerProcess
    );


//
// csrsxs.c
//
NTSTATUS
NtWow64CsrBasepCreateActCtx(
    IN PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\namepipe.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    namepipe.c

Abstract:

    This module contains the Win32 Named Pipe API

Author:

    Colin Watson (ColinW)  13-March-1991

Revision History:

--*/

#include "basedll.h"

#define DOS_LOCAL_PIPE_PREFIX   L"\\\\.\\pipe\\"
#define DOS_LOCAL_PIPE          L"\\DosDevices\\pipe\\"
#define DOS_REMOTE_PIPE         L"\\DosDevices\\UNC\\"

#define INVALID_PIPE_MODE_BITS  ~(PIPE_READMODE_BYTE    \
                                | PIPE_READMODE_MESSAGE \
                                | PIPE_WAIT             \
                                | PIPE_NOWAIT)
BOOL
NpGetUserNamep(
    HANDLE hNamedPipe,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    );

typedef
BOOL (WINAPI *REVERTTOSELF)( VOID );

typedef
BOOL (WINAPI *GETUSERNAMEW)( LPWSTR, LPDWORD );

typedef
BOOL (WINAPI *IMPERSONATENAMEDPIPECLIENT)( HANDLE );

HANDLE
APIENTRY
CreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++
    Ansi thunk to CreateNamedPipeW.

--*/
{
    NTSTATUS Status;
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return INVALID_HANDLE_VALUE;
        }

    return CreateNamedPipeW(
            (LPCWSTR)Unicode->Buffer,
            dwOpenMode,
            dwPipeMode,
            nMaxInstances,
            nOutBufferSize,
            nInBufferSize,
            nDefaultTimeOut,
            lpSecurityAttributes);
}

HANDLE
APIENTRY
CreateNamedPipeW(
    LPCWSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++


Parameters:

    lpName --Supplies the pipe name Documented in "Pipe Names" section
        earlier.  This must be a local name.

    dwOpenMode --Supplies the set of flags that define the mode which the
        pipe is to be opened with.  The open mode consists of access
        flags (one of three values) logically ORed with a writethrough
        flag (one of two values) and an overlapped flag (one of two
        values), as described below.

        dwOpenMode Flags:

        PIPE_ACCESS_DUPLEX --Pipe is bidirectional.  (This is
            semantically equivalent to calling CreateFile with access
            flags of GENERIC_READ | GENERIC_WRITE.)

        PIPE_ACCESS_INBOUND --Data goes from client to server only.
            (This is semantically equivalent to calling CreateFile with
            access flags of GENERIC_READ.)

        PIPE_ACCESS_OUTBOUND --Data goes from server to client only.
            (This is semantically equivalent to calling CreateFile with
            access flags of GENERIC_WRITE.)

        PIPE_WRITETHROUGH --The redirector is not permitted to delay the
            transmission of data to the named pipe buffer on the remote
            server. This disables a performance enhancement for
            applications that need synchronization with every write
            operation.

        FILE_FLAG_OVERLAPPED --Indicates that the system should
            initialize the file so that ReadFile, WriteFile and other
            operations that may take a significant time to process will
            return ERROR_IO_PENDING. An event will be set to the
            signalled state when the operation completes.

        FILE_FLAG_WRITETHROUGH -- No intermediate buffering.

        WRITE_DAC --            Standard security desired access
        WRITE_OWNER --          ditto
        ACCESS_SYSTEM_SECURITY -- ditto

    dwPipeMode --Supplies the pipe-specific modes (as flags) of the pipe.
        This parameter is a combination of a read-mode flag, a type flag,
        and a wait flag.

        dwPipeMode Flags:

        PIPE_WAIT --Blocking mode is to be used for this handle.

        PIPE_NOWAIT --Nonblocking mode is to be used for this handle.

        PIPE_READMODE_BYTE --Read pipe as a byte stream.

        PIPE_READMODE_MESSAGE --Read pipe as a message stream.  Note that
            this is not allowed with PIPE_TYPE_BYTE.

        PIPE_TYPE_BYTE --Pipe is a byte-stream pipe.  Note that this is
            not allowed with PIPE_READMODE_MESSAGE.

        PIPE_TYPE_MESSAGE --Pipe is a message-stream pipe.

    nMaxInstances --Gives the maximum number of instances for this pipe.
        Acceptable values are 1 to PIPE_UNLIMITED_INSTANCES-1 and
        PIPE_UNLIMITED_INSTANCES.

        nMaxInstances Special Values:

        PIPE_UNLIMITED_INSTANCES --Unlimited instances of this pipe can
            be created.

    nOutBufferSize --Specifies an advisory on the number of bytes to
        reserve for the outgoing buffer.

    nInBufferSize --Specifies an advisory on the number of bytes to
        reserve for the incoming buffer.

    nDefaultTimeOut -- Specifies an optional pointer to a timeout value
        that is to be used if a timeout value is not specified when
        waiting for an instance of a named pipe. This parameter is only
        meaningful when the first instance of a named pipe is created. If
        neither CreateNamedPipe or WaitNamedPipe specify a timeout 50
        milliseconds will be used.

    lpSecurityAttributes --An optional parameter that, if present and
        supported on the target system, supplies a security descriptor
        for the named pipe.  This parameter includes an inheritance flag
        for the handle.  If this parameter is not present, the handle is
        not inherited by child processes.

Return Value:

    Returns one of the following:

    INVALID_HANDLE_VALUE --An error occurred.  Call GetLastError for more
    information.

    Anything else --Returns a handle for use in the server side of
    subsequent named pipe operations.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    LARGE_INTEGER Timeout;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    LPWSTR FilePart;
    ULONG CreateFlags;
    ULONG DesiredAccess;
    ULONG ShareAccess;
    ULONG MaxInstances;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL DefaultAcl = NULL;

    if ((nMaxInstances == 0) ||
        (nMaxInstances > PIPE_UNLIMITED_INSTANCES)) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
        }

    // Convert Win32 maximum Instances to Nt maximum instances.
    MaxInstances = (nMaxInstances == PIPE_UNLIMITED_INSTANCES)?
        0xffffffff : nMaxInstances;


    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpName,
                            &FileName,
                            &FilePart,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    if (Obja.SecurityDescriptor == NULL) {

        //
        // Apply default security if none specified (bug 131090)
        //

        Status = RtlDefaultNpAcl( &DefaultAcl );
        if (NT_SUCCESS( Status )) {
            RtlCreateSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
            RtlSetDaclSecurityDescriptor( &SecurityDescriptor, TRUE, DefaultAcl, FALSE );
            Obja.SecurityDescriptor = &SecurityDescriptor;
        } else {
            RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            BaseSetLastNTError(Status);
            return INVALID_HANDLE_VALUE;
        }
    }

    //  End of code common with fileopcr.c CreateFile()

    CreateFlags = (dwOpenMode & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwOpenMode & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT);

    //
    //  Determine the timeout. Convert from milliseconds to an Nt delta time
    //

    if ( nDefaultTimeOut ) {
        Timeout.QuadPart = - (LONGLONG)UInt32x32To64( 10 * 1000, nDefaultTimeOut );
        }
    else {
        //  Default timeout is 50 Milliseconds
        Timeout.QuadPart =  -10 * 1000 * 50;
        }

    //  Check no reserved bits are set by mistake.

    if (( dwOpenMode & ~(PIPE_ACCESS_DUPLEX |
                         FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH |
                         FILE_FLAG_FIRST_PIPE_INSTANCE | WRITE_DAC |
                         WRITE_OWNER | ACCESS_SYSTEM_SECURITY ))||

        ( dwPipeMode & ~(PIPE_NOWAIT | PIPE_READMODE_MESSAGE |
                         PIPE_TYPE_MESSAGE ))) {

            RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            if (DefaultAcl != NULL) {
                RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
            }
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    //
    //  Translate the open mode into a sharemode to restrict the clients access
    //  and derive the appropriate local desired access.
    //

    switch ( dwOpenMode & PIPE_ACCESS_DUPLEX ) {
        case PIPE_ACCESS_INBOUND:
            ShareAccess = FILE_SHARE_WRITE;
            DesiredAccess = GENERIC_READ;
            break;

        case PIPE_ACCESS_OUTBOUND:
            ShareAccess = FILE_SHARE_READ;
            DesiredAccess = GENERIC_WRITE;
            break;

        case PIPE_ACCESS_DUPLEX:
            ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
            DesiredAccess = GENERIC_READ | GENERIC_WRITE;
            break;

        default:
            RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            if (DefaultAcl != NULL) {
                RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
            }
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    DesiredAccess |= SYNCHRONIZE |
         ( dwOpenMode & (WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY ));

    Status = NtCreateNamedPipeFile (
        &Handle,
        DesiredAccess,
        &Obja,
        &IoStatusBlock,
        ShareAccess,
        (dwOpenMode & FILE_FLAG_FIRST_PIPE_INSTANCE) ?
            FILE_CREATE : FILE_OPEN_IF, // Create first instance or subsequent
        CreateFlags,                    // Create Options
        dwPipeMode & PIPE_TYPE_MESSAGE ?
            FILE_PIPE_MESSAGE_TYPE : FILE_PIPE_BYTE_STREAM_TYPE,
        dwPipeMode & PIPE_READMODE_MESSAGE ?
            FILE_PIPE_MESSAGE_MODE : FILE_PIPE_BYTE_STREAM_MODE,
        dwPipeMode & PIPE_NOWAIT ?
            FILE_PIPE_COMPLETE_OPERATION : FILE_PIPE_QUEUE_OPERATION,
        MaxInstances,                   // Max instances
        nInBufferSize,                  // Inbound quota
        nOutBufferSize,                 // Outbound quota
        (PLARGE_INTEGER)&Timeout
        );

    if ( Status == STATUS_NOT_SUPPORTED ||
         Status == STATUS_INVALID_DEVICE_REQUEST ) {

        //
        // The request must have been processed by some other device driver
        // (other than NPFS).  Map the error to something reasonable.
        //

        Status = STATUS_OBJECT_NAME_INVALID;
    }

    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
    if (DefaultAcl != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }

    return Handle;
}

BOOL
APIENTRY
ConnectNamedPipe(
    HANDLE hNamedPipe,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    The ConnectNamedPipe function is used by the server side of a named pipe
    to wait for a client to connect to the named pipe with a CreateFile
    request. The handle provided with the call to ConnectNamedPipe must have
    been previously returned by a successful call to CreateNamedPipe. The pipe
    must be in the disconnected, listening or connected states for
    ConnectNamedPipe to succeed.

    The behavior of this call depends on the blocking/nonblocking mode selected
    with the PIPE_WAIT/PIPE_NOWAIT flags when the server end of the pipe was
    created with CreateNamedPipe.

    If blocking mode is specified, ConnectNamedPipe will change the state from
    disconnected to listening and block. When a client connects with a
    CreateFile, the state will be changed from listening to connected and the
    ConnectNamedPipe returns TRUE. When the file handle is created with
    FILE_FLAG_OVERLAPPED on a blocking mode pipe, the lpOverlapped parameter
    can be specified. This allows the caller to continue processing while the
    ConnectNamedPipe API awaits a connection. When the pipe enters the
    signalled state the event is set to the signalled state.

    When nonblocking is specified ConnectNamedPipe will not block. On the
    first call the state will change from disconnected to listening. When a
    client connects with an Open the state will be changed from listening to
    connected. The ConnectNamedPipe will return FALSE (with GetLastError
    returning ERROR_PIPE_LISTENING) until the state is changed to the listening
    state.

Arguments:

    hNamedPipe - Supplies a Handle to the server side of a named pipe.

    lpOverlapped - Supplies an overlap structure to be used with the request.
        If NULL then the API will not return until the operation completes. When
        FILE_FLAG_OVERLAPPED is specified when the handle was created,
        ConnectNamedPipe may return ERROR_IO_PENDING to allow the caller to
        continue processing while the operation completes. The event (or File
        handle if hEvent=NULL) will be set to the not signalled state before
        ERROR_IO_PENDING is returned. The event will be set to the signalled
        state upon completion of the request. GetOverlappedResult is used to
        determine the error status.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    if ( lpOverlapped ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        }
    Status = NtFsControlFile(
                hNamedPipe,
                (lpOverlapped==NULL)? NULL : lpOverlapped->hEvent,
                NULL,   // ApcRoutine
                lpOverlapped ? ((ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped) : NULL,
                (lpOverlapped==NULL) ? &Iosb : (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                FSCTL_PIPE_LISTEN,
                NULL,   // InputBuffer
                0,      // InputBufferLength,
                NULL,   // OutputBuffer
                0       // OutputBufferLength
                );

    if ( lpOverlapped == NULL && Status == STATUS_PENDING) {
        // Operation must complete before return & Iosb destroyed
        Status = NtWaitForSingleObject( hNamedPipe, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {
            Status = Iosb.Status;
            }
        }

    if (NT_SUCCESS( Status ) && Status != STATUS_PENDING ) {
        return TRUE;
        }
    else
        {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
DisconnectNamedPipe(
    HANDLE hNamedPipe
    )

/*++

Routine Description:

    The DisconnectNamedPipe function can be used by the server side of a named
    pipe to force the client side to close the client side's handle. (Note that
    the client side must still call CloseFile to do this.)  The client will
    receive an error the next time it attempts to access the pipe. Disconnecting
    the pipe may cause data to be lost before the client reads it. (If the
    application wants to make sure that data is not lost, the serving side
    should call FlushFileBuffers before calling DisconnectNamedPipe.)

Arguments:

    hNamedPipe - Supplies a Handle to the server side of a named pipe.

Return Value:

    TRUE -- The operation was successful, the pipe is in the disconnected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    Status = NtFsControlFile(
                        hNamedPipe,
                        NULL,
                        NULL,   // ApcRoutine
                        NULL,   // ApcContext
                        &Iosb,
                        FSCTL_PIPE_DISCONNECT,
                        NULL,   // InputBuffer
                        0,      // InputBufferLength,
                        NULL,   // OutputBuffer
                        0       // OutputBufferLength
                        );

    if ( Status == STATUS_PENDING) {
        // Operation must complete before return & Iosb destroyed
        Status = NtWaitForSingleObject( hNamedPipe, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {
            Status = Iosb.Status;
            }
        }

    if (NT_SUCCESS( Status )) {
        return TRUE;
        }
    else
        {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
GetNamedPipeHandleStateA(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPSTR lpUserName,
    DWORD nMaxUserNameSize
    )
/*++

Routine Description:

    Ansi thunk to GetNamedPipeHandleStateW

---*/
{
    if ( ARGUMENT_PRESENT( lpUserName ) ) {

        BOOL b;
        NTSTATUS Status;
        ANSI_STRING AnsiUserName;
        UNICODE_STRING UnicodeUserName;

        UnicodeUserName.MaximumLength = (USHORT)(nMaxUserNameSize << 1);
        UnicodeUserName.Buffer = RtlAllocateHeap(
                                        RtlProcessHeap(),MAKE_TAG( TMP_TAG ),
                                        UnicodeUserName.MaximumLength
                                        );

        AnsiUserName.Buffer = lpUserName;
        AnsiUserName.MaximumLength = (USHORT)nMaxUserNameSize;


        if ( !UnicodeUserName.Buffer ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
            }


        b = GetNamedPipeHandleStateW(
                hNamedPipe,
                lpState,
                lpCurInstances,
                lpMaxCollectionCount,
                lpCollectDataTimeout,
                UnicodeUserName.Buffer,
                UnicodeUserName.MaximumLength/2);

        if ( b ) {

            //  Set length correctly in UnicodeUserName
            RtlInitUnicodeString(
                &UnicodeUserName,
                UnicodeUserName.Buffer
                );

            Status = RtlUnicodeStringToAnsiString(
                        &AnsiUserName,
                        &UnicodeUserName,
                        FALSE
                        );

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                b = FALSE;
                }
            }

        if ( UnicodeUserName.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(),0,UnicodeUserName.Buffer);
            }

        return b;
        }
    else {
        return GetNamedPipeHandleStateW(
                hNamedPipe,
                lpState,
                lpCurInstances,
                lpMaxCollectionCount,
                lpCollectDataTimeout,
                NULL,
                0);
        }

}

BOOL
APIENTRY
GetNamedPipeHandleStateW(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    )
/*++

Routine Description:

The GetNamedPipeHandleState function retrieves information about a given
named pipe handle. The information returned by this function can vary during
the lifetime of an instance of a named pipe. The handle must be created with
the GENERIC_READ access rights.

Arguments:

    hNamedPipe - Supplies the handle of an opened named pipe.

    lpState - An optional parameter that if non-null, points to a DWORD which
        will be set with flags indicating the current state of the handle.
        The following flags may be specified:

        PIPE_NOWAIT
            Nonblocking mode is to be used for this handle.

        PIPE_READMODE_MESSAGE
            Read the pipe as a message stream. If this flag is not set, the pipe is
            read as a byte stream.

    lpCurInstances - An optional parameter that if non-null, points to a DWORD
        which will be set with the number of current pipe instances.

    lpMaxCollectionCount - If non-null, this points to a DWORD which will be
        set to the maximum number of bytes that will be collected on the clients
        machine before transmission to the server. This parameter must be NULL
        on a handle to the server end of a named pipe or when client and
        server applications are on the same machine.

    lpCollectDataTimeout - If non-null, this points to a DWORD which will be
        set to the maximum time (in milliseconds) that can pass before a
        remote named pipe transfers information over the network. This parameter
        must be NULL if the handle is for the server end of a named pipe or
        when client and server applications are on the same machine.

    lpUserName - An optional parameter on the server end of a named pipe.
        Points to an area which will be filled-in with the null-terminated
        string containing the name of the username of the client application.
        This parameter is invalid if not NULL on a handle to a client end of
        a named pipe.

    nMaxUserNameSize - Size in characters of the memory allocated at lpUserName.
        Ignored if lpUserName is NULL.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT( lpState ) ){
        FILE_PIPE_INFORMATION Common;

        Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Common,
                    sizeof(FILE_PIPE_INFORMATION),
                    FilePipeInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }

        *lpState = (Common.CompletionMode == FILE_PIPE_QUEUE_OPERATION) ?
            PIPE_WAIT : PIPE_NOWAIT;

        *lpState |= (Common.ReadMode == FILE_PIPE_BYTE_STREAM_MODE) ?
            PIPE_READMODE_BYTE : PIPE_READMODE_MESSAGE;
        }

    if (ARGUMENT_PRESENT( lpCurInstances ) ){
        FILE_PIPE_LOCAL_INFORMATION Local;

        Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Local,
                    sizeof(FILE_PIPE_LOCAL_INFORMATION),
                    FilePipeLocalInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }

        if (Local.CurrentInstances >= PIPE_UNLIMITED_INSTANCES) {
            *lpCurInstances = PIPE_UNLIMITED_INSTANCES;
            }
        else {
            *lpCurInstances = Local.CurrentInstances;
            }

        }

    if (ARGUMENT_PRESENT( lpMaxCollectionCount ) ||
        ARGUMENT_PRESENT( lpCollectDataTimeout ) ) {
        FILE_PIPE_REMOTE_INFORMATION Remote;

        Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Remote,
                    sizeof(FILE_PIPE_REMOTE_INFORMATION),
                    FilePipeRemoteInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }

        if (ARGUMENT_PRESENT( lpMaxCollectionCount ) ) {
            *lpMaxCollectionCount = Remote.MaximumCollectionCount;
            }

        if (ARGUMENT_PRESENT( lpCollectDataTimeout ) ) {
            LARGE_INTEGER TimeWorkspace;
            LARGE_INTEGER LiTemporary;

            // Convert delta NT LARGE_INTEGER to milliseconds delay

            LiTemporary.QuadPart = -Remote.CollectDataTime.QuadPart;
            TimeWorkspace = RtlExtendedLargeIntegerDivide (
                    LiTemporary,
                    10000,
                    NULL ); // Not interested in any remainder

            if ( TimeWorkspace.HighPart ) {

                //
                //  Timeout larger than we can return- but not infinity.
                //  Must have been set with the direct NT Interface.
                //

                *lpCollectDataTimeout = 0xfffffffe;   //  Maximum we can set
                }
            else {
                *lpCollectDataTimeout = TimeWorkspace.LowPart;
                }
            }
        }

    if ( ARGUMENT_PRESENT( lpUserName ) ) {
            return NpGetUserNamep(hNamedPipe, lpUserName, nMaxUserNameSize );
        }

    return TRUE;
}

BOOL
NpGetUserNamep(
    HANDLE hNamedPipe,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    )
/*++

Routine Description:

The NpGetUserNamep function retrieves user name for the client at the other
end of the named pipe indicated by the handle.

Arguments:

    hNamedPipe - Supplies the handle of an opened named pipe.

    lpUserName - Points to an area which will be filled-in with the null-terminated
        string containing the name of the username of the client application.
        This parameter is invalid if not NULL on a handle to a client end of
        a named pipe.

    nMaxUserNameSize - Size in characters of the memory allocated at lpUserName.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    HANDLE   hToken;
    NTSTATUS Status;
    DWORD Size = nMaxUserNameSize;
    BOOL res;
    HANDLE advapi32;

    REVERTTOSELF RevertToSelfp;

    GETUSERNAMEW GetUserNameWp;

    IMPERSONATENAMEDPIPECLIENT ImpersonateNamedPipeClientp;

    advapi32 = LoadLibraryW(AdvapiDllString);

    if (advapi32 == NULL ) {
        return FALSE;
        }

    RevertToSelfp = (REVERTTOSELF)GetProcAddress(advapi32,"RevertToSelf");
    if ( RevertToSelfp == NULL) {
        FreeLibrary(advapi32);
        return FALSE;
        }

    GetUserNameWp = (GETUSERNAMEW)GetProcAddress(advapi32,"GetUserNameW");
    if ( GetUserNameWp == NULL) {
        FreeLibrary(advapi32);
        return FALSE;
        }

    ImpersonateNamedPipeClientp = (IMPERSONATENAMEDPIPECLIENT)GetProcAddress(advapi32,"ImpersonateNamedPipeClient");
    if ( ImpersonateNamedPipeClientp == NULL) {
        FreeLibrary(advapi32);
        return FALSE;
        }

    //  Save whoever the thread is currently impersonating.

    Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_IMPERSONATE,
                    TRUE,
                    &hToken
                    );

    if (!(ImpersonateNamedPipeClientp)( hNamedPipe )) {
        if (NT_SUCCESS (Status)) {
            if (!CloseHandle (hToken)) {
                ASSERTMSG ("CloseHandle failed for previously opened token", 0);
            }
        }
        FreeLibrary(advapi32);
        return FALSE;
    }

    res = (GetUserNameWp)( lpUserName, &Size );

    if ( !NT_SUCCESS( Status ) ) {
        //  We were not impersonating anyone

        (RevertToSelfp)();

    } else {

        //
        //  Set thread back to whoever it was originally impersonating.
        //  An error on this API overrides any error from  GetUserNameW
        //

        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     (PVOID)&hToken,
                     (ULONG)sizeof(HANDLE)
                     );

        if (!CloseHandle (hToken)) {
            ASSERTMSG ("CloseHandle failed for previously opened token", 0);
        }
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            FreeLibrary(advapi32);
            return FALSE;
            }
        }

    FreeLibrary(advapi32);

    return res;
}

BOOL
APIENTRY
SetNamedPipeHandleState(
    HANDLE hNamedPipe,
    LPDWORD lpMode,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout
    )
/*++

Routine Description:


    The SetNamedPipeHandleState function is used to set the read
    mode and the blocking mode of a named pipe. On the client end
    of a remote named pipe this function can also control local
    buffering. The handle must be created with the GENERIC_WRITE
    access rights.

Arguments:

    hNamedPipe - Supplies a handle to a named pipe.

    lpMode - If non-null, this points to a DWORD which supplies the new
        mode. The mode is a combination of a read-mode flag and a wait flag.
        The following values may be used:

    PIPE_READMODE_BYTE
        Read pipe as a byte stream.

    PIPE_READMODE_MESSAGE
        Read pipe as a message stream.

    PIPE_WAIT
        Blocking mode is to be used for this handle.

    PIPE_NOWAIT
        Nonblocking mode is to be used for this handle.

    lpMaxCollectionCount - If non-null, this points to
        a DWORD which supplies the maximum number of
        bytes that will be collected on the client machine before
        transmission to the server. This parameter must be NULL on
        a handle to the server end of a named pipe or when client
        and server applications are on the same machine. This parameter
        is ignored if the client specified write through
        when the handle was created.

    lpCollectDataTimeout - If non-null, this points to a DWORD which
        supplies the maximum time (in milliseconds) that can pass before
        a remote named pipe transfers information over the network. This
        parameter must be NULL if the handle is for the server end of a
        named pipe or when client and server applications are on the same
        machine. This parameter is ignored if the client specified write
        through when the handle was created.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT( lpMode ) ){
        FILE_PIPE_INFORMATION Common;

        if (*lpMode & INVALID_PIPE_MODE_BITS) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        Common.ReadMode = ( *lpMode & PIPE_READMODE_MESSAGE ) ?
            FILE_PIPE_MESSAGE_MODE: FILE_PIPE_BYTE_STREAM_MODE;

        Common.CompletionMode = ( *lpMode & PIPE_NOWAIT ) ?
            FILE_PIPE_COMPLETE_OPERATION : FILE_PIPE_QUEUE_OPERATION;

        Status = NtSetInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Common,
                    sizeof(FILE_PIPE_INFORMATION),
                    FilePipeInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }

    if ( ARGUMENT_PRESENT( lpMaxCollectionCount ) ||
         ARGUMENT_PRESENT( lpCollectDataTimeout ) ){
        FILE_PIPE_REMOTE_INFORMATION Remote;

        if ( ( lpMaxCollectionCount == NULL ) ||
             ( lpCollectDataTimeout == NULL ) ){

            //
            // User is setting only one of the two parameters so read
            // the other value. There is a small window where another
            // thread using the same handle could set the other value.
            // in this case the setting would be lost.
            //

            Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Remote,
                    sizeof(FILE_PIPE_REMOTE_INFORMATION),
                    FilePipeRemoteInformation );

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }

        if (ARGUMENT_PRESENT( lpMaxCollectionCount ) ) {
            Remote.MaximumCollectionCount = *lpMaxCollectionCount;
            }

        if (ARGUMENT_PRESENT( lpCollectDataTimeout ) ) {

            //
            //  Convert from milliseconds to an Nt delta time.
            //

            Remote.CollectDataTime.QuadPart =
                        - (LONGLONG)UInt32x32To64( 10 * 1000, *lpCollectDataTimeout );
            }

        Status = NtSetInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Remote,
                    sizeof(FILE_PIPE_REMOTE_INFORMATION),
                    FilePipeRemoteInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }


    return TRUE;
}

BOOL
APIENTRY
GetNamedPipeInfo(
    HANDLE hNamedPipe,
    LPDWORD lpFlags,
    LPDWORD lpOutBufferSize,
    LPDWORD lpInBufferSize,
    LPDWORD lpMaxInstances
    )
/*++

Routine Description:

    The GetNamedPipeInfo function retrieves information about a named
    pipe. The information returned by this API is preserved the lifetime
    of an instance of a named pipe. The handle must be created with the
    GENERIC_READ access rights.

Arguments:
    hNamedPipe - Supplies a handle to a named pipe.

    lpFlags - An optional parameter that if non-null, points to a DWORD
        which will be set with flags indicating the type of named pipe and handle.

        PIPE_END_SERVER
            The handle is the server end of a named pipe.

        PIPE_TYPE_MESSAGE
            The pipe is a message-stream pipe. If this flag is not set, the pipe is
            a byte-stream pipe.

    lpOutBufferSize - An optional parameter that if non-null, points to a
        DWORD which will be set with the size (in bytes) of the buffer for
        outgoing data. A return value of zero indicates the buffer is allocated
        as needed.

    lpInBufferSize - An optional parameter that if non-null, points to a DWORD
        which will be set with the size (in bytes) of the buffer for incoming
        data. A return
        value of zero indicates the buffer is allocated as needed.

    lpMaxInstances - An optional parameter that if non-null, points to a
        DWORD which will be set with the maximum number of pipe instances
        that can be created. Besides various numeric values, a special value
        may be returned for this.

        PIPE_UNLIMITED_INSTANCES
            Unlimited instances of the pipe can be created. This is an
            indicator that the maximum is requested; the value of the
            equate may be higher or lower than the actual implementation's limit,
            which may vary over time.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    FILE_PIPE_LOCAL_INFORMATION Local;

    Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Local,
                    sizeof(FILE_PIPE_LOCAL_INFORMATION),
                    FilePipeLocalInformation );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    if (ARGUMENT_PRESENT( lpFlags ) ) {
        *lpFlags = (Local.NamedPipeEnd == FILE_PIPE_CLIENT_END) ?
            PIPE_CLIENT_END : PIPE_SERVER_END;
        *lpFlags |= (Local.NamedPipeType == FILE_PIPE_BYTE_STREAM_TYPE) ?
            PIPE_TYPE_BYTE : PIPE_TYPE_MESSAGE;
        }

    if (ARGUMENT_PRESENT( lpOutBufferSize ) ) {
        *lpOutBufferSize = Local.OutboundQuota;
        }

    if (ARGUMENT_PRESENT( lpInBufferSize ) ) {
        *lpInBufferSize = Local.InboundQuota;
        }

    if (ARGUMENT_PRESENT( lpMaxInstances ) ) {
        if (Local.MaximumInstances >= PIPE_UNLIMITED_INSTANCES) {
            *lpMaxInstances = PIPE_UNLIMITED_INSTANCES;
            }
        else {
            *lpMaxInstances = Local.MaximumInstances;
            }
        }


    return TRUE;
}


BOOL
APIENTRY
PeekNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpBuffer,
    DWORD nBufferSize,
    LPDWORD lpBytesRead,
    LPDWORD lpTotalBytesAvail,
    LPDWORD lpBytesLeftThisMessage
    )
/*++

Routine Description:

    The PeekNamedPipe function copies a named pipe's data into a buffer for
    preview without removing it. The results of a PeekNamedPipe are similar to
    a ReadFile on the pipe except more information is returned, the function
    never blocks and if the pipe handle is reading in message mode, a partial
    message can be returned.

    A partial message peek'd on a message mode pipe will return TRUE.

    It is not an error if all of the pointers passed to this function are
    null. However, there is no reason for calling it this way.

    The NT peek call has the received data immediately after the state
    information so this routine needs to allocate an intermediate buffer
    large enough for the state information plus data.

Arguments:

    hNamedPipe - Supplies a handle to a named pipe.

    lpBuffer - If non-null, pointer to buffer to read data into.

    nBufferSize - Size of input buffer, in bytes. (Ignored if lpBuffer
        is null.)

    lpBytesRead - If non-null, this points to a DWORD which will be set
        with the number of bytes actually read.

    lpTotalBytesAvail - If non-null, this points to a DWORD which receives
        a value giving the number of bytes that were available to be read.

    lpBytesLeftThisMessage - If non-null, this points to a DWORD which
        will be set to the number of bytes left in this message. (This will
        be zero for a byte-stream pipe.)

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;
    PFILE_PIPE_PEEK_BUFFER PeekBuffer;
    DWORD IOLength;

    // Allocate enough for the users data and FILE_PIPE_PEEK_BUFFER

    IOLength = nBufferSize + FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]);
    PeekBuffer = RtlAllocateHeap(RtlProcessHeap(),MAKE_TAG( TMP_TAG ), IOLength);
    if (PeekBuffer == NULL) {
        BaseSetLastNTError (STATUS_INSUFFICIENT_RESOURCES);
        return FALSE;
    }

    try {

        Status = NtFsControlFile(hNamedPipe,
                    NULL,
                    NULL,           // APC routine
                    NULL,           // APC Context
                    &Iosb,          // I/O Status block
                    FSCTL_PIPE_PEEK,// IoControlCode
                    NULL,           // Buffer for data to the FS
                    0,              // Length.
                    PeekBuffer,     // OutputBuffer for data from the FS
                    IOLength        // OutputBuffer Length
                    );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hNamedPipe, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        //
        //  Buffer overflow simply means that lpBytesLeftThisMessage != 0
        //

        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            Status = STATUS_SUCCESS;
        }

        //
        //  Peek is complete, package up data for caller ensuring that
        //  the PeekBuffer is deleted even if an invalid pointer was given.
        //

        if ( NT_SUCCESS(Status)) {

            try {

                if ( ARGUMENT_PRESENT( lpTotalBytesAvail ) ) {
                    *lpTotalBytesAvail = PeekBuffer->ReadDataAvailable;
                    }

                if ( ARGUMENT_PRESENT( lpBytesRead ) ) {
                    *lpBytesRead = (ULONG)(Iosb.Information - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]));
                    }

                if ( ARGUMENT_PRESENT( lpBytesLeftThisMessage ) ) {
                    *lpBytesLeftThisMessage =
                        PeekBuffer->MessageLength -
                        (ULONG)(Iosb.Information - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]));
                    }

                if ( ARGUMENT_PRESENT( lpBuffer ) ) {
                    RtlCopyMemory(
                        lpBuffer,
                        PeekBuffer->Data,
                        Iosb.Information - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]));
                    }
                }
            except (EXCEPTION_EXECUTE_HANDLER) {
                Status = STATUS_ACCESS_VIOLATION;
                }
            }
        }

    finally {

        if ( PeekBuffer != NULL ) {
            RtlFreeHeap(RtlProcessHeap(),0,PeekBuffer);
            }
        }

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
TransactNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:

    The TransactNamedPipe function writes data to and reads data from a named
    pipe. This function fails if the named pipe contains any unread data or if
    the named pipe is not in message mode. A named pipe's blocking state has no
    effect on the TransactNamedPipe function. This API does not complete until
    data is written into the InBuffer buffer. The lpOverlapped parameter is
    available to allow an application to continue processing while the operation
    takes place.

Arguments:
    hNamedPipe - Supplies a handle to a named pipe.

    lpInBuffer - Supplies the buffer containing the data that is written to
        the pipe.

    nInBufferSize - Supplies the size (in bytes) of the output buffer.

    lpOutBuffer - Supplies the buffer that receives the data read from the pipe.

    nOutBufferSize - Supplies the size (in bytes) of the input buffer.

    lpBytesRead - Points to a DWORD that receives the number of bytes actually
        read from the pipe.

    lpOverlapped - An optional parameter that supplies an overlap structure to
        be used with the request. If NULL or the handle was created without
        FILE_FLAG_OVERLAPPED then the TransactNamedPipe will not return until
        the operation completes.

        When lpOverlapped is supplied and FILE_FLAG_OVERLAPPED was specified
        when the handle was created, TransactNamedPipeFile may return
        ERROR_IO_PENDING to allow the caller to continue processing while the
        operation completes. The event (or File handle if hEvent == NULL) will
        be set to the not signalled state before ERROR_IO_PENDING is
        returned. The event will be set to the signalled state upon completion
        of the request. GetOverlappedResult is used to determine the result
        when ERROR_IO_PENDING is returned.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    NTSTATUS Status;

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        Status = NtFsControlFile(hNamedPipe,
                    lpOverlapped->hEvent,
                    NULL,           // APC routine
                    (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                    (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                    FSCTL_PIPE_TRANSCEIVE,// IoControlCode
                    lpInBuffer,    // Buffer for data to the FS
                    nInBufferSize,
                    lpOutBuffer,     // OutputBuffer for data from the FS
                    nOutBufferSize   // OutputBuffer Length
                    );

        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpBytesRead) ) {
                try {
                    *lpBytesRead = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpBytesRead = 0;
                    }
                }
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                if ( ARGUMENT_PRESENT(lpBytesRead) ) {
                    try {
                        *lpBytesRead = (DWORD)lpOverlapped->InternalHigh;
                        }
                    except(EXCEPTION_EXECUTE_HANDLER) {
                        *lpBytesRead = 0;
                        }
                    }
            }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        IO_STATUS_BLOCK Iosb;

        Status = NtFsControlFile(hNamedPipe,
                    NULL,
                    NULL,           // APC routine
                    NULL,           // APC Context
                    &Iosb,
                    FSCTL_PIPE_TRANSCEIVE,// IoControlCode
                    lpInBuffer,    // Buffer for data to the FS
                    nInBufferSize,
                    lpOutBuffer,     // OutputBuffer for data from the FS
                    nOutBufferSize   // OutputBuffer Length
                    );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & Iosb destroyed
            Status = NtWaitForSingleObject( hNamedPipe, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpBytesRead = (DWORD)Iosb.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpBytesRead = (DWORD)Iosb.Information;
            }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
APIENTRY
CallNamedPipeA(
    LPCSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    )
/*++

    ANSI thunk to CallNamedPipeW

--*/
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpNamedPipeName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }

    return ( CallNamedPipeW( (LPCWSTR)Unicode->Buffer,
                lpInBuffer,
                nInBufferSize,
                lpOutBuffer,
                nOutBufferSize,
                lpBytesRead,
                nTimeOut)
           );
}


BOOL
APIENTRY
CallNamedPipeW(
    LPCWSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    )
/*++

Routine Description:

    CallNamedPipe is equivalent to a series of calls to CreateFile, perhaps
    WaitNamedPipe (if CreateFile can't open the pipe immediately),
    SetNamedPipeHandleState, TransactNamedPipe, and CloseFile. Refer to
    the documentation for those APIs for more information.

Arguments:

    lpNamedPipeName - Supplies the name of the named pipe.

    lpInBuffer - Supplies the buffer containing the data that is written to
        the pipe.

    nInBufferSize - Supplies the size (in bytes) of the output buffer.

    lpOutBuffer - Supplies the buffer that receives the data read from the pipe.

    nOutBufferSize - Supplies the size (in bytes) of the input buffer.

    lpBytesRead - Points to a DWORD that receives the number of bytes actually
        read from the pipe.

    nTimeOut - Gives a value (in milliseconds) that is the amount of time
        this function should wait for the pipe to become available. (Note
        that the function may take longer than that to execute, due to
        various factors.)

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    HANDLE Pipe;
    BOOL FirstChance = TRUE; //  Allow only one chance at WaitNamedPipe
    BOOL Result;

    while ( 1 ) {

        Pipe = CreateFileW(lpNamedPipeName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,       // Security Attributes
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

        if ( Pipe != INVALID_HANDLE_VALUE ) {
            break;  //  Created a handle
            }

        if ( FirstChance == FALSE ) {
           //  Already called WaitNamedPipe once so give up.
           return FALSE;
        }

        WaitNamedPipeW(lpNamedPipeName, nTimeOut);

        FirstChance = FALSE;

        }


    try {
        DWORD ReadMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;

        //  Default open is readmode byte stream- change to message mode.
        Result = SetNamedPipeHandleState( Pipe, &ReadMode, NULL, NULL);

        if ( Result == TRUE ) {
            Result = TransactNamedPipe(
                Pipe,
                lpInBuffer,
                nInBufferSize,
                lpOutBuffer,
                nOutBufferSize,
                lpBytesRead,
                NULL);
            }
        }
    finally {
        CloseHandle( Pipe );
        }

    return Result;
}

BOOL
APIENTRY
WaitNamedPipeA(
    LPCSTR lpNamedPipeName,
    DWORD nTimeOut
    )
/*++

    Ansi thunk to WaitNamedPipeW

--*/
{
    UNICODE_STRING UnicodeString;
    BOOL b;

    if (!Basep8BitStringToDynamicUnicodeString( &UnicodeString, lpNamedPipeName )) {
        return FALSE;
    }

    b = WaitNamedPipeW( UnicodeString.Buffer, nTimeOut );

    RtlFreeUnicodeString(&UnicodeString);

    return b;

}


BOOL
APIENTRY
WaitNamedPipeW(
    LPCWSTR lpNamedPipeName,
    DWORD nTimeOut
    )
/*++

Routine Description:

    The WaitNamedPipe function waits for a named pipe to become available.

Arguments:

    lpNamedPipeName - Supplies the name of the named pipe.

    nTimeOut - Gives a value (in milliseconds) that is the amount of time
        this function should wait for the pipe to become available. (Note
        that the function may take longer than that to execute, due to
        various factors.)

    nTimeOut Special Values:

        NMPWAIT_WAIT_FOREVER
            No timeout.

        NMPWAIT_USE_DEFAULT_WAIT
            Use default timeout set in call to CreateNamedPipe.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    RTL_PATH_TYPE PathType;
    ULONG WaitPipeLength;
    PFILE_PIPE_WAIT_FOR_BUFFER WaitPipe;
    PWSTR FreeBuffer;
    UNICODE_STRING FileSystem;
    UNICODE_STRING PipeName;
    UNICODE_STRING OriginalPipeName;
    UNICODE_STRING ValidUnicodePrefix;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    LPWSTR Pwc;
    ULONG Index;

    //
    //  Open a handle either to the redirector or the NPFS depending on
    //  the start of the pipe name. Split lpNamedPipeName into two
    //  halves as follows:
    //      \\.\pipe\pipename       \\.\pipe\ and pipename
    //      \\server\pipe\pipename  \\ and server\pipe\pipename
    //

    if (!RtlCreateUnicodeString( &OriginalPipeName, lpNamedPipeName)) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
        }

    //
    //  Change all the forward slashes into backward slashes.
    //

    for ( Index =0; Index < (OriginalPipeName.Length/sizeof(WCHAR)); Index++ ) {
        if (OriginalPipeName.Buffer[Index] == L'/') {
            OriginalPipeName.Buffer[Index] = L'\\';
            }
        }

    PipeName = OriginalPipeName;

    PathType = RtlDetermineDosPathNameType_U(lpNamedPipeName);

    FreeBuffer = NULL;

    switch ( PathType ) {
    case RtlPathTypeLocalDevice:

            //  Name should be of the form \\.\pipe\pipename (IgnoreCase)

            RtlInitUnicodeString( &ValidUnicodePrefix, DOS_LOCAL_PIPE_PREFIX);

            if (RtlPrefixString((PSTRING)&ValidUnicodePrefix,
                    (PSTRING)&PipeName,
                    TRUE) == FALSE) {
                RtlFreeUnicodeString(&OriginalPipeName);
                BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
                return FALSE;
                }

            //  Skip first 9 characters "\\.\pipe\"
            PipeName.Buffer+=9;
            PipeName.Length-=9*sizeof(WCHAR);

            RtlInitUnicodeString( &FileSystem, DOS_LOCAL_PIPE);

            break;

        case RtlPathTypeUncAbsolute:
            //  Name is of the form \\server\pipe\pipename

            //  Find the pipe name.

            for ( Pwc = &PipeName.Buffer[2]; *Pwc != 0; Pwc++) {
                if ( *Pwc == L'\\') {
                    //  Found backslash after servername
                    break;
                    }
                }

            if ( (*Pwc != 0) &&
                 ( _wcsnicmp( Pwc + 1, L"pipe\\", 5 ) == 0 ) ) {

                // Temporarily, break this up into 2 strings
                //    string1 = \\server\pipe
                //    string2 = the-rest

                Pwc += (sizeof (L"pipe\\") / sizeof( WCHAR ) ) - 1;

            } else {

                // This is not a valid remote path name.

                RtlFreeUnicodeString(&OriginalPipeName);
                BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
                return FALSE;
                }

            //  Pwc now points to the first path seperator after \\server\pipe.
            //  Attempt to open \DosDevices\Unc\Servername\Pipe.

            PipeName.Buffer = &PipeName.Buffer[2];
            PipeName.Length = (USHORT)((PCHAR)Pwc - (PCHAR)PipeName.Buffer);
            PipeName.MaximumLength = PipeName.Length;

            FileSystem.MaximumLength =
                (USHORT)sizeof( DOS_REMOTE_PIPE ) +
                PipeName.MaximumLength;

            FileSystem.Buffer = RtlAllocateHeap(
                                    RtlProcessHeap(),MAKE_TAG( TMP_TAG ),
                                    FileSystem.MaximumLength
                                    );

            if ( !FileSystem.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                RtlFreeUnicodeString(&OriginalPipeName);
                return FALSE;
                }
            FreeBuffer = FileSystem.Buffer;

            RtlCopyMemory(
                FileSystem.Buffer,
                DOS_REMOTE_PIPE,
                sizeof( DOS_REMOTE_PIPE ) - sizeof(WCHAR)
                );

            FileSystem.Length = sizeof( DOS_REMOTE_PIPE ) - sizeof(WCHAR);

            RtlAppendUnicodeStringToString( &FileSystem, &PipeName );

            // Set up pipe name, skip leading backslashes.

            RtlInitUnicodeString( &PipeName, (PWCH)Pwc + 1 );

            break;

        default:
            BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
            RtlFreeUnicodeString(&OriginalPipeName);
            return FALSE;
        }


    InitializeObjectAttributes(
        &Obja,
        &FileSystem,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if (FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
        }

    if ( !NT_SUCCESS(Status) ) {
        RtlFreeUnicodeString(&OriginalPipeName);
        BaseSetLastNTError(Status);
        return FALSE;
        }

    WaitPipeLength =
        FIELD_OFFSET(FILE_PIPE_WAIT_FOR_BUFFER, Name[0]) + PipeName.Length;
    WaitPipe = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), WaitPipeLength);
    if ( !WaitPipe ) {
        RtlFreeUnicodeString(&OriginalPipeName);
        NtClose(Handle);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return FALSE;
        }

    if ( nTimeOut == NMPWAIT_USE_DEFAULT_WAIT ) {
        WaitPipe->TimeoutSpecified = FALSE;
        }
    else {
        if ( nTimeOut == NMPWAIT_WAIT_FOREVER ) {
            WaitPipe->Timeout.LowPart = 0;
            WaitPipe->Timeout.HighPart =0x80000000;
            }
        else {
            //
            //  Convert from milliseconds to an Nt delta time.
            //

            WaitPipe->Timeout.QuadPart =
                                - (LONGLONG)UInt32x32To64( 10 * 1000, nTimeOut );
            }
        WaitPipe->TimeoutSpecified = TRUE;
        }

    WaitPipe->NameLength = PipeName.Length;

    RtlCopyMemory(
        WaitPipe->Name,
        PipeName.Buffer,
        PipeName.Length
        );

    RtlFreeUnicodeString(&OriginalPipeName);

    Status = NtFsControlFile(Handle,
                        NULL,
                        NULL,           // APC routine
                        NULL,           // APC Context
                        &Iosb,
                        FSCTL_PIPE_WAIT,// IoControlCode
                        WaitPipe,       // Buffer for data to the FS
                        WaitPipeLength,
                        NULL,           // OutputBuffer for data from the FS
                        0               // OutputBuffer Length
                        );

    RtlFreeHeap(RtlProcessHeap(),0,WaitPipe);

    NtClose(Handle);

    if (NT_SUCCESS( Status ) ) {
        return TRUE;
        }
    else
        {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\numa.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    numa.c

Abstract:

    This module implements Win32 Non Uniform Memory Architecture
    information APIs.

Author:

    Peter Johnston (peterj) 21-Sep-2000

Revision History:

--*/

#include "basedll.h"

BOOL
WINAPI
GetNumaHighestNodeNumber(
    PULONG HighestNodeNumber
    )

/*++

Routine Description:

    Return the (current) highest numbered node in the system.

Arguments:

    HighestNodeNumber   Supplies a pointer to receive the number of
                        last (highest) node in the system.

Return Value:

    TRUE unless something impossible happened.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSize;
    ULONGLONG Information;
    PSYSTEM_NUMA_INFORMATION Numa;

    Numa = (PSYSTEM_NUMA_INFORMATION)&Information;

    Status = NtQuerySystemInformation(SystemNumaProcessorMap,
                                      Numa,
                                      sizeof(Information),
                                      &ReturnedSize);

    if (!NT_SUCCESS(Status)) {

        //
        // This can't possibly happen.   Attempt to handle it
        // gracefully.
        //

        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (ReturnedSize < sizeof(ULONG)) {

        //
        // Nor can this.
        //

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Return the number of nodes in the system.
    //

    *HighestNodeNumber = Numa->HighestNodeNumber;
    return TRUE;
}

BOOL
WINAPI
GetNumaProcessorNode(
    UCHAR Processor,
    PUCHAR NodeNumber
    )

/*++

Routine Description:

    Return the Node number for a given processor.

Arguments:

    Processor       Supplies the processor number.
    NodeNumber      Supplies a pointer to the UCHAR to receive the
                    node number this processor belongs to.

Return Value:

    Returns the Node number for the node this processor belongs to.
    Returns 0xFF if the processor doesn't exist.

--*/

{
    ULONGLONG Mask;
    NTSTATUS Status;
    ULONG ReturnedSize;
    UCHAR Node;
    SYSTEM_NUMA_INFORMATION Map;

    //
    // If the requested processor number is not reasonable, return
    // error value.
    //

    if (Processor >= MAXIMUM_PROCESSORS) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Get the Node -> Processor Affinity map from the system.
    //

    Status = NtQuerySystemInformation(SystemNumaProcessorMap,
                                      &Map,
                                      sizeof(Map),
                                      &ReturnedSize);

    if (!NT_SUCCESS(Status)) {

        //
        // This can't happen,... but try to stay sane if possible.
        //

        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Look thru the nodes returned for the node in which the
    // requested processor's affinity is non-zero.
    //

    Mask = 1 << Processor;

    for (Node = 0; Node <= Map.HighestNodeNumber; Node++) {
        if ((Map.ActiveProcessorsAffinityMask[Node] & Mask) != 0) {
            *NodeNumber = Node;
            return TRUE;
        }
    }

    //
    // Didn't find this processor in any node, return error value.
    //

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
WINAPI
GetNumaNodeProcessorMask(
    UCHAR Node,
    PULONGLONG ProcessorMask
    )

/*++

Routine Description:

    This routine is used to obtain the bitmask of processors for a
    given node.

Arguments:

    Node            Supplies the Node number for which the set of
                    processors is returned.
    ProcessorMask Pointer to a ULONGLONG to receivethe bitmask of 
                    processors on this node.

Return Value:

    TRUE is the Node number was reasonable, FALSE otherwise.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSize;
    SYSTEM_NUMA_INFORMATION Map;

    //
    // Get the node -> processor mask table from the system.
    //

    Status = NtQuerySystemInformation(SystemNumaProcessorMap,
                                      &Map,
                                      sizeof(Map),
                                      &ReturnedSize);
    if (!NT_SUCCESS(Status)) {

        //
        // This can't possibly have happened.
        //

        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // If the requested node doesn't exist, return a zero processor
    // mask.
    //

    if (Node > Map.HighestNodeNumber) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Return the processor mask for the requested node.
    //

    *ProcessorMask = Map.ActiveProcessorsAffinityMask[Node];
    return TRUE;
}

BOOL
WINAPI
GetNumaProcessorMap(
    PSYSTEM_NUMA_INFORMATION Map,
    ULONG Length,
    PULONG ReturnedLength
    )


/*++

Routine Description:

    Query the system for the NUMA processor map.

Arguments:

    Map             Supplies a pointer to a stucture into which the
                    Node to Processor layout is copied.
    Length          Size of Map (ie max size to copy).
    ReturnedLength  Number of bytes returned in Map.

Return Value:

    TRUE unless something bad happened, FALSE otherwise.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSize;

    RtlZeroMemory(Map, Length);

    //
    // Fill in the user's buffer with the system Node -> Processor map.
    //

    Status = NtQuerySystemInformation(SystemNumaProcessorMap,
                                      Map,
                                      Length,
                                      ReturnedLength);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
GetNumaAvailableMemory(
    PSYSTEM_NUMA_INFORMATION Memory,
    ULONG Length,
    PULONG ReturnedLength
    )

/*++

Routine Description:

    Query the system for the NUMA processor map.

Arguments:

    Memory          Supplies a pointer to a stucture into which the
                    per node available memory data is copied.
    Length          Size of data (ie max size to copy).
    ReturnedLength  Nomber of bytes returned in Memory.

Return Value:

    Returns the length of the data returned.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSize;

    RtlZeroMemory(Memory, Length);

    //
    // Fill in the user's buffer with the per node available
    // memory table.
    //

    Status = NtQuerySystemInformation(SystemNumaAvailableMemory,
                                      Memory,
                                      Length,
                                      ReturnedLength);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
GetNumaAvailableMemoryNode(
    UCHAR Node,
    PULONGLONG AvailableBytes
    )


/*++

Routine Description:

    This routine returns the (aproximate) amount of memory available
    on a given node.

Arguments:

    Node        Node number for which available memory count is
                needed.
    AvailableBytes  Supplies a pointer to a ULONGLONG in which the
                    number of bytes of available memory will be 
                    returned.

Return Value:

    TRUE is this call was successful, FALSE otherwise.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSize;
    SYSTEM_NUMA_INFORMATION Memory;

    //
    // Get the per node available memory table from the system.
    //

    Status = NtQuerySystemInformation(SystemNumaAvailableMemory,
                                      &Memory,
                                      sizeof(Memory),
                                      &ReturnedSize);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // If the requested node doesn't exist, it doesn't have any
    // available memory either.
    //

    if (Node > Memory.HighestNodeNumber) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Return the amount of available memory on the requested node.
    //

    *AvailableBytes = Memory.AvailableMemory[Node];
    return TRUE;
}

//
// NumaVirtualQueryNode
//
// SORT_SIZE defines the number of elements to be sorted before merging.
//

#define SORT_SIZE   64

typedef struct {
    PMEMORY_WORKING_SET_BLOCK Low;
    PMEMORY_WORKING_SET_BLOCK Limit;
} MERGELIST, *PMERGELIST;


static
VOID
numaSortWSInfo(
    PMERGELIST List
    )
{
    //
    // A simple bubble sort for small data sets.
    //

    PMEMORY_WORKING_SET_BLOCK High;
    PMEMORY_WORKING_SET_BLOCK Low;
    MEMORY_WORKING_SET_BLOCK Temp;

    for (Low = List->Low; Low < List->Limit; Low++) {
        for (High = Low + 1; High <= List->Limit; High++) {
            if (Low->VirtualPage > High->VirtualPage) {
                Temp = *High;
                *High = *Low;
                *Low = Temp;
            }
        }
    }
}


ULONGLONG
WINAPI
NumaVirtualQueryNode(
    IN  ULONG       NumberOfRanges,
    IN  PULONG_PTR  RangeList,
    OUT PULONG_PTR  VirtualPageAndNode,
    IN  SIZE_T      MaximumOutputLength
    )

/*++

Routine Description:

    Determine the nodes for pages in the ranges described by the input
    RangeList.

Arguments:

    NumberOfRanges      Supplies the number of ranges in the range list.
    RangeList           Points to a list of ULONG_PTRs which, in pairs,
                        describe the lower and upper bounds of the pages
                        for which node information is required.
    VirtualPageAndNode  Points to the result buffer.   The result buffer
                        will be filled with one entry for each page that
                        is found to fall within the ranges specified in
                        RangeList.
    MaximumOutputLength Defines the maximum amount of data (in bytes) to
                        be places in the result set.

Return Value:

    Returns the number of entries in the result set.

--*/

{
    ULONGLONG PagesReturned = 0;
    PULONG_PTR Range;
    ULONG i;
    ULONG j;
    NTSTATUS Status;
    MEMORY_WORKING_SET_INFORMATION Info0;
    HANDLE Process = NtCurrentProcess();
    PMEMORY_WORKING_SET_INFORMATION Info = &Info0;
    SIZE_T ReturnedLength;
    ULONG_PTR NumberOfLists;
    PMEMORY_WORKING_SET_INFORMATION MergedList;
    PMERGELIST MergeList;
    PMERGELIST List;
    MERGELIST List0;

    typedef union {
        ULONG_PTR Raw;
        MEMORY_WORKING_SET_BLOCK WsBlock;
    } RAWWSBLOCK, *PRAWWSBLOCK;
    
    RAWWSBLOCK Result;
    RAWWSBLOCK MaxInterest;
    RAWWSBLOCK MinInterest;
    RAWWSBLOCK MaskLow;
    RAWWSBLOCK MaskHigh;

    SetLastError(NO_ERROR);

    //
    // Determine the max and min pages of interest.
    //

    Range = RangeList;
    MinInterest.Raw = (ULONG_PTR)-1;
    MaxInterest.Raw = 0;
    for (i = 0; i < NumberOfRanges; i++) {
        if (*Range < MinInterest.Raw) {
            MinInterest.Raw = *Range;
        }
        Range++;
        if (*Range > MaxInterest.Raw) {
            MaxInterest.Raw = *Range;
        }
        Range++;
    }

    //
    // Trim out any garbage.
    //

    Result.Raw = 0;
    Result.WsBlock.VirtualPage = MinInterest.WsBlock.VirtualPage;
    MinInterest = Result;
    Result.WsBlock.VirtualPage = MaxInterest.WsBlock.VirtualPage;
    MaxInterest = Result;

    if (MinInterest.Raw > MaxInterest.Raw) {
        return 0;
    }

    //
    // Ask for the working set once, with only enough space to get
    // the number of entries in the working set list.
    //

    Status = NtQueryVirtualMemory(Process,
                                  NULL,
                                  MemoryWorkingSetInformation,
                                  &Info0,
                                  sizeof(Info0),
                                  &ReturnedLength);

    if (Status != STATUS_INFO_LENGTH_MISMATCH) {
        BaseSetLastNTError(Status);
        return 0;
    }

    if (Info->NumberOfEntries == 0) {
        return 0;
    }

    //
    // Bump the entry count by some margin in case a few pages get added
    // before we ask again.
    //

    i = sizeof(Info0) + (Info->NumberOfEntries + 100) *
                         sizeof(MEMORY_WORKING_SET_BLOCK);

    //
    // Get memory to read the process's working set information into.
    //

    Info = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), i);
    if (!Info) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    Status = NtQueryVirtualMemory(Process,
                                  NULL,
                                  MemoryWorkingSetInformation,
                                  Info,
                                  i,
                                  &ReturnedLength);
    if (!NT_SUCCESS(Status)) {
        RtlFreeHeap(RtlProcessHeap(), 0, Info);
        BaseSetLastNTError(Status);
        return 0;
    }

    //
    // Make the comparisons easier.   Or, more specifically, make
    // the comparisons ignore any page offsets in the Range info.
    //

    MaskLow.Raw = (ULONG_PTR)-1;
    MaskHigh.Raw = 0;

    //
    // For each entry returned, check to see if the entry is within
    // a requested range.
    //
    // We assume the number of working set entries will exceed the
    // number of ranges requested which means it is more efficient
    // to make one pass over the working set information.
    //

    for (i = 0; i < Info->NumberOfEntries; i++) {

        MaskHigh.WsBlock.VirtualPage = Info->WorkingSetInfo[i].VirtualPage;
        if ((MaskHigh.Raw < MinInterest.Raw) ||
            (MaskHigh.Raw > MaxInterest.Raw)) {

            //
            // This page is not interesting, skip it.
            //

            continue;
        }
        MaskLow.WsBlock.VirtualPage = MaskHigh.WsBlock.VirtualPage;

        Range = RangeList;
        for (j = 0; j < NumberOfRanges; j++) {
            if ((MaskLow.Raw >= *Range) &&
                (MaskHigh.Raw <= *(Range+1))) {

                //
                // Match.
                //
                // Coalesce interesting entries towards the beginning
                // os the WSInfo array.
                //

                Info->WorkingSetInfo[PagesReturned] = Info->WorkingSetInfo[i];
                PagesReturned++;
                break;
            }
            Range += 2;
        }
    }

    //
    // The pages of interest are now collected at the front of the
    // set of data returned by the system.   Sort this and merge the
    // results into the caller's buffer.
    //

    Info->NumberOfEntries = (ULONG)PagesReturned;

    //
    // Divide the sort into a number of smaller sort lists.
    //

    NumberOfLists = (Info->NumberOfEntries / SORT_SIZE) + 1;

    //
    // Allocate memory for list management of the sorts (for the merge).
    //

    MergeList = RtlAllocateHeap(RtlProcessHeap(),
                                MAKE_TAG(TMP_TAG),
                                NumberOfLists * sizeof(MERGELIST));

    if (!MergeList) {

        //
        // Couldn't allocate memory for merge copy, do bubble sort in
        // place.   Slow but will work.
        //

        List0.Low = &Info->WorkingSetInfo[0];
        List0.Limit = &Info->WorkingSetInfo[Info->NumberOfEntries - 1];
        numaSortWSInfo(&List0);
        NumberOfLists = 1;
        MergeList = &List0;
    } else {


        //
        // Sort each of the smaller lists.
        //

        List = MergeList;
        for (i = 0; i < Info->NumberOfEntries; i += SORT_SIZE) {
            ULONG_PTR j = i + SORT_SIZE - 1;
            if (j >= Info->NumberOfEntries) {
                j = Info->NumberOfEntries - 1;
            }
            List->Low = &Info->WorkingSetInfo[i];
            List->Limit = &Info->WorkingSetInfo[j];
            numaSortWSInfo(List);
            List++;
        }
    }

    //
    // Trim the result set to what will fit in the structure supplied
    // by the caller.
    //

    if ((PagesReturned * sizeof(ULONG_PTR)) > MaximumOutputLength) {
        PagesReturned = MaximumOutputLength / sizeof(ULONG_PTR);
    }

    //
    // Merge each list into the result array.
    //

    for (i = 0; i < PagesReturned; i++) {

        //
        // Look at each of the lists and choose the lowest element.
        //

        PMERGELIST NewLow = NULL;
        for (j = 0; j < NumberOfLists; j++) {

            //
            // If this list has been exhausted, skip it.
            //

            if (MergeList[j].Low > MergeList[j].Limit) {
                continue;
            }

            //
            // If no list has been selected as the new low, OR,
            // if this list has a lower element than the currently
            // selected low element, select it.
            //

            if ((NewLow == NULL) ||
                (MergeList[j].Low->VirtualPage < NewLow->Low->VirtualPage)) {
                NewLow = &MergeList[j];
            }
        }

        //
        // Take the selected low element and place it on the output list
        // then increment the low pointer for the list it was removed from.
        //

        Result.Raw = 0;
        Result.WsBlock.VirtualPage = NewLow->Low->VirtualPage;
        Result.Raw |= NewLow->Low->Node;
        *VirtualPageAndNode++ = Result.Raw;
        NewLow->Low++;
    }

    //
    // Free allocated memory and return the number of pages in the 
    // result set.
    //

    if (MergeList != &List0) {
        RtlFreeHeap(RtlProcessHeap(), 0, MergeList);
    }
    RtlFreeHeap(RtlProcessHeap(), 0, Info);
    return PagesReturned;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\module.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    module.c

Abstract:

    This module contains the Win32 Module Management APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop
#include <winsafer.h>
#include <winuserp.h>
#include <sxstypes.h>

PVOID
BasepMapModuleHandle(
    IN HMODULE hModule OPTIONAL,
    IN BOOLEAN bResourcesOnly
    )
{
    if (ARGUMENT_PRESENT( hModule )) {
        if (LDR_IS_DATAFILE(hModule)) {
            if (bResourcesOnly) {
                return( (PVOID)hModule );
                }
            else {
                return( NULL );
                }
            }
        else {
            return( (PVOID)hModule );
            }
        }
    else {
        return( (PVOID)NtCurrentPeb()->ImageBaseAddress);
        }
}

HMODULE
LoadLibraryA(
    LPCSTR lpLibFileName
    )
{
    //
    // The specification for twain_32.dll says that this
    // DLL is supposed to be installed in %windir%. Some
    // apps put a twain_32.dll in the system32 directory
    // and all the apps using this dll will blow up.
    //

    if (ARGUMENT_PRESENT(lpLibFileName) &&
        _strcmpi(lpLibFileName, "twain_32.dll") == 0) {

        LPSTR pszBuffer;

        pszBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG( TMP_TAG ),
                                    MAX_PATH * sizeof(char));

        if (pszBuffer != NULL) {

            HMODULE hMod;

            GetWindowsDirectoryA(pszBuffer, MAX_PATH);

            strcat(pszBuffer, "\\twain_32.dll");

            hMod = LoadLibraryA(pszBuffer);

            RtlFreeHeap(RtlProcessHeap(), 0, pszBuffer);

            if (hMod != NULL) {
                return hMod;
            }
        }
    }

    return LoadLibraryExA( lpLibFileName, NULL, 0 );
}

HMODULE
LoadLibraryW(
    LPCWSTR lpwLibFileName
    )
{
    return LoadLibraryExW( lpwLibFileName, NULL, 0 );
}

HMODULE
LoadLibraryExA(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )

/*++

Routine Description:

    ANSI thunk to LoadLibraryExW

--*/

{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpLibFileName );
    if (Unicode == NULL) {
        return NULL;
    }

    return LoadLibraryExW( Unicode->Buffer, hFile, dwFlags);
}

NTSTATUS
BasepLoadLibraryAsDataFile(
    IN PWSTR DllPath OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    )

{
    WCHAR FullPath[ MAX_PATH ];
    PWSTR FilePart;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    UNICODE_STRING FullPathPreAllocatedString;
    UNICODE_STRING FullPathDynamicString = {0};
    UNICODE_STRING DefaultExtensionString = RTL_CONSTANT_STRING(L".DLL");
    PUNICODE_STRING FullPathString = NULL;
    LPVOID DllBase;
    PIMAGE_NT_HEADERS NtHeaders;
    PTEB Teb;
    NTSTATUS Status;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA askd;

    Teb = NtCurrentTeb();

    *DllHandle = NULL;

    FullPathPreAllocatedString.MaximumLength = sizeof(FullPath);
    FullPathPreAllocatedString.Length = 0;
    FullPathPreAllocatedString.Buffer = FullPath;

    Status = RtlDosApplyFileIsolationRedirection_Ustr(
        RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
        DllName,
        &DefaultExtensionString,
        &FullPathPreAllocatedString,
        &FullPathDynamicString,
        &FullPathString,
        NULL,
        NULL,
        NULL);
    if (NT_ERROR(Status)) {
        if (Status != STATUS_SXS_KEY_NOT_FOUND)
            goto Exit;

        if (!SearchPathW( DllPath,
                          DllName->Buffer,
                          DefaultExtensionString.Buffer,
                          sizeof(FullPath) / sizeof(FullPath[0]),
                          FullPath,
                          &FilePart
                        )
           ) {
            Status = Teb->LastStatusValue;
            goto Exit;
        }

        FullPathString = &FullPathPreAllocatedString;
    }

    FileHandle = CreateFileW( FullPathString->Buffer,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_DELETE,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL
                            );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        Status = Teb->LastStatusValue;
        goto Exit;
        }

    MappingHandle = CreateFileMappingW( FileHandle,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                                      );
    CloseHandle( FileHandle );
    if (MappingHandle == NULL) {
        Status = Teb->LastStatusValue;
        goto Exit;
        }

    DllBase = MapViewOfFileEx( MappingHandle,
                               FILE_MAP_READ,
                               0,
                               0,
                               0,
                               NULL
                             );
    CloseHandle( MappingHandle );
    if (DllBase == NULL) {
        Status = Teb->LastStatusValue;
        goto Exit;
        }

    NtHeaders = RtlImageNtHeader( DllBase );
    if (NtHeaders == NULL) {
        UnmapViewOfFile( DllBase );
        Status = STATUS_INVALID_IMAGE_FORMAT;
        goto Exit;
        }

    *DllHandle = LDR_VIEW_TO_DATAFILE(DllBase);
    LdrLoadAlternateResourceModule(*DllHandle, FullPathString->Buffer);

    Status = STATUS_SUCCESS;

Exit:
    if (FullPathDynamicString.Buffer != NULL)
        RtlFreeUnicodeString(&FullPathDynamicString);
    return Status;
}

HMODULE
LoadLibraryExW(
    LPCWSTR lpwLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )

/*++

Routine Description:

    This function loads the library module contained in the specified
    file and retrieves a handle to the loaded module.

    It is important to note that module handles are NOT global, in that
    a LoadLibrary call by one application does not produce a handle that
    another application can use, say in calling GetProcAddress.  The
    other application would need to do its own call to LoadLibrary for
    the module before calling GetProcAddress.  Module handles will have
    the same 32-bit value across all processes, but a module handle is
    only valid in the context of a process after the module has been
    loaded into that process, either as a result of an explicit call to
    LoadLibrary or as a result of an implicit call caused by a loadtime
    dynamic link to an entry point in the module.

    The library file name does not need to specify an extension.  If one
    is not specified, then the default library file extension, .DLL, is
    used (note that this is different than Win16. Under Win16 specifying
    no extension would not cause ".DLL" to be appended to the name. To get
    Win16 behavior, if the module name has no extension, the caller must
    supply a trailing ".").

    The library file name does not need to specify a directory path.  If
    one is specified, then the specified file must exist.  If a path is
    not specified, this function will look for the library file in using
    the Windows search path:

      - The current process image file directory

      - The current directory

      - The Windows system directory

      - The Windows directory

      - The directories listed in the PATH environment variable

    The first directory searched is the directory that contains the
    image file that was used to create the current process (see
    CreateProcess).  This allows private dynamic link library files
    associated with an application to be found without having to add the
    application's installed directory to the PATH environment variable.

    The image file loader optimizes the search by remembering for each
    loaded library module that unqualified module name that was searched
    for when a module was loaded into the current process the first
    time.  This unqualified name has nothing to do with the module name
    that is stored within the library module itself, as specified by the
    NAME keyword in the .DEF file.  This is a change from the Windows
    3.1 behavior, where the search was optimized by comparing to the
    name within the library module itself, which could lead to confusing
    result if the internal name differed from the external file name.

    Once a fully qualified path name to a library module file is
    obtained, a search is made to see if that library module file has
    been loaded into the current process.  The search is case
    insensitive and includes the full path name of each library module
    file.  If a match is found for the library module file, then it has
    already been loaded into the current process, so this function just
    increments the reference count for the module and returns the module
    handle for that library.

    Otherwise, this is the first time the specified module has been
    loaded for the current process, so the library module's DLL Instance
    Initialization entry point will be called.  See the Task Management
    section for a description of the DLL Instance Initialization entry
    point.

    Fine Point: If DLL re-direction is enabled for the app./process requesting
    this load, if we find a DLL in the app. folder (with same base name),
    we load that file (ignoring any path qualifications passed in).

Arguments:

    lpwLibFileName - Points to a string that names the library file.  The
    string must be a null-terminated unicode string.

    hFile - optional file handle, that if specified, while be used to
        create the mapping object for the module.

    dwFlags - flags that specify optional behavior.  Valid flags are:

        DONT_RESOLVE_DLL_REFERENCES - loads the library but does not
            attempt to resolve any of its DLL references nor does it
            attempt to call its initialization procedure.

        LOAD_LIBRARY_AS_DATAFILE - If this value is used, the system
            maps the file into the calling process's virtual address
            space as if it were a data file.

        LOAD_WITH_ALTERED_SEARCH_PATH - If this value is used, and
            lpFileName specifies a path, the system uses the alternate
            file search strategy

        LOAD_IGNORE_CODE_AUTHZ_LEVEL - Indicates that WinSafer sandbox
            restrictions should be ignored when loading the library
            and that load should be allowed to continue, even if the
            library is less trustworthy than the process loading it.

Return Value:

    The return value identifies the loaded module if the function is
    successful.  A return value of NULL indicates an error and extended
    error status is available using the GetLastError function.

--*/

{
    LPWSTR TrimmedDllName = NULL;
    LPWSTR AllocatedPath = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    HMODULE hModule = NULL;
    UNICODE_STRING DllName_U;
    UNICODE_STRING AllocatedPath_U;
    ULONG DllCharacteristics;
    
    DllCharacteristics = 0;
    if (dwFlags & DONT_RESOLVE_DLL_REFERENCES) {
        DllCharacteristics |= IMAGE_FILE_EXECUTABLE_IMAGE;
        }
    if ( dwFlags & LOAD_IGNORE_CODE_AUTHZ_LEVEL ) {
        DllCharacteristics |= IMAGE_FILE_SYSTEM;
        }

    RtlInitUnicodeString(&DllName_U, lpwLibFileName);

    //
    // Quick check to see if dll being loaded is the main exe. For some reason
    // hook stuff tends to do this and this is worst path through the loader
    //

    BasepCheckExeLdrEntry();

    if ( !(dwFlags & LOAD_LIBRARY_AS_DATAFILE) && BasepExeLdrEntry && (DllName_U.Length == BasepExeLdrEntry->FullDllName.Length) ){
        if ( RtlEqualUnicodeString(&DllName_U,&BasepExeLdrEntry->FullDllName,TRUE) ) {
            return (HMODULE)BasepExeLdrEntry->DllBase;
            }
        }

    //
    // check to see if there are trailing spaces in the dll name (Win95 compat)
    //
    if ( DllName_U.Length && DllName_U.Buffer[(DllName_U.Length-1)>>1] == (WCHAR)' ') {
        TrimmedDllName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), DllName_U.MaximumLength);
        if ( !TrimmedDllName ) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
            }
        RtlCopyMemory(TrimmedDllName,DllName_U.Buffer,DllName_U.MaximumLength);
        DllName_U.Buffer = TrimmedDllName;
        while (DllName_U.Length && DllName_U.Buffer[(DllName_U.Length-1)>>1] == (WCHAR)' ') {
            DllName_U.Buffer[(DllName_U.Length-1)>>1] = UNICODE_NULL;
            DllName_U.Length -= sizeof(WCHAR);
            DllName_U.MaximumLength -= sizeof(WCHAR);
            }
        }


    AllocatedPath = NULL;

    //
    // Determine the path that the program was created from
    //
    AllocatedPath
        = BaseComputeProcessDllPath(
            dwFlags & LOAD_WITH_ALTERED_SEARCH_PATH ? DllName_U.Buffer : NULL,
            NULL
            );

    if ( !AllocatedPath ) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
        }

    //
    // Actually perform the library loading sequence.
    //
    RtlInitUnicodeString(&AllocatedPath_U, AllocatedPath);
    try {
        if (dwFlags & LOAD_LIBRARY_AS_DATAFILE) {
#ifdef WX86
            // LdrGetDllHandle clears UseKnownWx86Dll, but the value is
            // needed again by LdrLoadDll.
            BOOLEAN Wx86KnownDll = NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll;
#endif
            Status = LdrGetDllHandle(
                        AllocatedPath_U.Buffer,
                        NULL,
                        &DllName_U,
                        (PVOID *)&hModule
                        );
            if (NT_SUCCESS( Status )) {
#ifdef WX86
                NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = Wx86KnownDll;
#endif
                goto alreadyLoaded;
                }
            Status = BasepLoadLibraryAsDataFile( AllocatedPath_U.Buffer,
                                                 &DllName_U,
                                                 (PVOID *)&hModule
                                               );
            }
        else {
alreadyLoaded:
            Status = LdrLoadDll(
                        AllocatedPath_U.Buffer,
                        &DllCharacteristics,
                        &DllName_U,
                        (PVOID *)&hModule
                        );
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }
Exit:
    if ( TrimmedDllName )
        RtlFreeHeap(RtlProcessHeap(), 0, TrimmedDllName);

    if ( AllocatedPath )
        RtlFreeHeap(RtlProcessHeap(), 0, AllocatedPath);

    if (!NT_SUCCESS(Status))
        BaseSetLastNTError(Status);

    return hModule;
}

BOOL
FreeLibrary(
    HMODULE hLibModule
    )

/*++

Routine Description:

    This function decreases the reference count of the loaded library
    module by one.  The reference count is maintain for each process.

    When the reference count for the specified library module is
    decremented to zero, the library module's DLL Instance Termination
    entry point is called.  This will allow a library module a chance to
    cleanup resources that we allocated on behalf of the current
    process.  See the Task Management section for a description of the
    DLL Instance Termination entry point.  Finally, after the
    termination entry point returns, the library module is removed from
    the address space of the current process.

    If more than one process has loaded a library module, then the
    library module will remain in use until all process's that loaded
    the module have called FreeLibrary to unload the library.

Arguments:

    hLibModule - Identifies the loaded library module.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using the GetLastError function.

--*/

{
    NTSTATUS Status;

    if (LDR_IS_DATAFILE(hLibModule)) {

        if (RtlImageNtHeader(LDR_DATAFILE_TO_VIEW(hLibModule))) {

            Status = NtUnmapViewOfSection( NtCurrentProcess(),
                                           LDR_DATAFILE_TO_VIEW(hLibModule)
                                         );
            LdrUnloadAlternateResourceModule(hLibModule);

            }
        else {
            Status = STATUS_INVALID_IMAGE_FORMAT;
            }
        }
    else {
        Status = LdrUnloadDll( (PVOID)hLibModule );
        }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

VOID
WINAPI
FreeLibraryAndExitThread(
    HMODULE hLibModule,
    DWORD dwExitCode
    )

/*++

Routine Description:

    This function decreases the reference count of the loaded library
    module by one, and then calls ExitThread.

    The purpose of this function is to allow threads that are created
    within a dll, and execute within that DLL an opportunity to safely
    unload the DLL and to exit.

    When the reference count for the specified library module is
    decremented to zero, the library module's DLL Instance Termination
    entry point is called.  This will allow a library module a chance to
    cleanup resources that we allocated on behalf of the current
    process.  See the Task Management section for a description of the
    DLL Instance Termination entry point.  Finally, after the
    termination entry point returns, the library module is removed from
    the address space of the current process.

    If more than one process has loaded a library module, then the
    library module will remain in use until all process's that loaded
    the module have called FreeLibrary to unload the library.

Arguments:

    hLibModule - Identifies the loaded library module.

    dwExitCode - Supplies the exit code for the thread

Return Value:

    This function never returns. invalid hLibModule values are silently ignored

--*/

{
    if (LDR_IS_DATAFILE(hLibModule)) {
        NtUnmapViewOfSection( NtCurrentProcess(),
                                       LDR_DATAFILE_TO_VIEW(hLibModule)
                                     );
        }
    else {
        LdrUnloadDll( (PVOID)hLibModule );
        }

    ExitThread(dwExitCode);
}

BOOL
WINAPI
DisableThreadLibraryCalls(
    HMODULE hLibModule
    )

/*++

Routine Description:

    This function disables DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications
    for the DLL specified by hLibModule. Attempting to call this on a DLL with
    inuse static thread local storage is an error.

Arguments:

    hLibModule - Identifies the loaded library module.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using the GetLastError function.

--*/

{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = LdrDisableThreadCalloutsForDll(hLibModule);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        rv = FALSE;
        }
    return rv;
}

BOOL
WINAPI
SetDllDirectoryW(
    IN LPCWSTR lpPathName
    )

/*++

Routine Description:

    This function sets the effective current directory used
    for the LoadLibrary() dll search path.

Arguments:

    lpPathName - Specifies the directory to use.

                 If the directory is NULL, switch back to the default
                 dll search path behavior (in case a SetDllDirectory()
                 call was already in effect).

                 If the directory is the empty string, omit both the
                 dll directory and the current directory from the
                 search path.

                 Note that setting the directory to L"." has the
                 effect of reverting back to the original
                 LoadLibrary() path.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Extended error status is available
            via GetLastError().

Notes:

    Moving the current directory after the system directories (which
    we have to do for security considerations) breaks applications
    which depend on using { SetCurrentDirectory(); LoadLibrary(); } to
    pick up specific versions of libraries.

    We recognize that this solution is suboptimal, but we're stuck
    with the current LoadLibrary() API, which has been around for
    quite some time.  We did try changing it, but ran into serious
    application compatibility issues; moving the current directory
    later in the search path caused the least number of problems, and
    this API makes it easy for applications and application
    compatibility shims to get back the old behavior.

--*/

{
    UNICODE_STRING OldDllDirectory;
    UNICODE_STRING NewDllDirectory;
    
    if (lpPathName) {

        if (wcschr(lpPathName, L';')) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (! RtlCreateUnicodeString(&NewDllDirectory, lpPathName)) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    } else {
        RtlInitUnicodeString(&NewDllDirectory, NULL);
    }

    RtlEnterCriticalSection(&BaseDllDirectoryLock);

    OldDllDirectory = BaseDllDirectory;
    BaseDllDirectory = NewDllDirectory;

    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    RtlFreeUnicodeString(&OldDllDirectory);

    return TRUE;
}

BOOL
WINAPI
SetDllDirectoryA(
    IN LPCSTR lpPathName
    )

/*++

Routine Description:

    ANSI implementation of SetDllDirectoryW

--*/

{
    UNICODE_STRING OldDllDirectory;
    UNICODE_STRING NewDllDirectory;
    NTSTATUS Status;
    ULONG Length;
    
    if (lpPathName) {

        if (strchr(lpPathName, ';')) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (! Basep8BitStringToDynamicUnicodeString(&NewDllDirectory,
                                                    lpPathName)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    } else {
        RtlInitUnicodeString(&NewDllDirectory, NULL);
    }

    RtlEnterCriticalSection(&BaseDllDirectoryLock);

    OldDllDirectory = BaseDllDirectory;
    BaseDllDirectory = NewDllDirectory;

    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    RtlFreeUnicodeString(&OldDllDirectory);

    return TRUE;
}

DWORD
WINAPI
GetDllDirectoryW(
    IN  DWORD  nBufferLength,
    OUT LPWSTR lpBuffer
    )

/*++

Routine Description:

    This function retrieves the effective current directory used for
    the LoadLibrary() dll search path.

Arguments:

    nBufferLength - Specifies the size of the output buffer.

    lpBuffer - The buffer where the current dll directory will be written.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Extended error status is available
            via GetLastError().

--*/

{
    DWORD Result;
    
    RtlEnterCriticalSection(&BaseDllDirectoryLock);

    if (nBufferLength * sizeof(WCHAR) <= BaseDllDirectory.Length) {
        Result = ((BaseDllDirectory.Length + sizeof(UNICODE_NULL))
                  / sizeof(WCHAR));
        if (lpBuffer) {
            lpBuffer[0] = UNICODE_NULL;
        }
    } else {
        RtlCopyMemory(lpBuffer,
                      BaseDllDirectory.Buffer,
                      BaseDllDirectory.Length);
        Result = BaseDllDirectory.Length / sizeof(WCHAR);
        lpBuffer[Result] = UNICODE_NULL;
    }

    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    return Result;
}

DWORD
WINAPI
GetDllDirectoryA(
    IN  DWORD  nBufferLength,
    OUT LPSTR lpBuffer
    )

/*++

Routine Description:

    ANSI implementation of GetDllDirectoryW

--*/

{
    ANSI_STRING Ansi;
    DWORD       Result;
    NTSTATUS    Status;

    RtlInitEmptyUnicodeString(&Ansi, lpBuffer, nBufferLength);

    RtlEnterCriticalSection(&BaseDllDirectoryLock);

    // Includes the NULL
    Result = BasepUnicodeStringTo8BitSize(&BaseDllDirectory);

    if (Result <= nBufferLength) {
        Status = BasepUnicodeStringTo8BitString(&Ansi,
                                                &BaseDllDirectory,
                                                FALSE);
        Result--; // trim off the space needed for the NULL
    } else {
        Status = STATUS_SUCCESS;
        if (lpBuffer) {
            lpBuffer[0] = ANSI_NULL;
        }
    }

    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        Result = 0;
        lpBuffer[0] = ANSI_NULL;
    }

    return Result;
}

DWORD
WINAPI
GetModuleFileNameW(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head,Next;
    DWORD ReturnCode;
    PVOID DllHandle = BasepMapModuleHandle( hModule, FALSE );
    PUNICODE_STRING Ustr;
    PVOID LoaderLockCookie = NULL;

    ReturnCode = 0;
    nSize = nSize << 1;

    //
    // If we are looking at the current image, then check for name
    // redirection
    //

    if ( !ARGUMENT_PRESENT( hModule )) {
        if ( RtlGetPerThreadCurdir() && RtlGetPerThreadCurdir()->ImageName ) {
            Ustr = RtlGetPerThreadCurdir()->ImageName;
            ReturnCode = (DWORD)Ustr->Length + sizeof(WCHAR);
            if ( nSize < ReturnCode ) {
                ReturnCode = nSize;
                }
            RtlMoveMemory(
                lpFilename,
                Ustr->Buffer,
                ReturnCode
                );
            if ( ReturnCode == (DWORD)Ustr->Length + sizeof(WCHAR)) {
                ReturnCode = (DWORD)Ustr->Length;
                }
            return ReturnCode/2;
            }
        }
    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LoaderLockCookie);
    try {
        Head = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
        Next = Head->Flink;

        while ( Next != Head ) {
            Entry = CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InLoadOrderLinks);
            if ( DllHandle == (PVOID)Entry->DllBase ) {
                ReturnCode = (DWORD)Entry->FullDllName.Length + sizeof(WCHAR);
                if ( nSize < ReturnCode ) {
                    ReturnCode = nSize;
                    }
                try {
                    RtlMoveMemory(
                        lpFilename,
                        Entry->FullDllName.Buffer,
                        ReturnCode
                        );
                    if ( ReturnCode == (DWORD)Entry->FullDllName.Length + sizeof(WCHAR)) {
                        ReturnCode = (DWORD)Entry->FullDllName.Length ;
                        }
                    goto finally_exit;
                    }
                except (EXCEPTION_EXECUTE_HANDLER) {
                    BaseSetLastNTError(GetExceptionCode());
                    return 0;
                    }
                }
            Next = Next->Flink;
            }
finally_exit:;
        }
    finally {
        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LoaderLockCookie);
        }
    return ReturnCode/2;
}

DWORD
GetModuleFileNameA(
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    DWORD ReturnCode;

    UnicodeString.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), nSize*2);
    if ( !UnicodeString.Buffer ) {
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return 0;
        }
    ReturnCode = GetModuleFileNameW(hModule, UnicodeString.Buffer, nSize);
    UnicodeString.Length = UnicodeString.MaximumLength = (USHORT)ReturnCode*2;
    UnicodeString.MaximumLength++;
    UnicodeString.MaximumLength++;

    if (ReturnCode) {
    Status = BasepUnicodeStringTo8BitString(&AnsiString, &UnicodeString, TRUE);
    if (!NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        RtlFreeUnicodeString(&UnicodeString);
        return 0;
        }

    ReturnCode = min( nSize, AnsiString.Length );

    RtlMoveMemory(
        lpFilename,
        AnsiString.Buffer,
        nSize <= ReturnCode ? nSize : ReturnCode + 1
        );

    RtlFreeAnsiString(&AnsiString);
    }

    RtlFreeUnicodeString(&UnicodeString);
    return ReturnCode;
}

HMODULE
GetModuleHandleA(
    LPCSTR lpModuleName
    )

/*++

Routine Description:

    ANSI thunk to GetModuleHandleW

--*/

{
    PUNICODE_STRING Unicode;

    if ( !ARGUMENT_PRESENT(lpModuleName) ) {
        return( (HMODULE)(PVOID)NtCurrentPeb()->ImageBaseAddress );
        }

    Unicode = Basep8BitStringToStaticUnicodeString( lpModuleName );
    if (Unicode == NULL) {
        return NULL;
    }

    return GetModuleHandleW(Unicode->Buffer);
}

HMODULE
WINAPI
GetModuleHandleForUnicodeString(
    IN PUNICODE_STRING ModuleName
    )
/*++

Routine Description:

    This function is the helper routine for GetModuleHandleW. See that for
    more details on return value, etc.

Arguments:

    ModuleName - Points to counted unicode string that names the library file.
        Caller guarantees that ModuleName->Buffer is not NULL.

Return Value:

    See GetModuleHandleW for this.

--*/

{
    LPWSTR AllocatedPath;
    NTSTATUS Status;
    HMODULE hModule;
#ifdef WX86
    BOOLEAN Wx86KnownDll;
#endif

#ifdef WX86
    // LdrGetDllHandle clears UseKnownWx86Dll, but the value is needed again
    // for the second LdrGetDllHandle call.
    Wx86KnownDll = NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll;
#endif
    Status = LdrGetDllHandle(
                (PWSTR)1,
                NULL,
                ModuleName,
                (PVOID *)&hModule
                );
    if ( NT_SUCCESS(Status) ) {
        return hModule;
        }

    //
    // Determine the path that the program was created from
    //

    AllocatedPath = BaseComputeProcessDllPath(NULL,NULL);
    if (!AllocatedPath) {
        Status = STATUS_NO_MEMORY;
        goto bail;
        }
#ifdef WX86
    NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = Wx86KnownDll;
#endif

    try {

        Status = LdrGetDllHandle(
                    AllocatedPath,
                    NULL,
                    ModuleName,
                    (PVOID *)&hModule
                    );
        RtlFreeHeap(RtlProcessHeap(), 0, AllocatedPath);
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        RtlFreeHeap(RtlProcessHeap(), 0, AllocatedPath);
        }

bail:
    if (!NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    else {
        return hModule;
        }
}

HMODULE
WINAPI
GetModuleHandleW(
    LPCWSTR lpwModuleName
    )
/*++

Routine Description:

    This function returns the handle of a module that is loaded into the
    context of the calling process.

    In a multi-thread environment, this function is not reliable, since
    while one thread is calling this function and getting back a module
    handle, another thread in the same process could be calling
    FreeLibrary for the same module, therefore invalidating the returned
    module handle for the first thread.

Arguments:

    lpwModuleName - Points to a string that names the library file.  The
    string must be a null-terminated unicode string.  If this
        parameter is NULL, then the handle for the current image file is
        returned.

Return Value:

    The return value is a module handle.  A return value of NULL
    indicates either that the module has not been loaded into the
    context of the current process or an error occured.  The exact
    reason is available using the GetLastError function.

--*/
{
    HMODULE hModule;
    BOOL    fSuccess;

    if (!ARGUMENT_PRESENT(lpwModuleName)) {
        return( (HMODULE)(PVOID)NtCurrentPeb()->ImageBaseAddress );
    }

    fSuccess =
        BasepGetModuleHandleExW(
            BASEP_GET_MODULE_HANDLE_EX_NO_LOCK,
            GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
            lpwModuleName,
            &hModule
            );
    return fSuccess ? hModule : NULL;
}

ULONG
WINAPI
BasepGetModuleHandleExParameterValidation(
    IN DWORD        dwFlags,
    IN CONST VOID*  lpModuleName,
    OUT HMODULE*    phModule
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (phModule != NULL)
        *phModule = NULL;

    if ((dwFlags & ~(
              GET_MODULE_HANDLE_EX_FLAG_PIN
            | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
            | GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
            )) != 0) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Error;
    }
    if ((dwFlags & GET_MODULE_HANDLE_EX_FLAG_PIN) != 0
            && (dwFlags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT) != 0
            ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Error;
    }
    if (!ARGUMENT_PRESENT(lpModuleName)
            && (dwFlags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS) != 0
            ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Error;
    }
    if (phModule == NULL) {
        Status = STATUS_INVALID_PARAMETER_2;
        goto Error;
    }

    if (!ARGUMENT_PRESENT(lpModuleName)) {
        *phModule = ( (HMODULE)(PVOID)NtCurrentPeb()->ImageBaseAddress );
        goto Success;
    }
    goto Continue;
Error:
    BaseSetLastNTError(Status);
    return BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_ERROR;
Success:
    return BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_SUCCESS;
Continue:
    return BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE;
}

BOOL
GetModuleHandleExA(
    IN DWORD        dwFlags,
    IN LPCSTR       lpaModuleName,
    OUT HMODULE*    phModule
    )
/*++

Routine Description:

    ANSI thunk to GetModuleHandleExW

--*/

{
    PUNICODE_STRING Unicode;
    ULONG Disposition;
    LPCWSTR lpwModuleName;
    BOOL    fSuccess = FALSE;

    Disposition = BasepGetModuleHandleExParameterValidation(dwFlags, lpaModuleName, phModule);
    switch (Disposition)
    {
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_ERROR:
        goto Exit;
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_SUCCESS:
        fSuccess = TRUE;
        goto Exit;
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE:
        break;
    }

    if ((dwFlags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS) == 0) {
        Unicode = Basep8BitStringToStaticUnicodeString(lpaModuleName);
        if (Unicode == NULL) {
            goto Exit;
        }
        lpwModuleName = Unicode->Buffer;
    } else {
        lpwModuleName = (LPCWSTR)(CONST VOID*)lpaModuleName;
    }

    if (!BasepGetModuleHandleExW(0, dwFlags, lpwModuleName, phModule))
        goto Exit;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
WINAPI
GetModuleHandleExW(
    IN DWORD        dwFlags,
    IN LPCWSTR      lpwModuleName,
    OUT HMODULE*    phModule
    )
{
    ULONG Disposition;
    BOOL   fSuccess = FALSE;

    Disposition = BasepGetModuleHandleExParameterValidation(dwFlags, lpwModuleName, phModule);
    switch (Disposition)
    {
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_ERROR:
        goto Exit;
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_SUCCESS:
        fSuccess = TRUE;
        goto Exit;
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE:
        break;
    }
    if (!BasepGetModuleHandleExW(0, dwFlags, lpwModuleName, phModule))
        goto Exit;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
WINAPI
BasepGetModuleHandleExW(
    IN DWORD        dwPrivateFlags,
    IN DWORD        dwPublicFlags,
    IN LPCWSTR      lpwModuleName,
    OUT HMODULE*    phModule
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HMODULE hModule = NULL;
    UNICODE_STRING DllName_U, AppPathDllName_U, LocalDirDllName_U;
    BOOL DoDllRedirection = FALSE;
    WCHAR DllNameUnderImageDirBuffer[MAX_PATH];
    WCHAR DllNameUnderLocalDirBuffer[MAX_PATH];
    BOOL HoldingLoaderLock = FALSE;
    ULONG LdrFlags;
    PVOID LdrLockCookie = NULL;

    RTL_SOFT_ASSERT(BasepGetModuleHandleExParameterValidation(dwPublicFlags, lpwModuleName, phModule) == BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE);

    AppPathDllName_U.Buffer = DllNameUnderImageDirBuffer;
    AppPathDllName_U.Length = 0 ;
    AppPathDllName_U.MaximumLength = sizeof(DllNameUnderImageDirBuffer);

    LocalDirDllName_U.Buffer = DllNameUnderLocalDirBuffer;
    LocalDirDllName_U.Length = 0 ;
    LocalDirDllName_U.MaximumLength = sizeof(DllNameUnderLocalDirBuffer);

    if ((dwPrivateFlags & BASEP_GET_MODULE_HANDLE_EX_NO_LOCK) == 0) {
        Status = LdrLockLoaderLock(0, NULL, &LdrLockCookie);
        if (!NT_SUCCESS(Status))
            goto Exit;
        HoldingLoaderLock = TRUE;
    }
    __try {
        if (dwPublicFlags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS) {
            hModule = RtlPcToFileHeader((PVOID)lpwModuleName, (PVOID*)&hModule);
            if (hModule == NULL) {
                Status = STATUS_DLL_NOT_FOUND;
                __leave;
            }
        } else {
            RtlInitUnicodeString(&DllName_U, lpwModuleName);

            if ((NtCurrentPeb()->ProcessParameters != NULL) &&
                (NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL))
               DoDllRedirection = TRUE;

            if (DoDllRedirection) {
                Status = RtlComputePrivatizedDllName_U(&DllName_U, &AppPathDllName_U, &LocalDirDllName_U);
                if(!NT_SUCCESS(Status)) {
                    __leave;
                }

                hModule = GetModuleHandleForUnicodeString(&LocalDirDllName_U) ;
                if (!hModule )
                    hModule = GetModuleHandleForUnicodeString(&AppPathDllName_U) ;
                // Didn't find any re-directed DLL with this name loaded. Now we can just check for the
                // original name passed in.
            }
            if ( ! hModule)
                hModule = GetModuleHandleForUnicodeString(&DllName_U) ;
            if (hModule == NULL) {
                Status = NtCurrentTeb()->LastStatusValue;
                __leave;
            }
        }
        if (dwPublicFlags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT) {
            Status = STATUS_SUCCESS;
            __leave;
        }
        LdrFlags = (dwPublicFlags & GET_MODULE_HANDLE_EX_FLAG_PIN) ? LDR_ADDREF_DLL_PIN : 0;
        Status = LdrAddRefDll(LdrFlags, (PVOID)hModule);
    } __finally {
        if (HoldingLoaderLock) {
            NTSTATUS Status2 = LdrUnlockLoaderLock(0, LdrLockCookie);
            ASSERT(NT_SUCCESS(Status2));
            HoldingLoaderLock = FALSE;
        }
    }

Exit : // cleanup
    if (AppPathDllName_U.Buffer != DllNameUnderImageDirBuffer)
        RtlFreeUnicodeString(&AppPathDllName_U);

    if (LocalDirDllName_U.Buffer != DllNameUnderLocalDirBuffer)
        RtlFreeUnicodeString(&LocalDirDllName_U);
    if (!NT_SUCCESS(Status))
        BaseSetLastNTError(Status);

    if (phModule != NULL)
        *phModule = hModule;

    return NT_SUCCESS(Status);
}

FARPROC
GetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName
    )

/*++

Routine Description:

    This function retrieves the memory address of the function whose
    name is pointed to by the lpProcName parameter.  The GetProcAddress
    function searches for the function in the module specified by the
    hModule parameter, or in the module associated with the current
    process if hModule is NULL.  The function must be an exported
    function; the module's definition file must contain an appropriate
    EXPORTS line for the function.

    If the lpProcName parameter is an ordinal value and a function with
    the specified ordinal does not exist in the module, GetProcAddress
    can still return a non-NULL value.  In cases where the function may
    not exist, specify the function by name rather than ordinal value.

    Only use GetProcAddress to retrieve addresses of exported functions
    that belong to library modules.

    The spelling of the function name (pointed to by lpProcName) must be
    identical to the spelling as it appears in the source library's
    definition (.DEF) file.  The function can be renamed in the
    definition file.  Case sensitive matching is used???

Arguments:

    hModule - Identifies the module whose executable file contains the
        function.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.


    lpProcName - Points to the function name, or contains the ordinal
        value of the function.  If it is an ordinal value, the value
        must be in the low-order word and zero must be in the high-order
        word.  The string must be a null-terminated character string.

Return Value:

    The return value points to the function's entry point if the
    function is successful.  A return value of NULL indicates an error
    and extended error status is available using the GetLastError function.


--*/

{
    NTSTATUS Status;
    PVOID ProcedureAddress;
    STRING ProcedureName;

    if ( (ULONG_PTR)lpProcName > 0xffff ) {
        RtlInitString(&ProcedureName,lpProcName);
        Status = LdrGetProcedureAddress(
                        BasepMapModuleHandle( hModule, FALSE ),
                        &ProcedureName,
                        0L,
                        &ProcedureAddress
                        );
        }
    else {
        Status = LdrGetProcedureAddress(
                        BasepMapModuleHandle( hModule, FALSE ),
                        NULL,
                        PtrToUlong((PVOID)lpProcName),
                        &ProcedureAddress
                        );
        }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    else {
        if ( ProcedureAddress == BasepMapModuleHandle( hModule, FALSE ) ) {
            if ( (ULONG_PTR)lpProcName > 0xffff ) {
                Status = STATUS_ENTRYPOINT_NOT_FOUND;
                }
            else {
                Status = STATUS_ORDINAL_NOT_FOUND;
                }
            BaseSetLastNTError(Status);
            return NULL;
            }
        else {
            return (FARPROC)ProcedureAddress;
            }
        }
}

DWORD
GetVersion(
    VOID
    )

/*++

Routine Description:

    This function returns the current version number of Windows.

Arguments:

    None.

Return Value:

    The return value specifies the major and minor version numbers of
    Windows.  The high-order word specifies the minor version (revision)
    number; the low-order word specifies the major version number.

--*/

{
    PPEB Peb;

    Peb = NtCurrentPeb();

    return (((Peb->OSPlatformId ^ 0x2) << 30) |
            (Peb->OSBuildNumber << 16) |
            (Peb->OSMinorVersion << 8) |
             Peb->OSMajorVersion
           );
}

WINBASEAPI
BOOL
WINAPI
GetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    )
{
    OSVERSIONINFOEXW VersionInformationU;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    if (lpVersionInformation->dwOSVersionInfoSize != sizeof( OSVERSIONINFOEXA ) &&
        lpVersionInformation->dwOSVersionInfoSize != sizeof( *lpVersionInformation )
       ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
        }

    VersionInformationU.dwOSVersionInfoSize = sizeof( VersionInformationU );
    if (GetVersionExW( (LPOSVERSIONINFOW)&VersionInformationU )) {
        lpVersionInformation->dwMajorVersion = VersionInformationU.dwMajorVersion;
        lpVersionInformation->dwMinorVersion = VersionInformationU.dwMinorVersion;
        lpVersionInformation->dwBuildNumber  = VersionInformationU.dwBuildNumber;
        lpVersionInformation->dwPlatformId   = VersionInformationU.dwPlatformId;
        if (lpVersionInformation->dwOSVersionInfoSize == sizeof( OSVERSIONINFOEXA )) {
            ((POSVERSIONINFOEXA)lpVersionInformation)->wServicePackMajor = VersionInformationU.wServicePackMajor;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wServicePackMinor = VersionInformationU.wServicePackMinor;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wSuiteMask = VersionInformationU.wSuiteMask;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wProductType = VersionInformationU.wProductType;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wReserved = VersionInformationU.wReserved;
            }

        AnsiString.Buffer = lpVersionInformation->szCSDVersion;
        AnsiString.Length = 0;
        AnsiString.MaximumLength = sizeof( lpVersionInformation->szCSDVersion );

        RtlInitUnicodeString( &UnicodeString, VersionInformationU.szCSDVersion );
        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &UnicodeString,
                                               FALSE
                                             );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        else {
            return FALSE;
            }
        }
    else {
        return FALSE;
        }
}

WINBASEAPI
BOOL
WINAPI
GetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    )
{
    PPEB Peb;
    NTSTATUS Status;

    if (lpVersionInformation->dwOSVersionInfoSize != sizeof( OSVERSIONINFOEXW ) &&
        lpVersionInformation->dwOSVersionInfoSize != sizeof( *lpVersionInformation )
       ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
        }
    Status = RtlGetVersion(lpVersionInformation);
    if (Status == STATUS_SUCCESS) {
        if (lpVersionInformation->dwOSVersionInfoSize ==
                                            sizeof( OSVERSIONINFOEXW))
            ((POSVERSIONINFOEXW)lpVersionInformation)->wReserved =
                                        (UCHAR)BaseRCNumber;
        return TRUE;
    } else {
        return FALSE;
    }
}


WINBASEAPI
BOOL
WINAPI
VerifyVersionInfoW(
    IN LPOSVERSIONINFOEXW VersionInfo,
    IN DWORD TypeMask,
    IN DWORDLONG ConditionMask
    )

/*++

Routine Description:

    This function verifies a version condition.  Basically, this
    function lets an app query the system to see if the app is
    running on a specific version combination.


Arguments:

    VersionInfo     - a version structure containing the comparison data
    TypeMask        - a mask comtaining the data types to look at
    ConditionMask   - a mask containing conditionals for doing the comparisons


Return Value:

    TRUE  - the version condition exists
    FALSE - the version condition does NOT exists

--*/

{
    DWORD i;
    OSVERSIONINFOEXW CurrVersion;
    BOOL SuiteFound = FALSE;
    NTSTATUS Status;


    Status = RtlVerifyVersionInfo(VersionInfo, TypeMask, ConditionMask);
    if (Status == STATUS_INVALID_PARAMETER) {
        SetLastError( ERROR_BAD_ARGUMENTS );
        return FALSE;
    } else if (Status == STATUS_REVISION_MISMATCH) {
        SetLastError(ERROR_OLD_WIN_VERSION);
        return FALSE;
    }

    return TRUE;
}

WINBASEAPI
BOOL
WINAPI
VerifyVersionInfoA(
    IN LPOSVERSIONINFOEXA VersionInfo,
    IN DWORD TypeMask,
    IN DWORDLONG ConditionMask
    )

/*++

Routine Description:

    This function verifies a version condition.  Basically, this
    function lets an app query the system to see if the app is
    running on a specific version combination.


Arguments:

    VersionInfo     - a version structure containing the comparison data
    TypeMask        - a mask comtaining the data types to look at
    ConditionMask   - a mask containing conditionals for doing the comparisons


Return Value:

    TRUE  - the version condition exists
    FALSE - the version condition does NOT exists

--*/

{
    OSVERSIONINFOEXW VersionInfoW;


    VersionInfoW.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);

    VersionInfoW.dwMajorVersion      = VersionInfo->dwMajorVersion;
    VersionInfoW.dwMinorVersion      = VersionInfo->dwMinorVersion;
    VersionInfoW.dwBuildNumber       = VersionInfo->dwBuildNumber;
    VersionInfoW.dwPlatformId        = VersionInfo->dwPlatformId;
    VersionInfoW.wServicePackMajor   = VersionInfo->wServicePackMajor;
    VersionInfoW.wServicePackMinor   = VersionInfo->wServicePackMinor;
    VersionInfoW.wSuiteMask          = VersionInfo->wSuiteMask;
    VersionInfoW.wProductType        = VersionInfo->wProductType;
    VersionInfoW.wReserved           = VersionInfo->wReserved;

    return VerifyVersionInfoW( &VersionInfoW, TypeMask, ConditionMask );
}

HRSRC
FindResourceA(
    HMODULE hModule,
    LPCSTR lpName,
    LPCSTR lpType
    )

/*++

Routine Description:

    This function determines the location of a resource in the specified
    resource file.  The lpName and lpType parameters define the resource
    name and type, respectively.

    If the high-order word of the lpName or lpType parameter is zero,
    the low-order word specifies the integer ID of the name or type of
    the given resource.  Otherwise, the parameters are pointers to
    null-terminated character strings.  If the first character of the
    string is a pound sign (#), the remaining characters represent a
    decimal number that specifies the integer ID of the resource's name
    or type.  For example, the string "#258" represents the integer ID
    258.

    To reduce the amount of memory required for the resources used by an
    application, applications should refer to their resources by integer
    ID instead of by name.

    An application must not call FindResource and the LoadResource
    function to load cursor, icon, or string resources.  Instead, it
    must load these resources by calling the following functions:

      - LoadCursor

      - LoadIcon

      - LoadString

    An application can call FindResource and LoadResource to load other
    predefined resource types.  However, it is recommended that the
    application load the corresponding resources by calling the
    following functions:

      - LoadAccelerators

      - LoadBitmap

      - LoadMenu

    The above six API calls are documented with the Graphical User
    Interface API specification.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpName - Points to a null-terminated character string that
        represents the name of the resource.

    lpType - Points to a null-terminated character string that
        represents the type name of the resource.  For predefined
        resource types, the lpType parameter should be one of the
        following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

Return Value:

    The return value identifies the named resource.  It is NULL if the
    requested resource cannot be found.

--*/


{
    NTSTATUS Status;
    ULONG_PTR IdPath[ 3 ];
    PVOID p;

    IdPath[ 0 ] = 0;
    IdPath[ 1 ] = 0;
    try {
        if ((IdPath[ 0 ] = BaseDllMapResourceIdA( lpType )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            }
        else
        if ((IdPath[ 1 ] = BaseDllMapResourceIdA( lpName )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            }
        else {
            IdPath[ 2 ] = 0;
            p = NULL;
            Status = LdrFindResource_U( BasepMapModuleHandle( hModule, TRUE ),
                                        IdPath,
                                        3,
                                        (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                                      );
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    //
    // Free any strings allocated by BaseDllMapResourceIdA
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
        }
    else {
        return( (HRSRC)p );
        }
}

HRSRC
FindResourceExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD  wLanguage
    )

/*++

Routine Description:

    This function determines the location of a resource in the specified
    resource file.  The lpType, lpName and wLanguage parameters define
    the resource type, name and language respectively.

    If the high-order word of the lpType or lpName parameter
    is zero, the low-order word specifies the integer ID of the type, name
    or language of the given resource.  Otherwise, the parameters are pointers
    to null-terminated character strings.  If the first character of the
    string is a pound sign (#), the remaining characters represent a
    decimal number that specifies the integer ID of the resource's name
    or type.  For example, the string "#258" represents the integer ID
    258.

    If the wLanguage parameter is zero, then the current language
    associated with the calling thread will be used.

    To reduce the amount of memory required for the resources used by an
    application, applications should refer to their resources by integer
    ID instead of by name.

    An application must not call FindResource and the LoadResource
    function to load cursor, icon, or string resources.  Instead, it
    must load these resources by calling the following functions:

      - LoadCursor

      - LoadIcon

      - LoadString

    An application can call FindResource and LoadResource to load other
    predefined resource types.  However, it is recommended that the
    application load the corresponding resources by calling the
    following functions:

      - LoadAccelerators

      - LoadBitmap

      - LoadMenu

    The above six API calls are documented with the Graphical User
    Interface API specification.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resource.  For predefined
        resource types, the lpType parameter should be one of the
        following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpName - Points to a null-terminated character string that
        represents the name of the resource.

    wLanguage -  represents the language of the resource.  If this parameter
        is zero then the current language associated with the calling
        thread is used.

Return Value:

    The return value identifies the named resource.  It is NULL if the
    requested resource cannot be found.

--*/


{
    NTSTATUS Status;
    ULONG_PTR IdPath[ 3 ];
    PVOID p;

    IdPath[ 0 ] = 0;
    IdPath[ 1 ] = 0;
    try {
        if ((IdPath[ 0 ] = BaseDllMapResourceIdA( lpType )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            }
        else
        if ((IdPath[ 1 ] = BaseDllMapResourceIdA( lpName )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            }
        else {
            IdPath[ 2 ] = (ULONG_PTR)wLanguage;
            p = NULL;
            Status = LdrFindResource_U( BasepMapModuleHandle( hModule, TRUE ),
                                        IdPath,
                                        3,
                                        (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                                      );
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    //
    // Free any strings allocated by BaseDllMapResourceIdA
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
        }
    else {
        return( (HRSRC)p );
        }
}

HGLOBAL
LoadResource(
    HMODULE hModule,
    HRSRC hResInfo
    )

/*++

Routine Description:

    This function loads a resource identified by the hResInfo parameter
    from the executable file associated with the module specified by the
    hModule parameter.  The function loads the resource into memory only
    if it has not been previously loaded.  Otherwise, it retrieves a
    handle to the existing resource.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    hResInfo - Identifies the desired resource.  This handle is assumed
        to have been returned by the FindResource function.

Return Value:

    The return value identifies the global memory block that contains
    the data associated with the resource.  It is NULL if no such
    resource exists.

--*/

{
    NTSTATUS Status;
    PVOID p;

    try {
        Status = LdrAccessResource( BasepMapModuleHandle( hModule, TRUE ),
                                    (PIMAGE_RESOURCE_DATA_ENTRY)hResInfo,
                                    &p,
                                    (PULONG)NULL
                                  );
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
        }
    else {
        return( (HGLOBAL)p );
        }
}

DWORD
SizeofResource(
    HMODULE hModule,
    HRSRC hResInfo
    )

/*++

Routine Description:

    This function supplies the size (in bytes) of the specified
    resource.

    The value returned may be larger than the actual resource due to
    alignment.  An application should not rely upon this value for the
    exact size of a resource.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    hResInfo - Identifies the desired resource.  This handle is assumed
        to have been returned by the FindResource function.

Return Value:

    The return value specifies the number of bytes in the resource.  It
    is zero if the resource cannot be found.

--*/

{
    NTSTATUS Status;
    ULONG cb;

    try {
        Status = LdrAccessResource( BasepMapModuleHandle( hModule, TRUE ),
                                    (PIMAGE_RESOURCE_DATA_ENTRY)hResInfo,
                                    (PVOID *)NULL,
                                    &cb
                                  );
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( 0 );
        }
    else {
        return( (DWORD)cb );
        }
}

#ifdef _X86_
BOOL
__stdcall
_ResourceCallEnumTypeRoutine(
    ENUMRESTYPEPROCA EnumProc,
    HMODULE hModule,
    LPSTR lpType,
    LONG lParam);
#else
#define _ResourceCallEnumTypeRoutine( EnumProc, hModule, lpType, lParam ) \
    (*EnumProc)(hModule, lpType, lParam)
#endif


BOOL
WINAPI
EnumResourceTypesA(
    HMODULE hModule,
    ENUMRESTYPEPROCA lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the resource type names contained in
    a module.  It enumerates them by passing each type name to the callback
    function pointed to by the lpEnumFunc parameter.

    The EnumResourceTypes function continues to enumerate type names until
    called function returns FALSE or the last type name in the module has
    been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource type names to be enumerated.  A value of NULL
        references the module handle associated with the image file that
        was used to create the current process.

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource type name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource type names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource type
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPSTR lpType,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains the
            resource type names to be enumerated.  A value of NULL
            references the module handle associated with the image file that
            was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource.  For predefined
            resource types, the lpType parameter will be one of the
            following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lParam - Specifies the 32-bit arugment of the EnumResourceTypes
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource type names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    LPSTR lpType;
    LPSTR Buffer;
    ULONG BufferLength;
    ULONG Length;

    DllHandle = BasepMapModuleHandle( hModule, TRUE );
    TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
        RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                      TRUE,
                                      IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                      &i
                                     );
    if (!TopResourceDirectory) {
        BaseSetLastNTError( STATUS_RESOURCE_DATA_NOT_FOUND );
        return FALSE;
        }

    Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                         NULL,
                                         0,
                                         &ResourceDirectory
                                       );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
        }

    Buffer = NULL;
    BufferLength = 0;
    Result = TRUE;
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        for (i=0; i<ResourceDirectory->NumberOfNamedEntries; i++) {
            ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                ((PCHAR)TopResourceDirectory + ResourceDirectoryEntry->NameOffset);
            if ((ULONG)(ResourceNameString->Length+1) >= BufferLength) {
                if (Buffer) {
                    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
                    Buffer = NULL;
                    }

                BufferLength = (ResourceNameString->Length + 64) & ~63;
                Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), BufferLength );
                if (! Buffer) {
                    /* Status will be set by RtlAllocateHeap */
                    Result = FALSE;
                    break;
                    }
                }

            Status = RtlUnicodeToMultiByteN( Buffer,
                                             BufferLength - 1,
                                             &Length,
                                             ResourceNameString->NameString,
                                             ResourceNameString->Length * sizeof( WCHAR )
                                           );

            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError( Status );
                Result = FALSE;
                break;
            }

            Buffer[ Length ] = '\0';

            if (!_ResourceCallEnumTypeRoutine(lpEnumFunc, hModule, (LPSTR)Buffer, lParam )) {
                Result = FALSE;
                break;
                }

            ResourceDirectoryEntry++;
            }

        if (Result) {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                lpType = (LPSTR)ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumTypeRoutine(lpEnumFunc, hModule, lpType, lParam )) {
                    Result = FALSE;
                    break;
                    }

                ResourceDirectoryEntry++;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    if (Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
        }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
    else {
        return Result;
        }
}


#ifdef _X86_
BOOL
__stdcall
_ResourceCallEnumNameRoutine(
    ENUMRESNAMEPROCA EnumProc,
    HMODULE hModule,
    LPCSTR lpType,
    LPSTR lpName,
    LONG lParam);
#else
#define _ResourceCallEnumNameRoutine( EnumProc, hModule, lpType, lpName, lParam ) \
    (*EnumProc)(hModule, lpType, lpName, lParam)
#endif

BOOL
WINAPI
EnumResourceNamesA(
    HMODULE hModule,
    LPCSTR lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the resource names for a specific
    resource type name contained in a module.  It enumerates them by
    passing each resource name and type name to the callback function
    pointed to by the lpEnumFunc parameter.

    The EnumResourceNames function continues to enumerate resource names
    until called function returns FALSE or the last resource name for the
    specified resource type name has been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource names to be enumerated.  A value of NULL references the
        module handle associated with the image file that was used to
        create the current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resources whose names are to be
        enumerated.  For predefined resource types, the lpType parameter
        should be one of the following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPSTR lpType,
        LPSTR lpName,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains
            the resource names to be enumerated.  A value of NULL
            references the module handle associated with the image file
            that was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource being enumerated.
            For predefined resource types, the lpType parameter will be
            one of the following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lpName - Points to a null-terminated character string that
            represents the name of the resource being enumerated.

        lParam - Specifies the 32-bit arugment of the EnumResourceNames
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    ULONG_PTR IdPath[ 1 ];
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    LPSTR lpName;
    PCHAR Buffer;
    ULONG BufferLength;
    ULONG Length;

    if ((IdPath[0] = BaseDllMapResourceIdA (lpType)) == -1) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DllHandle = BasepMapModuleHandle (hModule, TRUE);
    TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
        RtlImageDirectoryEntryToData ((PVOID)DllHandle,
                                      TRUE,
                                      IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                      &i);
    if (!TopResourceDirectory) {
        Status = STATUS_RESOURCE_DATA_NOT_FOUND;
    } else {
        Status = LdrFindResourceDirectory_U ((PVOID)DllHandle,
                                             IdPath,
                                             1,
                                             &ResourceDirectory);
    }

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        BaseDllFreeResourceId (IdPath[ 0 ]);
        return FALSE;
    }

    Buffer = NULL;
    BufferLength = 0;
    Result = TRUE;
    SetLastError( NO_ERROR );
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        for (i=0; i<ResourceDirectory->NumberOfNamedEntries; i++) {
            ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                ((PCHAR)TopResourceDirectory + ResourceDirectoryEntry->NameOffset);
            if ((ULONG)(ResourceNameString->Length+1) >= BufferLength) {
                if (Buffer) {
                    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
                    Buffer = NULL;
                }

                BufferLength = (ResourceNameString->Length + 64) & ~63;
                Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), BufferLength );
                if (Buffer == NULL) {
                    BaseSetLastNTError (STATUS_NO_MEMORY);
                    Result = FALSE;
                    break;
                }
            }

            Status = RtlUnicodeToMultiByteN (Buffer,
                                             BufferLength - 1,
                                             &Length,
                                             ResourceNameString->NameString,
                                             ResourceNameString->Length * sizeof(WCHAR));

            if (!NT_SUCCESS (Status)) {
                BaseSetLastNTError (Status);
                Result = FALSE;
                break;
            }

            Buffer[Length] = '\0';

            if (!_ResourceCallEnumNameRoutine (lpEnumFunc, hModule, lpType, (LPSTR)Buffer, lParam)) {
                Result = FALSE;
                break;
            }

            ResourceDirectoryEntry++;
        }

        if (Result) {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                lpName = (LPSTR)ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumNameRoutine (lpEnumFunc, hModule, lpType, lpName, lParam )) {
                    Result = FALSE;
                    break;
                }

                ResourceDirectoryEntry++;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Result = FALSE;
    }

    if (Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
    }

    //
    // Free any string allocated by BaseDllMapResourceIdA
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );

    return Result;
}


#ifdef _X86_
BOOL
__stdcall
_ResourceCallEnumLangRoutine(
    ENUMRESLANGPROCA EnumProc,
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD wLanguage,
    LONG lParam);
#else
#define _ResourceCallEnumLangRoutine( EnumProc, hModule, lpType, lpName, wLanguage, lParam ) \
    (*EnumProc)(hModule, lpType, lpName, wLanguage, lParam)
#endif

BOOL
WINAPI
EnumResourceLanguagesA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the language specific resources
    contained in a module for a given resource type and name ID.  It
    enumerates them by passing each resource type, name and language to
    the callback function pointed to by the lpEnumFunc parameter.

    The EnumResourceLanguares function continues to enumerate resources
    until called function returns FALSE or the last resource for
    the specified language has been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource names to be enumerated.  A value of NULL references the
        module handle associated with the image file that was used to
        create the current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resources whose names are to be
        enumerated.  For predefined resource types, the lpType parameter
        should be one of the following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpName - Points to a null-terminated character string that
        represents the name of the resource being enumerated.

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPSTR lpType,
        LPSTR lpName,
        WORD  wLanguage,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains
            the resource names to be enumerated.  A value of NULL
            references the module handle associated with the image file
            that was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource being enumerated.
            For predefined resource types, the lpType parameter will be
            one of the following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lpName - Points to a null-terminated character string that
            represents the name of the resource being enumerated.

        wLanguage -  represents the language of the resource.

        lParam - Specifies the 32-bit arugment of the EnumResourceNames
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    ULONG_PTR IdPath[ 2 ];
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    USHORT wLanguage;

    IdPath[ 1 ] = 0;
    if ((IdPath[ 0 ] = BaseDllMapResourceIdA( lpType )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        }
    else
    if ((IdPath[ 1 ] = BaseDllMapResourceIdA( lpName )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        }
    else {
        DllHandle = BasepMapModuleHandle( hModule, TRUE );
        TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                          TRUE,
                                          IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                          &i
                                        );
        if (!TopResourceDirectory) {
            Status = STATUS_RESOURCE_DATA_NOT_FOUND;
            }
        else {
            Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                                 IdPath,
                                                 2,
                                                 &ResourceDirectory
                                               );
            }
        }

    if (!NT_SUCCESS( Status )) {
        BaseDllFreeResourceId( IdPath[ 0 ] );
        BaseDllFreeResourceId( IdPath[ 1 ] );
        BaseSetLastNTError( Status );
        return FALSE;
        }

    Result = TRUE;
    SetLastError( NO_ERROR );
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        if (ResourceDirectory->NumberOfNamedEntries != 0) {
            BaseSetLastNTError( STATUS_INVALID_IMAGE_FORMAT );
            Result = FALSE;
            }
        else {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                wLanguage = ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumLangRoutine(lpEnumFunc, hModule, lpType, lpName, wLanguage, lParam )) {
                    Result = FALSE;
                    break;
                    }

                ResourceDirectoryEntry++;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Result = FALSE;
        }

    //
    // Free any strings allocated by BaseDllMapResourceIdA
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );
    return Result;
}


BOOL
WINAPI
FreeResource(
    HGLOBAL hResData
    )
{
    //
    // Can't fail so return Win 3.x success code.
    //

    return FALSE;
}

LPVOID
WINAPI
LockResource(
    HGLOBAL hResData
    )
{
    return( (LPVOID)hResData );
}


HRSRC
FindResourceW(
    HMODULE hModule,
    LPCWSTR lpName,
    LPCWSTR lpType
    )

/*++

Routine Description:

    This function determines the location of a resource in the specified
    resource file.  The lpName and lpType parameters define the resource
    name and type, respectively.

    If the high-order word of the lpName or lpType parameter is zero,
    the low-order word specifies the integer ID of the name or type of
    the given resource.  Otherwise, the parameters are pointers to
    null-terminated character strings.  If the first character of the
    string is a pound sign (#), the remaining characters represent a
    decimal number that specifies the integer ID of the resource's name
    or type.  For example, the string "#258" represents the integer ID
    258.

    To reduce the amount of memory required for the resources used by an
    application, applications should refer to their resources by integer
    ID instead of by name.

    An application must not call FindResource and the LoadResource
    function to load cursor, icon, or string resources.  Instead, it
    must load these resources by calling the following functions:

      - LoadCursor

      - LoadIcon

      - LoadString

    An application can call FindResource and LoadResource to load other
    predefined resource types.  However, it is recommended that the
    application load the corresponding resources by calling the
    following functions:

      - LoadAccelerators

      - LoadBitmap

      - LoadMenu

    The above six API calls are documented with the Graphical User
    Interface API specification.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpName - Points to a null-terminated character string that
        represents the name of the resource.

    lpType - Points to a null-terminated character string that
        represents the type name of the resource.  For predefined
        resource types, the lpType parameter should be one of the
        following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

Return Value:

    The return value identifies the named resource.  It is NULL if the
    requested resource cannot be found.

--*/


{
    NTSTATUS Status;
    ULONG_PTR IdPath[ 3 ];
    PVOID p;

    IdPath[ 0 ] = 0;
    IdPath[ 1 ] = 0;
    try {
        if ((IdPath[ 0 ] = BaseDllMapResourceIdW( lpType )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            }
        else
        if ((IdPath[ 1 ] = BaseDllMapResourceIdW( lpName )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            }
        else {
            IdPath[ 2 ] = 0;
            p = NULL;
            Status = LdrFindResource_U( BasepMapModuleHandle( hModule, TRUE ),
                                        IdPath,
                                        3,
                                        (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                                      );
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    //
    // Free any strings allocated by BaseDllMapResourceIdW
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
        }
    else {
        return( (HRSRC)p );
        }
}

HRSRC
FindResourceExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD  wLanguage
    )

/*++

Routine Description:

    This function determines the location of a resource in the specified
    resource file.  The lpType, lpName and wLanguage parameters define
    the resource type, name and language respectively.

    If the high-order word of the lpType or lpName parameter
    is zero, the low-order word specifies the integer ID of the type, name
    or language of the given resource.  Otherwise, the parameters are pointers
    to null-terminated character strings.  If the first character of the
    string is a pound sign (#), the remaining characters represent a
    decimal number that specifies the integer ID of the resource's name
    or type.  For example, the string "#258" represents the integer ID
    258.

    If the wLanguage parameter is zero, then the current language
    associated with the calling thread will be used.

    To reduce the amount of memory required for the resources used by an
    application, applications should refer to their resources by integer
    ID instead of by name.

    An application must not call FindResource and the LoadResource
    function to load cursor, icon, or string resources.  Instead, it
    must load these resources by calling the following functions:

      - LoadCursor

      - LoadIcon

      - LoadString

    An application can call FindResource and LoadResource to load other
    predefined resource types.  However, it is recommended that the
    application load the corresponding resources by calling the
    following functions:

      - LoadAccelerators

      - LoadBitmap

      - LoadMenu

    The above six API calls are documented with the Graphical User
    Interface API specification.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resource.  For predefined
        resource types, the lpType parameter should be one of the
        following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpName - Points to a null-terminated character string that
        represents the name of the resource.

    wLanguage -  represents the language of the resource.  If this parameter
        is zero then the current language associated with the calling
        thread is used.

Return Value:

    The return value identifies the named resource.  It is NULL if the
    requested resource cannot be found.

--*/


{
    NTSTATUS Status;
    ULONG_PTR IdPath[ 3 ];
    PVOID p;

    IdPath[ 0 ] = 0;
    IdPath[ 1 ] = 0;
    try {
        if ((IdPath[ 0 ] = BaseDllMapResourceIdW( lpType )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            }
        else
        if ((IdPath[ 1 ] = BaseDllMapResourceIdW( lpName )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            }
        else {
            IdPath[ 2 ] = (ULONG_PTR)wLanguage;
            p = NULL;
            Status = LdrFindResource_U( BasepMapModuleHandle( hModule, TRUE ),
                                      IdPath,
                                      3,
                                      (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                                    );
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    //
    // Free any strings allocated by BaseDllMapResourceIdW
    //

    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
        }
    else {
        return( (HRSRC)p );
        }
}


BOOL
APIENTRY
EnumResourceTypesW(
    HMODULE hModule,
    ENUMRESTYPEPROCW lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the resource type names contained in
    a module.  It enumerates them by passing each type name to the callback
    function pointed to by the lpEnumFunc parameter.

    The EnumResourceTypes function continues to enumerate type names until
    called function returns FALSE or the last type name in the module has
    been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource type names to be enumerated.  A value of NULL
        references the module handle associated with the image file that
        was used to create the current process.

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource type name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource type names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource type
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPWSTR lpType,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains the
            resource type names to be enumerated.  A value of NULL
            references the module handle associated with the image file that
            was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource.  For predefined
            resource types, the lpType parameter will be one of the
            following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lParam - Specifies the 32-bit arugment of the EnumResourceTypes
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource type names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    LPWSTR lpType;
    LPWSTR Buffer;
    ULONG BufferLength;

    DllHandle = BasepMapModuleHandle( hModule, TRUE );
    TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
        RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                      TRUE,
                                      IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                      &i
                                     );
    if (!TopResourceDirectory) {
        BaseSetLastNTError( STATUS_RESOURCE_DATA_NOT_FOUND );
        return FALSE;
        }

    Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                         NULL,
                                         0,
                                         &ResourceDirectory
                                       );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
        }

    Buffer = NULL;
    BufferLength = 0;
    Result = TRUE;
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        for (i=0; i<ResourceDirectory->NumberOfNamedEntries; i++) {
            ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                ((PCHAR)TopResourceDirectory + ResourceDirectoryEntry->NameOffset);
            if ((ULONG)((ResourceNameString->Length+1) * sizeof( WCHAR )) >= BufferLength) {
                if (Buffer) {
                    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
                    Buffer = NULL;
                    }

                BufferLength = ((ResourceNameString->Length * sizeof( WCHAR )) + 64) & ~63;
                Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), BufferLength );
                if (Buffer == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    Result = FALSE;
                    break;
                    }
                }
            RtlMoveMemory( Buffer,
                           ResourceNameString->NameString,
                           ResourceNameString->Length * sizeof( WCHAR )
                         );
            Buffer[ ResourceNameString->Length ] = UNICODE_NULL;

            if (!_ResourceCallEnumTypeRoutine((ENUMRESTYPEPROCA)lpEnumFunc, hModule, (LPSTR)Buffer, lParam )) {
                Result = FALSE;
                break;
                }

            ResourceDirectoryEntry++;
            }

        if (Result) {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                lpType = (LPWSTR)ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumTypeRoutine((ENUMRESTYPEPROCA)lpEnumFunc, hModule, (LPSTR)lpType, lParam )) {
                    Result = FALSE;
                    break;
                    }

                ResourceDirectoryEntry++;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    if (Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
        }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
    else {
        return Result;
        }
}


BOOL
APIENTRY
EnumResourceNamesW(
    HMODULE hModule,
    LPCWSTR lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the resource names for a specific
    resource type name contained in a module.  It enumerates them by
    passing each resource name and type name to the callback function
    pointed to by the lpEnumFunc parameter.

    The EnumResourceNames function continues to enumerate resource names
    until called function returns FALSE or the last resource name for the
    specified resource type name has been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource names to be enumerated.  A value of NULL references the
        module handle associated with the image file that was used to
        create the current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resources whose names are to be
        enumerated.  For predefined resource types, the lpType parameter
        should be one of the following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPWSTR lpType,
        LPWSTR lpName,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains
            the resource names to be enumerated.  A value of NULL
            references the module handle associated with the image file
            that was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource being enumerated.
            For predefined resource types, the lpType parameter will be
            one of the following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lpName - Points to a null-terminated character string that
            represents the name of the resource being enumerated.

        lParam - Specifies the 32-bit arugment of the EnumResourceNames
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    ULONG_PTR IdPath[ 1 ];
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    LPWSTR lpName;
    LPWSTR Buffer;
    ULONG BufferLength;

    if ((IdPath[ 0 ] = BaseDllMapResourceIdW( lpType )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        }
    else {
        DllHandle = BasepMapModuleHandle( hModule, TRUE );
        TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                          TRUE,
                                          IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                          &i
                                        );
        if (!TopResourceDirectory) {
            Status = STATUS_RESOURCE_DATA_NOT_FOUND;
            }
        else {
            Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                                 IdPath,
                                                 1,
                                                 &ResourceDirectory
                                               );
            }
        }

    if (!NT_SUCCESS( Status )) {
        BaseDllFreeResourceId( IdPath[ 0 ] );
        BaseSetLastNTError( Status );
        return FALSE;
        }

    Buffer = NULL;
    BufferLength = 0;
    Result = TRUE;
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        for (i=0; i<ResourceDirectory->NumberOfNamedEntries; i++) {
            ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                ((PCHAR)TopResourceDirectory + ResourceDirectoryEntry->NameOffset);
            if ((ULONG)((ResourceNameString->Length+1) * sizeof( WCHAR )) >= BufferLength) {
                if (Buffer) {
                    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
                    Buffer = NULL;
                    }

                BufferLength = ((ResourceNameString->Length * sizeof( WCHAR )) + 64) & ~63;
                Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), BufferLength );
                if (Buffer == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    Result = FALSE;
                    break;
                    }
                }
            RtlMoveMemory( Buffer,
                           ResourceNameString->NameString,
                           ResourceNameString->Length * sizeof( WCHAR )
                         );
            Buffer[ ResourceNameString->Length ] = UNICODE_NULL;

            if (!_ResourceCallEnumNameRoutine((ENUMRESNAMEPROCA)lpEnumFunc, hModule, (LPSTR)lpType, (LPSTR)Buffer, lParam )) {
                Result = FALSE;
                break;
                }

            ResourceDirectoryEntry++;
            }

        if (Result) {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                lpName = (LPWSTR)ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumNameRoutine((ENUMRESNAMEPROCA)lpEnumFunc, hModule, (LPSTR)lpType, (LPSTR)lpName, lParam )) {
                    Result = FALSE;
                    break;
                    }

                ResourceDirectoryEntry++;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Result = FALSE;
        }

    if (Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
        }

    //
    // Free any string allocated by BaseDllMapResourceIdW
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );

    return Result;
}


BOOL
APIENTRY
EnumResourceLanguagesW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the language specific resources
    contained in a module for a given resource type and name ID.  It
    enumerates them by passing each resource type, name and language to
    the callback function pointed to by the lpEnumFunc parameter.

    The EnumResourceLanguares function continues to enumerate resources
    until called function returns FALSE or the last resource for
    the specified language has been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource names to be enumerated.  A value of NULL references the
        module handle associated with the image file that was used to
        create the current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resources whose names are to be
        enumerated.  For predefined resource types, the lpType parameter
        should be one of the following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpName - Points to a null-terminated character string that
        represents the name of the resource being enumerated.

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPWSTR lpType,
        LPWSTR lpName,
        WORD  wLanguage,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains
            the resource names to be enumerated.  A value of NULL
            references the module handle associated with the image file
            that was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource being enumerated.
            For predefined resource types, the lpType parameter will be
            one of the following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lpName - Points to a null-terminated character string that
            represents the name of the resource being enumerated.

        wLanguage -  represents the language of the resource.

        lParam - Specifies the 32-bit arugment of the EnumResourceNames
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    ULONG_PTR IdPath[ 2 ];
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    USHORT wLanguage;

    IdPath[ 1 ] = 0;
    if ((IdPath[ 0 ] = BaseDllMapResourceIdW( lpType )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        }
    else
    if ((IdPath[ 1 ] = BaseDllMapResourceIdW( lpName )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        }
    else {
        DllHandle = BasepMapModuleHandle( hModule, TRUE );
        TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                          TRUE,
                                          IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                          &i
                                        );
        if (!TopResourceDirectory) {
            Status = STATUS_RESOURCE_DATA_NOT_FOUND;
            }
        else {
            Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                                 IdPath,
                                                 2,
                                                 &ResourceDirectory
                                               );
            }
        }

    if (!NT_SUCCESS( Status )) {
        BaseDllFreeResourceId( IdPath[ 0 ] );
        BaseDllFreeResourceId( IdPath[ 1 ] );
        BaseSetLastNTError( Status );
        return FALSE;
        }

    Result = TRUE;
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        if (ResourceDirectory->NumberOfNamedEntries != 0) {
            BaseSetLastNTError( STATUS_INVALID_IMAGE_FORMAT );
            Result = FALSE;
            }
        else {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                wLanguage = ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumLangRoutine((ENUMRESLANGPROCA)lpEnumFunc, hModule, (LPSTR)lpType, (LPSTR)lpName, wLanguage, lParam )) {
                    Result = FALSE;
                    break;
                    }

                ResourceDirectoryEntry++;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Result = FALSE;
        }

    //
    // Free any strings allocated by BaseDllMapResourceIdW
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    return Result;
}


ULONG_PTR
BaseDllMapResourceIdA(
    LPCSTR lpId
    )
{
    NTSTATUS Status;
    ULONG_PTR Id;
    ULONG ulId;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    PWSTR s;

    try {
        if ((ULONG_PTR)lpId >= LDR_RESOURCE_ID_NAME_MINVAL) {

            if (*lpId == '#') {
                Status = RtlCharToInteger( lpId+1, 10, &ulId );
                Id = ulId;
                if (!NT_SUCCESS( Status ) || (Id & LDR_RESOURCE_ID_NAME_MASK)) {
                    if (NT_SUCCESS( Status )) {
                        Status = STATUS_INVALID_PARAMETER;
                        }
                    BaseSetLastNTError( Status );
                    Id = (ULONG)-1;
                    }
                }
            else {
                RtlInitAnsiString( &AnsiString, lpId );
                Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                                       &AnsiString,
                                                       TRUE
                                                     );
                if (!NT_SUCCESS( Status )){
                    BaseSetLastNTError( Status );
                    Id = (ULONG_PTR)-1;
                    }
                else {
                    s = UnicodeString.Buffer;
                    while (*s != UNICODE_NULL) {
                        *s = RtlUpcaseUnicodeChar( *s );
                        s++;
                        }

                    Id = (ULONG_PTR)UnicodeString.Buffer;
                    }
                }
            }
        else {
            Id = (ULONG_PTR)lpId;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Id =  (ULONG_PTR)-1;
        }
    return Id;
}

ULONG_PTR
BaseDllMapResourceIdW(
    LPCWSTR lpId
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ULONG_PTR Id;
    ULONG ulId;
    PWSTR s;

    try {
        if ((ULONG_PTR)lpId >= LDR_RESOURCE_ID_NAME_MINVAL) {
            if (*lpId == '#') {
                RtlInitUnicodeString( &UnicodeString, lpId+1 );
                Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &ulId );
                Id = ulId;
                if (!NT_SUCCESS( Status ) || Id > LDR_RESOURCE_ID_NAME_MASK) {
                    if (NT_SUCCESS( Status )) {
                        Status = STATUS_INVALID_PARAMETER;
                        }
                    BaseSetLastNTError( Status );
                    Id = (ULONG_PTR)-1;
                    }
                }
            else {
                s = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (wcslen( lpId ) + 1) * sizeof( WCHAR ) );
                if (s == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    Id = (ULONG_PTR)-1;
                    }
                else {
                    Id = (ULONG_PTR)s;

                    while (*lpId != UNICODE_NULL) {
                            *s++ = RtlUpcaseUnicodeChar( *lpId++ );
                            }

                    *s = UNICODE_NULL;
                    }
                }
            }
        else {
            Id = (ULONG_PTR)lpId;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Id =  (ULONG_PTR)-1;
        }

    return Id;
}


VOID
BaseDllFreeResourceId(
    ULONG_PTR Id
    )
{
    UNICODE_STRING UnicodeString;

    if (Id >= LDR_RESOURCE_ID_NAME_MINVAL && Id != -1) {
        UnicodeString.Buffer = (PWSTR)Id;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = 0;
        RtlFreeUnicodeString( &UnicodeString );
        }
}


INT_PTR ReturnMem16Data(
    DWORD dwReserved1,
    DWORD dwReserved2,
    DWORD dwReserved3
    )
{
// Since there's _currently_ no other app we know that this will be useful for, we can
// always return "our" value.

    // Elmo's Preschool Deluxe is looking for free physical or virtual mem.  Give it a
    // Number it will be happy with.
    // Incoming params from Elmo's (in case they're needed one day):
    // dwReserved1 will be 0
    // dwReserved2 will be 1 or 2 (physical/virtual)
    // dwReserved3 will be 0
    return 0x2000;
}


BOOL
UTRegister(
    HMODULE hInst32,
    LPSTR lpszDll16,
    LPSTR lpszInitFunc,
    LPSTR lpszThunkFunc,
    FARPROC *ppfnThunk32Func,
    FARPROC Callback,
    PVOID lpvData
    )
{

    //
    // This function is supposed to return an error code.  VOID happens to work because
    // the stub would just leave EAX alone.  If something happens and EAX starts getting
    // zero'ed out, it'll cause problems and return type here should be changed to int
    // and success should return NON-ZERO.   - bjm 09/98
    //

    // Sure, we could have checked this on a compat bit instead, but the ISV is the
    // Children's Television Workshop people and if they do this silliness in any
    // of their other apps, we'll get those fixed "for free".
    if ( 0 == lstrcmpi( lpszDll16, (LPCSTR)"mem16.dll" ) &&
         0 == lstrcmpi( lpszThunkFunc, (LPCSTR)"GetMemory" ) )
    {
        //
        // Elmo's Preschool Deluxe calls to a 16bit dll they ship just
        // to get physical and virtual mem.  Let's give 'em a pointer to our routine that
        // will give it numbers that makes it happy.
        //
        *ppfnThunk32Func = ReturnMem16Data;
       return(TRUE);
    }

    // Stub this function for King's Quest and Bodyworks 5.0 and other random Win 95 apps.
    return(FALSE);
}


VOID
UTUnRegister(
    HMODULE hInst32
    )
{
    // Stub this function for King's Quest and Bodyworks 5.0 and other random Win 95 apps.
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\pathmisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pathmisc.c

Abstract:

    Win32 misceleneous path functions

Author:

    Mark Lucovsky (markl) 16-Oct-1990

Revision History:

--*/

#include "basedll.h"
#include "apcompat.h"
#include <wow64t.h>

BOOL
IsThisARootDirectory(
    HANDLE RootHandle,
    PUNICODE_STRING FileName OPTIONAL
    )
{
    PFILE_NAME_INFORMATION FileNameInfo;
    WCHAR Buffer[MAX_PATH+sizeof(FileNameInfo)];
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    BOOL rv;

    OBJECT_ATTRIBUTES Attributes;
    HANDLE LinkHandle;
    WCHAR LinkValueBuffer[2*MAX_PATH];
    UNICODE_STRING LinkValue;
    ULONG ReturnedLength;

    rv = FALSE;

    FileNameInfo = (PFILE_NAME_INFORMATION)Buffer;
    if (RootHandle == NULL) {
        Status = STATUS_INVALID_HANDLE;
    } else {
        Status = NtQueryInformationFile (RootHandle,
                                         &IoStatusBlock,
                                         FileNameInfo,
                                         sizeof(Buffer),
                                         FileNameInformation);
    }

    if (NT_SUCCESS (Status)) {
        if ( FileNameInfo->FileName[(FileNameInfo->FileNameLength>>1)-1] == (WCHAR)'\\' ) {
            rv = TRUE;
        }
    }

    if ( !rv ) {

        //
        // See if this is a dos substed drive (or) redirected net drive
        //

        if (ARGUMENT_PRESENT (FileName)) {

            FileName->Length = FileName->Length - sizeof((WCHAR)'\\');

            InitializeObjectAttributes( &Attributes,
                                        FileName,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL
                                      );
            Status = NtOpenSymbolicLinkObject (&LinkHandle,
                                               SYMBOLIC_LINK_QUERY,
                                               &Attributes);
            FileName->Length = FileName->Length + sizeof((WCHAR)'\\');
            if (NT_SUCCESS (Status)) {

                //
                // Now query the link and see if there is a redirection
                //

                LinkValue.Buffer = LinkValueBuffer;
                LinkValue.Length = 0;
                LinkValue.MaximumLength = (USHORT)(sizeof(LinkValueBuffer));
                ReturnedLength = 0;
                Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                    &LinkValue,
                                                    &ReturnedLength
                                                  );
                NtClose( LinkHandle );

                if ( NT_SUCCESS(Status) ) {
                    rv = TRUE;
                }
            }

        }
    }
    return rv;
}


UINT
APIENTRY
GetSystemDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    ANSI thunk to GetSystemDirectoryW

--*/

{
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    ULONG cbAnsiString;
    PUNICODE_STRING WindowsSystemDirectory = &BaseWindowsSystemDirectory;

#ifdef WX86
    if (NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll) {
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
        WindowsSystemDirectory = &BaseWindowsSys32x86Directory;
        }
#endif



    // BaseWindowsSystemDirectory.Length contains the byte
    // count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to
    // get the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS
    // environment, it's definitely WRONG.

    Status = RtlUnicodeToMultiByteSize(&cbAnsiString,
                                       WindowsSystemDirectory->Buffer,
                                       WindowsSystemDirectory->MaximumLength
                                       );
    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }

    if ( (USHORT)uSize < (USHORT)cbAnsiString ) {
        return cbAnsiString;
        }

    AnsiString.MaximumLength = (USHORT)(uSize);
    AnsiString.Buffer = lpBuffer;

    Status = BasepUnicodeStringTo8BitString(
                &AnsiString,
                WindowsSystemDirectory,
                FALSE
                );
    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }
    return AnsiString.Length;
}


UINT
APIENTRY
GetSystemDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the Windows system
    subdirectory.  The system subdirectory contains such files as
    Windows libraries, drivers, and font files.

    The pathname retrieved by this function does not end with a
    backslash unless the system directory is the root directory.  For
    example, if the system directory is named WINDOWS\SYSTEM on drive
    C:, the pathname of the system subdirectory retrieved by this
    function is C:\WINDOWS\SYSTEM.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in bytes) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    PUNICODE_STRING WindowsSystemDirectory = &BaseWindowsSystemDirectory;

#ifdef WX86
    if (NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll) {
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
        WindowsSystemDirectory = &BaseWindowsSys32x86Directory;
        }
#endif

    if ( uSize*2 < WindowsSystemDirectory->MaximumLength ) {
        return WindowsSystemDirectory->MaximumLength/2;
        }
    RtlMoveMemory(
        lpBuffer,
        WindowsSystemDirectory->Buffer,
        WindowsSystemDirectory->Length
        );
    lpBuffer[(WindowsSystemDirectory->Length>>1)] = UNICODE_NULL;
    return WindowsSystemDirectory->Length/2;
}

UINT
APIENTRY
GetSystemWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    ANSI thunk to GetSystemWindowsDirectoryW

--*/

{
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    ULONG cbAnsiString;

    // BaseWindowsDirectory.Length contains the byte
    // count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to
    // get the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS
    // environment, it's definitely WRONG.

    Status = RtlUnicodeToMultiByteSize( &cbAnsiString,
                               BaseWindowsDirectory.Buffer,
                               BaseWindowsDirectory.MaximumLength);
    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }

    if ( (USHORT)uSize < (USHORT)cbAnsiString ) {
        return cbAnsiString;
        }

    AnsiString.MaximumLength = (USHORT)(uSize);
    AnsiString.Buffer = lpBuffer;

    Status = BasepUnicodeStringTo8BitString(
                &AnsiString,
                &BaseWindowsDirectory,
                FALSE
                );
    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }
    return AnsiString.Length;
}

UINT
APIENTRY
GetSystemWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the system Windows directory.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in wchars) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{

    if ( uSize*2 < BaseWindowsDirectory.MaximumLength ) {
        return BaseWindowsDirectory.MaximumLength/2;
        }
    RtlMoveMemory(
        lpBuffer,
        BaseWindowsDirectory.Buffer,
        BaseWindowsDirectory.Length
        );
    lpBuffer[(BaseWindowsDirectory.Length>>1)] = UNICODE_NULL;
    return BaseWindowsDirectory.Length/2;
}

UINT
APIENTRY
GetSystemWow64DirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the system wow64 directory.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in bytes) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/
{
#if ! defined(BUILD_WOW6432) && ! defined(_WIN64)

  SetLastError(ERROR_CALL_NOT_IMPLEMENTED);

  return 0;

#else // BUILD_WOW6432 || _WIN64

  const CHAR syswowdir[] = "\\" WOW64_SYSTEM_DIRECTORY;
  UINT Available, Needed;

  if (uSize < sizeof(syswowdir)) {

    // We don't even have enough room to hold the syswow64
    // subdirectory component, much less the whole path.  Pass in a
    // zero length so that we get back the length needed.
    Available = 0;

  } else {

    // We might have enough room; decrement the size passed in by the
    // amount of overhead we'll use.
    Available = uSize - sizeof(syswowdir) + 1 /* NULL compensation */;

  }

  Needed = GetSystemWindowsDirectoryA(lpBuffer, Available);

  if (Needed == 0) {

    // The call failed -- just return zero.
    return 0;

  }

  if (Needed <= Available) {

    // We had enough buffer space, even with our overhead; we can go
    // ahead and tack on the syswow64 directory name.

    RtlMoveMemory(lpBuffer + Needed,
          syswowdir,
          sizeof(syswowdir));
  }

  return (Needed + sizeof(syswowdir) - 1);

#endif // BUILD_WOW6432 || _WIN64
}

UINT
APIENTRY
GetSystemWow64DirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the system wow64 directory.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in wchars) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/
{
#if ! defined(BUILD_WOW6432) && ! defined(_WIN64)

  SetLastError(ERROR_CALL_NOT_IMPLEMENTED);

  return 0;

#else // BUILD_WOW6432 || _WIN64

  const WCHAR syswowdir[] = L"\\" WOW64_SYSTEM_DIRECTORY_U;
  UINT Available, Needed;
  const UINT SysWCharSize = sizeof(syswowdir) / sizeof(WCHAR);

  if (uSize < SysWCharSize) {

    // We don't even have enough room to hold the syswow64
    // subdirectory component, much less the whole path.  Pass in a
    // zero length so that we get back the length needed.
    Available = 0;

  } else {

    // We might have enough room; decrement the size passed in by the
    // amount of overhead we'll use.
    Available = uSize - SysWCharSize + 1 /* NULL compensation */;

  }

  Needed = GetSystemWindowsDirectoryW(lpBuffer, Available);

  if (Needed == 0) {

    // The call failed -- just return zero.
    return 0;

  }

  if (Needed <= Available) {

    // We had enough buffer space, even with our overhead; we can go
    // ahead and tack on the syswow64 directory name.

    RtlMoveMemory(lpBuffer + Needed,
          syswowdir,
          sizeof(syswowdir));
  }

  return (Needed + SysWCharSize - 1);

#endif // BUILD_WOW6432 || _WIN64
}


UINT
APIENTRY
GetWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:


--*/

{

    if (gpTermsrvGetWindowsDirectoryA) {

        //
        //  If Terminal Server get the Per User Windows Directory
        //

        UINT retval;
        if (retval = gpTermsrvGetWindowsDirectoryA(lpBuffer, uSize)) {
            return retval;
        }
    }


    return GetSystemWindowsDirectoryA(lpBuffer,uSize);
}

UINT
APIENTRY
GetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the Windows directory.  The
    Windows directory contains such files as Windows applications,
    initialization files, and help files.
    425
    The pathname retrieved by this function does not end with a
    backslash unless the Windows directory is the root directory.  For
    example, if the Windows directory is named WINDOWS on drive C:, the
    pathname of the Windows directory retrieved by this function is
    C:\WINDOWS If Windows was installed in the root directory of drive
    C:, the pathname retrieved by this function is C:\

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in bytes) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    if (gpTermsrvGetWindowsDirectoryW) {
        //
        //  If Terminal Server get the Per User Windows Directory
        //

        UINT retval;
        if (retval = gpTermsrvGetWindowsDirectoryW(lpBuffer, uSize)) {
            return retval;
        }
    }

    return GetSystemWindowsDirectoryW(lpBuffer,uSize);

}



UINT
APIENTRY
GetDriveTypeA(
    LPCSTR lpRootPathName
    )

/*++

Routine Description:

    ANSI thunk to GetDriveTypeW

--*/

{
    PUNICODE_STRING Unicode;
    LPCWSTR lpRootPathName_U;

    if (ARGUMENT_PRESENT(lpRootPathName)) {
        Unicode = Basep8BitStringToStaticUnicodeString( lpRootPathName );
        if (Unicode == NULL) {
            return 1;
        }

        lpRootPathName_U = (LPCWSTR)Unicode->Buffer;
        }
    else {
        lpRootPathName_U = NULL;
        }

    return GetDriveTypeW(lpRootPathName_U);
}

UINT
APIENTRY
GetDriveTypeW(
    LPCWSTR lpRootPathName
    )

/*++

Routine Description:

    This function determines whether a disk drive is removeable, fixed,
    remote, CD ROM, or a RAM disk.

    The return value is zero if the function cannot determine the drive
    type, or 1 if the specified root directory does not exist.

Arguments:

    lpRootPathName - An optional parameter, that if specified, supplies
        the root directory of the disk whose drive type is to be
        determined.  If this parameter is not specified, then the root
        of the current directory is used.

Return Value:

    The return value specifies the type of drive.  It can be one of the
    following values:

    DRIVE_UNKNOWN - The drive type can not be determined.

    DRIVE_NO_ROOT_DIR - The root directory does not exist.

    DRIVE_REMOVABLE - Disk can be removed from the drive.

    DRIVE_FIXED - Disk cannot be removed from the drive.

    DRIVE_REMOTE - Drive is a remote (network) drive.

    DRIVE_CDROM - Drive is a CD rom drive.

    DRIVE_RAMDISK - Drive is a RAM disk.

--*/

{
    WCHAR wch;
    ULONG n, DriveNumber;
    WCHAR DefaultPath[MAX_PATH];
    PWSTR RootPathName;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName, volumeNameString;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    DWORD ReturnValue;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;
    WCHAR volumeName[MAX_PATH];

    if (!ARGUMENT_PRESENT(lpRootPathName)) {
        n = RtlGetCurrentDirectory_U(sizeof(DefaultPath), DefaultPath);
        RootPathName = DefaultPath;
        if (n > (3 * sizeof(WCHAR))) {
            RootPathName[3]=UNICODE_NULL;
            }
        }
    else
    if (lpRootPathName == (PWSTR)IntToPtr(0xFFFFFFFF)) {
        //
        // Hack to be compatible with undocumented feature of old
        // implementation.
        //

        return 0;
        }
    else {
        //
        // If input string is just C: then convert to C:\ so it does
        // not default to current directory which may or may not be
        // at the root.
        //
        RootPathName = (PWSTR)lpRootPathName;
        if (wcslen( RootPathName ) == 2) {
            wch = RtlUpcaseUnicodeChar( *RootPathName );
            if (wch >= (WCHAR)'A' &&
                wch <= (WCHAR)'Z' &&
                RootPathName[1] == (WCHAR)':'
               ) {
                RootPathName = wcscpy(DefaultPath, lpRootPathName);
                RootPathName[2] = (WCHAR)'\\';
                RootPathName[3] = UNICODE_NULL;
                }
            }
        }

    //
    // If input string is of the form C:\ then look in the drive letter
    // cache maintained by the kernel to see if the drive type is already
    // known.
    //
    wch = RtlUpcaseUnicodeChar( *RootPathName );
    if (wch >= (WCHAR)'A' &&
        wch <= (WCHAR)'Z' &&
        RootPathName[1]==(WCHAR)':' &&
        RootPathName[2]==(WCHAR)'\\' &&
        RootPathName[3]==UNICODE_NULL
       ) {
        Status = NtQueryInformationProcess( NtCurrentProcess(),
                                            ProcessDeviceMap,
                                            &ProcessDeviceMapInfo.Query,
                                            sizeof( ProcessDeviceMapInfo.Query ),
                                            NULL
                                          );
        if (!NT_SUCCESS( Status )) {
            RtlZeroMemory( &ProcessDeviceMapInfo, sizeof( ProcessDeviceMapInfo ) );
            }

        DriveNumber = wch - (WCHAR)'A';
        if (ProcessDeviceMapInfo.Query.DriveMap & (1 << DriveNumber)) {
            switch ( ProcessDeviceMapInfo.Query.DriveType[ DriveNumber ] ) {
                case DOSDEVICE_DRIVE_UNKNOWN:
                    return DRIVE_UNKNOWN;

                case DOSDEVICE_DRIVE_REMOVABLE:
                    return DRIVE_REMOVABLE;

                case DOSDEVICE_DRIVE_FIXED:
                    return DRIVE_FIXED;

                case DOSDEVICE_DRIVE_REMOTE:
                    return DRIVE_REMOTE;

                case DOSDEVICE_DRIVE_CDROM:
                    return DRIVE_CDROM;

                case DOSDEVICE_DRIVE_RAMDISK:
                    return DRIVE_RAMDISK;
                }
            }
        }


    //
    // Either not C:\ or kernel does not know the drive type, so try to
    // calculate the drive type by opening the root directory and doing
    // a query volume information.
    //


    //
    // If curdir is a UNC connection, and default path is used,
    // the RtlGetCurrentDirectory logic is wrong, so throw it away.
    //

    if (!ARGUMENT_PRESENT(lpRootPathName)) {
        RootPathName = L"\\";
        }

    TranslationStatus = RtlDosPathNameToNtPathName_U( RootPathName,
                                                      &FileName,
                                                      NULL,
                                                      NULL
                                                    );
    if (!TranslationStatus) {
        return DRIVE_NO_ROOT_DIR;
        }
    FreeBuffer = FileName.Buffer;

    //
    // Check to make sure a root was specified
    //

    if (FileName.Buffer[(FileName.Length >> 1)-1] != '\\') {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        return DRIVE_NO_ROOT_DIR;
        }

    FileName.Length -= 2;
    InitializeObjectAttributes( &Obja,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    //
    // Open the file
    //
    Status = NtOpenFile( &Handle,
                         (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                       );

    //
    //
    // substd drives are really directories, so if we are dealing with one
    // of them, bypass this
    //

    if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {

        if (BasepGetVolumeNameFromReparsePoint(lpRootPathName, volumeName,
                                               MAX_PATH, NULL)) {

            RtlInitUnicodeString(&volumeNameString, volumeName);

            volumeNameString.Buffer[1] = '?';
            volumeNameString.Length -= sizeof(WCHAR);

            InitializeObjectAttributes( &Obja,
                                        &volumeNameString,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL
                                      );

            }

            Status = NtOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT
                        );
        }

    else {

        //
        // check for substed drives another way just in case
        //

        FileName.Length = FileName.Length + sizeof((WCHAR)'\\');
        if (!IsThisARootDirectory(NULL,&FileName) ) {
            FileName.Length = FileName.Length - sizeof((WCHAR)'\\');
            if (NT_SUCCESS(Status)) {
                NtClose(Handle);
                }
            Status = NtOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT
                        );
            }
        }
    RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
    if (!NT_SUCCESS( Status )) {
        return DRIVE_NO_ROOT_DIR;
        }

    //
    // Determine if this is a network or disk file system. If it
    // is a disk file system determine if this is removable or not
    //

    Status = NtQueryVolumeInformationFile( Handle,
                                           &IoStatusBlock,
                                           &DeviceInfo,
                                           sizeof(DeviceInfo),
                                           FileFsDeviceInformation
                                         );
    if (!NT_SUCCESS( Status )) {
        ReturnValue = DRIVE_UNKNOWN;
        }
    else
    if (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) {
        ReturnValue = DRIVE_REMOTE;
        }
    else {
        switch (DeviceInfo.DeviceType) {

            case FILE_DEVICE_NETWORK:
            case FILE_DEVICE_NETWORK_FILE_SYSTEM:
                ReturnValue = DRIVE_REMOTE;
                break;

            case FILE_DEVICE_CD_ROM:
            case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
                ReturnValue = DRIVE_CDROM;
                break;

            case FILE_DEVICE_VIRTUAL_DISK:
                ReturnValue = DRIVE_RAMDISK;
                break;

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:

                if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                    ReturnValue = DRIVE_REMOVABLE;
                    }
                else {
                    ReturnValue = DRIVE_FIXED;
                    }
                break;

            default:
                ReturnValue = DRIVE_UNKNOWN;
                break;
            }
        }

    NtClose( Handle );
    return ReturnValue;
}

DWORD
APIENTRY
SearchPathA(
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    )

/*++

Routine Description:

    ANSI thunk to SearchPathW

--*/

{

    UNICODE_STRING xlpPath;
    PUNICODE_STRING Unicode;
    UNICODE_STRING xlpExtension;
    PWSTR xlpBuffer;
    DWORD ReturnValue;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    PWSTR FilePart;
    PWSTR *FilePartPtr;

    if ( ARGUMENT_PRESENT(lpFilePart) ) {
        FilePartPtr = &FilePart;
        }
    else {
        FilePartPtr = NULL;
        }

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return 0;
    }

    if ( ARGUMENT_PRESENT(lpExtension) ) {

        if (!Basep8BitStringToDynamicUnicodeString( &xlpExtension, lpExtension )) {
            return 0;
        }

    } else {
        xlpExtension.Buffer = NULL;
    }

    if ( ARGUMENT_PRESENT(lpPath) ) {

        if (!Basep8BitStringToDynamicUnicodeString( &xlpPath, lpPath )) {
            if ( ARGUMENT_PRESENT(lpExtension) ) {
                RtlFreeUnicodeString(&xlpExtension);
            }
            return 0;
        }
    } else {
        xlpPath.Buffer = NULL;
    }

    xlpBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), nBufferLength<<1);
    if ( !xlpBuffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        ReturnValue = 0;
        goto bail0;
        }
    ReturnValue = SearchPathW(
                    xlpPath.Buffer,
                    Unicode->Buffer,
                    xlpExtension.Buffer,
                    nBufferLength,
                    xlpBuffer,
                    FilePartPtr
                    );
    //
    // === DBCS modification note [takaok] ===
    //
    // SearchPathW retruns:
    //
    //   buffer size needed(including null terminator) if buffer size is too small.
    //   number of characters( not including null terminator) if buffer size is enougth
    //
    // This means SearchPathW never returns value which is equal to nBufferLength.
    //

    if ( ReturnValue > nBufferLength ) {
        //
        // To know the ansi buffer size needed, we should get all of
        // unicode string.
        //
        RtlFreeHeap(RtlProcessHeap(), 0,xlpBuffer);
        xlpBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG( TMP_TAG ),
                                    ReturnValue * sizeof(WCHAR));
        if ( !xlpBuffer ) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            goto bail0;
        }
        ReturnValue = SearchPathW(
                        xlpPath.Buffer,
                        Unicode->Buffer,
                        xlpExtension.Buffer,
                        ReturnValue,
                        xlpBuffer,
                        FilePartPtr
                        );
        if ( ReturnValue > 0 ) {
            //
            // We called SearchPathW with the enough size of buffer.
            // So, ReturnValue is the size of the path not including the
            // terminating null character.
            //
            Status = RtlUnicodeToMultiByteSize( &ReturnValue,
                                       xlpBuffer,
                                       ReturnValue * sizeof(WCHAR));
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnValue = 0;
            }
            else {
                ReturnValue += 1;
            }
        }
    } else if ( ReturnValue > 0 ) {

        INT AnsiByteCount;

        //
        // We have unicode string. We need to compute the ansi byte count
        // of the string.
        //
        // ReturnValue   : unicode character count not including null terminator
        // AnsiByteCount : ansi byte count not including null terminator
        //
        Status = RtlUnicodeToMultiByteSize( &AnsiByteCount,
                                   xlpBuffer,
                                   ReturnValue * sizeof(WCHAR) );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            ReturnValue = 0;
            }
        else {
            if ( AnsiByteCount < (INT)nBufferLength ) {
            //
            // The string (including null terminator) fits to the buffer
            //
                Status = RtlUnicodeToMultiByteN ( lpBuffer,
                                                  nBufferLength - 1,
                                                  &AnsiByteCount,
                                                  xlpBuffer,
                                                  ReturnValue * sizeof(WCHAR)
                                                );
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnValue = 0;
                }
                else {

                    lpBuffer[ AnsiByteCount ] = '\0';

                    //
                    // The return value is the byte count copied to the buffer
                    // not including the terminating null character.
                    //
                    ReturnValue = AnsiByteCount;


                    if ( ARGUMENT_PRESENT(lpFilePart) ) {
                        if ( FilePart == NULL ) {
                            *lpFilePart = NULL;
                        } else {

                            INT PrefixLength;

                            PrefixLength = (INT)(FilePart - xlpBuffer);
                            Status = RtlUnicodeToMultiByteSize( &PrefixLength,
                                                       xlpBuffer,
                                                       PrefixLength * sizeof(WCHAR));
                            if ( !NT_SUCCESS(Status) ) {
                                BaseSetLastNTError(Status);
                                ReturnValue = 0;
                            }
                            else {
                                *lpFilePart = lpBuffer + PrefixLength;
                            }
                        }
                    }
                }

            } else {
            //
            // We should return the size of the buffer required to
            // hold the path. The size should include the
            // terminating null character.
            //
                ReturnValue = AnsiByteCount + 1;

            }
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0,xlpBuffer);
bail0:
    if ( ARGUMENT_PRESENT(lpExtension) ) {
        RtlFreeUnicodeString(&xlpExtension);
        }

    if ( ARGUMENT_PRESENT(lpPath) ) {
        RtlFreeUnicodeString(&xlpPath);
        }
    return ReturnValue;
}



#ifdef WX86

ULONG
GetFullPathNameWithWx86Override(
    PCWSTR lpFileName,
    ULONG nBufferLength,
    PWSTR lpBuffer,
    PWSTR *lpFilePart
    )
{
    UNICODE_STRING FullPathName, PathUnicode, Wx86PathName;
    PUNICODE_STRING FoundFileName;
    RTL_PATH_TYPE PathType;
    PWSTR FilePart;
    ULONG Length, LengthPath;
    ULONG  PathNameLength;

    FullPathName.Buffer = NULL;
    Wx86PathName.Buffer = NULL;

    if (lpFilePart) {
        *lpFilePart = NULL;
        }

    FullPathName.MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR)) + sizeof(WCHAR);
    FullPathName.Length = 0;
    FullPathName.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                          MAKE_TAG( TMP_TAG ),
                                          FullPathName.MaximumLength
                                          );
    if (!FullPathName.Buffer) {
        PathNameLength = 0;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto WDOExitCleanup;
        }

    FoundFileName = &FullPathName;
    PathNameLength = RtlGetFullPathName_U(lpFileName,
                                          FullPathName.MaximumLength,
                                          FullPathName.Buffer,
                                          &FilePart
                                          );

    if (!PathNameLength || PathNameLength >= FullPathName.MaximumLength) {
        PathNameLength = 0;
        goto WDOExitCleanup;
        }

    FullPathName.Length = (USHORT)PathNameLength;


    PathUnicode = FullPathName;
    PathUnicode.Length = (USHORT)((ULONG_PTR)FilePart -
                                  (ULONG_PTR)FullPathName.Buffer);

    PathUnicode.Length -= sizeof(WCHAR);
    if (!RtlEqualUnicodeString(&PathUnicode, &BaseWindowsSystemDirectory, TRUE)) {
        goto WDOExitCleanup;
        }


    Wx86PathName.MaximumLength = BaseWindowsSys32x86Directory.Length +
                                 FullPathName.Length - PathUnicode.Length +
                                 2*sizeof(WCHAR);
    Wx86PathName.Length = 0;
    Wx86PathName.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                          MAKE_TAG( TMP_TAG ),
                                          Wx86PathName.MaximumLength
                                          );

    if (!Wx86PathName.Buffer) {
        goto WDOExitCleanup;
        }

    RtlCopyUnicodeString(&Wx86PathName, &BaseWindowsSys32x86Directory);
    Length = Wx86PathName.Length + sizeof(WCHAR);
    RtlAppendUnicodeToString (&Wx86PathName, FilePart - 1);
    if (RtlDoesFileExists_U(Wx86PathName.Buffer)) {
        FoundFileName = &Wx86PathName;
        FilePart = Wx86PathName.Buffer + Length/sizeof(WCHAR);
        }



WDOExitCleanup:

    if (PathNameLength) {
        if (FoundFileName->Length >= nBufferLength) {
            PathNameLength = FoundFileName->Length + sizeof(WCHAR);
            }
        else {
            RtlMoveMemory(lpBuffer,
                          FoundFileName->Buffer,
                          FoundFileName->Length + sizeof(WCHAR)
                          );

            PathNameLength = FoundFileName->Length;
            Length = (ULONG)(FilePart - FoundFileName->Buffer);

            if (lpFilePart) {
                *lpFilePart = lpBuffer + Length/sizeof(WCHAR);
                }
            }
        }


    if (FullPathName.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, FullPathName.Buffer);
        }

    if (Wx86PathName.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, Wx86PathName.Buffer);
        }

    return PathNameLength;

}
#endif










DWORD
APIENTRY
SearchPathW(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )

/*++

Routine Description:

    This function is used to search for a file specifying a search path
    and a filename.  It returns with a fully qualified pathname of the
    found file.

    This function is used to locate a file using the specified path.  If
    the file is found, its fully qualified pathname is returned.  In
    addition to this, it calculates the address of the file name portion
    of the fully qualified pathname.

Arguments:

    lpPath - An optional parameter, that if specified, supplies the
        search path to be used when locating the file.  If this
        parameter is not specified, the default windows search path is
        used.  The default path is:

          - The current directory

          - The windows directory

          - The windows system directory

          - The directories listed in the path environment variable

    lpFileName - Supplies the file name of the file to search for.

    lpExtension - An optional parameter, that if specified, supplies an
        extension to be added to the filename when doing the search.
        The extension is only added if the specified filename does not
        end with an extension.

    nBufferLength - Supplies the length in characters of the buffer that
        is to receive the fully qualified path.

    lpBuffer - Returns the fully qualified pathname corresponding to the
        file that was found.

    lpFilePart - Returns the address of the last component of the fully
        qualified pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    UNICODE_STRING Path;
    UNICODE_STRING FileName;
    UNICODE_STRING DefaultExtension;
    UNICODE_STRING CallersBuffer;
    LPWSTR AllocatedPath = NULL;
    RTL_PATH_TYPE PathType;
    SIZE_T BytesRequired = 0;
    SIZE_T FilePartPrefixCch = 0;
    NTSTATUS Status;
    DWORD dwReturnValue = 0;

    //
    //  The guts of this function are now in common ntdll code; however the win32 search
    //  path has a few interesting differences from the ntdll search path code.  First, it
    //  does not search the path if the filename is ".\foo" or "..\foo" and second, when the
    //  filename passed in is not a relative path but the file is not found, the default
    //  extension is applied regardless of whether the existing filename has an extension.
    //
    //  These flags enable those feature-compatibility modes.
    //
    ULONG SearchPathFlags =
        RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH |
        RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION;

    if (lpFilePart != NULL)
        *lpFilePart = NULL;

    Path.Buffer = NULL;

    RtlInitUnicodeString(&FileName, lpFileName);

    //
    // trim trailing spaces, and then check for a real filelength
    // if length is 0 (NULL, "", or " ") passed in then abort the
    // search
    //

    while ((FileName.Length >= sizeof(WCHAR)) &&
           (FileName.Buffer[(FileName.Length / sizeof(WCHAR)) - 1] == L' '))
        FileName.Length -= sizeof(WCHAR);

    if (FileName.Length == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    RtlInitUnicodeString(&DefaultExtension, lpExtension);

    if ( !ARGUMENT_PRESENT(lpPath) ) {
        SIZE_T Cch;

        Path.Buffer = BaseComputeProcessSearchPath();
        if (Path.Buffer == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }

        Cch = lstrlenW(Path.Buffer);

        if (Cch > UNICODE_STRING_MAX_CHARS) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto Exit;
        }

        Path.Length = (USHORT) (Cch * sizeof(WCHAR));
        Path.MaximumLength = Path.Length;
        SearchPathFlags |= RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION;
    } else {
        Status = RtlInitUnicodeStringEx(&Path, lpPath);
        if (NT_ERROR(Status)) {
            BaseSetLastNTError(Status);
            goto Exit;
        }
    }

    CallersBuffer.Length = 0;

    if (nBufferLength > UNICODE_STRING_MAX_CHARS) {
        CallersBuffer.MaximumLength = UNICODE_STRING_MAX_BYTES;
    } else {
        CallersBuffer.MaximumLength = (USHORT) (nBufferLength * sizeof(WCHAR));
    }
    CallersBuffer.Buffer = lpBuffer;

    Status = RtlDosSearchPath_Ustr(
        SearchPathFlags,
        &Path,
        &FileName,
        &DefaultExtension,
        &CallersBuffer,
        NULL,               // dynamicstring
        NULL,               // fullfilenameout
        &FilePartPrefixCch,
        &BytesRequired);
    if (NT_ERROR(Status)) {

#if DBG
        // Don't bother with debug spew for the two common expected cases.
        if ((Status != STATUS_NO_SUCH_FILE) && (Status != STATUS_BUFFER_TOO_SMALL)) {
            DbgPrint("%s on file %wZ failed; NTSTATUS = %08lx\n", __FUNCTION__, &FileName, Status);
            DbgPrint("   Path = %wZ\n", &Path);
        }
#endif // DBG

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            SIZE_T CchRequired = BytesRequired / sizeof(WCHAR);
            if (CchRequired > 0xffffffff) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                goto Exit;
            }
            dwReturnValue = (DWORD) CchRequired;
            goto Exit;
        }

        // Only set the last error if it wasn't an insufficient buffer; this is just preserving
        // Windows 2000 behavior.
        BaseSetLastNTError(Status);
        goto Exit;
    }

#ifdef WX86
    if (UseKnownWx86Dll) {
        WCHAR TempBuffer[MAX_PATH];

        RtlCopyMemory(TempBuffer, lpBuffer, CallersBuffer.Length);
        TempBuffer[CallersBuffer.Length / sizeof(WCHAR)] = UNICODE_NULL;

        dwReturnValue = GetFullPathNameWithWx86Override(
                 TempBuffer,
                 nBufferLength,
                 lpBuffer,
                 lpFilePart
                 );
        goto Exit;

    } else if (lpFilePart != NULL) {
        *lpFilePart = lpBuffer + FilePartPrefixCch;
    }
#else
    if (lpFilePart != NULL) {
        *lpFilePart = lpBuffer + FilePartPrefixCch;
    }
#endif // WX86

    dwReturnValue = CallersBuffer.Length / sizeof(WCHAR);

Exit:
    if ((Path.Buffer != lpPath) && (Path.Buffer != NULL))
        RtlFreeHeap(RtlProcessHeap(), 0, Path.Buffer);

    return dwReturnValue;
}


DWORD
APIENTRY
GetTempPathA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )

/*++

Routine Description:

    ANSI thunk to GetTempPathW

--*/

{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG  cbAnsiString;

    UnicodeString.MaximumLength = (USHORT)((nBufferLength<<1)+sizeof(UNICODE_NULL));
    UnicodeString.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                UnicodeString.MaximumLength
                                );
    if ( !UnicodeString.Buffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
        }
    UnicodeString.Length = (USHORT)GetTempPathW(
                                        (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2,
                                        UnicodeString.Buffer
                                        )*2;
    if ( UnicodeString.Length > (USHORT)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL)) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);

        //
        // given buffer size is too small.
        // allocate enough size of buffer and try again
        //
        // we need to get entire unicode temporary path
        // otherwise we can't figure out the exact length
        // of corresponding ansi string (cbAnsiString).

        UnicodeString.Buffer = RtlAllocateHeap ( RtlProcessHeap(),
                                                 MAKE_TAG( TMP_TAG ),
                                                 UnicodeString.Length+ sizeof(UNICODE_NULL));
        if ( !UnicodeString.Buffer ) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return 0;
            }

        UnicodeString.Length = (USHORT)GetTempPathW(
                                     (DWORD)(UnicodeString.Length)/2,
                                     UnicodeString.Buffer) * 2;
        Status = RtlUnicodeToMultiByteSize( &cbAnsiString,
                                            UnicodeString.Buffer,
                                            UnicodeString.Length );
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            BaseSetLastNTError(Status);
            return 0;
            }
        else if ( nBufferLength <= cbAnsiString ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            return cbAnsiString + sizeof(ANSI_NULL);
            }
        }
    AnsiString.Buffer = lpBuffer;
    AnsiString.MaximumLength = (USHORT)(nBufferLength+1);
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }
    return AnsiString.Length;
}

DWORD
APIENTRY
GetTempPathW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )
/*++

Routine Description:

    This function is used to return the pathname of the directory that
    should be used to create temporary files.

Arguments:

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the temporary file path.

    lpBuffer - Returns the pathname of the directory that should be used
        to create temporary files in.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/
{
    return BasepGetTempPathW(0, nBufferLength, lpBuffer);
}

DWORD
APIENTRY
BasepGetTempPathW(
    ULONG  Flags,
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )

/*++

Routine Description:

    This function is used to return the pathname of the directory that
    should be used to create temporary files.

Arguments:

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the temporary file path.

    lpBuffer - Returns the pathname of the directory that should be used
        to create temporary files in.

    Flags -

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{

    DWORD Length;
    BOOLEAN AddTrailingSlash;
    UNICODE_STRING EnvironmentValue;
    NTSTATUS Status;
    LPWSTR Name;
    ULONG Position;

    if (
        (Flags & ~BASEP_GET_TEMP_PATH_PRESERVE_TEB) != 0
        ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_1);
        return 0;
    }

    //
    // Some apps don't work with the new long path for the temp directory
    //

    if (APPCOMPATFLAG(KACF_GETTEMPPATH)) {

        #define OLD_TEMP_PATH       L"c:\\temp\\"
        #define OLD_TEMP_PATH_SIZE  (sizeof(OLD_TEMP_PATH) / sizeof(WCHAR))

        BOOL bRet;

        //
        // If there isn't enough space provided in the buffer return
        // the desired size.
        //

        if (nBufferLength < OLD_TEMP_PATH_SIZE) {
            return OLD_TEMP_PATH_SIZE;
        }

        wcscpy(lpBuffer, OLD_TEMP_PATH);

        //
        // Use the correct drive letter
        //

        lpBuffer[0] = BaseWindowsDirectory.Buffer[0];

        bRet = CreateDirectoryW(lpBuffer, NULL);

        if (!bRet) {

            if (GetLastError() != ERROR_ALREADY_EXISTS)
                return 0;
        }

        return OLD_TEMP_PATH_SIZE - 1;
    }

    nBufferLength *= 2;
    EnvironmentValue = NtCurrentTeb()->StaticUnicodeString;
    if (Flags & BASEP_GET_TEMP_PATH_PRESERVE_TEB) {
        EnvironmentValue.Buffer = (PWSTR)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), EnvironmentValue.MaximumLength);
        if (EnvironmentValue.Buffer == NULL) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return 0;
        }
    }
    __try {

        AddTrailingSlash = FALSE;

        Status = RtlQueryEnvironmentVariable_U(NULL,&BaseTmpVariableName,&EnvironmentValue);
        if ( !NT_SUCCESS(Status) ) {
            Status = RtlQueryEnvironmentVariable_U(NULL,&BaseTempVariableName,&EnvironmentValue);
            if ( !NT_SUCCESS(Status) ) {
                Status = RtlQueryEnvironmentVariable_U(NULL,&BaseUserProfileVariableName,&EnvironmentValue);
                }
            }

        if ( NT_SUCCESS(Status) ) {
            Name = EnvironmentValue.Buffer;
            if ( Name[(EnvironmentValue.Length>>1)-1] != (WCHAR)'\\' ) {
                AddTrailingSlash = TRUE;
                }
            }
        else {
            Name = BaseWindowsDirectory.Buffer;
            if ( Name[(BaseWindowsDirectory.Length>>1)-1] != (WCHAR)'\\' ) {
                AddTrailingSlash = TRUE;
                }
            }

        Length = RtlGetFullPathName_U(
                    Name,
                    nBufferLength,
                    lpBuffer,
                    NULL
                    );
        Position = Length>>1;

        //
        // Make sure there is room for a trailing back slash
        //

        if ( Length && Length < nBufferLength ) {
            if ( lpBuffer[Position-1] != '\\' ) {
                if ( Length+sizeof((WCHAR)'\\') < nBufferLength ) {
                    lpBuffer[Position] = (WCHAR)'\\';
                    lpBuffer[Position+1] = UNICODE_NULL;
                    return (Length+sizeof((WCHAR)'\\'))/2;
                    }
                else {
                    return (Length+sizeof((WCHAR)'\\')+sizeof(UNICODE_NULL))/2;
                    }
                }
            else {
                return Length/2;
                }
            }
        else {
            if ( AddTrailingSlash ) {
                Length += sizeof((WCHAR)'\\');
                }
            return Length/2;
            }
    }
    __finally {
        if (Flags & BASEP_GET_TEMP_PATH_PRESERVE_TEB) {
            RtlFreeHeap(RtlProcessHeap(), 0, EnvironmentValue.Buffer);
        }
    }
}

UINT
APIENTRY
GetTempFileNameA(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    )

/*++

Routine Description:

    ANSI thunk to GetTempFileNameW

--*/

{
    PUNICODE_STRING Unicode;
    UNICODE_STRING UnicodePrefix;
    NTSTATUS Status;
    UINT ReturnValue;
    UNICODE_STRING UnicodeResult;

    Unicode = Basep8BitStringToStaticUnicodeString( lpPathName );
    if (Unicode == NULL) {
        return 0;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &UnicodePrefix, lpPrefixString )) {
        return 0;
    }

    UnicodeResult.MaximumLength = (USHORT)((MAX_PATH<<1)+sizeof(UNICODE_NULL));
    UnicodeResult.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), UnicodeResult.MaximumLength);
    if ( !UnicodeResult.Buffer ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RtlFreeUnicodeString(&UnicodePrefix);
        return 0;
        }

    ReturnValue = GetTempFileNameW(
                    Unicode->Buffer,
                    UnicodePrefix.Buffer,
                    uUnique,
                    UnicodeResult.Buffer
                    );
    if ( ReturnValue ) {
        ANSI_STRING AnsiString;

        RtlInitUnicodeString(&UnicodeResult,UnicodeResult.Buffer);
        AnsiString.Buffer = lpTempFileName;
        AnsiString.MaximumLength = MAX_PATH+1;
        Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeResult,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            ReturnValue = 0;
            }
        }
    RtlFreeUnicodeString(&UnicodePrefix);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeResult.Buffer);

    return ReturnValue;
}

UINT
APIENTRY
GetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    )

/*++

Routine Description:

    This function creates a temporary filename of the following form:

        drive:\path\prefixuuuu.tmp

    In this syntax line, drive:\path\ is the path specified by the
    lpPathName parameter; prefix is all the letters (up to the first
    three) of the string pointed to by the lpPrefixString parameter; and
    uuuu is the hexadecimal value of the number specified by the
    uUnique parameter.

    To avoid problems resulting from converting OEM character an string
    to an ANSI string, an application should call the CreateFile
    function to create the temporary file.

    If the uUnique parameter is zero, GetTempFileName attempts to form a
    unique number based on the current system time.  If a file with the
    resulting filename exists, the number is increased by one and the
    test for existence is repeated.  This continues until a unique
    filename is found; GetTempFileName then creates a file by that name
    and closes it.  No attempt is made to create and open the file when
    uUnique is nonzero.

Arguments:

    lpPathName - Specifies the null terminated pathname of the directory
        to create the temporary file within.

    lpPrefixString - Points to a null-terminated character string to be
        used as the temporary filename prefix.  This string must consist
        of characters in the OEM-defined character set.

    uUnique - Specifies an unsigned integer.

    lpTempFileName - Points to the buffer that is to receive the
        temporary filename.  This string consists of characters in the
        OEM-defined character set.  This buffer should be at least MAX_PATH
        characters in length to allow sufficient room for the pathname.

Return Value:

    The return value specifies a unique numeric value used in the
    temporary filename.  If a nonzero value was given for the uUnique
    parameter, the return value specifies this same number.

--*/

{
#if !defined(BUILD_WOW6432)
    BASE_API_MSG m;
    PBASE_GETTEMPFILE_MSG a = &m.u.GetTempFile;
#endif
    LPWSTR p,savedp;
    ULONG Length;
    HANDLE FileHandle;
    ULONG PassCount;
    DWORD LastError;
    UNICODE_STRING UnicodePath, UnicodePrefix;
    CHAR UniqueAsAnsi[8];
    CHAR *c;
    ULONG i;

#if defined(BUILD_WOW6432)
    UINT uNewUnique;
#endif

    PassCount = 0;
    RtlInitUnicodeString(&UnicodePath,lpPathName);
    Length = UnicodePath.Length;

    RtlMoveMemory(lpTempFileName,lpPathName,UnicodePath.MaximumLength);
    if ( !Length || lpTempFileName[(Length>>1)-1] != (WCHAR)'\\' ) {
        lpTempFileName[Length>>1] = (WCHAR)'\\';
        Length += sizeof(UNICODE_NULL);
        }

    lpTempFileName[(Length>>1)-1] = UNICODE_NULL;
    i = GetFileAttributesW(lpTempFileName);
    if (i == 0xFFFFFFFF) {
        lpTempFileName[(Length>>1)-1] = (WCHAR)'\\';
        lpTempFileName[(Length>>1)] = UNICODE_NULL;
        i = GetFileAttributesW(lpTempFileName);
        lpTempFileName[(Length>>1)-1] = UNICODE_NULL;
        }
    if ( (i == 0xFFFFFFFF) ||
         !(i & FILE_ATTRIBUTE_DIRECTORY) ) {
        SetLastError(ERROR_DIRECTORY);
        return FALSE;
        }
    lpTempFileName[(Length>>1)-1] = (WCHAR)'\\';

    RtlInitUnicodeString(&UnicodePrefix,lpPrefixString);
    if ( UnicodePrefix.Length > (USHORT)6 ) {
        UnicodePrefix.Length = (USHORT)6;
        }
    p = &lpTempFileName[Length>>1];
    Length = UnicodePrefix.Length;
    RtlMoveMemory(p,lpPrefixString,Length);
    p += (Length>>1);
    savedp = p;
    //
    // If uUnique is not specified, then get one
    //

    uUnique = uUnique & 0x0000ffff;

try_again:
    p = savedp;
    if ( !uUnique ) {

#if defined(BUILD_WOW6432)
        uNewUnique = CsrBasepGetTempFile();
        if ( uNewUnique == 0 ) {
#else
        CsrClientCallServer( (PCSR_API_MSG)&m,
                             NULL,
                             CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                  BasepGetTempFile
                                                ),
                             sizeof( *a )
                           );
        a->uUnique = (UINT)m.ReturnValue;
        if ( m.ReturnValue == 0 ) {
#endif

            PassCount++;
            if ( PassCount & 0xffff0000 ) {
                return 0;
                }
            goto try_again;
            }
        }
    else {
#if defined(BUILD_WOW6432)
        uNewUnique = uUnique;
#else
        a->uUnique = uUnique;
#endif
        }

    //
    // Convert the unique value to a 4 byte character string
    //

#if defined(BUILD_WOW6432)
    RtlIntegerToChar ((ULONG) uNewUnique,16,5,UniqueAsAnsi);
#else
    RtlIntegerToChar ((ULONG) a->uUnique,16,5,UniqueAsAnsi);
#endif
    c = UniqueAsAnsi;
    for(i=0;i<4;i++){
        *p = RtlAnsiCharToUnicodeChar(&c);
        if ( *p == UNICODE_NULL ) {
            break;
            }
        p++;
        }
    RtlMoveMemory(p,BaseDotTmpSuffixName.Buffer,BaseDotTmpSuffixName.MaximumLength);

    if ( !uUnique ) {

        //
        // test for resulting name being a device (prefix com, uUnique 1-9...
        //

        if ( RtlIsDosDeviceName_U(lpTempFileName) ) {
            PassCount++;
            if ( PassCount & 0xffff0000 ) {
                SetLastError(ERROR_INVALID_NAME);
                return 0;
                }
            goto try_again;
            }

        FileHandle = CreateFileW(
                        lpTempFileName,
                        GENERIC_READ,
                        0,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        //
        // If the create worked, then we are ok. Just close the file.
        // Otherwise, try again.
        //

        if ( FileHandle != INVALID_HANDLE_VALUE ) {
            NtClose(FileHandle);
            }
        else {

            //
            // FIXFIX This test should be inverted when time permits
            // sufficient testing to nail down the error codes that
            // would indicate is is reasonable to continue the loop
            // as opposed to stop the loop. All it currently takes is
            // CreateFile coming back with an error we don't know about
            // to make us spin here for a long time.
            //

            LastError = GetLastError();
            switch (LastError) {
                case ERROR_INVALID_PARAMETER     :
                case ERROR_WRITE_PROTECT         :
                case ERROR_FILE_NOT_FOUND        :
                case ERROR_BAD_PATHNAME          :
                case ERROR_INVALID_NAME          :
                case ERROR_PATH_NOT_FOUND        :
                case ERROR_NETWORK_ACCESS_DENIED :
                case ERROR_DISK_CORRUPT          :
                case ERROR_FILE_CORRUPT          :
                case ERROR_DISK_FULL             :
                    return 0;
                case ERROR_ACCESS_DENIED         :
                    // It's possible for us to hit this if there's a
                    // directory with the name we're trying; in that
                    // case, we can usefully continue.
                    // CreateFile() uses BaseSetLastNTError() to set
                    // LastStatusValue to the actual NT error in the
                    // TEB; we just need to check it, and only abort
                    // if it's not a directory.
                    // This was bug #397477.
                    if (NtCurrentTeb()->LastStatusValue
                        != STATUS_FILE_IS_A_DIRECTORY)
                        return 0;
                }

            PassCount++;
            if ( PassCount & 0xffff0000 ) {
                return 0;
                }
            goto try_again;
            }
        }
#if defined(BUILD_WOW6432)
    return uNewUnique;
#else
    return a->uUnique;
#endif
}

BOOL
APIENTRY
GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )

/*++

Routine Description:

    ANSI thunk to GetDiskFreeSpaceW

--*/

{
    PUNICODE_STRING Unicode;

    if (!ARGUMENT_PRESENT( lpRootPathName )) {
        lpRootPathName = "\\";
    }

    Unicode = Basep8BitStringToStaticUnicodeString( lpRootPathName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( GetDiskFreeSpaceW(
                (LPCWSTR)Unicode->Buffer,
                lpSectorsPerCluster,
                lpBytesPerSector,
                lpNumberOfFreeClusters,
                lpTotalNumberOfClusters
                )
            );
}

BOOL
APIENTRY
GetDiskFreeSpaceW(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )

#define MAKE2GFRIENDLY(lpOut, dwSize)                                           \
                                                                                \
    if (!bAppHack) {                                                            \
        *lpOut =  dwSize;                                                       \
    } else {                                                                    \
        dwTemp = SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector;   \
                                                                                \
        if (0x7FFFFFFF / dwTemp < dwSize) {                                     \
                                                                                \
            *lpOut = 0x7FFFFFFF / dwTemp;                                       \
        } else {                                                                \
            *lpOut =  dwSize;                                                   \
        }                                                                       \
    }



/*++

Routine Description:

    The free space on a disk and the size parameters can be returned
    using GetDiskFreeSpace.

Arguments:

    lpRootPathName - An optional parameter, that if specified, supplies
        the root directory of the disk whose free space is to be
        returned for.  If this parameter is not specified, then the root
        of the current directory is used.

    lpSectorsPerCluster - Returns the number of sectors per cluster
        where a cluster is the allocation granularity on the disk.

    lpBytesPerSector - Returns the number of bytes per sector.

    lpNumberOfFreeClusters - Returns the total number of free clusters
        on the disk.

    lpTotalNumberOfClusters - Returns the total number of clusters on
        the disk.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    WCHAR DefaultPath[2];
    DWORD dwTemp;
    BOOL  bAppHack;

    DefaultPath[0] = (WCHAR)'\\';
    DefaultPath[1] = UNICODE_NULL;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            ARGUMENT_PRESENT(lpRootPathName) ? lpRootPathName : DefaultPath,
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

        //
        // Prior releases of NT where these parameters were not optional
        // zeroed out this field even in the failure case.  Some applications
        // failed to check the return value from this function and instead
        // relied on this side effect.  I'm putting that back now so the apps
        // can still treat an unformatted volume as a zero size volume.
        //

        if (ARGUMENT_PRESENT( lpBytesPerSector )) {
            *lpBytesPerSector = 0;
            }
        return FALSE;
        }

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &SizeInfo,
                sizeof(SizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    //
    // See if the calling process needs hack to work with HDD > 2GB
    // 2GB is 0x80000000 bytes and some apps treat that as a signed LONG.
    //

    if (APPCOMPATFLAG(KACF_GETDISKFREESPACE)) {

        bAppHack = TRUE;
    } else {
        bAppHack = FALSE;
    }

    //
    // Deal with 64 bit sizes
    //

    if ( SizeInfo.TotalAllocationUnits.HighPart ) {
        SizeInfo.TotalAllocationUnits.LowPart = (ULONG)-1;
        }
    if ( SizeInfo.AvailableAllocationUnits.HighPart ) {
        SizeInfo.AvailableAllocationUnits.LowPart = (ULONG)-1;
        }

    if (ARGUMENT_PRESENT( lpSectorsPerCluster )) {
        *lpSectorsPerCluster = SizeInfo.SectorsPerAllocationUnit;
        }
    if (ARGUMENT_PRESENT( lpBytesPerSector )) {
        *lpBytesPerSector = SizeInfo.BytesPerSector;
        }
    if (ARGUMENT_PRESENT( lpNumberOfFreeClusters )) {
        MAKE2GFRIENDLY(lpNumberOfFreeClusters, SizeInfo.AvailableAllocationUnits.LowPart);
        }
    if (ARGUMENT_PRESENT( lpTotalNumberOfClusters )) {
        MAKE2GFRIENDLY(lpTotalNumberOfClusters, SizeInfo.TotalAllocationUnits.LowPart);
        }

    return TRUE;
}

WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceExA(
    LPCSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    )
{
    PUNICODE_STRING Unicode;

    if (!ARGUMENT_PRESENT( lpDirectoryName )) {
        lpDirectoryName = "\\";
    }

    Unicode = Basep8BitStringToStaticUnicodeString( lpDirectoryName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( GetDiskFreeSpaceExW(
                (LPCWSTR)Unicode->Buffer,
                lpFreeBytesAvailableToCaller,
                lpTotalNumberOfBytes,
                lpTotalNumberOfFreeBytes
                )
            );
}


WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceExW(
    LPCWSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    union {
        FILE_FS_SIZE_INFORMATION Normal;
        FILE_FS_FULL_SIZE_INFORMATION Full;
    } SizeInfo;

    WCHAR DefaultPath[2];
    ULARGE_INTEGER BytesPerAllocationUnit;
    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;

    DefaultPath[0] = (WCHAR)'\\';
    DefaultPath[1] = UNICODE_NULL;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            ARGUMENT_PRESENT(lpDirectoryName) ? lpDirectoryName : DefaultPath,
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        return FALSE;
        }

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    //
    // If the caller wants the volume total then try to get a full
    // file size.
    //

    if ( ARGUMENT_PRESENT(lpTotalNumberOfFreeBytes) ) {

        Status = NtQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &SizeInfo,
                    sizeof(SizeInfo.Full),
                    FileFsFullSizeInformation
                    );

        if ( NT_SUCCESS(Status) ) {

            NtClose(Handle);

            BytesPerAllocationUnit.QuadPart =
                SizeInfo.Full.BytesPerSector * SizeInfo.Full.SectorsPerAllocationUnit;

            if ( ARGUMENT_PRESENT(lpFreeBytesAvailableToCaller) ) {
                lpFreeBytesAvailableToCaller->QuadPart =
                    BytesPerAllocationUnit.QuadPart *
                    SizeInfo.Full.CallerAvailableAllocationUnits.QuadPart;
                }
            if ( ARGUMENT_PRESENT(lpTotalNumberOfBytes) ) {
                lpTotalNumberOfBytes->QuadPart =
                    BytesPerAllocationUnit.QuadPart * SizeInfo.Full.TotalAllocationUnits.QuadPart;
                }
            lpTotalNumberOfFreeBytes->QuadPart =
                BytesPerAllocationUnit.QuadPart *
                SizeInfo.Full.ActualAvailableAllocationUnits.QuadPart;

            return TRUE;
        }
    }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &SizeInfo,
                sizeof(SizeInfo.Normal),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    BytesPerAllocationUnit.QuadPart =
        SizeInfo.Normal.BytesPerSector * SizeInfo.Normal.SectorsPerAllocationUnit;

    FreeBytesAvailableToCaller.QuadPart =
        BytesPerAllocationUnit.QuadPart * SizeInfo.Normal.AvailableAllocationUnits.QuadPart;

    TotalNumberOfBytes.QuadPart =
        BytesPerAllocationUnit.QuadPart * SizeInfo.Normal.TotalAllocationUnits.QuadPart;

    if ( ARGUMENT_PRESENT(lpFreeBytesAvailableToCaller) ) {
        lpFreeBytesAvailableToCaller->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfBytes) ) {
        lpTotalNumberOfBytes->QuadPart = TotalNumberOfBytes.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfFreeBytes) ) {
        lpTotalNumberOfFreeBytes->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }

    return TRUE;
}

BOOL
APIENTRY
GetVolumeInformationA(
    LPCSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    )

/*++

Routine Description:

    ANSI thunk to GetVolumeInformationW

--*/

{
    PUNICODE_STRING Unicode;
    NTSTATUS Status;
    UNICODE_STRING UnicodeVolumeName;
    UNICODE_STRING UnicodeFileSystemName;
    ANSI_STRING AnsiVolumeName;
    ANSI_STRING AnsiFileSystemName;
    BOOL ReturnValue;

    if (!ARGUMENT_PRESENT( lpRootPathName )) {
        lpRootPathName = "\\";
    }

    Unicode = Basep8BitStringToStaticUnicodeString( lpRootPathName );
    if (Unicode == NULL) {
        return FALSE;
    }

    UnicodeVolumeName.Buffer = NULL;
    UnicodeFileSystemName.Buffer = NULL;
    UnicodeVolumeName.MaximumLength = 0;
    UnicodeFileSystemName.MaximumLength = 0;
    AnsiVolumeName.Buffer = lpVolumeNameBuffer;
    AnsiVolumeName.MaximumLength = (USHORT)(nVolumeNameSize+1);
    AnsiFileSystemName.Buffer = lpFileSystemNameBuffer;
    AnsiFileSystemName.MaximumLength = (USHORT)(nFileSystemNameSize+1);

    try {
        if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
            UnicodeVolumeName.MaximumLength = AnsiVolumeName.MaximumLength << 1;
            UnicodeVolumeName.Buffer = RtlAllocateHeap(
                                            RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                            UnicodeVolumeName.MaximumLength
                                            );

            if ( !UnicodeVolumeName.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
                }
            }

        if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
            UnicodeFileSystemName.MaximumLength = AnsiFileSystemName.MaximumLength << 1;
            UnicodeFileSystemName.Buffer = RtlAllocateHeap(
                                                RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                                UnicodeFileSystemName.MaximumLength
                                                );

            if ( !UnicodeFileSystemName.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
                }
            }

        ReturnValue = GetVolumeInformationW(
                            (LPCWSTR)Unicode->Buffer,
                            UnicodeVolumeName.Buffer,
                            nVolumeNameSize,
                            lpVolumeSerialNumber,
                            lpMaximumComponentLength,
                            lpFileSystemFlags,
                            UnicodeFileSystemName.Buffer,
                            nFileSystemNameSize
                            );

        if ( ReturnValue ) {

            if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
                RtlInitUnicodeString(
                    &UnicodeVolumeName,
                    UnicodeVolumeName.Buffer
                    );

                Status = BasepUnicodeStringTo8BitString(
                            &AnsiVolumeName,
                            &UnicodeVolumeName,
                            FALSE
                            );

                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }

            if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
                RtlInitUnicodeString(
                    &UnicodeFileSystemName,
                    UnicodeFileSystemName.Buffer
                    );

                Status = BasepUnicodeStringTo8BitString(
                            &AnsiFileSystemName,
                            &UnicodeFileSystemName,
                            FALSE
                            );

                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }
            }
        }
    finally {
        if ( UnicodeVolumeName.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(), 0,UnicodeVolumeName.Buffer);
            }
        if ( UnicodeFileSystemName.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(), 0,UnicodeFileSystemName.Buffer);
            }
        }

    return ReturnValue;
}

BOOL
APIENTRY
GetVolumeInformationW(
    LPCWSTR lpRootPathName,
    LPWSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPWSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    )

/*++

Routine Description:

    This function returns information about the file system whose root
    directory is specified.

Arguments:

    lpRootPathName - An optional parameter, that if specified, supplies
        the root directory of the file system that information is to be
        returned about.  If this parameter is not specified, then the
        root of the current directory is used.

    lpVolumeNameBuffer - An optional parameter that if specified returns
        the name of the specified volume.

    nVolumeNameSize - Supplies the length of the volume name buffer.
        This parameter is ignored if the volume name buffer is not
        supplied.

    lpVolumeSerialNumber - An optional parameter that if specified
        points to a DWORD.  The DWORD contains the 32-bit of the volume
        serial number.

    lpMaximumComponentLength - An optional parameter that if specified
        returns the maximum length of a filename component supported by
        the specified file system.  A filename component is that portion
        of a filename between pathname seperators.

    lpFileSystemFlags - An optional parameter that if specified returns
        flags associated with the specified file system.

        lpFileSystemFlags Flags:

            FS_CASE_IS_PRESERVED - Indicates that the case of file names
                is preserved when the name is placed on disk.

            FS_CASE_SENSITIVE - Indicates that the file system supports
                case sensitive file name lookup.

            FS_UNICODE_STORED_ON_DISK - Indicates that the file system
                supports unicode in file names as they appear on disk.

    lpFileSystemNameBuffer - An optional parameter that if specified returns
        the name for the specified file system (e.g. FAT, HPFS...).

    nFileSystemNameSize - Supplies the length of the file system name
        buffer.  This parameter is ignored if the file system name
        buffer is not supplied.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInfo;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    ULONG AttributeInfoLength;
    ULONG VolumeInfoLength;
    WCHAR DefaultPath[2];
    BOOL rv;
    ULONG HardErrorValue;
#if defined(BUILD_WOW6432)
    ULONG HardErrorValue64;
#endif
    PTEB Teb;

    rv = FALSE;
    DefaultPath[0] = (WCHAR)'\\';
    DefaultPath[1] = UNICODE_NULL;

    nVolumeNameSize *= 2;
    nFileSystemNameSize *= 2;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            ARGUMENT_PRESENT(lpRootPathName) ? lpRootPathName : DefaultPath,
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    //
    // Check to make sure a root was specified
    //

    if ( FileName.Buffer[(FileName.Length >> 1)-1] != '\\' ) {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    AttributeInfo = NULL;
    VolumeInfo = NULL;

    //
    // Open the file
    //
    Teb = NtCurrentTeb();
    HardErrorValue = Teb->HardErrorsAreDisabled;
    Teb->HardErrorsAreDisabled = 1;
#if defined(BUILD_WOW6432)
    HardErrorValue64 = NtCurrentTeb64()->HardErrorsAreDisabled;
    NtCurrentTeb64()->HardErrorsAreDisabled = 1;
#endif
    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                );
    Teb->HardErrorsAreDisabled = HardErrorValue;
#if defined(BUILD_WOW6432)
    NtCurrentTeb64()->HardErrorsAreDisabled = HardErrorValue64;
#endif
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        return FALSE;
        }

    if ( !IsThisARootDirectory(Handle,&FileName) ) {
        NtClose(Handle);
        SetLastError(ERROR_DIR_NOT_ROOT);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        return FALSE;
        }
    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ||
         ARGUMENT_PRESENT(lpVolumeSerialNumber) ) {
        if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
            VolumeInfoLength = sizeof(*VolumeInfo)+nVolumeNameSize;
            }
        else {
            VolumeInfoLength = sizeof(*VolumeInfo)+MAX_PATH;
            }
        VolumeInfo = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), VolumeInfoLength);

        if ( !VolumeInfo ) {
            NtClose(Handle);
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return FALSE;
            }
        }

    if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ||
         ARGUMENT_PRESENT(lpMaximumComponentLength) ||
         ARGUMENT_PRESENT(lpFileSystemFlags) ) {
        if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
            AttributeInfoLength = sizeof(*AttributeInfo) + nFileSystemNameSize;
            }
        else {
            AttributeInfoLength = sizeof(*AttributeInfo) + MAX_PATH;
            }
        AttributeInfo = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), AttributeInfoLength);
        if ( !AttributeInfo ) {
            NtClose(Handle);
            if ( VolumeInfo ) {
                RtlFreeHeap(RtlProcessHeap(), 0,VolumeInfo);
                }
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return FALSE;
            }
        }

    try {
        if ( VolumeInfo ) {
            Status = NtQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        VolumeInfo,
                        VolumeInfoLength,
                        FileFsVolumeInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                rv = FALSE;
                goto finally_exit;
                }
            }

        if ( AttributeInfo ) {
            Status = NtQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        AttributeInfo,
                        AttributeInfoLength,
                        FileFsAttributeInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                rv = FALSE;
                goto finally_exit;
                }
            }
        try {

            if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
                if ( VolumeInfo->VolumeLabelLength >= nVolumeNameSize ) {
                    SetLastError(ERROR_BAD_LENGTH);
                    rv = FALSE;
                    goto finally_exit;
                    }
                else {
                    RtlMoveMemory( lpVolumeNameBuffer,
                                   VolumeInfo->VolumeLabel,
                                   VolumeInfo->VolumeLabelLength );

                    *(lpVolumeNameBuffer + (VolumeInfo->VolumeLabelLength >> 1)) = UNICODE_NULL;
                    }
                }

            if ( ARGUMENT_PRESENT(lpVolumeSerialNumber) ) {
                *lpVolumeSerialNumber = VolumeInfo->VolumeSerialNumber;
                }

            if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {

                if ( AttributeInfo->FileSystemNameLength >= nFileSystemNameSize ) {
                    SetLastError(ERROR_BAD_LENGTH);
                    rv = FALSE;
                    goto finally_exit;
                    }
                else {
                    RtlMoveMemory( lpFileSystemNameBuffer,
                                   AttributeInfo->FileSystemName,
                                   AttributeInfo->FileSystemNameLength );

                    *(lpFileSystemNameBuffer + (AttributeInfo->FileSystemNameLength >> 1)) = UNICODE_NULL;
                    }
                }

            if ( ARGUMENT_PRESENT(lpMaximumComponentLength) ) {
                *lpMaximumComponentLength = AttributeInfo->MaximumComponentNameLength;
                }

            if ( ARGUMENT_PRESENT(lpFileSystemFlags) ) {
                *lpFileSystemFlags = AttributeInfo->FileSystemAttributes;
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
            return FALSE;
            }
        rv = TRUE;
finally_exit:;
        }
    finally {
        NtClose(Handle);
        if ( VolumeInfo ) {
            RtlFreeHeap(RtlProcessHeap(), 0,VolumeInfo);
            }
        if ( AttributeInfo ) {
            RtlFreeHeap(RtlProcessHeap(), 0,AttributeInfo);
            }
        }
    return rv;
}

DWORD
APIENTRY
GetLogicalDriveStringsA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )
{
    ULONG DriveMap;
    ANSI_STRING RootName;
    int i;
    PUCHAR Dst;
    DWORD BytesLeft;
    DWORD BytesNeeded;
    BOOL WeFailed;
    CHAR szDrive[] = "A:\\";

    BytesNeeded = 0;
    BytesLeft = nBufferLength;
    Dst = (PUCHAR)lpBuffer;
    WeFailed = FALSE;

    RtlInitAnsiString(&RootName, szDrive);
    DriveMap = GetLogicalDrives();
    for ( i=0; i<26; i++ ) {
        RootName.Buffer[0] = (CHAR)((CHAR)i+'A');
        if (DriveMap & (1 << i) ) {

            BytesNeeded += RootName.MaximumLength;
            if ( BytesNeeded < (USHORT)BytesLeft ) {
                RtlMoveMemory(Dst,RootName.Buffer,RootName.MaximumLength);
                Dst += RootName.MaximumLength;
                *Dst = '\0';
                }
            else {
                WeFailed = TRUE;
                }
            }
        }

    if ( WeFailed ) {
        BytesNeeded++;
        }
    //
    // Need to handle network uses;
    //

    return( BytesNeeded );
}

DWORD
APIENTRY
GetLogicalDriveStringsW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )
{
    ULONG DriveMap;
    UNICODE_STRING RootName;
    int i;
    PUCHAR Dst;
    DWORD BytesLeft;
    DWORD BytesNeeded;
    BOOL WeFailed;
    WCHAR wszDrive[] = L"A:\\";

    nBufferLength = nBufferLength*2;
    BytesNeeded = 0;
    BytesLeft = nBufferLength;
    Dst = (PUCHAR)lpBuffer;
    WeFailed = FALSE;

    RtlInitUnicodeString(&RootName, wszDrive);

    DriveMap = GetLogicalDrives();
    for ( i=0; i<26; i++ ) {
        RootName.Buffer[0] = (WCHAR)((CHAR)i+'A');
        if (DriveMap & (1 << i) ) {

            BytesNeeded += RootName.MaximumLength;
            if ( BytesNeeded < (USHORT)BytesLeft ) {
                RtlMoveMemory(Dst,RootName.Buffer,RootName.MaximumLength);
                Dst += RootName.MaximumLength;
                *(PWSTR)Dst = UNICODE_NULL;
                }
            else {
                WeFailed = TRUE;
                }
            }
        }

    if ( WeFailed ) {
        BytesNeeded += 2;
        }

    //
    // Need to handle network uses;
    //

    return( BytesNeeded/2 );
}

BOOL
WINAPI
SetVolumeLabelA(
    LPCSTR lpRootPathName,
    LPCSTR lpVolumeName
    )
{
    PUNICODE_STRING Unicode;
    UNICODE_STRING UnicodeVolumeName;
    BOOL ReturnValue;

    if (!ARGUMENT_PRESENT( lpRootPathName )) {
        lpRootPathName = "\\";
    }

    Unicode = Basep8BitStringToStaticUnicodeString( lpRootPathName );

    if (Unicode == NULL) {
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpVolumeName) ) {
        if (!Basep8BitStringToDynamicUnicodeString( &UnicodeVolumeName, lpVolumeName )) {
            return FALSE;
        }

    } else {
        UnicodeVolumeName.Buffer = NULL;
    }

    ReturnValue = SetVolumeLabelW((LPCWSTR)Unicode->Buffer,(LPCWSTR)UnicodeVolumeName.Buffer);

    RtlFreeUnicodeString(&UnicodeVolumeName);

    return ReturnValue;
}

BOOL
WINAPI
SetVolumeLabelW(
    LPCWSTR lpRootPathName,
    LPCWSTR lpVolumeName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    UNICODE_STRING LabelName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    PFILE_FS_LABEL_INFORMATION LabelInformation;
    ULONG LabelInfoLength;
    WCHAR DefaultPath[2];
    BOOL rv;
    WCHAR volumeName[MAX_PATH];
    BOOL usingVolumeName;

    rv = FALSE;
    DefaultPath[0] = (WCHAR)'\\';
    DefaultPath[1] = UNICODE_NULL;

    if ( ARGUMENT_PRESENT(lpVolumeName) ) {
        RtlInitUnicodeString(&LabelName,lpVolumeName);
        }
    else {
        LabelName.Length = 0;
        LabelName.MaximumLength = 0;
        LabelName.Buffer = NULL;
        }

    if (ARGUMENT_PRESENT(lpRootPathName)) {
        if (GetVolumeNameForVolumeMountPointW(lpRootPathName, volumeName,
                                              MAX_PATH)) {

            usingVolumeName = TRUE;
        } else {
            usingVolumeName = FALSE;
        }
    } else {
        usingVolumeName = FALSE;
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            usingVolumeName ? volumeName : (ARGUMENT_PRESENT(lpRootPathName) ? lpRootPathName : DefaultPath),
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    //
    // Check to make sure a root was specified
    //

    if ( FileName.Buffer[(FileName.Length >> 1)-1] != '\\' ) {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_DATA | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );
    if ( !NT_SUCCESS(Status) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        BaseSetLastNTError(Status);
        return FALSE;
        }

    if ( !IsThisARootDirectory(Handle,NULL) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        NtClose(Handle);
        SetLastError(ERROR_DIR_NOT_ROOT);
        return FALSE;
        }

    NtClose(Handle);

    //
    // Now open the volume DASD by ignoring the ending backslash
    //

    FileName.Length -= 2;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the volume
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_DATA | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );
    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the volume label
    //

    LabelInformation = NULL;

    try {

        rv = TRUE;

        //
        // the label info buffer contains a single wchar that is the basis of
        // the label name. Subtract this out so the info length is the length
        // of the label and the structure (not including the extra wchar)
        //

        if ( LabelName.Length ) {
            LabelInfoLength = sizeof(*LabelInformation) + LabelName.Length - sizeof(WCHAR);
            }
        else {
            LabelInfoLength = sizeof(*LabelInformation);
            }

        LabelInformation = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), LabelInfoLength);
        if ( LabelInformation ) {
            RtlCopyMemory(
                LabelInformation->VolumeLabel,
                LabelName.Buffer,
                LabelName.Length
                );
            LabelInformation->VolumeLabelLength = LabelName.Length;
            Status = NtSetVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        (PVOID) LabelInformation,
                        LabelInfoLength,
                        FileFsLabelInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                rv = FALSE;
                BaseSetLastNTError(Status);
                }
            }
        else {
            rv = FALSE;
            BaseSetLastNTError(STATUS_NO_MEMORY);
            }
        }
    finally {
        NtClose(Handle);
        if ( LabelInformation ) {
            RtlFreeHeap(RtlProcessHeap(), 0,LabelInformation);
            }
        }
    return rv;
}

BOOL
APIENTRY
CheckNameLegalDOS8Dot3A(
    IN LPCSTR lpName,
    OUT LPSTR lpOemName OPTIONAL,
    IN DWORD OemNameSize OPTIONAL,
    OUT PBOOL pbNameContainsSpaces OPTIONAL,
    OUT PBOOL pbNameLegal
    )
/*++

    ANSI thunk to IsNameLegalDOS8Dot3W

--*/

{
    ANSI_STRING AnsiStr;
    PUNICODE_STRING pUnicodeStr;
    NTSTATUS Status;
    BOOL Result;

    if( (lpName == NULL) || (pbNameLegal == NULL) ||
        ((lpOemName == NULL) && (OemNameSize != 0)) ||
        (OemNameSize > MAXUSHORT)
      ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pUnicodeStr = Basep8BitStringToStaticUnicodeString( lpName );

    if( pUnicodeStr == NULL ) {
        //
        // LastError already set by Basep8BitStringToStaticUnicodeString
        //
        return FALSE;
    }

    Result = CheckNameLegalDOS8Dot3W(
                (LPCWSTR)(pUnicodeStr->Buffer),
                lpOemName,
                OemNameSize,
                pbNameContainsSpaces,
                pbNameLegal
                );

    return Result;
}

BOOL
APIENTRY
CheckNameLegalDOS8Dot3W(
    IN LPCWSTR lpName,
    OUT LPSTR lpOemName OPTIONAL,
    IN DWORD OemNameSize OPTIONAL,
    OUT PBOOL pbNameContainsSpaces OPTIONAL,
    OUT PBOOL pbNameLegal
    )

/*++

Routine Description:

    This function determines whether this name can successfully be used to
    create a file on the FAT file system.

    This routine can therefore also be used to determine if a name is
    appropriate to be passed back to a Win31 or DOS app, i.e. whether
    the downlevel APP will understand the name.

Arguments:

    lpName - The UNICODE name to test for conformance to 8.3 symantics.

    lpOemName - If specified, will receive the Oem name corresponding
        to the passed in lpName.  Storage must be provided by the caller.
        The name is undefined if the routine returns FALSE or lpName
        does not conform to 8.3 symantics.

    OemNameSize - If lpOemName is specified, then OemNameSize must specify
        the size of the lpOemName buffer in chars.  If lpOemName is not
        specified, then OemNameSize must be set to zero.

    pbNameContainsSpaces - If the name is a valid 8.3 FAT name, then this
        parameter will indicate if the names contains spaces.  If
        the name is not 8.3 compliant, this parameter is undefined. In
        many instances, the alternate name is more appropriate to
        use if spaces are present in the principle name, even if
        it is 8.3 compliant.

    pbNameLegal - If the function returns TRUE, then this
        parameter will indicate if the passed in UNICODE name forms a valid
        8.3 FAT name when upcased to the current Oem code page.  If
        the name is not 8.3 compliant, this parameter is undefined.
        TRUE  - passed in UNICODE name forms a valid 8.3 FAT name
        FALSE - passed in UNICODE name does not forms a valid 8.3 FAT name

Return Value:

    TRUE  - function succeeds
    FALSE - Function fails.  Extended error status is available using
            GetLastError.

--*/
{

#define BASEP_LOCAL_OEM_BUFFER_SIZE (12 * sizeof(ANSI_NULL))

    UNICODE_STRING UnicodeStr;
    OEM_STRING OemStr;
    POEM_STRING pOemStr;
    UCHAR OemBuffer[BASEP_LOCAL_OEM_BUFFER_SIZE];
    BOOLEAN SpacesInName, Result;

    if( (lpName == NULL) || (pbNameLegal == NULL) ||
        ((lpOemName == NULL) && (OemNameSize != 0)) ||
        (OemNameSize > MAXUSHORT)
      ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( lpOemName != NULL ) {
        //
        // Use a local buffer so that RtlIsNameLegalDOS8Dot3 will not fail
        // due to insufficent OemName buffer size
        //
        OemStr.Length = 0;
        OemStr.MaximumLength = BASEP_LOCAL_OEM_BUFFER_SIZE;
        OemStr.Buffer = OemBuffer;
        pOemStr = &OemStr;
    }
    else {
        pOemStr = NULL;
    }

    RtlInitUnicodeString( &UnicodeStr, lpName );

    Result = RtlIsNameLegalDOS8Dot3(
                &UnicodeStr,
                pOemStr,
                &SpacesInName
                );

    if( Result != FALSE ) {

        if( pOemStr != NULL ) {

            if( OemNameSize < (OemStr.Length + sizeof(ANSI_NULL)) ) {

                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                return FALSE;
            }
            RtlCopyMemory( lpOemName, OemStr.Buffer, OemStr.Length );
            lpOemName[OemStr.Length/sizeof(ANSI_NULL)] = ANSI_NULL;
        }

        if( pbNameContainsSpaces != NULL ) {
            *pbNameContainsSpaces = SpacesInName;
        }
    }

    *pbNameLegal = Result;

    return TRUE;

#undef BASEP_LOCAL_OEM_BUFFER_SIZE
}


#if 0
//
// frankar, let me know if this is needed...
//
UINT
WINAPI
GetZawSysDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG  cbAnsiString;

    UnicodeString.MaximumLength = (USHORT)((uSize<<1)+sizeof(UNICODE_NULL));
    UnicodeString.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                UnicodeString.MaximumLength
                                );
    if ( !UnicodeString.Buffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
        }
    UnicodeString.Length = (USHORT)GetZawSysDirectoryW(
                                        UnicodeString.Buffer,
                                        (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2
                                        )*2;
    if ( UnicodeString.Length > (USHORT)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL)) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);

        //
        // given buffer size is too small.
        // allocate enough size of buffer and try again
        //
        // we need to get entire unicode path
        // otherwise we can't figure out the exact length
        // of corresponding ansi string (cbAnsiString).

        UnicodeString.Buffer = RtlAllocateHeap ( RtlProcessHeap(),
                                                 MAKE_TAG( TMP_TAG ),
                                                 UnicodeString.Length+ sizeof(UNICODE_NULL));
        if ( !UnicodeString.Buffer ) {
             BaseSetLastNTError(STATUS_NO_MEMORY);
             return 0;
             }

        UnicodeString.Length = (USHORT)GetZawSysDirectoryW(
                                     UnicodeString.Buffer,
                                     (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2,
                                     ) * 2;
        Status = RtlUnicodeToMultiByteSize( &cbAnsiString,
                                            UnicodeString.Buffer,
                                            UnicodeString.Length );
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            BaseSetLastNTError(Status);
            return 0;
            }
        else if ( nBufferLength < cbAnsiString ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            return cbAnsiString;
            }
        }
    AnsiString.Buffer = lpBuffer;
    AnsiString.MaximumLength = (USHORT)(uSize+1);
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }
    return AnsiString.Length;
}

UINT
WINAPI
GetZawWindDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG  cbAnsiString;

    UnicodeString.MaximumLength = (USHORT)((uSize<<1)+sizeof(UNICODE_NULL));
    UnicodeString.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                UnicodeString.MaximumLength
                                );
    if ( !UnicodeString.Buffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
        }
    UnicodeString.Length = (USHORT)GetZawWindDirectoryW(
                                        UnicodeString.Buffer,
                                        (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2
                                        )*2;
    if ( UnicodeString.Length > (USHORT)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL)) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);

        //
        // given buffer size is too small.
        // allocate enough size of buffer and try again
        //
        // we need to get entire unicode path
        // otherwise we can't figure out the exact length
        // of corresponding ansi string (cbAnsiString).

        UnicodeString.Buffer = RtlAllocateHeap ( RtlProcessHeap(),
                                                 MAKE_TAG( TMP_TAG ),
                                                 UnicodeString.Length+ sizeof(UNICODE_NULL));
        if ( !UnicodeString.Buffer ) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return 0;
            }

        UnicodeString.Length = (USHORT)GetZawWindDirectoryW(
                                     UnicodeString.Buffer,
                                     (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2
                                     ) * 2;
        Status = RtlUnicodeToMultiByteSize( &cbAnsiString,
                                            UnicodeString.Buffer,
                                            UnicodeString.Length );
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            BaseSetLastNTError(Status);
            return 0;
            }
        else if ( nBufferLength < cbAnsiString ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            return cbAnsiString;
            }
        }
    AnsiString.Buffer = lpBuffer;
    AnsiString.MaximumLength = (USHORT)(uSize+1);
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }
    return AnsiString.Length;
}

UINT
WINAPI
GetZawSysDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )
{
    NTSTATUS Status;
    HANDLE CurrentUserKey;
    HANDLE DirKey;
    UNICODE_STRING KeyName;
    UNICODE_STRING KeyValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG DataLength;
    ULONG ValueInfoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+MAX_PATH/2];
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;

    Status = RtlOpenCurrentUser(GENERIC_READ,&CurrentUserKey);

    if ( !NT_SUCCESS(Status) ) {
bail_gzsd:
        return GetSystemDirectoryW(lpBuffer,uSize);
        }

    RtlInitUnicodeString(&KeyName,L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ZAW");

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                CurrentUserKey,
                                NULL
                              );
    Status = NtOpenKey( &DirKey,
                        KEY_READ | KEY_NOTIFY | KEY_WRITE,
                        &ObjectAttributes
                      );

    NtClose(CurrentUserKey);
    if ( !NT_SUCCESS(Status) ) {
        goto bail_gzsd;
        }

    RtlInitUnicodeString(&KeyValueName,L"ZawSys");
    ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)&ValueInfoBuffer;
    Status = NtQueryValueKey( DirKey,
                              &KeyValueName,
                              KeyValuePartialInformation,
                              ValueInfo,
                              sizeof(ValueInfoBuffer),
                              &DataLength
                            );
    NtClose(DirKey);
    if ( !NT_SUCCESS(Status) ) {
        goto bail_gzsd;
        }
    if ( ValueInfo->DataLength > (uSize<<1) ) {
        goto bail_gzsd;
        }
    RtlCopyMemory(lpBuffer,ValueInfo->Data,ValueInfo->DataLength);
    return (ValueInfo->DataLength >> 1)-1;
}

UINT
WINAPI
GetZawWindDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )
{
    NTSTATUS Status;
    HANDLE CurrentUserKey;
    HANDLE DirKey;
    UNICODE_STRING KeyName;
    UNICODE_STRING KeyValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG DataLength;
    ULONG ValueInfoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+MAX_PATH/2];
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;

    Status = RtlOpenCurrentUser(GENERIC_READ,&CurrentUserKey);

    if ( !NT_SUCCESS(Status) ) {
bail_gzwd:
        return GetWindowsDirectoryW(lpBuffer,uSize);
        }

    RtlInitUnicodeString(&KeyName,L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ZAW");

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                CurrentUserKey,
                                NULL
                              );
    Status = NtOpenKey( &DirKey,
                        KEY_READ | KEY_NOTIFY | KEY_WRITE,
                        &ObjectAttributes
                      );

    NtClose(CurrentUserKey);
    if ( !NT_SUCCESS(Status) ) {
        goto bail_gzwd;
        }

    RtlInitUnicodeString(&KeyValueName,L"ZawWind");
    ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)&ValueInfoBuffer;
    Status = NtQueryValueKey( DirKey,
                              &KeyValueName,
                              KeyValuePartialInformation,
                              ValueInfo,
                              sizeof(ValueInfoBuffer),
                              &DataLength
                            );
    NtClose(DirKey);
    if ( !NT_SUCCESS(Status) ) {
        goto bail_gzwd;
        }
    if ( ValueInfo->DataLength > (uSize<<1) ) {
        goto bail_gzwd;
        }
    RtlCopyMemory(lpBuffer,ValueInfo->Data,ValueInfo->DataLength);
    return (ValueInfo->DataLength >> 1)-1;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\mtbnch.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// - hStartOfRace is a manual reset event that is signalled when
//   all of the threads are supposed to cut loose and begin working
//
// - hEndOfRace is a manual reset event that is signalled once the end time
//   has been retrieved and it is ok for the threads to exit
//

HANDLE hStartOfRace;
HANDLE hEndOfRace;

#define MAX_THREADS 32

//
// - ThreadReadyDoneEvents are an array of autoclearing events. The threads
//   initially signal these events once they have reached their start routines
//   and are ready to being processing. Once they are done processing, they
//   signal thier event to indicate that they are done processing.
//
// - ThreadHandles are an array of thread handles to the worker threads. The
//   main thread waits on these to know when all of the threads have exited.
//

HANDLE ThreadReadyDoneEvents[MAX_THREADS];
HANDLE ThreadHandles[MAX_THREADS];

//
// Each thread has a THREAD_WORK structure. This contains the address
// of the cells that this thread is responsible for, and the number of
// cells it is supposed to process.
//

typedef struct _THREAD_WORK {
    PDWORD CellVector;
    DWORD NumberOfCells;
    DWORD RecalcResult;
} THREAD_WORK, *PTHREAD_WORK;

THREAD_WORK ThreadWork[MAX_THREADS];

#define ONE_MB      (1024*1024)

DWORD Mb = 4;
DWORD NumberOfThreads = 1;
DWORD ExpectedRecalcValue;
DWORD ActualRecalcValue;
DWORD ContentionValue;
BOOL fMemoryContention;

DWORD WorkerThread(PVOID ThreadIndex);

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD StartTicks, EndTicks;
    DWORD i;
    BOOL fShowUsage;
    char c, *p, *whocares;
    PDWORD CellVector;
    DWORD NumberOfDwords;
    DWORD DwordsPerThread;
    DWORD ThreadId;
    LPSTR Answer;

    fShowUsage = FALSE;
    fMemoryContention = FALSE;

    if (argc <= 1) {
        goto showUsage;
        }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
            case '?':
                fShowUsage = TRUE;
                goto showUsage;
                break;

            case 'M':
                if (!argc--) {
                    fShowUsage = TRUE;
                    goto showUsage;
                    }
                argv++;
                Mb = strtoul(*argv,&whocares,10);
                break;

            case 'C':
                fMemoryContention = TRUE;
                break;

            case 'T':
                if (!argc--) {
                    fShowUsage = TRUE;
                    goto showUsage;
                    }
                argv++;
                NumberOfThreads = strtoul(*argv,&whocares,10);
                if ( NumberOfThreads > MAX_THREADS ) {
                    fShowUsage = TRUE;
                    goto showUsage;
                    }
                break;

            default:
                fprintf( stderr, "MTBNCH: Invalid switch - /%c\n", c );
                goto showUsage;
                break;
                }
            }
        }

showUsage:
    if ( fShowUsage ) {
        fprintf(stderr,"usage: MTBNCH\n" );
        fprintf(stderr,"              [-?] display this message\n" );
        fprintf(stderr,"              [-t n] use n threads for benchmark (less than 32)\n" );
        fprintf(stderr,"              [-m n] use an n Mb spreadsheet size (default 4)\n" );
        fprintf(stderr,"              [-c] cause memory contention on each loop iteration\n" );
        ExitProcess(1);
        }

    //
    // Prepare the race events. These are manual reset events.
    //

    hStartOfRace = CreateEvent(NULL,TRUE,FALSE,NULL);
    hEndOfRace = CreateEvent(NULL,TRUE,FALSE,NULL);

    if ( !hStartOfRace || !hEndOfRace ) {
        fprintf(stderr,"MTBNCH: Race Event Creation Failed\n");
        ExitProcess(1);
        }

    //
    // Prepare the ready done events. These are auto clearing events
    //

    for(i=0; i<NumberOfThreads; i++ ) {
        ThreadReadyDoneEvents[i] = CreateEvent(NULL,FALSE,FALSE,NULL);
        if ( !ThreadReadyDoneEvents[i] ) {
            fprintf(stderr,"MTBNCH: Ready Done Event Creation Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        }

    //
    // Allocate and initialize the CellVector
    //

    CellVector = (PDWORD)VirtualAlloc(NULL,Mb*ONE_MB,MEM_COMMIT,PAGE_READWRITE);
    if ( !CellVector ) {
        fprintf(stderr,"MTBNCH: Cell Vector Allocation Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    NumberOfDwords = (Mb*ONE_MB) / sizeof(DWORD);
    DwordsPerThread = NumberOfDwords / NumberOfThreads;

    //
    // Initialize the Cell Vector
    //

    for(i=0, ExpectedRecalcValue; i<NumberOfDwords; i++ ){
        ExpectedRecalcValue += i;
        CellVector[i] = i;
        }

    //
    // Partition the work to the worker threads
    //

    for(i=0; i<NumberOfThreads; i++ ){
        ThreadWork[i].CellVector = &CellVector[i*DwordsPerThread];
        ThreadWork[i].NumberOfCells = DwordsPerThread;
        NumberOfDwords -= DwordsPerThread;

        //
        // If we have a remainder, give the remaining work to the last thread
        //

        if ( NumberOfDwords < DwordsPerThread ) {
            ThreadWork[i].NumberOfCells += NumberOfDwords;
            }
        }

    //
    // Create the worker threads
    //

    for(i=0; i<NumberOfThreads; i++ ) {
        ThreadHandles[i] = CreateThread(
                                NULL,
                                0,
                                WorkerThread,
                                (PVOID)i,
                                0,
                                &ThreadId
                                );
        if ( !ThreadHandles[i] ) {
            fprintf(stderr,"MTBNCH: Worker Thread Creation Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        }

    //
    // All of the worker threads will signal thier ready done event
    // when they are idle and ready to proceed. Once all events have been
    // set, then setting the hStartOfRaceEvent will begin the recalc
    //

    i = WaitForMultipleObjects(
            NumberOfThreads,
            ThreadReadyDoneEvents,
            TRUE,
            INFINITE
            );

    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"MTBNCH: Wait for threads to stabalize Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    //
    // Everthing is set to begin the recalc operation
    //

    StartTicks = GetTickCount();
    if ( !SetEvent(hStartOfRace) ) {
        fprintf(stderr,"MTBNCH: SetEvent(hStartOfRace) Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    //
    // Now just wait for the recalc to complete
    //

    i = WaitForMultipleObjects(
            NumberOfThreads,
            ThreadReadyDoneEvents,
            TRUE,
            INFINITE
            );

    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"MTBNCH: Wait for threads to complete Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    //
    // Now pick up the individual recalc values
    //

    for(i=0, ActualRecalcValue = 0; i<NumberOfThreads; i++ ){
        ActualRecalcValue += ThreadWork[i].RecalcResult;
        }

    EndTicks = GetTickCount();

    if ( fMemoryContention ) {
        if ( ContentionValue == (Mb*ONE_MB) / sizeof(DWORD) ) {
            if ( ActualRecalcValue == ExpectedRecalcValue ) {
                Answer = "Correct";
                }
            else {
                Answer = "Recalc Failure";
                }
            }
        else {
            Answer = "Contention Failure";
            }
        }
    else {
        if ( ActualRecalcValue == ExpectedRecalcValue ) {
            Answer = "Correct";
            }
        else {
            Answer = "Recalc Failure";
            }
        }

    fprintf(stdout,"MTBNCH: %d Thread Recalc complete in %dms, Answer = %s\n",
        NumberOfThreads,
        EndTicks-StartTicks,
        Answer
        );

    ExitProcess(2);
}

//
// The worker threads perform the recalc operation on their
// assigned cells. They begin by setting their ready done event
// to indicate that they are ready to begin the recalc. Then they
// wait until the hStartOfRace event is signaled. Once this occurs, they
// do their part of the recalc and when done they signal their ready done
// event and then wait on the hEndOfRaceEvent
//

DWORD
WorkerThread(
    PVOID ThreadIndex
    )
{

    DWORD Me;
    PDWORD MyCellVectorBase;
    PDWORD CurrentCellVector;
    DWORD MyRecalcValue;
    DWORD MyNumberOfCells;
    DWORD i;
    BOOL MemoryContention;

    Me = (DWORD)ThreadIndex;
    MyRecalcValue = 0;
    MyCellVectorBase = ThreadWork[Me].CellVector;
    MyNumberOfCells = ThreadWork[Me].NumberOfCells;
    MemoryContention = fMemoryContention;

    //
    // Signal that I am ready to go
    //

    if ( !SetEvent(ThreadReadyDoneEvents[Me]) ) {
        fprintf(stderr,"MTBNCH: (1) SetEvent(ThreadReadyDoneEvent[%d]) Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    //
    // Wait for the master to release us to do the recalc
    //

    i = WaitForSingleObject(hStartOfRace,INFINITE);
    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"MTBNCH: Thread %d Wait for start of recalc Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    //
    // perform the recalc operation
    //

    for (i=0, CurrentCellVector = MyCellVectorBase; i<MyNumberOfCells; i++ ) {
        MyRecalcValue += *CurrentCellVector++;
        if ( MemoryContention ) {
            InterlockedIncrement(&ContentionValue);
            }
        }
    ThreadWork[Me].RecalcResult = MyRecalcValue;

    //
    // Signal that I am done and then wait for further instructions
    //

    if ( !SetEvent(ThreadReadyDoneEvents[Me]) ) {
        fprintf(stderr,"MTBNCH: (2) SetEvent(ThreadReadyDoneEvent[%d]) Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    i = WaitForSingleObject(hEndOfRace,INFINITE);
    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"MTBNCH: Thread %d Wait for end of recalc Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    return MyRecalcValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\perfctr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfctr.c

Abstract:

    This module contains the Win32 Performance Counter APIs

Author:

    Russ Blake (russbl)  29-May-1992

Revision History:

--*/

#include "basedll.h"


BOOL
WINAPI
QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    )

/*++

    QueryPerformanceCounter -   provides access to a high-resolution
                                counter; frequency of this counter
                                is supplied by QueryPerformanceFrequency

        Inputs:

            lpPerformanceCount  -   a pointer to variable which
                                    will receive the counter

        Outputs:

            lpPerformanceCount  -   the current value of the counter,
                                    or 0 if it is not available

        Returns:

            TRUE if the performance counter is supported by the
            hardware, or FALSE if the performance counter is not
            supported by the hardware.


                                                                                            will receive the count

--*/

{
    LARGE_INTEGER PerfFreq;
    NTSTATUS Status;

    Status = NtQueryPerformanceCounter(lpPerformanceCount, &PerfFreq);

    if (!NT_SUCCESS(Status)) {
        // Call failed, report error
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }

    if (PerfFreq.LowPart == 0 && PerfFreq.HighPart == 0 ) {
        // Counter not supported
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    )

/*++

    QueryPerformanceFrequency -   provides the frequency of the high-
                                  resolution counter returned by
                                  QueryPerformanceCounter

        Inputs:


            lpFrequency         -   a pointer to variable which
                                    will receive the frequency

        Outputs:

            lpPerformanceCount  -   the frequency of the counter,
                                    or 0 if it is not available

        Returns:

            TRUE if the performance counter is supported by the
            hardware, or FALSE if the performance counter is not
            supported by the hardware.

--*/
{
    LARGE_INTEGER PerfCount;
    NTSTATUS Status;

    Status = NtQueryPerformanceCounter(&PerfCount, lpFrequency);

    if (!NT_SUCCESS(Status)) {
        // Call failed, report error
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }

    if (lpFrequency->LowPart == 0 && lpFrequency->HighPart == 0 ) {
        // Counter not supported
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\pipe.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pipe.c

Abstract:

    This module contains the Win32 Anonymous Pipe API

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"

ULONG PipeSerialNumber;

BOOL
APIENTRY
CreatePipe(
    OUT LPHANDLE lpReadPipe,
    OUT LPHANDLE lpWritePipe,
    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
    IN DWORD nSize
    )

/*++

Routine Description:

    The CreatePipe API is used to create an anonymous pipe I/O device.
    Two handles to the device are created.  One handle is opened for
    reading and the other is opened for writing.  These handles may be
    used in subsequent calls to ReadFile and WriteFile to transmit data
    through the pipe.

Arguments:

    lpReadPipe - Returns a handle to the read side of the pipe.  Data
        may be read from the pipe by specifying this handle value in a
        subsequent call to ReadFile.

    lpWritePipe - Returns a handle to the write side of the pipe.  Data
        may be written to the pipe by specifying this handle value in a
        subsequent call to WriteFile.

    lpPipeAttributes - An optional parameter that may be used to specify
        the attributes of the new pipe.  If the parameter is not
        specified, then the pipe is created without a security
        descriptor, and the resulting handles are not inherited on
        process creation.  Otherwise, the optional security attributes
        are used on the pipe, and the inherit handles flag effects both
        pipe handles.

    nSize - Supplies the requested buffer size for the pipe.  This is
        only a suggestion and is used by the operating system to
        calculate an appropriate buffering mechanism.  A value of zero
        indicates that the system is to choose the default buffering
        scheme.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    UCHAR PipeNameBuffer[ MAX_PATH ];
    ANSI_STRING PipeName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ReadPipeHandle, WritePipeHandle;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    LARGE_INTEGER Timeout;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PUNICODE_STRING Unicode;

    //
    //  Set the default timeout to 120 seconds
    //

    Timeout.QuadPart = - 10 * 1000 * 1000 * 120;

    if (nSize == 0) {
        nSize = 4096;
        }

    sprintf( PipeNameBuffer,
             WIN32_SS_PIPE_FORMAT_STRING,
             HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
             InterlockedIncrement(&PipeSerialNumber)
           );

    RtlInitAnsiString( &PipeName, PipeNameBuffer );
    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    Status = RtlAnsiStringToUnicodeString(Unicode,&PipeName,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpPipeAttributes) ) {
        Attributes =
              lpPipeAttributes->bInheritHandle ? (OBJ_INHERIT | OBJ_CASE_INSENSITIVE) : (OBJ_CASE_INSENSITIVE);
        SecurityDescriptor = lpPipeAttributes->lpSecurityDescriptor;
        }
    else {
        Attributes = OBJ_CASE_INSENSITIVE;
        SecurityDescriptor = NULL;
        }

    InitializeObjectAttributes( &ObjectAttributes,
                                Unicode,
                                Attributes,
                                NULL,
                                SecurityDescriptor
                              );

    Status = NtCreateNamedPipeFile( &ReadPipeHandle,
                                    GENERIC_READ | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                                    &ObjectAttributes,
                                    &Iosb,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE, // Gary ?
                                    FILE_CREATE,
                                    FILE_SYNCHRONOUS_IO_NONALERT,
                                    FILE_PIPE_BYTE_STREAM_TYPE,
                                    FILE_PIPE_BYTE_STREAM_MODE,
                                    FILE_PIPE_QUEUE_OPERATION,
                                    1,
                                    nSize,
                                    nSize,
                                    (PLARGE_INTEGER) &Timeout
                                  );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
        }

    Status = NtOpenFile( &WritePipeHandle,
                         GENERIC_WRITE | SYNCHRONIZE,
                         &ObjectAttributes,
                         &Iosb,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        NtClose( ReadPipeHandle );
        BaseSetLastNTError( Status );
        return( FALSE );
        }

    *lpReadPipe = ReadPipeHandle;
    *lpWritePipe = WritePipeHandle;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\pperf.c ===
#include "stdio.h"
#include "string.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"

#define SPD_PROCESS_ITERATIONS 15

//
// Define local types.
//

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    ULONG ContextSwitches;
    ULONG InterruptCount;
    ULONG FirstLevelFills;
    ULONG SecondLevelFills;
    ULONG SystemCalls;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

VOID
SuspendedProcessTest(
    VOID
    );

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    );

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    );

VOID
main(
    int argc,
    char *argv[]
    )

{
    if ( !_strcmpi("just exit",GetCommandLine()) ) {
        return;
        }
    SuspendedProcessTest();
    return;
}

VOID
SuspendedProcessTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    STARTUPINFO si;
    PROCESS_INFORMATION pi[SPD_PROCESS_ITERATIONS];
    BOOL b;
    int Index;
    CHAR Buffer[256];
    KPRIORITY Base;

    GetModuleFileName(0,Buffer,256);

    RtlZeroMemory(&si,sizeof(si));
    si.cb = sizeof(si);

    Base = 13;
    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &Base,
        sizeof(Base)
        );
//    SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    StartBenchMark("Suspended Process Creation Benchmark)",
                   SPD_PROCESS_ITERATIONS,
                   &PerfInfo);

    for (Index = 0; Index < SPD_PROCESS_ITERATIONS; Index += 1) {
        b = CreateProcess(
                Buffer,
                "just exit",
                NULL,
                NULL,
                TRUE,
                CREATE_SUSPENDED,
                NULL,
                NULL,
                &si,
                &pi[Index]
                );
        if ( !b ) {
            printf("failed %ld\n",Index);
            }
        }
    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
//    SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS);

    StartBenchMark("Process Startup/Exit Benchmark)",
                   SPD_PROCESS_ITERATIONS,
                   &PerfInfo);
    for (Index = 0; Index < SPD_PROCESS_ITERATIONS; Index += 1) {
        ResumeThread(pi[Index].hThread);
        CloseHandle(pi[Index].hThread);
        WaitForSingleObject(pi[Index].hProcess,-1);
        CloseHandle(pi[Index].hProcess);
        }
    FinishBenchMark(&PerfInfo);

    //
    // End of event1 context switch test.
    //

    return;
}

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    ULONG ContextSwitches;
    LARGE_INTEGER Duration;
    ULONG FirstLevelFills;
    ULONG InterruptCount;
    ULONG Length;
    ULONG Performance;
    ULONG SecondLevelFills;
    NTSTATUS Status;
    ULONG SystemCalls;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;


    //
    // Print results and announce end of test.
    //

    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StopTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    Duration = RtlLargeIntegerSubtract(PerfInfo->StopTime, PerfInfo->StartTime);
    Length = Duration.LowPart / 10000;
    printf("        Test time in milliseconds %d\n", Length);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = PerfInfo->Iterations * 1000 / Length;
    printf("        Iterations per second     %d\n", Performance);

    ContextSwitches = SystemInfo.ContextSwitches - PerfInfo->ContextSwitches;
    FirstLevelFills = SystemInfo.FirstLevelTbFills - PerfInfo->FirstLevelFills;
    InterruptCount = SystemInfo.InterruptCount - PerfInfo->InterruptCount;
    SecondLevelFills = SystemInfo.SecondLevelTbFills - PerfInfo->SecondLevelFills;
    SystemCalls = SystemInfo.SystemCalls - PerfInfo->SystemCalls;
    printf("        First Level TB Fills      %d\n", FirstLevelFills);
    printf("        Second Level TB Fills     %d\n", SecondLevelFills);
    printf("        Number of Interrupts      %d\n", InterruptCount);
    printf("        Total Context Switches    %d\n", ContextSwitches);
    printf("        Number of System Calls    %d\n", SystemCalls);

    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    )

{

    NTSTATUS Status;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StartTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    PerfInfo->ContextSwitches = SystemInfo.ContextSwitches;
    PerfInfo->FirstLevelFills = SystemInfo.FirstLevelTbFills;
    PerfInfo->InterruptCount = SystemInfo.InterruptCount;
    PerfInfo->SecondLevelFills = SystemInfo.SecondLevelTbFills;
    PerfInfo->SystemCalls = SystemInfo.SystemCalls;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\res.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    res.c

Abstract:

    This module implements Win32 Resource Manager APIs

Author:

    Rob Earhart (Earhart) 04-Apr-2001

Revision History:

--*/

#include "basedll.h"

//
// N.B. This is a stub implementation intended to provide basic
//      resource management interfaces for applications which care
//      about their memory usage.  It is NOT the final version of the
//      usermode side of the resource manager.
//


//
// Globals used by the routines in this module
//

const WCHAR BasepMmLowMemoryConditionEventName[] = L"\\KernelObjects\\LowMemoryCondition";
const WCHAR BasepMmHighMemoryConditionEventName[] = L"\\KernelObjects\\HighMemoryCondition";

HANDLE
APIENTRY
CreateMemoryResourceNotification(
    IN MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    )

/*++

Routine Description:

    Creates a memory resource notification handle.  Memory resource
    notification handles monitor memory for changes, and are used
    to query information about memory.

Arguments:

    NotificationType -- the type of notification requested

Return Value:

    Non-NULL - a handle to the new subscription object.

    NULL - The operation failed.  Extended error status is available
           using GetLastError.

--*/

{
    LPCWSTR           EventName;
    HANDLE            Handle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    ObjectName;
    NTSTATUS          Status;

    //
    // Determine the event in which the caller's interested.
    //
    switch (NotificationType) {
    case LowMemoryResourceNotification:
        //
        // It's the low memory condition event
        //
        EventName = BasepMmLowMemoryConditionEventName;
        break;

    case HighMemoryResourceNotification:
        //
        // It's the high memory condition event
        //
        EventName = BasepMmHighMemoryConditionEventName;
        break;

    default:
        //
        // Not one of our known event-of-interest types; all we can do 
        // is indicate an invalid parameter, and return a failure
        // condition.
        //

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;

    }
    

    //
    // Attempt the actual event open
    //
    RtlInitUnicodeString(&ObjectName, EventName);

    InitializeObjectAttributes(&Obja,
                               &ObjectName,
                               0,
                               NULL,
                               NULL);

    Status = NtOpenEvent(&Handle,
                         SYNCHRONIZE | EVENT_QUERY_STATE,
                         &Obja);

    if (! NT_SUCCESS(Status)) {
        //
        // We failed to open the event for some reason.
        //
        BaseSetLastNTError(Status);
        return NULL;
    }

    //
    // Otherwise, we have the handle, so we're all set; just return it.
    //

    return Handle;
}

BOOL
APIENTRY
QueryMemoryResourceNotification(
    IN HANDLE ResourceNotificationHandle,
    IN PBOOL  ResourceState
    )

/*++

Routine Description:

    Query a memory resource notification handle for information about
    the associated memory resources.

Arguments:

    ResourceNotificationHandle - a handle to the memory resource
                                 notification to query.

    ResourceState - location to put the information about the memory
                    resource

Return Value:

    TRUE - The query succeeded.

    FALSE - The query failed.  Extended error status is available
            using GetLastError.

--*/

{
    EVENT_BASIC_INFORMATION      EventInfo;
    NTSTATUS                     Status;

    //
    // Check parameter validity
    //
    if (! ResourceNotificationHandle
        || ResourceNotificationHandle == INVALID_HANDLE_VALUE
        || ! ResourceState) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Get the event's current state
    //
    Status = NtQueryEvent(ResourceNotificationHandle,
                          EventBasicInformation,
                          &EventInfo,
                          sizeof(EventInfo),
                          NULL);

    if (! NT_SUCCESS(Status)) {
        //
        // On failure, set the last NT error and indicate the failure
        // condition to our caller.
        //
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Fill in the state
    //
    *ResourceState = (EventInfo.EventState == 1);

    //
    // And we're done -- return success to our caller.
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\sources.inc ===
MAJORCOMP=windows
MINORCOMP=base

SYNCHRONIZE_DRAIN=1

TARGETNAME=kernel32
TARGETPATH=obj
TARGETTYPE=DYNLINK
W32_SB=1

NTTARGETFILE1= \
    $(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\kernl32p.lib \
    $(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\kernel32.lib

DLLDEF=$(O)\kernel32.def

LINKLIBS=\
    $(WINDOWS_LIB_PATH)\conlibk.lib \
    $(PROJECT_ROOT)\win32\winnls\$(ALT_PROJECT)\$(O)\nlslib.lib \
    $(PROJECT_LIB_PATH)\dload.lib \
    $(SDK_LIB_PATH)\ntdll.lib


TARGETLIBS=\
    $(PROJECT_ROOT)\win32\lz32\winlza\$(O)\winlza.lib

DLLENTRY=BaseDllInitialize

USE_NTDLL=1

INCLUDES=\
    ..;\
    ..\..\inc;\
    $(DS_INC_PATH);\
    $(WINDOWS_INC_PATH);\
    $(TERMSRV_INC_PATH);\
    $(SDKTOOLS_INC_PATH);\
    $(PROJECT_ROOT)\published\$(O);\
    $(PROJECT_ROOT)\win32\lz32\winlza;

CONDITIONAL_INCLUDES=doswin32.h

C_DEFINES=$(C_DEFINES) -D_KERNEL32_

MSC_WARNING_LEVEL=/W3 /WX

DLLORDER=..\kernel32.prf

SOURCES= \
    ..\alignstr.c \
    ..\base.rc    \
    ..\backup.c   \
    ..\beep.c     \
    ..\compname.c \
    ..\copylz.c   \
    ..\curdir.c   \
    ..\datetime.c \
    ..\debug.c    \
    ..\dir.c      \
    ..\dllatom.c  \
    ..\dllini.c   \
    ..\dosdev.c   \
    ..\error.c    \
    ..\filefind.c \
    ..\filehops.c \
    ..\filemap.c  \
    ..\filemisc.c \
    ..\fileopcr.c \
    ..\firmware.c \
    ..\gmem.c     \
    ..\handle.c   \
    ..\baseinit.c \
    ..\lcompat.c  \
    ..\lmem.c     \
    ..\mailslot.c \
    ..\message.c  \
    ..\module.c   \
    ..\namepipe.c \
    ..\numa.c     \
    ..\pathmisc.c \
    ..\perfctr.c  \
    ..\pipe.c     \
    ..\power.c    \
    ..\process.c  \
    ..\res.c      \
    ..\sessdev.c  \
    ..\support.c  \
    ..\synch.c    \
    ..\termutil.c \
    ..\thread.c   \
    ..\toolhelp.c \
    ..\ustubs.c   \
    ..\winlzexp.c \
    ..\comm.c     \
    ..\vdm.c      \
    ..\volmount.c \
    ..\updrsrc.cpp   \
    ..\blddcb.c   \
    ..\tapeapi.c  \
    ..\job.c      \
    ..\winlinks.c \
    ..\w98stubs.c \
    ..\sxs.c      \
    ..\sxsfind.c  \
    ..\csrsxs.c   \
    ..\compsup.c  \
    ..\ahcache.c

UMTYPE=console
OPTIONAL_UMTEST=tatom*tprof*taskstrs*winperf*tbase*tprof*tfile*ttask*tmem*tlfn

PRECOMPILED_INCLUDE=..\basedll.h
PRECOMPILED_PCH=basedll.pch
PRECOMPILED_OBJ=basedll.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\sessdev.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sessdev.c

Abstract:

    Per Session Dos Device access routines

Author:


Revision History:

--*/

#include "basedll.h"


#define SESSION0_ROOT L"GLOBALROOT"
#define SESSIONX_ROOT L"GLOBALROOT\\Sessions\\"



BOOL
WINAPI
DosPathToSessionPathA(
    IN DWORD   SessionId,
    IN LPCSTR pInPath,
    OUT LPSTR  *ppOutPath
    )

/*++

Routine Description:

    Converts a DOS path relative to the current session to a DOS path
    that allows access to a specific session.

Arguments:

    SessionId - SessionId to access.

    pInPath   - WIN32 DOS path. Could be of the form "C:", "LPT1:",
                "C:\file\path", etc.

    ppOutPath - Output path that accesses the specified session.
                If pIniPath is "C:" and SessionId is 6, the output would be
                "GLOBALROOT\Sessions\6\DosDevices\C:".

Return Value:

    TRUE - Path returned in *ppOutPath in newly allocated memory from
           LocalAlloc.
    FALSE - Call failed. Error code returned via GetLastError()

--*/

{
    BOOL rc;
    DWORD Len;
    PCHAR Buf;
    NTSTATUS Status;
    PWCHAR pOutPath;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    // if the input path is null or the pointer is a bad pointer, return
    // an error.

    if( (pInPath == 0) ||
        (IsBadReadPtr( pInPath, sizeof( CHAR ))) ||
        (IsBadWritePtr( ppOutPath, sizeof(LPSTR) )) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    try {

        RtlInitAnsiString( &AnsiString, pInPath );
        Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
    }

    rc = DosPathToSessionPathW(
             SessionId,
             UnicodeString.Buffer,
             &pOutPath
             );

    RtlFreeUnicodeString( &UnicodeString );

    if( !rc ) {
        return( rc );
    }

    RtlInitUnicodeString( &UnicodeString, pOutPath );
    Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, TRUE );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        LocalFree( pOutPath );
        return FALSE;
    }

    Len = strlen( AnsiString.Buffer ) + 1;
    Buf = LocalAlloc(LMEM_FIXED, Len);

    if( Buf == NULL ) {
        LocalFree( pOutPath );
        RtlFreeAnsiString( &AnsiString );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    strcpy( Buf, AnsiString.Buffer );

    *ppOutPath = Buf;

    LocalFree( pOutPath );
    RtlFreeAnsiString( &AnsiString );

    return(TRUE);
}


BOOL
WINAPI
DosPathToSessionPathW(
    IN DWORD   SessionId,
    IN LPCWSTR  pInPath,
    OUT LPWSTR  *ppOutPath
    )

/*++

Routine Description:

    Converts a DOS path relative to the current session to a DOS path
    that allows access to a specific session.

Arguments:

    SessionId - SessionId to access.

    pInPath   - WIN32 DOS path. Could be of the form "C:", "LPT1:",
                "C:\file\path", etc.

    ppOutPath - Output path that accesses the specified session.
                If pIniPath is "C:" and SessionId is 6, the output would be
                "GLOBALROOT\Sessions\6\DosDevices\C:".

Return Value:

    TRUE - Path returned in *ppOutPath in newly allocated memory from
           LocalAlloc.
    FALSE - Call failed. Error code returned via GetLastError()

--*/

{
    PWCHAR Buf;
    ULONG  Len;

    //
    // SessionId 0 has no per session object directories.
    //
    if (BaseStaticServerData->LUIDDeviceMapsEnabled == TRUE) {

        Len = 0;

    } else {

        if( SessionId == 0 ) {
            Len =  wcslen(SESSION0_ROOT);
        }
        else {
            Len =  wcslen(SESSIONX_ROOT);
            Len += 10;                     // Max DWORD width
        }
    }

    Len += 13;                         // \DosDevices\ ... <NULL>

    // if the input path is null or the pointer is a bad pointer, return
    // an error.

    if( (pInPath == 0) ||
        (IsBadReadPtr( pInPath, sizeof( WCHAR ))) ||
        (IsBadWritePtr( ppOutPath, sizeof(LPWSTR) )) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    Len += wcslen(pInPath);

    Buf = LocalAlloc(LMEM_FIXED, Len * sizeof(WCHAR));
    if( Buf == NULL ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    try {
        if (BaseStaticServerData->LUIDDeviceMapsEnabled == TRUE) {

            // C: -> C:
            swprintf(
                Buf,
                L"%ws",
                pInPath
                );

        } else {

            if( SessionId == 0 ) {
                // C: -> GLOBALROOT\DosDevices\C:
                swprintf(
                    Buf,
                    L"%ws\\DosDevices\\%ws",
                    SESSION0_ROOT,
                    pInPath
                    );
            }
            else {
                // C: -> GLOBALROOT\Sessions\6\DosDevices\C:
                swprintf(
                    Buf,
                    L"%ws%u\\DosDevices\\%ws",
                    SESSIONX_ROOT,
                    SessionId,
                    pInPath
                    );
            }
        }

        *ppOutPath = Buf;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        BaseSetLastNTError(GetExceptionCode());
        return(FALSE);
    }


    return(TRUE);
}


BOOL
WINAPI
ProcessIdToSessionId(
    IN  DWORD  dwProcessId,
    OUT DWORD *pSessionId
    )

/*++

Routine Description:

    Given a ProcessId, return the SessionId.

    This is useful for services that impersonate a caller, and
    redefine a drive letter for the caller. An example is the
    workstation service. Transport specific routines allow the
    ProcessId of the caller to be retrieved.

Arguments:

    Process -  Process identifies process to
                return the SessionId for.

    pSessionId - returned SessionId.

Return Value:

    TRUE - SessionId returned in *pSessionId
    FALSE - Call failed. Error code returned via GetLastError()

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES Obja;
    PROCESS_SESSION_INFORMATION Info;


    if( IsBadWritePtr( pSessionId, sizeof(DWORD) ) )   {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    InitializeObjectAttributes(
        &Obja,
        NULL,
        0,
        NULL,
        NULL
        );

    ClientId.UniqueProcess = (HANDLE) LongToHandle(dwProcessId);
    ClientId.UniqueThread = (HANDLE)NULL;

    Status = NtOpenProcess(
                 &Handle,
                 (ACCESS_MASK)PROCESS_QUERY_INFORMATION,
                 &Obja,
                 &ClientId
                 );

    if( !NT_SUCCESS(Status) ) {
        SetLastError(RtlNtStatusToDosError(Status));
        return(FALSE);
    }

    Status = NtQueryInformationProcess(
                 Handle,
                 ProcessSessionInformation,
                 &Info,
                 sizeof(Info),
                 NULL
                 );

    if( !NT_SUCCESS(Status) ) {
        NtClose( Handle );
        SetLastError(RtlNtStatusToDosError(Status));
        return(FALSE);
    }

    *pSessionId = Info.SessionId;

    NtClose( Handle );

    return(TRUE);
}


DWORD
WINAPI
WTSGetActiveConsoleSessionId ()
/*++

Routine Description:

    returns the Session ID for the session, attached to Console.

Arguments:

    none

Return Value:

    SessionID for the console (session attached to console not necessarily session 0 ) session.
    return 0xFFFFFFFF if there is no session attached to console.
    This could happen if session disconnect / connect is taking place

    This is a session id for the session currently connected to console, it changes when
    new session is connected at console. to keep track of the current console sesion, use
    WTSRegisterSessionNotification


--*/
{
    return (USER_SHARED_DATA->ActiveConsoleId);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\power.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    power.c

Abstract:

    Stubs for unimplemented power management APIs

Author:

    Steve Wood (stevewo) 18-Nov-1994

Revision History:

--*/

#include "basedll.h"


BOOL
WINAPI
GetSystemPowerStatus(
    LPSYSTEM_POWER_STATUS lpStatus
    )
{
    SYSTEM_BATTERY_STATE    BatteryState;
    NTSTATUS                Status;

    //
    // Get power policy managers Battery State
    //

    Status = NtPowerInformation (
                SystemBatteryState,
                NULL,
                0,
                &BatteryState,
                sizeof (BatteryState)
                );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Convert it to the legacy System Power State structure
    //

    RtlZeroMemory (lpStatus, sizeof(*lpStatus));

    lpStatus->ACLineStatus = AC_LINE_ONLINE;
    if (BatteryState.BatteryPresent && !BatteryState.AcOnLine) {
        lpStatus->ACLineStatus = AC_LINE_OFFLINE;
    }

    if (BatteryState.Charging) {
        lpStatus->BatteryFlag |= BATTERY_FLAG_CHARGING;
    }

    if (!BatteryState.BatteryPresent) {
        lpStatus->BatteryFlag |= BATTERY_FLAG_NO_BATTERY;
    }

    lpStatus->BatteryLifePercent = BATTERY_PERCENTAGE_UNKNOWN;
    if (BatteryState.MaxCapacity) {
        if (BatteryState.RemainingCapacity > BatteryState.MaxCapacity) {

            //
            // Values greater than 100% should not be returned
            // According to the SDK they are reserved.
            //

            lpStatus->BatteryLifePercent = 100;
        } else {
            lpStatus->BatteryLifePercent = (UCHAR)
                (((BatteryState.RemainingCapacity * 100) +
                  (BatteryState.MaxCapacity/2)) /
                 BatteryState.MaxCapacity);
        }

        if (lpStatus->BatteryLifePercent > 66) {
            lpStatus->BatteryFlag |= BATTERY_FLAG_HIGH;
        }

        if (lpStatus->BatteryLifePercent < 33) {
            lpStatus->BatteryFlag |= BATTERY_FLAG_LOW;
        }
    }

    lpStatus->BatteryLifeTime = BATTERY_LIFE_UNKNOWN;
    lpStatus->BatteryFullLifeTime = BATTERY_LIFE_UNKNOWN;
    if (BatteryState.EstimatedTime) {
        lpStatus->BatteryLifeTime = BatteryState.EstimatedTime;
    }

    return TRUE;
}

BOOL
WINAPI
SetSystemPowerState(
    BOOL fSuspend,
    BOOL fForce
    )
{
    NTSTATUS        Status;

    Status = NtInitiatePowerAction (fSuspend ? PowerActionSleep : PowerActionHibernate,
                                    fSuspend ? PowerSystemSleeping1 : PowerSystemHibernate,
                                    fForce == TRUE ? 0 : POWER_ACTION_QUERY_ALLOWED,
                                    FALSE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


EXECUTION_STATE
WINAPI
SetThreadExecutionState(
    EXECUTION_STATE esFlags
    )
{
    NTSTATUS            Status;
    EXECUTION_STATE     PreviousFlags;

    Status = NtSetThreadExecutionState (esFlags, &PreviousFlags);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return (EXECUTION_STATE) 0;
    }

    return PreviousFlags;
}

BOOL
WINAPI
RequestWakeupLatency (
    LATENCY_TIME    latency
    )
{
    NTSTATUS        Status;

    Status = NtRequestWakeupLatency (latency);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
GetDevicePowerState(
    HANDLE  h,
    OUT BOOL *pfOn
    )
{
    NTSTATUS Status;
    DEVICE_POWER_STATE PowerState;

    Status = NtGetDevicePowerState(h, &PowerState);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }
    if ((PowerState == PowerDeviceD0) ||
        (PowerState == PowerDeviceUnspecified)) {
        *pfOn = TRUE;
    } else {
        *pfOn = FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
IsSystemResumeAutomatic(
    VOID
    )
{
    return(NtIsSystemResumeAutomatic());
}

BOOL
WINAPI
RequestDeviceWakeup (
    HANDLE  h
    )
{
    NTSTATUS Status;

    Status = NtRequestDeviceWakeup(h);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        return(TRUE);
    }
}


BOOL
WINAPI
CancelDeviceWakeupRequest(
    HANDLE  h
    )
{
    NTSTATUS Status;

    Status = NtCancelDeviceWakeupRequest(h);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        return(TRUE);
    }
}



BOOL
WINAPI
SetMessageWaitingIndicator (
    IN HANDLE hMsgIndicator,
    IN ULONG ulMsgCount
    )
{
    BaseSetLastNTError(STATUS_NOT_IMPLEMENTED);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\support.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    support.c

Abstract:

    This module implements various conversion routines
    that transform Win32 parameters into NT parameters.

Author:

    Mark Lucovsky (markl) 20-Sep-1990

Revision History:

--*/

#include "basedll.h"

PCLDR_DATA_TABLE_ENTRY BasepExeLdrEntry = NULL;

// N.B. These are the registry values we check for SafeDllSearchMode,
//      and MUST match the entries in BasepDllSearchPaths
typedef enum {
    BasepCurrentDirUninitialized = -1,
    BasepCurrentDirAtStart       =  0,
    BasepCurrentDirAfterSystem32 =  1,
    MaxBasepCurrentDir
} BASEP_CURDIR_PLACEMENT;

#define BASEP_DEFAULT_DLL_CURDIR_PLACEMENT (BasepCurrentDirAfterSystem32)

#define BASEP_VALID_CURDIR_PLACEMENT_P(c) (BasepCurrentDirUninitialized < (c)  \
                                           && (c) < MaxBasepCurrentDir)

LONG BasepDllCurrentDirPlacement = BasepCurrentDirUninitialized;

typedef enum {
    BasepSearchPathEnd,         // end of path
    BasepSearchPathDlldir,      // use the dll dir; fallback to nothing
    BasepSearchPathAppdir,      // use the exe dir; fallback to base exe dir
    BasepSearchPathDefaultDirs, // use the default system dirs
    BasepSearchPathEnvPath,     // use %PATH%
    BasepSearchPathCurdir,      // use "."
    MaxBasepSearchPath
} BASEP_SEARCH_PATH_ELEMENT;

// N.B. The ordering of these must match the definitions for
//      BASEP_CURDIR_PLACEMENT.
static const BASEP_SEARCH_PATH_ELEMENT BasepDllSearchPaths[MaxBasepCurrentDir][7] = 
{
    {
        // BasepCurrentDirAtStart
        BasepSearchPathAppdir,
        BasepSearchPathCurdir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    },
    {
        // BasepCurrentDirAfterSystem32
        BasepSearchPathAppdir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathCurdir,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    }
};


POBJECT_ATTRIBUTES
BaseFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    IN PSECURITY_ATTRIBUTES SecurityAttributes,
    IN PUNICODE_STRING ObjectName
    )

/*++

Routine Description:

    This function transforms a Win32 security attributes structure into
    an NT object attributes structure.  It returns the address of the
    resulting structure (or NULL if SecurityAttributes was not
    specified).

Arguments:

    ObjectAttributes - Returns an initialized NT object attributes
        structure that contains a superset of the information provided
        by the security attributes structure.

    SecurityAttributes - Supplies the address of a security attributes
        structure that needs to be transformed into an NT object
        attributes structure.

    ObjectName - Supplies a name for the object relative to the
        BaseNamedObjectDirectory object directory.

Return Value:

    NULL - A value of null should be used to mimic the behavior of the
        specified SecurityAttributes structure.

    NON-NULL - Returns the ObjectAttributes value.  The structure is
        properly initialized by this function.

--*/

{
    HANDLE RootDirectory;
    ULONG Attributes;
    PVOID SecurityDescriptor;

    if ( ARGUMENT_PRESENT(SecurityAttributes) ||
         ARGUMENT_PRESENT(ObjectName) ) {

        if ( ARGUMENT_PRESENT(ObjectName) ) {
            RootDirectory = BaseGetNamedObjectDirectory();
            }
        else {
            RootDirectory = NULL;
            }

        if ( SecurityAttributes ) {
            Attributes = (SecurityAttributes->bInheritHandle ? OBJ_INHERIT : 0);
            SecurityDescriptor = SecurityAttributes->lpSecurityDescriptor;
            }
        else {
            Attributes = 0;
            SecurityDescriptor = NULL;
            }

        if ( ARGUMENT_PRESENT(ObjectName) ) {
            Attributes |= OBJ_OPENIF;
            }

        InitializeObjectAttributes(
            ObjectAttributes,
            ObjectName,
            Attributes,
            RootDirectory,
            SecurityDescriptor
            );
        return ObjectAttributes;
        }
    else {
        return NULL;
        }
}

PLARGE_INTEGER
BaseFormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    )

/*++

Routine Description:

    This function translates a Win32 style timeout to an NT relative
    timeout value.

Arguments:

    TimeOut - Returns an initialized NT timeout value that is equivalent
         to the Milliseconds parameter.

    Milliseconds - Supplies the timeout value in milliseconds.  A value
         of -1 indicates indefinite timeout.

Return Value:


    NULL - A value of null should be used to mimic the behavior of the
        specified Milliseconds parameter.

    NON-NULL - Returns the TimeOut value.  The structure is properly
        initialized by this function.

--*/

{
    if ( (LONG) Milliseconds == -1 ) {
        return( NULL );
        }
    TimeOut->QuadPart = UInt32x32To64( Milliseconds, 10000 );
    TimeOut->QuadPart *= -1;
    return TimeOut;
}


NTSTATUS
BaseCreateStack(
    IN HANDLE Process,
    IN SIZE_T StackSize,
    IN SIZE_T MaximumStackSize,
    OUT PINITIAL_TEB InitialTeb
    )

/*++

Routine Description:

    This function creates a stack for the specified process.

Arguments:

    Process - Supplies a handle to the process that the stack will
        be allocated within.

    StackSize - An optional parameter, that if specified, supplies
        the initial commit size for the stack.

    MaximumStackSize - Supplies the maximum size for the new threads stack.
        If this parameter is not specified, then the reserve size of the
        current images stack descriptor is used.

    InitialTeb - Returns a populated InitialTeb that contains
        the stack size and limits.

Return Value:

    TRUE - A stack was successfully created.

    FALSE - The stack counld not be created.

--*/

{
    NTSTATUS Status;
    PCH Stack;
    BOOLEAN GuardPage;
    SIZE_T RegionSize;
    ULONG OldProtect;
    SIZE_T ImageStackSize, ImageStackCommit;
    PIMAGE_NT_HEADERS NtHeaders;
    PPEB Peb;
    ULONG PageSize;

    Peb = NtCurrentPeb();

    BaseStaticServerData = BASE_SHARED_SERVER_DATA;
    PageSize = BASE_SYSINFO.PageSize;

    //
    // If the stack size was not supplied, then use the sizes from the
    // image header.
    //

    NtHeaders = RtlImageNtHeader(Peb->ImageBaseAddress);
    if (!NtHeaders) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }
    ImageStackSize = NtHeaders->OptionalHeader.SizeOfStackReserve;
    ImageStackCommit = NtHeaders->OptionalHeader.SizeOfStackCommit;

    if ( !MaximumStackSize ) {
        MaximumStackSize = ImageStackSize;
    }
    if (!StackSize) {
        StackSize = ImageStackCommit;
    }
    else {

        //
        // Now Compute how much additional stack space is to be
        // reserved.  This is done by...  If the StackSize is <=
        // Reserved size in the image, then reserve whatever the image
        // specifies.  Otherwise, round up to 1Mb.
        //

        if ( StackSize >= MaximumStackSize ) {
            MaximumStackSize = ROUND_UP(StackSize, (1024*1024));
        }
    }

    //
    // Align the stack size to a page boundry and the reserved size
    // to an allocation granularity boundry.
    //

    StackSize = ROUND_UP( StackSize, PageSize );

    MaximumStackSize = ROUND_UP(
                        MaximumStackSize,
                        BASE_SYSINFO.AllocationGranularity
                        );

    //
    // Enforce a minimal stack commit if there is a PEB setting
    // for this.
    //

    {
        SIZE_T MinimumStackCommit;

        MinimumStackCommit = NtCurrentPeb()->MinimumStackCommit;
        
        if (MinimumStackCommit != 0 && StackSize < MinimumStackCommit) {
            StackSize = MinimumStackCommit;
        }

        //
        // Recheck and realign reserve size
        //
        
        if ( StackSize >= MaximumStackSize ) {
            MaximumStackSize = ROUND_UP (StackSize, (1024*1024));
        }
    
        StackSize = ROUND_UP (StackSize, PageSize);
        MaximumStackSize = ROUND_UP (MaximumStackSize, BASE_SYSINFO.AllocationGranularity);
    }

#if !defined (_IA64_)

    //
    // Reserve address space for the stack
    //

    Stack = NULL;

    Status = NtAllocateVirtualMemory(
                Process,
                (PVOID *)&Stack,
                0,
                &MaximumStackSize,
                MEM_RESERVE,
                PAGE_READWRITE
                );
#else

    //
    // Take RseStack into consideration.
    // RSE stack has same size as memory stack, has same StackBase,
    // has a guard page at the end, and grows upwards towards higher
    // memory addresses
    //

    //
    // Reserve address space for the two stacks
    //
    {
        SIZE_T TotalStackSize = MaximumStackSize * 2;

        Stack = NULL;

        Status = NtAllocateVirtualMemory(
                    Process,
                    (PVOID *)&Stack,
                    0,
                    &TotalStackSize,
                    MEM_RESERVE,
                    PAGE_READWRITE
                    );
    }

#endif // IA64
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
        }

    InitialTeb->OldInitialTeb.OldStackBase = NULL;
    InitialTeb->OldInitialTeb.OldStackLimit = NULL;
    InitialTeb->StackAllocationBase = Stack;
    InitialTeb->StackBase = Stack + MaximumStackSize;

#if defined (_IA64_)
    InitialTeb->OldInitialTeb.OldBStoreLimit = NULL;
#endif //IA64

    Stack += MaximumStackSize - StackSize;
    if (MaximumStackSize > StackSize) {
        Stack -= PageSize;
        StackSize += PageSize;
        GuardPage = TRUE;
        }
    else {
        GuardPage = FALSE;
        }

    //
    // Commit the initially valid portion of the stack
    //

#if !defined(_IA64_)

    Status = NtAllocateVirtualMemory(
                Process,
                (PVOID *)&Stack,
                0,
                &StackSize,
                MEM_COMMIT,
                PAGE_READWRITE
                );
#else
    {
	//
	// memory and rse stacks are expected to be contiguous
	// reserver virtual memory for both stack at once
	//
        SIZE_T NewCommittedStackSize = StackSize * 2;

        Status = NtAllocateVirtualMemory(
                    Process,
                    (PVOID *)&Stack,
                    0,
                    &NewCommittedStackSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );
    }

#endif //IA64

    if ( !NT_SUCCESS( Status ) ) {

        //
        // If the commit fails, then delete the address space for the stack
        //

        RegionSize = 0;
        NtFreeVirtualMemory(
            Process,
            (PVOID *)&Stack,
            &RegionSize,
            MEM_RELEASE
            );

        return Status;
        }

    InitialTeb->StackLimit = Stack;

#if defined(_IA64_)
    InitialTeb->BStoreLimit = Stack + 2 * StackSize;
#endif

    //
    // if we have space, create a guard page.
    //

    if (GuardPage) {
        RegionSize = PageSize;
        Status = NtProtectVirtualMemory(
                    Process,
                    (PVOID *)&Stack,
                    &RegionSize,
                    PAGE_GUARD | PAGE_READWRITE,
                    &OldProtect
                    );
        if ( !NT_SUCCESS( Status ) ) {
            return Status;
            }
        InitialTeb->StackLimit = (PVOID)((PUCHAR)InitialTeb->StackLimit + RegionSize);

#if defined(_IA64_)
	//
        // additional code to Create RSE stack guard page
        //
        Stack = ((PCH)InitialTeb->StackBase) + StackSize - PageSize;
        RegionSize = PageSize;
        Status = NtProtectVirtualMemory(
                    Process,
                    (PVOID *)&Stack,
                    &RegionSize,
                    PAGE_GUARD | PAGE_READWRITE,
                    &OldProtect
                    );
        if ( !NT_SUCCESS( Status ) ) {
            return Status;
            }
        InitialTeb->BStoreLimit = (PVOID)Stack;

#endif // IA64

        }

    return STATUS_SUCCESS;
}

VOID
BaseThreadStart(
    IN LPTHREAD_START_ROUTINE lpStartAddress,
    IN LPVOID lpParameter
    )

/*++

Routine Description:

    This function is called to start a Win32 thread. Its purpose
    is to call the thread, and if the thread returns, to terminate
    the thread and delete its stack.

Arguments:

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns and that
        accepts a single 32-bit pointer argument.

    lpParameter - Supplies a single parameter value passed to the thread.

Return Value:

    None.

--*/

{
    try {

        //
        // test for fiber start or new thread
        //

        //
        // WARNING WARNING DO NOT CHANGE INIT OF NtTib.Version. There is
        // external code depending on this initialization !
        //
        if ( NtCurrentTeb()->NtTib.Version == OS2_VERSION ) {
            if ( !BaseRunningInServerProcess ) {
                CsrNewThread();
                }
            }
        ExitThread((lpStartAddress)(lpParameter));
        }
    except(UnhandledExceptionFilter( GetExceptionInformation() )) {
        if ( !BaseRunningInServerProcess ) {
            ExitProcess(GetExceptionCode());
            }
        else {
            ExitThread(GetExceptionCode());
            }
        }
}

VOID
BaseProcessStart(
    PPROCESS_START_ROUTINE lpStartAddress
    )

/*++

Routine Description:

    This function is called to start a Win32 process.  Its purpose is to
    call the initial thread of the process, and if the thread returns,
    to terminate the thread and delete its stack.

Arguments:

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns.

Return Value:

    None.

--*/

{
    try {

        NtSetInformationThread( NtCurrentThread(),
                                ThreadQuerySetWin32StartAddress,
                                &lpStartAddress,
                                sizeof( lpStartAddress )
                              );
        ExitThread((lpStartAddress)());
        }
    except(UnhandledExceptionFilter( GetExceptionInformation() )) {
        if ( !BaseRunningInServerProcess ) {
            ExitProcess(GetExceptionCode());
            }
        else {
            ExitThread(GetExceptionCode());
            }
        }
}

VOID
BaseFreeStackAndTerminate(
    IN PVOID OldStack,
    IN DWORD ExitCode
    )

/*++

Routine Description:

    This API is called during thread termination to delete a thread's
    stack and then terminate.

Arguments:

    OldStack - Supplies the address of the stack to free.

    ExitCode - Supplies the termination status that the thread
        is to exit with.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    SIZE_T Zero;
    PVOID BaseAddress;

#if defined (WX86)
    PWX86TIB Wx86Tib;
    PTEB Teb;
#endif

    Zero = 0;
    BaseAddress = OldStack;

    Status = NtFreeVirtualMemory(
                NtCurrentProcess(),
                &BaseAddress,
                &Zero,
                MEM_RELEASE
                );
    ASSERT(NT_SUCCESS(Status));

#if defined (WX86)
    Teb = NtCurrentTeb();
    if (Teb && (Wx86Tib = Wx86CurrentTib())) {
        BaseAddress = Wx86Tib->DeallocationStack;
        Zero = 0;
        Status = NtFreeVirtualMemory(
                    NtCurrentProcess(),
                    &BaseAddress,
                    &Zero,
                    MEM_RELEASE
                    );
        ASSERT(NT_SUCCESS(Status));

        if (Teb->Wx86Thread.DeallocationCpu) {
            BaseAddress = Teb->Wx86Thread.DeallocationCpu;
            Zero = 0;
            Status = NtFreeVirtualMemory(
                        NtCurrentProcess(),
                        &BaseAddress,
                        &Zero,
                        MEM_RELEASE
                        );
            ASSERT(NT_SUCCESS(Status));
            }

        }
#endif

    //
    // Don't worry, no commenting precedent has been set by SteveWo.  this
    // comment was added by an innocent bystander.
    //
    // NtTerminateThread will return if this thread is the last one in
    // the process.  So ExitProcess will only be called if that is the
    // case.
    //

    NtTerminateThread(NULL,(NTSTATUS)ExitCode);
    ExitProcess(ExitCode);
}



#if defined(WX86) || defined(_AXP64_)

NTSTATUS
BaseCreateWx86Tib(
    HANDLE Process,
    HANDLE Thread,
    ULONG InitialPc,
    ULONG CommittedStackSize,
    ULONG MaximumStackSize,
    BOOLEAN EmulateInitialPc
    )

/*++

Routine Description:

    This API is called to create a Wx86Tib for Wx86 emulated threads

Arguments:


    Process  - Target Process

    Thread   - Target Thread


    Parameter - Supplies the thread's parameter.

    InitialPc - Supplies an initial program counter value.

    StackSize - BaseCreateStack parameters

    MaximumStackSize - BaseCreateStack parameters

    BOOLEAN

Return Value:

    NtStatus from mem allocations

--*/

{
    NTSTATUS Status;
    PTEB Teb;
    ULONG Size, SizeWx86Tib;
    PVOID   TargetWx86Tib;
    PIMAGE_NT_HEADERS NtHeaders;
    WX86TIB Wx86Tib;
    INITIAL_TEB InitialTeb;
    THREAD_BASIC_INFORMATION ThreadInfo;


    Status = NtQueryInformationThread(
                Thread,
                ThreadBasicInformation,
                &ThreadInfo,
                sizeof( ThreadInfo ),
                NULL
                );
    if (!NT_SUCCESS(Status)) {
        return Status;
        }

    Teb = ThreadInfo.TebBaseAddress;


    //
    // if stack size not supplied, get from current image
    //
    NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);
    if (!NtHeaders) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }
    if (!MaximumStackSize) {
        MaximumStackSize = (ULONG)NtHeaders->OptionalHeader.SizeOfStackReserve;
    }
    if (!CommittedStackSize) {
        CommittedStackSize = (ULONG)NtHeaders->OptionalHeader.SizeOfStackCommit;
    }



    //
    // Increase stack size for Wx86Tib, which sits at the top of the stack.
    //

    //
    // x86 Borland C++ 4.1 (and perhaps other versions) Rudely assumes that
    // it can use the top of the stack. Even tho this is completly bogus,
    // leave some space on the top of the stack, to avoid problems.
    //
    SizeWx86Tib = sizeof(WX86TIB) + 16;

    SizeWx86Tib = ROUND_UP(SizeWx86Tib, sizeof(ULONG));
    Size = (ULONG)ROUND_UP_TO_PAGES(SizeWx86Tib + 4096);
    if (CommittedStackSize < 1024 * 1024) {  // 1 MB
        CommittedStackSize += Size;
        }
    if (MaximumStackSize < 1024 * 1024 * 16) {  // 10 MB
        MaximumStackSize += Size;
        }

    if (MaximumStackSize < 256 * 1024) {
        // Enforce a minimum stack size of 256k since the CPU emulator
        // grabs several pages of the x86 stack for itself
        MaximumStackSize = 256 * 1024;
    }

    Status = BaseCreateStack( Process,
                              CommittedStackSize,
                              MaximumStackSize,
                              &InitialTeb
                              );

    if (!NT_SUCCESS(Status)) {
        return Status;
        }


    //
    //  Fill in the Teb->Vdm with pWx86Tib
    //
    TargetWx86Tib = (PVOID)((ULONG_PTR)InitialTeb.StackBase - SizeWx86Tib);
    Status = NtWriteVirtualMemory(Process,
                                  &Teb->Vdm,
                                  &TargetWx86Tib,
                                  sizeof(TargetWx86Tib),
                                  NULL
                                  );


    if (NT_SUCCESS(Status)) {

        //
        // Write the initial Wx86Tib information
        //
        RtlZeroMemory(&Wx86Tib, sizeof(WX86TIB));
        Wx86Tib.Size = sizeof(WX86TIB);
        Wx86Tib.InitialPc = InitialPc;
        Wx86Tib.InitialSp = (ULONG)((ULONG_PTR)TargetWx86Tib);
        Wx86Tib.StackBase = (VOID * POINTER_32) InitialTeb.StackBase;
        Wx86Tib.StackLimit = (VOID * POINTER_32) InitialTeb.StackLimit;
        Wx86Tib.DeallocationStack = (VOID * POINTER_32) InitialTeb.StackAllocationBase;
        Wx86Tib.EmulateInitialPc = EmulateInitialPc;

        Status = NtWriteVirtualMemory(Process,
                                      TargetWx86Tib,
                                      &Wx86Tib,
                                      sizeof(WX86TIB),
                                      NULL
                                      );
        }


    if (!NT_SUCCESS(Status)) {
        BaseFreeThreadStack(Process, NULL, &InitialTeb);
        }


    return Status;
}


#endif


VOID
BaseFreeThreadStack(
     HANDLE hProcess,
     HANDLE hThread,
     PINITIAL_TEB InitialTeb
     )

/*++

Routine Description:

    Deletes a thread's stack

Arguments:

    Process - Target process

    Thread - Target thread OPTIONAL

    InitialTeb - stack paremeters


Return Value:

    VOID


--*/


{
   NTSTATUS Status;
   DWORD dwStackSize;
   SIZE_T stStackSize;
   PVOID BaseAddress;

   stStackSize = 0;
   dwStackSize = 0;
   BaseAddress = InitialTeb->StackAllocationBase;
   NtFreeVirtualMemory( hProcess,
                        &BaseAddress,
                        &stStackSize,
                        MEM_RELEASE
                        );

#if defined (WX86)

    if (hThread) {
        PTEB Teb;
        PWX86TIB pWx86Tib;
        WX86TIB Wx86Tib;
        THREAD_BASIC_INFORMATION ThreadInfo;

        Status = NtQueryInformationThread(
                    hThread,
                    ThreadBasicInformation,
                    &ThreadInfo,
                    sizeof( ThreadInfo ),
                    NULL
                    );

        Teb = ThreadInfo.TebBaseAddress;
        if (!NT_SUCCESS(Status) || !Teb) {
            return;
            }

        Status = NtReadVirtualMemory(
                    hProcess,
                    &Teb->Vdm,
                    &pWx86Tib,
                    sizeof(pWx86Tib),
                    NULL
                    );
        if (!NT_SUCCESS(Status) || !pWx86Tib) {
            return;
        }

        Status = NtReadVirtualMemory(
                    hProcess,
                    pWx86Tib,
                    &Wx86Tib,
                    sizeof(Wx86Tib),
                    NULL
                    );

        if (NT_SUCCESS(Status) && Wx86Tib.Size == sizeof(WX86TIB)) {

            // release the wx86tib stack
            dwStackSize = 0;
            stStackSize = 0;
            BaseAddress = Wx86Tib.DeallocationStack;
            NtFreeVirtualMemory(hProcess,
                                &BaseAddress,
                                &stStackSize,
                                MEM_RELEASE
                                );

            // set Teb->Vdm = NULL;
            dwStackSize = 0;
            Status = NtWriteVirtualMemory(
                        hProcess,
                        &Teb->Vdm,
                        &dwStackSize,
                        sizeof(pWx86Tib),
                        NULL
                        );
            }
        }
#endif

}

#if defined(BUILD_WOW6432)

typedef struct _ENVIRONMENT_THUNK_TABLE
{
    WCHAR *Native;

    WCHAR *X86;

    WCHAR *FakeName;

} ENVIRONMENT_THUNK_TABLE, *PENVIRONMENT_THUNK_TABLE;

ENVIRONMENT_THUNK_TABLE ProgramFilesEnvironment[] = 
{
    { 
        L"ProgramFiles", 
        L"ProgramFiles(x86)", 
        L"ProgramW6432" 
    },
    { 
        L"CommonProgramFiles", 
        L"CommonProgramFiles(x86)", 
        L"CommonProgramW6432" 
    },
    {
        L"PROCESSOR_ARCHITECTURE",
        L"PROCESSOR_ARCHITECTURE",
        L"PROCESSOR_ARCHITEW6432"
    }
};


NTSTATUS
Wow64pThunkEnvironmentVariables (
    IN OUT PVOID *Environment
    )

/*++

Routine Description:

    This routine is called when we are about to create a 64-bit process for
    a 32-bit process. It thunks back the ProgramFiles environment
    variables so that they point to the native directory.
    
    This routine must stay in sync with what's in \base\wow64\wow64\init.c.

Arguments:

    Environment - Address of pointer of environment variable to thunk.


Return Value:

    NTSTATUS.
--*/

{
    UNICODE_STRING Name, Value;
    WCHAR Buffer [ MAX_PATH ];
    NTSTATUS NtStatus;
    ULONG i=0;
    
    while (i < (sizeof(ProgramFilesEnvironment) / sizeof(ProgramFilesEnvironment[0]))) {

        RtlInitUnicodeString (&Name, ProgramFilesEnvironment[i].FakeName);

        Value.Length = 0;
        Value.MaximumLength = sizeof (Buffer);
        Value.Buffer = Buffer;
        
        NtStatus = RtlQueryEnvironmentVariable_U (*Environment,
                                                  &Name,
                                                  &Value                                                  
                                                  );

        if (NT_SUCCESS (NtStatus)) {

            RtlSetEnvironmentVariable (Environment,
                                       &Name,
                                       NULL
                                       );

            RtlInitUnicodeString (&Name, ProgramFilesEnvironment[i].Native);
            
            NtStatus = RtlSetEnvironmentVariable (Environment,
                                                  &Name,
                                                  &Value
                                                  );
        }
        
        if (!NT_SUCCESS (NtStatus)) {
            break;
        }
        i++;
    }

    return NtStatus;
}
#endif


BOOL
BasePushProcessParameters(
    DWORD dwFlags,
    HANDLE Process,
    PPEB Peb,
    LPCWSTR ApplicationPathName,
    LPCWSTR CurrentDirectory,
    LPCWSTR CommandLine,
    LPVOID Environment,
    LPSTARTUPINFOW lpStartupInfo,
    DWORD dwCreationFlags,
    BOOL bInheritHandles,
    DWORD dwSubsystem,
    PVOID pAppCompatData,
    DWORD cbAppCompatData
    )

/*++

Routine Description:

    This function allocates a process parameters record and
    formats it. The parameter record is then written into the
    address space of the specified process.

Arguments:

    dwFlags - bitmask of flags to affect the behavior of
        BasePushProcessParameters.

        BASE_PUSH_PROCESS_PARAMETERS_FLAG_APP_MANIFEST_PRESENT
            Set to indicate that an application manifest was found/used
            for the given executable.

    Process - Supplies a handle to the process that is to get the
        parameters.

    Peb - Supplies the address of the new processes PEB.

    ApplicationPathName - Supplies the application path name for the
        process.

    CurrentDirectory - Supplies an optional current directory for the
        process.  If not specified, then the current directory is used.

    CommandLine - Supplies a command line for the new process.

    Environment - Supplies an optional environment variable list for the
        process. If not specified, then the current processes arguments
        are passed.

    lpStartupInfo - Supplies the startup information for the processes
        main window.

    dwCreationFlags - Supplies creation flags for the process

    bInheritHandles - TRUE if child process inherited handles from parent

    dwSubsystem - if non-zero, then value will be stored in child process
        PEB.  Only non-zero for separate VDM applications, where the child
        process has NTVDM.EXE subsystem type, not the 16-bit application
        type, which is what we want.

    pAppCompatData   - data that is needed for appcompat backend
    cbAppCompatData  - data size in bytes

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation Failed.

--*/


{
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLineString;
    UNICODE_STRING CurrentDirString;
    UNICODE_STRING DllPath;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeInfo;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PRTL_USER_PROCESS_PARAMETERS ParametersInNewProcess;
    ULONG ParameterLength, EnvironmentLength;
    SIZE_T RegionSize;
    PWCHAR s;
    NTSTATUS Status;
    WCHAR FullPathBuffer[MAX_PATH+5];
    WCHAR *fp;
    DWORD Rvalue;
    LPWSTR DllPathData;
    LPVOID pAppCompatDataInNewProcess;
#if defined(BUILD_WOW6432)
    ULONG_PTR Peb32;
    PVOID TempEnvironment = NULL;
#endif

    
    Rvalue = GetFullPathNameW(ApplicationPathName,MAX_PATH+4,FullPathBuffer,&fp);
    if ( Rvalue == 0 || Rvalue > MAX_PATH+4 ) {
        DllPathData = BaseComputeProcessDllPath( ApplicationPathName, Environment);
        if ( !DllPathData ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
            }
        RtlInitUnicodeString( &DllPath, DllPathData );
        RtlInitUnicodeString( &ImagePathName, ApplicationPathName );
        }
    else {
        DllPathData = BaseComputeProcessDllPath( FullPathBuffer, Environment);
        if ( !DllPathData ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
            }
        RtlInitUnicodeString( &DllPath, DllPathData );
        RtlInitUnicodeString( &ImagePathName, FullPathBuffer );
        }

    RtlInitUnicodeString( &CommandLineString, CommandLine );

    RtlInitUnicodeString( &CurrentDirString, CurrentDirectory );

    if ( lpStartupInfo->lpDesktop ) {
        RtlInitUnicodeString( &DesktopInfo, lpStartupInfo->lpDesktop );
        }
    else {
        RtlInitUnicodeString( &DesktopInfo, L"");
        }

    if ( lpStartupInfo->lpReserved ) {
        RtlInitUnicodeString( &ShellInfo, lpStartupInfo->lpReserved );
        }
    else {
        RtlInitUnicodeString( &ShellInfo, L"");
        }

    RuntimeInfo.Buffer = (PWSTR)lpStartupInfo->lpReserved2;
    RuntimeInfo.Length = lpStartupInfo->cbReserved2;
    RuntimeInfo.MaximumLength = RuntimeInfo.Length;

    if (NULL == pAppCompatData) {
        cbAppCompatData = 0;
    } 

    if ( lpStartupInfo->lpTitle ) {
        RtlInitUnicodeString( &WindowTitle, lpStartupInfo->lpTitle );
        }
    else {
        RtlInitUnicodeString( &WindowTitle, ApplicationPathName );
        }

    Status = RtlCreateProcessParameters( &ProcessParameters,
                                         &ImagePathName,
                                         &DllPath,
                                         (ARGUMENT_PRESENT(CurrentDirectory) ? &CurrentDirString : NULL),
                                         &CommandLineString,
                                         Environment,
                                         &WindowTitle,
                                         &DesktopInfo,
                                         &ShellInfo,
                                         &RuntimeInfo
                                       );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    if ( !bInheritHandles ) {
        ProcessParameters->CurrentDirectory.Handle = NULL;
        }
    try {
        if (s = ProcessParameters->Environment) {
            while (*s) {
                while (*s++) {
                    }
                }
            s++;
            Environment = ProcessParameters->Environment;
            EnvironmentLength = (ULONG)((PUCHAR)s - (PUCHAR)Environment);

            ProcessParameters->Environment = NULL;
            RegionSize = EnvironmentLength;
            Status = NtAllocateVirtualMemory( Process,
                                              (PVOID *)&ProcessParameters->Environment,
                                              0,
                                              &RegionSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                return( FALSE );
                }

#if defined(BUILD_WOW6432)

            //
            // Let's try and thunk back some environment variables if we are about to
            // launch a 64-bit process
            //

            Status = NtQueryInformationProcess (Process,
                                                ProcessWow64Information,
                                                &Peb32,
                                                sizeof (Peb32),
                                                NULL
                                                );
            
            if (NT_SUCCESS (Status) && (Peb32 == 0)) {

                RegionSize = EnvironmentLength;
                
                Status = NtAllocateVirtualMemory (NtCurrentProcess(),
                                                  &TempEnvironment,
                                                  0,
                                                  &RegionSize,
                                                  MEM_COMMIT,
                                                  PAGE_READWRITE
                                                  );

                if (NT_SUCCESS (Status)) {
                    
                    try {
                        
                        RtlCopyMemory (TempEnvironment, 
                                       Environment,
                                       EnvironmentLength
                                       );
                    } except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = GetExceptionCode ();
                    }

                    if (NT_SUCCESS (Status)) {
                        
                        //
                        // Thunk back special environment variables so that they won't be inherited 
                        // for 64-bit processes
                        //

                        Status = Wow64pThunkEnvironmentVariables (&TempEnvironment);

                        if (NT_SUCCESS (Status)) {
                            Environment = TempEnvironment;
                        }
                    }
                }
            }
#endif

            Status = NtWriteVirtualMemory( Process,
                                           ProcessParameters->Environment,
                                           Environment,
                                           EnvironmentLength,
                                           NULL
                                         );

#if defined(BUILD_WOW6432)            
            
            if (TempEnvironment != NULL) {
                
                RegionSize = 0;
                NtFreeVirtualMemory(Process,
                                    &TempEnvironment,
                                    &RegionSize,
                                    MEM_RELEASE
                                    );
            }
#endif

            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                return( FALSE );
                }
            }

        //
        // Push the parameters into the new process
        //

        ProcessParameters->StartingX       = lpStartupInfo->dwX;
        ProcessParameters->StartingY       = lpStartupInfo->dwY;
        ProcessParameters->CountX          = lpStartupInfo->dwXSize;
        ProcessParameters->CountY          = lpStartupInfo->dwYSize;
        ProcessParameters->CountCharsX     = lpStartupInfo->dwXCountChars;
        ProcessParameters->CountCharsY     = lpStartupInfo->dwYCountChars;
        ProcessParameters->FillAttribute   = lpStartupInfo->dwFillAttribute;
        ProcessParameters->WindowFlags     = lpStartupInfo->dwFlags;
        ProcessParameters->ShowWindowFlags = lpStartupInfo->wShowWindow;

        if (lpStartupInfo->dwFlags & (STARTF_USESTDHANDLES | STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {
            ProcessParameters->StandardInput = lpStartupInfo->hStdInput;
            ProcessParameters->StandardOutput = lpStartupInfo->hStdOutput;
            ProcessParameters->StandardError = lpStartupInfo->hStdError;
        }

        if (dwCreationFlags & DETACHED_PROCESS) {
            ProcessParameters->ConsoleHandle = (HANDLE)CONSOLE_DETACHED_PROCESS;
        } else if (dwCreationFlags & CREATE_NEW_CONSOLE) {
            ProcessParameters->ConsoleHandle = (HANDLE)CONSOLE_NEW_CONSOLE;
        } else if (dwCreationFlags & CREATE_NO_WINDOW) {
            ProcessParameters->ConsoleHandle = (HANDLE)CONSOLE_CREATE_NO_WINDOW;
        } else {
            ProcessParameters->ConsoleHandle =
                NtCurrentPeb()->ProcessParameters->ConsoleHandle;
            if (!(lpStartupInfo->dwFlags & (STARTF_USESTDHANDLES | STARTF_USEHOTKEY | STARTF_HASSHELLDATA))) {
                if (bInheritHandles ||
                    CONSOLE_HANDLE( NtCurrentPeb()->ProcessParameters->StandardInput )
                   ) {
                    ProcessParameters->StandardInput =
                        NtCurrentPeb()->ProcessParameters->StandardInput;
                }
                if (bInheritHandles ||
                    CONSOLE_HANDLE( NtCurrentPeb()->ProcessParameters->StandardOutput )
                   ) {
                    ProcessParameters->StandardOutput =
                        NtCurrentPeb()->ProcessParameters->StandardOutput;
                }
                if (bInheritHandles ||
                    CONSOLE_HANDLE( NtCurrentPeb()->ProcessParameters->StandardError )
                   ) {
                    ProcessParameters->StandardError =
                        NtCurrentPeb()->ProcessParameters->StandardError;
                }
            }
        }

        if (dwCreationFlags & CREATE_NEW_PROCESS_GROUP) {
            ProcessParameters->ConsoleFlags = 1;
            }

        ProcessParameters->Flags |=
            (NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_DISABLE_HEAP_DECOMMIT);
        ParameterLength = ProcessParameters->Length;

        if (dwFlags & BASE_PUSH_PROCESS_PARAMETERS_FLAG_APP_MANIFEST_PRESENT)
            ProcessParameters->Flags |= RTL_USER_PROC_APP_MANIFEST_PRESENT;

        //
        // Allocate memory in the new process to push the parameters
        //

        ParametersInNewProcess = NULL;
        RegionSize = ParameterLength;
        Status = NtAllocateVirtualMemory(
                    Process,
                    (PVOID *)&ParametersInNewProcess,
                    0,
                    &RegionSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );
        ParameterLength = (ULONG)RegionSize;
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        ProcessParameters->MaximumLength = ParameterLength;

        if ( dwCreationFlags & PROFILE_USER ) {
            ProcessParameters->Flags |= RTL_USER_PROC_PROFILE_USER;
            }

        if ( dwCreationFlags & PROFILE_KERNEL ) {
            ProcessParameters->Flags |= RTL_USER_PROC_PROFILE_KERNEL;
            }

        if ( dwCreationFlags & PROFILE_SERVER ) {
            ProcessParameters->Flags |= RTL_USER_PROC_PROFILE_SERVER;
            }

        //
        // Push the parameters
        //

        Status = NtWriteVirtualMemory(
                    Process,
                    ParametersInNewProcess,
                    ProcessParameters,
                    ProcessParameters->Length,
                    NULL
                    );
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }

        //
        // Make the processes PEB point to the parameters.
        //

        Status = NtWriteVirtualMemory(
                    Process,
                    &Peb->ProcessParameters,
                    &ParametersInNewProcess,
                    sizeof( ParametersInNewProcess ),
                    NULL
                    );
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }

        
        // 
        // allocate and write appcompat data for the new process
        //
        
        pAppCompatDataInNewProcess = NULL;
        if ( NULL != pAppCompatData ) {
            RegionSize = cbAppCompatData;
            Status = NtAllocateVirtualMemory(
                        Process,
                        (PVOID*)&pAppCompatDataInNewProcess,
                        0,
                        &RegionSize,
                        MEM_COMMIT,
                        PAGE_READWRITE
                        );
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }

            //
            // write the data itself
            //
            Status = NtWriteVirtualMemory(
                        Process,
                        pAppCompatDataInNewProcess,
                        pAppCompatData,
                        cbAppCompatData,
                        NULL
                        );
                        
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }

        // 
        // save the pointer to appcompat data in peb 
        //
        Status = NtWriteVirtualMemory(
                    Process,
                    &Peb->pShimData,
                    &pAppCompatDataInNewProcess,
                    sizeof( pAppCompatDataInNewProcess ),
                    NULL
                    );
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
                    


        //
        // Set subsystem type in PEB if requested by caller.  Ignore error
        //

        if (dwSubsystem != 0) {
            NtWriteVirtualMemory(
               Process,
               &Peb->ImageSubsystem,
               &dwSubsystem,
               sizeof( Peb->ImageSubsystem ),
               NULL
               );
            }
        }
    finally {
        RtlFreeHeap(RtlProcessHeap(), 0,DllPath.Buffer);
        if ( ProcessParameters ) {
            RtlDestroyProcessParameters(ProcessParameters);
            }
        }

    return TRUE;
}

LPCWSTR
BasepEndOfDirName(
    IN LPCWSTR FileName
    )
{
    LPCWSTR FileNameEnd,
            FileNameFirstWhack = wcschr(FileName, L'\\');

    if (FileNameFirstWhack) {

        FileNameEnd = wcsrchr(FileNameFirstWhack, L'\\');
        ASSERT(FileNameEnd);

        if (FileNameEnd == FileNameFirstWhack)
            FileNameEnd++;

    } else {
        FileNameEnd = NULL;
    }

    return FileNameEnd;
}

VOID
BasepLocateExeLdrEntry(
    IN PCLDR_DATA_TABLE_ENTRY Entry,
    IN PVOID Context,
    IN OUT BOOLEAN *StopEnumeration
    )

/*++

Routine Description:

    This function is a LDR_LOADED_MODULE_ENUMBERATION_CALLBACK_FUNCTION
    which locates the exe's loader data table entry.

Arguments:

    Entry - the entry currently being enumerated.

    Context - the image base address (NtCurrentPeb()->ImageBaseAddress).

    StopEnumeration - used to stop the enumeration.

Return Value:

    None.  The exe's loader data table entry, if found, is stored in
    the global BasepExeLdrEntry.

--*/

{
    ASSERT(Entry);
    ASSERT(Context);
    ASSERT(StopEnumeration);

    if (BasepExeLdrEntry) {

        *StopEnumeration = TRUE;

    } else if (Entry->DllBase == Context) {

        BasepExeLdrEntry = Entry;
        *StopEnumeration = TRUE;

    }
}


LPWSTR
BasepComputeProcessPath(
    IN const BASEP_SEARCH_PATH_ELEMENT *Elements,
    IN LPCWSTR AppName,
    IN LPVOID  Environment
    )

/*++

Routine Description:

    This function computes a process path.

Arguments:

    Elements - The elements to build into a path.

    AppName - An optional argument that specifies the name of
              the application.  If this parameter is not specified,
              then the current application is used.

    Environment - Supplies the environment block to be used to calculate
        the path variable value.

Return Value:

    The return value is the value of the requested path.

--*/

{
    LPCWSTR        AppNameEnd;
    const BASEP_SEARCH_PATH_ELEMENT *Element;
    UNICODE_STRING EnvPath;
    LPWSTR         EnvPathBuffer = NULL;
    LPWSTR         PathBuffer = NULL,
                   PathCurrent;
    ULONG          PathLengthInBytes;
    NTSTATUS       Status = STATUS_SUCCESS;

    __try {

        // First, figure out how much space we'll need.
        PathLengthInBytes = 0;
        for (Element = Elements;
             *Element != BasepSearchPathEnd;
             Element++) {

            switch (*Element) {

            case BasepSearchPathCurdir:
                PathLengthInBytes += 2 * sizeof(UNICODE_NULL); // .;
                break;

            case BasepSearchPathDlldir:

                ASSERT(BaseDllDirectory.Buffer != NULL);

                PathLengthInBytes += BaseDllDirectory.Length;
                if (BaseDllDirectory.Length) {
                    PathLengthInBytes += sizeof(UNICODE_NULL);
                }

                break;

            case BasepSearchPathAppdir:

                if (AppName) {
                    // Try to use the passed-in appname
                    AppNameEnd = BasepEndOfDirName(AppName);
                }

                if (!AppName || !AppNameEnd) {

                    // We didn't have or were unable to use the passed-in
                    // appname -- so attempt to use the current exe's name

                    if (RtlGetPerThreadCurdir()
                        && RtlGetPerThreadCurdir()->ImageName) {

                        AppName = RtlGetPerThreadCurdir()->ImageName->Buffer;

                    } else {

                        BasepCheckExeLdrEntry();

                        if (BasepExeLdrEntry) {
                            AppName = BasepExeLdrEntry->FullDllName.Buffer;
                        }
                    }

                    if (AppName) {
                        AppNameEnd = BasepEndOfDirName(AppName);
                    }
                }

                if (AppName && AppNameEnd) {

                    // Either we had a passed-in appname which worked, or
                    // we found the current exe's name and that worked.
                    //
                    // AppNameEnd points to the end of the base of the exe
                    // name -- so the difference is the number of
                    // characters in the base name, and we add one for the
                    // trailing semicolon / NULL.

                    PathLengthInBytes += ((AppNameEnd - AppName + 1)
                                          * sizeof(UNICODE_NULL));
                }

                break;

            case BasepSearchPathDefaultDirs:
                ASSERT(! (BaseDefaultPath.Length & 1));

                // We don't need an extra UNICODE_NULL here -- baseinit.c
                // appends our trailing semicolon for us.

                PathLengthInBytes += BaseDefaultPath.Length;
                break;

            case BasepSearchPathEnvPath:

                if (! Environment) {
                    RtlAcquirePebLock();
                }

                __try {
                    EnvPath.MaximumLength = 0;
                
                    Status = RtlQueryEnvironmentVariable_U(Environment,
                                                           &BasePathVariableName,
                                                           &EnvPath);

                    if (Status == STATUS_BUFFER_TOO_SMALL) {

                        // Now that we know how much to allocate, attempt
                        // to alloc a buffer that's actually big enough.

                        EnvPath.MaximumLength = EnvPath.Length + sizeof(UNICODE_NULL);

                        EnvPathBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                                        MAKE_TAG(TMP_TAG),
                                                        EnvPath.MaximumLength);
                        if (! EnvPathBuffer) {
                            Status = STATUS_NO_MEMORY;
                            __leave;
                        }

                        EnvPath.Buffer = EnvPathBuffer;

                        Status = RtlQueryEnvironmentVariable_U(Environment,
                                                               &BasePathVariableName,
                                                               &EnvPath);
                    }
                } __finally {
                    if (! Environment) {
                        RtlReleasePebLock();
                    }
                }

                if (Status == STATUS_VARIABLE_NOT_FOUND) {
                    EnvPath.Length = 0;
                    Status = STATUS_SUCCESS;
                } else if (! NT_SUCCESS(Status)) {
                    __leave;
                } else {
                    // The final tally is the length, in bytes, of whatever
                    // we're using for our path, plus a character for the
                    // trailing whack or NULL.
                    ASSERT(! (EnvPath.Length & 1));
                    PathLengthInBytes += EnvPath.Length + sizeof(UNICODE_NULL);
                }
                
                break;

            DEFAULT_UNREACHABLE;

            } // switch (*Element)
        } // foreach Element (Elements) -- size loop

        ASSERT(PathLengthInBytes > 0);
        ASSERT(! (PathLengthInBytes & 1));

        // Now we have the length, in bytes, of the buffer we'll need for
        // our path.  Time to allocate it...

        PathBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                     MAKE_TAG(TMP_TAG),
                                     PathLengthInBytes);

        if (! PathBuffer) {
            Status = STATUS_NO_MEMORY;
            __leave;
        }

        // Now go through the loop again, this time appending onto the
        // PathBuffer.

        PathCurrent = PathBuffer;
    
        for (Element = Elements;
             *Element != BasepSearchPathEnd;
             Element++) {

            switch (*Element) {
            case BasepSearchPathCurdir:
                ASSERT(((PathCurrent - PathBuffer + 2)
                        * sizeof(UNICODE_NULL))
                       <= PathLengthInBytes);
                *PathCurrent++ = L'.';
                *PathCurrent++ = L';';
                break;

            case BasepSearchPathDlldir:
                if (BaseDllDirectory.Length) {
                    ASSERT((((PathCurrent - PathBuffer + 1)
                             * sizeof(UNICODE_NULL))
                            + BaseDllDirectory.Length)
                           <= PathLengthInBytes);
                    RtlCopyMemory(PathCurrent,
                                  BaseDllDirectory.Buffer,
                                  BaseDllDirectory.Length);

                    PathCurrent += (BaseDllDirectory.Length >> 1);
                    *PathCurrent++ = L';';
                }

                break;

            case BasepSearchPathAppdir:
                if (AppName && AppNameEnd) {
                    ASSERT(((PathCurrent - PathBuffer + 1
                             + (AppNameEnd - AppName))
                            * sizeof(UNICODE_NULL))
                           <= PathLengthInBytes);
                    RtlCopyMemory(PathCurrent,
                                  AppName,
                                  ((AppNameEnd - AppName)
                                   * sizeof(UNICODE_NULL)));
                    PathCurrent += AppNameEnd - AppName;
                    *PathCurrent++ = L';';
                }

                break;

            case BasepSearchPathDefaultDirs:
                ASSERT((((PathCurrent - PathBuffer)
                         * sizeof(UNICODE_NULL))
                        + BaseDefaultPath.Length)
                       <= PathLengthInBytes);
                RtlCopyMemory(PathCurrent,
                              BaseDefaultPath.Buffer,
                              BaseDefaultPath.Length);
                PathCurrent += (BaseDefaultPath.Length >> 1);

                // We don't need to add a semicolon here -- baseinit.c
                // appends our trailing semicolon for us.

                break;

            case BasepSearchPathEnvPath:
                if (EnvPath.Length) {
                    ASSERT((((PathCurrent - PathBuffer + 1)
                             * sizeof(UNICODE_NULL))
                            + EnvPath.Length)
                           <= PathLengthInBytes);
                    RtlCopyMemory(PathCurrent,
                                  EnvPath.Buffer,
                                  EnvPath.Length);
                    PathCurrent += (EnvPath.Length >> 1);
                    *PathCurrent++ = L';';
                }
                break;

            DEFAULT_UNREACHABLE;
            
            } // switch (*Element)
        } // foreach Element (Elements) -- append loop

        // At this point, PathCurrent points just beyond PathBuffer.
        // Let's assert that...
        ASSERT((PathCurrent - PathBuffer) * sizeof(UNICODE_NULL)
               == PathLengthInBytes);

        // ... and turn the final ';' into the string terminator.
        ASSERT(PathCurrent > PathBuffer);
        PathCurrent[-1] = UNICODE_NULL;

    } __finally {
        if (EnvPathBuffer) {
            RtlFreeHeap(RtlProcessHeap(),
                        0,
                        EnvPathBuffer);
        }

        if (PathBuffer
            && (AbnormalTermination()
                || ! NT_SUCCESS(Status))) {
            RtlFreeHeap(RtlProcessHeap(),
                        0,
                        PathBuffer);
            PathBuffer = NULL;
        }
    }

    return PathBuffer;
}

LPWSTR
BaseComputeProcessDllPath(
    IN LPCWSTR AppName,
    IN LPVOID  Environment
    )

/*++

Routine Description:

    This function computes a process DLL path.

Arguments:

    AppName - An optional argument that specifies the name of
        the application. If this parameter is not specified, then the
        current application is used.

    Environment - Supplies the environment block to be used to calculate
        the path variable value.

Return Value:

    The return value is the value of the processes DLL path.

--*/

{
    NTSTATUS          Status;
    HANDLE            Key;
    static UNICODE_STRING
        KeyName = RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager"),
        ValueName = RTL_CONSTANT_STRING(L"SafeDllSearchMode");

    static OBJECT_ATTRIBUTES
        ObjA = RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyName, OBJ_CASE_INSENSITIVE);

    CHAR              Buffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)
                            + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION Info;
    ULONG             ResultLength;
    LONG              CurrentDirPlacement,
                      PrevCurrentDirPlacement;
    LPWSTR            Result;

    static const BASEP_SEARCH_PATH_ELEMENT DllDirSearchPath[] = {
        BasepSearchPathAppdir,
        BasepSearchPathDlldir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    };

    RtlEnterCriticalSection(&BaseDllDirectoryLock);
    if (BaseDllDirectory.Buffer) {
        Result = BasepComputeProcessPath(DllDirSearchPath,
                                         AppName,
                                         Environment);
        RtlLeaveCriticalSection(&BaseDllDirectoryLock);
        return Result;
    }
    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    CurrentDirPlacement = BasepDllCurrentDirPlacement;

    if (CurrentDirPlacement == BasepCurrentDirUninitialized) {

        Status = NtOpenKey(&Key,
                           KEY_QUERY_VALUE,
                           &ObjA);

        if (! NT_SUCCESS(Status)) {
            goto compute_path;
        }
    
        Info = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
        Status = NtQueryValueKey(Key,
                                 &ValueName,
                                 KeyValuePartialInformation,
                                 Info,
                                 sizeof(Buffer),
                                 &ResultLength);
        if (! NT_SUCCESS(Status)) {
            goto close_key;
        }

        if (ResultLength != sizeof(Buffer)) {
            goto close_key;
        }

        RtlCopyMemory(&CurrentDirPlacement,
                      Info->Data,
                      sizeof(DWORD));

  close_key:
        NtClose(Key);

  compute_path:
        if (! BASEP_VALID_CURDIR_PLACEMENT_P(CurrentDirPlacement)) {
            CurrentDirPlacement = BASEP_DEFAULT_DLL_CURDIR_PLACEMENT;
        }

        PrevCurrentDirPlacement = InterlockedCompareExchange(&BasepDllCurrentDirPlacement,
                                                             CurrentDirPlacement,
                                                             BasepCurrentDirUninitialized);
        
        if (PrevCurrentDirPlacement != BasepCurrentDirUninitialized) {
            CurrentDirPlacement = PrevCurrentDirPlacement;
        }
    }

    if (! BASEP_VALID_CURDIR_PLACEMENT_P(CurrentDirPlacement)) {
        CurrentDirPlacement = BASEP_DEFAULT_DLL_CURDIR_PLACEMENT;
    }

    return BasepComputeProcessPath(BasepDllSearchPaths[CurrentDirPlacement],
                                   AppName,
                                   Environment);
}

LPWSTR
BaseComputeProcessSearchPath(
    VOID
    )

/*++

Routine Description:

    This function computes a process search path.

Arguments:

    None

Return Value:

    The return value is the value of the processes search path.

--*/

{
    static const BASEP_SEARCH_PATH_ELEMENT SearchPath[] = {
        BasepSearchPathAppdir,
        BasepSearchPathCurdir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    };

    return BasepComputeProcessPath(SearchPath,
                                   NULL,
                                   NULL);
}




PUNICODE_STRING
Basep8BitStringToStaticUnicodeString(
    IN LPCSTR lpSourceString
    )

/*++

Routine Description:

    Captures and converts a 8-bit (OEM or ANSI) string into the Teb Static
    Unicode String

Arguments:

    lpSourceString - string in OEM or ANSI

Return Value:

    Pointer to the Teb static string if conversion was successful, NULL
    otherwise.  If a failure occurred, the last error is set.

--*/

{
    PUNICODE_STRING StaticUnicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    //
    //  Get pointer to static per-thread string
    //

    StaticUnicode = &NtCurrentTeb()->StaticUnicodeString;

    //
    //  Convert input string into unicode string
    //

    RtlInitAnsiString( &AnsiString, lpSourceString );
    Status = Basep8BitStringToUnicodeString( StaticUnicode, &AnsiString, FALSE );

    //
    //  If we couldn't convert the string
    //

    if ( !NT_SUCCESS( Status ) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError( ERROR_FILENAME_EXCED_RANGE );
        } else {
            BaseSetLastNTError( Status );
        }
        return NULL;
    } else {
        return StaticUnicode;
    }
}

BOOL
Basep8BitStringToDynamicUnicodeString(
    OUT PUNICODE_STRING UnicodeString,
    IN LPCSTR lpSourceString
    )
/*++

Routine Description:

    Captures and converts a 8-bit (OEM or ANSI) string into a heap-allocated
    UNICODE string

Arguments:

    UnicodeString - location where UNICODE_STRING is stored

    lpSourceString - string in OEM or ANSI

Return Value:

    TRUE if string is correctly stored, FALSE if an error occurred.  In the
    error case, the last error is correctly set.

--*/

{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    //
    //  Convert input into dynamic unicode string
    //

    RtlInitString( &AnsiString, lpSourceString );
    Status = Basep8BitStringToUnicodeString( UnicodeString, &AnsiString, TRUE );

    //
    //  If we couldn't do this, fail
    //

    if (!NT_SUCCESS( Status )){
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError( ERROR_FILENAME_EXCED_RANGE );
        } else {
            BaseSetLastNTError( Status );
        }
        return FALSE;
        }

    return TRUE;
}


//
//  Thunks for converting between ANSI/OEM and UNICODE
//

ULONG
BasepAnsiStringToUnicodeSize(
    PANSI_STRING AnsiString
    )
/*++

Routine Description:

    Determines the size of a UNICODE version of an ANSI string

Arguments:

    AnsiString - string to examine

Return Value:

    Byte size of UNICODE version of string including a trailing L'\0'.

--*/
{
    return RtlAnsiStringToUnicodeSize( AnsiString );
}



ULONG
BasepOemStringToUnicodeSize(
    PANSI_STRING OemString
    )
/*++

Routine Description:

    Determines the size of a UNICODE version of an OEM string

Arguments:

    OemString - string to examine

Return Value:

    Byte size of UNICODE version of string including a trailing L'\0'.

--*/
{
    return RtlOemStringToUnicodeSize( OemString );
}



ULONG
BasepUnicodeStringToOemSize(
    PUNICODE_STRING UnicodeString
    )
/*++

Routine Description:

    Determines the size of an OEM version of a UNICODE string

Arguments:

    UnicodeString - string to examine

Return Value:

    Byte size of OEM version of string including a trailing '\0'.

--*/
{
    return RtlUnicodeStringToOemSize( UnicodeString );
}



ULONG
BasepUnicodeStringToAnsiSize(
    PUNICODE_STRING UnicodeString
    )
/*++

Routine Description:

    Determines the size of an ANSI version of a UNICODE string

Arguments:

    UnicodeString - string to examine

Return Value:

    Byte size of ANSI version of string including a trailing '\0'.

--*/
{
    return RtlUnicodeStringToAnsiSize( UnicodeString );
}



typedef struct _BASEP_ACQUIRE_STATE {
    HANDLE Token;
    PTOKEN_PRIVILEGES OldPrivileges;
    PTOKEN_PRIVILEGES NewPrivileges;
    ULONG Revert;
    ULONG Spare;
    BYTE OldPrivBuffer[ 1024 ];
} BASEP_ACQUIRE_STATE, *PBASEP_ACQUIRE_STATE;


//
// This function does the correct thing - it checks for the thread token
// before opening the process token.
//


NTSTATUS
BasepAcquirePrivilegeEx(
    ULONG Privilege,
    PVOID *ReturnedState
    )
{
    PBASEP_ACQUIRE_STATE State;
    ULONG cbNeeded;
    LUID LuidPrivilege;
    NTSTATUS Status, Status1;
    BOOL St;

    //
    // Make sure we have access to adjust and to get the old token privileges
    //

    *ReturnedState = NULL;
    State = RtlAllocateHeap (RtlProcessHeap(),
                             MAKE_TAG( TMP_TAG ),
                             sizeof(BASEP_ACQUIRE_STATE) +
                             sizeof(TOKEN_PRIVILEGES) +
                                (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (State == NULL) {
        return STATUS_NO_MEMORY;
    }

    State->Revert = 0;
    //
    // Try opening the thread token first, in case we're impersonating.
    //

    Status = NtOpenThreadToken (NtCurrentThread(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                FALSE,
                                &State->Token);

    if ( !NT_SUCCESS( Status )) {
        Status = RtlImpersonateSelf (SecurityDelegation);
        if (!NT_SUCCESS (Status)) {
            RtlFreeHeap (RtlProcessHeap(), 0, State);
            return Status;
        }
        Status = NtOpenThreadToken (NtCurrentThread(),
                                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                    FALSE,
                                    &State->Token);

        if (!NT_SUCCESS (Status)) {
            State->Token = NULL;
            Status1 = NtSetInformationThread (NtCurrentThread(),
                                              ThreadImpersonationToken,
                                              &State->Token,
                                              sizeof (State->Token));
            ASSERT (NT_SUCCESS (Status1));
            RtlFreeHeap( RtlProcessHeap(), 0, State );
            return Status;
        }

        State->Revert = 1;
    }

    State->NewPrivileges = (PTOKEN_PRIVILEGES)(State+1);
    State->OldPrivileges = (PTOKEN_PRIVILEGES)(State->OldPrivBuffer);

    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertUlongToLuid(Privilege);
    State->NewPrivileges->PrivilegeCount = 1;
    State->NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    State->NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    cbNeeded = sizeof( State->OldPrivBuffer );
    Status = NtAdjustPrivilegesToken (State->Token,
                                      FALSE,
                                      State->NewPrivileges,
                                      cbNeeded,
                                      State->OldPrivileges,
                                      &cbNeeded);



    if (Status == STATUS_BUFFER_TOO_SMALL) {
        State->OldPrivileges = RtlAllocateHeap (RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cbNeeded);
        if (State->OldPrivileges  == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {
            Status = NtAdjustPrivilegesToken (State->Token,
                                              FALSE,
                                              State->NewPrivileges,
                                              cbNeeded,
                                              State->OldPrivileges,
                                              &cbNeeded);
        }
    }

    //
    // STATUS_NOT_ALL_ASSIGNED means that the privilege isn't
    // in the token, so we can't proceed.
    //
    // This is a warning level status, so map it to an error status.
    //

    if (Status == STATUS_NOT_ALL_ASSIGNED) {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }


    if (!NT_SUCCESS( Status )) {
        if (State->OldPrivileges != (PTOKEN_PRIVILEGES)State->OldPrivBuffer) {
            RtlFreeHeap( RtlProcessHeap(), 0, State->OldPrivileges );
        }

        St = CloseHandle (State->Token);
        ASSERT (St);
        State->Token = NULL;
        if (State->Revert) {
            Status1 = NtSetInformationThread (NtCurrentThread(),
                                              ThreadImpersonationToken,
                                              &State->Token,
                                              sizeof (State->Token));
            ASSERT (NT_SUCCESS (Status1));
        }
        RtlFreeHeap( RtlProcessHeap(), 0, State );
        return Status;
    }

    *ReturnedState = State;
    return STATUS_SUCCESS;
}


VOID
BasepReleasePrivilege(
    PVOID StatePointer
    )
{
    BOOL St;
    NTSTATUS Status;
    PBASEP_ACQUIRE_STATE State = (PBASEP_ACQUIRE_STATE)StatePointer;

    if (!State->Revert) {
        NtAdjustPrivilegesToken (State->Token,
                                 FALSE,
                                 State->OldPrivileges,
                                 0,
                                 NULL,
                                 NULL);
    }

    if (State->OldPrivileges != (PTOKEN_PRIVILEGES)State->OldPrivBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, State->OldPrivileges );
    }

    St = CloseHandle( State->Token );
    ASSERT (St);

    State->Token = NULL;
    if (State->Revert) {
        Status = NtSetInformationThread (NtCurrentThread(),
                                         ThreadImpersonationToken,
                                         &State->Token,
                                         sizeof (State->Token));
        ASSERT (NT_SUCCESS (Status));
    }
    RtlFreeHeap( RtlProcessHeap(), 0, State );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\process.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module implements Win32 Thread Object APIs

Author:

    Mark Lucovsky (markl) 21-Sep-1990

Revision History:

--*/



#include "basedll.h"
#pragma hdrstop
#include <winsafer.h>
#include <softpub.h>

#define MEDIUM_PATH (64)
static WCHAR pszFullQualifiedSetupEXE[100];
static PWSTR g_pszFullQualifiedSetupEXE = NULL;

RTL_QUERY_REGISTRY_TABLE BasepAppCertTable[] = {

    {(PRTL_QUERY_REGISTRY_ROUTINE )BasepConfigureAppCertDlls,     RTL_QUERY_REGISTRY_SUBKEY,
     L"AppCertDlls",                &BasepAppCertDllsList,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}

};

#define IsEmbeddedNT() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << EmbeddedNT))

BOOL
BuildSubSysCommandLine(
    LPWSTR  SubSysName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    PUNICODE_STRING SubSysCommandLine
    );

PVOID
BasepIsRealtimeAllowed(
    BOOLEAN LeaveEnabled
    );

#ifdef WX86

PWCHAR
BasepWx86KnownExe(
    LPCWSTR ExeName
    )
/*++

Routine Description:

    Checks for Wx86 Known Exes which wx86 applications must run
    compatible binaries. We currently have Known exes for
    regedit.exe, regsvr32.exe, and msiexec.exe

Arguments:

     ExeName - name to check for match.

Return Value:

     if the name needs to be swapped, a buffer is allocated off
     of the process heap filled with new name and returned.
     otherwise NULL is returned.

--*/

{
     UNICODE_STRING NameUnicode;
     PWCHAR pwch, pwcNewName = NULL;

     //
     // Compare the base name, and see if its regedit.exe
     // Note that we are expecting a fully qualified path name.
     //

     pwch = wcsrchr(ExeName, L'\\');
     if (pwch && *pwch++ && *pwch ) {
        if (!_wcsicmp(pwch, L"regedit.exe")) {
           pwcNewName = L"\\wiregedt.exe";
        } else {
           if (!_wcsicmp(pwch, L"regsvr32.exe")) {
              pwcNewName = L"\\regsvr32.exe";
           } else {
              if (!_wcsicmp(pwch, L"msiexec.exe")) {
                 pwcNewName = L"\\msiexec.exe";
              } else {
                 return NULL;
              }
           }
        }
     } else {
        return NULL;
     }



     //
     // It matches, so formulate new name
     //

     pwch = RtlAllocateHeap(RtlProcessHeap(),
                               MAKE_TAG( TMP_TAG ),
                               MAX_PATH + sizeof(WCHAR)
                               );

     if (!pwch) {
         return NULL;
         }

     NameUnicode.Buffer = pwch;
     NameUnicode.MaximumLength = MAX_PATH + sizeof(WCHAR);
     RtlCopyUnicodeString(&NameUnicode, &BaseWindowsSystemDirectory);
     if (NameUnicode.Buffer[(NameUnicode.Length>>1)-1] == (WCHAR)'\\') {
         NameUnicode.Buffer[(NameUnicode.Length>>1)-1] = UNICODE_NULL;
         NameUnicode.Length -= sizeof(WCHAR);
         }

     RtlAppendUnicodeToString(&NameUnicode, pwcNewName);

     return pwch;
}


#endif

BOOL
BasepIsSetupInvokedByWinLogon(
    PCWSTR pwszFullQualifiedApplicationPath)
{
    if (GetModuleHandle(TEXT("winlogon.EXE")))  // winlogon is running
    {
        //
        // set the global pointer g_pszFullQualifiedSetupEXE
        //
        if (g_pszFullQualifiedSetupEXE == NULL) 
        {
            //
            // we assume that the name of setup program is "setup.exe". This may change in the future
            // and the best way is to query RegistryValue of \\HKLM\SYSTEM\Setup\CmdLine 
            // and get the firstpart of the value, attach ".exe" if it does not have an ext
            //
            LPWSTR pwszSetupExe = L"setup.exe";

            ULONG ulReservedLength = sizeof(WCHAR) +        // trailing backSlash
                                     wcslen(pwszSetupExe);  //trailing NULL is included

            ULONG ulSizeOfBuf = sizeof(pszFullQualifiedSetupEXE)/sizeof(WCHAR);
            ULONG ulLength = GetSystemDirectoryW(pszFullQualifiedSetupEXE, ulSizeOfBuf - ulReservedLength);

            //
            // very unlikely failed because of UNSUFFICIENT_BUFFER_SIZE
            // but kind of buggy here
            //
            if ((ulLength == 0) || (ulLength > ulSizeOfBuf - ulReservedLength)) 
                return FALSE;
            
            if (pszFullQualifiedSetupEXE[ulLength] != L'\\') // set trailing slash
                pszFullQualifiedSetupEXE[ulLength] = L'\\';
                
            wcscpy(pszFullQualifiedSetupEXE + ulLength, pwszSetupExe);
            g_pszFullQualifiedSetupEXE = pszFullQualifiedSetupEXE;            
        }

        if (_wcsicmp(pwszFullQualifiedApplicationPath, g_pszFullQualifiedSetupEXE) == 0) 
            return TRUE;
    }

    return FALSE;
}


PFNWAITFORINPUTIDLE UserWaitForInputIdleRoutine = NULL;
#define DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT 30000

BOOL
BasepIsImageVersionOk(
    IN ULONG ImageMajorVersion,
    IN ULONG ImageMinorVersion
    )
{
    //
    // Make sure image is at least 3.10
    //

    if ( ( ImageMajorVersion < 3 ) ||
         ( ImageMajorVersion == 3 && ImageMinorVersion < 10 ) ) {
        return FALSE;
        }

    //
    // And not greater than what we are
    //

    if ( ( ImageMajorVersion > USER_SHARED_DATA->NtMajorVersion ) ||
         ( ImageMajorVersion == USER_SHARED_DATA->NtMajorVersion &&
           ImageMinorVersion > USER_SHARED_DATA->NtMinorVersion
         )
       ) {
        return FALSE;
        }

    return TRUE;
}





NTSTATUS
BasepIsProcessAllowed(LPCWSTR lpApplicationName)
/*++

    Validate that the image lpApplicationName
    is listed in certified/authorized executables
--*/

{
    NTSTATUS                        Status;
    UNICODE_STRING                  BackupUnicodeString;
    PUNICODE_STRING                 pStaticString;
    LPWSTR                          DllNameBuf;
    ULONG                           BackupStringSize;
    PLIST_ENTRY                     Head, Next;

    static BOOL              fInitialized = FALSE;
    static BOOL              fCertifyEnabled = TRUE;
    static NTSTATUS          CertifyErrorCode = STATUS_ACCESS_DENIED;
    static HINSTANCE         hEmbeddedCertDll = NULL;
    static NTSTATUS (WINAPI *fEmbeddedCertFunc)(LPCWSTR lpApplicationName) = NULL;


    //
    // Initialization occures when this routine is first entered. After init
    // is done, fInitialized is TRUE, and one of the following must hold
    // - Certification is OFF, and dwCertifyErrorCode indicates whether this
    //   is because no certification is needed, or due to an initialization
    //   error.
    // - Certification is ON, call the EmbeddedNT and/or Plugin dlls to verify
    //
InitDone:

    if ( fInitialized ) {

       PBASEP_APPCERT_ENTRY p;
       NTSTATUS tempStatus;
       ULONG Reason;

        if ( !fCertifyEnabled ) {
            return CertifyErrorCode;
        }

        ASSERT( fEmbeddedCertFunc || !IsListEmpty( &BasepAppCertDllsList ) );

        Status = STATUS_SUCCESS;

        if ( fEmbeddedCertFunc ) {
            Status = (*fEmbeddedCertFunc)( lpApplicationName );
            return Status;
        }

        Head = &BasepAppCertDllsList;

        Reason = APPCERT_CREATION_ALLOWED;
        //
        // Two phase notification scheme. In the first phase we get every dll to
        // vote whether the process should be created. In the second phase we
        // let them know if the process is going to get created or not.
        //

        //
        // Phase 1 : Voting
        //
        Next = Head->Flink;
        while (Next != Head) {
           p = CONTAINING_RECORD( Next,
                                  BASEP_APPCERT_ENTRY,
                                  Entry
                                );
           ASSERT(p->fPluginCertFunc != NULL);

           tempStatus = (*(p->fPluginCertFunc))( lpApplicationName, APPCERT_IMAGE_OK_TO_RUN );

           if (!NT_SUCCESS(tempStatus)) {
              Status = tempStatus;
              Reason = APPCERT_CREATION_DENIED;
           }

           Next = Next->Flink;
        }


        //
        // Phase 2: Announce Results
        //

        Next = Head->Flink;

        while (Next != Head) {
           p = CONTAINING_RECORD( Next,
                                  BASEP_APPCERT_ENTRY,
                                  Entry
                                );
           ASSERT(p->fPluginCertFunc != NULL);

           (*(p->fPluginCertFunc))( lpApplicationName, Reason );

           Next = Next->Flink;
        }

        return Status;
    }


    //
    // Start initialization
    //
    RtlEnterCriticalSection(&gcsAppCert);


    //
    // check if someone did init while we waited on the crit sect
    //
    if (fInitialized) {
        goto Initialized;
    }

    //
    // Initialize locals
    //
    Status = STATUS_SUCCESS;
    RtlZeroMemory( &BackupUnicodeString, sizeof(BackupUnicodeString) );
    DllNameBuf = NULL;


    //
    // check if this is EmbeddedNT
    //
    if (IsEmbeddedNT()) {

        HINSTANCE  hDll;
        ULONG      Length;


        //
        // LoadDll calls a routine that uses &NtCurrentTeb()->StaticUnicodeString
        // When we are called from CreateProcessA (e.g. the debuggers), the
        // application command line is stored in this area. Therefore,
        // we need to save / restore it around the call to LoadLibrary
        //
        pStaticString = &NtCurrentTeb()->StaticUnicodeString;
        BackupUnicodeString.MaximumLength = pStaticString->MaximumLength;
        BackupUnicodeString.Length = pStaticString->Length;
        BackupStringSize = pStaticString->Length + sizeof(UNICODE_NULL);
        if (BackupStringSize > BackupUnicodeString.MaximumLength) {
            BackupStringSize = BackupUnicodeString.MaximumLength;
        }

        BackupUnicodeString.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                         MAKE_TAG( TMP_TAG ),
                                         BackupStringSize);

        if (BackupUnicodeString.Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        RtlMoveMemory(BackupUnicodeString.Buffer,
                      pStaticString->Buffer,
                      BackupStringSize);


        //
        // build the full path DLL name
        //
        DllNameBuf = RtlAllocateHeap(RtlProcessHeap(),
                                     MAKE_TAG( TMP_TAG ),
                                     (MAX_PATH + 1) << 1);

        if (DllNameBuf == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        Length = GetSystemDirectoryW(
                      DllNameBuf,
                      MAX_PATH - 1 - sizeof(CERTAPP_EMBEDDED_DLL_NAME)/2);

        if (!Length ||
             Length > (MAX_PATH - 1 - sizeof(CERTAPP_EMBEDDED_DLL_NAME)/2) ) {
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        if (DllNameBuf[ Length - 1 ] != L'\\') {
            DllNameBuf[ Length++ ] = L'\\';
        }

        RtlMoveMemory(
                &DllNameBuf[ Length ],
                CERTAPP_EMBEDDED_DLL_NAME,
                sizeof(CERTAPP_EMBEDDED_DLL_NAME));

        hDll = LoadLibraryW( DllNameBuf );
        if (hDll == NULL) {
            //
            // The library was not loaded, return.
            //
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        //
        // get the entry point
        //
        fEmbeddedCertFunc = (NTSTATUS (WINAPI *)(LPCWSTR))
                                GetProcAddress(hDll,
                                               CERTAPP_EMBEDDED_DLL_EP
                                               );
        if (fEmbeddedCertFunc == NULL) {
            //
            // Unable to retrieve routine address, fail.
            //
            Status = STATUS_UNSUCCESSFUL;
        }
        goto Cleanup;

    } else {
       //
       // On non-embedded NT
       // Do a quick test of top level key to find out if app cert is on.
       //
          static const UNICODE_STRING     UnicodeString =
              RTL_CONSTANT_STRING(CERTAPP_KEY_NAME);
          static const OBJECT_ATTRIBUTES  obja =
              RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeString, OBJ_CASE_INSENSITIVE);
          HANDLE                          hKey;

          if ( !NT_SUCCESS(NtOpenKey(&hKey,
                             KEY_QUERY_VALUE,
                             (POBJECT_ATTRIBUTES) &obja))) {

              goto Cleanup;

          } else {
             NtClose(hKey);
          }

    }



    //
    // Backup static string if we haven't done so before. see comment above
    //
    if (BackupUnicodeString.Buffer == NULL) {
        pStaticString = &NtCurrentTeb()->StaticUnicodeString;
        BackupUnicodeString.MaximumLength = pStaticString->MaximumLength;
        BackupUnicodeString.Length = pStaticString->Length;
        BackupStringSize = pStaticString->Length + sizeof(UNICODE_NULL);
        if (BackupStringSize > BackupUnicodeString.MaximumLength) {
            BackupStringSize = BackupUnicodeString.MaximumLength;
        }

        BackupUnicodeString.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                         MAKE_TAG( TMP_TAG ),
                                         BackupStringSize);

        if (BackupUnicodeString.Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        RtlMoveMemory(BackupUnicodeString.Buffer,
                      pStaticString->Buffer,
                      BackupStringSize);
    }

    //
    // load and initialize the list of certification DLLs
    //

    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     L"Session Manager",
                                     BasepAppCertTable,
                                     NULL,
                                     NULL
                                   );


    if (!NT_SUCCESS(Status)) {

       if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
          //
          // If the registry Key is missing AppCert is turned off
          //
          Status = STATUS_SUCCESS;
       }
    }


Cleanup:

    if (DllNameBuf) {
        RtlFreeHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), DllNameBuf);
    }
    if (BackupUnicodeString.Buffer) {
        RtlMoveMemory(
                pStaticString->Buffer,
                BackupUnicodeString.Buffer,
                BackupStringSize);
        pStaticString->Length = BackupUnicodeString.Length;
        RtlFreeHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), BackupUnicodeString.Buffer);
    }


    if (NT_SUCCESS( Status ) && (fEmbeddedCertFunc || !IsListEmpty( &BasepAppCertDllsList))) {
        fCertifyEnabled = TRUE;
    } else {
        fCertifyEnabled = FALSE;
        CertifyErrorCode = Status;
    }

    fInitialized = TRUE;

Initialized:
    RtlLeaveCriticalSection(&gcsAppCert);

    goto InitDone;
}


BOOL
IsShimInfrastructureDisabled(
    void
    )
{
    static int g_nDisableShims = -1;
            // -1 means we didn't check for disabled shims yet
            //  0 means the shim infrastructure is enabled
            //  1 means the shim infrastructure is disabled

    static const UNICODE_STRING KeyNameAppCompat =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility");
    static const UNICODE_STRING ValueNameDisableShims =
        RTL_CONSTANT_STRING(L"DisableAppCompat");
    static const OBJECT_ATTRIBUTES objaAppCompat =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyNameAppCompat, OBJ_CASE_INSENSITIVE);

    HANDLE                      hKey;
    BYTE ValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    DWORD                       ValueLength;
    NTSTATUS                    Status;

    //
    // First see if we already checked the registry
    //
    if (g_nDisableShims == 1) {
        return TRUE;
    }

    if (g_nDisableShims == 0) {
        return FALSE;
    }

    //
    // Now see if the shim infrastructure is disabled for this machine
    //
    Status = NtOpenKey(&hKey, KEY_QUERY_VALUE, (POBJECT_ATTRIBUTES) &objaAppCompat);

    if (NT_SUCCESS(Status)) {
        Status = NtQueryValueKey(hKey,
                                 (PUNICODE_STRING) &ValueNameDisableShims,
                                 KeyValuePartialInformation,
                                 pKeyValueInformation,
                                 sizeof(ValueBuffer),
                                 &ValueLength);

        NtClose(hKey);

        if (NT_SUCCESS(Status) &&
            pKeyValueInformation->Type == REG_DWORD &&
            pKeyValueInformation->DataLength == sizeof(DWORD)) {
            if (*((PDWORD) pKeyValueInformation->Data) > 0) {
                g_nDisableShims = 1;
                return TRUE;
            }
        }
    }

    g_nDisableShims = 0;

    return FALSE;
}

//
// the code below should never be called on non-386 platform
//

NTSTATUS
BasepCheckBadapp(
    HANDLE hFile,
    WCHAR* pwszApplication,          // IN
    WCHAR* pEnvironment,             // IN
    PVOID* ppData,                   // OUT
    PDWORD pcbData,                  // OUT
    PVOID* ppSxsData,                // OUT
    PDWORD pcbSxsData                // OUT
    )
{
    typedef BOOL (STDAPICALLTYPE *PFNCheckRunApp)(
        HANDLE FileHandle,
        WCHAR* pwszPath,
        WCHAR* pEnvironment,
        DWORD  dwReason,
        PVOID* ppData,
        PDWORD pcbData,
        PVOID* ppDataSxs,
        PDWORD pcbDataSxs);

    NTSTATUS                  RetStatus;
    NTSTATUS                  Status;
    HANDLE                    ModuleHandle;
    static PFNCheckRunApp     pfnCheckRunApp = NULL;
    PUNICODE_STRING           pStaticString;
    UNICODE_STRING            BackupUnicodeString;
    ULONG                     BackupStringSize;
    WCHAR                     Apphelp_dllBuffer[MAX_PATH];
    UNICODE_STRING            Apphelp_dllPath;
    DWORD                     dwReason = 0; // reason for having avoided cache

    static const UNICODE_STRING Apphelp_dllModuleName        = RTL_CONSTANT_STRING(L"\\system32\\Apphelp.dll");
    static const STRING         CheckRunAppProcedureName     = RTL_CONSTANT_STRING("ApphelpCheckRunApp");

    //
    // Do nothing if the shim infrastructure is disabled
    //
    if (IsShimInfrastructureDisabled()) {
        return STATUS_SUCCESS;
    }

    //
    // We can't re-enter this code even within the same thread.
    // Such an occasion is when apphelp needs to do ShellExecute
    // which comes back here -- clobbering our state
    //
    pStaticString = &NtCurrentTeb()->StaticUnicodeString;
    BackupUnicodeString.MaximumLength = pStaticString->MaximumLength;
    BackupUnicodeString.Length = pStaticString->Length;
    BackupStringSize = pStaticString->Length + sizeof(UNICODE_NULL);

    if (BackupStringSize > BackupUnicodeString.MaximumLength) {
        BackupStringSize = BackupUnicodeString.MaximumLength;
    }

    BackupUnicodeString.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                                 MAKE_TAG(TMP_TAG),
                                                 BackupStringSize);

    if (BackupUnicodeString.Buffer == NULL) {
        //
        // we failed to allocate memory to save the static string
        // return success and try to run an app
        //
        return STATUS_SUCCESS;
    }

    RtlMoveMemory(BackupUnicodeString.Buffer,
                  pStaticString->Buffer,
                  BackupStringSize);


    //
    // Check our internal cache -- no touching apphelp.dll before we check with the cache
    //
    if (BaseCheckAppcompatCache(pwszApplication, hFile, pEnvironment, &dwReason)) {
        RetStatus = STATUS_SUCCESS;
        //
        // we can't just return here since we need to restore the static
        // unicode string, so we go around the code that calls into apphelp
        //
        goto CheckDone;
    }


    if (pfnCheckRunApp == (PFNCheckRunApp)(LONG_PTR)-1) {
        // We've tried before and could not get the fn ptr
        RetStatus = STATUS_SUCCESS;
        goto CheckDone;
    }

    RtlEnterCriticalSection(&gcsAppCompat);

    if (NULL == pfnCheckRunApp) {
        //
        // BaseWindowsDirectory is the unicode string that houses windows directory
        //
        DWORD dwLength;
        WCHAR* pModuleName = Apphelp_dllModuleName.Buffer;

        dwLength = BaseWindowsDirectory.Length + Apphelp_dllModuleName.Length + sizeof(UNICODE_NULL);
        if (dwLength > sizeof(Apphelp_dllBuffer)) {
            Status = STATUS_BUFFER_TOO_SMALL; // error, we don't support case when windows dir + apphelp location > MAX_PATH
        }
        else {

            Apphelp_dllPath.Buffer        = Apphelp_dllBuffer;
            Apphelp_dllPath.Length        = 0;
            Apphelp_dllPath.MaximumLength = sizeof(Apphelp_dllBuffer);

            RtlCopyUnicodeString(&Apphelp_dllPath, &BaseWindowsDirectory);

            if (L'\\' == Apphelp_dllPath.Buffer[Apphelp_dllPath.Length/sizeof(WCHAR) - 1]) {
                ++pModuleName; // skip over the first backslash character
            }

            RtlAppendUnicodeToString(&Apphelp_dllPath, pModuleName);


            Status = LdrLoadDll(NULL,
                                NULL,
                                &Apphelp_dllPath,
                                &ModuleHandle);
        }

        if (NT_SUCCESS(Status)) {
            // loaded apphelp, get proc
            Status = LdrGetProcedureAddress(ModuleHandle,
                                            &CheckRunAppProcedureName,
                                            0,
                                            (PVOID*)&pfnCheckRunApp);

            if (!NT_SUCCESS(Status)) {
                //
                // Couldn't get the fn ptr. Make sure we won't try again
                //
                LdrUnloadDll(ModuleHandle);
                pfnCheckRunApp = (PFNCheckRunApp)(LONG_PTR)-1;
            }
        } else {
            //
            // No Apphelp.dll, so don't try again
            //
            pfnCheckRunApp = (PFNCheckRunApp)(LONG_PTR)-1;
        }
    }

    RtlLeaveCriticalSection(&gcsAppCompat);

    RetStatus = STATUS_SUCCESS;

    if (pfnCheckRunApp && (pfnCheckRunApp != (PFNCheckRunApp)(LONG_PTR)- 1)) {

        //
        // We have the proc here, do the checking
        //

        if (!pfnCheckRunApp(hFile,
                            pwszApplication,
                            pEnvironment,
                            dwReason,
                            ppData,
                            pcbData,
                            ppSxsData,
                            pcbSxsData)) {

            RetStatus = STATUS_ACCESS_DENIED;
        }

    }

CheckDone:

    //
    // Store appcompat data -- only returns something if we are running an app!
    //

    // now restore
    RtlMoveMemory(pStaticString->Buffer,
                  BackupUnicodeString.Buffer,
                  BackupStringSize);

    pStaticString->Length = BackupUnicodeString.Length;

    RtlFreeHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), BackupUnicodeString.Buffer);

    return RetStatus;
}


BOOL
WINAPI
CreateProcessInternalA(
    HANDLE hUserToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation,
    PHANDLE hRestrictedUserToken
    )

/*++

    ANSI thunk to CreateProcessW

--*/

{
    NTSTATUS Status;
    PUNICODE_STRING CommandLine;
    UNICODE_STRING ApplicationName;
    UNICODE_STRING CurrentDirectory;
    STARTUPINFOW StartupInfo;
    ANSI_STRING AnsiString;
    UNICODE_STRING Unicode;
    UNICODE_STRING DynamicCommandLine;
    UNICODE_STRING NullUnicodeString;
    BOOL ReturnStatus;

    if (ARGUMENT_PRESENT (lpCommandLine)) {
        if (!Basep8BitStringToDynamicUnicodeString( &DynamicCommandLine,
                                                    lpCommandLine )) {
            return FALSE;
        }
    } else {
         DynamicCommandLine.Buffer = NULL;
         CommandLine = &NullUnicodeString;
         CommandLine->Buffer = NULL;
    }

    ApplicationName.Buffer = NULL;
    ApplicationName.Buffer = NULL;
    CurrentDirectory.Buffer = NULL;
    RtlMoveMemory(&StartupInfo,lpStartupInfo,sizeof(*lpStartupInfo));
    ASSERT(sizeof(StartupInfo) == sizeof(*lpStartupInfo));
    StartupInfo.lpReserved = NULL;
    StartupInfo.lpDesktop = NULL;
    StartupInfo.lpTitle = NULL;

    try {
        try {
            if (ARGUMENT_PRESENT(lpApplicationName)) {

                if (!Basep8BitStringToDynamicUnicodeString( &ApplicationName,
                                                            lpApplicationName )) {
                    ReturnStatus = FALSE;
                    goto tryexit;
                }
            }

            if (ARGUMENT_PRESENT(lpCurrentDirectory)) {
                if (!Basep8BitStringToDynamicUnicodeString( &CurrentDirectory,
                                                            lpCurrentDirectory )) {
                    ReturnStatus = FALSE;
                    goto tryexit;
                }
            }

            if (ARGUMENT_PRESENT(lpStartupInfo->lpReserved)) {

                //
                // Win95 does not touch reserved, and Intergraph Voxtel passes
                // garbage for this. Handle this by probing lpReserved, and if
                // the pointer is bad, ignore it
                //

                try {

                    RtlInitAnsiString(&AnsiString,lpStartupInfo->lpReserved);

                    }
                except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
                            ? EXCEPTION_EXECUTE_HANDLER
                            : EXCEPTION_CONTINUE_SEARCH) {
                    goto bail_on_reserved;
                    }

                Unicode.MaximumLength = (USHORT)RtlAnsiStringToUnicodeSize(&AnsiString) ;
                StartupInfo.lpReserved = RtlAllocateHeap( RtlProcessHeap(),
                                                          MAKE_TAG( TMP_TAG ),
                                                          Unicode.MaximumLength);
                if ( !StartupInfo.lpReserved ) {
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                Unicode.Buffer = StartupInfo.lpReserved;
                Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                }

bail_on_reserved:
            if (ARGUMENT_PRESENT(lpStartupInfo->lpDesktop)) {
                RtlInitAnsiString(&AnsiString,lpStartupInfo->lpDesktop);
                Unicode.MaximumLength = (USHORT)RtlAnsiStringToUnicodeSize(&AnsiString) ;
                StartupInfo.lpDesktop = RtlAllocateHeap( RtlProcessHeap(),
                                                         MAKE_TAG( TMP_TAG ),
                                                         Unicode.MaximumLength);
                if ( !StartupInfo.lpDesktop ) {
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                Unicode.Buffer = StartupInfo.lpDesktop;
                Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                }

            if (ARGUMENT_PRESENT(lpStartupInfo->lpTitle)) {
                RtlInitAnsiString(&AnsiString,lpStartupInfo->lpTitle);
                Unicode.MaximumLength = (USHORT)RtlAnsiStringToUnicodeSize(&AnsiString) ;
                StartupInfo.lpTitle = RtlAllocateHeap( RtlProcessHeap(),
                                                       MAKE_TAG( TMP_TAG ),
                                                       Unicode.MaximumLength);
                if ( !StartupInfo.lpTitle ) {
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                Unicode.Buffer = StartupInfo.lpTitle;
                Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                }
            }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
                    ? EXCEPTION_EXECUTE_HANDLER
                    : EXCEPTION_CONTINUE_SEARCH) {
            BaseSetLastNTError(GetExceptionCode());
            ReturnStatus = FALSE;
            goto tryexit;
            }
        ReturnStatus = CreateProcessInternalW(
                            hUserToken,
                            ApplicationName.Buffer,
                            DynamicCommandLine.Buffer ? DynamicCommandLine.Buffer
                                                      : CommandLine->Buffer,
                            lpProcessAttributes,
                            lpThreadAttributes,
                            bInheritHandles,
                            dwCreationFlags,
                            lpEnvironment,
                            CurrentDirectory.Buffer,
                            &StartupInfo,
                            lpProcessInformation,
                            hRestrictedUserToken
                            );
tryexit:;
        }
    finally {
        RtlFreeUnicodeString(&DynamicCommandLine);
        RtlFreeUnicodeString(&ApplicationName);
        RtlFreeUnicodeString(&CurrentDirectory);
        RtlFreeHeap(RtlProcessHeap(), 0,StartupInfo.lpReserved);
        RtlFreeHeap(RtlProcessHeap(), 0,StartupInfo.lpDesktop);
        RtlFreeHeap(RtlProcessHeap(), 0,StartupInfo.lpTitle);
        }

    return ReturnStatus;

}

BOOL
WINAPI
CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )

/*++

    ANSI thunk to CreateProcessW

--*/

{
    return CreateProcessInternalA(
               NULL, // Create new process with the token on the creator process
               lpApplicationName,
               lpCommandLine,
               lpProcessAttributes,
               lpThreadAttributes,
               bInheritHandles,
               dwCreationFlags,
               lpEnvironment,
               lpCurrentDirectory,
               lpStartupInfo,
               lpProcessInformation,
               NULL  // Do not return the restricted token
               );

}

void
WINAPI
RegisterWaitForInputIdle(
    IN PFNWAITFORINPUTIDLE WaitForInputIdleRoutine
    )
{
    //
    // Soft link in the USER call back for the routine needed for WinExec()
    // synchronization. The only reason this is a soft link is so we can
    // run char mode without gui.
    //

    UserWaitForInputIdleRoutine = WaitForInputIdleRoutine;
}

void
StuffStdHandle(
    HANDLE ProcessHandle,
    HANDLE StdHandle,
    PHANDLE TargetHandleAddress
    )
{
    NTSTATUS Status;
    HANDLE TargetStdHandle;
    SIZE_T NumberOfBytesWritten;

    if (StdHandle == NULL) {
        return;
    }
    Status = NtDuplicateObject (NtCurrentProcess(),
                                StdHandle,
                                ProcessHandle,
                                &TargetStdHandle,
                                DUPLICATE_SAME_ACCESS | DUPLICATE_SAME_ATTRIBUTES,
                                0,
                                0);
    if (!NT_SUCCESS( Status )) {
        return;
    }

    Status = NtWriteVirtualMemory (ProcessHandle,
                                   TargetHandleAddress,
                                   &TargetStdHandle,
                                   sizeof( TargetStdHandle ),
                                   &NumberOfBytesWritten);
    return;
}


static HANDLE AdvApi32ModuleHandle = (HANDLE) (ULONG_PTR) -1;

NTSTATUS
BasepCheckWinSaferRestrictions(
        IN HANDLE       hUserToken          OPTIONAL,
        IN LPCWSTR      lpApplicationName,
        IN HANDLE       FileImageHandle     OPTIONAL,
        OUT LPDWORD     pdwJobMemberLevel,
        OUT PHANDLE     phRestrictedToken,
        OUT PHANDLE     phAssignmentJob
        )
// Note: May return -1 for the ERROR_ACCESS_DISABLED_BY_POLICY case.
{

#define SAFER_USER_KEY_NAME L"\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers"

    typedef BOOL (WINAPI *ComputeAccessTokenFromCodeAuthzLevelT) (
        IN SAFER_LEVEL_HANDLE LevelObject,
        IN HANDLE             InAccessToken         OPTIONAL,
        OUT PHANDLE           OutAccessToken,
        IN DWORD              dwFlags,
        IN LPVOID             lpReserved
        );

    typedef BOOL (WINAPI *IdentifyCodeAuthzLevelWT) (
        IN DWORD                dwCheckFlags,
        IN PSAFER_CODE_PROPERTIES    CodeProperties,
        OUT SAFER_LEVEL_HANDLE        *pLevelObject,
        IN LPVOID               lpReserved
        );

    typedef BOOL (WINAPI *CloseCodeAuthzLevelT) (
        IN SAFER_LEVEL_HANDLE      hLevelObject);

    typedef BOOL (WINAPI *CodeAuthzRecordEventLogEntryT) (
        IN SAFER_LEVEL_HANDLE      hAuthzLevel,
        IN LPCWSTR          szTargetPath,
        IN LPVOID           lpReserved
        );

    NTSTATUS Status;
    SAFER_CODE_PROPERTIES codeproperties;
    SAFER_LEVEL_HANDLE hAuthzLevel;
    HANDLE hProcessToken = NULL;
    HANDLE hThreadToken = NULL;
    HANDLE hEffectiveToken = NULL;
    static DWORD dwSaferAuthenticodeFlag = 0;

    const static SID_IDENTIFIER_AUTHORITY NtAuthority =
            SECURITY_NT_AUTHORITY;
    const static UNICODE_STRING UnicodeSafeBootKeyName =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\SafeBoot\\Option");
    const static UNICODE_STRING UnicodeSafeBootValueName =
        RTL_CONSTANT_STRING(L"OptionValue");
    const static OBJECT_ATTRIBUTES ObjectAttributesSafeBoot =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeSafeBootKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING UnicodeKeyName =
        RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
    const static UNICODE_STRING UnicodeTransparentValueName =
        RTL_CONSTANT_STRING(L"TransparentEnabled");
    const static OBJECT_ATTRIBUTES ObjectAttributesCodeIdentifiers =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING ModuleName =
        RTL_CONSTANT_STRING(L"ADVAPI32.DLL");
    const static ANSI_STRING ProcedureNameIdentify =
        RTL_CONSTANT_STRING("SaferIdentifyLevel");
    const static ANSI_STRING ProcedureNameCompute =
        RTL_CONSTANT_STRING("SaferComputeTokenFromLevel");
    const static ANSI_STRING ProcedureNameClose =
        RTL_CONSTANT_STRING("SaferCloseLevel");
    const static ANSI_STRING ProcedureNameLogEntry =
        RTL_CONSTANT_STRING("SaferRecordEventLogEntry");
    const static UNICODE_STRING SaferAuthenticodeValueName =
        RTL_CONSTANT_STRING(L"AuthenticodeEnabled");

    static IdentifyCodeAuthzLevelWT lpfnIdentifyCodeAuthzLevelW;
    static ComputeAccessTokenFromCodeAuthzLevelT
            lpfnComputeAccessTokenFromCodeAuthzLevel;
    static CloseCodeAuthzLevelT lpfnCloseCodeAuthzLevel;
    static CodeAuthzRecordEventLogEntryT lpfnCodeAuthzRecordEventLogEntry;


    //
    // Verify that our required arguments were supplied.
    //
    if (!ARGUMENT_PRESENT(lpApplicationName) || !*lpApplicationName) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!ARGUMENT_PRESENT(pdwJobMemberLevel) ||
        !ARGUMENT_PRESENT(phRestrictedToken) ||
        !ARGUMENT_PRESENT(phAssignmentJob)) {
        return STATUS_ACCESS_VIOLATION;
    }


    //
    // Enter a critical section for the entire trust evalation.
    // (We borrow the critical section used by AppCert).
    //
    RtlEnterCriticalSection(&gcsAppCert);


    //
    // If either of these two cases are true, then we should bail out
    // as quickly as possible because we know that WinSafer evaluations
    // should definitely not occur for this process anymore.
    //
    if (AdvApi32ModuleHandle == NULL) {
        // We tried to load ADVAPI32.DLL once before, but failed.
        Status = STATUS_ENTRYPOINT_NOT_FOUND;
        goto ExitHandler;
    } else if (AdvApi32ModuleHandle == LongToHandle(-2)) {
        // Indicates that DLL checking should never be done for this process.
        Status = STATUS_SUCCESS;
        goto ExitHandler;
    }

    // 
    // We only need the process token if no token is supplied.
    //

    if (hUserToken == NULL) {


        //
        // Open and save the thread token.
        //

        Status = NtOpenThreadToken(
                     NtCurrentThread(), 
                     MAXIMUM_ALLOWED, 
                     TRUE, 
                     &hThreadToken);

        if (Status == STATUS_NO_TOKEN) {

        // The thread is not impersonating. It is ok to fall thru.

        } else if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        } else {

            
            HANDLE NewToken = NULL;
            // 
            // Revert to self.
            // 

            Status = NtSetInformationThread(
                                   NtCurrentThread(),
                                   ThreadImpersonationToken,
                                   (PVOID)&NewToken,
                                   (ULONG)sizeof(HANDLE)
                                   );
            //
            // This should never happen unless kernel gives up on us.
            //
    
            if ( !NT_SUCCESS(Status) ) {
                NtClose(hThreadToken);
                hThreadToken = NULL;
                goto ExitHandler;
            }
        }


        //
        // Open a handle to the current process's access token.
        // We care only about the process token, and not the
        // thread impersonation token.
        //
        Status = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_DUPLICATE | TOKEN_QUERY,
                        &hProcessToken);
        if (Status == STATUS_ACCESS_DENIED) {
            // Failed to open with query and duplicate privs.  Retry with
            // only query privileges, which might be enough to do simply
            // determine that we should not allow futher loading.  But without
            // duplicate access, we won't be able to restrict tokens later.
            Status = NtOpenProcessToken(
                            NtCurrentProcess(),
                            TOKEN_QUERY,
                            &hProcessToken);
        }

        if (hThreadToken != NULL) {

            //
            // Set the thread token to the saved one.
            //
    
            NTSTATUS lStatus = NtSetInformationThread(
                                   NtCurrentThread(),
                                   ThreadImpersonationToken,
                                   (PVOID)&hThreadToken,
                                   (ULONG)sizeof(HANDLE)
                                   );
    
            NtClose(hThreadToken);
            hThreadToken = NULL;

            //
            // This should never happen unless kernel gives up on us.
            //
    
            if ( !NT_SUCCESS(lStatus) ) {
                Status = lStatus;
                goto ExitHandler2;
            }

        }

        if (!NT_SUCCESS(Status)) {
            if (AdvApi32ModuleHandle == LongToHandle(-1)) {
                // If this is our first pass through, then it is unlikely
                // that any later attempts will succeed, so remember that.
                AdvApi32ModuleHandle = LongToHandle(-2);
                Status = STATUS_SUCCESS;
            }
            goto ExitHandler;
        }
        hEffectiveToken = hProcessToken;
    } else {
        hEffectiveToken = hUserToken;
    }

    //
    // Load ADVAPI32.DLL and get pointers to our functions.
    //
    if (AdvApi32ModuleHandle == LongToHandle(-1)) {
        HANDLE TempModuleHandle;

        //
        // Check if this process's access token is running as
        // the Local SYSTEM account, and disable enforcement if so.
        //
        {
            BYTE tokenuserbuff[sizeof(TOKEN_USER) + 128];
            PTOKEN_USER ptokenuser = (PTOKEN_USER) tokenuserbuff;
            BYTE localsystembuff[128];
            PSID LocalSystemSid = (PSID) localsystembuff;
            ULONG ulReturnLength;

            Status = NtQueryInformationToken(
                            hEffectiveToken, TokenUser,
                            tokenuserbuff, sizeof(tokenuserbuff),
                            &ulReturnLength);
            if (NT_SUCCESS(Status)) {
                Status = RtlInitializeSid(
                            LocalSystemSid,
                            (PSID_IDENTIFIER_AUTHORITY) &NtAuthority, 1);
                ASSERTMSG("InitializeSid should not fail.", NT_SUCCESS(Status));
                *RtlSubAuthoritySid(LocalSystemSid, 0) = SECURITY_LOCAL_SYSTEM_RID;

                if (RtlEqualSid(ptokenuser->User.Sid, LocalSystemSid)) {
                    goto FailSuccessfully;
                }

            }
        }


        //
        // If we are booting in safe mode and the user is a member of
        // the local Administrators group, then disable enforcement.
        // Notice that Windows itself does not perform any implicit
        // restriction of only allowing Administrators to log in during
        // Safe mode boot, so we must perform the test ourself.
        //
        {
            HANDLE hKeySafeBoot;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize;
            BOOLEAN bSafeModeBoot = FALSE;

            // We open the key for SET access (in addition to QUERY)
            // because only Administrators should be able to modify values
            // under this key.  This allows us to combine our test of
            // being an Administrator and having booted in Safe mode.
            Status = NtOpenKey(&hKeySafeBoot, KEY_QUERY_VALUE | KEY_SET_VALUE,
                               (POBJECT_ATTRIBUTES) &ObjectAttributesSafeBoot);
            if (NT_SUCCESS(Status)) {
                Status = NtQueryValueKey(
                            hKeySafeBoot,
                            (PUNICODE_STRING) &UnicodeSafeBootValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo,
                            sizeof(QueryBuffer),
                            &dwActualSize);
                NtClose(hKeySafeBoot);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 0) {
                        bSafeModeBoot = TRUE;
                    }
                }
            }

            if (bSafeModeBoot) {
                AdvApi32ModuleHandle = LongToHandle(-2);
FailSuccessfully:
                Status = STATUS_SUCCESS;
                goto ExitHandler2;
            }
        }



        //
        // Allow a way for policy to enable whether transparent
        // enforcement should be enabled or not (default to disable).
        // Note that the following values have meanings:
        //      0 = Transparent WinSafer enforcement disabled.
        //      1 = means enable transparent EXE enforcement
        //     >1 = means enable transparent EXE and DLL enforcement.
        //
        {
            // BUG 240635: change to use existence of policy instead.
            HANDLE hKeyEnabled;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize;
            BOOLEAN bPolicyEnabled = FALSE;

            Status = NtOpenKey(&hKeyEnabled, KEY_QUERY_VALUE,
                               (POBJECT_ATTRIBUTES) &ObjectAttributesCodeIdentifiers);
            if (NT_SUCCESS(Status)) {
                Status = NtQueryValueKey(
                            hKeyEnabled,
                            (PUNICODE_STRING) &UnicodeTransparentValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 0) {
                        bPolicyEnabled = TRUE;
                    }
                }

                //
                // do authenticode checks only if a regvalue is set
                //

                Status = NtQueryValueKey(
                            hKeyEnabled,
                            (PUNICODE_STRING) &SaferAuthenticodeValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 0) {
                        dwSaferAuthenticodeFlag = SAFER_CRITERIA_AUTHENTICODE;
                    }
                }
                NtClose(hKeyEnabled);
            }

            //
            // There was no machine policy. Check if user policy is enabled.
            //

            if (!bPolicyEnabled) {
                UNICODE_STRING CurrentUserKeyPath;
                UNICODE_STRING SubKeyNameUser;
                OBJECT_ATTRIBUTES ObjectAttributesUser;

                //
                // Get the prefix for the user key.
                //

                Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );

                if (NT_SUCCESS( Status ) ) {

                    SubKeyNameUser.Length = 0;
                    SubKeyNameUser.MaximumLength = CurrentUserKeyPath.Length + 
                                                   sizeof(WCHAR) + 
                                                   sizeof(SAFER_USER_KEY_NAME); 

                    //
                    // Allocate memory big enough to hold the unicode string.
                    //

                    SubKeyNameUser.Buffer = RtlAllocateHeap( 
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ),
                                                SubKeyNameUser.MaximumLength);

                    if (SubKeyNameUser.Buffer != NULL) {

                        //
                        // Copy the prefix into the string.
                        // This is of the type Registry\S-1-5-21-xxx-xxx-xxx-xxx.
                        //

                        Status = RtlAppendUnicodeStringToString(
                                    &SubKeyNameUser, 
                                    &CurrentUserKeyPath );

                        if (NT_SUCCESS( Status ) ) {

                            //
                            // Append the Safer suffix.
                            //

                            Status = RtlAppendUnicodeToString( 
                                         &SubKeyNameUser,
                                         SAFER_USER_KEY_NAME );

                            if (NT_SUCCESS( Status ) ) {

                                InitializeObjectAttributes(
                                    &ObjectAttributesUser,
                                    &SubKeyNameUser,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                );

                                Status = NtOpenKey( &hKeyEnabled,KEY_QUERY_VALUE,
                                             (POBJECT_ATTRIBUTES) &ObjectAttributesUser);

                                if (NT_SUCCESS(Status)) {
                                    Status = NtQueryValueKey(
                                                hKeyEnabled,
                                                (PUNICODE_STRING) &UnicodeTransparentValueName,
                                                KeyValuePartialInformation,
                                                pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);

                                    if (NT_SUCCESS(Status)) {
                                        if (pKeyValueInfo->Type == REG_DWORD &&
                                            pKeyValueInfo->DataLength == sizeof(DWORD) &&
                                            *((PDWORD) pKeyValueInfo->Data) > 0) {
                                            bPolicyEnabled = TRUE;
                                        }
                                    }
                                }
                            }

                        }
                        RtlFreeHeap(RtlProcessHeap(), 0, SubKeyNameUser.Buffer);
                    }
                    RtlFreeUnicodeString( &CurrentUserKeyPath );
                }
            }

            if (!bPolicyEnabled) {
                AdvApi32ModuleHandle = LongToHandle(-2);
                goto FailSuccessfully;
            }
        }


        //
        // Finally load the library.  We'll pass a special flag in
        // DllCharacteristics to eliminate WinSafer checking on advapi.
        //
        {
            ULONG DllCharacteristics = IMAGE_FILE_SYSTEM;
            Status = LdrLoadDll(UNICODE_NULL,
                                &DllCharacteristics,
                                (PUNICODE_STRING) &ModuleName,
                                &TempModuleHandle);
            if (!NT_SUCCESS(Status)) {
                Status = STATUS_ENTRYPOINT_NOT_FOUND;
                AdvApi32ModuleHandle = NULL;
                goto ExitHandler2;
            }
        }


        //
        // Get function pointers to the APIs that we'll need.  If we fail
        // to get pointers for any of them, then just unload advapi and
        // ignore all future attempts to load it within this process.
        //
        Status = LdrGetProcedureAddress(
                TempModuleHandle,
                (PANSI_STRING) &ProcedureNameIdentify,
                0,
                (PVOID*)&lpfnIdentifyCodeAuthzLevelW);

        if (!NT_SUCCESS(Status) || !lpfnIdentifyCodeAuthzLevelW) {
            //
            // Couldn't get the fn ptr. Make sure we won't try again
            //
AdvapiLoadFailure:
            LdrUnloadDll(TempModuleHandle);
            AdvApi32ModuleHandle = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler2;
        }

        Status = LdrGetProcedureAddress(
                TempModuleHandle,
                (PANSI_STRING) &ProcedureNameCompute,
                0,
                (PVOID*)&lpfnComputeAccessTokenFromCodeAuthzLevel);

        if (!NT_SUCCESS(Status) ||
            !lpfnComputeAccessTokenFromCodeAuthzLevel) {
            goto AdvapiLoadFailure;
        }

        Status = LdrGetProcedureAddress(
                TempModuleHandle,
                (PANSI_STRING) &ProcedureNameClose,
                0,
                (PVOID*)&lpfnCloseCodeAuthzLevel);

        if (!NT_SUCCESS(Status) || !lpfnCloseCodeAuthzLevel) {
            goto AdvapiLoadFailure;
        }

        Status = LdrGetProcedureAddress(
                TempModuleHandle,
                (PANSI_STRING) &ProcedureNameLogEntry,
                0,
                (PVOID*)&lpfnCodeAuthzRecordEventLogEntry);

        if (!NT_SUCCESS(Status) || !lpfnCodeAuthzRecordEventLogEntry) {
            goto AdvapiLoadFailure;
        }

        AdvApi32ModuleHandle = TempModuleHandle;

    }



    //
    // Prepare the code properties struct.
    //
    
    RtlZeroMemory(&codeproperties, sizeof(codeproperties));
    codeproperties.cbSize = sizeof(codeproperties);
    codeproperties.dwCheckFlags =
            (SAFER_CRITERIA_IMAGEPATH | SAFER_CRITERIA_IMAGEHASH | dwSaferAuthenticodeFlag);
    codeproperties.ImagePath = lpApplicationName;
    codeproperties.dwWVTUIChoice = WTD_UI_NONE;  //harmless if AUTHZCRITERIA_AUTHENTICODE is not passed in
    codeproperties.hImageFileHandle = FileImageHandle;

    //
    // Ask the system to find the Authorization Level that classifies it.
    //
    ASSERT(lpfnIdentifyCodeAuthzLevelW != NULL);
    if (lpfnIdentifyCodeAuthzLevelW(
                                   1,                      // 1 structure
                                   &codeproperties,        // details to identify
                                   &hAuthzLevel,           // Safer level
                                   NULL)) {                  // reserved.
        // We found an Authorization Level applicable to this application.
        HANDLE hRestrictedToken = NULL;
        DWORD dwSaferFlags = 0;
        HANDLE hActualJobObject = NULL;
        DWORD dwJobMemberLevel = 0;


        //
        // Generate the Restricted Token that we will use.
        //
        ASSERT(lpfnComputeAccessTokenFromCodeAuthzLevel != NULL);
        if (!lpfnComputeAccessTokenFromCodeAuthzLevel(
                                                     hAuthzLevel,                // Safer Level
                                                     hEffectiveToken,
                                                     &hRestrictedToken,          // target token
                                                     SAFER_TOKEN_NULL_IF_EQUAL |  // flags
                                                     SAFER_TOKEN_WANT_FLAGS,
                                                     &dwSaferFlags)) {             // reserved
            DWORD dwLastError = GetLastError();
            ASSERT(lpfnCloseCodeAuthzLevel != NULL);
            if (dwLastError == ERROR_ACCESS_DISABLED_BY_POLICY) {
                lpfnCodeAuthzRecordEventLogEntry(
                                                hAuthzLevel, lpApplicationName, NULL);
                Status = -1;
            } else {
                Status = STATUS_ACCESS_DENIED;
            }
            lpfnCloseCodeAuthzLevel(hAuthzLevel);
            goto ExitHandler2;
        }

        ASSERT(lpfnCloseCodeAuthzLevel != NULL);
        lpfnCloseCodeAuthzLevel(hAuthzLevel);


        //
        // If the identified Authorization Level needs to be run
        // within an isolation Job Object, then do the Job setup.
        //
        if ((dwSaferFlags & SAFER_POLICY_JOBID_MASK) != 0) {
            JOB_SET_ARRAY jobsetarray[2];
            DWORD dwNumJobSetMembers = 0;


            //
            // Verify that the job member level is one that we support.
            //
            dwJobMemberLevel = (dwSaferFlags & SAFER_POLICY_JOBID_MASK);
            if (dwJobMemberLevel != SAFER_POLICY_JOBID_UNTRUSTED &&
                dwJobMemberLevel != SAFER_POLICY_JOBID_CONSTRAINED) {
                NtClose(hRestrictedToken);
                Status = STATUS_ACCESS_DENIED;
                goto ExitHandler2;
            }



            Status = NtIsProcessInJob(GetCurrentProcess(), NULL);
            if (Status == STATUS_PROCESS_IN_JOB) {
                //
                // The parent process is already within a job, so
                // we will assume that its job is one of the WinSafer
                // jobs and is thus within a WinSafer "jobset" and
                // that NtCreateProcessEx can directly transition to it.
                //
                *phAssignmentJob = NULL;

            } else if (Status == STATUS_PROCESS_NOT_IN_JOB) {
                //
                // The parent process is not in any job (nor jobset)
                // so we must create all of the Jobs and place then
                // within a new Jobset.
                //

                //if (dwJobMemberLevel >= AUTHZPOL_SAFERFLAGS_JOBID_UNTRUSTED)
                {
                    HANDLE hThisJobObject;
                    JOBOBJECT_BASIC_UI_RESTRICTIONS RestrictUI;

                    Status = NtCreateJobObject(
                                              &hThisJobObject,
                                              JOB_OBJECT_ALL_ACCESS,
                                              NULL);
                    if (!NT_SUCCESS(Status)) {
                        goto JobCreationFailure;
                    }
                    RestrictUI.UIRestrictionsClass =
                    JOB_OBJECT_UILIMIT_DESKTOP |
                    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS |
                    JOB_OBJECT_UILIMIT_EXITWINDOWS |
                    JOB_OBJECT_UILIMIT_GLOBALATOMS |
                    JOB_OBJECT_UILIMIT_HANDLES |
                    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS;
                    if (!SetInformationJobObject(
                                                hThisJobObject,
                                                JobObjectBasicUIRestrictions,
                                                &RestrictUI,
                                                sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS))) {
                        NtClose(hThisJobObject);
                        Status = STATUS_ACCESS_DENIED;
                        goto JobCreationFailure;
                    }
                    jobsetarray[dwNumJobSetMembers].MemberLevel =
                    SAFER_POLICY_JOBID_UNTRUSTED;
                    jobsetarray[dwNumJobSetMembers].Flags = 0;
                    jobsetarray[dwNumJobSetMembers].JobHandle = hThisJobObject;
                    dwNumJobSetMembers++;
                    if (dwJobMemberLevel == SAFER_POLICY_JOBID_UNTRUSTED) {
                        hActualJobObject = hThisJobObject;
                    }
                }


                //if (dwJobMemberLevel >= AUTHZPOL_SAFERFLAGS_JOBID_CONSTRAINED)
                {
                    HANDLE hThisJobObject;
                    JOBOBJECT_BASIC_UI_RESTRICTIONS RestrictUI;

                    Status = NtCreateJobObject(
                                              &hThisJobObject,
                                              JOB_OBJECT_ALL_ACCESS,
                                              NULL);
                    if (!NT_SUCCESS(Status)) {
                        goto JobCreationFailure;
                    }
                    RestrictUI.UIRestrictionsClass =
                    JOB_OBJECT_UILIMIT_DESKTOP |
                    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS |
                    JOB_OBJECT_UILIMIT_EXITWINDOWS |
                    JOB_OBJECT_UILIMIT_GLOBALATOMS |
                    JOB_OBJECT_UILIMIT_HANDLES |
                    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS;
                    if (!SetInformationJobObject(
                                                hThisJobObject,
                                                JobObjectBasicUIRestrictions,
                                                &RestrictUI,
                                                sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS))) {
                        NtClose(hThisJobObject);
                        Status = STATUS_ACCESS_DENIED;
                        goto JobCreationFailure;
                    }
                    jobsetarray[dwNumJobSetMembers].MemberLevel =
                    SAFER_POLICY_JOBID_CONSTRAINED;
                    jobsetarray[dwNumJobSetMembers].Flags = 0;
                    jobsetarray[dwNumJobSetMembers].JobHandle = hThisJobObject;
                    dwNumJobSetMembers++;
                    if (dwJobMemberLevel == SAFER_POLICY_JOBID_CONSTRAINED) {
                        hActualJobObject = hThisJobObject;
                    }
                }


                //
                // Create the Job Set that will hold all of the Job Objects.
                //
                ASSERT(dwNumJobSetMembers > 1 &&
                       dwNumJobSetMembers <= sizeof(jobsetarray) / sizeof(jobsetarray[0]));
                ASSERT(hActualJobObject != NULL);
                Status = NtCreateJobSet(dwNumJobSetMembers, jobsetarray, 0);
                if (!NT_SUCCESS(Status)) {
                    JobCreationFailure:
                    for (; dwNumJobSetMembers > 0; dwNumJobSetMembers--) {
                        NtClose(jobsetarray[dwNumJobSetMembers - 1].JobHandle);
                    }
                    NtClose(hRestrictedToken);
                    goto ExitHandler2;
                }

                //
                // Close all Job Handles except the one that we are returning.
                //
                for (; dwNumJobSetMembers > 0; dwNumJobSetMembers--) {
                    if (jobsetarray[dwNumJobSetMembers - 1].JobHandle != hActualJobObject)
                        NtClose(jobsetarray[dwNumJobSetMembers - 1].JobHandle);
                }

                dwJobMemberLevel = 0;
            } else if (!NT_SUCCESS(Status)) {
                // Some other failure.
                goto ExitHandler2;
            } else {
                Status = STATUS_UNSUCCESSFUL;
                goto ExitHandler2;
            }
        }


        //
        // Pass back the restricted token, and the Job handle/level.
        //
        ASSERTMSG("Only one may be specified (job handle or job member)\n",
                  hActualJobObject == NULL || dwJobMemberLevel == 0);
        *phRestrictedToken = hRestrictedToken;
        *phAssignmentJob = hActualJobObject;
        *pdwJobMemberLevel = dwJobMemberLevel;
        Status = STATUS_SUCCESS;

    } else {
        //
        // Failed to identify an Authorization Level for this
        // application so it will run without restrictions.
        //
        *phRestrictedToken = NULL;
        *phAssignmentJob = NULL;
        *pdwJobMemberLevel = 0;
        Status = STATUS_SUCCESS;
    }

ExitHandler2:
    if (hProcessToken != NULL)
    {
        NtClose(hProcessToken);
    }

ExitHandler:

    RtlLeaveCriticalSection(&gcsAppCert);

    return Status;
}



NTSTATUS
BasepReplaceProcessThreadTokens(
    IN HANDLE       NewTokenHandle,
    IN HANDLE       ProcessHandle,
    IN HANDLE       ThreadHandle
    )
{
    typedef BOOL (WINAPI *CodeAuthzReplaceProcessThreadTokensT) (
        IN HANDLE       NewTokenHandle,
        IN HANDLE       ProcessHandle,
        IN HANDLE       ThreadHandle);

    NTSTATUS Status;
    static const ANSI_STRING ProcedureNameReplaceTokens =
            RTL_CONSTANT_STRING("SaferiReplaceProcessThreadTokens");
    static CodeAuthzReplaceProcessThreadTokensT
            lpfnCodeAuthzReplaceProcessThreadTokens = NULL;


    //
    // Enter a critical section for the entire trust evalation.
    // (We borrow the critical section used by AppCert).
    //
    RtlEnterCriticalSection(&gcsAppCert);


    //
    // Get a pointer to our private function in ADVAPI32.DLL.
    //
    if (!lpfnCodeAuthzReplaceProcessThreadTokens) {

        if (!AdvApi32ModuleHandle ||
            AdvApi32ModuleHandle == LongToHandle(-1) ||
            AdvApi32ModuleHandle == LongToHandle(-2))
        {
            // ADVAPI32 has not been loaded yet, or it was loaded
            // but we already failed to get one of our entrypoints.
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler;
        }


        Status = LdrGetProcedureAddress(
                AdvApi32ModuleHandle,
                (PANSI_STRING) &ProcedureNameReplaceTokens,
                0,
                (PVOID*)&lpfnCodeAuthzReplaceProcessThreadTokens);

        if (!NT_SUCCESS(Status) ||
            !lpfnCodeAuthzReplaceProcessThreadTokens) {
            //
            // Couldn't get the fn ptr. Make sure we won't try again
            //
            LdrUnloadDll(AdvApi32ModuleHandle);
            AdvApi32ModuleHandle = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler;
        }
    }


    //
    // Actually call the function and return the results.
    //
    ASSERT(lpfnCodeAuthzReplaceProcessThreadTokens != NULL);
    if (!lpfnCodeAuthzReplaceProcessThreadTokens(
                    NewTokenHandle,
                    ProcessHandle,
                    ThreadHandle)) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        Status = STATUS_SUCCESS;
    }

ExitHandler:
    RtlLeaveCriticalSection(&gcsAppCert);
    return Status;
}





#if defined(_WIN64) || defined(BUILD_WOW6432)
BOOL
NtVdm64CreateProcess(
    BOOL fPrefixMappedApplicationName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
#endif

#define PRIORITY_CLASS_MASK (NORMAL_PRIORITY_CLASS|IDLE_PRIORITY_CLASS|                 \
                             HIGH_PRIORITY_CLASS|REALTIME_PRIORITY_CLASS|               \
                             BELOW_NORMAL_PRIORITY_CLASS|ABOVE_NORMAL_PRIORITY_CLASS)

BOOL
WINAPI
CreateProcessInternalW(
    HANDLE hUserToken,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation,
    PHANDLE hRestrictedUserToken
    )

/*++

Routine Description:

    This is the worker routine for CreateProcess and CreateProcessAsUser.
    CreateProcessAsUser supplies a User token to be stamped on the new process.
    CreateProcess supplies NULL and the current process token is used.

    A process and thread object are created and a handle opened to each
    object using CreateProcessInternal.  Note that WinExec and LoadModule are
    still supported, but are implemented as a call to CreateProcess.

Arguments:

    hUserToken - Supplies an optional token handle to be set on the new process.
        Process token is used is this parameter is NULL.

    lpApplicationName - Supplies an optional pointer to a null terminated
        character string that contains the name of the image file to
        execute.  This is a fully qualified DOS path name.  If not
        specified, then the image file name is the first whitespace
        delimited token on the command line.

    lpCommandLine - Supplies a null terminated character string that
        contains the command line for the application to be executed.
        The entire command line is made available to the new process
        using GetCommandLine.  If the lpApplicationName parameter was
        not specified, then the first token of the command line
        specifies file name of the application (note that this token
        begins at the beginning of the command line and ends at the
        first "white space" character).  If the file name does not
        contain an extension (the presence of a "."), then .EXE is
        assumed.  If the file name does not contain a directory path,
        Windows will search for the executable file in:

          - The current directory

          - The windows directory

          - The windows system directory

          - The directories listed in the path environment variable

        This parameter is optional onlu if the lpApplicationName
        parameter is specified.  In this case the command line the
        application receives will be the application name.

    lpProcessAttributes - An optional parameter that may be used to
        specify the attributes of the new process.  If the parameter is
        not specified, then the process is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation:

        SECURITY_ATTRIBUTES Structure:

        DWORD nLength - Specifies the length of this structure.  Must be
            set to sizeof( SECURITY_ATTRUBUTES ).

        LPVOID lpSecurityDescriptor - Points to a security descriptor for
            the object (must be NULL for Win32, used on NT/Win32). The
            security descriptor controls the sharing of an object.

        BOOL bInheritHandle - Supplies a flag that indicates whether
            or not the returned handle is to be inherited by a new
            process during process creation.  A value of TRUE
            indicates that the new process will inherit the handle.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on
        process creation.

    dwCreationFlags - Supplies additional flags that control the creation
        of the process.

        dwCreationFlags Flags:

        DEBUG_PROCESS - If this flag bit is set, then the creating
            process is treated as a debugger, and the process being
            created is created as a debugee.  All debug events occuring
            in the debugee are reported to the debugger.  If this bit is
            clear, but the calling process is a debugee, then the
            process becomes a debugee of the calling processes debugger.
            If this bit is clear and the calling processes is not a
            debugee then no debug related actions occur.

        DEBUG_ONLY_THIS_PROCESS - If this flag is set, then the
            DEBUG_PROCESS flag bit must also be set.  The calling
            process is is treated as a debugger, and the new process is
            created as its debuggee.  If the new process creates
            additional processes, no debug related activities (with
            respect to the debugger) occur.

        CREATE_SUSPENDED - The process is created, but the initial thread
            of the process remains suspended. The creator can resume this
            thread using ResumeThread. Until this is done, code in the
            process will not execute.

        CREATE_UNICODE_ENVIRONMENT - If set, the environment pointer
            points to a Unicode environment block.  Otherwise, the
            block is ANSI (actually OEM.)

    bInheritHandles - Supplies a flag that specifies whether or not the
        new process is to inherit handles to objects visible to the
        calling process.  A value of TRUE causes handles to be inherited
        by the new process.  If TRUE was specified, then for each handle
        visible to the calling process, if the handle was created with
        the inherit handle option, the handle is inherited to the new
        process.  The handle has the same granted access in the new
        process as it has in the calling process, and the value of the
        handle is the same.

    lpEnvironment - An optional parameter, that if specified, supplies a
        pointer to an environment block.  If the parameter is not
        specified, the environment block of the current process is used.
        This environment block is made available to the new process
        using GetEnvironmentStrings.

    lpCurrentDirectory - An optional parameter, that if specified,
        supplies a string representing the current drive and directory
        for the new process.  The string must be a fully qualified
        pathname that includes a drive letter.  If the parameter is not
        specified, then the new process is created with the same current
        drive and directory as the calling process.  This option is
        provided primarily for shells that want to start an application
        and specify its initial drive and working directory.

    lpStartupInfo - Supplies information that specified how the
        applications window is to be shown. This structure is described
        in the Win32 User Interface API Book.

    lpProcessInformation - Returns identification information about the
        new process.

    PROCESS_INFORMATION Structure:

        HANDLE hProcess - Returns a handle to the newly created process.
            Through the handle, all operations on process objects are
            allowed.

        HANDLE hThread - Returns a handle to the newly created thread.
            Through the handle, all operations on thread objects are
            allowed.

        DWORD dwProcessId - Returns a global process id that may be used
            to identify a process.  The value is valid from the time the
            process is created until the time the process is terminated.

        DWORD dwThreadId - Returns a global thread id that may be used
            to identify a thread.  The value is valid from the time the
            thread is created until the time the thread is terminated.

    hRestrictedUserToken - Returns a restricted token if a UsetToken was
        supplied. This is applicable for the CreateProcessAsUser case.
        The token is released by CreateProcessAsUser.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE ProcessHandle, ThreadHandle, VdmWaitHandle = NULL;
    HANDLE FileHandle, SectionHandle;
    CLIENT_ID ClientId;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    LPWSTR NameBuffer;
    LPWSTR WhiteScan;
    ULONG Length,i;
    PROCESS_BASIC_INFORMATION ProcessInfo;
    SECTION_IMAGE_INFORMATION ImageInformation;
    NTSTATUS StackStatus;
    BOOLEAN bStatus;
    INITIAL_TEB InitialTeb;
    CONTEXT ThreadContext;
    PPEB Peb;
    BASE_API_MSG m;
    PBASE_CREATEPROCESS_MSG a = &m.u.CreateProcess;
    PBASE_CHECKVDM_MSG b = &m.u.CheckVDM;
    PWCH TempNull = NULL;
    WCHAR TempChar;
    UNICODE_STRING VdmNameString;
    PVOID BaseAddress;
    ULONG VdmReserve;
    SIZE_T BigVdmReserve;
    ULONG iTask=0;
    LPWSTR CurdirBuffer, CurdirFilePart;
    DWORD CurdirLength,CurdirLength2;
    ULONG VDMCreationState=0;
    ULONG VdmBinaryType = 0;
    BOOL  bMeowBinary = FALSE;
    UNICODE_STRING  SubSysCommandLine;
    PIMAGE_NT_HEADERS NtHeaders;
    DWORD dwNoWindow = (dwCreationFlags & CREATE_NO_WINDOW);
    ANSI_STRING AnsiStringVDMEnv;
    UNICODE_STRING UnicodeStringVDMEnv;
    WCHAR ImageFileDebuggerCommand[ MAX_PATH ];
    LPWSTR QuotedBuffer;
    BOOLEAN QuoteInsert;
    BOOLEAN QuoteCmdLine = FALSE;
    BOOLEAN QuoteFound;
    BOOL bSaferChecksNeeded = FALSE;
    BOOLEAN SearchRetry;
    BOOLEAN IsWowBinary = FALSE;
    STARTUPINFOW StartupInfo;
    DWORD LastError;
    DWORD fileattr;
    PROCESS_PRIORITY_CLASS PriClass;
    PVOID State;
    HANDLE DebugPortHandle = NULL;
    PVOID pAppCompatDataTemp;
    PVOID pAppCompatData  = NULL;
    DWORD cbAppCompatData = 0;    // for the future
    BOOLEAN bVdmRetry = FALSE;
    DWORD Flags;
    PVOID pAppCompatSxsData = NULL;
    DWORD cbAppCompatSxsData = 0;
    SXS_OVERRIDE_STREAM AppCompatSxsManifest;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
    SIZE_T SxsConglomeratedBufferSizeBytes;
    PBYTE SxsConglomeratedByteBuffer = NULL; // this contains all the of the below in one large right-sized heap allocation
                            // if we compute its size wrong, other code (if it gets it right..) should
                            // do more heap allocation
    ULONG sxsi; // for loop counter
    RTL_UNICODE_STRING_BUFFER SxsWin32ManifestPathBuffer;
    RTL_UNICODE_STRING_BUFFER SxsWin32PolicyPathBuffer;
    RTL_UNICODE_STRING_BUFFER SxsWin32AssemblyDirectoryBuffer;
    RTL_UNICODE_STRING_BUFFER SxsNtManifestPathBuffer;
    RTL_UNICODE_STRING_BUFFER SxsNtPolicyPathBuffer;
    const PRTL_UNICODE_STRING_BUFFER SxsStringBuffers[] = {
        // The order here does not matter.
        &SxsWin32ManifestPathBuffer,
        &SxsWin32PolicyPathBuffer,
        &SxsWin32AssemblyDirectoryBuffer,
        &SxsNtManifestPathBuffer,
        &SxsNtPolicyPathBuffer
    };
    UNICODE_STRING SxsWin32ExePath;
    UNICODE_STRING SxsNtExePath;
    BASE_MSG_SXS_HANDLES SxsExeHandles = {0};
    BASE_MSG_SXS_HANDLES SxsManifestFileHandles = {0};
    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR SxsExePathPair = { &SxsWin32ExePath, &SxsNtExePath };
    CONST SXS_WIN32_NT_PATH_PAIR SxsManifestPathPair = { &SxsWin32ManifestPathBuffer, &SxsNtManifestPathBuffer };
    CONST SXS_WIN32_NT_PATH_PAIR SxsPolicyPathPair = { &SxsWin32PolicyPathBuffer, &SxsNtPolicyPathBuffer };
    BASE_MSG_SXS_HANDLES SxsPolicyHandles = {0};
    PWSTR ExePathFullBuffer = NULL;

    DWORD dwJobMemberLevel = 0;
    HANDLE hSaferAssignmentJob = NULL;
    HANDLE hSaferRestrictedToken = NULL;

    DWORD dwBasePushProcessParametersFlags = 0;

#if defined(BUILD_WOW6432) || defined(_WIN64)
    BOOLEAN ComPlusILImage;
    LPCWSTR lpOriginalApplicationName = lpApplicationName;
    LPWSTR lpOriginalCommandLine = lpCommandLine;
#endif

#if defined(WX86)
    HANDLE Wx86Info = NULL;
#endif

#if defined WX86
    BOOLEAN UseKnownWx86Dll;
    UseKnownWx86Dll = NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll;
    NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
#endif

    RtlZeroMemory(&a->Sxs, sizeof(a->Sxs));
    RtlZeroMemory(lpProcessInformation,sizeof(*lpProcessInformation));

    if (ARGUMENT_PRESENT( hRestrictedUserToken )) {
        *hRestrictedUserToken = NULL;
        }

    // Private VDM flag should be ignored; Its meant for internal use only.
    dwCreationFlags &= (ULONG)~CREATE_NO_WINDOW;

    if ((dwCreationFlags & (DETACHED_PROCESS | CREATE_NEW_CONSOLE)) ==
        (DETACHED_PROCESS | CREATE_NEW_CONSOLE)) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    AnsiStringVDMEnv.Buffer = NULL;
    UnicodeStringVDMEnv.Buffer = NULL;

    //
    // the lowest specified priority class is used.
    //

    if (dwCreationFlags & IDLE_PRIORITY_CLASS ) {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_IDLE;
        }
    else if (dwCreationFlags & BELOW_NORMAL_PRIORITY_CLASS ) {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_BELOW_NORMAL;
        }
    else if (dwCreationFlags & NORMAL_PRIORITY_CLASS ) {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;
        }
    else if (dwCreationFlags & ABOVE_NORMAL_PRIORITY_CLASS ) {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_ABOVE_NORMAL;
        }
    else if (dwCreationFlags & HIGH_PRIORITY_CLASS ) {
        PriClass.PriorityClass =  PROCESS_PRIORITY_CLASS_HIGH;
        }
    else if (dwCreationFlags & REALTIME_PRIORITY_CLASS ) {
        if ( BasepIsRealtimeAllowed(FALSE) ) {
            PriClass.PriorityClass =  PROCESS_PRIORITY_CLASS_REALTIME;
            }
        else {
            PriClass.PriorityClass =  PROCESS_PRIORITY_CLASS_HIGH;
            }
        }
    else {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_UNKNOWN;
        }
    PriClass.Foreground = FALSE;

    dwCreationFlags = (dwCreationFlags & ~PRIORITY_CLASS_MASK );

    //
    // Default separate/shared VDM option if not explicitly specified.
    //

    if (dwCreationFlags & CREATE_SEPARATE_WOW_VDM) {
        if (dwCreationFlags & CREATE_SHARED_WOW_VDM) {
            SetLastError(ERROR_INVALID_PARAMETER);

            return FALSE;
            }
        }
    else
    if ((dwCreationFlags & CREATE_SHARED_WOW_VDM) == 0) {
        if (BaseStaticServerData->DefaultSeparateVDM) {
            dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
            }
        }

    if ((dwCreationFlags & CREATE_SEPARATE_WOW_VDM) == 0) {
        //
        // If the creator is running inside a job object, always
        // set SEPERATE_WOW_VDM so the VDM is part of the job.
        //
        JOBOBJECT_BASIC_UI_RESTRICTIONS UiRestrictions;

        Status = NtQueryInformationJobObject(NULL,
                                             JobObjectBasicUIRestrictions,
                                             &UiRestrictions,
                                             sizeof(UiRestrictions),
                                             NULL);
        if (Status != STATUS_ACCESS_DENIED) {
            //
            // Anything other than STATUS_ACCESS_DENIED indicates the
            // current process is inside a job.
            //
            dwCreationFlags = (dwCreationFlags & (~CREATE_SHARED_WOW_VDM)) |
                                  CREATE_SEPARATE_WOW_VDM;
            }
        }


    //
    //  If ANSI environment, convert to Unicode
    //

    if (lpEnvironment && !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT) ) {
        PUCHAR s;
        STRING Ansi;
        UNICODE_STRING Unicode;
        MEMORY_BASIC_INFORMATION MemoryInformation;

        Ansi.Buffer = s = lpEnvironment;
        while (*s || *(s+1))            // find end of block
            s++;

        Ansi.Length = (USHORT)(s - Ansi.Buffer) + 1;
        Ansi.MaximumLength = Ansi.Length + 1;
        MemoryInformation.RegionSize = Ansi.MaximumLength * sizeof(WCHAR);
        Unicode.Buffer = NULL;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Unicode.Buffer,
                                          0,
                                          &MemoryInformation.RegionSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);

            return FALSE;
            }

        Unicode.MaximumLength = (USHORT)MemoryInformation.RegionSize;
        Status = RtlAnsiStringToUnicodeString(&Unicode, &Ansi, FALSE);
        if (!NT_SUCCESS(Status) ) {
            NtFreeVirtualMemory( NtCurrentProcess(),
                                 &Unicode.Buffer,
                                 &MemoryInformation.RegionSize,
                                 MEM_RELEASE
                               );
            BaseSetLastNTError(Status);

            return FALSE;
            }
        lpEnvironment = Unicode.Buffer;
        }

    FileHandle = NULL;
    SectionHandle = NULL;
    ProcessHandle = NULL;
    ThreadHandle = NULL;
    FreeBuffer = NULL;
    NameBuffer = NULL;
    VdmNameString.Buffer = NULL;
    BaseAddress = (PVOID)1;
    VdmReserve = 0;
    CurdirBuffer = NULL;
    CurdirFilePart = NULL;
    SubSysCommandLine.Buffer = NULL;
    QuoteFound = FALSE;
    QuoteInsert = FALSE;
    QuotedBuffer = NULL;

    try {

        //
        // Make a copy of the startup info so we can change it.
        //

        StartupInfo = *lpStartupInfo;

        //
        // STARTF_USEHOTKEY means hStdInput is really the hotkey value.
        // STARTF_HASSHELLDATA means std handles are used for shell-private
        // data.  This flag is used if an icon is passed to ShellExecuteEx.
        // As a result they cannot be specified with STARTF_USESTDHANDLES.
        // Consistent with Win95, USESTDHANDLES is ignored.
        //

        if (StartupInfo.dwFlags & STARTF_USESTDHANDLES &&
            StartupInfo.dwFlags & (STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {

            StartupInfo.dwFlags &= ~STARTF_USESTDHANDLES;
            }

VdmRetry:
        //
        // None of this cleanup/reinit occurs for launching a Win32 or Win64 .exe,
        // but they generally do occur for launching 16bit, .bat, etc.
        //
        if (NameBuffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, NameBuffer);
            NameBuffer = NULL;
        }
        if (FreeBuffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
            FreeBuffer = NULL;
        }
        if (FileHandle) {
            NtClose(FileHandle);
            FileHandle = NULL;
        }

        LastError = 0;
        SearchRetry = TRUE;
        QuoteInsert = FALSE;
        QuoteCmdLine = FALSE;
        if (!ARGUMENT_PRESENT( lpApplicationName )) {

            //
            // Locate the image
            //

            // forgot to free NameBuffer before goto VdmRetry???
            ASSERT(NameBuffer == NULL);

            NameBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                          MAKE_TAG( TMP_TAG ),
                                          MAX_PATH * sizeof( WCHAR ));
            if ( !NameBuffer ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                return FALSE;
                }
            lpApplicationName = lpCommandLine;
            TempNull = (PWCH)lpApplicationName;
            WhiteScan = (LPWSTR)lpApplicationName;

            //
            // check for lead quote
            //
            if ( *WhiteScan == L'\"' ) {
                SearchRetry = FALSE;
                WhiteScan++;
                lpApplicationName = WhiteScan;
                while(*WhiteScan) {
                    if ( *WhiteScan == (WCHAR)'\"' ) {
                        TempNull = (PWCH)WhiteScan;
                        QuoteFound = TRUE;
                        break;
                        }
                    WhiteScan++;
                    TempNull = (PWCH)WhiteScan;
                    }
                }
            else {
retrywsscan:
                lpApplicationName = lpCommandLine;
                while(*WhiteScan) {
                    if ( *WhiteScan == (WCHAR)' ' ||
                         *WhiteScan == (WCHAR)'\t' ) {
                        TempNull = (PWCH)WhiteScan;
                        break;
                        }
                    WhiteScan++;
                    TempNull = (PWCH)WhiteScan;
                    }
                }
            TempChar = *TempNull;
            *TempNull = UNICODE_NULL;

#ifdef WX86

            //
            // Wx86 applications must use x86 version of known exes
            // for compatibility.
            //

            if (UseKnownWx86Dll) {
               LPWSTR KnownName;

               NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;

               KnownName = BasepWx86KnownExe(lpApplicationName);
               if (KnownName) {
                  lpApplicationName = KnownName;
                  }
               }
#endif


            Length = SearchPathW(
                        NULL,
                        lpApplicationName,
                        L".exe",
                        MAX_PATH,
                        NameBuffer,
                        NULL
                        )*2;

            if (Length != 0 && Length < MAX_PATH * sizeof( WCHAR )) {
                //
                // SearchPathW worked, but file might be a directory
                // if this happens, we need to keep trying
                //
                fileattr = GetFileAttributesW(NameBuffer);
                if ( fileattr != 0xffffffff &&
                     (fileattr & FILE_ATTRIBUTE_DIRECTORY) ) {
                    Length = 0;
                } else {
                    Length++;
                    Length++;
                }
            }

            if ( !Length || Length >= MAX_PATH<<1 ) {

                //
                // If we search pathed, then return file not found.
                // otherwise, try to be more specific.
                //
                RTL_PATH_TYPE PathType;
                HANDLE hFile;

                PathType = RtlDetermineDosPathNameType_U(lpApplicationName);
                if ( PathType != RtlPathTypeRelative ) {

                    //
                    // The failed open should set get last error properly.
                    //

                    hFile = CreateFileW(
                                lpApplicationName,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );
                    if ( hFile != INVALID_HANDLE_VALUE ) {
                        CloseHandle(hFile);
                        BaseSetLastNTError(STATUS_OBJECT_NAME_NOT_FOUND);
                        }
                    }
                else {
                    BaseSetLastNTError(STATUS_OBJECT_NAME_NOT_FOUND);
                    }

                //
                // remember initial last error value for the retry scan path
                //

                if ( LastError ) {
                    SetLastError(LastError);
                    }
                else {
                    LastError = GetLastError();
                    }

                //
                // restore the command line
                //

                *TempNull = TempChar;
                lpApplicationName = NameBuffer;

                //
                // If we still have command line left, then keep going
                // the point is to march through the command line looking
                // for whitespace so we can try to find an image name
                // launches of things like:
                // c:\word 95\winword.exe /embedding -automation
                // require this. Our first iteration will stop at c:\word, our next
                // will stop at c:\word 95\winword.exe
                //
                if (*WhiteScan && SearchRetry) {
                    WhiteScan++;
                    TempNull = WhiteScan;
                    QuoteInsert = TRUE;
                    QuoteFound = TRUE;
                    goto retrywsscan;
                }

                return FALSE;
                }
            //
            // restore the command line
            //

            *TempNull = TempChar;
            lpApplicationName = NameBuffer;

            //
            // check whether it is setup.exe started by winlogon.exe
            //
            if (BasepIsSetupInvokedByWinLogon(lpApplicationName))
            {
                // validate the flag 
                if (!(dwCreationFlags & CREATE_IGNORE_SYSTEM_DEFAULT))
                {
                    //
                    // BUGBUBGUBGUBUGBUGBUGUBGBUGUBGUB
                    //    Winlogon does not set the flag correctly
                    //    in phase1, ignore it(now)
                    //    in phase2, ASSERT it
                    // BUGBUBGUBGUBUGBUGBUGUBGBUGUBGUB
                    //
                    dwCreationFlags |= CREATE_IGNORE_SYSTEM_DEFAULT;
                }
            }
            
        }
        else
        if (!ARGUMENT_PRESENT( lpCommandLine ) || *lpCommandLine == UNICODE_NULL ) {
            QuoteCmdLine = TRUE;
            lpCommandLine = (LPWSTR)lpApplicationName;
            }


#ifdef WX86

       //
       // Wx86 applications must use x86 version of known exes
       // for compatibility.
       //

       if (UseKnownWx86Dll) {
           LPWSTR KnownName;

           NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;

           KnownName = BasepWx86KnownExe(lpApplicationName);
           if (KnownName) {

               RtlFreeHeap(RtlProcessHeap(), 0, NameBuffer);
               NameBuffer = KnownName;
               lpApplicationName = KnownName;
               }
           }

#endif

        //
        // Translate to an NT name.
        //

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpApplicationName,
                                &PathName,
                                NULL,
                                &RelativeName
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);

            return FALSE;
            }

        // forgot to free FreeBuffer before goto VdmRetry????
        ASSERT(FreeBuffer == NULL);
        FreeBuffer = PathName.Buffer;

        RtlInitUnicodeString(&SxsWin32ExePath, lpApplicationName);

        {
            RTL_PATH_TYPE SxsWin32ExePathType = RtlDetermineDosPathNameType_U(lpApplicationName);

            if ((SxsWin32ExePathType != RtlPathTypeDriveAbsolute) &&
                (SxsWin32ExePathType != RtlPathTypeUncAbsolute)) {
                if (ExePathFullBuffer == NULL) {
                    // It seems that with VDM things, we can rerun this code with a new lpApplication, so
                    // we protect against double-allocating the buffer and just allocate a big
                    // MAX_PATH one the first time through, assuming it's good enough for the 2ndary times
                    // too.
                    ExePathFullBuffer = RtlAllocateHeap(RtlProcessHeap(), 0, (MAX_PATH + 1) * sizeof(WCHAR));
                    if (ExePathFullBuffer == NULL) {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return FALSE;
                    }
                }

                RtlGetFullPathName_U(lpApplicationName, (MAX_PATH + 1) * sizeof(WCHAR), ExePathFullBuffer, NULL);

                RtlInitUnicodeString(&SxsWin32ExePath, ExePathFullBuffer);
            }
        }


        SxsNtExePath = PathName;

        if ( RelativeName.RelativeName.Length ) {
            PathName = *(PUNICODE_STRING)&RelativeName.RelativeName;
            }
        else {
            RelativeName.ContainingDirectory = NULL;
            }

        InitializeObjectAttributes(
            &Obja,
            &PathName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );

        //
        // Open the file for red and execute access
        //

        Status = NtOpenFile(
                    &FileHandle,
                    SYNCHRONIZE | FILE_EXECUTE | FILE_READ_ATTRIBUTES | FILE_READ_DATA,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                    );

        if (!NT_SUCCESS(Status) ) {

            //
            // We failed. Open the file for lesser access.
            //

            Status = NtOpenFile(
                        &FileHandle,
                        SYNCHRONIZE | FILE_EXECUTE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );

            if (!NT_SUCCESS(Status) ) {
                //
                // if we failed, see if this is a device. If it is a device,
                // then just return invalid image format
                //

                if ( RtlIsDosDeviceName_U(RTL_CONST_CAST(PWSTR)(lpApplicationName)) ) {
                    SetLastError(ERROR_BAD_DEVICE);
                    }
                else {
                    BaseSetLastNTError(Status);
                    }

                return FALSE;
            }

        }

        //
        // If no desktop has been specified, use the caller's
        // desktop.
        //

        if (StartupInfo.lpDesktop == NULL) {
            StartupInfo.lpDesktop =
                    (LPWSTR)((PRTL_USER_PROCESS_PARAMETERS)NtCurrentPeb()->
                        ProcessParameters)->DesktopInfo.Buffer;
            }

        //
        // Create a section object backed by the file
        //

        Status = NtCreateSection(
                    &SectionHandle,
                    SECTION_ALL_ACCESS,
                    NULL,
                    NULL,
                    PAGE_EXECUTE,
                    SEC_IMAGE,
                    FileHandle
                    );

        //
        // App Certification DLL
        //

        if (NT_SUCCESS(Status)) {
            Status = BasepIsProcessAllowed(lpApplicationName);

            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                NtClose(SectionHandle);
                return FALSE;
            }


       
          //
          // If Meow subsystem is enabled and caller specified CREATE_FORECEDOS for a win32 image
          // push it into the meow subsystem
          //

          if ((dwCreationFlags & CREATE_FORCEDOS) && BaseStaticServerData->ForceDos) {
               dwCreationFlags &= ~(CREATE_SHARED_WOW_VDM | CREATE_FORCEDOS);
               dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
               Status = STATUS_INVALID_IMAGE_WIN_16;
               bMeowBinary = TRUE;

               NtClose(SectionHandle);
               SectionHandle = NULL;
          }


       }

        //
        // check appcompat (aka apphelp)
        //
        // if we are running under debugger, bVdmRetry will be FALSE
        // yet pAppCompatData may have some data (from the app itself)
        // debugger will do a separate CreateProcess on debugee
        //
        // apphelp gets called if it is win32 app or if it is a .bat or .cmd 

       if(!bVdmRetry &&
          (NT_SUCCESS(Status) ||
           (Status == STATUS_INVALID_IMAGE_NOT_MZ && !BaseIsDosApplication(&PathName,Status)))
         ) {
            NTSTATUS BadAppStatus;

            if (NULL != pAppCompatData) {
                RtlFreeHeap(RtlProcessHeap(), 0, pAppCompatData);
                pAppCompatData = NULL;
                }
              
            if (NULL != pAppCompatSxsData) {
                RtlFreeHeap(RtlProcessHeap(), 0, pAppCompatSxsData);
                pAppCompatSxsData = NULL;
                }
             
            //
            // we only check ONCE --
            // the second time around is rather meaningless - to check for posix/ntvdm/os2 emulation
            //
            BadAppStatus = BasepCheckBadapp(FileHandle,
                                            PathName.Buffer,
                                            (WCHAR*)lpEnvironment,
                                            &pAppCompatData,
                                            &cbAppCompatData,
                                            &pAppCompatSxsData,
                                            &cbAppCompatSxsData);
                    
            if (!NT_SUCCESS(BadAppStatus)) {
                if (BadAppStatus == STATUS_ACCESS_DENIED) {
                    SetLastError(ERROR_CANCELLED);
                    }
                else {
                    BaseSetLastNTError(BadAppStatus);
                    }

                if (SectionHandle) {
                    NtClose(SectionHandle);
                    SectionHandle = NULL;
                    }
                return FALSE;
                }
            }

       //
       // Winsafer code
       //
       // If this is the first time then we will have to do Safer checks.
       // Note that we do not impose any restrictions on the interpreter
       // itself since it is part of OS.
       //


       if ((!bVdmRetry) &&
           ( (dwCreationFlags & CREATE_PRESERVE_CODE_AUTHZ_LEVEL) == 0 )) {

           NTSTATUS SaferStatus;

 
           {

               //
               // WinSafer process sandbox restrictions handling.
               // Should be done for non .NET images only.
               //

               SaferStatus = BasepCheckWinSaferRestrictions(
                                                      hUserToken,
                                                      lpApplicationName,   // same as PathName.Buffer
                                                      FileHandle,
                                                      &dwJobMemberLevel,
                                                      &hSaferRestrictedToken,
                                                      &hSaferAssignmentJob);
               if (SaferStatus == -1) {
                   SetLastError(ERROR_ACCESS_DISABLED_BY_POLICY);
                   bStatus =  FALSE;
                   leave;
               } else if (!NT_SUCCESS(SaferStatus)) {
                   BaseSetLastNTError(SaferStatus);
                   bStatus = FALSE;
                   leave;
               }
           }
       }


        if (!NT_SUCCESS(Status)) {
            switch (Status) {
                // 16 bit OS/2 exe
                case STATUS_INVALID_IMAGE_NE_FORMAT:
#if defined(i386) && defined(OS2_SUPPORT_ENABLED)
                //
                // Use OS/2 if x86 (OS/2 not supported on risc),
                //    and CreationFlags don't have forcedos bit
                //    and Registry didn't specify ForceDos
                //
                // else execute as a DOS bound app.
                //
                //

                if (!(dwCreationFlags & CREATE_FORCEDOS) &&
                    !BaseStaticServerData->ForceDos)
                  {

                    if ( !BuildSubSysCommandLine( L"OS2 /P ",
                                                  lpApplicationName,
                                                  lpCommandLine,
                                                  &SubSysCommandLine
                                                ) ) {
                        return FALSE;
                        }

                    lpCommandLine = SubSysCommandLine.Buffer;

                    lpApplicationName = NULL;

                    bVdmRetry = TRUE;
                    goto VdmRetry;
                    }
#endif
                    // Falls into Dos case, so that stub message will be
                    // printed, and bound apps will run w/o OS/2 subsytem

                // Dos .exe or .com

                case STATUS_INVALID_IMAGE_PROTECT:
                case STATUS_INVALID_IMAGE_NOT_MZ:
ForceDos:
                    {
                    ULONG BinarySubType;

                    BinarySubType = BINARY_TYPE_DOS_EXE;
                    if (Status == STATUS_INVALID_IMAGE_PROTECT   ||
                        Status == STATUS_INVALID_IMAGE_NE_FORMAT ||
                       (BinarySubType = BaseIsDosApplication(&PathName,Status)) )
                       {
#if defined(_WIN64) || defined(BUILD_WOW6432)
                        //
                        // If this a DOS application, then we need to pop up a dialog
                        // saying that this an invalid win32 application.
                        //
                        goto RaiseInvalidWin32Error;
#endif
                        VdmBinaryType = BINARY_TYPE_DOS;

                        // create the environment before going to the
                        // server. This was done becuase we want NTVDM
                        // to have the new environment when it gets
                        // created.
                        if (!BaseCreateVDMEnvironment(
                                    lpEnvironment,
                                    &AnsiStringVDMEnv,
                                    &UnicodeStringVDMEnv
                                    )) {
                            return FALSE;
                        }

                        if(!BaseCheckVDM(VdmBinaryType | BinarySubType,
                                         lpApplicationName,
                                         lpCommandLine,
                                         lpCurrentDirectory,
                                         &AnsiStringVDMEnv,
                                         &m,
                                         &iTask,
                                         dwCreationFlags,
                                         &StartupInfo
                                         )) {

                            return FALSE;
                        }

                        // Check the return value from the server
                        switch (b->VDMState & VDM_STATE_MASK) {
                            case VDM_NOT_PRESENT:
                                // mark this so the server can undo
                                // creation if something goes wrong.
                                // We marked it "partially created" because
                                // the NTVDM has yet not been fully created.
                                // a call to UpdateVdmEntry to update
                                // process handle will signal the NTVDM
                                // process completed creation
                                VDMCreationState = VDM_PARTIALLY_CREATED;
                                // fail the call if NTVDM process is being
                                // created DETACHED.
                                // note that, we let it go if NTVDM process
                                // is already running.
                                if (dwCreationFlags & DETACHED_PROCESS) {
                                    SetLastError(ERROR_ACCESS_DENIED);
                                    return FALSE;
                                    }
                                if (!BaseGetVdmConfigInfo(lpCommandLine,
                                                          iTask,
                                                          VdmBinaryType,
                                                          &VdmNameString,
                                                          &VdmReserve)) {
                                    BaseSetLastNTError(Status);
                                    return FALSE;
                                    }

                                lpCommandLine = VdmNameString.Buffer;
                                lpApplicationName = NULL;

                                break;

                            case VDM_PRESENT_NOT_READY:
                                SetLastError (ERROR_NOT_READY);
                                return FALSE;

                            case VDM_PRESENT_AND_READY:
                                VDMCreationState = VDM_BEING_REUSED;
                                VdmWaitHandle = b->WaitObjectForParent;
                                break;
                            }
                         VdmReserve--;               // we reserve from addr 1
                         if(VdmWaitHandle)
                            goto VdmExists;
                         else{
                            bInheritHandles = FALSE;
                            if (lpEnvironment &&
                                !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT)){
                                RtlDestroyEnvironment(lpEnvironment);
                                }
                            lpEnvironment = UnicodeStringVDMEnv.Buffer;
                            bVdmRetry = TRUE;
                            goto VdmRetry;
                            }
                        }
                    else {

                        //
                        //  must be a .bat or .cmd file
                        //

                        static PWCHAR CmdPrefix = L"cmd /c ";
                        PWCHAR NewCommandLine;
                        ULONG Length;
                        PWCHAR Last4 = &PathName.Buffer[PathName.Length / sizeof( WCHAR )-4];

                        if ( PathName.Length < 8 ) {
                            SetLastError(ERROR_BAD_EXE_FORMAT);
                            return FALSE;
                            }

                        if (_wcsnicmp( Last4, L".bat", 4 ) && _wcsnicmp( Last4, L".cmd", 4 )) {
                            SetLastError(ERROR_BAD_EXE_FORMAT);
                            return FALSE;
                        }

                        Length = wcslen( CmdPrefix )
                                 + (QuoteCmdLine || QuoteFound )
                                 + wcslen( lpCommandLine )
                                 + (QuoteCmdLine || QuoteFound)
                                 + 1;

                        NewCommandLine = RtlAllocateHeap( RtlProcessHeap( ),
                                                          MAKE_TAG( TMP_TAG ),
                                                          Length * sizeof( WCHAR ) );

                        if (NewCommandLine == NULL) {
                            BaseSetLastNTError(STATUS_NO_MEMORY);
                            return FALSE;
                        }

                        wcscpy( NewCommandLine, CmdPrefix );
                        if (QuoteCmdLine || QuoteFound) {
                            wcscat( NewCommandLine, L"\"" );
                        }
                        wcscat( NewCommandLine, lpCommandLine );
                        if (QuoteCmdLine || QuoteFound) {
                            wcscat( NewCommandLine, L"\"" );
                        }

                        RtlInitUnicodeString( &SubSysCommandLine, NewCommandLine );

                        lpCommandLine = SubSysCommandLine.Buffer;

                        lpApplicationName = NULL;

                        bVdmRetry = TRUE;
                        goto VdmRetry;

                        }

                    }

                // 16 bit windows exe
                case STATUS_INVALID_IMAGE_WIN_16:
#if defined(BUILD_WOW6432) || defined(_WIN64)
                   if (lpOriginalApplicationName == NULL) {
                       // pass in the part of the command line after the exe name
                       // including whitespace
                       lpCommandLine = ((*TempNull == '\"') ? TempNull + 1 : TempNull);
                   } else {
                       lpCommandLine = lpOriginalCommandLine;
                   }

                   return NtVdm64CreateProcess(lpOriginalApplicationName == NULL,
                                               lpApplicationName,             // this is now the real file name we've loaded
                                               lpCommandLine,
                                               lpProcessAttributes,
                                               lpThreadAttributes,
                                               bInheritHandles,
                                               (dwCreationFlags & ~CREATE_UNICODE_ENVIRONMENT),  // the environment has already been converted to unicode
                                               lpEnvironment,
                                               lpCurrentDirectory,
                                               lpStartupInfo,
                                               lpProcessInformation
                                               );
#endif
                   if (dwCreationFlags & CREATE_FORCEDOS) {
                       goto ForceDos;
                       }

                    IsWowBinary = TRUE;
                    if (!BaseCreateVDMEnvironment(lpEnvironment,
                                                  &AnsiStringVDMEnv,
                                                  &UnicodeStringVDMEnv)) {
                        return FALSE;
                        }

RetrySepWow:
                    VdmBinaryType = dwCreationFlags & CREATE_SEPARATE_WOW_VDM
                                     ? BINARY_TYPE_SEPWOW : BINARY_TYPE_WIN16;

                    if (!BaseCheckVDM(VdmBinaryType,
                                      lpApplicationName,
                                      lpCommandLine,
                                      lpCurrentDirectory,
                                      &AnsiStringVDMEnv,
                                      &m,
                                      &iTask,
                                      dwCreationFlags,
                                      &StartupInfo
                                      ))
                       {
                        //
                        // If we failed with access denied, caller may not
                        // be allowed allowed to access the shared wow's
                        // desktop, so retry as a separate wow
                        //
                        if (VdmBinaryType == BINARY_TYPE_WIN16 &&
                            GetLastError() == ERROR_ACCESS_DENIED)
                          {
                           dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
                           }
                        else {
                            return FALSE;
                            }
                        goto RetrySepWow;
                        }

                    // Check the return value from the server
                    switch (b->VDMState & VDM_STATE_MASK){
                        case VDM_NOT_PRESENT:
                            // mark this so the server can undo
                            // creation if something goes wrong.
                            // We marked it "partitially created" because
                            // the NTVDM has yet not been fully created.
                            // a call to UpdateVdmEntry to update
                            // process handle will signal the NTVDM
                            // process completed creation

                            VDMCreationState = VDM_PARTIALLY_CREATED;

                            // jarbats: 1/8/2001
                            // Tell BaseGetVdmConfigInfo to create
                            // vdm commandline for meow
                            //

                            if (bMeowBinary)
                               {
                               VdmReserve = 1;
                               }

                            if (!BaseGetVdmConfigInfo(
                                    lpCommandLine,
                                    iTask,
                                    VdmBinaryType,
                                    &VdmNameString,
                                    &VdmReserve
                                    )) {
                                BaseSetLastNTError(Status);
                                return FALSE;
                                }

                            lpCommandLine = VdmNameString.Buffer;
                            lpApplicationName = NULL;


                            //
                            // Wow must have a hidden console
                            // Throw away DETACHED_PROCESS flag which isn't
                            // meaningful for Win16 apps.
                            //

                            dwCreationFlags |= CREATE_NO_WINDOW;
                            dwCreationFlags &= ~(CREATE_NEW_CONSOLE | DETACHED_PROCESS);


                            //
                            // We're starting a WOW VDM, turn on feedback unless
                            // the creator passed STARTF_FORCEOFFFEEDBACK.
                            //

                            StartupInfo.dwFlags |= STARTF_FORCEONFEEDBACK;

                            break;

                        case VDM_PRESENT_NOT_READY:
                            SetLastError (ERROR_NOT_READY);
                            return FALSE;

                        case VDM_PRESENT_AND_READY:
                            VDMCreationState = VDM_BEING_REUSED;
                            VdmWaitHandle = b->WaitObjectForParent;
                            break;
                        }

                    VdmReserve--;               // we reserve from addr 1
                    if(VdmWaitHandle)
                        goto VdmExists;
                    else {
                        bInheritHandles = FALSE;
                        // replace the environment with ours
                        if (lpEnvironment &&
                            !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT)) {
                            RtlDestroyEnvironment(lpEnvironment);
                            }
                        lpEnvironment = UnicodeStringVDMEnv.Buffer;
                        bVdmRetry = TRUE;
                        goto VdmRetry;
                        }

                case STATUS_FILE_IS_OFFLINE:
                    SetLastError(ERROR_FILE_OFFLINE);
                    break;

                default :
                    SetLastError(ERROR_BAD_EXE_FORMAT);
                    return FALSE;
            }
        }

        //
        // Make sure only WOW apps can have the CREATE_SEPARATE_WOW_VDM flag.
        //

        if (!IsWowBinary && (dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
            dwCreationFlags &= ~CREATE_SEPARATE_WOW_VDM;
        }

        //
        // Query the section to determine the stack parameters and
        // image entrypoint.
        //

        Status = NtQuerySection(
                    SectionHandle,
                    SectionImageInformation,
                    &ImageInformation,
                    sizeof( ImageInformation ),
                    NULL
                    );

        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError(Status);
            return FALSE;
            }

        if (ImageInformation.ImageCharacteristics & IMAGE_FILE_DLL) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return FALSE;
            }

        ImageFileDebuggerCommand[ 0 ] = UNICODE_NULL;
        if (!(dwCreationFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)) ||
            NtCurrentPeb()->ReadImageFileExecOptions
           ) {
            LdrQueryImageFileExecutionOptions( &PathName,
                                               L"Debugger",
                                               REG_SZ,
                                               ImageFileDebuggerCommand,
                                               sizeof( ImageFileDebuggerCommand ),
                                               NULL
                                             );
            }


        if ((ImageInformation.Machine < USER_SHARED_DATA->ImageNumberLow) ||
            (ImageInformation.Machine > USER_SHARED_DATA->ImageNumberHigh)) {
#if defined(_WIN64) || defined(BUILD_WOW6432)
            if (ImageInformation.Machine == IMAGE_FILE_MACHINE_I386) {
               // Fall through since this is a valid machine type.
                }
             else
#endif
                {
                ULONG_PTR ErrorParameters[2];
                ULONG ErrorResponse;

#if defined(_WIN64) || defined(BUILD_WOW6432)
RaiseInvalidWin32Error:
#endif
                ErrorResponse = ResponseOk;
                ErrorParameters[0] = (ULONG_PTR)&PathName;

                NtRaiseHardError( STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE,
                                  1,
                                  1,
                                  ErrorParameters,
                                  OptionOk,
                                  &ErrorResponse
                                );
                if ( NtCurrentPeb()->ImageSubsystemMajorVersion <= 3 ) {
                    SetLastError(ERROR_BAD_EXE_FORMAT);
                    }
                else {
                    SetLastError(ERROR_EXE_MACHINE_TYPE_MISMATCH);
                    }
                return FALSE;
                }
            }

        if ( ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_WINDOWS_GUI &&
             ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_WINDOWS_CUI ) {

            // POSIX exe

            NtClose(SectionHandle);
            SectionHandle = NULL;

            if ( ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_POSIX_CUI ) {

                if ( !BuildSubSysCommandLine( L"POSIX /P ",
                                              lpApplicationName,
                                              lpCommandLine,
                                              &SubSysCommandLine
                                            ) ) {
                    return FALSE;
                }

                lpCommandLine = SubSysCommandLine.Buffer;

                lpApplicationName = NULL;
                bVdmRetry = TRUE;
                goto VdmRetry;
                }
            else {
                SetLastError(ERROR_CHILD_NOT_COMPLETE);
                return FALSE;
                }
            }
        else {
            if (!BasepIsImageVersionOk( ImageInformation.SubSystemMajorVersion,
                                        ImageInformation.SubSystemMinorVersion) ) {
                SetLastError(ERROR_BAD_EXE_FORMAT);
                return FALSE;
                }
            }

        if (ImageFileDebuggerCommand[ 0 ] != UNICODE_NULL) {
            SIZE_T n;

            n = wcslen( lpCommandLine );
            if (n == 0) {
                lpCommandLine = (LPWSTR)lpApplicationName;
                n = wcslen( lpCommandLine );
                }

            n += wcslen( ImageFileDebuggerCommand ) + 1 + 2;
            n *= sizeof( WCHAR );

            SubSysCommandLine.Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), n );
            SubSysCommandLine.Length = 0;
            SubSysCommandLine.MaximumLength = (USHORT)n;
            RtlAppendUnicodeToString( &SubSysCommandLine, ImageFileDebuggerCommand );
            RtlAppendUnicodeToString( &SubSysCommandLine, L" " );
            RtlAppendUnicodeToString( &SubSysCommandLine, lpCommandLine );
#if DBG
            DbgPrint( "BASE: Calling debugger with '%wZ'\n", &SubSysCommandLine );
#endif
            lpCommandLine = SubSysCommandLine.Buffer;
            lpApplicationName = NULL;
            NtClose(SectionHandle);
            SectionHandle = NULL;
            RtlFreeHeap(RtlProcessHeap(), 0, NameBuffer);
            NameBuffer = NULL;
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
            FreeBuffer = NULL;
            goto VdmRetry;
            }

        //
        // Create the process object
        //

        pObja = BaseFormatObjectAttributes(&Obja,lpProcessAttributes,NULL);

        Flags = 0;
        if (dwCreationFlags & CREATE_BREAKAWAY_FROM_JOB ) {
            Flags |= PROCESS_CREATE_FLAGS_BREAKAWAY;
        }

        if ( dwCreationFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS) ) {
            Status = DbgUiConnectToDbg();
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
            }
            DebugPortHandle = DbgUiGetThreadDebugObject ();
            if (dwCreationFlags & DEBUG_ONLY_THIS_PROCESS) {
                Flags |= PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT;
            }
        }

        if (bInheritHandles) {
            Flags |= PROCESS_CREATE_FLAGS_INHERIT_HANDLES;
        }

        if (((ImageInformation.LoaderFlags & IMAGE_LOADER_FLAGS_COMPLUS) != 0)) {

#if defined(_WIN64) || defined(BUILD_WOW6432)

            //
            // Check if this is a 32-bit IL_ONLY COM+ image that needs to run natively
            // on Win64.
            //

            if ( ImageInformation.Machine == IMAGE_FILE_MACHINE_I386 ) {

                Status = BasepIsComplusILImage(
                                              SectionHandle,
                                              &ImageInformation,
                                              &ComPlusILImage
                                              );

                if ((NT_SUCCESS (Status)) && (ComPlusILImage != FALSE)) {
                    Flags |= PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE;
                }
            }

#endif
        } 
            
        //
        // This is temporary till we get Shim dlls support for native Win64 applications.
        //

        if (ImageInformation.Machine != IMAGE_FILE_MACHINE_I386) {
            pAppCompatDataTemp = NULL;
        } else {
            pAppCompatDataTemp = pAppCompatData;
        }

        Status = NtCreateProcessEx(
                    &ProcessHandle,
                    PROCESS_ALL_ACCESS,
                    pObja,
                    NtCurrentProcess(),
                    Flags,
                    SectionHandle,
                    DebugPortHandle,
                    NULL,
                    dwJobMemberLevel         // Job member level
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        //
        // NtCreateProcess will set to normal OR inherit if parent is IDLE or Below
        // only override if a mask is given during the create.
        //

        if ( PriClass.PriorityClass != PROCESS_PRIORITY_CLASS_UNKNOWN ) {
            State = NULL;
            if ( PriClass.PriorityClass ==  PROCESS_PRIORITY_CLASS_REALTIME ) {
                State = BasepIsRealtimeAllowed(TRUE);
                }
            Status = NtSetInformationProcess(
                        ProcessHandle,
                        ProcessPriorityClass,
                        (PVOID)&PriClass,
                        sizeof(PriClass)
                        );
            if ( State ) {
                BasepReleasePrivilege( State );
                }

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }

        if (dwCreationFlags & CREATE_DEFAULT_ERROR_MODE) {
            UINT NewMode;
            NewMode = SEM_FAILCRITICALERRORS;
            NtSetInformationProcess(
                ProcessHandle,
                ProcessDefaultHardErrorMode,
                &NewMode,
                sizeof(NewMode)
                );
            }

        //
        // If the process is being created for a VDM call the server with
        // process handle.
        //

        if (VdmBinaryType) {
            VdmWaitHandle = ProcessHandle;
            if (!BaseUpdateVDMEntry(UPDATE_VDM_PROCESS_HANDLE,
                                    &VdmWaitHandle,
                                    iTask,
                                    VdmBinaryType
                                    ))
                {
                //make sure we don't close the handle twice --
                //(VdmWaitHandle == ProcessHandle) if we don't do this.
                VdmWaitHandle = NULL;
                return FALSE;
                }

            //
            // For Sep wow the VdmWaitHandle = NULL (there is none!)
            //

            VDMCreationState |= VDM_FULLY_CREATED;
            }


#if defined(i386)
        //
        // Reserve memory in the new process' address space if necessary
        // (for vdms). This is required only for x86 system.
        //

    if ( VdmReserve ) {
            BigVdmReserve = VdmReserve;
            Status = NtAllocateVirtualMemory(
                        ProcessHandle,
                        &BaseAddress,
                        0L,
                        &BigVdmReserve,
                        MEM_RESERVE,
                        PAGE_EXECUTE_READWRITE
                        );
            if ( !NT_SUCCESS(Status) ){
                BaseSetLastNTError(Status);
                return FALSE;
            }
    }
#endif

        //
        // Abuse the StaticSize fields temporarily.
        // They are somewhat private, but we are using them for temporary space, sort of.
        // These are the right values for them, but we need to call the proper initialization function,
        // which will store the values a second time (possibly optimized away).
        //
        SxsWin32ManifestPathBuffer.ByteBuffer.StaticSize = SxsWin32ExePath.Length + sizeof(SXS_MANIFEST_SUFFIX);
        SxsWin32PolicyPathBuffer.ByteBuffer.StaticSize = SxsWin32ExePath.Length + sizeof(SXS_POLICY_SUFFIX);
        SxsWin32AssemblyDirectoryBuffer.ByteBuffer.StaticSize = SxsWin32ExePath.Length + sizeof(WCHAR); // Win32AssemblyDirectory overestimate
        SxsNtManifestPathBuffer.ByteBuffer.StaticSize = SxsNtExePath.Length + sizeof(SXS_MANIFEST_SUFFIX);
        SxsNtPolicyPathBuffer.ByteBuffer.StaticSize = SxsNtExePath.Length + sizeof(SXS_POLICY_SUFFIX);
        //
        // now add them up as BYTE sizes
        //
        SxsConglomeratedBufferSizeBytes = 0;
        for (sxsi = 0 ; sxsi != RTL_NUMBER_OF(SxsStringBuffers) ; ++sxsi) {
            SxsConglomeratedBufferSizeBytes += SxsStringBuffers[sxsi]->ByteBuffer.StaticSize;
        }
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_INFO_LEVEL,
            "SXS: SxsConglomeratedBufferSizeBytes:%Id\n",
            SxsConglomeratedBufferSizeBytes
            );
#endif
        //
        // one honking heap allocation
        //
        SxsConglomeratedByteBuffer = (PBYTE)RtlAllocateHeap(RtlProcessHeap(), 0, SxsConglomeratedBufferSizeBytes);
        if (SxsConglomeratedByteBuffer == NULL) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return FALSE;
        }
        //
        // now dole out pieces, calling the proper initialization function
        //
        for (sxsi= 0 ; sxsi != RTL_NUMBER_OF(SxsStringBuffers) ; ++sxsi) {
            RtlInitUnicodeStringBuffer(
                SxsStringBuffers[sxsi],
                (sxsi != 0) ? SxsStringBuffers[sxsi - 1]->ByteBuffer.Buffer + SxsStringBuffers[sxsi- 1]->ByteBuffer.StaticSize
                         : SxsConglomeratedByteBuffer,
                SxsStringBuffers[sxsi]->ByteBuffer.StaticSize
                );
        }

        SxsExeHandles.Process = ProcessHandle;
        SxsExeHandles.File = FileHandle;
         // The 1 bit here means something different than in the loader.
        ASSERT((((ULONG_PTR)SectionHandle) & (ULONG_PTR)1) == 0);
        SxsExeHandles.Section = SectionHandle;

        // if we have an override stream, use it
        if (NULL != pAppCompatSxsData) {
            AppCompatSxsManifest.Name    = SxsWin32ExePath;     // unicode string
            AppCompatSxsManifest.Address = pAppCompatSxsData;   // pointer to unicode manifest
            AppCompatSxsManifest.Size    = cbAppCompatSxsData;  // byte count
        }

        Status = BasepSxsCreateProcessCsrMessage(
            (NULL != pAppCompatSxsData) ? &AppCompatSxsManifest : NULL, // override manifest (appcompat hook)
            NULL, // override policy (appcompat hook)
            &SxsManifestPathPair,
            &SxsManifestFileHandles,
            &SxsExePathPair,
            &SxsExeHandles,
            &SxsPolicyPathPair,
            &SxsPolicyHandles,
            &SxsWin32AssemblyDirectoryBuffer,
            &a->Sxs
            );
#if DBG
        // verify the buffer size calculation
        for (sxsi = 0 ; sxsi != RTL_NUMBER_OF(SxsStringBuffers) ; ++sxsi)
        {
            if (SxsStringBuffers[sxsi]->ByteBuffer.Buffer != SxsStringBuffers[sxsi]->ByteBuffer.StaticBuffer)
            {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_WARNING_LEVEL,
                    "SXS: SxsStringBuffers[%lu]'s StaticSize was computed too small (%Id, %Id)\n",
                    sxsi,
                    SxsStringBuffers[sxsi]->ByteBuffer.StaticSize,
                    SxsStringBuffers[sxsi]->ByteBuffer.Size
                    );
            }
        }
#endif
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }

        //
        // Determine the location of the
        // processes PEB.
        //

        Status = NtQueryInformationProcess(
                    ProcessHandle,
                    ProcessBasicInformation,
                    &ProcessInfo,
                    sizeof( ProcessInfo ),
                    NULL
                    );
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }

        Peb = ProcessInfo.PebBaseAddress;

        //
        // Push the parameters into the address space of the new process
        //

        if ( ARGUMENT_PRESENT(lpCurrentDirectory) ) {
            CurdirBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                            MAKE_TAG( TMP_TAG ),
                                            (MAX_PATH + 1) * sizeof( WCHAR ) );
            if ( !CurdirBuffer ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                return FALSE;
                }
            CurdirLength2 = GetFullPathNameW(
                                lpCurrentDirectory,
                                MAX_PATH,
                                CurdirBuffer,
                                &CurdirFilePart
                                );
            if ( CurdirLength2 > MAX_PATH ) {
                SetLastError(ERROR_DIRECTORY);
                return FALSE;
                }

            //
            // now make sure the directory exists
            //

            CurdirLength = GetFileAttributesW(CurdirBuffer);
            if ( (CurdirLength == 0xffffffff) ||
                 !(CurdirLength & FILE_ATTRIBUTE_DIRECTORY) ) {
                SetLastError(ERROR_DIRECTORY);
                return FALSE;
                }
            }


        if ( QuoteInsert || QuoteCmdLine) {
            QuotedBuffer = RtlAllocateHeap(RtlProcessHeap(),0,wcslen(lpCommandLine)*2+6);

            if ( QuotedBuffer ) {
                wcscpy(QuotedBuffer,L"\"");

                if ( QuoteInsert ) {
                    TempChar = *TempNull;
                    *TempNull = UNICODE_NULL;
                    }

                wcscat(QuotedBuffer,lpCommandLine);
                wcscat(QuotedBuffer,L"\"");

                if ( QuoteInsert ) {
                    *TempNull = TempChar;
                    wcscat(QuotedBuffer,TempNull);
                    }

                }
            else {
                if ( QuoteInsert ) {
                    QuoteInsert = FALSE;
                    }
                if ( QuoteCmdLine ) {
                    QuoteCmdLine = FALSE;
                    }
                }
            }


        // If we found a manifest, we want to push that fact to the new process.
        if (a->Sxs.Flags & BASE_MSG_SXS_MANIFEST_PRESENT)
            dwBasePushProcessParametersFlags |= BASE_PUSH_PROCESS_PARAMETERS_FLAG_APP_MANIFEST_PRESENT;

        if (!BasePushProcessParameters(
                dwBasePushProcessParametersFlags,
                ProcessHandle,
                Peb,
                lpApplicationName,
                CurdirBuffer,
                QuoteInsert || QuoteCmdLine ? QuotedBuffer : lpCommandLine,
                lpEnvironment,
                &StartupInfo,
                dwCreationFlags | dwNoWindow,
                bInheritHandles,
                IsWowBinary ? IMAGE_SUBSYSTEM_WINDOWS_GUI : 0,
                pAppCompatDataTemp,
                cbAppCompatData
                ) ) {
            return FALSE;
            }


        RtlFreeUnicodeString(&VdmNameString);
        VdmNameString.Buffer = NULL;

        //
        // Stuff in the standard handles if needed
        //
        if (!VdmBinaryType &&
            !bInheritHandles &&
            !(StartupInfo.dwFlags & STARTF_USESTDHANDLES) &&
            !(dwCreationFlags & (DETACHED_PROCESS | CREATE_NEW_CONSOLE | CREATE_NO_WINDOW)) &&
            ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_WINDOWS_CUI
           ) {
            PRTL_USER_PROCESS_PARAMETERS ParametersInNewProcess;

            Status = NtReadVirtualMemory( ProcessHandle,
                                          &Peb->ProcessParameters,
                                          &ParametersInNewProcess,
                                          sizeof( ParametersInNewProcess ),
                                          NULL
                                        );
            if (NT_SUCCESS( Status )) {
                if (!CONSOLE_HANDLE( NtCurrentPeb()->ProcessParameters->StandardInput )) {
                    StuffStdHandle( ProcessHandle,
                                    NtCurrentPeb()->ProcessParameters->StandardInput,
                                    &ParametersInNewProcess->StandardInput
                                  );
                    }
                if (!CONSOLE_HANDLE( NtCurrentPeb()->ProcessParameters->StandardOutput )) {
                    StuffStdHandle( ProcessHandle,
                                    NtCurrentPeb()->ProcessParameters->StandardOutput,
                                    &ParametersInNewProcess->StandardOutput
                                  );
                    }
                if (!CONSOLE_HANDLE( NtCurrentPeb()->ProcessParameters->StandardError )) {
                    StuffStdHandle( ProcessHandle,
                                    NtCurrentPeb()->ProcessParameters->StandardError,
                                    &ParametersInNewProcess->StandardError
                                  );
                    }
                }
            }

        //
        // Create the thread...
        //

        //
        // Allocate a stack for this thread in the address space of the target
        // process.
        //

        StackStatus = BaseCreateStack(
                        ProcessHandle,
                        ImageInformation.CommittedStackSize,
                        (ImageInformation.MaximumStackSize < 256*1024) ? 256*1024 : ImageInformation.MaximumStackSize,
                        &InitialTeb
                        );

        if ( !NT_SUCCESS(StackStatus) ) {
            BaseSetLastNTError(StackStatus);
            return FALSE;
            }


        //
        // Create an initial context for the new thread.
        //

        BaseInitializeContext(
            &ThreadContext,
            Peb,
            ImageInformation.TransferAddress,
            InitialTeb.StackBase,
            BaseContextTypeProcess
            );


        //
        // Create the actual thread object
        //

        pObja = BaseFormatObjectAttributes(&Obja,lpThreadAttributes,NULL);

        Status = NtCreateThread(
                    &ThreadHandle,
                    THREAD_ALL_ACCESS,
                    pObja,
                    ProcessHandle,
                    &ClientId,
                    &ThreadContext,
                    &InitialTeb,
                    TRUE
                    );

        if (!NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }

        a->Peb = (ULONGLONG) Peb;

        //
        // From here on out, do not modify the address space of the
        // new process.  WOW64's implementation of NtCreateThread()
        // reshuffles the new process' address space if the current
        // process is 32-bit and the new process is 64-bit.
        //
#if DBG
        Peb = NULL;
#endif

#if defined(WX86)

        //
        // if this is a Wx86 Process, setup for a Wx86 emulated Thread
        //

        if (Wx86Info) {

            //
            // create a WX86Tib and initialize it's Teb->Vdm.
            //
            Status = BaseCreateWx86Tib(ProcessHandle,
                                       ThreadHandle,
                                       (ULONG)((ULONG_PTR)ImageInformation.TransferAddress),
                                       (ULONG)ImageInformation.CommittedStackSize,
                                       (ULONG)ImageInformation.MaximumStackSize,
                                       TRUE
                                       );

            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                return( FALSE );
                }


            //
            // Mark Process as WX86
            //
            Status = NtSetInformationProcess (ProcessHandle,
                                              ProcessWx86Information,
                                              &Wx86Info,
                                              sizeof(Wx86Info)
                                              );

            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                return( FALSE );
                }
            }
#endif


        //
        // Call the Windows server to let it know about the
        // process.
        //

        a->ProcessHandle = ProcessHandle;
        a->ThreadHandle = ThreadHandle;
        a->ClientId = ClientId;

        switch (ImageInformation.Machine) {
        case IMAGE_FILE_MACHINE_I386:
#if defined(_WIN64) || defined(BUILD_WOW6432)
            a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
#else
            a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
#endif
            break;

        case IMAGE_FILE_MACHINE_IA64:
            a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_AMD64;
            break;

        default:
            DbgPrint("kernel32: No mapping for ImageInformation.Machine == %04x\n", ImageInformation.Machine);
            a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
            break;
        }

        //
        // remove debug flags now its not being done by CSR
        //
        a->CreationFlags = dwCreationFlags & ~ (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS);
        a->DebuggerClientId.UniqueProcess = NULL;
        a->DebuggerClientId.UniqueThread = NULL;


        //
        // Set the 2 bit if a gui app is starting. The window manager needs to
        // know this so it can synchronize the startup of this app
        // (WaitForInputIdle api). This info is passed using the process
        // handle tag bits.  The 1 bit asks the window manager to turn on
        // or turn off the application start cursor (hourglass/pointer).
        //
        // When starting a WOW process, lie and tell UserSrv NTVDM.EXE is a GUI
        // process.  We also turn on bit 0x8 so that UserSrv can ignore the
        // UserNotifyConsoleApplication call made by the console during startup.
        //

        if ( ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_WINDOWS_GUI ||
             IsWowBinary ) {

            a->ProcessHandle = (HANDLE)((ULONG_PTR)a->ProcessHandle | 2);

            //
            // If the creating process is a GUI app, turn on the app. start cursor
            // by default.  This can be overridden by STARTF_FORCEOFFFEEDBACK.
            //

            NtHeaders = RtlImageNtHeader((PVOID)GetModuleHandle(NULL));
            if ( NtHeaders
                 && (NtHeaders->OptionalHeader.Subsystem
                     == IMAGE_SUBSYSTEM_WINDOWS_GUI ) ) {
                a->ProcessHandle = (HANDLE)((ULONG_PTR)a->ProcessHandle | 1);
                }
            }


        //
        // If feedback is forced on, turn it on. If forced off, turn it off.
        // Off overrides on.
        //

        if (StartupInfo.dwFlags & STARTF_FORCEONFEEDBACK)
            a->ProcessHandle = (HANDLE)((ULONG_PTR)a->ProcessHandle | 1);
        if (StartupInfo.dwFlags & STARTF_FORCEOFFFEEDBACK)
            a->ProcessHandle = (HANDLE)((ULONG_PTR)a->ProcessHandle & ~1);

        a->VdmBinaryType = VdmBinaryType; // just tell server the truth

        if (VdmBinaryType){
           a->hVDM    = iTask ? 0 : NtCurrentPeb()->ProcessParameters->ConsoleHandle;
           a->VdmTask = iTask;
        }

#if defined(BUILD_WOW6432)
        m.ReturnValue = CsrBasepCreateProcess(a);
#else
        m.u.CreateProcess = *a;
        if (m.u.CreateProcess.Sxs.Flags != 0)
        {
            const PUNICODE_STRING StringsToCapture[] =
            {
                &m.u.CreateProcess.Sxs.Manifest.Path,
                    &m.u.CreateProcess.Sxs.Policy.Path,
                    &m.u.CreateProcess.Sxs.AssemblyDirectory
            };

            Status =
                CsrCaptureMessageMultiUnicodeStringsInPlace(
                &CaptureBuffer,
                RTL_NUMBER_OF(StringsToCapture),
                StringsToCapture
                );
            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                return FALSE;
            }
        }

        CsrClientCallServer( (PCSR_API_MSG)&m,
                             CaptureBuffer,
                             CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                  BasepCreateProcess
                                                ),
                             sizeof( *a )
                           );

        if ( CaptureBuffer ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            CaptureBuffer = NULL;
        }

#endif

        if (!NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
            BaseSetLastNTError((NTSTATUS)m.ReturnValue);
            NtTerminateProcess(ProcessHandle, (NTSTATUS)m.ReturnValue);
            return FALSE;
            }



        //
        // If the WinSafer sandboxing policy indicates that the
        // process needs to be run with a restricted token or placed
        // into a restricted job object, then do those actions now.
        // Do not replace the token if the restricted token was created
        // from a caller supplied token i.e. the CreateProcessAsUser case.
        //
        if ((hSaferRestrictedToken != NULL) && (hUserToken == NULL)) {
            Status = BasepReplaceProcessThreadTokens(
                    hSaferRestrictedToken,
                    ProcessHandle,
                    ThreadHandle);
            if (!NT_SUCCESS(Status)) {
                // kill and cleanup.
                NtTerminateProcess(ProcessHandle, Status);
                BaseSetLastNTError(Status);
                return FALSE;
            }
        }
        if (hSaferAssignmentJob != NULL) {
            Status = NtAssignProcessToJobObject(
                    hSaferAssignmentJob, ProcessHandle);
            if (!NT_SUCCESS(Status)) {
                // kill and cleanup.
                NtTerminateProcess(ProcessHandle, STATUS_ACCESS_DENIED);
                BaseSetLastNTError(Status);
                return FALSE;
            }
        }


        //
        // Make the thread start execution if we are allowed to.
        //
        if (!( dwCreationFlags & CREATE_SUSPENDED) ) {
            NtResumeThread(ThreadHandle,&i);
            }

VdmExists:
        bStatus = TRUE;
        if (VDMCreationState)
            VDMCreationState |= VDM_CREATION_SUCCESSFUL;

        try {
            if (VdmWaitHandle) {

                //
                // tag Shared WOW VDM handles so that wait for input idle has a
                // chance to work.  Shared WOW VDM "process" handles are actually
                // event handles,  Separate WOW VDM handles are real process
                // handles. Also mark DOS handles with 0x1 so WaitForInputIdle
                // has a way to distinguish DOS apps and not block forever.
                //

                if (VdmBinaryType == BINARY_TYPE_WIN16)  {
                    lpProcessInformation->hProcess =
                            (HANDLE)((ULONG_PTR)VdmWaitHandle | 0x2);

                    //
                    // Shared WOW doesn't always start a process, so
                    // we don't have a process ID or thread ID to
                    // return if the VDM already existed.
                    //
                    // Separate WOW doesn't hit this codepath
                    // (no VdmWaitHandle).
                    //

                    if (VDMCreationState & VDM_BEING_REUSED) {
                        ClientId.UniqueProcess = 0;
                        ClientId.UniqueThread = 0;
                        }

                    }
                else  {
                    lpProcessInformation->hProcess =
                            (HANDLE)((ULONG_PTR)VdmWaitHandle | 0x1);
                    }


                //
                // Close the ProcessHandle, since we are returning the
                // VdmProcessHandle instead.
                //

                if (ProcessHandle != NULL)
                    NtClose(ProcessHandle);
                }
            else{
                lpProcessInformation->hProcess = ProcessHandle;
                }

            lpProcessInformation->hThread = ThreadHandle;
            lpProcessInformation->dwProcessId = HandleToUlong(ClientId.UniqueProcess);
            lpProcessInformation->dwThreadId = HandleToUlong(ClientId.UniqueThread);
            ProcessHandle = NULL;
            ThreadHandle = NULL;
            }
        __except ( EXCEPTION_EXECUTE_HANDLER ) {
            NtClose( ProcessHandle );
            NtClose( ThreadHandle );
            ProcessHandle = NULL;
            ThreadHandle = NULL;
            if (VDMCreationState)
                VDMCreationState &= ~VDM_CREATION_SUCCESSFUL;
            }
        }
    __finally {

        if (ExePathFullBuffer != NULL) {
            SxsWin32ExePath.Buffer = NULL;
            SxsWin32ExePath.Length = 0;
            SxsWin32ExePath.MaximumLength = 0;
            RtlFreeHeap(RtlProcessHeap(), 0, ExePathFullBuffer);
            ExePathFullBuffer = NULL;
        }

        if (!VdmBinaryType) {
            NTSTATUS Status1;

            BasepSxsCloseHandles(&SxsManifestFileHandles);
            BasepSxsCloseHandles(&SxsPolicyHandles);
            //
            // don't close SxsExeHandles, they are
            // aliases of other variables that are either closed
            // or returned to the caller
            //

            //
            // This loop only really frees any memory if our computation
            // of the overall buffer size was too low, which it is not supposed to be.
            //
            if (SxsConglomeratedByteBuffer != NULL) {
                for (sxsi= 0 ; sxsi != RTL_NUMBER_OF(SxsStringBuffers) ; ++sxsi) {
                    RtlFreeUnicodeStringBuffer(SxsStringBuffers[sxsi]);
                    }
                RtlFreeHeap(RtlProcessHeap(), 0,SxsConglomeratedByteBuffer);
                }
            }
        if (lpEnvironment && !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT) ) {
            RtlDestroyEnvironment(lpEnvironment);
            lpEnvironment = NULL;
            }
        RtlFreeHeap(RtlProcessHeap(), 0,QuotedBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0,CurdirBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        if ( FileHandle ) {
            NtClose(FileHandle);
            }
        if ( SectionHandle ) {
            NtClose(SectionHandle);
            }
        if ( ThreadHandle ) {
            NtTerminateProcess(ProcessHandle,STATUS_SUCCESS);
            NtClose(ThreadHandle);
            }
        if ( ProcessHandle ) {
            NtClose(ProcessHandle);
            }
        if ( hSaferAssignmentJob ) {
            NtClose(hSaferAssignmentJob);
            }
        if ( hSaferRestrictedToken ) {
            if (hUserToken == NULL) {
                // CreateProcess case
                NtClose(hSaferRestrictedToken);
                }
            else{
                // CreateProcessAsUser case
                *hRestrictedUserToken = hSaferRestrictedToken;
                }
            }

        if (NULL != pAppCompatData) {
            RtlFreeHeap(RtlProcessHeap(), 0, pAppCompatData);
            }

        if (NULL != pAppCompatSxsData) {
            RtlFreeHeap(RtlProcessHeap(), 0, pAppCompatSxsData);
            }

        RtlFreeUnicodeString(&VdmNameString);
        RtlFreeUnicodeString(&SubSysCommandLine);
        if (AnsiStringVDMEnv.Buffer || UnicodeStringVDMEnv.Buffer)
            BaseDestroyVDMEnvironment(&AnsiStringVDMEnv, &UnicodeStringVDMEnv);

        if (VDMCreationState && !(VDMCreationState & VDM_CREATION_SUCCESSFUL)){
            BaseUpdateVDMEntry (
                UPDATE_VDM_UNDO_CREATION,
                (HANDLE *)&iTask,
                VDMCreationState,
                VdmBinaryType
                );
            if(VdmWaitHandle) {
                NtClose(VdmWaitHandle);
                }
            }
        }

    if (lpEnvironment && !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT) ) {
        RtlDestroyEnvironment(lpEnvironment);
        }
    return bStatus;
}

BOOL
WINAPI
CreateProcessW(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )

/*++

Routine Description:

    A process and thread object are created and a handle opened to each
    object using CreateProcess.  Note that WinExec and LoadModule are
    still supported, but are implemented as a call to CreateProcess.

Arguments:

    lpApplicationName - Supplies an optional pointer to a null terminated
        character string that contains the name of the image file to
        execute.  This is a fully qualified DOS path name.  If not
        specified, then the image file name is the first whitespace
        delimited token on the command line.

    lpCommandLine - Supplies a null terminated character string that
        contains the command line for the application to be executed.
        The entire command line is made available to the new process
        using GetCommandLine.  If the lpApplicationName parameter was
        not specified, then the first token of the command line
        specifies file name of the application (note that this token
        begins at the beginning of the command line and ends at the
        first "white space" character).  If the file name does not
        contain an extension (the presence of a "."), then .EXE is
        assumed.  If the file name does not contain a directory path,
        Windows will search for the executable file in:

          - The current directory

          - The windows directory

          - The windows system directory

          - The directories listed in the path environment variable

        This parameter is optional onlu if the lpApplicationName
        parameter is specified.  In this case the command line the
        application receives will be the application name.

    lpProcessAttributes - An optional parameter that may be used to
        specify the attributes of the new process.  If the parameter is
        not specified, then the process is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation:

        SECURITY_ATTRIBUTES Structure:

        DWORD nLength - Specifies the length of this structure.  Must be
            set to sizeof( SECURITY_ATTRUBUTES ).

        LPVOID lpSecurityDescriptor - Points to a security descriptor for
            the object (must be NULL for Win32, used on NT/Win32). The
            security descriptor controls the sharing of an object.

        BOOL bInheritHandle - Supplies a flag that indicates whether
            or not the returned handle is to be inherited by a new
            process during process creation.  A value of TRUE
            indicates that the new process will inherit the handle.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on
        process creation.

    dwCreationFlags - Supplies additional flags that control the creation
        of the process.

        dwCreationFlags Flags:

        DEBUG_PROCESS - If this flag bit is set, then the creating
            process is treated as a debugger, and the process being
            created is created as a debugee.  All debug events occuring
            in the debugee are reported to the debugger.  If this bit is
            clear, but the calling process is a debugee, then the
            process becomes a debugee of the calling processes debugger.
            If this bit is clear and the calling processes is not a
            debugee then no debug related actions occur.

        DEBUG_ONLY_THIS_PROCESS - If this flag is set, then the
            DEBUG_PROCESS flag bit must also be set.  The calling
            process is is treated as a debugger, and the new process is
            created as its debuggee.  If the new process creates
            additional processes, no debug related activities (with
            respect to the debugger) occur.

        CREATE_SUSPENDED - The process is created, but the initial thread
            of the process remains suspended. The creator can resume this
            thread using ResumeThread. Until this is done, code in the
            process will not execute.

        CREATE_UNICODE_ENVIRONMENT - If set, the environment pointer
            points to a Unicode environment block.  Otherwise, the
            block is ANSI (actually OEM.)

    bInheritHandles - Supplies a flag that specifies whether or not the
        new process is to inherit handles to objects visible to the
        calling process.  A value of TRUE causes handles to be inherited
        by the new process.  If TRUE was specified, then for each handle
        visible to the calling process, if the handle was created with
        the inherit handle option, the handle is inherited to the new
        process.  The handle has the same granted access in the new
        process as it has in the calling process, and the value of the
        handle is the same.

    lpEnvironment - An optional parameter, that if specified, supplies a
        pointer to an environment block.  If the parameter is not
        specified, the environment block of the current process is used.
        This environment block is made available to the new process
        using GetEnvironmentStrings.

    lpCurrentDirectory - An optional parameter, that if specified,
        supplies a string representing the current drive and directory
        for the new process.  The string must be a fully qualified
        pathname that includes a drive letter.  If the parameter is not
        specified, then the new process is created with the same current
        drive and directory as the calling process.  This option is
        provided primarily for shells that want to start an application
        and specify its initial drive and working directory.

    lpStartupInfo - Supplies information that specified how the
        applications window is to be shown. This structure is described
        in the Win32 User Interface API Book.

    lpProcessInformation - Returns identification information about the
        new process.

    PROCESS_INFORMATION Structure:

        HANDLE hProcess - Returns a handle to the newly created process.
            Through the handle, all operations on process objects are
            allowed.

        HANDLE hThread - Returns a handle to the newly created thread.
            Through the handle, all operations on thread objects are
            allowed.

        DWORD dwProcessId - Returns a global process id that may be used
            to identify a process.  The value is valid from the time the
            process is created until the time the process is terminated.

        DWORD dwThreadId - Returns a global thread id that may be used
            to identify a thread.  The value is valid from the time the
            thread is created until the time the thread is terminated.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return CreateProcessInternalW(
               NULL, // Create new process with the token on the creator process
               lpApplicationName,
               lpCommandLine,
               lpProcessAttributes,
               lpThreadAttributes,
               bInheritHandles,
               dwCreationFlags,
               lpEnvironment,
               lpCurrentDirectory,
               lpStartupInfo,
               lpProcessInformation,
               NULL  // Do not return the restricted token
               );
}

HANDLE
WINAPI
OpenProcess(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
    )

/*++

Routine Description:

    A handle to a process object may be created using OpenProcess.

    Opening a process creates a handle to the specified process.
    Associated with the process handle is a set of access rights that
    may be performed using the process handle.  The caller specifies the
    desired access to the process using the DesiredAccess parameter.

Arguments:

    mDesiredAccess - Supplies the desired access to the process object.
        For NT/Win32, this access is checked against any security
        descriptor on the target process.  The following object type
        specific access flags can be specified in addition to the
        STANDARD_RIGHTS_REQUIRED access flags.

        DesiredAccess Flags:

        PROCESS_DUP_HANDLE - Duplicate object access to the process is
            desired.  This access is required in order to duplicate an
            object handle into or out of a process.

        PROCESS_QUERY_INFORMATION - This access is required to read
            certain information from the process object.

        PROCESS_VM_READ - This access is required to read the memory of
            another process.

        PROCESS_VM_WRITE - This access is required to write the memory
            of another process.

        SYNCHRONIZE - This access is required to wait on a process object.

        PROCESS_ALL_ACCESS - This set of access flags specifies all of the
            possible access flags for a process object.

    bInheritHandle - Supplies a flag that indicates whether or not the
        returned handle is to be inherited by a new process during
        process creation.  A value of TRUE indicates that the new
        process will inherit the handle.

    dwProcessId - Supplies the process id of the process to open.

Return Value:

    NON-NULL - Returns an open handle to the specified process.  The
        handle may be used by the calling process in any API that
        requires a handle to a process.  If the open is successful, the
        handle is granted access to the process object only to the
        extent that it requested access through the DesiredAccess
        parameter.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = LongToHandle(dwProcessId);

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenProcess(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

VOID
WINAPI
#if defined(_X86_)
_ExitProcess(
#else
ExitProcess(
#endif
    UINT uExitCode
    )

/*++

Routine Description:

    The current process can exit using ExitProcess.

    ExitProcess is the prefered method of exiting an application.  This
    API provides a clean application shutdown.  This includes calling
    all attached DLLs at their instance termination entrypoint.  If an
    application terminates by any other method:

        - TerminateProcess

        - TerminateThread of last thread in the process

        - ExitThread of last thread in the process

    The DLLs that the process is attached to will not be notified of the
    process termination.

    After notifying all DLLs of the process termination, this API
    terminates the current process as if a call to
    TerminateProcess(GetCurrentProcess()) were made.

Arguments:

    uExitCode - Supplies the termination status for each thread
        in the process.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    BASE_API_MSG m;
    PBASE_EXITPROCESS_MSG a = &m.u.ExitProcess;

    if ( BaseRunningInServerProcess ) {
        ASSERT(!BaseRunningInServerProcess);
        }
    else {

        RtlAcquirePebLock();

        try {
            Status = NtTerminateProcess(NULL,(NTSTATUS)uExitCode);

            LdrShutdownProcess();

#if defined(BUILD_WOW6432)
            CsrBasepExitProcess(uExitCode);
#else
            a->uExitCode = uExitCode;
            CsrClientCallServer( (PCSR_API_MSG)&m,
                                 NULL,
                                 CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                      BasepExitProcess
                                                    ),
                                 sizeof( *a )
                               );
#endif

            NtTerminateProcess(NtCurrentProcess(),(NTSTATUS)uExitCode);
            }
        finally {
                RtlReleasePebLock();
            }
    }
}

#if defined(_X86_)
// Appcompat: There's code that depends on the old EH frame setup/teardown.  Simulate it here
// then call the real function.  ExitProcess is a no-return function so don't bother cleaning up.
__declspec(naked) VOID WINAPI ExitProcess( UINT uExitCode )
{
    __asm {
        push ebp
        mov  ebp,esp
        push -1
        push 0x77e8f3b0
        push uExitCode
        call _ExitProcess
    }
}
#endif

BOOL
WINAPI
TerminateProcess(
    HANDLE hProcess,
    UINT uExitCode
    )

/*++

Routine Description:

    A process and all of its threads may be terminated using
    TerminateProcess.

    TerminateProcess is used to cause all of the threads within a
    process to terminate.

    While TerminateProcess will cause all threads within a process to
    terminate, and will cause an application to exit, it does not notify
    DLLs that the process is attached to that the process is
    terminating.  TerminateProcess is used to unconditionally cause a
    process to exit.  It should only be used in extreme circumstances.
    The state of global data maintained by DLLs may be comprimised if
    TerminateProcess is used rather that ExitProcess.

    Once all of the threads have terminated, the process attains a state
    of signaled satisfying any waits on the process.  The process's
    termination status is updated from its initial value of
    STATUS_PENDING to the termination status of the last thread in the
    process to terminate (usually this is the same value as the
    TerminationStatus parameter).  Terminating a process does not remove
    a process from the system.  It simply causes all of the threads in
    the process to terminate their execution, and causes all of the
    object handles opened by the process to be closed.  The process is
    not removed from the system until the last handle to the process is
    closed.

Arguments:

    hProcess - Supplies a handle to the process to terminate.  The handle
        must have been created with PROCESS_TERMINATE access.

    uExitCode - Supplies the termination status for each thread
        in the process.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    if ( hProcess == NULL ) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
        }
    Status = NtTerminateProcess(hProcess,(NTSTATUS)uExitCode);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
GetExitCodeProcess(
    HANDLE hProcess,
    LPDWORD lpExitCode
    )

/*++

Routine Description:

    The termination status of a process can be read using
    GetExitCodeProcess.

    If a process is in the signaled state, calling this function returns
    the termination status of the process.
    If the process is not yet signaled, the termination
    status returned is STILL_ACTIVE.


Arguments:

    hProcess - Supplies a handle to the process whose termination status
        is to be read.  The handle must have been created with
        PROCESS_QUERY_INFORMATION access.

    lpExitCode - Returns the current termination status of the process.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInformation;


    if (BaseCheckForVDM (hProcess,lpExitCode) == TRUE)
        return TRUE;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        *lpExitCode = BasicInformation.ExitStatus;
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

VOID
WINAPI
GetStartupInfoW(
    LPSTARTUPINFOW lpStartupInfo
    )

/*++

Routine Description:

    The startup information for the current process is available using this
    API.

Arguments:

    lpStartupInfo - a pointer to a STARTUPINFO structure that will be filed
        in by the API.  The pointer fields of the structure will point
        to static strings.

Return Value:

    None.

--*/

{
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    ProcessParameters = NtCurrentPeb()->ProcessParameters;
    lpStartupInfo->cb = sizeof( *lpStartupInfo );
    lpStartupInfo->lpReserved  = (LPWSTR)ProcessParameters->ShellInfo.Buffer;
    lpStartupInfo->lpDesktop   = (LPWSTR)ProcessParameters->DesktopInfo.Buffer;
    lpStartupInfo->lpTitle     = (LPWSTR)ProcessParameters->WindowTitle.Buffer;
    lpStartupInfo->dwX         = ProcessParameters->StartingX;
    lpStartupInfo->dwY         = ProcessParameters->StartingY;
    lpStartupInfo->dwXSize     = ProcessParameters->CountX;
    lpStartupInfo->dwYSize     = ProcessParameters->CountY;
    lpStartupInfo->dwXCountChars = ProcessParameters->CountCharsX;
    lpStartupInfo->dwYCountChars = ProcessParameters->CountCharsY;
    lpStartupInfo->dwFillAttribute = ProcessParameters->FillAttribute;
    lpStartupInfo->dwFlags     = ProcessParameters->WindowFlags;
    lpStartupInfo->wShowWindow = (WORD)ProcessParameters->ShowWindowFlags;
    lpStartupInfo->cbReserved2 = ProcessParameters->RuntimeData.Length;
    lpStartupInfo->lpReserved2 = (LPBYTE)ProcessParameters->RuntimeData.Buffer;

    if (lpStartupInfo->dwFlags & (STARTF_USESTDHANDLES | STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {
        lpStartupInfo->hStdInput   = ProcessParameters->StandardInput;
        lpStartupInfo->hStdOutput  = ProcessParameters->StandardOutput;
        lpStartupInfo->hStdError   = ProcessParameters->StandardError;
    }

    return;
}


VOID
WINAPI
GetStartupInfoA(
    LPSTARTUPINFOA lpStartupInfo
    )
/*++

Routine Description:

    The startup information for the current process is available using this
    API.

Arguments:

    lpStartupInfo - a pointer to a STARTUPINFO structure that will be filed
        in by the API.  The pointer fields of the structure will point
        to static strings.

Return Value:

    None.

--*/

{
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    NTSTATUS Status;
    ANSI_STRING AnsiString;

    ProcessParameters = NtCurrentPeb()->ProcessParameters;

    RtlAcquirePebLock();
    try {
        if ( !BaseAnsiStartupInfo ) {
            BaseAnsiStartupInfo = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), sizeof(*BaseAnsiStartupInfo));
            if (!BaseAnsiStartupInfo) {
                RtlRaiseStatus(STATUS_NO_MEMORY);
                }
            BaseAnsiStartupInfo->cb = sizeof( *BaseAnsiStartupInfo );
            BaseAnsiStartupInfo->dwX         = ProcessParameters->StartingX;
            BaseAnsiStartupInfo->dwY         = ProcessParameters->StartingY;
            BaseAnsiStartupInfo->dwXSize     = ProcessParameters->CountX;
            BaseAnsiStartupInfo->dwYSize     = ProcessParameters->CountY;
            BaseAnsiStartupInfo->dwXCountChars = ProcessParameters->CountCharsX;
            BaseAnsiStartupInfo->dwYCountChars = ProcessParameters->CountCharsY;
            BaseAnsiStartupInfo->dwFillAttribute = ProcessParameters->FillAttribute;
            BaseAnsiStartupInfo->dwFlags     = ProcessParameters->WindowFlags;
            BaseAnsiStartupInfo->wShowWindow = (WORD)ProcessParameters->ShowWindowFlags;
            BaseAnsiStartupInfo->cbReserved2 = ProcessParameters->RuntimeData.Length;
            BaseAnsiStartupInfo->lpReserved2 = (LPBYTE)ProcessParameters->RuntimeData.Buffer;
            BaseAnsiStartupInfo->hStdInput   = ProcessParameters->StandardInput;
            BaseAnsiStartupInfo->hStdOutput  = ProcessParameters->StandardOutput;
            BaseAnsiStartupInfo->hStdError   = ProcessParameters->StandardError;

            BaseAnsiStartupInfo->lpReserved  = NULL;
            BaseAnsiStartupInfo->lpDesktop   = NULL;
            BaseAnsiStartupInfo->lpTitle     = NULL;

            Status = RtlUnicodeStringToAnsiString(&AnsiString,&ProcessParameters->ShellInfo,TRUE);
            if ( !NT_SUCCESS(Status) ) {
                RtlRaiseStatus(Status);
                }
            else {
                BaseAnsiStartupInfo->lpReserved = AnsiString.Buffer;
                }

            Status = RtlUnicodeStringToAnsiString(&AnsiString,&ProcessParameters->DesktopInfo,TRUE);
            if ( !NT_SUCCESS(Status) ) {
                RtlRaiseStatus(Status);
                }
            else {
                BaseAnsiStartupInfo->lpDesktop = AnsiString.Buffer;
                }

            Status = RtlUnicodeStringToAnsiString(&AnsiString,&ProcessParameters->WindowTitle,TRUE);
            if ( !NT_SUCCESS(Status) ) {
                RtlRaiseStatus(Status);
                }
            else {
                BaseAnsiStartupInfo->lpTitle = AnsiString.Buffer;
                }
            }
        }
    finally {
        RtlReleasePebLock();
        }

    lpStartupInfo->cb          = BaseAnsiStartupInfo->cb         ;
    lpStartupInfo->lpReserved  = BaseAnsiStartupInfo->lpReserved ;
    lpStartupInfo->lpDesktop   = BaseAnsiStartupInfo->lpDesktop  ;
    lpStartupInfo->lpTitle     = BaseAnsiStartupInfo->lpTitle    ;
    lpStartupInfo->dwX         = BaseAnsiStartupInfo->dwX        ;
    lpStartupInfo->dwY         = BaseAnsiStartupInfo->dwY        ;
    lpStartupInfo->dwXSize     = BaseAnsiStartupInfo->dwXSize    ;
    lpStartupInfo->dwYSize     = BaseAnsiStartupInfo->dwYSize    ;
    lpStartupInfo->dwXCountChars = BaseAnsiStartupInfo->dwXCountChars;
    lpStartupInfo->dwYCountChars = BaseAnsiStartupInfo->dwYCountChars;
    lpStartupInfo->dwFillAttribute = BaseAnsiStartupInfo->dwFillAttribute;
    lpStartupInfo->dwFlags     = BaseAnsiStartupInfo->dwFlags    ;
    lpStartupInfo->wShowWindow = BaseAnsiStartupInfo->wShowWindow;
    lpStartupInfo->cbReserved2 = BaseAnsiStartupInfo->cbReserved2;
    lpStartupInfo->lpReserved2 = BaseAnsiStartupInfo->lpReserved2;

    if (lpStartupInfo->dwFlags & (STARTF_USESTDHANDLES | STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {
        lpStartupInfo->hStdInput   = BaseAnsiStartupInfo->hStdInput;
        lpStartupInfo->hStdOutput  = BaseAnsiStartupInfo->hStdOutput;
        lpStartupInfo->hStdError   = BaseAnsiStartupInfo->hStdError;
        }
    else {
        lpStartupInfo->hStdInput   = INVALID_HANDLE_VALUE;
        lpStartupInfo->hStdOutput  = INVALID_HANDLE_VALUE;
        lpStartupInfo->hStdError   = INVALID_HANDLE_VALUE;
        }
    return;
}


LPSTR
WINAPI
GetCommandLineA(
    VOID
    )

/*++

Routine Description:

    The command line of the current process is available using this
    API.

Arguments:

    None.

Return Value:

    The address of the current processes command line is returned.  The
    return value is a pointer to null terminate string.

--*/

{
    return (LPSTR)BaseAnsiCommandLine.Buffer;
}

LPWSTR
WINAPI
GetCommandLineW(
    VOID
    )
/*++

Routine Description:

    The command line of the current process is available using this
    API.

Arguments:

    None.

Return Value:

    The address of the current processes command line is returned.  The
    return value is a pointer to null terminate string.

--*/

{
    return BaseUnicodeCommandLine.Buffer;
}



BOOL
WINAPI
FreeEnvironmentStringsW(
    LPWSTR penv
    )

/*++

Routine Description:

    This API is intended to be called after the environment block
    pointer returned by GetEnvironmentStringsW is no longer needed.

Arguments:

    None.

Return Value:

    TRUE, since the process environment block is never freed until
    the process terminates.

--*/

{
    UNREFERENCED_PARAMETER(penv);

    return TRUE;
}


BOOL
WINAPI
FreeEnvironmentStringsA(
    LPSTR penv
    )

/*++

Routine Description:

    This API is intended to be called after the environment block
    pointer returned by GetEnvironmentStringsA is no longer needed.

Arguments:

    None.

Return Value:

    The return code from RtlFreeHeap.

--*/

{
    return RtlFreeHeap(RtlProcessHeap(), 0, penv );
}


LPWSTR
WINAPI
GetEnvironmentStringsW(
    VOID
    )

/*++

Routine Description:

    The environment strings of the current process are available using
    this API.

Arguments:

    None.

Return Value:

    The address of the current processes environment block is returned.
    The block is opaque and must only be interpreted via the environment
    variable access functions.

--*/

{
    return (LPWSTR)NtCurrentPeb()->ProcessParameters->Environment;
}


LPSTR
WINAPI
GetEnvironmentStrings(
    VOID
    )

/*++

Routine Description:

    The environment strings of the current process are available using
    this API.

Arguments:

    None.

Return Value:

    The address of the current processes environment block is returned.
    The block is opaque and must only be interpreted via the environment
    variable access functions.

--*/

{
    NTSTATUS    Status;
    LPWSTR      pUnicode;
    USHORT      cch = 0;
    UNICODE_STRING      Unicode;
    OEM_STRING  Buffer;

    pUnicode = (LPWSTR)NtCurrentPeb()->ProcessParameters->Environment;
    Unicode.Buffer = pUnicode;

    while ( (*pUnicode) || (*(pUnicode+1))) {
        cch++;
        pUnicode++;
    }

    // Go for worst case
    Buffer.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( ENV_TAG ), (cch+2)*sizeof(WCHAR));
    if (Buffer.Buffer == NULL) {
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return NULL;
        }
    Buffer.Length  = Buffer.MaximumLength  = (cch + 2) * sizeof(WCHAR);
    Unicode.Length = Unicode.MaximumLength = (cch + 2) * sizeof(WCHAR);

    Status = RtlUnicodeStringToOemString(&Buffer, &Unicode, FALSE);
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer.Buffer );
        }
    return Buffer.Buffer;
}


DWORD
WINAPI
GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    )

/*++

Routine Description:

    The value of an environment variable of the current process is available
    using this API.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        environment variable whose value is being requested.

    lpBuffer - Pointer to a buffer that is to contain the value of the
        specified variable name.

    nSize - Specifies the maximum number of bytes that can be stored in
        the buffer pointed to by lpBuffer, including the null terminator.

Return Value:

    The actual number of bytes stored in the memory pointed to by the
    lpBuffer parameter.  The return value is zero if the environment
    variable name was not found in the current process's environment.
    On successful return (returned value < nSize) the returned value
    does not include the null terminator byte. On buffer overflow failure
    (returned value > nSize), the returned value does include the null
    terminator byte.

--*/

{
    NTSTATUS Status;
    NTSTATUS Status2;
    STRING Value, Name;
    UNICODE_STRING UnicodeName;
    UNICODE_STRING UnicodeValue;
    DWORD iSize;

    RtlInitString( &Name, lpName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return ( 0 );
        }

    if ( nSize > (MAXUSHORT >> 1)-2 ) {
        iSize = (MAXUSHORT >> 1)-2;
        }
    else {
        iSize = nSize;
        }

    UnicodeValue.MaximumLength = (USHORT)(iSize ? iSize - 1 : iSize)*sizeof(WCHAR);
    UnicodeValue.Buffer = (PWCHAR)
        RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), UnicodeValue.MaximumLength );
    if (UnicodeValue.Buffer == NULL) {
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return ( 0 );
        }

    Status = RtlQueryEnvironmentVariable_U( NULL,
                                            &UnicodeName,
                                            &UnicodeValue
                                          );
    if (NT_SUCCESS( Status ) && (nSize == 0)) {
        Status = STATUS_BUFFER_OVERFLOW; // No room for terminator
    }

    if( Status != STATUS_BUFFER_TOO_SMALL ) RtlFreeUnicodeString( &UnicodeName );

    if (NT_SUCCESS( Status )) {

        if ( nSize > MAXUSHORT-2 ) {
            iSize = MAXUSHORT-2;
            }
        else {
            iSize = nSize;
            }

        Value.Buffer = lpBuffer;
        Value.MaximumLength = (USHORT)iSize;
        Status2 = RtlUnicodeStringToAnsiString( &Value, &UnicodeValue, FALSE );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
        if (!NT_SUCCESS( Status2 )) {
            BaseSetLastNTError( Status2 );
            return ( 0 );
            }
        lpBuffer[ Value.Length ] = '\0';
        return( Value.Length );
        }
    else {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            DWORD dwAnsiStringSize = 0;

            UnicodeValue.MaximumLength = UnicodeValue.Length + sizeof(WCHAR); // for NULL
            UnicodeValue.Buffer = (PWCHAR)
                RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), UnicodeValue.MaximumLength );

            if (UnicodeValue.Buffer == NULL) {
                BaseSetLastNTError( STATUS_NO_MEMORY );
                return ( 0 );
            }

            Status = RtlQueryEnvironmentVariable_U( NULL ,
                                                    &UnicodeName ,
                                                    &UnicodeValue
                                                  );
            RtlFreeUnicodeString( &UnicodeName );

            if( NT_SUCCESS( Status ) ) {
                dwAnsiStringSize = RtlUnicodeStringToAnsiSize( &UnicodeValue );
                }

            RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );

            // dwAnsiStringSize alreay keeps the size including NULL character.

            return dwAnsiStringSize;
            }
        else {
            BaseSetLastNTError( Status );
            return( 0 );
            }
        }
}


BOOL
WINAPI
SetEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpValue
    )

/*++

Routine Description:

    The value of an environment variable of the current process is available
    using this API.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        environment variable whose value is being requested.

    lpValue - An optional pointer to a null terminated string that is to be
        the new value of the specified variable name.  If this parameter
        is NULL, then the variable will be deleted from the current
        process's environment.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    STRING Name;
    STRING Value;
    UNICODE_STRING UnicodeName;
    UNICODE_STRING UnicodeValue;

    RtlInitString( &Name, lpName );
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &Name, TRUE);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError( Status );
        return FALSE;
        }

    if (ARGUMENT_PRESENT( lpValue )) {
        RtlInitString( &Value, lpValue );
        Status = RtlAnsiStringToUnicodeString(&UnicodeValue, &Value, TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            RtlFreeUnicodeString(&UnicodeName);
            return FALSE;
            }
        Status = RtlSetEnvironmentVariable( NULL, &UnicodeName, &UnicodeValue);
        RtlFreeUnicodeString(&UnicodeValue);
        }
    else {
        Status = RtlSetEnvironmentVariable( NULL, &UnicodeName, NULL);
        }
    RtlFreeUnicodeString(&UnicodeName);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}


DWORD
WINAPI
GetEnvironmentVariableW(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    DWORD iSize;

    if (nSize > UNICODE_STRING_MAX_CHARS - 1) {
        iSize = UNICODE_STRING_MAX_BYTES - sizeof (WCHAR);
    } else {
        if (nSize > 0) {
            iSize = (nSize - 1) * sizeof (WCHAR);
        } else {
            iSize = 0;
        }
    }

    Status = RtlInitUnicodeStringEx (&Name, lpName);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return( 0 );
    }

    Value.Buffer = lpBuffer;
    Value.Length = 0;
    Value.MaximumLength = (USHORT)iSize;

    Status = RtlQueryEnvironmentVariable_U (NULL,
                                            &Name,
                                            &Value);

    if (NT_SUCCESS (Status) && (nSize == 0)) {
        Status = STATUS_BUFFER_OVERFLOW; // No room for terminator
    }

    if (NT_SUCCESS (Status)) {
        lpBuffer[Value.Length / sizeof(WCHAR)] = L'\0';
        return (Value.Length / sizeof(WCHAR));
    } else {
        if (Status == STATUS_BUFFER_TOO_SMALL) {
            return Value.Length / sizeof(WCHAR) + 1;
        } else {
            BaseSetLastNTError (Status);
            return (0);
        }
    }
}


BOOL
WINAPI
SetEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpValue
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;

    Status = RtlInitUnicodeStringEx (&Name, lpName);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return (FALSE);
    }
    

    if (ARGUMENT_PRESENT (lpValue)) {
        Status = RtlInitUnicodeStringEx (&Value, lpValue);
        if (!NT_SUCCESS (Status)) {
            BaseSetLastNTError (Status);
            return (FALSE);
        }

        Status = RtlSetEnvironmentVariable (NULL, &Name, &Value);
    } else {
        Status = RtlSetEnvironmentVariable (NULL, &Name, NULL);
    }

    if (NT_SUCCESS (Status)) {
        return (TRUE);
    } else {
        BaseSetLastNTError (Status);
        return (FALSE);
    }
}


DWORD
WINAPI
ExpandEnvironmentStringsA(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    )
{
    NTSTATUS Status;
    ANSI_STRING Source, Destination;
    ULONG Length;
    UNICODE_STRING UnicodeSource;
    UNICODE_STRING UnicodeDest;
    DWORD iSize;

    if ( nSize > (MAXUSHORT >> 1)-2 ) {
        iSize = (MAXUSHORT >> 1)-2;
        }
    else {
        iSize = nSize;
        }

    if( lpDst != NULL )
        *lpDst = '\0';
    RtlInitString( &Source, lpSrc );
    Status = RtlAnsiStringToUnicodeString( &UnicodeSource, &Source, TRUE );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return 0;
        }
    UnicodeDest.MaximumLength = (USHORT)(iSize ? iSize - 1 : iSize)*sizeof(WCHAR);
    UnicodeDest.Buffer = (PWCHAR)
        RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), UnicodeDest.MaximumLength );
    if (UnicodeDest.Buffer == NULL) {
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return 0;
        }

    Length = 0;
    Status = RtlExpandEnvironmentStrings_U( NULL,
                                            (PUNICODE_STRING)&UnicodeSource,
                                            (PUNICODE_STRING)&UnicodeDest,
                                            &Length
                                          );
    if (NT_SUCCESS( Status )) {

        if ( nSize > MAXUSHORT-2 ) {
            iSize = MAXUSHORT-2;
            }
        else {
            iSize = nSize;
            }

        Destination.MaximumLength = (USHORT)iSize;
        Destination.Buffer = lpDst;
        Status = RtlUnicodeStringToAnsiString(&Destination,&UnicodeDest,FALSE);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDest.Buffer);
        RtlFreeUnicodeString(&UnicodeSource);
        if (!NT_SUCCESS( Status )) {
            *lpDst = '\0';
            BaseSetLastNTError( Status );
            return 0;
            }
        return( Length / sizeof( WCHAR ) );
        }
    else if (Status == STATUS_BUFFER_TOO_SMALL) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDest.Buffer);
        RtlFreeUnicodeString(&UnicodeSource);
        return( (Length / sizeof( WCHAR )) + 1 );
        }
    else {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDest.Buffer);
        RtlFreeUnicodeString(&UnicodeSource);
        BaseSetLastNTError( Status );
        return 0;
        }
}


DWORD
WINAPI
ExpandEnvironmentStringsW(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    )
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;
    DWORD iSize;

    if ( nSize > (MAXUSHORT >> 1)-2 ) {
        iSize = (MAXUSHORT >> 1)-2;
        }
    else {
        iSize = nSize;
        }

    RtlInitUnicodeString( &Source, lpSrc );
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(iSize * sizeof( WCHAR ));
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U( NULL,
                                            &Source,
                                            &Destination,
                                            &Length
                                          );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length / sizeof( WCHAR ) );
        }
    else {
        BaseSetLastNTError( Status );
        return( 0 );
        }
}


UINT
WINAPI
WinExec(
    LPCSTR lpCmdLine,
    UINT uCmdShow
    )

/*++

Routine Description:

    This function executes the Windows or non-Windows application
    identified by the lpCmdLine parameter.  The uCmdShow parameter
    specifies the initial state of the application's main window when it
    is created.

    The WinExec function is obsolete.  CreateProcess is the prefered
    mechanism for creating a process to run an application.  The Win32
    implementation of WinExec is layered on top of CreateProcess.  For
    each parameter to CreateProcess, the following section describes how
    the parameter is formed, and its meaning with respect to WinExec.

        lpApplicationName - NULL

        lpCommandLine - The value of lpCmdLine is passed.

        lpProcessAttributes - A value of NULL is used.

        lpThreadAttributes - A value of NULL is used.

        bInheritHandles - A value of FALSE is used.

        dwCreationFlags - A value of 0 is used

        lpEnvironment - The value of NULL is used.

        lpCurrentDirectory - A value of NULL is used.

        lpStartupInfo - The structure is initialized to NULL.  The cb
            field is initialized, and the wShowWindow field is set to
            the value of uCmdShow.

        lpProcessInformation.hProcess - The handle is immediately closed.

        lpProcessInformation.hThread - The handle is immediately closed.

Arguments:

    lpCmdLine - Points to a null-terminated character string that
        contains the command line (filename plus optional parameters)
        for the application to be executed.  If the lpCmdLine string
        does not contain a directory path, Windows will search for the
        executable file in this order:

        1.  The current directory

        2.  The Windows directory (the directory containing WIN.COM);
            the GetWindowsDirectory function obtains the pathname of
            this directory

        3.  The Windows system directory (the directory containing such
            system files as KERNEL.EXE); the GetSystemDirectory function
            obtains the pathname of this directory

        4.  The directories listed in the PATH environment variable

    uCmdShow - Specifies how a Windows application window is to be
        shown.  See the description of the ShowWindow function for a
        list of the acceptable values for the uCmdShow parameter.  For a
        non-Windows application, the PIF file, if any, for the
        application determines the window state.

Return Value:

    33 - The operation was successful

     2 - File not found.

     3 - Path not found.

    11 - Invalid .EXE file (non-Win32 .EXE or error in .EXE image).

     0 - Out of memory or system resources.


--*/

{
    STARTUPINFOA StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL CreateProcessStatus;
    DWORD ErrorCode;

retry:
    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = (WORD)uCmdShow;
    CreateProcessStatus = CreateProcess(
                            NULL,
                            (LPSTR)lpCmdLine,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInformation
                            );

    if ( CreateProcessStatus ) {
        //
        // Wait for the started process to go idle. If it doesn't go idle in
        // 10 seconds, return anyway.
        //
        if (UserWaitForInputIdleRoutine != NULL)
            (*UserWaitForInputIdleRoutine)(ProcessInformation.hProcess,
                    DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT);
        NtClose(ProcessInformation.hProcess);
        NtClose(ProcessInformation.hThread);
        return 33;
        }
    else {
        //
        // If CreateProcess failed, then look at GetLastError to determine
        // appropriate return code.
        //

        //
        // Take a closer look at CreateProcess errors. For instance,
        // Claris Works 5.0 launches hyperterm.exe as hyperterm.exe"<null>
        // the trailing " is causing problems so nuke it and then retry.
        //

        if ( !lstrcmpiA(lpCmdLine,"hypertrm.exe\"") ) {
            lpCmdLine = "hypertrm.exe";
            goto retry;
            }

        ErrorCode = GetLastError();
        switch ( ErrorCode ) {
            case ERROR_FILE_NOT_FOUND:
                return 2;

            case ERROR_PATH_NOT_FOUND:
                return 3;

            case ERROR_BAD_EXE_FORMAT:
                return 11;

            default:
                return 0;
            }
        }
}

DWORD
WINAPI
LoadModule(
    LPCSTR lpModuleName,
    LPVOID lpParameterBlock
    )

/*++

Routine Description:

    This function loads and executes a Windows program.  This function
    is designed to layer directly on top of CreateProcess.

    The LoadModule function is obsolete.  CreateProcess is the prefered
    mechanism for creating a process to run an application.  The Win32
    implementation of LoadModule is layered on top of CreateProcess.
    For each parameter to CreateProcess, the following section describes
    how the parameter is formed, and its meaning with respect to
    LoadModule.

        lpApplicationName - The value of lpModuleName

        lpCommandLine - The value of lpParameterBlock->lpCmdLine.

        lpProcessAttributes - A value of NULL is used.

        lpThreadAttributes - A value of NULL is used.

        bInheritHandles - A value of FALSE is used.

        dwCreationFlags - A value of 0 is used

        lpEnvironment - The value of lpEnvAddress from the parameter
            block is used.

        lpCurrentDirectory - A value of NULL is used.

        lpStartupInfo - The structure is initialized to NULL.  The cb
            field is initialized, and the wShowWindow field is set to
            the value of second word of the lpCmdShow field of the
            parameter block is used.

        lpProcessInformation.hProcess - The handle is immediately closed.

        lpProcessInformation.hThread - The handle is immediately closed.

Arguments:

    lpModuleName - Points to a null-terminated string that contains the
        filename of the application to be run.  If the lpModuleName
        string does not contain a directory path, Windows will search
        for the executable file in this order:

        1.  The current directory

        2.  The Windows directory.  the GetWindowsDirectory function
            obtains the pathname of this directory

        3.  The Windows system directory (the directory containing such
            system files as KERNEL.EXE); the GetSystemDirectory function
            obtains the pathname of this directory

        4.  The directories listed in the PATH environment variable

    lpParameterBlock - Points to a data structure consisting of four
        fields that defines a parameter block.  This data structure
        consists of the following fields:

        lpEnvAddress - Points to an array of NULL terminated strings
            that supply the environment strings for the new process.
            The array has a value of NULL as its last entry.  A value of
            NULL for this parameter causes the new process to start with
            the same environment as the calling process.

        lpCmdLine - Points to a null-terminated string that contains a
            correctly formed command line.

        lpCmdShow - Points to a structure containing two WORD values.
            The first value must always be set to two.  The second value
            specifies how the application window is to be shown and is used
            to supply the dwShowWindow parameter to CreateProcess.  See
            the description of the <uCmdShow> paramter of the ShowWindow
            function for a list of the acceptable values.

        dwReserved - Is reserved and must be NULL.

        All unused fields should be set to NULL, except for lpCmdLine,
        which must point to a null string if it is not used.

Return Value:

    33 - The operation was successful

     2 - File not found.

     3 - Path not found.

    11 - Invalid .EXE file (non-Win32 .EXE or error in .EXE image).

     0 - Out of memory or system resources.

--*/

{
    STARTUPINFOA StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL CreateProcessStatus;
    PLOAD_MODULE_PARAMS LoadModuleParams;
    LPSTR NameBuffer;
    LPSTR CommandLineBuffer;
    DWORD Length;
    DWORD CreateFlag;

    CreateFlag = 0;
    LoadModuleParams = (PLOAD_MODULE_PARAMS)lpParameterBlock;

    if ( LoadModuleParams->dwReserved ||
         LoadModuleParams->lpCmdShow->wMustBe2 != 2 ) {

        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return 0;
        }
    CommandLineBuffer = NULL;
    NameBuffer = NULL;
    try {

        //
        // Locate the image
        //

        NameBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), MAX_PATH);

        Length = SearchPath(
                    NULL,
                    lpModuleName,
                    ".exe",
                    MAX_PATH,
                    NameBuffer,
                    NULL
                    );
        if ( !Length || Length >= MAX_PATH ) {

            //
            // If we search pathed, then return file not found.
            // otherwise, try to be more specific.
            //
            RTL_PATH_TYPE PathType;
            HANDLE hFile;
            UNICODE_STRING u;
            ANSI_STRING a;

            RtlInitAnsiString(&a,lpModuleName);
            if ( !NT_SUCCESS(RtlAnsiStringToUnicodeString(&u,&a,TRUE)) ) {
                if ( NameBuffer ) {
                    RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
                    }
                return 2;
                }
            PathType = RtlDetermineDosPathNameType_U(u.Buffer);
            RtlFreeUnicodeString(&u);
            if ( PathType != RtlPathTypeRelative ) {

                //
                // The failed open should set get last error properly.
                //

                hFile = CreateFile(
                            lpModuleName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
                RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
                if ( hFile != INVALID_HANDLE_VALUE ) {
                    CloseHandle(hFile);
                    return 2;
                    }
                return GetLastError();
                }
            else {
                RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
                return 2;
                }
            }

        RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow =
            LoadModuleParams->lpCmdShow->wShowWindowValue;

        CommandLineBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (ULONG)LoadModuleParams->lpCmdLine[0]+1+Length+1);

        RtlMoveMemory(CommandLineBuffer,NameBuffer,Length);
        CommandLineBuffer[Length] = ' ';
        RtlMoveMemory(&CommandLineBuffer[Length+1],&LoadModuleParams->lpCmdLine[1],(ULONG)LoadModuleParams->lpCmdLine[0]);
        CommandLineBuffer[Length+1+LoadModuleParams->lpCmdLine[0]] = '\0';

        CreateProcessStatus = CreateProcess(
                                NameBuffer,
                                CommandLineBuffer,
                                NULL,
                                NULL,
                                FALSE,
                                CreateFlag,
                                LoadModuleParams->lpEnvAddress,
                                NULL,
                                &StartupInfo,
                                &ProcessInformation
                                );
        RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
        NameBuffer = NULL;
        RtlFreeHeap(RtlProcessHeap(), 0,CommandLineBuffer);
        CommandLineBuffer = NULL;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0,CommandLineBuffer);
        BaseSetLastNTError(GetExceptionCode());
        return 0;
        }

    if ( CreateProcessStatus ) {

        //
        // Wait for the started process to go idle. If it doesn't go idle in
        // 10 seconds, return anyway.
        //

        if (UserWaitForInputIdleRoutine != NULL)
            (*UserWaitForInputIdleRoutine)(ProcessInformation.hProcess,
                    DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT);
        NtClose(ProcessInformation.hProcess);
        NtClose(ProcessInformation.hThread);
        return 33;
        }
    else {

        //
        // If CreateProcess failed, then look at GetLastError to determine
        // appropriate return code.
        //

        Length = GetLastError();
        switch ( Length ) {
            case ERROR_FILE_NOT_FOUND:
                return 2;

            case ERROR_PATH_NOT_FOUND:
                return 3;

            case ERROR_BAD_EXE_FORMAT:
                return 11;

            default:
                return 0;
            }
        }
}

HANDLE
WINAPI
GetCurrentProcess(
    VOID
    )

/*++

Routine Description:

    A pseudo handle to the current process may be retrieved using
    GetCurrentProcess.

    A special constant is exported by Win32 that is interpreted as a
    handle to the current process.  This handle may be used to specify
    the current process whenever a process handle is required.  On
    Win32, this handle has PROCESS_ALL_ACCESS to the current process.
    On NT/Win32, this handle has the maximum access allowed by any
    security descriptor placed on the current process.

Arguments:

    None.

Return Value:

    Returns the pseudo handle of the current process.

--*/

{
    return NtCurrentProcess();
}

DWORD
WINAPI
GetCurrentProcessId(
    VOID
    )

/*++

Routine Description:

    The process ID of the current process may be retrieved using
    GetCurrentProcessId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the process ID of the currently
    executing process.  The return value may be used to open a handle to
    a process.

--*/

{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess);
}

DWORD
APIENTRY
GetProcessId(
    HANDLE Process
    )
/*++

Routine Description:

    Gets the process ID of the process open via the specified handle

Arguments:

    Process - Handle of the process to do the query on

Return Value:

    Returns a unique value representing the process ID of the
    executing process.  The return value may be used to identify a process
    in the system. If the function fails the return value is zero.

--*/

{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION pbi;

    Status = NtQueryInformationProcess (Process,
                                        ProcessBasicInformation,
                                        &pbi,
                                        sizeof (pbi),
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return 0;
    }

    return  (DWORD) pbi.UniqueProcessId;
}

BOOL
WINAPI
ReadProcessMemory(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesRead
    )

/*++

Routine Description:

    Memory within a specified process can be read using
    ReadProcessMemory.

    This function copies the data in the specified address range from
    the specified process into the specified buffer of the current
    process.  The specified process does not have to be being debugged
    in order for this API to operate.  The caller must simply have a
    handle to the process that was created with PROCESS_VM_READ access.

Arguments:

    hProcess - Supplies an open handle to a process whose memory is to
        be read.  The handle must have been created with PROCESS_VM_READ
        access to the process.

    lpBaseAddress - Supplies the base address in the specified process
        to be read.  Before any data transfer occurs, the system
        verifies that all data within the base address and the specified
        size is accessible for read access.  If this is the case, then
        the API proceeds.  Otherwise the API fail.

    lpBuffer - Supplies the address of a buffer which receives the
        contents from the specified process address space.

    nSize - Supplies the requested number of bytes to read from the
        specified process.

    lpNumberOfBytesRead - An optional parameter, that if supplied
        receives the actual number of bytes transferred into the
        specified buffer.  This can be different than the value of nSize
        if the requested read crosses into an area of the process that
        is inaccessible (and that was made inaccessible during the data
        transfer).  If this occurs a value of FALSE is returned and
        GetLastError returns a "short read" error indicator.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    SIZE_T NtNumberOfBytesRead;

    Status = NtReadVirtualMemory(
                hProcess,
                (PVOID)lpBaseAddress,
                lpBuffer,
                nSize,
                &NtNumberOfBytesRead
                );

    if ( lpNumberOfBytesRead != NULL ) {
        *lpNumberOfBytesRead = NtNumberOfBytesRead;
        }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOL
WINAPI
WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesWritten
    )

/*++

Routine Description:

    Memory within a specified process can be written using
    WriteProcessMemory.

    This function copies the from the specified buffer in the current
    process to the address range of the specified process.  The
    specified process does not have to be being debugged in order for
    this API to operate.  The caller must simply have a handle to the
    process that was created with PROCESS_VM_WRITE access.

Arguments:

    hProcess - Supplies an open handle to a process whose memory is to
        be written.  The handle must have been created with PROCESS_VM_WRITE
        access to the process.

    lpBaseAddress - Supplies the base address in the specified process
        to be written.  Before any data transfer occurs, the system
        verifies that all data within the base address and the specified
        size is accessible for write access.  If this is the case, then
        the API proceeds.  Otherwise the API fail.

    lpBuffer - Supplies the address of a buffer which supplies the data
        to be written into the specified process address space.

    nSize - Supplies the requested number of bytes to write into the
        specified process.

    lpNumberOfBytesWritten - An optional parameter, that if supplied
        receives the actual number of bytes transferred into the
        specified process.  This can be different than the value of
        nSize if the requested write crosses into an area of the process
        that is inaccessible (and that was made inaccessible during the
        data transfer).  .  If this occurs a value of FALSE is returned
        and GetLastError returns a "short write" error indicator.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status, xStatus;
    ULONG OldProtect;
    SIZE_T RegionSize;
    PVOID Base;
    SIZE_T NtNumberOfBytesWritten;

    //
    // Set the protection to allow writes
    //

    RegionSize =  nSize;
    Base = lpBaseAddress;
    Status = NtProtectVirtualMemory(
                hProcess,
                &Base,
                &RegionSize,
                PAGE_READWRITE,
                &OldProtect
                );
    if ( NT_SUCCESS(Status) ) {

        //
        // See if previous protection was writable. If so,
        // then reset protection and do the write.
        // Otherwise, see if previous protection was read-only or
        // no access. In this case, don't do the write, just fail
        //

        if ( (OldProtect & PAGE_READWRITE) == PAGE_READWRITE ||
             (OldProtect & PAGE_WRITECOPY) == PAGE_WRITECOPY ||
             (OldProtect & PAGE_EXECUTE_READWRITE) == PAGE_EXECUTE_READWRITE ||
             (OldProtect & PAGE_EXECUTE_WRITECOPY) == PAGE_EXECUTE_WRITECOPY ) {

            Status = NtProtectVirtualMemory(
                        hProcess,
                        &Base,
                        &RegionSize,
                        OldProtect,
                        &OldProtect
                        );
            Status = NtWriteVirtualMemory(
                        hProcess,
                        lpBaseAddress,
                        lpBuffer,
                        nSize,
                        &NtNumberOfBytesWritten
                        );

            if ( lpNumberOfBytesWritten != NULL ) {
                *lpNumberOfBytesWritten = NtNumberOfBytesWritten;
                }

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            NtFlushInstructionCache(hProcess,lpBaseAddress,nSize);
            return TRUE;
            }
        else {

            //
            // See if the previous protection was read only or no access. If
            // this is the case, restore the previous protection and return
            // an access violation error.
            //
            if ( (OldProtect & PAGE_NOACCESS) == PAGE_NOACCESS ||
                 (OldProtect & PAGE_READONLY) == PAGE_READONLY ) {

                Status = NtProtectVirtualMemory(
                            hProcess,
                            &Base,
                            &RegionSize,
                            OldProtect,
                            &OldProtect
                            );
                BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
                return FALSE;
                }
            else {

                //
                // The previous protection must have been code and the caller
                // is trying to set a breakpoint or edit the code. Do the write
                // and then restore the previous protection.
                //

                Status = NtWriteVirtualMemory(
                            hProcess,
                            lpBaseAddress,
                            lpBuffer,
                            nSize,
                            &NtNumberOfBytesWritten
                            );

                if ( lpNumberOfBytesWritten != NULL ) {
                    *lpNumberOfBytesWritten = NtNumberOfBytesWritten;
                    }

                xStatus = NtProtectVirtualMemory(
                            hProcess,
                            &Base,
                            &RegionSize,
                            OldProtect,
                            &OldProtect
                            );
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
                    return STATUS_ACCESS_VIOLATION;
                    }
                NtFlushInstructionCache(hProcess,lpBaseAddress,nSize);
                return TRUE;
                }
            }
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

VOID
WINAPI
FatalAppExitW(
    UINT uAction,
    LPCWSTR lpMessageText
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ULONG Response;
    ULONG_PTR ErrorParameters[1];

    RtlInitUnicodeString(&UnicodeString,lpMessageText);

    ErrorParameters[0] = (ULONG_PTR)&UnicodeString;

    Status =NtRaiseHardError( STATUS_FATAL_APP_EXIT | HARDERROR_OVERRIDE_ERRORMODE,
                              1,
                              1,
                              ErrorParameters,
#if DBG
                              OptionOkCancel,
#else
                              OptionOk,
#endif
                              &Response
                            );


    if ( NT_SUCCESS(Status) && Response == ResponseCancel ) {
        return;
        }
    else {
        ExitProcess(0);
        }
}


VOID
WINAPI
FatalAppExitA(
    UINT uAction,
    LPCSTR lpMessageText
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(
        &AnsiString,
        lpMessageText
        );
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        ExitProcess(0);
        }
    FatalAppExitW(uAction,Unicode->Buffer);
}

VOID
WINAPI
FatalExit(
    int ExitCode
    )
{
#if DBG
    char Response[ 2 ];
    DbgPrint("FatalExit...\n");
    DbgPrint("\n");

    while (TRUE) {
        DbgPrompt( "A (Abort), B (Break), I (Ignore)? ",
                   Response,
                   sizeof( Response )
                 );
        switch (Response[0]) {
            case 'B':
            case 'b':
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'A':
            case 'a':
                ExitProcess(ExitCode);
                break;
            }
        }
#endif
    ExitProcess(ExitCode);
}

BOOL
WINAPI
IsProcessorFeaturePresent(
    DWORD ProcessorFeature
    )
{
    BOOL rv;

    if ( ProcessorFeature < PROCESSOR_FEATURE_MAX ) {
        rv = (BOOL)(USER_SHARED_DATA->ProcessorFeatures[ProcessorFeature]);
        }
    else {
        rv = FALSE;
        }
    return rv;
}


VOID
GetSystemInfoInternal(
    IN PSYSTEM_BASIC_INFORMATION BasicInfo,
    IN PSYSTEM_PROCESSOR_INFORMATION ProcessorInfo,
    OUT LPSYSTEM_INFO lpSystemInfo
    )
/*++

Routine Description:

    The GetSystemInfo function is used to return information about the
    current system.  This includes the processor type, page size, oem
    id, and other interesting pieces of information.

Arguments:

    BasicInfo - Pointer to an initialized SYSTEM_BASIC_INFORMATION structure.
    
    ProcessorInfo - Pointer to an initialized SYSTEM_PROCESSOR_INFORMATION structure.
    
    lpSystemInfo - Returns information about the current system.


Return Value:

    None.

--*/
{
    RtlZeroMemory(lpSystemInfo,sizeof(*lpSystemInfo));

    lpSystemInfo->wProcessorArchitecture = ProcessorInfo->ProcessorArchitecture;
    lpSystemInfo->wReserved = 0;
    lpSystemInfo->dwPageSize = BasicInfo->PageSize;
    lpSystemInfo->lpMinimumApplicationAddress = (LPVOID)BasicInfo->MinimumUserModeAddress;
    lpSystemInfo->lpMaximumApplicationAddress = (LPVOID)BasicInfo->MaximumUserModeAddress;
    lpSystemInfo->dwActiveProcessorMask = BasicInfo->ActiveProcessorsAffinityMask;
    lpSystemInfo->dwNumberOfProcessors = BasicInfo->NumberOfProcessors;
    lpSystemInfo->wProcessorLevel = ProcessorInfo->ProcessorLevel;
    lpSystemInfo->wProcessorRevision = ProcessorInfo->ProcessorRevision;

    if (ProcessorInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        if (ProcessorInfo->ProcessorLevel == 3) {
            lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_386;
            }
        else
        if (ProcessorInfo->ProcessorLevel == 4) {
            lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_486;
            }
        else {
            lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_PENTIUM;
            }
        }
    else
    if (ProcessorInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_MIPS) {
        lpSystemInfo->dwProcessorType = PROCESSOR_MIPS_R4000;
        }
    else
    if (ProcessorInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA) {
        lpSystemInfo->dwProcessorType = PROCESSOR_ALPHA_21064;
        }
    else
    if (ProcessorInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_PPC) {
        lpSystemInfo->dwProcessorType = 604;  // backward compatibility
        }
    else
    if (ProcessorInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {
        lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_IA64;
        }
    else {
        lpSystemInfo->dwProcessorType = 0;
        }

    lpSystemInfo->dwAllocationGranularity = BasicInfo->AllocationGranularity;

    //
    // for apps less than 3.51, then return 0 in dwReserved. This allows borlands
    // debugger to continue to run since it mistakenly used dwReserved
    // as AllocationGranularity
    //

    if ( GetProcessVersion(0) < 0x30033 ) {
        lpSystemInfo->wProcessorLevel = 0;
        lpSystemInfo->wProcessorRevision = 0;
        }

    return;
}

VOID
WINAPI
GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    )

/*++

Routine Description:

    The GetSystemInfo function is used to return information about the
    current system.  This includes the processor type, page size, oem
    id, and other interesting pieces of information.

Arguments:

    lpSystemInfo - Returns information about the current system.

        SYSTEM_INFO Structure:

        WORD wProcessorArchitecture - returns the architecture of the
            processors in the system: e.g. Intel, Mips, Alpha or PowerPC

        DWORD dwPageSize - Returns the page size.  This is specifies the
            granularity of page protection and commitment.

        LPVOID lpMinimumApplicationAddress - Returns the lowest memory
            address accessible to applications and DLLs.

        LPVOID lpMaximumApplicationAddress - Returns the highest memory
            address accessible to applications and DLLs.

        DWORD dwActiveProcessorMask - Returns a mask representing the
            set of processors configured into the system.  Bit 0 is
            processor 0, bit 31 is processor 31.

        DWORD dwNumberOfProcessors - Returns the number of processors in
            the system.

        WORD wProcessorLevel - Returns the level of the processors in the
            system.  All processors are assumed to be of the same level,
            stepping, and are configured with the same options.

        WORD wProcessorRevision - Returns the revision or stepping of the
            processors in the system.  All processors are assumed to be
            of the same level, stepping, and are configured with the
            same options.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;


    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    Status = NtQuerySystemInformation(
                SystemProcessorInformation,
                &ProcessorInfo,
                sizeof(ProcessorInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    GetSystemInfoInternal(
        &BasicInfo,
        &ProcessorInfo,
        lpSystemInfo);

    return;
}

VOID
WINAPI
GetNativeSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    )

/*++

Routine Description:

    The GetSystemInfo function is used to return information about the
    native current system.  The function returns the native system information 
    ragarding the processor type, page size, oem id, and other interesting pieces of information
    when running inside a Wow64 process. If this function is called from a non-Wow64
    process, then the results would be the same as of GetSystemInfo.

Arguments:

    lpSystemInfo - Returns information about the current system.

        SYSTEM_INFO Structure:

        WORD wProcessorArchitecture - returns the architecture of the
            processors in the system: e.g. Intel, Mips, Alpha or PowerPC

        DWORD dwPageSize - Returns the page size.  This is specifies the
            granularity of page protection and commitment.

        LPVOID lpMinimumApplicationAddress - Returns the lowest memory
            address accessible to applications and DLLs.

        LPVOID lpMaximumApplicationAddress - Returns the highest memory
            address accessible to applications and DLLs.

        DWORD dwActiveProcessorMask - Returns a mask representing the
            set of processors configured into the system.  Bit 0 is
            processor 0, bit 31 is processor 31.

        DWORD dwNumberOfProcessors - Returns the number of processors in
            the system.

        WORD wProcessorLevel - Returns the level of the processors in the
            system.  All processors are assumed to be of the same level,
            stepping, and are configured with the same options.

        WORD wProcessorRevision - Returns the revision or stepping of the
            processors in the system.  All processors are assumed to be
            of the same level, stepping, and are configured with the
            same options.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;


    Status = RtlGetNativeSystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    Status = RtlGetNativeSystemInformation(
                SystemProcessorInformation,
                &ProcessorInfo,
                sizeof(ProcessorInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    GetSystemInfoInternal(
        &BasicInfo,
        &ProcessorInfo,
        lpSystemInfo);

    return;
}


#if defined(REMOTE_BOOT)
BOOL
WINAPI
GetSystemInfoExA(
    IN SYSTEMINFOCLASS dwSystemInfoClass,
    OUT LPVOID lpSystemInfoBuffer,
    IN OUT LPDWORD nSize
    )

/*++

    ANSI thunk to GetSystemInfoExW

--*/

{
    DWORD requiredSize;
    BOOL isRemoteBoot;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;

    isRemoteBoot = (BOOL)((USER_SHARED_DATA->SystemFlags & SYSTEM_FLAG_REMOTE_BOOT_CLIENT) != 0);

    //
    // Determine the required buffer size.
    //

    switch ( dwSystemInfoClass ) {

    case SystemInfoRemoteBoot:
        requiredSize = sizeof(BOOL);
        break;

    case SystemInfoRemoteBootServerPath:
        if ( isRemoteBoot ) {
            RtlInitUnicodeString( &unicodeString, USER_SHARED_DATA->RemoteBootServerPath );
            requiredSize = RtlUnicodeStringToAnsiSize( &unicodeString );
        } else {

            //
            // This is not a remote boot client. Return success with a
            // zero-length buffer.
            //

            *nSize = 0;
            return TRUE;
        }
        break;

    default:

        //
        // Unrecognized information class.
        //

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the buffer isn't big enough, tell the caller how big the buffer
    // needs to be and return an error.
    //

    if ( *nSize < requiredSize ) {
        *nSize = requiredSize;
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    *nSize = requiredSize;

    //
    // The buffer is big enough. Return the requested information.
    //

    switch ( dwSystemInfoClass ) {

    case SystemInfoRemoteBoot:
        *(LPBOOL)lpSystemInfoBuffer = isRemoteBoot;
        break;

    case SystemInfoRemoteBootServerPath:
        ansiString.Buffer = lpSystemInfoBuffer;
        ansiString.MaximumLength = (USHORT)*nSize;
        RtlUnicodeStringToAnsiString( &ansiString, &unicodeString, FALSE );
        break;

    }

    return TRUE;
}

BOOL
WINAPI
GetSystemInfoExW(
    IN SYSTEMINFOCLASS dwSystemInfoClass,
    OUT LPVOID lpSystemInfoBuffer,
    IN OUT LPDWORD nSize
    )

/*++

Routine Description:

    The GetSystemInfoEx function is used to return information about the
    current system.  It returns different information depending on the
    requested class.

Arguments:

    dwSystemInfoClass - Specifies the class of information to return.

    lpSystemInfoBuffer - Supplies a pointer to a buffer in which the
        requested information is returned. The structure of this buffer
        varies based on dwSystemInfoClass.

    nSize - On input, supplies the length, in bytes, of the buffer. On output,
        return the length of the data written to the buffer, or, if the
        buffer was too small, the required buffer size.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

    If the return value is FALSE and GetLastError returns
    ERROR_BUFFER_OVERFLOW, then the supplied buffer was too small
    too contain all of the information, and nSize returns the
    required buffer size.

--*/
{
    DWORD requiredSize;
    BOOL isRemoteBoot;

    isRemoteBoot = (BOOL)((USER_SHARED_DATA->SystemFlags & SYSTEM_FLAG_REMOTE_BOOT_CLIENT) != 0);

    //
    // Determine the required buffer size.
    //

    switch ( dwSystemInfoClass ) {

    case SystemInfoRemoteBoot:
        requiredSize = sizeof(BOOL);
        break;

    case SystemInfoRemoteBootServerPath:
        if ( isRemoteBoot ) {
            requiredSize = (wcslen(USER_SHARED_DATA->RemoteBootServerPath) + 1) * sizeof(WCHAR);
        } else {

            //
            // This is not a remote boot client. Return success with a
            // zero-length buffer.
            //

            *nSize = 0;
            return TRUE;
        }
        break;

    default:

        //
        // Unrecognized information class.
        //

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the buffer isn't big enough, tell the caller how big the buffer
    // needs to be and return an error.
    //

    if ( *nSize < requiredSize ) {
        *nSize = requiredSize;
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    *nSize = requiredSize;

    //
    // The buffer is big enough. Return the requested information.
    //

    switch ( dwSystemInfoClass ) {

    case SystemInfoRemoteBoot:
        *(LPBOOL)lpSystemInfoBuffer = isRemoteBoot;
        break;

    case SystemInfoRemoteBootServerPath:
        wcscpy( lpSystemInfoBuffer, USER_SHARED_DATA->RemoteBootServerPath );
        break;

    }

    return TRUE;
}
#endif // defined(REMOTE_BOOT)

BOOL
BuildSubSysCommandLine(
    LPWSTR  lpSubSysName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    PUNICODE_STRING SubSysCommandLine
    )
{
    UNICODE_STRING Args;
    UNICODE_STRING Command;
    BOOLEAN        ReturnStatus = TRUE;

    //
    // build the command line as follows:
    // [OS2 | POSIX] /P <full path> /C <original CommandLine>
    //

    // Get application name length
    RtlInitUnicodeString(&Command, lpApplicationName);

    // get lpCommandLine length
    RtlInitUnicodeString(&Args, lpCommandLine);

    SubSysCommandLine->Length = 0;
    SubSysCommandLine->MaximumLength = Command.MaximumLength
                                       + Args.MaximumLength
                                       + (USHORT)32;

    SubSysCommandLine->Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                                 SubSysCommandLine->MaximumLength
                                               );
    if ( SubSysCommandLine->Buffer ) {

        // New command line begins with either L"OS2 /P " or L"POSIX /P "
        RtlAppendUnicodeToString(SubSysCommandLine, lpSubSysName);

        // append full path name
        RtlAppendUnicodeStringToString(SubSysCommandLine, &Command);

        RtlAppendUnicodeToString(SubSysCommandLine, L" /C ");

        // and append to new command line
        RtlAppendUnicodeStringToString(SubSysCommandLine, &Args);

    } else {

        BaseSetLastNTError(STATUS_NO_MEMORY);
        ReturnStatus = FALSE;
    }

    return ReturnStatus;
}




BOOL
WINAPI
SetPriorityClass(
    HANDLE hProcess,
    DWORD dwPriorityClass
    )

/*++

Routine Description:

    This API is used to set the priority class of the specified process.
    PROCESS_SET_INFORMATION and PROCESS_QUERY_INFORMATION access is
    required to the process in order to call this API.  Using this API
    has a dramatic impact on the scheduling characteristics of the
    effected process.  Applications should use this API carefully and
    understand the impact of making a process run in either the Idle or
    High priority classes.

Arguments:

    hProcess - Supplies an open handle to the process whose priority is
        to change.

    dwPriorityClass - Supplies the new priority class for the process.
        The priority class constants are described above.  If more than
        one priority class is specified, the lowest specified priority
        class is used.

Return Value:

    TRUE - The operation was was successful.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    UCHAR PriorityClass;
    BOOL ReturnValue;
    // NOTE: The following construct is used to ensure the PriClass struct
    // is allocated on a dword boundary.  w/o it, the compiler may choose
    // to put it on a word boundary and the NtxxxInformationProces call will
    // fail with a datatype misalignment fault.
    union {
        PROCESS_PRIORITY_CLASS PriClass;
        ULONG x;
    }x;
    PVOID State = NULL;
    ReturnValue = TRUE;
    if (dwPriorityClass & IDLE_PRIORITY_CLASS ) {
        PriorityClass = PROCESS_PRIORITY_CLASS_IDLE;
        }
    else if (dwPriorityClass & BELOW_NORMAL_PRIORITY_CLASS ) {
        PriorityClass = PROCESS_PRIORITY_CLASS_BELOW_NORMAL;
        }
    else if (dwPriorityClass & NORMAL_PRIORITY_CLASS ) {
        PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;
        }
    else if (dwPriorityClass & ABOVE_NORMAL_PRIORITY_CLASS ) {
        PriorityClass = PROCESS_PRIORITY_CLASS_ABOVE_NORMAL;
        }
    else if (dwPriorityClass & HIGH_PRIORITY_CLASS ) {
        PriorityClass =  PROCESS_PRIORITY_CLASS_HIGH;
        }
    else if (dwPriorityClass & REALTIME_PRIORITY_CLASS ) {
        if ( State = BasepIsRealtimeAllowed(TRUE) ) {
            PriorityClass =  PROCESS_PRIORITY_CLASS_REALTIME;
            }
        else {
            PriorityClass =  PROCESS_PRIORITY_CLASS_HIGH;
            }
        }
    else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }
    x.PriClass.PriorityClass = PriorityClass;
    x.PriClass.Foreground = FALSE;

    Status = NtSetInformationProcess(
                hProcess,
                ProcessPriorityClass,
                (PVOID)&x.PriClass,
                sizeof(x.PriClass)
                );

    if ( State ) {
        BasepReleasePrivilege( State );
        }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }
    return ReturnValue;
}

DWORD
WINAPI
GetPriorityClass(
    HANDLE hProcess
    )

/*++

Routine Description:

    This API is used to get the priority class of the specified process.
    PROCESS_QUERY_INFORMATION access is required to the process in order
    to call this API.

Arguments:

    hProcess - Supplies an open handle to the process whose priority is
        to be returned.

Return Value:

    Non-Zero - Returns the priority class of the specified process.

    0 - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    ULONG PriorityClass;
    // NOTE: The following construct is used to ensure the PriClass struct
    // is allocated on a dword boundary.  w/o it, the compiler may choose
    // to put it on a word boundary and the NtxxxInformationProces call will
    // fail with a datatype misalignment fault.
    union _x {
        PROCESS_PRIORITY_CLASS PriClass;
        ULONG x;
    }x;

    PriorityClass = 0;


    Status = NtQueryInformationProcess(
                hProcess,
                ProcessPriorityClass,
                &x.PriClass,
                sizeof(x.PriClass),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }

    switch ( x.PriClass.PriorityClass ) {
        case PROCESS_PRIORITY_CLASS_IDLE:
            PriorityClass = IDLE_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_HIGH:
            PriorityClass = HIGH_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_REALTIME:
            PriorityClass = REALTIME_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_BELOW_NORMAL:
            PriorityClass = BELOW_NORMAL_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_ABOVE_NORMAL:
            PriorityClass = ABOVE_NORMAL_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_NORMAL:
        default:
            PriorityClass = NORMAL_PRIORITY_CLASS;
            break;
        }

    return PriorityClass;
}

BOOL
WINAPI
IsBadReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

Arguments:

    lp - Supplies the base address of the memory that is to be checked
        for read access.

    cb - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    PSZ EndAddress;
    PSZ StartAddress;
    ULONG PageSize;

    PageSize = BASE_SYSINFO.PageSize;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility or alignment.
    //

    if (cb != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lp == NULL) {
            return TRUE;
            }

        StartAddress = (PSZ)lp;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = StartAddress + cb - 1;
        if ( EndAddress < StartAddress ) {
           return TRUE;
            }
        else {
            try {
                *(volatile CHAR *)StartAddress;
                StartAddress = (PCHAR)((ULONG_PTR)StartAddress & (~((LONG)PageSize - 1)));
                EndAddress = (PCHAR)((ULONG_PTR)EndAddress & (~((LONG)PageSize - 1)));
                while (StartAddress != EndAddress) {
                    StartAddress = StartAddress + PageSize;
                    *(volatile CHAR *)StartAddress;
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadHugeReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    )

/*++

    Same as IsBadReadPtr

--*/

{
    return IsBadReadPtr(lp,cb);
}



BOOL
WINAPI
IsBadWritePtr(
    LPVOID lp,
    UINT_PTR cb
    )
/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be written by the calling process.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

    Also not that implementations are free to do a write test by reading
    a value and then writing it back.

Arguments:

    lp - Supplies the base address of the memory that is to be checked
        for write access.

    cb - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for write access.

    FALSE - All pages within the specified range have been successfully
        written.

--*/
{
    PSZ EndAddress;
    PSZ StartAddress;
    ULONG PageSize;

    PageSize = BASE_SYSINFO.PageSize;

    //
    // If the structure has zero length, then do not probe the structure for
    // write accessibility.
    //

    if (cb != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lp == NULL) {
            return TRUE;
            }

        StartAddress = (PCHAR)lp;

        //
        // Compute the ending address of the structure and probe for
        // write accessibility.
        //

        EndAddress = StartAddress + cb - 1;
        if ( EndAddress < StartAddress ) {
            return TRUE;
            }
        else {
            try {
                *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;
                StartAddress = (PCHAR)((ULONG_PTR)StartAddress & (~((LONG)PageSize - 1)));
                EndAddress = (PCHAR)((ULONG_PTR)EndAddress & (~((LONG)PageSize - 1)));
                while (StartAddress != EndAddress) {
                    StartAddress = StartAddress + PageSize;
                    *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadHugeWritePtr(
    LPVOID lp,
    UINT_PTR cb
    )

/*++

    Same as IsBadWritePtr

--*/

{
    return IsBadWritePtr(lp,cb);
}

BOOL
WINAPI
IsBadCodePtr(
    FARPROC lpfn
    )

/*++

    Same as IsBadReadPtr with a length of 1

--*/

{
    return IsBadReadPtr((LPVOID)lpfn,1);
}

BOOL
WINAPI
IsBadStringPtrA(
    LPCSTR lpsz,
    UINT_PTR cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated ANSI string, or the number of bytes specified
    by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    PSZ EndAddress;
    PSZ StartAddress;
    CHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lpsz == NULL) {
            return TRUE;
            }

        StartAddress = (PSZ)lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = StartAddress + cchMax - 1;
        try {
            c = *(volatile CHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile CHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadStringPtrW(
    LPCWSTR lpsz,
    UINT_PTR cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated UNICODE string, or the number of bytes
    specified by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in characters to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    LPCWSTR EndAddress;
    LPCWSTR StartAddress;
    WCHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lpsz == NULL) {
            return TRUE;
            }

        StartAddress = lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = (LPCWSTR)((PSZ)StartAddress + (cchMax*2) - 2);
        try {
            c = *(volatile WCHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile WCHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}

BOOL
WINAPI
SetProcessShutdownParameters(
    DWORD dwLevel,
    DWORD dwFlags
    )

/*++

Routine Description:

    This function sets shutdown parameters for the currently calling
    process. dwLevel is the field that defines this processes shutdown
    order relative to the other processes in the system. Higher levels
    shutdown first, lower levels shutdown last.

Arguments:

    dwLevel - Specifies shutdown order relative to other processes in the
        system. Higher levels shutdown first. System level shutdown orders
        are pre-defined.

    dwFlags - A flags parameter. The flags can be added together:

        SHUTDOWN_NORETRY - If this process takes longer than the user
            specified timeout to shutdown, do not put up a retry dialog
            for the user.

Notes:

    Applications running in the system security context do not get shut down
    by the system. They will get notified of shutdown or logoff through the
    callback installable via SetConsoleCtrlRoutine() (see that for more info).
    They also will get notified in the order specified by the dwLevel
    parameter.

Return Value

    TRUE - Successful in setting the process shutdown parameters.

    FALSE - Unsuccessful in setting the process shutdown parameters.

--*/

{

#if defined(BUILD_WOW6432)

    NTSTATUS Status;

    Status = CsrBasepSetProcessShutdownParam(dwLevel, dwFlags);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;

#else

    BASE_API_MSG m;
    PBASE_SHUTDOWNPARAM_MSG a = &m.u.ShutdownParam;

    a->ShutdownLevel = dwLevel;
    a->ShutdownFlags = dwFlags;

    CsrClientCallServer((PCSR_API_MSG)&m, NULL,
            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
            BasepSetProcessShutdownParam),
            sizeof(*a));

    if (!NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
        BaseSetLastNTError((NTSTATUS)m.ReturnValue);
        return FALSE;
        }

    return TRUE;

#endif

}

BOOL
WINAPI
GetProcessShutdownParameters(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    )

/*++

Routine Description:

    This function gets shutdown parameters for the currently calling
    process. See SetProcessShutdownParameters() for the parameter
    description.

Arguments:

    lpdwLevel - Pointer to the DWORD where the shutdown level information
        should be put.

    lpdwFlags - Pointer to the DWORD where the shutdown flags information
        should be put.
Return Value

    TRUE - Successful in getting the process shutdown parameters.

    FALSE - Unsuccessful in getting the process shutdown parameters.

--*/

{

#if defined(BUILD_WOW6432)

    NTSTATUS Status;

    Status = CsrBasepGetProcessShutdownParam(lpdwLevel, lpdwFlags);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;

#else

    BASE_API_MSG m;
    PBASE_SHUTDOWNPARAM_MSG a = &m.u.ShutdownParam;

    CsrClientCallServer((PCSR_API_MSG)&m, NULL,
            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
            BasepGetProcessShutdownParam),
            sizeof(*a));

    if (!NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
        BaseSetLastNTError((NTSTATUS)m.ReturnValue);
        return FALSE;
        }

    *lpdwLevel = a->ShutdownLevel;
    *lpdwFlags = a->ShutdownFlags;

    return TRUE;

#endif

}


PVOID
BasepIsRealtimeAllowed(
    BOOLEAN LeaveEnabled
    )
{
    PVOID State;
    NTSTATUS Status;

    Status = BasepAcquirePrivilegeEx( SE_INC_BASE_PRIORITY_PRIVILEGE, &State );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }
    if ( !LeaveEnabled ) {
        BasepReleasePrivilege( State );
        State = (PVOID)1;
        }
    return State;
}

BOOL
WINAPI
GetSystemTimes(
    PFILETIME lpIdleTime,
    PFILETIME lpKernelTime,
    PFILETIME lpUserTime
    )

/*++

Routine Description:

    This function is used to return various timing information about
    the system.  On a multiprocessor system, these values are the sum
    of the appropriate times across all processors.

Arguments:

    lpIdleTime - Returns the amount of time that the system has been
        idle.

    lpKernelTime - Returns the amount of time that the system (all
        threads in all processes) has executed in kernel-mode.

    lpUserTime - Returns the amount of time that the system (all
        threads in all processes) has executed in user-mode.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    LONG           Lupe;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
                   ProcessorTimes;
    ULONG          ProcessorTimesCb;
    NTSTATUS       Status;
    ULARGE_INTEGER Sum;
    ULONG          ReturnLength;

#if (!defined(BUILD_WOW6432) && !defined(_WIN64))
#define BASEP_GST_NPROCS BaseStaticServerData->SysInfo.NumberOfProcessors
#else
#define BASEP_GST_NPROCS SysInfo.NumberOfProcessors
#endif

    ProcessorTimesCb = BASEP_GST_NPROCS * sizeof(*ProcessorTimes);

    ProcessorTimes = ((PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION)
                      RtlAllocateHeap(RtlProcessHeap(),
                                      MAKE_TAG(TMP_TAG),
                                      ProcessorTimesCb));
    if (! ProcessorTimes) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                      ProcessorTimes,
                                      ProcessorTimesCb,
                                      &ReturnLength);
    if (! NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (ReturnLength != ProcessorTimesCb) {
        Status = STATUS_INTERNAL_ERROR;
        goto cleanup;
    }

#define BASEP_GST_SUM(DST, SRC)                                         \
    if ( DST ) {                                                        \
        Sum.QuadPart = 0;                                               \
        for (Lupe = 0;                                                  \
             Lupe < BASEP_GST_NPROCS;                                   \
             Lupe++) {                                                  \
            Sum.QuadPart += ProcessorTimes[Lupe]. SRC .QuadPart ;       \
        }                                                               \
        DST ->dwLowDateTime = Sum.LowPart;                              \
        DST ->dwHighDateTime = Sum.HighPart;                            \
    }

    BASEP_GST_SUM(lpIdleTime, IdleTime);
    BASEP_GST_SUM(lpKernelTime, KernelTime);
    BASEP_GST_SUM(lpUserTime, UserTime);

#undef BASEP_GST_SUM
#undef BASEP_GST_NPROCS

    Status = STATUS_SUCCESS;

 cleanup:
    if (ProcessorTimes) {
        RtlFreeHeap(RtlProcessHeap(),
                    MAKE_TAG(TMP_TAG),
                    ProcessorTimes);
    }

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
GetProcessTimes(
    HANDLE hProcess,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    )

/*++

Routine Description:

    This function is used to return various timing information about the
    process specified by hProcess.

    All times are in units of 100ns increments. For lpCreationTime and lpExitTime,
    the times are in terms of the SYSTEM time or GMT time.

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_QUERY_INFORMATION
        access.

    lpCreationTime - Returns a creation time of the process.

    lpExitTime - Returns the exit time of a process.  If the process has
        not exited, this value is not defined.

    lpKernelTime - Returns the amount of time that this process (all
        it's threads), have executed in kernel-mode.

    lpUserTime - Returns the amount of time that this process (all it's
        threads), have executed in user-mode.


Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    KERNEL_USER_TIMES TimeInfo;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    *lpCreationTime = *(LPFILETIME)&TimeInfo.CreateTime;
    *lpExitTime = *(LPFILETIME)&TimeInfo.ExitTime;
    *lpKernelTime = *(LPFILETIME)&TimeInfo.KernelTime;
    *lpUserTime = *(LPFILETIME)&TimeInfo.UserTime;

    return TRUE;

}

BOOL
WINAPI
GetProcessAffinityMask(
    HANDLE hProcess,
    PDWORD_PTR lpProcessAffinityMask,
    PDWORD_PTR lpSystemAffinityMask
    )

/*++

Routine Description:

    This function is used to return the processor affinity mask for the
    selected process and for the system.  The process affinity mask is a
    bit vector where each bit represents the processors that the process
    is allowed to run on.  The system affinity mask is a bit vector
    where each bit represents the processors configured into the system

    The process affinity mask is a proper subset of the system affinity mask.

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_QUERY_INFORMATION
        access.

    lpProcessAffinityMask - Supplies the address of a DWORD that returns the
        specified process' affinity mask.

    lpSystemAffinityMask - Supplies the address of a DWORD that returns the
        system affinity mask.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    PROCESS_BASIC_INFORMATION BasicInformation;
    NTSTATUS Status;
    BOOL rv;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        rv = FALSE;
        }
    else {
        *lpProcessAffinityMask = BasicInformation.AffinityMask;
        *lpSystemAffinityMask = BASE_SYSINFO.ActiveProcessorsAffinityMask;
        rv = TRUE;
        }

    return rv;
}

BOOL
WINAPI
GetProcessWorkingSetSize(
    HANDLE hProcess,
    PSIZE_T lpMinimumWorkingSetSize,
    PSIZE_T lpMaximumWorkingSetSize
    )

/*++

Routine Description:

    This function allows the caller to determine the minimum and maximum working
    set sizes of the specified process. The working set sizes effect the virtual
    memory paging behavior for the process.

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_QUERY_INFORMATION
        access.

    lpMinimumWorkingSetSize - Supplies the address of the variable that
        will receive the minimum working set size of the specified
        process.  The virtual memory manager will attempt to keep at
        least this much memory resident in the process whenever the
        process is active.


    lpMaximumWorkingSetSize - Supplies the address of the variable that
        will receive the maximum working set size of the specified
        process.  In tight memory situations, the virtual memory manager
        will attempt to keep at no more than this much memory resident
        in the process whenever the process is active.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    QUOTA_LIMITS QuotaLimits;
    NTSTATUS Status;
    BOOL rv;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessQuotaLimits,
                &QuotaLimits,
                sizeof(QuotaLimits),
                NULL
                );

    if (NT_SUCCESS(Status)) {
        *lpMinimumWorkingSetSize = QuotaLimits.MinimumWorkingSetSize;
        *lpMaximumWorkingSetSize = QuotaLimits.MaximumWorkingSetSize;
        rv = TRUE;
        }
    else {
        rv = FALSE;
        BaseSetLastNTError(Status);
        }
    return rv;
}

BOOL
WINAPI
SetProcessWorkingSetSize(
    HANDLE hProcess,
    SIZE_T dwMinimumWorkingSetSize,
    SIZE_T dwMaximumWorkingSetSize
    )

/*++

Routine Description:

    This function allows the caller to set the minimum and maximum
    working set sizes of the specified process.  The working set sizes
    effect the virtual memory paging behavior for the process.  The
    specified process's working set be emptied (essentially swapping out
    the process) by specifying the distinguished values 0xffffffff for
    both the minimum and maximum working set sizes.

    If you are not trimming an address space, SE_INC_BASE_PRIORITY_PRIVILEGE
    must be held by the process

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_SET_QUOTA
        access.

    dwMinimumWorkingSetSize - Supplies the minimum working set size for
        the specified process.  The virtual memory manager will attempt
        to keep at least this much memory resident in the process
        whenever the process is active.  A value of (SIZE_T)-1 and the
        same value in dwMaximumWorkingSetSize will temporarily trim the
        working set of the specified process (essentially out swap the
        process).


    dwMaximumWorkingSetSize - Supplies the maximum working set size for
        the specified process.  In tight memory situations, the virtual
        memory manager will attempt to keep at no more than this much
        memory resident in the process whenever the process is active.
        A value of (SIZE_T)-1 and the same value in
        dwMinimumWorkingSetSize will temporarily trim the working set of
        the specified process (essentially out swap the process).

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    QUOTA_LIMITS QuotaLimits;
    NTSTATUS Status, PrivStatus;
    BOOL rv;
    PVOID State;

#ifdef _WIN64
    ASSERT(dwMinimumWorkingSetSize != 0xffffffff && dwMaximumWorkingSetSize != 0xffffffff);
#endif

    if ( dwMinimumWorkingSetSize == 0 || dwMaximumWorkingSetSize == 0 ) {
        Status = STATUS_INVALID_PARAMETER;
        rv = FALSE;
        }
    else {

        QuotaLimits.MaximumWorkingSetSize = dwMaximumWorkingSetSize;
        QuotaLimits.MinimumWorkingSetSize = dwMinimumWorkingSetSize;

        //
        // Attempt to acquire the appropriate privilege.  If this
        // fails, it's no big deal -- we'll attempt to make the
        // NtSetInformationProcess call anyway, in case it turns out
        // to be a decrease operation (which will succeed anyway).
        //
        PrivStatus = BasepAcquirePrivilegeEx( SE_INC_BASE_PRIORITY_PRIVILEGE, &State );

        Status = NtSetInformationProcess (
                   hProcess,
                   ProcessQuotaLimits,
                   &QuotaLimits,
                   sizeof(QuotaLimits)
                   );
        if ( !NT_SUCCESS(Status) ) {
            rv = FALSE;
            }
        else {
            rv = TRUE;
            }

        if ( NT_SUCCESS(PrivStatus) ) {
            //
            // We successfully acquired the privilege above; we need to relinquish it.
            //
            ASSERT( State != NULL );
            BasepReleasePrivilege( State );
            State = NULL;
            }

        }
    if ( !rv ) {
        BaseSetLastNTError(Status);
        }
    return rv;
}

DWORD
WINAPI
GetProcessVersion(
    DWORD ProcessId
    )
{
    PIMAGE_NT_HEADERS NtHeader;
    PPEB Peb;
    HANDLE hProcess;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInfo;
    BOOL b;
    struct {
        USHORT  MajorSubsystemVersion;
        USHORT  MinorSubsystemVersion;
    } SwappedVersion;
    union {
        struct {
            USHORT  MinorSubsystemVersion;
            USHORT  MajorSubsystemVersion;
        };
        DWORD SubsystemVersion;
    } Version;

    PVOID ImageBaseAddress;
    LONG   e_lfanew;

    hProcess = NULL;
    Version.SubsystemVersion = 0;
    try {
        if ( ProcessId == 0 || ProcessId == GetCurrentProcessId() ) {
            Peb = NtCurrentPeb();
            NtHeader = RtlImageNtHeader(Peb->ImageBaseAddress);
            if (! NtHeader) {
                BaseSetLastNTError(STATUS_INVALID_IMAGE_FORMAT);
                goto finally_exit;
            }
            Version.MajorSubsystemVersion = NtHeader->OptionalHeader.MajorSubsystemVersion;
            Version.MinorSubsystemVersion = NtHeader->OptionalHeader.MinorSubsystemVersion;
            }
        else {
            hProcess = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,ProcessId);
            if ( !hProcess ) {
                goto finally_exit;
                }

            //
            // Get the Peb address
            //

            Status = NtQueryInformationProcess(
                        hProcess,
                        ProcessBasicInformation,
                        &ProcessInfo,
                        sizeof( ProcessInfo ),
                        NULL
                        );
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                goto finally_exit;
                }
            Peb = ProcessInfo.PebBaseAddress;


            //
            // Read the image base address from the Peb
            //

            b = ReadProcessMemory(
                    hProcess,
                    &Peb->ImageBaseAddress,
                    &ImageBaseAddress,
                    sizeof(ImageBaseAddress),
                    NULL
                    );
            if ( !b ) {
                goto finally_exit;
                }

            //
            // read e_lfanew from imageheader
            //

            b = ReadProcessMemory(
                    hProcess,
                    &((PIMAGE_DOS_HEADER)ImageBaseAddress)->e_lfanew,
                    &e_lfanew,
                    sizeof(e_lfanew),
                    NULL
                    );

            if ( !b ) {
                goto finally_exit;
                }

            NtHeader = (PIMAGE_NT_HEADERS)((PUCHAR)ImageBaseAddress + e_lfanew);

            //
            // Read subsystem version info
            //

            b = ReadProcessMemory(
                    hProcess,
                    &NtHeader->OptionalHeader.MajorSubsystemVersion,
                    &SwappedVersion,
                    sizeof(SwappedVersion),
                    NULL
                    );
            if ( !b ) {
                goto finally_exit;
                }
            Version.MajorSubsystemVersion = SwappedVersion.MajorSubsystemVersion;
            Version.MinorSubsystemVersion = SwappedVersion.MinorSubsystemVersion;
            }
finally_exit:;
        }
    finally {
        if ( hProcess ) {
            CloseHandle(hProcess);
            }
        }

        return Version.SubsystemVersion;
}


BOOL
WINAPI
SetProcessAffinityMask(
    HANDLE hProcess,
    DWORD_PTR dwProcessAffinityMask
    )
{
    NTSTATUS Status;

    Status = NtSetInformationProcess(
                hProcess,
                ProcessAffinityMask,
                &dwProcessAffinityMask,
                sizeof(dwProcessAffinityMask)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;

}

BOOL
WINAPI
SetProcessPriorityBoost(
    HANDLE hProcess,
    BOOL bDisablePriorityBoost
    )
{
    NTSTATUS Status;
    ULONG DisableBoost;

    DisableBoost = bDisablePriorityBoost ? 1 : 0;

    Status = NtSetInformationProcess(
                hProcess,
                ProcessPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;
}

BOOL
WINAPI
GetProcessPriorityBoost(
    HANDLE hProcess,
    PBOOL pDisablePriorityBoost
    )
{
    NTSTATUS Status;
    DWORD DisableBoost;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }


    *pDisablePriorityBoost = DisableBoost;

    return TRUE;
}

BOOL
WINAPI
GetProcessIoCounters(
    IN HANDLE hProcess,
    OUT PIO_COUNTERS lpIoCounters
    )
{
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessIoCounters,
                lpIoCounters,
                sizeof(IO_COUNTERS),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;
}

BOOL
WINAPI
GetProcessHandleCount(
    IN HANDLE hProcess,
    OUT PDWORD pdwHandleCount
    )

/*++

Routine Description:

    This function returns the count of handles open by the specified process.

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_QUERY_INFORMATION
        access.

    pdwHandleCount - Supplies the location in which the process's
        handle count should be written.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    ULONG HandleCount;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessHandleCount,
                &HandleCount,
                sizeof(HandleCount),
                NULL);

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    *pdwHandleCount = HandleCount;

    return TRUE;
}

BOOL
WINAPI
GetSystemRegistryQuota(
    OUT PDWORD pdwQuotaAllowed,
    OUT PDWORD pdwQuotaUsed
    )

/*++

Routine Description:

    This function returns the system registry's quota.

Arguments:

    pdwQuotaAllowed - Supplies the location in which to write the
        maximum size the registry may attain.

    pdwQuotaUsed - Supplies the location in which to write the amount
        of registry quota currently in use.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    SYSTEM_REGISTRY_QUOTA_INFORMATION QuotaInfo;

    Status = NtQuerySystemInformation(
                SystemRegistryQuotaInformation,
                &QuotaInfo,
                sizeof(QuotaInfo),
                NULL);

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (pdwQuotaAllowed) {
        *pdwQuotaAllowed = QuotaInfo.RegistryQuotaAllowed;
    }

    if (pdwQuotaUsed) {
        *pdwQuotaUsed = QuotaInfo.RegistryQuotaUsed;
    }

    return TRUE;
}


NTSTATUS
BasepConfigureAppCertDlls(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
   UNREFERENCED_PARAMETER( Context );

   return (BasepSaveAppCertRegistryValue( (PLIST_ENTRY)EntryContext,
                                ValueName,
                                ValueData
                              )
         );
}


NTSTATUS
BasepSaveAppCertRegistryValue(
    IN OUT PLIST_ENTRY ListHead,
    IN PWSTR Name,
    IN PWSTR Value OPTIONAL
    )
{
    PLIST_ENTRY Next;
    PBASEP_APPCERT_ENTRY p;
    UNICODE_STRING UnicodeName;

    RtlInitUnicodeString( &UnicodeName, Name );

    Next = ListHead->Flink;
    while ( Next != ListHead ) {
       p = CONTAINING_RECORD( Next,
                              BASEP_APPCERT_ENTRY,
                              Entry
                            );
       if (!RtlCompareUnicodeString( &p->Name, &UnicodeName, TRUE )) {
#if DBG
          DbgPrint("BasepSaveRegistryValue: Entry already exists for Certification Component %ws\n",Name);
#endif
          return( STATUS_SUCCESS );
           }

       Next = Next->Flink;
       }

     p = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), sizeof( *p ) + UnicodeName.MaximumLength );

     if (p == NULL) {
#if DBG
         DbgPrint("BasepSaveRegistryValue: Failed to allocate memory\n");
#endif
         return( STATUS_NO_MEMORY );
         }

     InitializeListHead( &p->Entry );

     p->Name.Buffer = (PWSTR)(p+1);
     p->Name.Length = UnicodeName.Length;
     p->Name.MaximumLength = UnicodeName.MaximumLength;
     RtlMoveMemory( p->Name.Buffer,
                    UnicodeName.Buffer,
                    UnicodeName.MaximumLength
                  );

     InsertTailList( ListHead, &p->Entry );


    if (ARGUMENT_PRESENT( Value )) {
      //
      // load certification DLL
      //

      HINSTANCE hDll = LoadLibraryW( Value );

      if (hDll == NULL) {
         //
         // The library was not loaded, return.
         //
         RemoveEntryList( &p->Entry );
         RtlFreeHeap( RtlProcessHeap(), 0, p );
#if DBG
         DbgPrint("BasepSaveRegistryValue: Certification DLL %ws not found\n", Value);
#endif
         return( STATUS_SUCCESS );
          }

      //
      // get entry point
      //
      p->fPluginCertFunc = (NTSTATUS (WINAPI *)(LPCWSTR,ULONG))
                          GetProcAddress(hDll,
                                         CERTAPP_ENTRYPOINT_NAME
                                         );

      if (p->fPluginCertFunc == NULL) {
          //
          // Unable to retrieve routine address, fail.
          //
          RemoveEntryList( &p->Entry );
          RtlFreeHeap( RtlProcessHeap(), 0, p );
          FreeLibrary(hDll);
#if DBG
          DbgPrint("BasepSaveRegistryValue: DLL %ws does not have entry point %s\n", Value,CERTAPP_ENTRYPOINT_NAME);
#endif
          return( STATUS_SUCCESS );
         }

        }
    else {
       RemoveEntryList( &p->Entry );
       RtlFreeHeap( RtlProcessHeap(), 0, p );
#if DBG
       DbgPrint("BasepSaveRegistryValue: Entry %ws is empty \n", Name);
#endif
       return( STATUS_SUCCESS );
        }

    return( STATUS_SUCCESS );

}

BOOL
IsWow64Process(
    HANDLE hProcess,
    PBOOL Wow64Process
    )
/*++

Routine Description:

    Checks if a process is running inside Wow64 (emulation for 32-bit applications
    on Win64).

Arguments:

    hProcess - Process handle to check if it is running inside Wow64.
    
    Wow64Process - Pointer to a boolean that receives the result if the function succeeds.

Return Value:

    BOOL

--*/

{
    NTSTATUS NtStatus;
    BOOL bRet;
    ULONG_PTR Peb32;

    NtStatus = NtQueryInformationProcess (
        hProcess,
        ProcessWow64Information,
        &Peb32,
        sizeof (Peb32),
        NULL
        );

    if (!NT_SUCCESS (NtStatus)) {
        
        BaseSetLastNTError (NtStatus);
    } else {
        
        if (Peb32 == 0) {
            *Wow64Process = FALSE;
        } else {
            *Wow64Process = TRUE;
        }
    }
        
    return (NT_SUCCESS (NtStatus));
}

#if defined(_WIN64) || defined(BUILD_WOW6432)

BOOL
NtVdm64CreateProcess(
    BOOL fPrefixMappedApplicationName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
/*++

Routine Description:

    Checks if there is a ported version of the Win16 lpApplicationName and
    if so creates a process with the ported version.

Arguments:

    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpApplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpApplicationName - Win16 file name not optional
    lpCommandLine - see comment for fPrefixMappedApplicationName.

    other arguments are identical to CreateProcessW.

Return Value:

    Same as CreateProcessW

--*/
{
    typedef BOOL
    (*LPNtVdm64CreateProcessFn)(
        BOOL fPrefixMappedApplicationName,
        LPCWSTR lpApplicationName,
        LPCWSTR lpCommandLine,
        LPSECURITY_ATTRIBUTES lpProcessAttributes,
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        BOOL bInheritHandles,
        DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCWSTR lpCurrentDirectory,
        LPSTARTUPINFOW lpStartupInfo,
        LPPROCESS_INFORMATION lpProcessInformation
        );

    HINSTANCE hInstance;
    LPNtVdm64CreateProcessFn lpfn;
    BOOL result;
    NTSTATUS Status;
    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];

    hInstance = NULL;
    Status = ERROR_BAD_EXE_FORMAT;
    result = FALSE;

    // so it turns out that there is a high probability that
    // lpCommandLine sits in the StaticUnicodeBuffer in the Teb
    // and also a high probability that LoadLibrary will trash that
    // buffer in a bad way
    if (lpCommandLine >= NtCurrentTeb()->StaticUnicodeBuffer &&
        lpCommandLine < &NtCurrentTeb()->StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH]) {
        wcscpy(StaticUnicodeBuffer, lpCommandLine);
        lpCommandLine = StaticUnicodeBuffer;
    }

    hInstance = LoadLibraryW(L"NtVdm64.Dll");
    if (hInstance == NULL) {
        goto ErrorExit;
    }

    lpfn = (LPNtVdm64CreateProcessFn) GetProcAddress(hInstance, "NtVdm64CreateProcess");
    if (lpfn == NULL) {
        goto ErrorExit;
    }

    result = (*lpfn)(fPrefixMappedApplicationName,
                     lpApplicationName,
                     lpCommandLine,
                     lpProcessAttributes,
                     lpThreadAttributes,
                     bInheritHandles,
                     dwCreationFlags,
                     lpEnvironment,
                     lpCurrentDirectory,
                     lpStartupInfo,
                     lpProcessInformation
                     );
    Status = GetLastError();

ErrorExit:
    if (hInstance != NULL) {
        FreeLibrary(hInstance);
    }
    SetLastError(Status);

    return result;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\sxsfind.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsfind.c

Abstract:

    Side-by-side activation APIs for Win32, broken out of sxs.c

Author:

    Jay Krell (JayKrell) November 2001

Revision History:

--*/

#include "basedll.h"
#include <sxstypes.h>
#include "sxsapi.h"

BOOL
BasepFindActCtxSection_FillOutReturnData(
    IN  DWORD                                   dwWin32FlagsIn,
    OUT PACTCTX_SECTION_KEYED_DATA              ReturnedData,
    IN  PCACTIVATION_CONTEXT_SECTION_KEYED_DATA RtlData
    )
{
    ReturnedData->ulDataFormatVersion = RtlData->DataFormatVersion;
    ReturnedData->lpData = RtlData->Data;
    ReturnedData->ulLength = RtlData->Length;
    ReturnedData->lpSectionGlobalData = RtlData->SectionGlobalData;
    ReturnedData->ulSectionGlobalDataLength = RtlData->SectionGlobalDataLength;
    ReturnedData->lpSectionBase = RtlData->SectionBase;
    ReturnedData->ulSectionTotalLength = RtlData->SectionTotalLength;

    //
    // The size check happens earlier.
    // We then don't pay attention to the flag, but just always copy the data
    // out, as 2600 does.
    //
    ASSERT(RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->cbSize, hActCtx));
    ReturnedData->hActCtx = (HANDLE) RtlData->ActivationContext;

    //
    // There's no flag for this. 2600 always returns it if it fits.
    //
    if (RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->cbSize, ulAssemblyRosterIndex)) {
        ReturnedData->ulAssemblyRosterIndex = RtlData->AssemblyRosterIndex;
    }

    if ((dwWin32FlagsIn & FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS) != 0) {
        ReturnedData->ulFlags = RtlData->Flags;
    }

    if ((dwWin32FlagsIn & FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA) != 0) {

        ReturnedData->AssemblyMetadata.lpInformation = RtlData->AssemblyMetadata.Information;
        ReturnedData->AssemblyMetadata.lpSectionBase = RtlData->AssemblyMetadata.SectionBase;
        ReturnedData->AssemblyMetadata.ulSectionLength = RtlData->AssemblyMetadata.SectionLength;
        ReturnedData->AssemblyMetadata.lpSectionGlobalDataBase = RtlData->AssemblyMetadata.SectionGlobalDataBase;
        ReturnedData->AssemblyMetadata.ulSectionGlobalDataLength = RtlData->AssemblyMetadata.SectionGlobalDataLength;

    }
    return TRUE;
}

BOOL
BasepFindActCtxSection_CheckAndConvertParameters(
    IN DWORD dwWin32Flags,
    IN PCACTCTX_SECTION_KEYED_DATA pWin32ReturnedData,
    OUT PULONG pulRtlFlags
    )
{
    BOOL fSuccess = FALSE;
    ULONG cbWin32Size = 0;
    ULONG ulRtlFlags = 0;

    if (pulRtlFlags != NULL) {
        *pulRtlFlags = 0;
    }
    if (pWin32ReturnedData == NULL) {
        goto InvalidParameter;
    }
    if (pulRtlFlags == NULL) {
        goto InvalidParameter;
    }
    cbWin32Size = pWin32ReturnedData->cbSize;
    if (cbWin32Size < RTL_SIZEOF_THROUGH_FIELD(ACTCTX_SECTION_KEYED_DATA, hActCtx)) {
        goto InvalidParameter;
    }

    if (((dwWin32Flags & ~(FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX |
                      FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS |
                      FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA
                      )) != 0)
        ) {
        goto InvalidParameter;
    }

    if (dwWin32Flags & FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX) {
        if (!RTL_CONTAINS_FIELD(pWin32ReturnedData, cbWin32Size, hActCtx)) {
            goto InvalidParameter;
        }
        ulRtlFlags |= FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT;
    }
    if (dwWin32Flags & FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS) {
        if (!RTL_CONTAINS_FIELD(pWin32ReturnedData, cbWin32Size, ulFlags)) {
            goto InvalidParameter;
        }
        ulRtlFlags |= FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS;
    }
    if (dwWin32Flags & FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA) {
        if (!RTL_CONTAINS_FIELD(pWin32ReturnedData, cbWin32Size, AssemblyMetadata)) {
            goto InvalidParameter;
        }
        ulRtlFlags |= FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA;
    }

    *pulRtlFlags = ulRtlFlags;
    fSuccess = TRUE;
Exit:
    return fSuccess;

InvalidParameter:
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_ERROR_LEVEL,
        "SXS: Invalid parameter(s) passed to FindActCtxSection*()\n"
        "   dwFlags = 0x%08lx\n"
        "   ReturnedData = %p\n"
        "      ->cbSize = %u\n",
        dwWin32Flags,
        pWin32ReturnedData,
        (pWin32ReturnedData != NULL) ? cbWin32Size : 0);
    SetLastError(ERROR_INVALID_PARAMETER);
    goto Exit;
}

BOOL
BasepFindActCtxSectionString(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    PCUNICODE_STRING PUnicodeString,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    )
{
    BOOL fSuccess = FALSE;
    NTSTATUS Status;
    ULONG ulRtlFindFlags = 0;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA TempData;

    if (!BasepFindActCtxSection_CheckAndConvertParameters(
        dwFlags,
        ReturnedData,
        &ulRtlFindFlags
        )) {
        goto Exit;
    }

    RtlZeroMemory(&TempData, sizeof(TempData));
    TempData.Size = sizeof(TempData);

    Status = RtlFindActivationContextSectionString(
                ulRtlFindFlags,
                lpExtensionGuid,
                ulSectionId,
                PUnicodeString,
                &TempData);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        goto Exit;
    }

    if (!BasepFindActCtxSection_FillOutReturnData(
        dwFlags,
        ReturnedData,
        &TempData
        )) {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#if !defined(COMPILE_FIND_ACTCTX_SECTION_STRING_A) || COMPILE_FIND_ACTCTX_SECTION_STRING_A
WINBASEAPI
BOOL
FindActCtxSectionStringA(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    LPCSTR lpStringToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    )
{
    BOOL fSuccess = FALSE;
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING PUnicodeString = NULL;

    if (lpStringToFind != NULL) {
        if (!Basep8BitStringToDynamicUnicodeString(&UnicodeString, lpStringToFind))
            goto Exit;

        PUnicodeString = &UnicodeString;
    }

    if (!BasepFindActCtxSectionString(dwFlags, lpExtensionGuid, ulSectionId, PUnicodeString, ReturnedData))
        goto Exit;

    fSuccess = TRUE;
Exit:
    if (PUnicodeString != NULL)
        RtlFreeUnicodeString(PUnicodeString);

    return fSuccess;
}
#endif

BOOL
FindActCtxSectionStringW(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    LPCWSTR lpStringToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    )
{
    BOOL fSuccess = FALSE;
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING PUnicodeString = NULL;

    if (lpStringToFind != NULL) {
        RtlInitUnicodeString(&UnicodeString, lpStringToFind);
        PUnicodeString = &UnicodeString;
    }
    if (!BasepFindActCtxSectionString(dwFlags, lpExtensionGuid, ulSectionId, PUnicodeString, ReturnedData))
        goto Exit;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
WINAPI
FindActCtxSectionGuid(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    const GUID *lpGuidToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    )
{
    BOOL fSuccess = FALSE;
    NTSTATUS Status;
    ULONG ulRtlFindFlags = 0;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA TempData;

    if (!BasepFindActCtxSection_CheckAndConvertParameters(
        dwFlags,
        ReturnedData,
        &ulRtlFindFlags
        )) {
        goto Exit;
    }

    RtlZeroMemory(&TempData, sizeof(TempData));
    TempData.Size = sizeof(TempData);

    Status = RtlFindActivationContextSectionGuid(
                ulRtlFindFlags,
                lpExtensionGuid,
                ulSectionId,
                lpGuidToFind,
                &TempData);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        goto Exit;
    }

    if (!BasepFindActCtxSection_FillOutReturnData(
        dwFlags,
        ReturnedData,
        &TempData
        )) {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\sxs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sxs.c

Abstract:

    Side-by-side activation APIs for Win32

Author:

    Michael Grier (MGrier) 2/29/2000

Revision History:

    Jay Krell (a-JayK) June - July 2000
        factored/merged with sxs.c, source code duplication eliminated
        moved file opening out of csrss.exe to client process
        merged with MGrier: flag per added api struct field, assembly dir support

    Jon Wiswall (jonwis) Dec. 2000
        Moved code here from csrsxs.c to make csrsxs.c tiny and more in-line with general
          csrxxxx.c coding patterns, and to fix when we look in system32 vs. when
          we look in syswow64

    Jon Wiswall (jonwis) December 2000
        ACTCTX's that don't specify what resource ID they want now automagically
            search through the sources to find a resource type in the "actctx
            source."  This requires a gross EnumResourceNamesW call, after a
            stomach-churning LoadLibraryExW to load the object.

    Jay Krell (JayKrell) May 2001
        CreateActCtx now honors "administrative" override for .dlls. (foo.dll.2.manifest)
        (not) CreateActCtx now implements ACTCTX_FLAG_LIKE_CREATEPROCESS flag (foo.exe.manifest)

--*/

#include "basedll.h"
#include <sxstypes.h>
#include "SxsApi.h"
#include "winuser.h"

#if !defined(RTL_NUL_TERMINATE_STRING)
#define RTL_NUL_TERMINATE_STRING(x) ((x)->Buffer[(x)->Length / sizeof(*(x)->Buffer)] = 0)
#endif

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    || (x) == STATUS_RESOURCE_DATA_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_TYPE_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_NAME_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_LANG_NOT_FOUND  \
                                    || (x) == STATUS_SXS_CANT_GEN_ACTCTX      \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

#define ACTCTX_VALID_FLAGS \
    ( \
        ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID | \
        ACTCTX_FLAG_LANGID_VALID | \
        ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID | \
        ACTCTX_FLAG_RESOURCE_NAME_VALID | \
        ACTCTX_FLAG_SET_PROCESS_DEFAULT | \
        ACTCTX_FLAG_APPLICATION_NAME_VALID | \
        ACTCTX_FLAG_HMODULE_VALID \
        /*| ACTCTX_FLAG_LIKE_CREATEPROCESS*/ \
    )

// This is the name for the manifest if we are given an assembly root directory but no manifest name is specified.
const WCHAR ManifestDefaultName[] = L"Application.Manifest";

#define MAXSIZE_T  (~(SIZE_T)0)

extern const UNICODE_STRING SxsManifestSuffix = RTL_CONSTANT_STRING(L".Manifest");
extern const UNICODE_STRING SxsPolicySuffix   = RTL_CONSTANT_STRING(L".Config");

#define MEDIUM_PATH (64)

//#define IsSxsAcceptablePathType(x)  (x in (RtlPathTypeUncAbsolute, RtlPathTypeDriveAbsolute, RtlPathTypeLocalDevice))
#define IsSxsAcceptablePathType(x)  ((x == RtlPathTypeUncAbsolute) || (x == RtlPathTypeDriveAbsolute) || (x == RtlPathTypeLocalDevice))

VOID
BasepSxsOverrideStreamToMessageStream(
    IN  PCSXS_OVERRIDE_STREAM OverrideStream,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    );

HANDLE
WINAPI
CreateActCtxA(
    PCACTCTXA pParamsA
    )
{
    ACTCTXW ParamsW = {sizeof(ParamsW)};
    PUNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ActivationContextHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING AssemblyDir = {0};
    WCHAR AssemblyDirBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    ULONG_PTR MappedResourceName = 0;
    const PTEB Teb = NtCurrentTeb();

    if (pParamsA == NULL
        || !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, lpSource)
        ) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Null %p or size 0x%lx too small\n",
            __FUNCTION__,
            pParamsA,
            pParamsA->cbSize
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    ParamsW.dwFlags =  pParamsA->dwFlags;

    if (((ParamsW.dwFlags & ~ACTCTX_VALID_FLAGS) != 0) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, wProcessorArchitecture)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_LANGID_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, wLangId)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, lpAssemblyDirectory)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, lpResourceName)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, lpApplicationName)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_HMODULE_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, hModule))) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Bad flags/size 0x%lx/0x%lx\n",
            __FUNCTION__,
            pParamsA->dwFlags,
            pParamsA->cbSize);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (pParamsA->lpSource != NULL) {
        UnicodeString = &Teb->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString, pParamsA->lpSource);
        Status = Basep8BitStringToUnicodeString(UnicodeString, &AnsiString, FALSE);
        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_BUFFER_OVERFLOW) {
                Status = STATUS_NAME_TOO_LONG;
            }
            goto Exit;
        }
        ParamsW.lpSource = UnicodeString->Buffer;
    } else {
        if ((ParamsW.dwFlags & ACTCTX_FLAG_HMODULE_VALID) == 0) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        ParamsW.lpSource = NULL;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID) {
        ParamsW.wProcessorArchitecture = pParamsA->wProcessorArchitecture;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_LANGID_VALID) {
        ParamsW.wLangId = pParamsA->wLangId;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_HMODULE_VALID) {
        ParamsW.hModule = pParamsA->hModule;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) {
        RtlInitAnsiString(&AnsiString, pParamsA->lpAssemblyDirectory);
        AssemblyDir.MaximumLength = sizeof(AssemblyDirBuffer);
        AssemblyDir.Buffer = AssemblyDirBuffer;

        Status = Basep8BitStringToUnicodeString(&AssemblyDir, &AnsiString, FALSE);

#if 0 // This is inconsistent. Two string ANSI APIs like MoveFileA are only
      // documented to support MAX_PATH. They actually support one of the strings
      // being unlimited, but let's stick to what is documented.
        if (Status == STATUS_BUFFER_OVERFLOW) {
            // Try again, this time with dynamic allocation
            Status = Basep8BitStringToUnicodeString(&AssemblyDir, &AnsiString, TRUE);
        }
#endif
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_NAME_TOO_LONG;
        }

        if (NT_ERROR(Status))
            goto Exit;

        ParamsW.lpAssemblyDirectory = AssemblyDir.Buffer;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) {
        MappedResourceName = BaseDllMapResourceIdA(pParamsA->lpResourceName);
        if (MappedResourceName == -1) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() BaseDllMapResourceIdA failed\n",
                __FUNCTION__);
            Status = Teb->LastStatusValue;
            goto Exit;
        }
        ParamsW.lpResourceName = (PCWSTR) MappedResourceName;
    }

    ActivationContextHandle = CreateActCtxW(&ParamsW);
    if (ActivationContextHandle == INVALID_HANDLE_VALUE) {
        Status = Teb->LastStatusValue;
    }
Exit:
    if (AssemblyDir.Buffer != NULL
        && AssemblyDir.Buffer != AssemblyDirBuffer) {
        RtlFreeUnicodeString(&AssemblyDir);
    }
    BaseDllFreeResourceId(MappedResourceName);
    if (ActivationContextHandle == INVALID_HANDLE_VALUE) {
        BaseSetLastNTError(Status);
    }
#if DBG
    if ( ActivationContextHandle == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
            "SXS: Exiting %s(%s, %p), Handle:%p, Status:0x%lx\n",
            __FUNCTION__,
            (pParamsA != NULL) ? pParamsA->lpSource : NULL,
            (pParamsA != NULL) ? pParamsA->lpResourceName : NULL,
            ActivationContextHandle,
            Status
        );
    }
#endif
    return ActivationContextHandle;
}

USHORT
BasepSxsGetProcessorArchitecture(
    VOID
    )
{
//
// Return the processor architecture of the currently executing code/process.
//
    USHORT Result;
#if defined(BUILD_WOW6432)
    Result = PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
#elif defined(_M_IX86)
    Result = PROCESSOR_ARCHITECTURE_INTEL;
#elif defined(_M_IA64)
    Result = PROCESSOR_ARCHITECTURE_IA64;
#elif defined(_M_AMD64)
    Result = PROCESSOR_ARCHITECTURE_AMD64;
#else
    static USHORT StaticResult;
    static BOOL   Inited = FALSE;
    if (!Inited) {
        SYSTEM_INFO SystemInfo;

        SystemInfo.wProcessorArchictecure = 0;
        GetSystemInfo(&SystemInfo);
        StaticResult = SystemInfo.wProcessorArchictecure;
        Inited = TRUE;
    }
    Result = StaticResult;
#endif
    return Result;
}

VOID
NTAPI
BasepSxsActivationContextNotification(
    IN ULONG NotificationType,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN const VOID *ActivationContextData,
    IN PVOID NotificationContext,
    IN PVOID NotificationData,
    IN OUT PBOOLEAN DisableNotification
    )
{
    switch (NotificationType)
    {
    case ACTIVATION_CONTEXT_NOTIFICATION_DESTROY:
        RTL_SOFT_VERIFY(NT_SUCCESS(NtUnmapViewOfSection(NtCurrentProcess(), (PVOID) ActivationContextData)));
        break;

    default:
        // Otherwise, we don't need to see this notification ever again.
        *DisableNotification = TRUE;
        break;
    }
}

#if DBG
VOID
DbgPrintActCtx(
    PCSTR     FunctionPlus,
    PCACTCTXW ActCtx
    )
{
    // odd but correct
    if (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_INFO_LEVEL) != TRUE)
        return;

    DbgPrint("%s Flags 0x%08lx(%s%s%s%s%s%s%s%s%s)\n",
        FunctionPlus,
        ActCtx->dwFlags,
        (ActCtx->dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID ) ? " processor" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_LANGID_VALID                 ) ? " langid" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID     ) ? " directory" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID          ) ? " resource" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_SET_PROCESS_DEFAULT          ) ? " setdefault" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID       ) ? " appname" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF        ) ? " asmref" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_HMODULE_VALID                ) ? " hmodule" : "",
#if defined(ACTCTX_FLAG_LIKE_CREATEPROCESS)
        (ActCtx->dwFlags & ACTCTX_FLAG_LIKE_CREATEPROCESS           ) ? " likecreateprocess" : ""
#else
        ""
#endif
        );

    DbgPrint("%s Source %ls\n", FunctionPlus, ActCtx->lpSource);

    if (ActCtx->dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID)
        DbgPrint("%s ProcessorArchitecture 0x%08lx\n", FunctionPlus, ActCtx->wProcessorArchitecture);

    if (ActCtx->dwFlags & ACTCTX_FLAG_LANGID_VALID)
        DbgPrint("%s LangId 0x%08lx\n", FunctionPlus, ActCtx->wLangId);

    if (ActCtx->dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID)
        DbgPrint("%s AssemblyDirectory %ls\n", FunctionPlus, ActCtx->lpAssemblyDirectory);

    if (ActCtx->dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID)
        DbgPrint("%s ResourceName %p (%Id)\n",  FunctionPlus, ActCtx->lpResourceName, (ULONG_PTR) ActCtx->lpResourceName);

    if (ActCtx->dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID)
        DbgPrint("%s ApplicationName %ls\n",  FunctionPlus, ActCtx->lpApplicationName);

    if (ActCtx->dwFlags & ACTCTX_FLAG_HMODULE_VALID)
        DbgPrint("%s hModule = %p\n", FunctionPlus, ActCtx->hModule);

}
#else
#define DbgPrintActCtx(FunctionPlus, ActCtx) /* nothing */
#endif

typedef struct EnumResParams {
    ULONG_PTR *MappedResourceName;
    BOOL FoundManifest;
    BOOL ErrorEncountered;
} EnumResParams;

BOOL CALLBACK
BasepSxsSuitableManifestCallback(
    HMODULE hModule,
    PCWSTR lpszType,
    PWSTR lpszName,
    LONG_PTR lParam
)
{
    EnumResParams *pParams = (EnumResParams*)lParam;
    BOOL fContinueEnumeration = FALSE;

#if DBG
    DbgPrintEx( DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL,
        "Sxs.c: %s(%p, %p, %p, %p)\n",
        __FUNCTION__, hModule, lpszType, lpszName, lParam
        );
#endif

    ASSERT((pParams != NULL) &&
           (!pParams->ErrorEncountered) &&
           (!pParams->FoundManifest) &&
           (pParams->MappedResourceName != NULL));

    ASSERT(lpszType == MAKEINTRESOURCEW(RT_MANIFEST));

    // Boo! Boooooo!
    if ((pParams == NULL) ||
        (pParams->ErrorEncountered) ||
        (pParams->FoundManifest) ||
        (pParams->MappedResourceName == NULL)) {
        // None of these should be able to happen except if there is a coding error in the caller
        // of EnumResourceNamesW() or in the code for EnumResourceNamesW().
        if (pParams != NULL)
            pParams->ErrorEncountered = TRUE;

        SetLastError(ERROR_INVALID_PARAMETER);
        fContinueEnumeration = FALSE;
        goto Exit;
    }

#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "   Params (start): { ResName: *(%p) = %p, Found: %s, Error: %s }",
        pParams->MappedResourceName, pParams->MappedResourceName,
        pParams->FoundManifest ? "true" : "false",
        pParams->ErrorEncountered ? "true" : "false");
#endif

    if (lpszType == MAKEINTRESOURCEW(RT_MANIFEST)) {
        // We found one - we don't care about others
        *pParams->MappedResourceName = BaseDllMapResourceIdW(lpszName);
        pParams->FoundManifest = TRUE;
        fContinueEnumeration = FALSE;
        goto Exit;
    }

    // This should not be able to happen; we should only be called for
    // RT_MANIFEST resources, but in case it somehow does happen, go on to the
    // next one.
    fContinueEnumeration = TRUE;

Exit:

#if DBG
    if ((pParams != NULL) && (pParams->MappedResourceName))
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            " Params (end): { ResName: *(%p) = %p, Found: %s, Error: %s }",
            pParams->MappedResourceName, pParams->MappedResourceName,
            pParams->FoundManifest ? "true" : "false",
            pParams->ErrorEncountered ? "true" : "false");
#endif

    return fContinueEnumeration;
}



NTSTATUS
BasepSxsFindSuitableManifestResourceFor(
    PCACTCTXW Params,
    ULONG_PTR *MappedResourceName,
    BOOL *FoundManifest
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    EnumResParams FinderParameters = { MappedResourceName, FALSE, FALSE };
    HMODULE hSourceItem = NULL;
    BOOL FreeSourceModule = FALSE;

    if (FoundManifest != NULL)
        *FoundManifest = FALSE;

    if (MappedResourceName != NULL)
        *MappedResourceName = 0;

    if ((FoundManifest == NULL) ||
        (MappedResourceName == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // General pattern - open Params->lpSource and attempt to find the first
    // resource with type == RT_MANIFEST (24).  Stuff its resource name into
    // MappedResourceName.
    //

    if (Params->dwFlags & ACTCTX_FLAG_HMODULE_VALID) {
        hSourceItem = Params->hModule;
        FreeSourceModule = FALSE;
    } else {
        //
        // Map the dll/exe/etc.  If this fails, then there's a good chance that the
        // thing isn't a dll or exe, so don't fail out, just indicate that no manifest
        // was found.
        //
        hSourceItem = LoadLibraryExW(Params->lpSource, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if ((hSourceItem == NULL) || (hSourceItem == INVALID_HANDLE_VALUE)) {
            Status = NtCurrentTeb()->LastStatusValue;
            goto Exit;
        }

        FreeSourceModule = TRUE;
    }

    //
    // If this fails with something other than ERROR_RESOURCE_TYPE_NOT_FOUND
    // then we're in an interesting state.
    //
    if (!EnumResourceNamesW(
            hSourceItem,
            MAKEINTRESOURCEW(RT_MANIFEST),
            &BasepSxsSuitableManifestCallback,
            (LONG_PTR) &FinderParameters)) {
        DWORD dwError = GetLastError();
        if ((dwError != ERROR_SUCCESS) && (dwError != ERROR_RESOURCE_TYPE_NOT_FOUND)) {
            Status = NtCurrentTeb()->LastStatusValue;
            goto Exit;
        }
    }

#if DBG
    if (FreeSourceModule && *MappedResourceName != 0) {
        // Debugging code for mgrier to see what DLLs we're actually using the enum pattern for.
        DbgPrint(
            "SXS/KERNEL32: Found resource %d in %ls (process %wZ) by enumeration\n",
            (INT) *MappedResourceName,
            Params->lpSource,
            &NtCurrentPeb()->ProcessParameters->ImagePathName);
    }
#endif

    Status = STATUS_SUCCESS;
Exit:
    if ((hSourceItem != NULL) &&
        (hSourceItem != INVALID_HANDLE_VALUE) &&
        (FreeSourceModule))
        FreeLibrary(hSourceItem);

    return Status;
}

HANDLE
WINAPI
CreateActCtxW(
    PCACTCTXW pParamsW
    )
{
    HANDLE ActivationContextHandle = INVALID_HANDLE_VALUE;
    NTSTATUS Status = STATUS_SUCCESS;
    ACTCTXW Params = { sizeof(Params) };
    ULONG_PTR MappedResourceName = 0;
    PVOID ActivationContextData = NULL;
    // lpTempSourcePath is used to hold a pointer to the source path if it needs to be created
    // in this function. It should be freed before leaving the function.
    LPWSTR lpTempSourcePath = NULL;
    PPEB Peb = NULL;
    RTL_UNICODE_STRING_BUFFER AssemblyDirectoryFromSourceBuffer = { 0 };
    RTL_UNICODE_STRING_BUFFER SourceBuffer = { 0 };
    UCHAR StaticBuffer[256];
    UCHAR SourceStaticBuffer[256];
    BOOLEAN PebLockAcquired = FALSE;
    ULONG BasepCreateActCtxFlags = 0;

    DbgPrintActCtx(__FUNCTION__ " before munging", pParamsW);

    if ((pParamsW == NULL) ||
        !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, lpSource)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Null %p or size 0x%lx too small\n",
            __FUNCTION__,
            pParamsW,
            pParamsW->cbSize
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Params.dwFlags =  pParamsW->dwFlags;

    if ((Params.dwFlags & ~ACTCTX_VALID_FLAGS) ||
        ((Params.dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, wProcessorArchitecture)) ||
        ((Params.dwFlags & ACTCTX_FLAG_LANGID_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, wLangId)) ||
        ((Params.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, lpAssemblyDirectory)) ||
        ((Params.dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, lpResourceName)) ||
        ((Params.dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, lpApplicationName)) ||
        ((Params.dwFlags & ACTCTX_FLAG_HMODULE_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, hModule))) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Bad flags/size 0x%lx/0x%lx\n",
            __FUNCTION__,
            pParamsW->dwFlags,
            pParamsW->cbSize);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Params.dwFlags & ACTCTX_FLAG_SET_PROCESS_DEFAULT) {
        Peb = NtCurrentPeb();
        if (Peb->ActivationContextData != NULL) {
            Status = STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET;
            goto Exit;
        }
    }

#if defined(ACTCTX_FLAG_LIKE_CREATEPROCESS)
    if (Params.dwFlags & ACTCTX_FLAG_LIKE_CREATEPROCESS) {

        Status = BasepCreateActCtxLikeCreateProcess(pParamsW);
        goto Exit;
    }
#endif

    Params.lpSource = pParamsW->lpSource;

    // We need at least either a source path or an HMODULE.
    if ((Params.lpSource == NULL) &&
        ((Params.dwFlags & ACTCTX_FLAG_HMODULE_VALID) == 0) &&
        ((Params.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) == 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Params.dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID) {
        USHORT wProcessorArchitecture = pParamsW->wProcessorArchitecture;
#if defined(BUILD_WOW6432)
        if (wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
            wProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
#endif

        if ((wProcessorArchitecture != PROCESSOR_ARCHITECTURE_UNKNOWN) &&
            (wProcessorArchitecture != BasepSxsGetProcessorArchitecture())) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() bad wProcessorArchitecture 0x%x\n",
                __FUNCTION__,
                pParamsW->wProcessorArchitecture);
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        Params.wProcessorArchitecture = wProcessorArchitecture;
    } else {
        Params.wProcessorArchitecture = BasepSxsGetProcessorArchitecture();
        Params.dwFlags |= ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID;
    }

    if (Params.dwFlags & ACTCTX_FLAG_LANGID_VALID) {
        Params.wLangId = pParamsW->wLangId;
    } else {
        Params.wLangId = GetUserDefaultUILanguage();
        Params.dwFlags |= ACTCTX_FLAG_LANGID_VALID;
    }

    if (Params.dwFlags & ACTCTX_FLAG_HMODULE_VALID)
        Params.hModule = pParamsW->hModule;

    // If the assembly root dir is specified, then the valid values for lpSource are
    // NULL - This implies that we look for a file called "application.manifest" in the assembly root dir.
    // Relative FilePath - if lpSource is relative then we combine it with the assembly root dir to get the path.
    // Absolute path - used unmodified.

    Params.lpAssemblyDirectory = pParamsW->lpAssemblyDirectory;

    if (Params.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) {
        RTL_PATH_TYPE AssemblyPathType;
        RTL_PATH_TYPE SourcePathType;
         // if this is true, implies we will make the source path from the assembly dir.
        BOOL MakeSourcePath = FALSE ;
        LPCWSTR RelativePath = NULL;

        if ((Params.lpAssemblyDirectory == NULL) ||
            (Params.lpAssemblyDirectory[0] == 0)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() Bad lpAssemblyDirectory %ls\n",
                __FUNCTION__,
                Params.lpAssemblyDirectory);
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        // Next check that the assembly dir is an absolute file name.
        AssemblyPathType = RtlDetermineDosPathNameType_U(Params.lpAssemblyDirectory);
        if (!IsSxsAcceptablePathType(AssemblyPathType)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() Bad lpAssemblyDirectory PathType %ls, 0x%lx\n",
                Params.lpAssemblyDirectory,
                (LONG) AssemblyPathType);
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if (Params.lpSource != NULL) {
            SourcePathType = RtlDetermineDosPathNameType_U(Params.lpSource);
            if (IsSxsAcceptablePathType(SourcePathType)){
                MakeSourcePath = FALSE ; // We don't need to mess with lpSource in this case.
            } else if ( SourcePathType == RtlPathTypeRelative ) {
                MakeSourcePath = TRUE ;
                RelativePath = Params.lpSource;
            } else {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: %s() Bad lpSource PathType %ls, 0x%lx\n",
                    Params.lpSource,
                    (LONG)SourcePathType);
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
        }
        else {
            MakeSourcePath = TRUE;
            RelativePath = ManifestDefaultName;
        }

        if (MakeSourcePath) {
            ULONG LengthAssemblyDir;
            ULONG LengthRelativePath ;
            ULONG Length ; // Will hold total number of characters we
            BOOL AddTrailingSlash = FALSE;
            LPWSTR lpCurrent;

            LengthAssemblyDir = wcslen(Params.lpAssemblyDirectory);
            AddTrailingSlash = (Params.lpAssemblyDirectory[LengthAssemblyDir - 1] != L'\\');
            LengthRelativePath = wcslen(RelativePath);

            Length = LengthAssemblyDir + (AddTrailingSlash ? 1 : 0) + LengthRelativePath;
            Length++ ; // For NULL terminator

            lpTempSourcePath = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                                    Length * sizeof(WCHAR));

            if (lpTempSourcePath == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }

            lpCurrent = lpTempSourcePath;

            memcpy(lpCurrent, Params.lpAssemblyDirectory, LengthAssemblyDir * sizeof(WCHAR));
            lpCurrent += LengthAssemblyDir;

            if (AddTrailingSlash) {
                *lpCurrent = L'\\';
                lpCurrent++;
            }

            memcpy(lpCurrent, RelativePath, LengthRelativePath * sizeof(WCHAR));
            lpCurrent += LengthRelativePath;

            *lpCurrent = L'\0';

            // make this the new lpSource member.
            Params.lpSource = lpTempSourcePath;
        }
    } else {
        SIZE_T         SourceLength;

        //
        // Ensure that this is a full absolute path.  If it's relative, then this
        // must be expanded out to the full path before we use it to default the
        // lpAssemblyDirectory member.
        //
        // There is no precedent for using the peb lock this way, but it is the correct
        // thing. FullPaths can change as the current working directory is modified
        // on other threads. The behavior isn't predictable either way, but our
        // code works better.
        //
        RtlAcquirePebLock();
        __try {
            RtlInitUnicodeStringBuffer(&SourceBuffer, SourceStaticBuffer, sizeof(SourceStaticBuffer));
            SourceLength = RtlGetFullPathName_U( Params.lpSource, (ULONG)SourceBuffer.ByteBuffer.Size, SourceBuffer.String.Buffer, NULL );
            if (SourceLength == 0) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            } else if (SourceLength > SourceBuffer.ByteBuffer.Size) {
                Status = RtlEnsureUnicodeStringBufferSizeBytes(&SourceBuffer, SourceLength);
                if ( !NT_SUCCESS(Status) )
                    goto Exit;
                SourceLength = RtlGetFullPathName_U( Params.lpSource, (ULONG)SourceBuffer.ByteBuffer.Size, SourceBuffer.String.Buffer, NULL );
                if (SourceLength == 0) {
                    Status = STATUS_NO_MEMORY;
                    goto Exit;
                }
            }
            SourceBuffer.String.Length = (USHORT)SourceLength;
            Params.lpSource = SourceBuffer.String.Buffer;
        } __finally {
            RtlReleasePebLock();
        }

        // This would be a nice place to use
        // RtlTakeRemainingStaticBuffer(&SourceBuffer, &DirectoryBuffer, &DirectoryBufferSize);
        // RtlInitUnicodeStringBuffer(&DirectoryBuffer, &DirectoryBuffer, &DirectoryBufferSize);
        // but RtlTakeRemainingStaticBuffer has not yet been tested.

        RtlInitUnicodeStringBuffer(&AssemblyDirectoryFromSourceBuffer, StaticBuffer, sizeof(StaticBuffer));
        Status = RtlAssignUnicodeStringBuffer(&AssemblyDirectoryFromSourceBuffer, &SourceBuffer.String);
        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
        Status = RtlRemoveLastFullDosOrNtPathElement(0, &AssemblyDirectoryFromSourceBuffer);
        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
        RTL_NUL_TERMINATE_STRING(&AssemblyDirectoryFromSourceBuffer.String);
        Params.lpAssemblyDirectory = AssemblyDirectoryFromSourceBuffer.String.Buffer;
        Params.dwFlags |= ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID;
    }

#if defined(ACTCTX_FLAG_LIKE_CREATEPROCESS)
    if (Params.dwFlags & ACTCTX_FLAG_LIKE_CREATEPROCESS) {
        Params.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
        MappedResourceName = (LONG_PTR)CREATEPROCESS_MANIFEST_RESOURCE_ID;
        if (MappedResourceName == -1) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() BaseDllMapResourceIdW(1) failed\n",
                __FUNCTION__
                );
            Status = NtCurrentTeb()->LastStatusValue;
            goto Exit;
        }

        Params.lpResourceName = (PCWSTR) MappedResourceName;
    }
    else
#endif
	if (Params.dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) {
        if (pParamsW->lpResourceName == 0) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() ACTCTX_FLAG_RESOURCE_NAME_VALID set but lpResourceName == 0\n",
                __FUNCTION__
                );
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        MappedResourceName = BaseDllMapResourceIdW(pParamsW->lpResourceName);
        if (MappedResourceName == -1) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() BaseDllMapResourceIdW failed\n",
                __FUNCTION__
                );
            Status = NtCurrentTeb()->LastStatusValue;
            goto Exit;
        }

        Params.lpResourceName = (PCWSTR) MappedResourceName;
    } else {
        BOOL ProbeFoundManifestResource;
        //
        // Otherwise, probe through the filename that was passed in via the resource
        // enumeration functions to find the first suitable manifest.
        //
        Status = BasepSxsFindSuitableManifestResourceFor(&Params, &MappedResourceName, &ProbeFoundManifestResource);
        if ((!NT_SUCCESS(Status)) &&
            (Status != STATUS_INVALID_IMAGE_FORMAT))
            goto Exit;

        if (ProbeFoundManifestResource) {
            Params.lpResourceName = (PCWSTR) MappedResourceName;
            Params.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
        }
        BasepCreateActCtxFlags = BASEP_CREATE_ACTCTX_FLAG_NO_ADMIN_OVERRIDE;
    }

    DbgPrintActCtx(__FUNCTION__ " after munging", &Params);

    Status = BasepCreateActCtx(BasepCreateActCtxFlags, &Params, &ActivationContextData);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    if (Params.dwFlags & ACTCTX_FLAG_SET_PROCESS_DEFAULT) {
        if (Peb->ActivationContextData != NULL) {
            Status = STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET;
            goto Exit;
        }
        if (InterlockedCompareExchangePointer(
                (PVOID*)&Peb->ActivationContextData,
                ActivationContextData,
                NULL
                )
                != NULL) {
            Status = STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET;
            goto Exit;
        }
        ActivationContextData = NULL; // don't unmap it
        ActivationContextHandle = NULL; // unusual success value, INVALID_HANDLE_VALUE is failure
                                        // and we don't need to return anything to be cleaned up
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    Status = RtlCreateActivationContext(
        0,
        ActivationContextData,
        0,                                      // no extra bytes required today
        BasepSxsActivationContextNotification,
        NULL,
        (PACTIVATION_CONTEXT *) &ActivationContextHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_LEVEL_STATUS(Status),
            "SXS: RtlCreateActivationContext() failed 0x%08lx\n", Status);

        // Just in case RtlCreateActivationContext() set it to NULL...
        ActivationContextHandle = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    ActivationContextData = NULL; // Don't unmap in exit if we actually succeeded.
    Status = STATUS_SUCCESS;
Exit:
    if (ActivationContextData != NULL) {
        NtUnmapViewOfSection(NtCurrentProcess(), ActivationContextData);
    }
    BaseDllFreeResourceId(MappedResourceName);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        ActivationContextHandle = INVALID_HANDLE_VALUE;
    }

#if DBG
    if (ActivationContextHandle == INVALID_HANDLE_VALUE) {
        DbgPrintEx( 
            DPFLTR_SXS_ID, 
            DPFLTR_LEVEL_STATUS(Status),
            "SXS: Exiting %s(%ls / %ls, %p), ActivationContextHandle:%p, Status:0x%lx\n",
            __FUNCTION__,
            Params.lpSource, pParamsW->lpSource,
            Params.lpResourceName,
            ActivationContextHandle,
            Status
        );
    }
#endif

    // Do these after DbgPrintEx because at least one of them can get printed.
    RtlFreeUnicodeStringBuffer(&AssemblyDirectoryFromSourceBuffer);
    RtlFreeUnicodeStringBuffer(&SourceBuffer);
    if (lpTempSourcePath != NULL) {
        // Set the lpSource value back to the original so we don't access freed memory.
        Params.lpSource = pParamsW->lpSource;
        RtlFreeHeap(RtlProcessHeap(), 0, lpTempSourcePath);
    }
    return ActivationContextHandle;
}

VOID
WINAPI
AddRefActCtx(
    HANDLE hActCtx
    )
{
    RtlAddRefActivationContext((PACTIVATION_CONTEXT) hActCtx);
}

VOID
WINAPI
ReleaseActCtx(
    HANDLE hActCtx
    )
{
    RtlReleaseActivationContext((PACTIVATION_CONTEXT) hActCtx);
}

BOOL
WINAPI
ZombifyActCtx(
    HANDLE hActCtx
    )
{
    NTSTATUS Status = RtlZombifyActivationContext((PACTIVATION_CONTEXT) hActCtx);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
ActivateActCtx(
    HANDLE hActCtx,
    ULONG_PTR *lpCookie
    )
{
   NTSTATUS Status;

    if (hActCtx == INVALID_HANDLE_VALUE) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    Status = RtlActivateActivationContext(0, (PACTIVATION_CONTEXT) hActCtx, lpCookie);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
DeactivateActCtx(
    DWORD dwFlags,
    ULONG_PTR ulCookie
    )
{
    DWORD dwFlagsDown = 0;

    if ((dwFlags & ~(DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION)) != 0) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    if (dwFlags & DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION)
        dwFlagsDown |= RTL_DEACTIVATE_ACTIVATION_CONTEXT_FLAG_FORCE_EARLY_DEACTIVATION;

    // The Rtl function does not fail...
    RtlDeactivateActivationContext(dwFlagsDown, ulCookie);
    return TRUE;
}

BOOL
WINAPI
GetCurrentActCtx(
    HANDLE *lphActCtx)
{
    NTSTATUS Status;
    BOOL fSuccess = FALSE;

    if (lphActCtx == NULL) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    Status = RtlGetActiveActivationContext((PACTIVATION_CONTEXT *) lphActCtx);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        goto Exit;
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

NTSTATUS
BasepAllocateActivationContextActivationBlock(
    IN DWORD Flags,
    IN PVOID Callback,
    IN PVOID CallbackContext,
    OUT PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK *ActivationBlock
    )
{
    NTSTATUS Status;
    ACTIVATION_CONTEXT_BASIC_INFORMATION acbi = {0};

    if (ActivationBlock != NULL)
        *ActivationBlock = NULL;

    if ((Flags & ~(
            BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK |
            BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT)) != 0) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Exit;
    }

    if (ActivationBlock == NULL) {
        Status = STATUS_INVALID_PARAMETER_4;
        goto Exit;
    }

    Status =
        RtlQueryInformationActivationContext(
            RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,
            NULL,
            0,
            ActivationContextBasicInformation,
            &acbi,
            sizeof(acbi),
            NULL);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s - Failure getting active activation context; ntstatus %08lx\n", __FUNCTION__, Status);
        goto Exit;
    }

    if (acbi.Flags & ACTIVATION_CONTEXT_FLAG_NO_INHERIT) {
        RtlReleaseActivationContext(acbi.ActivationContext);
        acbi.ActivationContext = NULL;
    }

    // If the activation context is non-NULL or the caller always wants the block allocated
    if (((Flags & BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT) == 0) ||
        (acbi.ActivationContext != NULL)) {

        *ActivationBlock = (PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK) RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), sizeof(BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK));
        if (*ActivationBlock == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        (*ActivationBlock)->Flags = 0;
        (*ActivationBlock)->ActivationContext = acbi.ActivationContext;
        acbi.ActivationContext = NULL; // don't release in exit path...

        if (Flags & BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK)
            (*ActivationBlock)->Flags |= BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK;

        (*ActivationBlock)->CallbackFunction = Callback;
        (*ActivationBlock)->CallbackContext = CallbackContext;
    }

    Status = STATUS_SUCCESS;
Exit:
    if (acbi.ActivationContext != NULL)
        RtlReleaseActivationContext(acbi.ActivationContext);

    return Status;
}

VOID
BasepFreeActivationContextActivationBlock(
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock
    )
{
    if (ActivationBlock != NULL) {
        if (ActivationBlock->ActivationContext != NULL) {
            RtlReleaseActivationContext(ActivationBlock->ActivationContext);
            ActivationBlock->ActivationContext = NULL;
        }
        RtlFreeHeap(RtlProcessHeap(), 0, ActivationBlock);
    }
}



VOID
BasepSxsCloseHandles(
    IN PCBASE_MSG_SXS_HANDLES Handles
    )
{
    NTSTATUS Status;

    if (Handles->File != NULL) {
        Status = NtClose(Handles->File);
        ASSERT(NT_SUCCESS(Status));
    }
    if (Handles->Section != NULL) {
        Status = NtClose(Handles->Section);
        ASSERT(NT_SUCCESS(Status));
    }
    if (Handles->ViewBase != NULL) {
        HANDLE Process = Handles->Process;
        if (Process == NULL) {
            Process = NtCurrentProcess();
        }
        Status = NtUnmapViewOfSection(Process, Handles->ViewBase);

        ASSERT(NT_SUCCESS(Status));
    }
}

NTSTATUS
BasepCreateActCtx(
    ULONG           Flags,
    IN PCACTCTXW    ActParams,
    OUT PVOID*      ActivationContextData
    )
{
    RTL_PATH_TYPE PathType = RtlPathTypeUnknown;
    IO_STATUS_BLOCK IoStatusBlock;
    UCHAR  Win32PolicyPathStaticBuffer[MEDIUM_PATH * sizeof(WCHAR)];
    UCHAR  NtPolicyPathStaticBuffer[MEDIUM_PATH * sizeof(WCHAR)];
    UNICODE_STRING Win32ManifestPath;
    UNICODE_STRING NtManifestPath;
    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR ManifestPathPair = { &Win32ManifestPath, &NtManifestPath };
    RTL_UNICODE_STRING_BUFFER Win32PolicyPath;
    RTL_UNICODE_STRING_BUFFER NtPolicyPath;
    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR PolicyPathPair = { &Win32PolicyPath.String, &NtPolicyPath.String };
    USHORT RemoveManifestExtensionFromPolicy = 0;
    BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING PolicyPathPieces[3];
    WCHAR PolicyManifestResourceId[sizeof(".65535\0")];
    BOOL IsImage = FALSE;
    BOOL IsExe = FALSE;
    PIMAGE_NT_HEADERS ImageNtHeader = NULL;
    OBJECT_ATTRIBUTES Obja;
    SIZE_T ViewSize = 0;
    PBASE_MSG_SXS_HANDLES ManifestFileHandles = NULL;
    PBASE_MSG_SXS_HANDLES ManifestImageHandles = NULL;
    BASE_MSG_SXS_HANDLES ManifestHandles = { 0 };
    BASE_MSG_SXS_HANDLES ManifestHandles2 = { 0 };
    BASE_MSG_SXS_HANDLES PolicyHandles = { 0 };
    BOOL CloseManifestImageHandles = TRUE;
    PCWSTR ManifestExtension = NULL;
    ULONG LdrCreateOutOfProcessImageFlags = 0;
    UCHAR  Win32ManifestAdminOverridePathStaticBuffer[MEDIUM_PATH * sizeof(WCHAR)];
    UCHAR  NtManifestAdminOverridePathStaticBuffer[MEDIUM_PATH * sizeof(WCHAR)];
    RTL_UNICODE_STRING_BUFFER Win32ManifestAdminOverridePath;
    RTL_UNICODE_STRING_BUFFER NtManifestAdminOverridePath;
    UNICODE_STRING ManifestAdminOverridePathPieces[3];
    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR ManifestAdminOverridePathPair =
        { &Win32ManifestAdminOverridePath.String, &NtManifestAdminOverridePath.String };
    BOOL PassFilePair = FALSE;
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR FilePairToPass = NULL;
    ULONG BasepSxsCreateStreamsFlags = 0;

#if DBG
    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n",  __FUNCTION__);

    ASSERT(ActParams != NULL);
    ASSERT(ActParams->cbSize == sizeof(*ActParams));
    ASSERT(ActParams->dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID);
    ASSERT(ActParams->dwFlags & ACTCTX_FLAG_LANGID_VALID);
    ASSERT(ActParams->dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID);
    ASSERT(ActivationContextData != NULL);
    ASSERT(*ActivationContextData == NULL);
#endif

    RtlZeroMemory(&Message, sizeof(Message));
    RtlInitUnicodeStringBuffer(&Win32PolicyPath, Win32PolicyPathStaticBuffer, sizeof(Win32PolicyPathStaticBuffer));
    RtlInitUnicodeStringBuffer(&NtPolicyPath, NtPolicyPathStaticBuffer, sizeof(NtPolicyPathStaticBuffer));
    RtlInitUnicodeStringBuffer(&Win32ManifestAdminOverridePath, Win32ManifestAdminOverridePathStaticBuffer, sizeof(Win32ManifestAdminOverridePathStaticBuffer));
    RtlInitUnicodeStringBuffer(&NtManifestAdminOverridePath, NtManifestAdminOverridePathStaticBuffer, sizeof(NtManifestAdminOverridePathStaticBuffer));
    NtManifestPath.Buffer = NULL;

    Message.ProcessorArchitecture = ActParams->wProcessorArchitecture;
    Message.LangId = ActParams->wLangId;
    RtlInitUnicodeString(&Message.AssemblyDirectory, RTL_CONST_CAST(PWSTR)(ActParams->lpAssemblyDirectory));
    if (Message.AssemblyDirectory.Length != 0) {
        ASSERT(RTL_STRING_IS_NUL_TERMINATED(&Message.AssemblyDirectory));
        if (!RTL_STRING_IS_NUL_TERMINATED(&Message.AssemblyDirectory)) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() AssemblyDirectory is not null terminated\n", __FUNCTION__);
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if (ActParams->lpSource == NULL || ActParams->lpSource[0] == 0) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() empty lpSource %ls\n", __FUNCTION__, ActParams->lpSource);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((ActParams->dwFlags & ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF) != 0) {
        Message.Flags = BASE_MSG_SXS_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT;
        RtlInitUnicodeString(&Message.TextualAssemblyIdentity, ActParams->lpSource);
        // no streams, no handles, no manifest
        // no policy, no last modified time
        // no paths
        goto CsrMessageFilledIn;
    }

    RtlInitUnicodeString(&Win32ManifestPath, ActParams->lpSource);
    PathType = RtlDetermineDosPathNameType_U(ActParams->lpSource);
    if (!RtlDosPathNameToNtPathName_U(
        Win32ManifestPath.Buffer,
        &NtManifestPath,
        NULL,
        NULL)) {
        //
        // NTRAID#NTBUG9-147881-2000/7/21-a-JayK errors mutated into bools in ntdll
        //
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto Exit;
    }

    // If there's an explicitly set HMODULE, we need to verify that the HMODULE came from the lpSource
    // specified and then we can avoid opening/mapping the file.
    if (ActParams->dwFlags & ACTCTX_FLAG_HMODULE_VALID) {
        ManifestHandles.File = NULL;
        ManifestHandles.Section = NULL;
        ManifestHandles.ViewBase = ActParams->hModule;

        if (LDR_IS_DATAFILE(ActParams->hModule))
            LdrCreateOutOfProcessImageFlags = LDR_DLL_MAPPED_AS_DATA;
        else
            LdrCreateOutOfProcessImageFlags = LDR_DLL_MAPPED_AS_IMAGE;

        // Don't try to close the handles or unmap the view on exit of this function...
        CloseManifestImageHandles = FALSE;
    } else {
        InitializeObjectAttributes(
            &Obja,
            &NtManifestPath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        Status =
            NtOpenFile(
                &ManifestHandles.File,
                FILE_GENERIC_READ | FILE_EXECUTE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );
        if (!NT_SUCCESS(Status)) {
            if (DPFLTR_LEVEL_STATUS(Status) == DPFLTR_ERROR_LEVEL) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_LEVEL_STATUS(Status),
                    "SXS: %s() NtOpenFile(%wZ) failed\n",
                    __FUNCTION__,
                    Obja.ObjectName
                    );
            }
            goto Exit;
        }

        KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() NtOpenFile(%wZ) succeeded\n", __FUNCTION__, Obja.ObjectName));
        
        Status =
            NtCreateSection(
                &ManifestHandles.Section,
                SECTION_MAP_READ,
                NULL, // ObjectAttributes
                NULL, // MaximumSize (whole file)
                PAGE_READONLY, // SectionPageProtection
                SEC_COMMIT, // AllocationAttributes
                ManifestHandles.File
                );
        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() NtCreateSection() failed\n", __FUNCTION__);
            goto Exit;
        }
        
        KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() NtCreateSection() succeeded\n", __FUNCTION__));

        Status =
            NtMapViewOfSection(
                ManifestHandles.Section,
                NtCurrentProcess(),
                &ManifestHandles.ViewBase,
                0, // ZeroBits,
                0, // CommitSize,
                NULL, // SectionOffset,
                &ViewSize, // ViewSize,
                ViewShare, // InheritDisposition,
                0, // AllocationType,
                PAGE_READONLY // Protect
                );
        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() NtMapViewOfSection failed\n", __FUNCTION__);
            goto Exit;
        }

        LdrCreateOutOfProcessImageFlags = LDR_DLL_MAPPED_AS_DATA;


    }

    ImageNtHeader = RtlImageNtHeader(LDR_DATAFILE_TO_VIEW(ManifestHandles.ViewBase));
    IsImage = (ImageNtHeader != NULL);
    if (IsImage) {
        IsExe = ((ImageNtHeader->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0);
        ManifestImageHandles = &ManifestHandles;
        ManifestFileHandles = &ManifestHandles2;
    } else {
        IsExe = FALSE;
        ManifestFileHandles = &ManifestHandles;
        ManifestImageHandles = NULL;
    }

#if defined(ACTCTX_FLAG_LIKE_CREATEPROCESS)
    if ((ActParams->dwFlags & ACTCTX_FLAG_LIKE_CREATEPROCESS) != 0 && !IsExe) {
        //
        // We want to be like CreateProcess(foo.dll), which does:
        //  SetLastError(ERROR_BAD_EXE_FORMAT), there are a few mappings from ntstatus
        // to this error.
        //
        Status = STATUS_INVALID_IMAGE_FORMAT;
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() bad flags/file combo\n", __FUNCTION__);
        goto Exit;
    }
#endif

    // See if someone's trying to load a resource from something that is not an EXE
    if ((!IsImage) && (ActParams->lpResourceName != NULL)) {
        // Yup...
        Status = STATUS_INVALID_IMAGE_FORMAT;
        goto Exit;
    }
    // or if an exe but no resource (and none found by probing earlier)
    else if (IsImage && (ActParams->dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) == 0) {
        Status = STATUS_RESOURCE_TYPE_NOT_FOUND;
        goto Exit;
    }


    //
    // form up the policy path
    //   foo.manifest => foo.policy
    //   foo.dll, resourceid == n, resourceid != 1 => foo.dll.n.policy
    //   foo.dll, resourceid == 1 => foo.dll.policy
    //   foo.dll, resourceid == "bar" => foo.dll.bar.policy
    //
    PolicyPathPieces[0] = Win32ManifestPath;

    PolicyPathPieces[1].Length = 0;
    PolicyPathPieces[1].MaximumLength = 0;
    PolicyPathPieces[1].Buffer = NULL;
#if defined(ACTCTX_FLAG_LIKE_CREATEPROCESS)
    if (ActParams->dwFlags & ACTCTX_FLAG_LIKE_CREATEPROCESS) {
         ; /* nothing */
    } else
#endif
	if (ActParams->dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) {
        if (IS_INTRESOURCE(ActParams->lpResourceName)) {
            if (ActParams->lpResourceName != MAKEINTRESOURCEW(CREATEPROCESS_MANIFEST_RESOURCE_ID)) {
                PolicyPathPieces[1].Length = (USHORT) (_snwprintf(PolicyManifestResourceId, RTL_NUMBER_OF(PolicyManifestResourceId), L".%lu", (ULONG)(ULONG_PTR)ActParams->lpResourceName) * sizeof(WCHAR));
                PolicyPathPieces[1].MaximumLength = sizeof(PolicyManifestResourceId);
                PolicyPathPieces[1].Buffer = PolicyManifestResourceId;
            }
        } else {
            RtlInitUnicodeString(&PolicyPathPieces[1], ActParams->lpResourceName);
        }
    }
    PolicyPathPieces[2] = SxsPolicySuffix;
    ManifestExtension = wcsrchr(Win32ManifestPath.Buffer, L'.');
    if (ManifestExtension != NULL && _wcsicmp(ManifestExtension, SxsManifestSuffix.Buffer) == 0) {
        RemoveManifestExtensionFromPolicy = SxsManifestSuffix.Length;
        PolicyPathPieces[0].Length -= RemoveManifestExtensionFromPolicy;
    }

    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(&Win32PolicyPath, RTL_NUMBER_OF(PolicyPathPieces), PolicyPathPieces))) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() RtlMultiAppendUnicodeStringBuffer failed\n", __FUNCTION__);
        goto Exit;
    }
    PolicyPathPieces[0] = NtManifestPath;
    PolicyPathPieces[0].Length -= RemoveManifestExtensionFromPolicy;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(&NtPolicyPath, RTL_NUMBER_OF(PolicyPathPieces), PolicyPathPieces))) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() RtlMultiAppendUnicodeStringBuffer failed\n", __FUNCTION__);
        goto Exit;
    }

    //
    // form up the path to the administrative override file for manifests in resources
    //
    // not an image => no override
    // manifest=foo.dll, resourceid=n, n != 1 => foo.dll.n.manifest
    // manifest=foo.dll, resourceid=n, n == 1 => foo.dll.manifest
    //
    // the second to last element is the same as for the policy file
    //
    if (IsImage) {
        ManifestAdminOverridePathPieces[0] = Win32ManifestPath;
        ManifestAdminOverridePathPieces[1] = PolicyPathPieces[1];
        ManifestAdminOverridePathPieces[2] = SxsManifestSuffix;
        if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(
                &Win32ManifestAdminOverridePath,
                RTL_NUMBER_OF(ManifestAdminOverridePathPieces),
                ManifestAdminOverridePathPieces))
                ) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() RtlMultiAppendUnicodeStringBuffer failed\n", __FUNCTION__);
            goto Exit;
        }
        ManifestAdminOverridePathPieces[0] = NtManifestPath;
        if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(
                &NtManifestAdminOverridePath,
                RTL_NUMBER_OF(ManifestAdminOverridePathPieces),
                ManifestAdminOverridePathPieces))
                ) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() RtlMultiAppendUnicodeStringBuffer failed\n", __FUNCTION__);
            goto Exit;
        }
    }

    Message.ActivationContextData = ActivationContextData;
    ManifestHandles.Process = NtCurrentProcess();

#if DBG
    if (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE)
    {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:        Win32ManifestPath: \"%wZ\"\n", __FUNCTION__, &Win32ManifestPath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:           NtManifestPath: \"%wZ\"\n", __FUNCTION__, &NtManifestPath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:   Win32ManifestAdminPath: \"%wZ\"\n", __FUNCTION__, &Win32ManifestAdminOverridePath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:      NtManifestAdminPath: \"%wZ\"\n", __FUNCTION__, &NtManifestAdminOverridePath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:          Win32PolicyPath: \"%wZ\"\n", __FUNCTION__, &Win32PolicyPath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:           Nt32PolicyPath: \"%wZ\"\n", __FUNCTION__, &NtPolicyPath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:  ManifestHandles.Process: %p\n", __FUNCTION__, ManifestHandles.Process);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:     ManifestHandles.File: %p\n", __FUNCTION__, ManifestHandles.File);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:  ManifestHandles.Section: %p\n", __FUNCTION__, ManifestHandles.Section);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s: ManifestHandles.ViewBase: %p\n", __FUNCTION__, ManifestHandles.ViewBase);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:                  IsImage: %lu\n", __FUNCTION__, (ULONG) IsImage);
    }
#endif

    PassFilePair = (!IsImage || (Flags & BASEP_CREATE_ACTCTX_FLAG_NO_ADMIN_OVERRIDE) == 0);
    FilePairToPass = IsImage ? &ManifestAdminOverridePathPair : &ManifestPathPair;

    Status =
        BasepSxsCreateStreams(
            BasepSxsCreateStreamsFlags,
            LdrCreateOutOfProcessImageFlags,
            FILE_GENERIC_READ | FILE_EXECUTE,   // AccessMask,
            NULL,                               // override manifest
            NULL,                               // override policy
            PassFilePair ? FilePairToPass : NULL,
            ManifestFileHandles,
            IsImage ? &ManifestPathPair : NULL,
            ManifestImageHandles,
            (ULONG_PTR)(ActParams->lpResourceName),
            &PolicyPathPair,
            &PolicyHandles,
            &Message.Flags,
            &Message.Manifest,
            &Message.Policy
            );
CsrMessageFilledIn:
    if (Message.Flags == 0) {
        ASSERT(!NT_SUCCESS(Status));
        //
        // BasepSxsCreateStreams doesn't DbgPrint for the file not found, but
        // we want to.
        //
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_LEVEL_STATUS(Status),
            "SXS: %s() BasepSxsCreateStreams() failed\n",
            __FUNCTION__
            );
        goto Exit;
    }
    ASSERT(Message.Flags & (BASE_MSG_SXS_MANIFEST_PRESENT | BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT));

    //
    // file not found for .policy is ok
    //
    if (((Message.Flags & BASE_MSG_SXS_POLICY_PRESENT) == 0) &&
        BasepSxsIsStatusFileNotFoundEtc(Status)) {
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() BasepSxsCreateStreams() failed\n", __FUNCTION__);
        goto Exit;
    }

    // Fly my pretties, fly!
    Status = CsrBasepCreateActCtx( &Message );

    if (!NT_SUCCESS(Status)) {
        ASSERT(*ActivationContextData == NULL);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() Calling csrss server failed\n", __FUNCTION__);
        goto Exit;
    }

    Status = STATUS_SUCCESS;

Exit:
    if (ManifestFileHandles != NULL) {
        BasepSxsCloseHandles(ManifestFileHandles);
    }
    if (ManifestImageHandles != NULL && CloseManifestImageHandles) {
        BasepSxsCloseHandles(ManifestImageHandles);
    }
    BasepSxsCloseHandles(&PolicyHandles);

    RtlFreeHeap(RtlProcessHeap(), 0, NtManifestPath.Buffer);
    RtlFreeUnicodeStringBuffer(&Win32PolicyPath);
    RtlFreeUnicodeStringBuffer(&NtPolicyPath);
    RtlFreeUnicodeStringBuffer(&Win32ManifestAdminOverridePath);
    RtlFreeUnicodeStringBuffer(&NtManifestAdminOverridePath);
    if (ActivationContextData != NULL) {
        NtUnmapViewOfSection(NtCurrentProcess(), ActivationContextData);
    }
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_STATUS(Status),
        "SXS: %s(%ls) exiting 0x%08lx\n",
        __FUNCTION__,
        (ActParams != NULL ? ActParams->lpSource : NULL),
        Status
        );
#endif
    return Status;
}

NTSTATUS
BasepSxsCreateResourceStream(
    IN ULONG                            LdrCreateOutOfProcessImageFlags,
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR   Win32NtPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES        Handles,
    IN ULONG_PTR                        MappedResourceName,
    OUT PBASE_MSG_SXS_STREAM            MessageStream
    )
{
//
// Any handles passed in, we do not close.
// Any handles we open, we close, except the ones passed out in MessageStream.
//
    IO_STATUS_BLOCK   IoStatusBlock;
    IMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry;
    FILE_BASIC_INFORMATION FileBasicInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    LDR_OUT_OF_PROCESS_IMAGE OutOfProcessImage = {0};
    ULONG_PTR ResourcePath[] = { ((ULONG_PTR)RT_MANIFEST), 0, 0 };
    PVOID ResourceAddress = 0;
    ULONG ResourceSize = 0;

    KdPrintEx((
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: %s(%wZ) beginning\n",
        __FUNCTION__,
        (Win32NtPathPair != NULL) ? Win32NtPathPair->Win32 : (PCUNICODE_STRING)NULL
        ));

    ASSERT(Handles != NULL);
    ASSERT(Handles->Process != NULL);
    ASSERT(MessageStream != NULL);
    ASSERT(Win32NtPathPair != NULL);

    // LdrFindOutOfProcessResource currently does not search on id or langid, just type.
    // If you give it a nonzero id, it will only find it if is the first one.
    // Another approach would be to have LdrFindOutOfProcessResource return the id it found.
    ASSERT((MappedResourceName == (ULONG_PTR)CREATEPROCESS_MANIFEST_RESOURCE_ID) || (Handles->Process == NtCurrentProcess()));

    //
    // We could open any null handles like CreateFileStream does, but we happen to know
    // that our clients open all of them.
    //

    // CreateActCtx maps the view earlier to determine if it starts MZ.
    // CreateProcess gives us the view from the peb.
    // .policy files are never resources.
    ASSERT(Handles->ViewBase != NULL);

    Status =
        LdrCreateOutOfProcessImage(
            LdrCreateOutOfProcessImageFlags,
            Handles->Process,
            Handles->ViewBase,
            &OutOfProcessImage
            );
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() LdrCreateOutOfProcessImage failed\n", __FUNCTION__);
        goto Exit;
    }

    ResourcePath[1] = MappedResourceName;

    Status =
        LdrFindCreateProcessManifest(
            0, // flags
            &OutOfProcessImage,
            ResourcePath,
            RTL_NUMBER_OF(ResourcePath),
            &ResourceDataEntry
            );
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() LdrFindOutOfProcessResource failed; nt status = %08lx\n", __FUNCTION__, Status);
        goto Exit;
    }

    Status =
        LdrAccessOutOfProcessResource(
            0, // flags
            &OutOfProcessImage,
            &ResourceDataEntry,
            &ResourceAddress,
            &ResourceSize);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() LdrAccessOutOfProcessResource failed; nt status = %08lx\n", __FUNCTION__, Status);
        goto Exit;
    }

    MessageStream->Handle = Handles->Process;
    MessageStream->FileHandle = Handles->File;
    MessageStream->PathType = BASE_MSG_PATHTYPE_FILE;
    MessageStream->FileType = BASE_MSG_FILETYPE_XML;
    MessageStream->Path = *Win32NtPathPair->Win32; // it will be put in the csr capture buffer later
    MessageStream->HandleType = BASE_MSG_HANDLETYPE_PROCESS;
    MessageStream->Offset = (ULONGLONG) ResourceAddress;
    MessageStream->Size = ResourceSize;

#if DBG
    if (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() ResourceAddress:%p\n", __FUNCTION__, ResourceAddress);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() OutOfProcessImage.DllHandle:%p\n", __FUNCTION__, OutOfProcessImage.DllHandle);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() MessageStream->Offset:0x%I64x\n", __FUNCTION__, MessageStream->Offset);
    }
#endif

    Status = STATUS_SUCCESS;
Exit:
    LdrDestroyOutOfProcessImage(&OutOfProcessImage);
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_STATUS(Status),
        "SXS: %s(%wZ) exiting 0x%08lx\n",
        __FUNCTION__,
        (Win32NtPathPair != NULL) ? Win32NtPathPair->Win32 : (PCUNICODE_STRING)NULL,
        Status
        );
#endif
    return Status;
}

VOID
BasepSxsOverrideStreamToMessageStream(
    IN  PCSXS_OVERRIDE_STREAM OverrideStream,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    )
{
    MessageStream->FileType = BASE_MSG_FILETYPE_XML;
    MessageStream->PathType = BASE_MSG_PATHTYPE_OVERRIDE;
    MessageStream->Path = OverrideStream->Name;
    MessageStream->FileHandle = NULL;
    MessageStream->HandleType = BASE_MSG_HANDLETYPE_CLIENT_PROCESS;
    MessageStream->Handle = NULL;
    MessageStream->Offset = (ULONGLONG)OverrideStream->Address;
    MessageStream->Size = OverrideStream->Size;
}

NTSTATUS
BasepSxsCreateStreams(
    IN ULONG                                Flags,
    IN ULONG                                LdrCreateOutOfProcessImageFlags,
    IN ACCESS_MASK                          AccessMask,
    IN PCSXS_OVERRIDE_STREAM                OverrideManifest OPTIONAL,
    IN PCSXS_OVERRIDE_STREAM                OverridePolicy OPTIONAL,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    ManifestFilePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            ManifestFileHandles,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    ManifestExePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            ManifestExeHandles,
    IN ULONG_PTR                            MappedManifestResourceName OPTIONAL,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    PolicyPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            PolicyHandles,
    OUT PULONG                              MessageFlags,
    OUT PBASE_MSG_SXS_STREAM                ManifestMessageStream,
    OUT PBASE_MSG_SXS_STREAM                PolicyMessageStream OPTIONAL
    )
/*
A mismash of combined code for CreateActCtx and CreateProcess.
*/
{
    NTSTATUS         Status = STATUS_SUCCESS;
    BOOLEAN LookForPolicy = TRUE;

#if DBG
    ASSERT(MessageFlags != NULL);
    ASSERT(ManifestMessageStream != NULL);
    ASSERT((ManifestFilePathPair != NULL) || (ManifestExePathPair != NULL));
    ASSERT((MappedManifestResourceName == 0) || (ManifestExePathPair != NULL));
    ASSERT((PolicyPathPair != NULL) == (PolicyMessageStream != NULL));
    if (ManifestFilePathPair != NULL) {
        ASSERT(ManifestFilePathPair->Win32 != NULL);
        ASSERT(ManifestFilePathPair->Nt != NULL);
    }
    if (ManifestExePathPair != NULL) {
        ASSERT(ManifestExePathPair->Win32 != NULL);
        ASSERT(ManifestExePathPair->Nt != NULL);
    }
    if (PolicyPathPair != NULL) {
        ASSERT(PolicyPathPair->Win32 != NULL);
        ASSERT(PolicyPathPair->Nt != NULL);
    }
    if (OverrideManifest != NULL && OverrideManifest->Size != 0) {
        ASSERT(OverrideManifest->Address != NULL);
    }
    if (OverridePolicy != NULL && OverridePolicy->Size != 0) {
        ASSERT(OverridePolicy->Address != NULL);
    }

    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: %s(ManifestFilePath:%wZ, ManifestExePath:%wZ, PolicyPath:%wZ) beginning\n",
        __FUNCTION__,
        (ManifestFilePathPair != NULL) ? ManifestFilePathPair->Win32 : (PCUNICODE_STRING)NULL,
        (ManifestExePathPair != NULL) ? ManifestExePathPair->Win32 : (PCUNICODE_STRING)NULL,
        (PolicyPathPair != NULL) ? PolicyPathPair->Win32 : (PCUNICODE_STRING)NULL
        );
#endif

    if (OverrideManifest != NULL) {
        BasepSxsOverrideStreamToMessageStream(OverrideManifest, ManifestMessageStream);
        Status = STATUS_SUCCESS;
        //
        // When appcompat provides a manifest, do not look for a policy.
        // This let's us fix the Matrix DVD.
        //
        LookForPolicy = FALSE;
        goto ManifestFound;
    }

    if (ManifestFilePathPair != NULL) {
        Status =
            BasepSxsCreateFileStream(
                AccessMask,
                ManifestFilePathPair,
                ManifestFileHandles,
                ManifestMessageStream);
        if (NT_SUCCESS(Status)) {
            goto ManifestFound;
        }
        if (!BasepSxsIsStatusFileNotFoundEtc(Status)) {
            goto Exit;
        }
    }

    if (ManifestExePathPair != NULL) {
        Status =
            BasepSxsCreateResourceStream(
                LdrCreateOutOfProcessImageFlags,
                ManifestExePathPair,
                ManifestExeHandles,
                MappedManifestResourceName,
                ManifestMessageStream);
        if (NT_SUCCESS(Status)) {
            goto ManifestFound;
        }
    }
    ASSERT(!NT_SUCCESS(Status)); // otherwise this should be unreachable
    goto Exit;
ManifestFound:
    // indicate partial success even if policy file not found
    *MessageFlags |= BASE_MSG_SXS_MANIFEST_PRESENT;

    if (OverridePolicy != NULL) {
        BasepSxsOverrideStreamToMessageStream(OverridePolicy, PolicyMessageStream);
        *MessageFlags |= BASE_MSG_SXS_POLICY_PRESENT;
        Status = STATUS_SUCCESS;
    } else if (LookForPolicy && PolicyPathPair != NULL) {
        Status = BasepSxsCreateFileStream(AccessMask, PolicyPathPair, PolicyHandles, PolicyMessageStream);
        if (!NT_SUCCESS(Status)) {
            goto Exit; // our caller knows this is not necessarily fatal
        }
        *MessageFlags |= BASE_MSG_SXS_POLICY_PRESENT;
    }

    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_STATUS(Status),
        "SXS: %s(MessageFlags=%lu) exiting 0x%08lx\n",
        __FUNCTION__,
        *MessageFlags,
        Status);
#endif // DBG

    return Status;
}

BOOL
BasepSxsIsStatusFileNotFoundEtc(
    NTSTATUS Status
    )
{
    DWORD Error;
    if (NT_SUCCESS(Status)) {
        return FALSE;
    }

    // First check the most obvious sounding, probably the most common.
    if (
        Status == STATUS_OBJECT_PATH_NOT_FOUND
        || Status == STATUS_OBJECT_NAME_NOT_FOUND
        || Status == STATUS_NO_SUCH_FILE
        )
    {
        return TRUE;
    }
    // Then get the eight or so less obvious ones by their mapping
    // to the two obvious Win32 values and the two inobvious Win32 values.
    Error = RtlNtStatusToDosErrorNoTeb(Status);
    // REVIEW
    //     STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,
    if (   Error == ERROR_FILE_NOT_FOUND
        || Error == ERROR_PATH_NOT_FOUND
        || Error == ERROR_BAD_NETPATH // \\a\b
        || Error == ERROR_BAD_NET_NAME // \\a-jayk2\b
        )
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
BasepSxsIsStatusResourceNotFound(
    NTSTATUS Status
    )
{
    if (NT_SUCCESS(Status))
        return FALSE;
    if (
           Status == STATUS_RESOURCE_DATA_NOT_FOUND
        || Status == STATUS_RESOURCE_TYPE_NOT_FOUND
        || Status == STATUS_RESOURCE_NAME_NOT_FOUND
        || Status == STATUS_RESOURCE_LANG_NOT_FOUND
        )
    {
        return TRUE;
    }
    return FALSE;
}

NTSTATUS
BasepSxsGetProcessImageBaseAddress(
    HANDLE Process,
    PVOID* ImageBaseAddress
    )
{
    PROCESS_BASIC_INFORMATION ProcessBasicInfo;
    NTSTATUS Status;

    C_ASSERT(RTL_FIELD_SIZE(PEB, ImageBaseAddress) == sizeof(*ImageBaseAddress));

    Status =
        NtQueryInformationProcess(
            Process,
            ProcessBasicInformation,
            &ProcessBasicInfo,
            sizeof(ProcessBasicInfo),
            NULL
            );
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status =
        NtReadVirtualMemory(
            Process,
            ((PUCHAR)ProcessBasicInfo.PebBaseAddress) + FIELD_OFFSET(PEB, ImageBaseAddress),
            ImageBaseAddress,
            sizeof(*ImageBaseAddress),
            NULL
            );
Exit:
    return Status;
}

extern const SXS_OVERRIDE_STREAM SxsForceEmptyPolicy =
{
    RTL_CONSTANT_STRING(L"SxsForceEmptyPolicy"),
    NULL,
    0
};


#if defined(ACTCTX_FLAG_LIKE_CREATEPROCESS)

NTSTATUS
BasepCreateActCtxLikeCreateProcess(
    PCACTCXW pParams
    )
{
    //
    // We could allow processor architecture, as long as it matches the client and the file,
    // modulo x86 vs. x86-on-ia64, we can smooth over that difference.
    //
    BASE_MSG_SXS_HANDLES  ExeHandles = { 0 };
    BASE_MSG_SXS_HANDLES  AdminOverrideHandles = { 0 };
    const ULONG OkFlags = (ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID | ACTCTX_FLAG_LANGID_VALID | ACTCTX_FLAG_SET_PROCESS_DEFAULT | ACTCTX_FLAG_LIKE_CREATEPROCESS);
    const ULONG BadFlags = (ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID | ACTCTX_FLAG_APPLICATION_NAME_VALID | ACTCTX_FLAG_HMODULE_VALID | ACTCTX_FLAG_RESOURCE_NAME_VALID);
    ACTCXW Params;

    Params.dwFlags = pParams->dwFlags;
    if (Params.dwFlags & BadFlags) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Bad flags (yourFlags: okFlags : 0x%lx, badFlags;  )",
            __FUNCTION__,
            Params.dwFlags,
            OkFlags
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
}
#endif

NTSTATUS
BasepSxsCreateProcessCsrMessage(
    IN PCSXS_OVERRIDE_STREAM             OverrideManifest OPTIONAL,
    IN PCSXS_OVERRIDE_STREAM             OverridePolicy   OPTIONAL,
    IN OUT PCSXS_WIN32_NT_PATH_PAIR      ManifestPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         ManifestFileHandles,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR ExePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         ManifestExeHandles,
    IN OUT PCSXS_WIN32_NT_PATH_PAIR      PolicyPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         PolicyHandles,
    IN OUT PRTL_UNICODE_STRING_BUFFER    Win32AssemblyDirectoryBuffer,
    OUT PBASE_SXS_CREATEPROCESS_MSG      Message
    )
{
    UNICODE_STRING PathPieces[2];
    NTSTATUS Status = STATUS_SUCCESS;

    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR ConstantManifestPathPair =
        { &ManifestPathPair->Win32->String, &ManifestPathPair->Nt->String };

    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR ConstantPolicyPathPair =
        { &PolicyPathPair->Win32->String, &PolicyPathPair->Nt->String };

#if DBG
    //
    // assertions are anded to avoid access violating
    //
    ASSERT(ExePathPair != NULL
        && ExePathPair->Win32 != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, ExePathPair->Win32))
        && (ExePathPair->Win32->Buffer[1] == '\\'
           ||  ExePathPair->Win32->Buffer[1] == ':')
        && ExePathPair->Nt != NULL
        && ExePathPair->Nt->Buffer[0] == '\\'
        && NT_SUCCESS(RtlValidateUnicodeString(0, ExePathPair->Nt)));
    ASSERT(ManifestPathPair != NULL
        && ManifestPathPair->Win32 != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, &ManifestPathPair->Win32->String))
        && ManifestPathPair->Nt != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, &ManifestPathPair->Nt->String)));
    ASSERT(PolicyPathPair != NULL
        && PolicyPathPair->Win32 != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, &PolicyPathPair->Win32->String))
        && PolicyPathPair->Nt != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, &PolicyPathPair->Nt->String)));
    ASSERT(Win32AssemblyDirectoryBuffer != NULL
       && NT_SUCCESS(RtlValidateUnicodeString(0, &Win32AssemblyDirectoryBuffer->String)));
    ASSERT(ManifestExeHandles != NULL
        && ManifestExeHandles->Process != NULL
        && ManifestExeHandles->ViewBase == NULL);
    ASSERT(Message != NULL);
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: %s(%wZ) beginning\n",
        __FUNCTION__,
        (ExePathPair != NULL) ? ExePathPair->Win32 : (PCUNICODE_STRING)NULL
        );
#endif

    // C_ASSERT didn't work.
    ASSERT(BASE_MSG_FILETYPE_NONE == 0);
    ASSERT(BASE_MSG_PATHTYPE_NONE == 0);
    RtlZeroMemory(Message, sizeof(*Message));

    Status = BasepSxsGetProcessImageBaseAddress(ManifestExeHandles->Process, &ManifestExeHandles->ViewBase);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // form up foo.exe.manifest and foo.exe.policy, nt and win32 flavors
    //
    PathPieces[0] = *ExePathPair->Win32;
    PathPieces[1] = SxsManifestSuffix;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(ManifestPathPair->Win32, 2, PathPieces)))
        goto Exit;
    PathPieces[1] = SxsPolicySuffix;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(PolicyPathPair->Win32, 2, PathPieces)))
        goto Exit;
    PathPieces[0] = *ExePathPair->Nt;
    PathPieces[1] = SxsManifestSuffix;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(ManifestPathPair->Nt, 2, PathPieces)))
        goto Exit;
    PathPieces[1] = SxsPolicySuffix;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(PolicyPathPair->Nt, 2, PathPieces)))
        goto Exit;

    Status =
        BasepSxsCreateStreams(
			0,
            LDR_DLL_MAPPED_AS_UNFORMATED_IMAGE, // LdrCreateOutOfProcessImageFlags
            FILE_GENERIC_READ | FILE_EXECUTE,
            OverrideManifest,
            OverridePolicy,
            &ConstantManifestPathPair,
            ManifestFileHandles,
            ExePathPair,
            ManifestExeHandles,
            (ULONG_PTR)CREATEPROCESS_MANIFEST_RESOURCE_ID,
            &ConstantPolicyPathPair,
            PolicyHandles,
            &Message->Flags,
            &Message->Manifest,
            &Message->Policy
            );

    //
    // did we find manifest and policy
    // it's ok to find neither but if either then always manifest
    //
    if (BasepSxsIsStatusFileNotFoundEtc(Status)
        || BasepSxsIsStatusResourceNotFound(Status)) {
        Status = STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    if (Message->Flags == 0) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // Set the assembly directory. Use a copy to not violate const.
    // We can't just shorten the path because basesrv expects the string to be nul
    // terminated, and better to meet that expection here than there.
    //
    Status = RtlAssignUnicodeStringBuffer(Win32AssemblyDirectoryBuffer, ExePathPair->Win32);
    if (!NT_SUCCESS(Status))
        goto Exit;
    Status = RtlRemoveLastFullDosOrNtPathElement(0, Win32AssemblyDirectoryBuffer);
    if (!NT_SUCCESS(Status))
        goto Exit;
    RTL_NUL_TERMINATE_STRING(&Win32AssemblyDirectoryBuffer->String);
    Message->AssemblyDirectory = Win32AssemblyDirectoryBuffer->String;

    Status = STATUS_SUCCESS;
Exit:

#if DBG
    if (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: %s() Message {\n"
            "SXS:   Flags:(%s | %s | %s)\n"
            "SXS: }\n",
            __FUNCTION__,
            (Message->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) ? "MANIFEST_PRESENT" : "0",
            (Message->Flags & BASE_MSG_SXS_POLICY_PRESENT) ? "POLICY_PRESENT" : "0",
            (Message->Flags & BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT) ? "TEXTUAL_ASSEMBLY_IDENTITY_PRESENT" : "0"
            );
        if (Message->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) {
            BasepSxsDbgPrintMessageStream(__FUNCTION__, "Manifest", &Message->Manifest);
        }
        if (Message->Flags & BASE_MSG_SXS_POLICY_PRESENT) {
            BasepSxsDbgPrintMessageStream(__FUNCTION__, "Policy", &Message->Policy);
        }
        //
        // CreateProcess does not support textual identities.
        //
        ASSERT((Message->Flags & BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT) == 0);
    }        
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_STATUS(Status),
        "SXS: %s(%wZ) exiting 0x%08lx\n",
        __FUNCTION__,
        (ExePathPair != NULL) ? ExePathPair->Win32 : (PCUNICODE_STRING)NULL,
        Status
        );
#endif
    return Status;
}

NTSTATUS
BasepSxsCreateFileStream(
    IN ACCESS_MASK                      AccessMask,
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR   Win32NtPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES        Handles,
    PBASE_MSG_SXS_STREAM                MessageStream
    )
{
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK   IoStatusBlock;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS Status1 = STATUS_SUCCESS;
    FILE_STANDARD_INFORMATION FileBasicInformation;
#if DBG
    ASSERT(Win32NtPathPair != NULL);
    if (Win32NtPathPair != NULL) {
        ASSERT(Win32NtPathPair->Win32 != NULL);
        ASSERT(Win32NtPathPair->Nt != NULL);
    }
    ASSERT(MessageStream != NULL);
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: %s(Path:%wZ, Handles:%p(Process:%p, File:%p, Section:%p), MessageStream:%p) beginning\n",
        __FUNCTION__,
        (Win32NtPathPair != NULL) ? Win32NtPathPair->Win32 : (PCUNICODE_STRING)NULL,
        Handles,
        (Handles != NULL) ? Handles->Process : NULL,
        (Handles != NULL) ? Handles->File : NULL,
        (Handles != NULL) ? Handles->Section : NULL,
        MessageStream
        );
#endif

    if (Handles->File == NULL) {

        CONST PCUNICODE_STRING NtPath = Win32NtPathPair->Nt;

        InitializeObjectAttributes(
            &Obja,
            RTL_CONST_CAST(PUNICODE_STRING)(NtPath),
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status =
            NtOpenFile(
                &Handles->File,
                AccessMask,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );
        if (!NT_SUCCESS(Status)) {
            if (DPFLTR_LEVEL_STATUS(Status) == DPFLTR_ERROR_LEVEL) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_LEVEL_STATUS(Status),
                    "SXS: %s() NtOpenFile(%wZ) failed\n",
                    __FUNCTION__,
                    Obja.ObjectName
                    );
            }
            goto Exit;
        }
        KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() NtOpenFile(%wZ) succeeded\n", __FUNCTION__, Obja.ObjectName));
    }
    if (Handles->Section == NULL) {
        Status =
            NtCreateSection(
                &Handles->Section,
                SECTION_MAP_READ,
                NULL, // ObjectAttributes
                NULL, // MaximumSize (whole file)
                PAGE_READONLY, // SectionPageProtection
                SEC_COMMIT, // AllocationAttributes
                Handles->File
                );
        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() NtCreateSection() failed\n", __FUNCTION__);
            goto Exit;
        }
        KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() NtCreateSection() succeeded\n", __FUNCTION__));
    }

    Status =
        NtQueryInformationFile(
            Handles->File,
            &IoStatusBlock,
            &FileBasicInformation,
            sizeof(FileBasicInformation),
            FileStandardInformation
            );
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() NtQueryInformationFile failed\n", __FUNCTION__);
        goto Exit;
    }
    // clamp >4gig on 32bit to 4gig (instead of modulo)
    // we should get an error later like STATUS_SECTION_TOO_BIG
    if (FileBasicInformation.EndOfFile.QuadPart > MAXSIZE_T) {
        FileBasicInformation.EndOfFile.QuadPart = MAXSIZE_T;
    }

    MessageStream->FileHandle = Handles->File;
    MessageStream->PathType = BASE_MSG_PATHTYPE_FILE;
    MessageStream->FileType = BASE_MSG_FILETYPE_XML;
    MessageStream->Path = *Win32NtPathPair->Win32; // it will be put in the csr capture buffer later
    MessageStream->HandleType = BASE_MSG_HANDLETYPE_SECTION;
    MessageStream->Handle = Handles->Section;
    MessageStream->Offset = 0;
     // cast to 32bits on 32bit platform
    MessageStream->Size   = (SIZE_T)FileBasicInformation.EndOfFile.QuadPart;

    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif // DBG

    return Status;
}

WINBASEAPI
BOOL
WINAPI
QueryActCtxW(
    IN DWORD dwFlags,
    IN HANDLE hActCtx,
    IN PVOID pvSubInstance,
    IN ULONG ulInfoClass,
    OUT PVOID pvBuffer,
    IN SIZE_T cbBuffer OPTIONAL,
    OUT SIZE_T *pcbWrittenOrRequired OPTIONAL
    )
{
    NTSTATUS Status;
    BOOL fSuccess = FALSE;
    ULONG FlagsToRtl = 0;
    ULONG ValidFlags =
              QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX
            | QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE
            | QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS
            | QUERY_ACTCTX_FLAG_NO_ADDREF
            ;

    if (pcbWrittenOrRequired != NULL)
        *pcbWrittenOrRequired = 0;

    //
    // compatibility with old values
    //  define QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX (0x00000001)
    //  define QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE (0x00000002)
    //  define QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS (0x00000003)
    //
    // 80000003 is in heavy use by -DISOLATION_AWARE_ENABLED.
    //
    switch (dwFlags & 3)
    {
        case 0: break; // It is legal to pass none of the flags, like if a real hActCtx is passed.
        case 1: dwFlags |= QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX; break;
        case 2: dwFlags |= QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE; break;
        case 3: dwFlags |= QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS; break;
    }
    dwFlags &= ~3; // These bits have been abandoned.

    if (dwFlags & ~ValidFlags) {
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad flags(passed: 0x%lx, allowed: 0x%lx, bad: 0x%lx)\n",
            __FUNCTION__,
            dwFlags,
            ValidFlags,
            (dwFlags & ~ValidFlags)
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_1);
        goto Exit;
    }

    switch (ulInfoClass)
    {
    default:
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad InfoClass(0x%lx)\n",
            __FUNCTION__,
            ulInfoClass
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_2);
        goto Exit;

    case ActivationContextBasicInformation:
    case ActivationContextDetailedInformation:
        break;

    case AssemblyDetailedInformationInActivationContext:
    case FileInformationInAssemblyOfAssemblyInActivationContext:
        if (pvSubInstance == NULL) 
        {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() InfoClass 0x%lx requires SubInstance != NULL\n",
                __FUNCTION__,
                ulInfoClass
                );
#endif
            BaseSetLastNTError(STATUS_INVALID_PARAMETER_3);
            goto Exit;
        }
    }


    if ((pvBuffer == NULL) && (cbBuffer != 0)) {
        // This probably means that they forgot to check for a failed allocation so we'll
        // attribute the failure to parameter 3.
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() (pvBuffer == NULL) && ((cbBuffer=0x%lu) != 0)\n",
            __FUNCTION__,
            cbBuffer
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_4);
        goto Exit;
    }

    if ((pvBuffer == NULL) && (pcbWrittenOrRequired == NULL)) {
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() (pvBuffer == NULL) && (pcbWrittenOrRequired == NULL)\n",
            __FUNCTION__
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_5);
        goto Exit;
    }

    ValidFlags = 
              QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX
            | QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE
            | QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS
            ;
    switch (dwFlags & ValidFlags)
    {
    default:
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s(dwFlags=0x%lx) more than one flag in 0x%lx was passed\n",
            __FUNCTION__,
            dwFlags,
            ValidFlags
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_1);
        goto Exit;
    case 0: // It is legal to pass none of the flags, like if a real hActCtx is passed.
        break;
    case QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX:
        FlagsToRtl |= RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT;
        break;
    case QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE:
        FlagsToRtl |= RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE;
        break;
    case QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS:
        FlagsToRtl |= RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS;
        break;
    }
    if ((dwFlags & QUERY_ACTCTX_FLAG_NO_ADDREF) != 0)
        FlagsToRtl |= RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF;

    Status = RtlQueryInformationActivationContext(FlagsToRtl, (PACTIVATION_CONTEXT) hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

NTSTATUS
NTAPI
BasepProbeForDllManifest(
    IN PVOID DllBase,
    IN PCWSTR FullDllPath,
    OUT PVOID *ActivationContextOut
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    PACTIVATION_CONTEXT ActivationContext = NULL;
    ACTCTXW acw = { sizeof(acw) };
    static const ULONG_PTR ResourceIdPath[2] = { (ULONG_PTR) RT_MANIFEST, (ULONG_PTR) ISOLATIONAWARE_MANIFEST_RESOURCE_ID };
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory = NULL;

    if (ActivationContextOut != NULL)
        *ActivationContextOut = NULL;

    ASSERT(ActivationContextOut != NULL);
    if (ActivationContextOut == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = LdrFindResourceDirectory_U(DllBase, ResourceIdPath, RTL_NUMBER_OF(ResourceIdPath), &ResourceDirectory);
    if (!NT_SUCCESS(Status))
        goto Exit;

    acw.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_HMODULE_VALID;
    acw.lpSource = FullDllPath;
    acw.lpResourceName = MAKEINTRESOURCEW(ISOLATIONAWARE_MANIFEST_RESOURCE_ID);
    acw.hModule = DllBase;

    ActivationContext = (PACTIVATION_CONTEXT) CreateActCtxW(&acw);

    if (ActivationContext == INVALID_HANDLE_VALUE) {
        Status = NtCurrentTeb()->LastStatusValue;
        goto Exit;
    }

    *ActivationContextOut = ActivationContext;
    Status = STATUS_SUCCESS;

Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tapeapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tapeapi.c

Abstract:

    This module implements Win32 Tape APIs

Author:

    Steve Wood (stevewo) 26-Mar-1992
    Lori Brown (Maynard)

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#include <ntddtape.h>

DWORD
BasepDoTapeOperation(
    IN HANDLE TapeDevice,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

DWORD
BasepDoTapeOperation(
    IN HANDLE TapeDevice,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )
{
    HANDLE NotificationEvent;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PIO_STATUS_BLOCK IoStatusBlock;

    IoStatusBlock = &IoStatus;

    NotificationEvent = CreateEvent(NULL, FALSE, FALSE, 
                                    NULL);
    if (NotificationEvent == NULL) {
        return GetLastError();
    }

    Status = NtDeviceIoControlFile( TapeDevice,
                                    NotificationEvent,
                                    NULL,
                                    NULL,
                                    IoStatusBlock,
                                    IoControlCode,
                                    InputBuffer,
                                    InputBufferLength,
                                    OutputBuffer,
                                    OutputBufferLength
                                  );
    if (Status == STATUS_PENDING) {

        WaitForSingleObject(NotificationEvent, INFINITE);

        Status = IoStatus.Status;

    }

    CloseHandle(NotificationEvent);

    if (!NT_SUCCESS( Status )) {
        return BaseSetLastNTError( Status );
    }
    else {
        return NO_ERROR;
    }
}


DWORD
WINAPI
SetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionMethod,
    DWORD dwPartition,
    DWORD dwOffsetLow,
    DWORD dwOffsetHigh,
    BOOL bImmediate
    )

/*++

Routine Description:

    This API is used to set the tape position.

Arguments:

    hDevice - Handle to the device on which to set the tape position.

    dwPositionMethod - Type of positioning to perform.
        This parameter can have one of the following values:

        TAPE_REWIND - Position the tape to beginning-of-tape or to
            beginning-of-partition if a multiple partition mode is in
            effect (ref: CreateTapePartition API). The parameters
            dwPartition, dwOffsetHigh, and dwOffsetLow are ignored.

        TAPE_ABSOLUTE_BLOCK - Position the tape to the device specific
            block address specified by dwOffsetHigh/dwOffsetLow. The
            dwPartition parameter is ignored.

        TAPE_LOGICAL_BLOCK - Position the tape to the logical block address
            specified by dwOffsetHigh/dwOffsetLow. If a multiple partition
            mode is in effect (ref: CreateTapePartition API), then the tape
            is positioned to the specified logical block address in the
            partition specified by dwPartition; otherwise, the dwPartition
            parameter value must be 0.

        TAPE_SPACE_END_OF_DATA - Position the tape to the end-of-data
            on tape or to the end-of-data in the current partition if a
            multiple partition mode is in effect (ref: CreateTapePartition
            API). The parameters dwPartition, dwOffsetHigh, and dwOffsetLow
            are ignored.

        TAPE_SPACE_RELATIVE_BLOCKS - Position forward or reverse the number
            of blocks specified by dwOffsetHigh/dwOffsetLow. The dwPartition
            parameter is ignored.

        TAPE_SPACE_FILEMARKS - Position forward or reverse the number of
            filemarks specified by dwOffsetHigh/dwOffsetLow. The dwPartition
            parameter is ignored.

        TAPE_SPACE_SEQUENTIAL_FMKS - Position forward or reverse to the
            next occurrence, if any, of the consecutive number of filemarks
            specified by dwOffsetHigh/dwOffsetLow. The dwPartition parameter
            is ignored.

        TAPE_SPACE_SETMARKS - Position forward or reverse the number of
            setmarks specified by dwOffsetHigh/dwOffsetLow. The dwPartition
            parameter is ignored.

        TAPE_SPACE_SEQUENTIAL_SMKS - Position forward or reverse to the
            next occurrence, if any, of the consecutive number of setmarks
            specified by dwOffsetHigh/dwOffsetLow. The dwPartition parameter
            is ignored.

        Note that a drive/tape may not support all dwPositionMethod values:
        an "unsupported" error indication is returned if the dwPositionMethod
        is one that is not flagged as supported in the drive's features bits
        (ref: GetTapeParameters API).

    dwPartition - The partition number for the position operation specified
        by dwPositionMethod (if not ignored).

        A partition number value of 0 selects the current partition for
        the position operation.

        Partitions are numbered logically from 1 to N: the first partition
        of the tape is partition number 1, the next is partition number 2,
        etc. However, a partition number does not imply a physical/linear
        position on tape -- partition number 1 on tape may not be at BOT.

        This parameter must be set to 0 if a multiple partition mode is not
        in effect (ref: CreateTapePartition API).

    dwOffsetHigh/dwOffsetLow - The block address or count for the position
        operation specified by dwPositionMethod.

        When the offset specifies the number of blocks, filemarks, or
        setmarks to position over, a positive value N in the offset shall
        cause forward positioning over N blocks, filemarks, or setmarks,
        ending on the end-of-partition/tape side of a block, filemark, or
        setmark. A zero value in the offset shall cause no change of
        position. A negative value N in the offset shall cause reverse
        positioning (toward beginning-of-partition/tape) over N blocks,
        filemarks, or setmarks, ending on the beginning-of-partition side
        of a block, filemark, or setmark.

    bImmediate - Return immediately without waiting for the operation to
        complete.

        Note that a drive/tape may not support the bImmediate option for
        either some or all dwPositionMethod values: an "unsupported" error
        indication is returned if the bImmediate dwPositionMethod is one
        that is not flagged as supported in the drive's features bits
        (ref: GetTapeParameters API).


Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_SET_POSITION TapeSetPosition;

    TapeSetPosition.Method = dwPositionMethod;
    TapeSetPosition.Partition = dwPartition;
    TapeSetPosition.Offset.LowPart = dwOffsetLow;
    TapeSetPosition.Offset.HighPart = dwOffsetHigh;
    TapeSetPosition.Immediate = (BOOLEAN)bImmediate;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_SET_POSITION,
                                 &TapeSetPosition,
                                 sizeof( TapeSetPosition ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
GetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionType,
    LPDWORD lpdwPartition,
    LPDWORD lpdwOffsetLow,
    LPDWORD lpdwOffsetHigh
    )

/*++

Routine Description:

    This API is used to get the tape position.

Arguments:

    hDevice - Handle to the device on which to get the tape position.

    dwPositionType - Type of position to return.
        This parameter can have one of the following values:

        TAPE_ABSOLUTE_POSITION - Return a device specific block address to
            the LARGE_INTEGER pointed to by lpliOffset.

            The DWORD pointed to by the lpdwPartition parameter is set to 0.

        TAPE_LOGICAL_POSITION - Return a logical block address to the
            LARGE_INTEGER pointed to by lpliOffset.

            The DWORD pointed to by the lpdwPartition parameter is set to 0
            if a multiple partition mode is not in effect; otherwise, it is
            set to the partition number of the currently selected partition
            (ref: CreateTapePartition API).

            Logical block addresses are 0 based -- 0 is a valid logical
            block address. A logical block address is a relative reference
            point (ref: logical positioning whitepaper).

    lpdwPartition - Pointer to a DWORD that receives the appropriate return
            value for the dwPositionType values explained above.

    lpliOffset - Pointer to a LARGE_INTEGER that receives the appropriate
            return value for the dwPositionType values explained above.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_GET_POSITION TapeGetPosition;
    DWORD rc;

    TapeGetPosition.Type = dwPositionType;

    rc = BasepDoTapeOperation( hDevice,
                               IOCTL_TAPE_GET_POSITION,
                               &TapeGetPosition,
                               sizeof( TapeGetPosition ),
                               &TapeGetPosition,
                               sizeof( TapeGetPosition )
                             );

    if (rc == NO_ERROR) {
        *lpdwPartition = TapeGetPosition.Partition;
        *lpdwOffsetLow = TapeGetPosition.Offset.LowPart;
        *lpdwOffsetHigh = TapeGetPosition.Offset.HighPart;
    }
    else {
        *lpdwPartition = 0;
        *lpdwOffsetLow = 0;
        *lpdwOffsetHigh = 0;
    }

    return rc;
}


DWORD
WINAPI
PrepareTape(
    HANDLE hDevice,
    DWORD dwOperation,
    BOOL bImmediate
    )

/*++

Routine Description:

    This API is used to prepare the tape.

Arguments:

    hDevice - Handle to the device on which to prepare the tape.

    dwOperation - Type of tape preparation to perform.
        This parameter can have one of the following values:

        TAPE_LOAD - Load the tape and position the tape to beginning-of-medium.

        TAPE_UNLOAD - Position the tape to beginning-of-medium for removal from
            the device.

            Following a successful unload operation, the device shall return an
            error for all subsequent medium-access commands until a load
            operation is successfully completed.

        TAPE_TENSION - Tension the tape in the device as required.  The
            implementation of this operation is device specific.

        TAPE_LOCK - Disable the removal of the tape from the device.

        TAPE_UNLOCK - Enable the removal of the tape from the device.

        TAPE_FORMAT - Format media in tape device.

    bImmediate - Return immediately without waiting for operation to complete.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_PREPARE TapePrepare;

    TapePrepare.Operation = dwOperation;
    TapePrepare.Immediate = (BOOLEAN)bImmediate;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_PREPARE,
                                 &TapePrepare,
                                 sizeof( TapePrepare ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
EraseTape(
    HANDLE hDevice,
    DWORD dwEraseType,
    BOOL bImmediate
    )

/*++

Routine Description:

    This API is used to erase the tape partition.

Arguments:

    hDevice - Handle to the device on which to erase the tape partition.

    dwEraseType - Type of erase to perform.
        This parameter can have one of the following values:

        TAPE_ERASE_SHORT - Write an erase gap or end-of-recorded data marker
            beginning at the current position.

        TAPE_ERASE_LONG - Erase all remaining media in the current partition
            beginning at the current position.

    bImmediate - Return immediately without waiting for operation to complete.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_ERASE TapeErase;

    TapeErase.Type = dwEraseType;
    TapeErase.Immediate = (BOOLEAN)bImmediate;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_ERASE,
                                 &TapeErase,
                                 sizeof( TapeErase ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
CreateTapePartition(
    HANDLE hDevice,
    DWORD dwPartitionMethod,
    DWORD dwCount,
    DWORD dwSize
    )

/*++

Routine Description:

    This API is used to create partitions.

Arguments:

    hDevice - Handle to the device on which to create partitions.

    dwPartitionMethod - Type of partitioning to perform.

        Creating partitions causes the tape to be reformatted.  All previous
        information recorded on the tape is destroyed.

        This parameter can have one of the following values:

        TAPE_FIXED_PARTITIONS - Partition the tape based on the device's fixed
            definition of partitions.  The dwCount and dwSize parameters are
            ignored.

        TAPE_SELECT_PARTITIONS - Partition the tape into the number of
            partitions specified by dwCount using the partition sizes defined
            by the device.  The dwSize parameter is ignored.

        TAPE_INITIATOR_PARTITIONS - Partition the tape into the number of
            partitions specified by dwCount using the partition size specified
            by dwSize for all but the last partition.  The size of the last
            partition is the remainder of the tape.

    dwCount - Number of partitions to create.  The maximum number of partitions
        a device can create is returned by GetTapeParameters.

    dwSize - Partition size in megabytes.  The maximum capacity of a tape is
        returned by GetTapeParameters.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_CREATE_PARTITION TapeCreatePartition;

    TapeCreatePartition.Method = dwPartitionMethod;
    TapeCreatePartition.Count = dwCount;
    TapeCreatePartition.Size = dwSize;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_CREATE_PARTITION,
                                 &TapeCreatePartition,
                                 sizeof( TapeCreatePartition ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
WriteTapemark(
    HANDLE hDevice,
    DWORD dwTapemarkType,
    DWORD dwTapemarkCount,
    BOOL bImmediate
    )

/*++

Routine Description:

    This API is used to write tapemarks.

Arguments:

    hDevice - Handle to the device on which to write the tapemarks.

    dwTapemarkType - Type of tapemarks to write.
        This parameter can have one of the following values:

        TAPE_SETMARKS - Write the number of setmarks specified by
            dwTapemarkCount to the tape.

            A setmark is a special recorded element containing no user data.
            A setmark provides a segmentation scheme hierarchically superior
            to filemarks.

        TAPE_FILEMARKS - Write the number of filemarks specified by
            dwTapemarkCount to the tape.

            A filemark is a special recorded element containing no user data.

        TAPE_SHORT_FILEMARKS - Write the number of short filemarks specified by
            dwTapemarkCount to the tape.

            A short filemark contains a short erase gap that does not allow a
            write operation to be performed.  The short filemark cannot be
            overwritten except when the write operation is performed from the
            beginning-of-partition or from a previous long filemark.

        TAPE_LONG_FILEMARKS - Write the number of long filemarks specified by
            dwTapemarkCount to the tape.

            A long filemark includes a long erase gap.  This gap allows the
            initiator to position on the beginning-of-partition side of the
            filemark, in the erase gap, and append data with the write
            operation.  This causes the long filemark and any data following
            the long filemark to be erased.

    dwTapemarkCount - The number of tapemarks to write.

    bImmediate - Return immediately without waiting for operation to complete.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_WRITE_MARKS TapeWriteMarks;

    TapeWriteMarks.Type = dwTapemarkType;
    TapeWriteMarks.Count = dwTapemarkCount;
    TapeWriteMarks.Immediate = (BOOLEAN)bImmediate;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_WRITE_MARKS,
                                 &TapeWriteMarks,
                                 sizeof( TapeWriteMarks ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
GetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPDWORD lpdwSize,
    LPVOID lpTapeInformation
    )

/*++

Routine Description:

    This API is used to get information about a tape device.

Arguments:

    hDevice - Handle to the device on which to get the information.

    dwOperation - Type of information to get.
        This parameter can have one of the following values:

        GET_TAPE_MEDIA_INFORMATION - Return the media specific information in
            lpTapeInformation.

        GET_TAPE_DRIVE_INFORMATION - Return the device specific information in
            lpTapeInformation.

    lpdwSize - Pointer to a DWORD containing the size of the buffer pointed to
        by lpTapeInformation.  If the buffer is too small, this parameter
        returns with the required size in bytes.

    lpTapeInformation - Pointer to a buffer to receive the information.  The
        structure returned in the buffer is determined by dwOperation.

        For GET_TAPE_MEDIA_INFORMATION, lpTapeInformation returns the following
        structure:

        LARGE_INTEGER Capacity - The maximum tape capacity in bytes.

        LARGE_INTEGER Remaining - The remaining tape capacity in bytes.

        DWORD BlockSize - The size of a fixed-length logical block in bytes.
            A block size of  0 indicates variable-length block mode, where the
            length of a block is set by the write operation.  The default
            fixed-block size and the range of valid block sizes are returned
            by GetTapeParameters.

        DWORD PartitionCount - Number of partitions on the tape.  If only one
            partition is supported by the device, this parameter is set to 0.

        BOOLEAN WriteProtected - Indicates if the tape is write protected:
            0 is write enabled, 1 is write protected.


        For GET_TAPE_DRIVE_INFORMATION, lpTapeInformation returns the following
        structure:

        BOOLEAN ECC - Indicates if hardware error correction is enabled or
            disabled: 0 is disabled, 1 is enabled.

        BOOLEAN Compression - Indicates if hardware data compression is enabled
            or disabled: 0 is disabled, 1 is enabled.

        BOOLEAN DataPadding - Indicates if data padding is disabled or enabled:
            0 is disabled, 1 is enabled.

        BOOLEAN ReportSetmarks - Indicates if reporting setmarks is enabled or
            disabled: 0 is disabled, 1 is enabled.

        DWORD DefaultBlockSize - Returns the default fixed-block size for the
            device.

        DWORD MaximumBlockSize - Returns the maximum block size for the device.

        DWORD MinimumBlockSize - Returns the minimum block size for the device.

        DWORD MaximumPartitionCount - Returns the maximum number of partitions
            the device can create.

        DWORD FeaturesLow - The lower 32 bits of the device features flag.

        DWORD FeaturesHigh - The upper 32 bits of the device features flag.

            The device features flag represents the operations a device
            supports by returning a value of 1 in the appropriate bit for each
            feature supported.

            This parameter can have one or more of the following bit values
            set in the lower 32 bits:

            TAPE_DRIVE_FIXED - Supports creating fixed data partitions.

            TAPE_DRIVE_SELECT - Supports creating select data partitions.

            TAPE_DRIVE_INITIATOR - Supports creating initiator-defined
                partitions.

            TAPE_DRIVE_ERASE_SHORT - Supports short erase operation.

            TAPE_DRIVE_ERASE_LONG - Supports long erase operation.

            TAPE_DRIVE_ERASE_BOP_ONLY - Supports erase operation from the
                beginning-of-partition only.

            TAPE_DRIVE_TAPE_CAPACITY - Supports returning the maximum capacity
                of the tape.

            TAPE_DRIVE_TAPE_REMAINING - Supports returning the remaining
                capacity of the tape.

            TAPE_DRIVE_FIXED_BLOCK - Supports fixed-length block mode.

            TAPE_DRIVE_VARIABLE_BLOCK - Supports variable-length block mode.

            TAPE_DRIVE_WRITE_PROTECT - Supports returning if the tape is write
                enabled or write protected.

            TAPE_DRIVE_ECC - Supports hardware error correction.

            TAPE_DRIVE_COMPRESSION - Supports hardware data compression.

            TAPE_DRIVE_PADDING - Supports data padding.

            TAPE_DRIVE_REPORT_SMKS - Supports reporting setmarks.

            TAPE_DRIVE_GET_ABSOLUTE_BLK - Supports returning the current device
                specific block address.

            TAPE_DRIVE_GET_LOGICAL_BLK - Supports returning the current logical
                block address (and logical tape partition).

            This parameter can have one or more of the following bit values
            set in the upper 32 bits:

            TAPE_DRIVE_LOAD_UNLOAD - Supports enabling and disabling the device
                for further operations.

            TAPE_DRIVE_TENSION - Supports tensioning the tape.

            TAPE_DRIVE_LOCK_UNLOCK - Supports enabling and disabling removal of
                the tape from the device.

            TAPE_DRIVE_SET_BLOCK_SIZE - Supports setting the size of a
                fixed-length logical block or setting variable-length block
                mode.

            TAPE_DRIVE_SET_ECC - Supports enabling and disabling hardware error
                correction.

            TAPE_DRIVE_SET_COMPRESSION - Supports enabling and disabling
                hardware data compression.

            TAPE_DRIVE_SET_PADDING - Supports enabling and disabling data
                padding.

            TAPE_DRIVE_SET_REPORT_SMKS - Supports enabling and disabling
                reporting of setmarks.

            TAPE_DRIVE_ABSOLUTE_BLK - Supports positioning to a device specific
                block address.

            TAPE_DRIVE_ABS_BLK_IMMED - Supports immediate positioning to a
                device specific block address.

            TAPE_DRIVE_LOGICAL_BLK - Supports positioning to a logical block
                address in a partition.

            TAPE_DRIVE_LOG_BLK_IMMED - Supports immediate positioning to a
                logical block address in a partition.

            TAPE_DRIVE_END_OF_DATA - Supports positioning to the end-of-data
                in a partition.

            TAPE_DRIVE_RELATIVE_BLKS - Supports positioning forward (or
                reverse) a specified number of blocks.

            TAPE_DRIVE_FILEMARKS - Supports positioning forward (or reverse)
                a specified number of filemarks.

            TAPE_DRIVE_SEQUENTIAL_FMKS - Supports positioning forward (or
                reverse) to the first occurrence of a specified number of
                consecutive filemarks.

            TAPE_DRIVE_SETMARKS - Supports positioning forward (or reverse)
                a specified number of setmarks.

            TAPE_DRIVE_SEQUENTIAL_SMKS - Supports positioning forward (or
                reverse) to the first occurrence of a specified number of
                consecutive setmarks.

            TAPE_DRIVE_REVERSE_POSITION - Supports positioning over blocks,
                filemarks, or setmarks in the reverse direction.

            TAPE_DRIVE_WRITE_SETMARKS - Supports writing setmarks.

            TAPE_DRIVE_WRITE_FILEMARKS - Supports writing filemarks.

            TAPE_DRIVE_WRITE_SHORT_FMKS - Supports writing short filemarks.

            TAPE_DRIVE_WRITE_LONG_FMKS - Supports writing long filemarks.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    DWORD rc;

    switch (dwOperation) {
        case GET_TAPE_MEDIA_INFORMATION:

            if (*lpdwSize < sizeof(TAPE_GET_MEDIA_PARAMETERS)) {
                *lpdwSize = sizeof(TAPE_GET_MEDIA_PARAMETERS);
                rc = ERROR_MORE_DATA ;
            } else {
                rc = BasepDoTapeOperation( hDevice,
                                           IOCTL_TAPE_GET_MEDIA_PARAMS,
                                           NULL,
                                           0,
                                           lpTapeInformation,
                                           sizeof( TAPE_GET_MEDIA_PARAMETERS )
                                         );
            }
            break;

        case GET_TAPE_DRIVE_INFORMATION:
            if (*lpdwSize < sizeof(TAPE_GET_DRIVE_PARAMETERS)) {
                *lpdwSize = sizeof(TAPE_GET_DRIVE_PARAMETERS);
                rc = ERROR_MORE_DATA ;
            } else {
                rc = BasepDoTapeOperation( hDevice,
                                           IOCTL_TAPE_GET_DRIVE_PARAMS,
                                           NULL,
                                           0,
                                           lpTapeInformation,
                                           sizeof( TAPE_GET_DRIVE_PARAMETERS )
                                         );
            }
            break;

        default:
            rc = ERROR_INVALID_FUNCTION;
            break;
    }

    return rc;
}


DWORD
WINAPI
SetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPVOID lpTapeInformation
    )

/*++

Routine Description:

    This API is used to set information about a tape device.

Arguments:

    hDevice - Handle to the device on which to set the information.

    dwOperation - Type of information to set.
        This parameter can have one of the following values:

        SET_TAPE_MEDIA_INFORMATION - Set the media specific information
            specified in lpTapeInformation.

        SET_TAPE_DRIVE_INFORMATION - Set the device specific information
            specified in lpTapeInformation.

    lpTapeInformation - Pointer to a buffer containing the information to set.
        The structure returned in the buffer is determined by dwOperation.

        For SET_TAPE_MEDIA_INFORMATION, lpTapeInformation contains the
        following structure:

        DWORD BlockSize - The size of a fixed-length logical block in bytes.
            A block size of 0 indicates variable-length block mode, where the
            length of a block is set by the write operation.  The default
            fixed-block size and the range of valid block sizes are returned
            by GetTapeParameters.


        For SET_TAPE_DRIVE_INFORMATION, lpTapeInformation contains the
        following structure:

        BOOLEAN ECC - Enables or disables hardware error correction: 0 is
            disabled, 1 is enabled.

        BOOLEAN Compression - Enables or disables hardware data compression:
            0 is disabled, 1 is enabled.

        BOOLEAN DataPadding - Enables or disables data padding: 0 is disabled,
            1 is enabled.

        BOOLEAN ReportSetmarks - Enables or disables reporting of setmarks:
            0 is disabled, 1 is enabled.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    DWORD rc;

    switch (dwOperation) {
        case SET_TAPE_MEDIA_INFORMATION:
            rc = BasepDoTapeOperation( hDevice,
                                       IOCTL_TAPE_SET_MEDIA_PARAMS,
                                       lpTapeInformation,
                                       sizeof( TAPE_SET_MEDIA_PARAMETERS ),
                                       NULL,
                                       0
                                     );
            break;

        case SET_TAPE_DRIVE_INFORMATION:
            rc = BasepDoTapeOperation( hDevice,
                                       IOCTL_TAPE_SET_DRIVE_PARAMS,
                                       lpTapeInformation,
                                       sizeof( TAPE_SET_DRIVE_PARAMETERS ),
                                       NULL,
                                       0
                                     );
            break;

        default:
            rc = ERROR_INVALID_FUNCTION;
            break;
    }

    return rc;
}


DWORD
WINAPI
GetTapeStatus(
    HANDLE hDevice
    )

/*++

Routine Description:

    This API is used to get the status of a tape device.

Arguments:

    hDevice - Handle to the device on which to get the status.

Return Value:

    If the device is ready to accept an appropriate medium-access command
    without returning an error, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_GET_STATUS,
                                 NULL,
                                 0,
                                 NULL,
                                 0
                               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tatom.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tatom.c

Abstract:

    Win32 Base API Test Program for Atom Manager calls

Author:

    Steve Wood (stevewo) 26-Oct-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <windows.h>

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    ATOM Atom1, Atom2, Atom3;
    BOOL Atom1Found, Atom2Found, Atom3Found;
    DWORD Atom1Length, Atom2Length, Atom3Length;
    TCHAR NameBuffer[ 128 ];

    printf( "TATOM: Entering Test Program\n" );

    Atom1 = AddAtom( TEXT("Atom1") );
    Atom2 = AddAtom( TEXT("#4095") );
    Atom3 = AddAtom( (LPTSTR)0x1234 );

    printf( "AddAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "AddAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "AddAtom( 0x1234 ) == %X\n", Atom3 );

    Atom1 = AddAtom( TEXT("Atom1") );
    Atom2 = AddAtom( TEXT("#4095") );
    Atom3 = AddAtom( (LPTSTR)0x1234 );

    printf( "AddAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "AddAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "AddAtom( 0x1234 ) == %X\n", Atom3 );

    assert( Atom1Found = (Atom1 == FindAtom( TEXT("Atom1") )) );
    assert( Atom2Found = (Atom2 == FindAtom( TEXT("#4095") )) );
    assert( Atom3Found = (Atom3 == FindAtom( (LPTSTR)0x1234 )) );

    printf( "FindAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "FindAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "FindAtom( 0x1234 ) == %X\n", Atom3 );

    Atom1Length = GetAtomName( Atom1, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GetAtomName( %X ) == %ws\n", Atom1, NameBuffer );
#else
    printf( "GetAtomName( %X ) == %s\n", Atom1, NameBuffer );
#endif
    Atom2Length = GetAtomName( Atom2, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GetAtomName( %X ) == %ws\n", Atom2, NameBuffer );
#else
    printf( "GetAtomName( %X ) == %s\n", Atom2, NameBuffer );
#endif
    Atom3Length = GetAtomName( Atom3, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GetAtomName( %X ) == %ws\n", Atom3, NameBuffer );
#else
    printf( "GetAtomName( %X ) == %s\n", Atom3, NameBuffer );
#endif

    printf( "DeleteAtom( %X ) == %X\n", Atom1, DeleteAtom( Atom1 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom1, DeleteAtom( Atom1 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom1, DeleteAtom( Atom1 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom1, DeleteAtom( Atom1 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom2, DeleteAtom( Atom2 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom3, DeleteAtom( Atom3 ) );

    Atom1 = GlobalAddAtom( TEXT("Atom1") );
    Atom2 = GlobalAddAtom( TEXT("#4095") );
    Atom3 = GlobalAddAtom( (LPTSTR)0x1234 );

    printf( "GlobalAddAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "GlobalAddAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "GlobalAddAtom( 0x1234 ) == %X\n", Atom3 );

    Atom1 = GlobalAddAtom( TEXT("Atom1") );
    Atom2 = GlobalAddAtom( TEXT("#4095") );
    Atom3 = GlobalAddAtom( (LPTSTR)0x1234 );

    printf( "GlobalAddAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "GlobalAddAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "GlobalAddAtom( 0x1234 ) == %X\n", Atom3 );

    assert( Atom1Found = (Atom1 == GlobalFindAtom( TEXT("Atom1") )) );
    assert( Atom2Found = (Atom2 == GlobalFindAtom( TEXT("#4095") )) );
    assert( Atom3Found = (Atom3 == GlobalFindAtom( (LPTSTR)0x1234 )) );

    printf( "GlobalFindAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "GlobalFindAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "GlobalFindAtom( 0x1234 ) == %X\n", Atom3 );

    Atom1Length = GlobalGetAtomName( Atom1, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GlobalGetAtomName( %X ) == %ws\n", Atom1, NameBuffer );
#else
    printf( "GlobalGetAtomName( %X ) == %s\n", Atom1, NameBuffer );
#endif
    Atom2Length = GlobalGetAtomName( Atom2, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GlobalGetAtomName( %X ) == %ws\n", Atom2, NameBuffer );
#else
    printf( "GlobalGetAtomName( %X ) == %s\n", Atom2, NameBuffer );
#endif
    Atom3Length = GlobalGetAtomName( Atom3, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GlobalGetAtomName( %X ) == %ws\n", Atom3, NameBuffer );
#else
    printf( "GlobalGetAtomName( %X ) == %s\n", Atom3, NameBuffer );
#endif

    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom1, GlobalDeleteAtom( Atom1 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom1, GlobalDeleteAtom( Atom1 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom1, GlobalDeleteAtom( Atom1 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom1, GlobalDeleteAtom( Atom1 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom2, GlobalDeleteAtom( Atom2 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom3, GlobalDeleteAtom( Atom3 ) );

    printf( "TATOM: Exiting Test Program\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\synch.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module implements all Win32 syncronization
    objects.

Author:

    Mark Lucovsky (markl) 19-Sep-1990

Revision History:

--*/

#include "basedll.h"

//
// Critical Section Services
//

VOID
InitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    )

/*++

Routine Description:

    A critical section object is initialized using
    Win32InitializeCriticalSection.

    Once a critical section object has been initialized threads within a
    single process may enter and exit critical sections using the
    critical section object.  A critical section object may not me moved
    or copied.  The application must also not modify the insides of the
    object, but must treat it as logically opaque.
    description-of-function.

Arguments:

    lpCriticalSection - Supplies the address of a critical section object
        to be initialized.  It is the callers resposibility to allocate
        the storage used by a critical section object.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection(lpCriticalSection);
    if ( !NT_SUCCESS(Status) ){
        RtlRaiseStatus(Status);
        }
}

BOOL
InitializeCriticalSectionAndSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
    )

/*++

Routine Description:

    A critical section object is initialized using
    Win32InitializeCriticalSection.

    Once a critical section object has been initialized threads within a
    single process may enter and exit critical sections using the
    critical section object.  A critical section object may not me moved
    or copied.  The application must also not modify the insides of the
    object, but must treat it as logically opaque.
    description-of-function.

Arguments:

    lpCriticalSection - Supplies the address of a critical section object
        to be initialized.  It is the callers resposibility to allocate
        the storage used by a critical section object.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = RtlInitializeCriticalSectionAndSpinCount(lpCriticalSection,dwSpinCount);
    if ( !NT_SUCCESS(Status) ){
        BaseSetLastNTError(Status);
        rv = FALSE;
        }
    return rv;
}



//
// Event Services
//
HANDLE
APIENTRY
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateEventW


--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateEventW(
                lpEventAttributes,
                bManualReset,
                bInitialState,
                NameBuffer
                );
}


HANDLE
APIENTRY
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )

/*++

Routine Description:

    An event object is created and a handle opened for access to the
    object with the CreateEvent function.

    The CreateEvent function creates an event object with the specified
    initial state.  If an event is in the Signaled state (TRUE), a wait
    operation on the event does not block.  If the event is in the Not-
    Signaled state (FALSE), a wait operation on the event blocks until
    the specified event attains a state of Signaled, or the timeout
    value is exceeded.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for event objects:

        - EVENT_MODIFY_STATE - Modify state access (set and reset) to
          the event is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the event is
          desired.

        - EVENT_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for an event object.


Arguments:

    lpEventAttributes - An optional parameter that may be used to
        specify the attributes of the new event.  If the parameter is
        not specified, then the event is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bManualReset - Supplies a flag which if TRUE specifies that the
        event must be manually reset.  If the value is FALSE, then after
        releasing a single waiter, the system automaticaly resets the
        event.

    bInitialState - The initial state of the event object, one of TRUE
        or FALSE.  If the InitialState is specified as TRUE, the event's
        current state value is set to one, otherwise it is set to zero.

    lpName - Optional unicode name of event

Return Value:

    NON-NULL - Returns a handle to the new event.  The handle has full
        access to the new event and may be used in any API that requires
        a handle to an event object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;
    PWCHAR pstrNewObjName = NULL;

    if ( ARGUMENT_PRESENT(lpName) ) {

        if (gpTermsrvFormatObjectName && 
            (pstrNewObjName = gpTermsrvFormatObjectName(lpName))) {

            RtlInitUnicodeString(&ObjectName,pstrNewObjName);

        } else {

            RtlInitUnicodeString(&ObjectName,lpName);
        }

        pObja = BaseFormatObjectAttributes(&Obja,lpEventAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpEventAttributes,NULL);
        }

    Status = NtCreateEvent(
                &Handle,
                EVENT_ALL_ACCESS,
                pObja,
                bManualReset ? NotificationEvent : SynchronizationEvent,
                (BOOLEAN)bInitialState
                );

    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
APIENTRY
OpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenNamedEventW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenEventW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
APIENTRY
OpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;
    PWCHAR pstrNewObjName = NULL;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }
    
    if (gpTermsrvFormatObjectName && 
        (pstrNewObjName = gpTermsrvFormatObjectName(lpName))) {

        RtlInitUnicodeString(&ObjectName,pstrNewObjName);

    } else {

        RtlInitUnicodeString(&ObjectName,lpName);
    }


    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenEvent(
                &Object,
                dwDesiredAccess,
                &Obja
                );
    
    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
SetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the signaled state (TRUE) with the SetEvent
    function.

    Setting the event causes the event to attain a state of Signaled,
    which releases all currently waiting threads (for manual reset
    events), or a single waiting thread (for automatic reset events).

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
ResetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    The state of an event is set to the Not-Signaled state (FALSE) using
    the ClearEvent function.

    Once the event attains a state of Not-Signaled, any threads which
    wait on the event block, awaiting the event to become Signaled.  The
    reset event service sets the event count to zero for the state of
    the event.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtClearEvent(hEvent);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
PulseEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the Signaled state and reset to the Not-
    Signaled state atomically with the PulseEvent function.

    Pulsing the event causes the event to attain a state of Signaled,
    release appropriate threads, and then reset the event.  When no
    waiters are currently waiting on the event, pulsing an event causes
    the event to release no threads and end up in the Not-Signaled
    state.  With waiters waiting on an event, pulsing an event has a
    different effect for manual reset events that it does for automatic
    reset events.  For manual reset events, pulsing releases all waiters
    and then leaves the event in the Not-Signaled state.  For automatic
    reset events, pulsing the event releases a single waiter and then
    leaves the event in the Not-Signaled state.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtPulseEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


//
// Semaphore Services
//

HANDLE
APIENTRY
CreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateSemaphoreW


--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateSemaphoreW(
                lpSemaphoreAttributes,
                lInitialCount,
                lMaximumCount,
                NameBuffer
                );
}


HANDLE
APIENTRY
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    )

/*++

Routine Description:

    A semaphore object is created and a handle opened for access to the
    object with the CreateSemaphore function.

    The CreateSemaphore function causes a semaphore object to be created
    which contains the specified initial and maximum counts.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for semaphore
    objects:

        - SEMAPHORE_MODIFY_STATE - Modify state access (release) to the
            semaphore is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the semaphore
            is desired.

        - SEMAPHORE_ALL_ACCESS - This set of access flags specifies all
            of the possible access flags for a semaphore object.


Arguments:

    lpSemaphoreAttributes - An optional parameter that may be used to
        specify the attributes of the new semaphore.  If the parameter
        is not specified, then the semaphore is created without a
        security descriptor, , and the resulting handle is not inherited
        on process creation.

    lInitialCount - The initial count for the semaphore, this value
        must be positive and less than or equal to the maximum count.

    lMaximumCount - The maximum count for the semaphore, this value
        must be greater than zero..

    lpName - Supplies an optional unicode name for the object.

Return Value:

    NON-NULL - Returns a handle to the new semaphore.  The handle has
        full access to the new semaphore and may be used in any API that
        requires a handle to a semaphore object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;
    PWCHAR pstrNewObjName = NULL;

    if ( ARGUMENT_PRESENT(lpName) ) {

        if (gpTermsrvFormatObjectName && 
            (pstrNewObjName = gpTermsrvFormatObjectName(lpName))) {

            RtlInitUnicodeString(&ObjectName,pstrNewObjName);

        } else {

            RtlInitUnicodeString(&ObjectName,lpName);
        }
        pObja = BaseFormatObjectAttributes(&Obja,lpSemaphoreAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpSemaphoreAttributes,NULL);
        }

    Status = NtCreateSemaphore(
                &Handle,
                SEMAPHORE_ALL_ACCESS,
                pObja,
                lInitialCount,
                lMaximumCount
                );
    
    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}


HANDLE
APIENTRY
OpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenSemaphoreW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenSemaphoreW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
APIENTRY
OpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;
    PWCHAR pstrNewObjName = NULL;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    if (gpTermsrvFormatObjectName && 
        (pstrNewObjName = gpTermsrvFormatObjectName(lpName))) {

        RtlInitUnicodeString(&ObjectName,pstrNewObjName);

    } else {

        RtlInitUnicodeString(&ObjectName,lpName);
    }

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenSemaphore(
                &Object,
                dwDesiredAccess,
                &Obja
                );

    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}


BOOL
ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG lReleaseCount,
    LPLONG lpPreviousCount
    )

/*++

Routine Description:

    A semaphore object can be released with the ReleaseSemaphore
    function.

    When the semaphore is released, the current count of the semaphore
    is incremented by the ReleaseCount.  Any threads that are waiting
    for the semaphore are examined to see if the current semaphore value
    is sufficient to satisfy their wait.

    If the value specified by ReleaseCount would cause the maximum count
    for the semaphore to be exceeded, then the count for the semaphore
    is not affected and an error status is returned.


Arguments:

    hSemaphore - Supplies an open handle to a semaphore object.  The
        handle must have SEMAPHORE_MODIFY_STATE access to the semaphore.

    lReleaseCount - The release count for the semaphore.  The count
        must be greater than zero and less than the maximum value
        specified for the semaphore.

    lpPreviousCount - An optional pointer to a variable that receives
        the previous count for the semaphore.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtReleaseSemaphore(hSemaphore,lReleaseCount,lpPreviousCount);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}



//
// Mutex Services
//

HANDLE
APIENTRY
CreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateMutexW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }

        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateMutexW(
                lpMutexAttributes,
                bInitialOwner,
                NameBuffer
                );
}

HANDLE
APIENTRY
CreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    )

/*++

Routine Description:

    A mutex object can be created and a handle opened for access to the
    object with the CreateMutex function.

    A new mutex object is created and a handle opened to the object with
    ownership as determined by the InitialOwner parameter.  The status
    of the newly created mutex object is set to not abandoned.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for mutex
    objects:

        - MUTEX_MODIFY_STATE - Modify access to the mutex is desired.
          This allows a process to release a mutex.

        - SYNCHRONIZE - Synchronization access (wait or release) to the
          mutex object is desired.

        - MUTEX_ALL_ACCESS - All possible types of access to the mutex
          object are desired.


Arguments:

    lpMutexAttributes - An optional parameter that may be used to specify
        the attributes of the new mutex.  If the parameter is not
        specified, then the mutex is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bInitialOwner - A boolean value that determines whether the creator
        of the object desires immediate ownership of the mutex object.


    lpName - Supplies an optional unicode name for the mutex.

Return Value:

    NON-NULL - Returns a handle to the new mutex.  The handle has full
        access to the new mutex and may be used in any API that
        requires a handle to a mutex object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;
    PWCHAR pstrNewObjName = NULL;

    if ( ARGUMENT_PRESENT(lpName) ) {

        if (gpTermsrvFormatObjectName && 
            (pstrNewObjName = gpTermsrvFormatObjectName(lpName))) {

            RtlInitUnicodeString(&ObjectName,pstrNewObjName);

        } else {

            RtlInitUnicodeString(&ObjectName,lpName);
        }
        pObja = BaseFormatObjectAttributes(&Obja,lpMutexAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpMutexAttributes,NULL);
        }


    Status = NtCreateMutant(
                &Handle,
                MUTANT_ALL_ACCESS,
                pObja,
                (BOOLEAN)bInitialOwner
                );

    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }
    
    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
APIENTRY
OpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenMutexW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenMutexW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
APIENTRY
OpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;
    PWCHAR pstrNewObjName = NULL;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    if (gpTermsrvFormatObjectName && 
        (pstrNewObjName = gpTermsrvFormatObjectName(lpName))) {

        RtlInitUnicodeString(&ObjectName,pstrNewObjName);

    } else {

        RtlInitUnicodeString(&ObjectName,lpName);
    }

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenMutant(
                &Object,
                dwDesiredAccess,
                &Obja
                );

    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
ReleaseMutex(
    HANDLE hMutex
    )

/*++

Routine Description:

    Ownership of a mutex object can be released with the ReleaseMutex
    function.

    A mutex object can only be released by a thread that currently owns
    the mutex object.  When the mutex is released, the current count of
    the mutex object is incremented by one.  If the resultant count is
    one, then the mutex object is no longer owned.  Any threads that are
    waiting for the mutex object are examined to see if their wait can
    be satisfied.

Arguments:

    hMutex - An open handle to a mutex object.  The handle must
        have MUTEX_MODIFY_STATE access to the mutex.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtReleaseMutant(hMutex,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


//
// Wait Services
//

DWORD
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObject function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

--*/

{
    return WaitForSingleObjectEx(hHandle,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObjectEx function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified object entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any
    one of the above wait termination conditions, or because an I/O
    completion callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    PPEB Peb;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {

        Peb = NtCurrentPeb();
        switch( HandleToUlong(hHandle) ) {
            case STD_INPUT_HANDLE:  hHandle = Peb->ProcessParameters->StandardInput;
                                    break;
            case STD_OUTPUT_HANDLE: hHandle = Peb->ProcessParameters->StandardOutput;
                                    break;
            case STD_ERROR_HANDLE:  hHandle = Peb->ProcessParameters->StandardError;
                                    break;
            }

        if (CONSOLE_HANDLE(hHandle) && VerifyConsoleIoHandle(hHandle)) {
            hHandle = GetConsoleInputWaitHandle();
            }

        pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtWaitForSingleObject(hHandle,(BOOLEAN)bAlertable,pTimeOut);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}


DWORD
WINAPI
SignalObjectAndWait(
    HANDLE hObjectToSignal,
    HANDLE hObjectToWaitOn,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    PPEB Peb;

    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {
        Peb = NtCurrentPeb();
        switch( HandleToUlong(hObjectToWaitOn) ) {
            case STD_INPUT_HANDLE:  hObjectToWaitOn = Peb->ProcessParameters->StandardInput;
                                    break;
            case STD_OUTPUT_HANDLE: hObjectToWaitOn = Peb->ProcessParameters->StandardOutput;
                                    break;
            case STD_ERROR_HANDLE:  hObjectToWaitOn = Peb->ProcessParameters->StandardError;
                                    break;
            }

        if (CONSOLE_HANDLE(hObjectToWaitOn) && VerifyConsoleIoHandle(hObjectToWaitOn)) {
            hObjectToWaitOn = GetConsoleInputWaitHandle();
            }

        pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtSignalAndWaitForSingleObject(
                    hObjectToSignal,
                    hObjectToWaitOn,
                    (BOOLEAN)bAlertable,
                    pTimeOut
                    );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}



DWORD
WaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

A wait operation on multiple waitable objects (up to
MAXIMUM_WAIT_OBJECTS) is accomplished with the WaitForMultipleObjects
function.

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

--*/

{
    return WaitForMultipleObjectsEx(nCount,lpHandles,bWaitAll,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on multiple waitable objects (up to
    MAXIMUM_WAIT_OBJECTS) is accomplished with the
    WaitForMultipleObjects function.

    This API can be used to wait on any of the specified objects to
    enter the signaled state, or all of the objects to enter the
    signaled state.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified objects entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any one of
    the above wait termination conditions, or because an I/O completion
    callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    DWORD i;
    LPHANDLE HandleArray;
    HANDLE Handles[ 8 ];
    PPEB Peb;

    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {
        if (nCount > 8) {
            HandleArray = (LPHANDLE) RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), nCount*sizeof(HANDLE));
            if (HandleArray == NULL) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                return 0xffffffff;
            }
        } else {
            HandleArray = Handles;
        }
        RtlCopyMemory(HandleArray,(LPVOID)lpHandles,nCount*sizeof(HANDLE));

        Peb = NtCurrentPeb();
        for (i=0;i<nCount;i++) {
            switch( HandleToUlong(HandleArray[i]) ) {
                case STD_INPUT_HANDLE:  HandleArray[i] = Peb->ProcessParameters->StandardInput;
                                        break;
                case STD_OUTPUT_HANDLE: HandleArray[i] = Peb->ProcessParameters->StandardOutput;
                                        break;
                case STD_ERROR_HANDLE:  HandleArray[i] = Peb->ProcessParameters->StandardError;
                                        break;
                }

            if (CONSOLE_HANDLE(HandleArray[i]) && VerifyConsoleIoHandle(HandleArray[i])) {
                HandleArray[i] = GetConsoleInputWaitHandle();
                }
            }

        pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtWaitForMultipleObjects(
                     (CHAR)nCount,
                     HandleArray,
                     bWaitAll ? WaitAll : WaitAny,
                     (BOOLEAN)bAlertable,
                     pTimeOut
                     );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }

        if (HandleArray != Handles) {
            RtlFreeHeap(RtlProcessHeap(), 0, HandleArray);
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}

VOID
Sleep(
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the Sleep function.

    The Sleep function causes the current thread to enter a
    waiting state until the specified interval of time has passed.

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    None.

--*/

{
    SleepEx(dwMilliseconds,FALSE);
}

DWORD
APIENTRY
SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the SleepEx function.

    The SleepEx function causes the current thread to enter a waiting
    state until the specified interval of time has passed.

    If the bAlertable parameter is FALSE, the only way the SleepEx
    returns is when the specified time interval has passed.  If the
    bAlertable parameter is TRUE, then the SleepEx can return due to the
    expiration of the time interval (return value of 0), or because an
    I/O completion callback terminated the SleepEx early (return value
    of WAIT_IO_COMPLETION).

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  A timeout value of -1 specifies an infinite
        timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        SleepEx may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    0 - The SleepEx terminated due to expiration of the time interval.

    WAIT_IO_COMPLETION - The SleepEx terminated due to one or more I/O
        completion callbacks.

--*/
{
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {
        pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
        if (pTimeOut == NULL) {
            //
            // If Sleep( -1 ) then delay for the longest possible integer
            // relative to now.
            //

            TimeOut.LowPart = 0x0;
            TimeOut.HighPart = 0x80000000;
            pTimeOut = &TimeOut;
            }

    rewait:
        Status = NtDelayExecution(
                    (BOOLEAN)bAlertable,
                    pTimeOut
                    );
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return Status == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE
WINAPI
CreateWaitableTimerA(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCSTR lpTimerName
    )

/*++

Routine Description:

    ANSI thunk to CreateWaitableTimerW


--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpTimerName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpTimerName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateWaitableTimerW(
                lpTimerAttributes,
                bManualReset,
                NameBuffer
                );
}

HANDLE
WINAPI
CreateWaitableTimerW(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCWSTR lpTimerName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpTimerName) ) {
        RtlInitUnicodeString(&ObjectName,lpTimerName);
        pObja = BaseFormatObjectAttributes(&Obja,lpTimerAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpTimerAttributes,NULL);
        }

    Status = NtCreateTimer(
                &Handle,
                TIMER_ALL_ACCESS,
                pObja,
                bManualReset ? NotificationTimer : SynchronizationTimer
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
WINAPI
OpenWaitableTimerA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpTimerName
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpTimerName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpTimerName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenWaitableTimerW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}


HANDLE
WINAPI
OpenWaitableTimerW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpTimerName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpTimerName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }
    RtlInitUnicodeString(&ObjectName,lpTimerName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenTimer(
                &Object,
                dwDesiredAccess,
                &Obja
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

static
VOID
CALLBACK
BasepTimerAPCProc(
    PVOID pvContext,
    ULONG TimerLowValue,
    LONG TimerHighValue
    )
{
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = (PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK) pvContext;
    const PVOID CallbackContext = ActivationBlock->CallbackContext;
    const PTIMERAPCROUTINE TimerAPCRoutine = (PTIMERAPCROUTINE) ActivationBlock->CallbackFunction;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };
    const PACTIVATION_CONTEXT ActivationContext = ActivationBlock->ActivationContext;

    if ((ActivationBlock->Flags & BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK) == 0) {
        BasepFreeActivationContextActivationBlock(ActivationBlock);
    }

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, ActivationContext);
    __try {
        (*TimerAPCRoutine)(CallbackContext, TimerLowValue, TimerHighValue);
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
    }
}

BOOL
WINAPI
SetWaitableTimer(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    )
{
    NTSTATUS Status;
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = NULL;
    PTIMER_APC_ROUTINE TimerApcRoutine = (PTIMER_APC_ROUTINE) pfnCompletionRoutine;
    PVOID TimerApcContext = lpArgToCompletionRoutine;

    // If there's an APC routine to call and we have a non-default activation
    // context active for this thread, we need to allocate a little chunk of heap
    // to pass to the APC callback.
    if (pfnCompletionRoutine != NULL) {
        DWORD dwActivationBlockAllocationFlags = BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT;

        // If it's a periodic timer, don't free the block until the timer is cancelled.
        if (lPeriod > 0)
            dwActivationBlockAllocationFlags |= BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK;

        Status = BasepAllocateActivationContextActivationBlock(dwActivationBlockAllocationFlags, pfnCompletionRoutine, lpArgToCompletionRoutine, &ActivationBlock);
        if (!NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        if (ActivationBlock != NULL) {
            TimerApcRoutine = &BasepTimerAPCProc;
            TimerApcContext = ActivationBlock;
        }
    }

    Status = NtSetTimer(
                hTimer,
                (PLARGE_INTEGER) lpDueTime,
                TimerApcRoutine,                // will be NULL if pfnCompletionRoutine was null
                TimerApcContext,
                (BOOLEAN) fResume,
                lPeriod,
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        if (ActivationBlock != NULL)
            BasepFreeActivationContextActivationBlock(ActivationBlock);
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        if ( Status == STATUS_TIMER_RESUME_IGNORED ) {
            SetLastError(ERROR_NOT_SUPPORTED);
        } else {
            SetLastError(ERROR_SUCCESS);
        }
        return TRUE;
    }
}

BOOL
WINAPI
CancelWaitableTimer(
    HANDLE hTimer
    )
{
    NTSTATUS Status;
    
    Status = NtCancelTimer(hTimer, NULL);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\taskstrs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    taststrs.c

Abstract:

    Tasking stress test.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

HANDLE Semaphore, Event;

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;

    (ReleaseSemaphore(Semaphore,1,NULL));

    st = WaitForSingleObject(Event,500);

    ExitThread(0);
}

VOID
NewProcess()
{

    DWORD st;
    DWORD ThreadId;
    HANDLE Thread;
    DWORD NumberOfThreads;
    DWORD MaximumThreadCount;
    DWORD i;

    //
    // Create an Event that is never signaled
    //

    Event = CreateEvent(NULL,TRUE,FALSE,NULL);

    //
    // Create a semaphore signaled by each thread as it starts
    //

    Semaphore = CreateSemaphore(NULL,0,256,NULL);

    (Event);
    (Semaphore);

    MaximumThreadCount = 15;
    NumberOfThreads = 0;

    //
    // Create the threads
    //

    printf("Creating %d threads... ",MaximumThreadCount);
    for ( i = 0;i<MaximumThreadCount;i++ ) {
        Thread = CreateThread(NULL,0L,(PVOID)TestThread,(LPVOID)99,0,&ThreadId);
        if ( Thread ) {
            NumberOfThreads++;
            CloseHandle(Thread);
            }
        }
    printf("%d threads Created\n",NumberOfThreads);

    for(i=0;i<NumberOfThreads;i++) {
        st = WaitForSingleObject((HANDLE)Semaphore,(DWORD)-1);
        (st == 0);
        }
    Sleep(3000);

    TerminateProcess(GetCurrentProcess(),0);
}


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    STARTUPINFO	StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    BOOL Success;
    DWORD st;
    DWORD ProcessCount;
    SMALL_RECT Window;

    ProcessCount = 0;
    if ( strchr(GetCommandLine(),'+') ) {
        NewProcess();
        }

    GetStartupInfo(&StartupInfo);
    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 15;
    Window.Bottom = 5;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );


    while ( TRUE ) {

        Success = CreateProcess(
                        NULL,
                        "taskstrs +",
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_NEW_CONSOLE,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInfo
                        );

        if (Success) {
            ProcessCount++;
            printf("Process %d Created\n",ProcessCount);
            st = WaitForSingleObject((HANDLE)ProcessInfo.hProcess,(DWORD)-1);
            (st == 0);
            CloseHandle(ProcessInfo.hProcess);
            CloseHandle(ProcessInfo.hThread);
            }
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\th2.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

DWORD Size;
LPSTR WriteData = "Hello World\n";
HANDLE ReadHandle, WriteHandle;

VOID
WriterThread(
    LPVOID ThreadParameter
    )
{
    DWORD n;
    Sleep(10000);
    printf("Writing...\n");
    WriteFile(WriteHandle,WriteData,Size, &n, NULL);
    assert(n==Size);
    printf("Done Writing...\n");
    Sleep(10000);
    printf("Done Sleeping...\n");
}


int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOL b;
    DWORD n;
    LPSTR l;
    HANDLE Thread;
    DWORD ThreadId;
DebugBreak();
    b = CreatePipe(&ReadHandle, &WriteHandle,NULL,0);
    assert(b);

    Size = strlen(WriteData)+1;
    l = LocalAlloc(LMEM_ZEROINIT,Size);
    assert(l);

    Thread = CreateThread(NULL,0L,WriterThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);
    printf("Reading\n");
    ReadFile(ReadHandle,l,Size, &n, NULL);
    assert(n==Size);
    printf("Reading Done %s\n",l);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tbase.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tbase.c

Abstract:

    Skeleton for a Win32 Base API Test Program

Author:

    Steve Wood (stevewo) 26-Oct-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>

LPSTR Inserts[ 9 ] = {
    "Insert 1",
    "Insert 2",
    "Insert 3",
    "Insert 4",
    "Insert 5",
    "Insert 6",
    "Insert 7",
    "Insert 8",
    "Insert 9"
};

void
TestEnvironment( void );

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    int i;
    HANDLE hMod,x;
    CHAR Buff[256];
    PCHAR s;
    FARPROC f;
    DWORD Version;
    HANDLE Handle;
    DWORD  rc;
    STARTUPINFO StartupInfo;


    GetStartupInfo(&StartupInfo);
    printf("Title %s\n",StartupInfo.lpTitle);


    printf( "TBASE: Entering Test Program\n" );

    assert(GetModuleFileName(0,Buff,256) < 255);
    printf("Image Name %s\n",Buff);
#if 0
    printf( "argc: %ld\n", argc );
    for (i=0; i<argc; i++) {
        printf( "argv[ %3ld ]: '%s'\n", i, argv[ i ] );
        }

    for (i=0; envp[ i ]; i++) {
        printf( "envp[ %3ld ]: %s\n", i, envp[ i ] );
        }

    DbgBreakPoint();

    s = "ync ""Yes or No""";
    printf( "Invoking: '%s'\nResult: %d\n", s, system(s) );

    TestEnvironment();
    for (i=1; i<=256; i++) {
        rc = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            NULL,
                            i, NULL, sizeof( Buff ), (va_list *)Inserts );
        if (rc != 0) {
            rc = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY, NULL,
                                i, Buff, rc, (va_list *)Inserts );
            if (rc != 0) {
                cprintf( "SYS%05u: %s\r\n", i, Buff );
                }
            }
        }

    Handle = CreateFile( "\\config.sys",
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL
                       );
    if (Handle != INVALID_HANDLE_VALUE) {
        printf( "CreateFile successful, handle = %lX\n", Handle );
        }
    else {
        printf( "CreateFile failed\n" );
        }

    rc = SetFilePointer(Handle, 0, NULL, FILE_END);
    if (rc != -1) {
        printf( "File size = %ld\n", rc );
        }
    else {
        printf( "SetFilePointer failed\n" );
        }

    Version = GetVersion();
    assert( (Version & 0x0000ffff) == 4);
    assert( (Version >> 16) == 0);
#endif
    hMod = LoadLibrary("dbgdll");
    assert(hMod);
    assert(hMod == GetModuleHandle("dbgdll"));

    hMod = LoadLibrary("c:\\nt\\dll\\csr.dll");
    assert(hMod);

    assert(GetModuleFileName(hMod,Buff,256) == strlen("c:\\nt\\dll\\csr.dll")+1);
    assert(_strcmpi(Buff,"c:\\nt\\dll\\csr.dll") == 0 );

    hMod = LoadLibrary("nt\\dll\\csrrtl.dll");
    assert(hMod);

    x = LoadLibrary("csrrtl");
    assert( x && x == hMod);
    assert(FreeLibrary(x));
    assert(FreeLibrary(x));
    hMod = GetModuleHandle("csrrtl");
    assert(hMod == NULL);
    x = LoadLibrary("csrrtl");
    assert( x );
    assert(FreeLibrary(x));

    hMod = LoadLibrary("kernel32");
    assert(hMod);

    f = GetProcAddress(hMod,"GetProcAddress");
    assert(f);
    assert(f == (f)(hMod,"GetProcAddress"));
    assert(f == MakeProcInstance(f,hMod));
    FreeProcInstance(f);
    DebugBreak();
    assert(FreeLibrary(hMod));

//    hMod = LoadLibrary("baddll");
//    assert(!hMod);

    printf( "TBASE: Exiting Test Program\n" );

    return 0;
}

VOID
DumpEnvironment( VOID )
{
    PCHAR s;

    s = (PCHAR)GetEnvironmentStrings();
    while (*s) {
        printf( "%s\n", s );
        while (*s++) {
            }
        }
}

VOID
SetEnvironment(
    PCHAR Name,
    PCHAR Value
    );

VOID
SetEnvironment(
    PCHAR Name,
    PCHAR Value
    )
{
    BOOL Success;

    Success = SetEnvironmentVariable( Name, Value );
    if (Value != NULL) {
        printf( "TENV: set variable %s=%s", Name, Value );
        }
    else {
        printf( "TENV: delete variable %Z", Name );
        }

    if (Success) {
        printf( "\n" );
        }
    else {
        printf( " - failed\n" );
        }

    DumpEnvironment();
    printf( "\n" );
}


void
TestEnvironment( void )
{
    DumpEnvironment();
    SetEnvironment( "aaaa", "12345" );
    SetEnvironment( "aaaa", "1234567890" );
    SetEnvironment( "aaaa", "1" );
    SetEnvironment( "aaaa", "" );
    SetEnvironment( "aaaa", NULL );
    SetEnvironment( "AAAA", "12345" );
    SetEnvironment( "AAAA", "1234567890" );
    SetEnvironment( "AAAA", "1" );
    SetEnvironment( "AAAA", "" );
    SetEnvironment( "AAAA", NULL );
    SetEnvironment( "MMMM", "12345" );
    SetEnvironment( "MMMM", "1234567890" );
    SetEnvironment( "MMMM", "1" );
    SetEnvironment( "MMMM", "" );
    SetEnvironment( "MMMM", NULL );
    SetEnvironment( "ZZZZ", "12345" );
    SetEnvironment( "ZZZZ", "1234567890" );
    SetEnvironment( "ZZZZ", "1" );
    SetEnvironment( "ZZZZ", "" );
    SetEnvironment( "ZZZZ", NULL );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\termutil.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    termutil.c

Abstract:

    Terminal server support functions and inifile syncing/merging code

Author:


Revision History:

--*/

#include "basedll.h"
#include "regapi.h"

#define TERMSRV_INIFILE_TIMES L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\IniFile Times"



BOOL IsTerminalServerCompatible(VOID)
{

PIMAGE_NT_HEADERS NtHeader = RtlImageNtHeader( NtCurrentPeb()->ImageBaseAddress );

    if ((NtHeader) && (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL IsTSAppCompatEnabled(VOID)
{

   NTSTATUS NtStatus;
   OBJECT_ATTRIBUTES ObjectAttributes;
   UNICODE_STRING UniString;
   HKEY   hKey = 0;
   ULONG  ul, ulcbuf;
   PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;

   BOOL retval = TRUE;


   RtlInitUnicodeString(&UniString,REG_NTAPI_CONTROL_TSERVER);



   // Determine the value info buffer size
   ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
            sizeof(ULONG);

   pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                 0,
                                 ulcbuf);

   // Did everything initialize OK?
   if (UniString.Buffer && pKeyValInfo) {

       InitializeObjectAttributes(&ObjectAttributes,
                                  &UniString,
                                  OBJ_CASE_INSENSITIVE,
                                  NULL,
                                  NULL
                                 );

       NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

       if (NT_SUCCESS(NtStatus)) {

           RtlInitUnicodeString(&UniString,
                               L"TSAppCompat");
           NtStatus = NtQueryValueKey(hKey,
                                      &UniString,
                                      KeyValuePartialInformation,
                                      pKeyValInfo,
                                      ulcbuf,
                                      &ul);

           if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {

               if ((*(PULONG)pKeyValInfo->Data) == 0) {
                  retval = FALSE;
               }

           }

           NtClose(hKey);
       }
   }

   // Free up the buffers we allocated
   // Need to zero out the buffers, because some apps (MS Internet Assistant)
   // won't install if the heap is not zero filled.
   if (pKeyValInfo) {
       memset(pKeyValInfo, 0, ulcbuf);
       RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
   }

   return(retval);

}

BOOL IsSystemLUID(VOID)
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ sizeof( TOKEN_STATISTICS ) ];
    ULONG       ReturnLength;
    LUID        CurrentLUID = { 0, 0 };
    LUID        SystemLUID = SYSTEM_LUID;
    NTSTATUS Status;

    if ( CurrentLUID.LowPart == 0 && CurrentLUID.HighPart == 0 ) {

        Status = NtOpenProcessToken( NtCurrentProcess(),
                                     TOKEN_QUERY,
                                     &TokenHandle );
        if ( !NT_SUCCESS( Status ) )
            return(TRUE);

        NtQueryInformationToken( TokenHandle, TokenStatistics, &TokenInformation,
                                 sizeof(TokenInformation), &ReturnLength );
        NtClose( TokenHandle );

        RtlCopyLuid(&CurrentLUID,
                    &(((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId));
    }

    if (RtlEqualLuid(&CurrentLUID, &SystemLUID)) {
        return(TRUE);
    } else {
        return(FALSE );
    }
}


void InitializeTermsrvFpns(void)
{

    HANDLE          dllHandle;

    if (IsTerminalServerCompatible() ||
       (IsSystemLUID()) ||
       (!IsTSAppCompatEnabled())) {
        return;
    }

    //
    // Load Terminal Server application compatibility dll
    //
    dllHandle = LoadLibraryW(L"tsappcmp.dll");

    if (dllHandle) {

        gpTermsrvFormatObjectName =
            (PTERMSRVFORMATOBJECTNAME)GetProcAddress(dllHandle,"TermsrvFormatObjectName");

        gpTermsrvGetComputerName =
            (PTERMSRVGETCOMPUTERNAME)GetProcAddress(dllHandle,"TermsrvGetComputerName");

        gpTermsrvAdjustPhyMemLimits =
                (PTERMSRVADJUSTPHYMEMLIMITS)GetProcAddress(dllHandle,"TermsrvAdjustPhyMemLimits");

        gpTermsrvGetWindowsDirectoryA =
                (PTERMSRVGETWINDOWSDIRECTORYA)GetProcAddress(dllHandle,"TermsrvGetWindowsDirectoryA");

        gpTermsrvGetWindowsDirectoryW =
                (PTERMSRVGETWINDOWSDIRECTORYW)GetProcAddress(dllHandle,"TermsrvGetWindowsDirectoryW");

        gpTermsrvConvertSysRootToUserDir =
                (PTERMSRVCONVERTSYSROOTTOUSERDIR)GetProcAddress(dllHandle,"TermsrvConvertSysRootToUserDir");

        gpTermsrvBuildIniFileName =
                (PTERMSRVBUILDINIFILENAME)GetProcAddress(dllHandle,"TermsrvBuildIniFileName");

        gpTermsrvCORIniFile =
                (PTERMSRVCORINIFILE)GetProcAddress(dllHandle,"TermsrvCORIniFile");

        gpGetTermsrCompatFlags =
                (PGETTERMSRCOMPATFLAGS)GetProcAddress(dllHandle,"GetTermsrCompatFlags");

        gpTermsrvBuildSysIniPath =
                (PTERMSRVBUILDSYSINIPATH)GetProcAddress(dllHandle,"TermsrvBuildSysIniPath");

        gpTermsrvCopyIniFile =
        (PTERMSRVCOPYINIFILE)GetProcAddress(dllHandle,"TermsrvCopyIniFile");

        gpTermsrvGetString =
        (PTERMSRVGETSTRING)GetProcAddress(dllHandle,"TermsrvGetString");

        gpTermsrvLogInstallIniFile =
        (PTERMSRVLOGINSTALLINIFILE)GetProcAddress(dllHandle,"TermsrvLogInstallIniFile");


    }
}


/*****************************************************************************
 *
 *  TermsrvAppInstallMode
 *
 *   Returns whether the system is in Install mode or not
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

WINBASEAPI
BOOL
WINAPI
TermsrvAppInstallMode( VOID )
{

    if ( BaseStaticServerData->fTermsrvAppInstallMode )
        return( TRUE );

    return( FALSE );
}


/*****************************************************************************
 *
 *  SetTermsrvAppInstallMode
 *
 *   Turns App install mode on or off. Default is off
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

WINBASEAPI
BOOL
WINAPI
SetTermsrvAppInstallMode( BOOL bState )
{
    typedef BOOL ( APIENTRY  Func_CheckTokenMembership )( HANDLE , PSID , PBOOL);
    BOOL     rc;
    NTSTATUS Status;
    PSID pSid = NULL ;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    HINSTANCE  dllHandle;
    
    if ( !( IsTerminalServer() && IsTSAppCompatEnabled() ) )
    {
        return FALSE;
    }


    dllHandle = LoadLibraryW(L"advapi32.dll");
    
    if (dllHandle)
    {
        Func_CheckTokenMembership     *fPtr;
        fPtr =  (Func_CheckTokenMembership * )GetProcAddress(dllHandle,"CheckTokenMembership");
        if (fPtr)
        {
            Status = RtlAllocateAndInitializeSid(
                    &SidAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pSid
                    );

            if (NT_SUCCESS(Status))
            {
                BOOL    FoundAdmin;
                if ( fPtr (NULL, pSid , &FoundAdmin)) 
                {
                    if (FoundAdmin) 
                    {
                    // caller is admin, go ahead

                    #if defined(BUILD_WOW6432)
                        Status = CsrBasepSetTermsrvAppInstallMode(bState);
                    #else
                        BASE_API_MSG m;
                        PBASE_SET_TERMSRVAPPINSTALLMODE c= (PBASE_SET_TERMSRVAPPINSTALLMODE)&m.u.SetTermsrvAppInstallMode;

                        c->bState = bState;
                        Status = CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                                     CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                     BasepSetTermsrvAppInstallMode),
                                                     sizeof( *c ));
                    #endif

                        if ( NT_SUCCESS( Status ) ) 
                        {
                            //
                            // Load tsappcmp.dll
                            //
                            if (gpTermsrvUpdateAllUserMenu == NULL) 
                            {
                                HANDLE          dllHandle;

                                //
                                // Load Terminal Server application compatibility dll
                                //
                                dllHandle = LoadLibraryW(L"tsappcmp.dll");

                                if (dllHandle) 
                                {
                                    gpTermsrvUpdateAllUserMenu =
                                            (PTERMSRVUPDATEALLUSERMENU)GetProcAddress(dllHandle,"TermsrvUpdateAllUserMenu");
                                }
                            }

                            if (gpTermsrvUpdateAllUserMenu) 
                            {
                                gpTermsrvUpdateAllUserMenu( bState == TRUE ? 0 : 1 );
                            }
                            rc = TRUE;
                        }
                        else
                        {
                            SetLastError( RtlNtStatusToDosError( Status ) );
                            rc = FALSE; 
                        }
                                   
                    }
                    else 
                    {
                        // user is not admin
                        SetLastError( ERROR_ACCESS_DENIED );
                        rc = FALSE;
                    }
                }
                else
                {
                    // call to CheckTokenMembership() failed, it set the last error
                    rc = FALSE;
                }
            }
            else
            {
                // attempt to allocate and init SID failed.
                SetLastError( RtlNtStatusToDosError( Status ) );
                rc = FALSE; 
            }
        }                       
        else
        {
            // function not found, GetProc() set the last error.
            rc = FALSE;
        }
        FreeLibrary( dllHandle );
    }
    else
    {
        // library not found, LoadLib() set the last error
        rc = FALSE;
    }

    if (pSid) 
    {
        RtlFreeSid( pSid );
    }

    return rc;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/*
  Ini File syncing/merging code

*/
//////////////////////////////////////////////////////////////////////////////
/* External Functions */
NTSTATUS
BaseDllOpenIniFileOnDisk(
    PINIFILE_PARAMETERS a
    );

NTSTATUS
BaseDllWriteKeywordValue(
    IN PINIFILE_PARAMETERS a,
    IN PUNICODE_STRING VariableName OPTIONAL
    );

NTSTATUS
BaseDllCloseIniFileOnDisk(
    IN PINIFILE_PARAMETERS a
    );

NTSTATUS
BaseDllFindSection(
    IN PINIFILE_PARAMETERS a
    );

NTSTATUS
BaseDllFindKeyword(
    IN PINIFILE_PARAMETERS a
    );

NTSTATUS
TermsrvIniSyncLoop( HANDLE SrcHandle,
                PINIFILE_PARAMETERS a,
                PBOOLEAN pfIniUpdated
              );
NTSTATUS
TermsrvGetSyncTime( PUNICODE_STRING pSysIniPath,
                PUNICODE_STRING pUserBasePath,
                PLARGE_INTEGER  pLastSyncTime
              );

NTSTATUS
TermsrvPutSyncTime( PUNICODE_STRING pSysIniPath,
                PUNICODE_STRING pUserBasePath,
                PLARGE_INTEGER  pLastSyncTime
              );


/*****************************************************************************
 *
 *  TermsrvGetSyncTime
 *
 *  This routine will get the time of the system ini file that the user ini
 *  file was last sync'd with.
 *
 * ENTRY:
 *   PUNICODE_STRING pSysIniPath (In) - NT fully qualified system ini path
 *   PUNICODE_STRING pUserBasePath (In) - NT fully qualified user directory path
 *   PLARGE_INTEGER pLastSyncTime (OUT) - ptr to return last sync time
 *
 * EXIT:
 *   STATUS_SUCCESS - successfully retrieved the last sync time from infile.upd
 *
 ****************************************************************************/

NTSTATUS
TermsrvGetSyncTime(
    PUNICODE_STRING pSysIniPath,
    PUNICODE_STRING pUserBasePath,
    PLARGE_INTEGER  pLastSyncTime)
{
    NTSTATUS Status;
    HANDLE   hUpdate = NULL;
    OBJECT_ATTRIBUTES ObjAUpd;
    IO_STATUS_BLOCK   Iosb;
    FILE_STANDARD_INFORMATION StandardInfo;
    WCHAR             wcUpdateFile[MAX_PATH+1];
    UNICODE_STRING    UniUpdateName = {0,
                                       sizeof(wcUpdateFile),
                                       wcUpdateFile};
    PCHAR             pBuff = NULL, pBuffEnd;
    PWCH              pwch;
    SIZE_T            ulBuffSize;
    LONG              lresult;

    if (!pSysIniPath) {
        return STATUS_INVALID_PARAMETER_1;
    }
    if (!pUserBasePath) {
        return STATUS_INVALID_PARAMETER_2;
    }
    if (!pLastSyncTime) {
        return STATUS_INVALID_PARAMETER_3;
    }

    Status = RtlAppendUnicodeStringToString(&UniUpdateName,
                                            pUserBasePath);
    if (NT_SUCCESS(Status)) {
      Status = RtlAppendUnicodeToString(&UniUpdateName,
                                        L"\\inifile.upd");
    }

    if (! NT_SUCCESS(Status)) {
      return Status;
    }

    pLastSyncTime->LowPart = 0;
    pLastSyncTime->HighPart = 0;

    InitializeObjectAttributes( &ObjAUpd,
                                &UniUpdateName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    // Open the update log
    Iosb.Status = STATUS_SUCCESS;
    Status = NtOpenFile( &hUpdate,
                         FILE_GENERIC_READ,
                         &ObjAUpd,
                         &Iosb,
                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT    // OpenOptions
                       );

    // Get the size of the file
    if (NT_SUCCESS( Status )) {
        Status = NtQueryInformationFile( hUpdate,
                                         &Iosb,
                                         &StandardInfo,
                                         sizeof(StandardInfo),
                                         FileStandardInformation
                                       );
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
        }
#if DBG
        else if (!NT_SUCCESS( Status )) {
            DbgPrint( "TermsrvGetSyncTime: Unable to QueryInformation for %wZ - Status == %x\n", &UniUpdateName, Status );
        }
#endif
    }

    if (NT_SUCCESS( Status )) {
        ulBuffSize = StandardInfo.EndOfFile.LowPart + 4 * sizeof(WCHAR);
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pBuff,
                                          0,
                                          &ulBuffSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE
                                        );
    }

    if (NT_SUCCESS( Status )) {
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pBuff,
                                          0,
                                          &ulBuffSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
    }

    if (NT_SUCCESS( Status )) {
        Status = NtReadFile( hUpdate,
                             NULL,
                             NULL,
                             NULL,
                             &Iosb,
                             pBuff,
                             StandardInfo.EndOfFile.LowPart,
                             NULL,
                             NULL
                           );

        if ( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( hUpdate, FALSE, NULL );
        }

        if ( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }
    }

    // Look for this ini file in the list
    if (NT_SUCCESS(Status)) {

        pwch = (PWCHAR)pBuff;
        pBuffEnd = pBuff + StandardInfo.EndOfFile.LowPart;

        // Look for the file in the sorted list
        while ((pwch < (PWCHAR)pBuffEnd) &&
               ((lresult = _wcsicmp(pwch, pSysIniPath->Buffer)) < 0)) {
            pwch += wcslen(pwch) + sizeof(LARGE_INTEGER)/sizeof(WCHAR) + 1;
        }

        if ((pwch < (PWCHAR)pBuffEnd) && (lresult == 0)) {
            pwch += wcslen(pwch) + 1;
            pLastSyncTime->LowPart = ((PLARGE_INTEGER)pwch)->LowPart;
            pLastSyncTime->HighPart = ((PLARGE_INTEGER)pwch)->HighPart;
        }
    }

    if (NT_SUCCESS(Status) ) {
        // Get final I/O status
        Status = Iosb.Status;
    }

    if (pBuff) {
        NtFreeVirtualMemory( NtCurrentProcess(),
                             &pBuff,
                             &ulBuffSize,
                             MEM_RELEASE
                           );
    }

    if (hUpdate) {
        Status = NtClose( hUpdate );
    }
    return(Status);
}


/*****************************************************************************
 *
 *  TermsrvPutSyncTime
 *
 *  This routine will write the time of the system ini file that the user ini
 *  file was last sync'd with.
 *
 * ENTRY:
 *   PUNICODE_STRING pSysIniPath (In) - NT fully qualified system ini path
 *   PUNICODE_STRING pUserBasePath (In) - NT fully qualified user directory path
 *   PLARGE_INTEGER pLastSyncTime (OUT) - ptr to return last sync time
 *
 * EXIT:
 *   STATUS_SUCCESS - successfully stored the last sync time in infile.upd
 *
 ****************************************************************************/

NTSTATUS
TermsrvPutSyncTime(
    PUNICODE_STRING pSysIniPath,
    PUNICODE_STRING pUserBasePath,
    PLARGE_INTEGER  pLastSyncTime)
{
    NTSTATUS Status;
    HANDLE   hUpdate = NULL;
    OBJECT_ATTRIBUTES ObjAUpd;
    IO_STATUS_BLOCK   Iosb;
    FILE_STANDARD_INFORMATION StandardInfo;
    WCHAR             wcUpdateFile[MAX_PATH+1];
    UNICODE_STRING    UniUpdateName = {0,
                                       sizeof(wcUpdateFile),
                                       wcUpdateFile};
    PCHAR             pBuff = NULL, pBuffEnd;
    PWCH              pwch;
    SIZE_T            ulBuffSize;
    ULONG             ulLength;
    SIZE_T            ulRegionSize;
    LONG              lresult;
    LARGE_INTEGER     FileLength;
    FILE_POSITION_INFORMATION CurrentPos;

    if (!pSysIniPath) {
        return STATUS_INVALID_PARAMETER_1;
    }
    if (!pUserBasePath) {
        return STATUS_INVALID_PARAMETER_2;
    }
    if (!pLastSyncTime) {
        return STATUS_INVALID_PARAMETER_3;
    }

    Status = RtlAppendUnicodeStringToString(&UniUpdateName,
                                            pUserBasePath);
    if (NT_SUCCESS(Status)) {
      Status = RtlAppendUnicodeToString(&UniUpdateName,
                                        L"\\inifile.upd");
    }

    if (! NT_SUCCESS(Status)) {
      return Status;
    }

    InitializeObjectAttributes( &ObjAUpd,
                                &UniUpdateName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    // Open the update log
    Iosb.Status = STATUS_SUCCESS;
    Status = NtCreateFile( &hUpdate,
                             FILE_READ_DATA | FILE_WRITE_DATA |
                               FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                             &ObjAUpd,
                             &Iosb,
                           NULL,                  // Allocation size
                           FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
                             FILE_SHARE_WRITE,      // dwShareMode
                           FILE_OPEN_IF,          // CreateDisposition
                             FILE_SYNCHRONOUS_IO_NONALERT |
                               FILE_NON_DIRECTORY_FILE, // CreateFlags
                           NULL, // EaBuffer
                           0     // EaLength
                           );

    if (NT_SUCCESS( Status )) {
        Status = NtQueryInformationFile( hUpdate,
                                         &Iosb,
                                         &StandardInfo,
                                         sizeof(StandardInfo),
                                         FileStandardInformation
                                       );
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
        }
#if DBG
        else if (!NT_SUCCESS( Status )) {
            DbgPrint( "TermsrvPutLastSyncTime: Unable to QueryInformation for %wZ - Status == %x\n", &UniUpdateName, Status );
        }
#endif
    }

    if (NT_SUCCESS( Status )) {
        ulBuffSize = StandardInfo.EndOfFile.LowPart + 4 * sizeof(WCHAR);
        ulRegionSize = ulBuffSize + 0x1000; // Room for 4K of growth
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pBuff,
                                          0,
                                          &ulRegionSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE
                                        );
    }

    if (NT_SUCCESS( Status )) {
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pBuff,
                                          0,
                                          &ulBuffSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
    }

    if (NT_SUCCESS( Status ) && StandardInfo.EndOfFile.LowPart) {
        Status = NtReadFile( hUpdate,
                             NULL,
                             NULL,
                             NULL,
                             &Iosb,
                             pBuff,
                             StandardInfo.EndOfFile.LowPart,
                             NULL,
                             NULL
                           );

        if ( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( hUpdate, FALSE, NULL );
        }

        if ( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }
    }

    // Look for this ini file in the list
    if (NT_SUCCESS(Status)) {

        pwch = (PWCHAR)pBuff;
        pBuffEnd = pBuff + StandardInfo.EndOfFile.LowPart;

        // Look for the file in the list
        while ((pwch < (PWCHAR)pBuffEnd) &&
               ((lresult = _wcsicmp(pwch, pSysIniPath->Buffer)) < 0)) {
            pwch += wcslen(pwch) + (sizeof(LARGE_INTEGER)/sizeof(WCHAR)) + 1;
        }

        // If the ini file is already in the file, just update the time
        if ((pwch < (PWCHAR)pBuffEnd) && (lresult == 0)) {
            pwch += wcslen(pwch) + 1;
            ((PLARGE_INTEGER)pwch)->LowPart = pLastSyncTime->LowPart;
            ((PLARGE_INTEGER)pwch)->HighPart = pLastSyncTime->HighPart;

        } else {                    // Ini file not in list

            // Figure out the size to grow the file
            ulLength = (pSysIniPath->Length + 2) + sizeof(LARGE_INTEGER);
            ulBuffSize += ulLength;

            // Grow the memory region
            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &pBuff,
                                              0,
                                              &ulBuffSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );

            if (NT_SUCCESS(Status)) {
                // figure out where the entry goes in the file
                if (pwch < (PWCHAR)pBuffEnd) {
                    RtlMoveMemory( pwch+(ulLength/sizeof(WCHAR)),
                                   pwch,
                                   pBuffEnd - (PCHAR)pwch
                                 );
                }

                pBuffEnd += ulLength;
                wcscpy(pwch, pSysIniPath->Buffer);
                pwch += (pSysIniPath->Length + 2)/sizeof(WCHAR);
                ((PLARGE_INTEGER)pwch)->LowPart = pLastSyncTime->LowPart;
                ((PLARGE_INTEGER)pwch)->HighPart = pLastSyncTime->HighPart;
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        CurrentPos.CurrentByteOffset.LowPart = 0;
        CurrentPos.CurrentByteOffset.HighPart = 0;
        Status = NtSetInformationFile( hUpdate,
                                       &Iosb,
                                       &CurrentPos,
                                       sizeof(CurrentPos),
                                       FilePositionInformation
                                     );

        Status = NtWriteFile( hUpdate,
                              NULL,
                              NULL,
                              NULL,
                              &Iosb,
                              pBuff,
                              (ULONG)(pBuffEnd - pBuff + 1),
                              NULL,
                              NULL
                            );

        if( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( hUpdate, FALSE, NULL );
        }

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }
    }

    if (NT_SUCCESS( Status )) {
        FileLength.LowPart = (ULONG)(pBuffEnd - pBuff);
        FileLength.HighPart = 0;
        Status = NtSetInformationFile( hUpdate,
                                       &Iosb,
                                       &FileLength,
                                       sizeof( FileLength ),
                                       FileEndOfFileInformation
                                     );
    }

    if (pBuff) {
        NtFreeVirtualMemory( NtCurrentProcess(),
                             &pBuff,
                             &ulRegionSize,
                             MEM_RELEASE
                           );
    }

    if (hUpdate) {
        Status = NtClose( hUpdate );
    }

    return(Status);
}


/*****************************************************************************
 *
 *  TermsrvCheckIniSync
 *
 *  This routine will get the time of the system ini file that the user ini
 *  file was last sync'd with.
 *
 * ENTRY:
 *   PUNICODE_STRING pSysIniPath (In) - NT fully qualified system ini path
 *   PUNICODE_STRING pUserBasePath (In) - NT fully qualified user directory path
 *   BOOLEAN fGet (In) - TRUE means to get last sync time, FALSE means to write it
 *   PLARGE_INTEGER pLastSyncTime (OUT) - ptr to return last sync time
 *
 * EXIT:
 *   TRUE  - User ini file should be sync'd
 *   FALSE - User ini file should be sync'd
 *
 ****************************************************************************/

BOOLEAN
TermsrvCheckIniSync(
    PUNICODE_STRING pSysIniPath,
    PUNICODE_STRING pUserBasePath)
{
    LARGE_INTEGER          LastSyncTime;
    OBJECT_ATTRIBUTES      objaIni;
    FILE_NETWORK_OPEN_INFORMATION BasicInfo;
    NTSTATUS               Status;

    // Get the last sync time of the ini file from the inifile.upd file
    TermsrvGetSyncTime(pSysIniPath, pUserBasePath, &LastSyncTime);

    // Get the last write time of the system ini file
    InitializeObjectAttributes(
        &objaIni,
        pSysIniPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    // Now query it
    Status = NtQueryFullAttributesFile( &objaIni, &BasicInfo );

    // If we couldn't get the time or the system ini file has been updated
    // since we last sync'd, return TRUE
    if (!NT_SUCCESS(Status) ||
        ((BasicInfo.LastWriteTime.HighPart > LastSyncTime.HighPart) ||
         ((BasicInfo.LastWriteTime.HighPart == LastSyncTime.HighPart) &&
         (BasicInfo.LastWriteTime.LowPart > LastSyncTime.LowPart)))) {
        return(TRUE);
    }
    return(FALSE);
}
/*****************************************************************************
 *
 *  TermsrvDoesFileExist
 *
 *   Returns whether the file exists or not.
 *
 *   Must use NT, not WIN32 pathnames.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvDoesFileExist(
    PUNICODE_STRING pFileName
    )
{
    NTSTATUS Status;
    FILE_BASIC_INFORMATION BasicInfo;
    OBJECT_ATTRIBUTES Obja;

    InitializeObjectAttributes(
        &Obja,
        pFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    /*
     * Now query it
     */
    Status = NtQueryAttributesFile( &Obja, &BasicInfo );

    if( NT_SUCCESS( Status ) ) {
        return( TRUE );
    }

    return( FALSE );
}



/*****************************************************************************
 *
 *  TermsrvSyncUserIniFile
 *
 *   This routine will check that the user's ini file is "sync'd" with the
 *   system version of the ini file.  This means that it walks through the
 *   system ini file and checks that there is a corresponding entry in the
 *   user's ini file.
 *
 * ENTRY:
 *   IN PINIFILE_PARAMETERS a - ptr to inifile structure
 *
 * EXIT:
 *   True  - Ini file updated
 *   False - User Ini file was unchanged
 *
 ****************************************************************************/
BOOL TermsrvSyncUserIniFile(PINIFILE_PARAMETERS a)
{
    WCHAR          wcIniPath[MAX_PATH+1];
    UNICODE_STRING IniFilePath = {MAX_PATH,
                                  MAX_PATH+1,
                                  wcIniPath};
    PWCH           pwch, pwcIniName;
    UNICODE_STRING UniSysPath;
    UNICODE_STRING UserBasePath;
    NTSTATUS       Status;
    HANDLE         SrcHandle;
    ULONG          ulCompatFlags;
    OBJECT_ATTRIBUTES SrcObja;
    IO_STATUS_BLOCK   SrcIosb;
    INIFILE_OPERATION OrigOperation;
    BOOLEAN           OrigWrite, OrigMultiValue, OrigUnicode,
                      OrigWriteOperation, fIniUpdated = FALSE;
    ANSI_STRING       OrigAppName, OrigVarName;
    ULONG             OrigResultChars, OrigResultMaxChars;
    LPSTR             OrigResultBuffer;
    OBJECT_ATTRIBUTES      objaIni;
    FILE_NETWORK_OPEN_INFORMATION BasicInfo;

    // If INI file mapping is not on, return
    if (IsSystemLUID() || TermsrvAppInstallMode()) {
        return(FALSE);
    }

    // Build full system path to the Ini file, and get BasePath to user dir
    if ((gpTermsrvBuildSysIniPath == NULL) || !(gpTermsrvBuildSysIniPath(&a->NtFileName, &UniSysPath, &UserBasePath))) {
        #if DBG
        //DbgPrint("TermsrvSyncUserIniFile: Error building Sys Ini Path!\n");
        #endif
        return(FALSE);
    }

    // Get the ini file name
    pwch = wcsrchr(a->NtFileName.Buffer, L'\\') ;
    if (pwch == NULL) {
        return FALSE;
    } else{
        pwch++;
    }

    pwcIniName = RtlAllocateHeap( RtlProcessHeap(),
                                  0,
                                  (wcslen(pwch) + 1)*sizeof(WCHAR));
    if (pwcIniName == NULL) {
        return FALSE;
    }

    wcscpy(pwcIniName, pwch);
    pwch = wcsrchr(pwcIniName, L'.');
    if (pwch) {
        *pwch = L'\0';
    }

    if (gpGetTermsrCompatFlags) {
        gpGetTermsrCompatFlags(pwcIniName, &ulCompatFlags, CompatibilityIniFile);
    } else {
        return FALSE;
    }

    // If the INISYNC compatibility flag is set in the registry and the
    // system version of the ini file exists, sync up the user version
    if (((ulCompatFlags & (TERMSRV_COMPAT_INISYNC | TERMSRV_COMPAT_WIN16)) ==
         (TERMSRV_COMPAT_INISYNC | TERMSRV_COMPAT_WIN16)) &&
        TermsrvDoesFileExist(&UniSysPath) &&
        TermsrvCheckIniSync(&UniSysPath, &UserBasePath)) {

        // Create a backup copy of the original file (inifile.ctx)
        wcscpy(wcIniPath, UserBasePath.Buffer);
        if (UserBasePath.Buffer[UserBasePath.Length/sizeof(WCHAR) - 1] != L'\\')
            wcscat(wcIniPath, L"\\");
        wcscat(wcIniPath, pwcIniName);
        wcscat(wcIniPath, L".ctx");
        IniFilePath.Length = wcslen(wcIniPath)*sizeof(WCHAR);

        if (gpTermsrvCopyIniFile) {
            Status = gpTermsrvCopyIniFile(&a->NtFileName, NULL, &IniFilePath);
    #if DBG
            if (!NT_SUCCESS(Status)) {
                DbgPrint("TermsrvSyncUserIniFile: Error 0x%x creating backup ini file %ws\n",
                         Status,
                         wcIniPath);
            }
    #endif
        } else {
            return FALSE;
            }

        // Check that each entry in the system version is in the user's version
        InitializeObjectAttributes(&SrcObja,
                                   &UniSysPath,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        // Open the src
        SrcIosb.Status = STATUS_SUCCESS;
        Status = NtOpenFile(&SrcHandle,
                             FILE_GENERIC_READ,
                            &SrcObja,
                            &SrcIosb,
                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                            FILE_SYNCHRONOUS_IO_NONALERT);

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
                  Status = SrcIosb.Status;
        }

        if( !NT_SUCCESS(Status) ) {
#if DBG
            DbgPrint("TermsrvSyncUserIniFile: Error 0x%x opening SrcFile %ws\n",
                     Status,
                     &UniSysPath.Buffer);
#endif
            goto Cleanup;
        }

        // Save the original values
        OrigOperation = a->Operation;
        OrigMultiValue = a->MultiValueStrings;
        OrigAppName = a->ApplicationName;
        OrigVarName = a->VariableName;
        OrigResultChars = a->ResultChars;
        OrigResultMaxChars = a->ResultMaxChars;
        OrigResultBuffer = a->ResultBuffer;
        OrigUnicode = a->Unicode;
        OrigWriteOperation = a->WriteOperation;

        // Set up the open for writes
        a->WriteOperation = TRUE;
        a->Operation = WriteKeyValue;
        a->MultiValueStrings = FALSE;
        a->Unicode = FALSE;

        Status = BaseDllOpenIniFileOnDisk( a );

        if( !NT_SUCCESS(Status) ) {
#if DBG
            DbgPrint("TermsrvSyncUserIniFile: Error 0x%x opening DestFile %ws\n",
                     Status,
                     &a->NtFileName.Buffer);
#endif
            NtClose( SrcHandle );
                goto Cleanup;
        }

        // set the data up for writing
        a->TextEnd = (PCHAR)a->IniFile->BaseAddress +
                            a->IniFile->EndOfFile;
        a->TextCurrent = a->IniFile->BaseAddress;

        // Make sure entries in system ini file are in user ini file
        Status = TermsrvIniSyncLoop( SrcHandle, a, &fIniUpdated );
#if DBG
        if( !NT_SUCCESS(Status) ) {
            DbgPrint("TermsrvSyncUserIniFile: Error 0x%x Doing sync loop\n",Status);
        }
#endif

        // Close the file handles
        NtClose( SrcHandle );
        BaseDllCloseIniFileOnDisk( a );

        // Restore the variables in the ini file structure
        a->Operation = OrigOperation;
        a->MultiValueStrings = OrigMultiValue;
        a->ApplicationName = OrigAppName;
        a->VariableName = OrigVarName;
        a->ResultChars = OrigResultChars;
        a->ResultMaxChars = OrigResultMaxChars;
        a->ResultBuffer = OrigResultBuffer;
        a->WriteOperation = FALSE;
        a->Unicode = OrigUnicode;
        a->WriteOperation = OrigWriteOperation;

        // Get the last write time of the system ini file
        InitializeObjectAttributes( &objaIni,
                                    &UniSysPath,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                  );

        // Now query it
        Status = NtQueryFullAttributesFile( &objaIni, &BasicInfo );

        // Update the sync time in the inisync file
        if (NT_SUCCESS(Status)) {
            TermsrvPutSyncTime( &UniSysPath,
                            &UserBasePath,
                            &BasicInfo.LastWriteTime
                          );
        }
    }

Cleanup:
    // Free the unicode buffers
    RtlFreeHeap( RtlProcessHeap(), 0, UniSysPath.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, UserBasePath.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, pwcIniName);

    return(fIniUpdated);
}


/*****************************************************************************
 *
 *  TermsrvIniSyncLoop
 *
 *  This routine will verify that there's a corresponding entry in the user's
 *  ini file for each entry in the system ini file.
 *
 * ENTRY:
 *   HANDLE SrcHandle (INPUT)  - Handle to system ini file
 *   PINIFILE_PARAMETERS a (INPUT) - pointer to current ini file structure
 *   PBOOLEAN pfIniUpdated (OUTPUT) - Returns TRUE if user ini file is modified
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvIniSyncLoop(HANDLE SrcHandle,
               PINIFILE_PARAMETERS a,
               PBOOLEAN pfIniUpdated)
{
    PCHAR pStr;
    NTSTATUS Status;
    ULONG StringSize;
    CHAR  IOBuf[512];
    ULONG IOBufSize = 512;
    ULONG IOBufIndex = 0;
    ULONG IOBufFillSize = 0;
    ANSI_STRING AnsiSection;
    PCH pch;
    PVOID pSection, origbase;

    AnsiSection.Buffer = NULL;
    *pfIniUpdated = FALSE;

    while( 1 ) {

        pStr = NULL;
        StringSize = 0;

        if (gpTermsrvGetString == NULL) {
            return STATUS_UNSUCCESSFUL;
        }

        // Get a string from the source ini file
        Status = gpTermsrvGetString(SrcHandle,
                               &pStr,
                               &StringSize,
                               IOBuf,
                               IOBufSize,
                              &IOBufIndex,
                               &IOBufFillSize);

        if( !NT_SUCCESS(Status) ) {

            ASSERT( pStr == NULL );

            if( Status == STATUS_END_OF_FILE ) {
                Status = STATUS_SUCCESS;
            }
            if (AnsiSection.Buffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, AnsiSection.Buffer );
            }

            a->IniFile->UpdateEndOffset = a->IniFile->EndOfFile;
            return( Status );
        }

        // Make sure we got some actual data
        ASSERT( pStr != NULL );

        // Is this a section name?
        if (*pStr == '[') {
            if (AnsiSection.Buffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, AnsiSection.Buffer );
                AnsiSection.Buffer = NULL;
            }
            pch = strrchr(pStr, ']');
            if (pch) {
                AnsiSection.MaximumLength = (USHORT)(pch - pStr);
                *pch = '\0';
            } else {
                AnsiSection.Length = (USHORT)strlen(pStr);
            }
            AnsiSection.Length = AnsiSection.MaximumLength - 1;
            AnsiSection.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                                 0,
                                                 AnsiSection.MaximumLength);
            if (!AnsiSection.Buffer) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            strcpy(AnsiSection.Buffer, pStr+1);
            a->ApplicationName = AnsiSection;

            a->TextCurrent = a->IniFile->BaseAddress;   // reset file pointer

            // See if the section already exists, if so save the start of it
            Status = BaseDllFindSection( a );
            if (NT_SUCCESS(Status)) {
                pSection = a->TextCurrent;
            } else {
                pSection = NULL;
            }

        // If it's not a comment, see if the entry is in the user's ini file
        } else if (*pStr != ';') {

            pch = strchr(pStr, '=');
            if (pch) {
                a->VariableName.Length = a->VariableName.MaximumLength =
                    (USHORT)(pch - pStr);
                a->VariableName.Buffer = pStr;
                a->ValueBuffer = (++pch);
                a->ValueLength = 0;
                while (*pch && (*pch != 0xa) && (*pch != 0xd)) {
                    pch++;
                    a->ValueLength++;
                }


                // If the section exists, check for the keyword in user's ini
                if (pSection) {
                    a->TextCurrent = pSection;
                    Status = BaseDllFindKeyword( a );
                }

                // If variable isn't found, write it out
                if (!pSection || !NT_SUCCESS( Status )) {

                    origbase = a->TextCurrent = a->IniFile->BaseAddress;
                    Status = BaseDllWriteKeywordValue( a, NULL );
                    a->TextEnd = (PCHAR)a->IniFile->BaseAddress +
                                        a->IniFile->EndOfFile;
                    if (!NT_SUCCESS(Status)) {
                              #if DBG
                              DbgPrint("TermsrvIniSyncLoop: Error 0x%x write Key Value\n",
                                  Status);
                              #endif
                        a->IniFile->UpdateEndOffset = a->IniFile->EndOfFile;
                        RtlFreeHeap( RtlProcessHeap(), 0, pStr );
                        if (AnsiSection.Buffer) {
                            RtlFreeHeap(RtlProcessHeap(),
                                        0,
                                        AnsiSection.Buffer);
                        }
                        return(Status);
                    }
                    *pfIniUpdated = TRUE;
                    if (origbase != a->IniFile->BaseAddress) {
                        a->TextCurrent = a->IniFile->BaseAddress;
                        Status = BaseDllFindSection( a );
                        if (NT_SUCCESS(Status)) {
                            pSection = a->TextCurrent;
                        } else {
                            pSection = NULL;
                        }
                    }
                }
            }
        }


    } // end while(1)
}

/******************************************************************************
 *
 *  GetPerUserWindowsDirectory
 *
 *
 *
 *****************************************************************************/
ULONG
GetPerUserWindowsDirectory(PWCHAR TermSrvWindowsPath, ULONG len)
{
    WCHAR Buf[MAX_PATH+1];
    UNICODE_STRING BaseHomePathVariableName, BaseHomeDriveVariableName;
    NTSTATUS Status;
    UNICODE_STRING Path;


    if( !IsTSAppCompatEnabled() || IsSystemLUID() || (len < MAX_PATH) ) {
        return 0;
    }

    /*
     * Check for HOMEDRIVE and HOMEPATH
     */
    RtlInitUnicodeString(&BaseHomeDriveVariableName,L"HOMEDRIVE");
    RtlInitUnicodeString(&BaseHomePathVariableName,L"HOMEPATH");


    Path.Buffer = Buf;
    Path.Length = 0;
    Path.MaximumLength = (MAX_PATH * sizeof(WCHAR)) - (9 * sizeof(WCHAR)); //MAX_PATH - wcslen(L"\\WINDOWS") + 1

    if (NT_SUCCESS(Status = RtlQueryEnvironmentVariable_U( NULL, &BaseHomeDriveVariableName,
                                        &Path))) {
      Path.Buffer[Path.Length] = UNICODE_NULL;
      wcscpy(TermSrvWindowsPath,Path.Buffer);

      Path.MaximumLength -= Path.Length;

      if (NT_SUCCESS(Status = RtlQueryEnvironmentVariable_U( NULL, &BaseHomePathVariableName,
                                          &Path))) {
         Path.Buffer[Path.Length] = UNICODE_NULL;
         wcscat(TermSrvWindowsPath,Path.Buffer);
      }

    }

    if (!NT_SUCCESS(Status)) {
#if DBG
       DbgPrint("GetPerUserWindowsDirectory Failed with Status %lx\n", Status);
#endif
       return 0;
    }

    /*
    * Add a trailing backslash if one's not already there
    */

    if (TermSrvWindowsPath[wcslen(TermSrvWindowsPath) -1 ] != L'\\') {
      wcscat(TermSrvWindowsPath,L"\\");
    }

    wcscat(TermSrvWindowsPath,L"WINDOWS");

    return( wcslen(TermSrvWindowsPath) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tmem.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tbase.c

Abstract:

    Skeleton for a Win32 Base API Test Program

Author:

    Steve Wood (stevewo) 26-Oct-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <stdarg.h>
#include <assert.h>
#include <stdio.h>

#ifndef DBG
#define DBG 0
#endif
#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif
#include "basertl.h"

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    NTSTATUS Status;
    LPVOID p1, p2, p3, p4, p5, p6;
    HANDLE h1, h2, h3, h4, h5, h6;
    BOOL result;
    LPDWORD p;

    printf( "TMEM: Entering Test Program\n" );

    p1 = LocalAlloc( LMEM_ZEROINIT, 0 );
    printf( "LocalAlloc( 0 ) == %lX\n", p1 );
    printf( "LocalSize( %lX ) == %ld\n", p1, LocalSize( p1 ) );

    p2 = LocalReAlloc( p1, 23, 0 );
    printf( "LocalReAlloc( %lX, 23 ) == %lX\n", p1, p2 );
    printf( "LocalSize( %lX ) == %ld\n", p2, LocalSize( p2 ) );
    printf( "LocalFree( %lX ) == %ld\n", p2, LocalFree( p2 ) );

    p1 = LocalAlloc( LMEM_ZEROINIT, 123 );
    printf( "LocalAlloc( 123 ) == %lX\n", p1 );
    printf( "LocalSize( %lX ) == %ld\n", p1, LocalSize( p1 ) );

    p2 = LocalReAlloc( p1, 23, 0 );
    printf( "LocalReAlloc( %lX, 23 ) == %lX\n", p1, p2 );
    printf( "LocalSize( %lX ) == %ld\n", p2, LocalSize( p2 ) );

    p3 = LocalReAlloc( p2, 223, LMEM_ZEROINIT );
    printf( "LocalReAlloc( %lX, 223 ) == %lX\n", p2, p3 );
    printf( "LocalSize( %lX ) == %ld\n", p3, LocalSize( p3 ) );

    p4 = LocalReAlloc( p3, 22, 0 );
    printf( "LocalReAlloc( %lX, 22 ) == %lX\n", p3, p4 );
    printf( "LocalSize( %lX ) == %ld\n", p4, LocalSize( p4 ) );
    printf( "LocalFree( %lX ) == %ld\n", p4, LocalFree( p4 ) );

    h1 = LocalAlloc( LMEM_MOVEABLE | LMEM_ZEROINIT, 123 );
    printf( "LocalAlloc( MOVEABLE, 123 ) == %lX (-> %lX)\n", h1, LocalLock( h1 ) );
    printf( "LocalSize( %lX ) == %ld\n", h1, LocalSize( h1 ) );

    h2 = LocalReAlloc( h1, 23, 0 );
    printf( "LocalReAlloc( %lX, 23 ) == %lX\n", h1, h2, LocalLock( h2 ) );
    printf( "LocalSize( %lX ) == %ld\n", h2, LocalSize( h2 ) );

    h3 = LocalReAlloc( h2, 223, LMEM_ZEROINIT );
    printf( "LocalReAlloc( %lX, 223 ) == %lX\n", h2, h3, LocalLock( h3 ) );
    printf( "LocalSize( %lX ) == %ld\n", h3, LocalSize( h3 ) );

    h4 = LocalReAlloc( h3, 22, 0 );
    printf( "LocalReAlloc( %lX, 22 ) == %lX\n", h3, h4, LocalLock( h4 ) );
    printf( "LocalSize( %lX ) == %ld\n", h4, LocalSize( h4 ) );
    printf( "LocalFree( %lX ) == %ld\n", h4, LocalFree( h4 ) );


    h1 = GlobalAlloc( GMEM_ZEROINIT, 123 );
    printf( "GlobalAlloc( 123 ) == %lX\n", h1 );
    printf( "GlobalFlags( %lX ) == %ld\n", h1, GlobalFlags( h1 ) );
    printf( "GlobalSize( %lX ) == %ld\n", h1, GlobalSize( h1 ) );

    h2 = GlobalReAlloc( h1, 23, 0 );
    printf( "GlobalReAlloc( %lX, 23 ) == %lX\n", h1, h2 );
    printf( "GlobalSize( %lX ) == %ld\n", h2, GlobalSize( h2 ) );

    h3 = GlobalReAlloc( h2, 223, GMEM_ZEROINIT );
    printf( "GlobalReAlloc( %lX, 223 ) == %lX\n", h2, h3 );
    printf( "GlobalSize( %lX ) == %ld\n", h3, GlobalSize( h3 ) );

    h4 = GlobalReAlloc( h3, 22, 0 );
    printf( "GlobalReAlloc( %lX, 22 ) == %lX\n", h3, h4 );
    printf( "GlobalSize( %lX ) == %ld\n", h4, GlobalSize( h4 ) );
    printf( "GlobalFree( %lX ) == %ld\n", h4, GlobalFree( h4 ) );

    h1 = GlobalAlloc( GMEM_ZEROINIT, 12003 );
    printf( "GlobalAlloc( 123 ) == %lX\n", h1 );
    printf( "GlobalFlags( %lX ) == %ld\n", h1, GlobalFlags( h1 ) );
    printf( "GlobalSize( %lX ) == %ld\n", h1, GlobalSize( h1 ) );

    h2 = GlobalReAlloc( h1, 4000, 0 );
    printf( "GlobalReAlloc( %lX, 23 ) == %lX\n", h1, h2 );
    printf( "GlobalSize( %lX ) == %ld\n", h2, GlobalSize( h2 ) );

    h3 = GlobalReAlloc( h2, 8000, GMEM_ZEROINIT );
    printf( "GlobalReAlloc( %lX, 223 ) == %lX\n", h2, h3 );
    printf( "GlobalSize( %lX ) == %ld\n", h3, GlobalSize( h3 ) );

    h4 = GlobalReAlloc( h3, 22, 0 );
    printf( "GlobalReAlloc( %lX, 22 ) == %lX\n", h3, h4 );
    printf( "GlobalSize( %lX ) == %ld\n", h4, GlobalSize( h4 ) );
    printf( "GlobalFree( %lX ) == %ld\n", h4, GlobalFree( h4 ) );

    DbgBreakPoint();

    h1 = GlobalAlloc( GMEM_DDESHARE, 123 );
    printf( "GlobalAlloc( 123 ) == %lX\n", h1 );
    printf( "GlobalFlags( %lX ) == %ld\n", h1, GlobalFlags( h1 ) );
    printf( "GlobalSize( %lX ) == %ld\n", h1, GlobalSize( h1 ) );

    p = GlobalLock( h1 );
    if (*p != 0xABCDEF01) {
        DbgBreakPoint();
        }

    h2 = GlobalReAlloc( h1, 23, 0 );
    printf( "GlobalReAlloc( %lX, 23 ) == %lX\n", h1, h2 );
    printf( "GlobalSize( %lX ) == %ld\n", h2, GlobalSize( h2 ) );

    h3 = GlobalReAlloc( h2, 223, GMEM_ZEROINIT );
    printf( "GlobalReAlloc( %lX, 223 ) == %lX\n", h2, h3 );
    printf( "GlobalSize( %lX ) == %ld\n", h3, GlobalSize( h3 ) );

    h4 = GlobalReAlloc( h3, 22, 0 );
    printf( "GlobalReAlloc( %lX, 22 ) == %lX\n", h3, h4 );
    printf( "GlobalSize( %lX ) == %ld\n", h4, GlobalSize( h4 ) );
    printf( "GlobalFree( %lX ) == %ld\n", h4, GlobalFree( h4 ) );

    printf( "TMEM: Exiting Test Program\n" );

    return 0;
}

#if 0
    MEMORY_BASIC_INFORMATION MemoryInformation;
    DWORD cb;
    DWORD oldProtect;

    p1 = VirtualAlloc( NULL, 8192, MEM_RESERVE, PAGE_READONLY );
    p2 = VirtualAlloc( (LPVOID)((LPSTR)p1 + 4096), 4096, MEM_COMMIT, PAGE_READWRITE );
    try {
        *(LPDWORD)p1 = -1;
        *(LPDWORD)p2 = -2;
        }
    except( 1 ) {
        }

    cb = VirtualQuery( (LPVOID)p1, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p1, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    cb = VirtualQuery( (LPVOID)p2, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p2, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    result = VirtualProtect( (LPVOID)p2, 4096, PAGE_READONLY, &oldProtect );
    printf( "VirtualProtect( %X, 4096, PAGE_READONLY, oldProtect == %x ) = %d (%d)\n", p2, oldProtect, result, GetLastError() );

    cb = VirtualQuery( (LPVOID)p2, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p2, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    result = VirtualFree( (LPVOID)p2, 4096, MEM_DECOMMIT );
    printf( "VirtualFree( %X, 4096, MEM_DECOMMIT ) = %d\n", p2, result, GetLastError() );

    cb = VirtualQuery( (LPVOID)p2, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p2, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    result = VirtualFree( (LPVOID)p2, 4096, MEM_RELEASE );
    printf( "VirtualFree( %X, 4096, MEM_RELEASE ) = %d\n", p2, result, GetLastError() );

    cb = VirtualQuery( (LPVOID)p2, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p2, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    result = VirtualFree( (LPVOID)p1, 4096, MEM_RELEASE );
    printf( "VirtualFree( %X, 4096, MEM_RELEASE ) = %d\n", p1, result, GetLastError() );

    cb = VirtualQuery( (LPVOID)p1, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p1, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tblddcb.c ===
#include "windows.h"
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>

void __cdecl main(int argc,char *argv[]) {

    DCB NewDCB;
    COMMTIMEOUTS To = {0};
    char firstString[] = "1200,n,8,1";
    char secondString[] = "COM1 1200,n,8,1";
    char thirdString[] = "HOST1 1200,8,N,1";
    char fourthString[] = "COM1:1200,n,8,1";
    char fifthString[] = "COM1: baud=9600 TO=ON";

    printf("About to do %s\n",&firstString[0]);
    if (!BuildCommDCB(
             &firstString[0],
             &NewDCB
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }
    printf("About to do %s\n",&secondString[0]);
    if (!BuildCommDCB(
             &secondString[0],
             &NewDCB
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }
    printf("About to do %s\n",&thirdString[0]);
    if (!BuildCommDCB(
             &thirdString[0],
             &NewDCB
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }
    printf("About to do %s\n",&fourthString[0]);
    if (!BuildCommDCB(
             &fourthString[0],
             &NewDCB
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }
    printf("About to do %s\n",&fifthString[0]);
    if (!BuildCommDCBAndTimeouts(
             &fifthString[0],
             &NewDCB,
             &To
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\thread.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    thread.c

Abstract:

    This module implements Win32 Thread Object APIs

Author:

    Mark Lucovsky (markl) 21-Sep-1990

Revision History:

--*/

#include "basedll.h"
#include "faultrep.h"

HANDLE BasepDefaultTimerQueue ;
ULONG BasepTimerQueueInitFlag ;
ULONG BasepTimerQueueDoneFlag ;

HANDLE
APIENTRY
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )

/*++

Routine Description:

    A thread object can be created to execute within the address space of the
    calling process using CreateThread.

    See CreateRemoteThread for a description of the arguments and return value.

--*/
{
    return CreateRemoteThread( NtCurrentProcess(),
                               lpThreadAttributes,
                               dwStackSize,
                               lpStartAddress,
                               lpParameter,
                               dwCreationFlags,
                               lpThreadId
                             );
}

HANDLE
APIENTRY
CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )

/*++

Routine Description:

    A thread object can be created to execute within the address space of the
    another process using CreateRemoteThread.

    Creating a thread causes a new thread of execution to begin in the address
    space of the current process. The thread has access to all objects opened
    by the process.

    The thread begins executing at the address specified by the StartAddress
    parameter. If the thread returns from this procedure, the results are
    un-specified.

    The thread remains in the system until it has terminated and
    all handles to the thread
    have been closed through a call to CloseHandle.

    When a thread terminates, it attains a state of signaled satisfying all
    waits on the object.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for thread objects:

        - THREAD_QUERY_INFORMATION - This access is required to read
          certain information from the thread object.

        - SYNCHRONIZE - This access is required to wait on a thread
          object.

        - THREAD_GET_CONTEXT - This access is required to read the
          context of a thread using GetThreadContext.

        - THREAD_SET_CONTEXT - This access is required to write the
          context of a thread using SetThreadContext.

        - THREAD_SUSPEND_RESUME - This access is required to suspend or
          resume a thread using SuspendThread or ResumeThread.

        - THREAD_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for a thread object.

Arguments:

    hProcess - Supplies the handle to the process in which the thread is
        to be create in.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    dwStackSize - Supplies the size in bytes of the stack for the new thread.
        A value of zero specifies that the thread's stack size should be
        the same size as the stack size of the first thread in the process.
        This size is specified in the application's executable file.

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns and that
        accepts a single 32-bit pointer argument.

    lpParameter - Supplies a single parameter value passed to the thread.

    dwCreationFlags - Supplies additional flags that control the creation
        of the thread.

        dwCreationFlags Flags:

        CREATE_SUSPENDED - The thread is created in a suspended state.
            The creator can resume this thread using ResumeThread.
            Until this is done, the thread will not begin execution.

        STACK_SIZE_PARAM_IS_A_RESERVATION - Use stack size as a reservation rather than commit

    lpThreadId - Returns the thread identifier of the thread.  The
        thread ID is valid until the thread terminates.

Return Value:

    NON-NULL - Returns a handle to the new thread.  The handle has full
        access to the new thread and may be used in any API that
        requires a handle to a thread object.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    CONTEXT ThreadContext;
    INITIAL_TEB InitialTeb;
    CLIENT_ID ClientId;
    ULONG i;
    ACTIVATION_CONTEXT_BASIC_INFORMATION ActivationContextInfo = {0};
    const ACTIVATION_CONTEXT_INFO_CLASS ActivationContextInfoClass = ActivationContextBasicInformation;

#if !defined(BUILD_WOW6432)
    BASE_API_MSG m;
    PBASE_CREATETHREAD_MSG a = &m.u.CreateThread;
#endif

#if defined(WX86) || defined(_AXP64_)
    BOOL bWx86 = FALSE;
    HANDLE Wx86Info;
    PWX86TIB Wx86Tib;
#endif



    //
    // Allocate a stack for this thread in the address space of the target
    // process.
    //
    if (dwCreationFlags&STACK_SIZE_PARAM_IS_A_RESERVATION) {
        Status = BaseCreateStack (hProcess,
                                  0L,
                                  dwStackSize,
                                  &InitialTeb);
    } else {
        Status = BaseCreateStack (hProcess,
                                  dwStackSize,
                                  0L,
                                  &InitialTeb);
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
    }

    //
    // Create an initial context for the new thread.
    //

    BaseInitializeContext(
        &ThreadContext,
        lpParameter,
        (PVOID)lpStartAddress,
        InitialTeb.StackBase,
        BaseContextTypeThread
        );

    pObja = BaseFormatObjectAttributes(&Obja,lpThreadAttributes,NULL);


    Status = NtCreateThread(
                &Handle,
                THREAD_ALL_ACCESS,
                pObja,
                hProcess,
                &ClientId,
                &ThreadContext,
                &InitialTeb,
                TRUE // CreateSuspended
                );
    if (!NT_SUCCESS(Status)) {
        BaseFreeThreadStack(hProcess,NULL, &InitialTeb);
        BaseSetLastNTError(Status);
        return NULL;
        }



    __try {
        // If the current thread has a non-default, inheriting activation context active, send it
        // on over to the new thread.
        if (hProcess == NtCurrentProcess()) {
            THREAD_BASIC_INFORMATION tbi;
            ULONG_PTR Cookie; // not really used but non-optional parameter

            // We need the TEB pointer for the new thread...
            Status = NtQueryInformationThread(
                Handle,
                ThreadBasicInformation,
                &tbi,
                sizeof(tbi),
                NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint("SXS: %s - Failing thread create becuase NtQueryInformationThread() failed with status %08lx\n", __FUNCTION__, Status);
                __leave;
            }

            // There might be some per-context activation going on in the current thread;
            // we need to propogate it to the new thread.
            Status =
                RtlQueryInformationActivationContext(
                    RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,
                    NULL,
                    0,
                    ActivationContextInfoClass,
                    &ActivationContextInfo,
                    sizeof(ActivationContextInfo),
                    NULL       
                    );
            if (!NT_SUCCESS(Status)) {
                DbgPrint("SXS: %s - Failing thread create because RtlQueryInformationActivationContext() failed with status %08lx\n", __FUNCTION__, Status);
                __leave;
            }

            // Only do the propogation if an activation context other than the process default is active and the NO_INHERIT flag isn't set.
            if ((ActivationContextInfo.ActivationContext != NULL) &&
                (!(ActivationContextInfo.Flags & ACTIVATION_CONTEXT_FLAG_NO_INHERIT))) {
                Status = RtlActivateActivationContextEx(
                    RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION,
                    tbi.TebBaseAddress,
                    ActivationContextInfo.ActivationContext,
                    &Cookie);
                if (!NT_SUCCESS(Status)) {
                    DbgPrint("SXS: %s - Failing thread create because RtlActivateActivationContextEx() failed with status %08lx\n", __FUNCTION__, Status);
                    __leave;
                }
            }
        }

#if defined(WX86) || defined(_AXP64_)

        //
        // Check the Target Processes to see if this is a Wx86 process
        //
        Status = NtQueryInformationProcess(hProcess,
                                           ProcessWx86Information,
                                           &Wx86Info,
                                           sizeof(Wx86Info),
                                           NULL
                                           );
        if (!NT_SUCCESS(Status)) {
            leave;
            }

        Wx86Tib = (PWX86TIB)NtCurrentTeb()->Vdm;

        //
        // if Wx86 process, setup for emulation
        //
        if ((ULONG_PTR)Wx86Info == sizeof(WX86TIB)) {

            //
            // create a WX86Tib and initialize it's Teb->Vdm.
            //
            Status = BaseCreateWx86Tib(hProcess,
                                       Handle,
                                       (ULONG)((ULONG_PTR)lpStartAddress),
                                       dwStackSize,
                                       0L,
                                       (Wx86Tib &&
                                        Wx86Tib->Size == sizeof(WX86TIB) &&
                                        Wx86Tib->EmulateInitialPc)
                                       );
            if (!NT_SUCCESS(Status)) {
                leave;
                }

            bWx86 = TRUE;

            }
        else if (Wx86Tib && Wx86Tib->EmulateInitialPc) {

            //
            // if not Wx86 process, and caller wants to call x86 code in that
            // process, fail the call.
            //
            Status = STATUS_ACCESS_DENIED;
            leave;

            }

#endif  // WX86


        //
        // Call the Windows server to let it know about the
        // thread.
        //
        if ( !BaseRunningInServerProcess ) {

#if defined(BUILD_WOW6432)
            Status = CsrBasepCreateThread(Handle,
                                          ClientId
                                          );
#else
            a->ThreadHandle = Handle;
            a->ClientId = ClientId;
            CsrClientCallServer( (PCSR_API_MSG)&m,
                                 NULL,
                                 CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                      BasepCreateThread
                                                    ),
                                 sizeof( *a )
                               );

            Status = m.ReturnValue;
#endif
        }

        else {
            if (hProcess != NtCurrentProcess()) {
                CSRREMOTEPROCPROC ProcAddress;
                ProcAddress = (CSRREMOTEPROCPROC)GetProcAddress(
                                                    GetModuleHandleA("csrsrv"),
                                                    "CsrCreateRemoteThread"
                                                    );
                if (ProcAddress) {
                    Status = (ProcAddress)(Handle, &ClientId);
                    }
                }
            }


        if (!NT_SUCCESS(Status)) {
            Status = (NTSTATUS)STATUS_NO_MEMORY;
            }
        else {

            if ( ARGUMENT_PRESENT(lpThreadId) ) {
                *lpThreadId = HandleToUlong(ClientId.UniqueThread);
                }

            if (!( dwCreationFlags & CREATE_SUSPENDED) ) {
                NtResumeThread(Handle,&i);
                }
            }

        }
    __finally {
        if (ActivationContextInfo.ActivationContext != NULL)
            RtlReleaseActivationContext(ActivationContextInfo.ActivationContext);

        if (!NT_SUCCESS(Status)) {
             //
             // A second release is needed because we activated the activation context
             // on the new thread but we did not succeed in completing creation of the
             // thread. Had the thread been created, it would have deactivated the
             // activation context upon exit (RtlFreeThreadActivationContextStack).
             // This extra addref/releasing is triggered
             // by the flags ACTIVATE_ACTIVATION_CONTEXT_FLAG_RELEASE_ON_STACK_DEALLOCATION
             // and ACTIVATION_CONTEXT_STACK_FRAME_RELEASE_ON_DEACTIVATION.
             //
             if (ActivationContextInfo.ActivationContext != NULL) {
                 RtlReleaseActivationContext(ActivationContextInfo.ActivationContext);
             }
            BaseFreeThreadStack(hProcess,
                                Handle,
                                &InitialTeb
                                );

            NtTerminateThread(Handle, Status);
            NtClose(Handle);
            BaseSetLastNTError(Status);
            Handle = NULL;
            }
        }


    return Handle;
}

NTSTATUS
NTAPI
BaseCreateThreadPoolThread(
    PUSER_THREAD_START_ROUTINE Function,
    PVOID Parameter,
    HANDLE * ThreadHandleReturn
    )
{
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL);
    __try {
        *ThreadHandleReturn
            = CreateRemoteThread(
                NtCurrentProcess(),
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) Function,
                Parameter,
                CREATE_SUSPENDED,
                NULL);

        if (*ThreadHandleReturn) {
            Status = STATUS_SUCCESS;
        } else {
            Status = NtCurrentTeb()->LastStatusValue;

            if (NT_SUCCESS(Status)) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return Status;
}

NTSTATUS
NTAPI
BaseExitThreadPoolThread(
    NTSTATUS Status
    )
{
    ExitThread( (DWORD) Status );
    return STATUS_SUCCESS ;
}

HANDLE
WINAPI
OpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    )

/*++

Routine Description:

    A handle to a thread object may be created using OpenThread.

    Opening a thread creates a handle to the specified thread.
    Associated with the thread handle is a set of access rights that
    may be performed using the thread handle.  The caller specifies the
    desired access to the thread using the DesiredAccess parameter.

Arguments:

    mDesiredAccess - Supplies the desired access to the thread object.
        For NT/Win32, this access is checked against any security
        descriptor on the target thread.  The following object type
        specific access flags can be specified in addition to the
        STANDARD_RIGHTS_REQUIRED access flags.

        DesiredAccess Flags:

        THREAD_TERMINATE - This access is required to terminate the
            thread using TerminateThread.

        THREAD_SUSPEND_RESUME - This access is required to suspend and
            resume the thread using SuspendThread and ResumeThread.

        THREAD_GET_CONTEXT - This access is required to use the
            GetThreadContext API on a thread object.

        THREAD_SET_CONTEXT - This access is required to use the
            SetThreadContext API on a thread object.

        THREAD_SET_INFORMATION - This access is required to set certain
            information in the thread object.

        THREAD_SET_THREAD_TOKEN - This access is required to set the
            thread token using SetTokenInformation.

        THREAD_QUERY_INFORMATION - This access is required to read
            certain information from the thread object.

        SYNCHRONIZE - This access is required to wait on a thread object.

        THREAD_ALL_ACCESS - This set of access flags specifies all of the
            possible access flags for a thread object.

    bInheritHandle - Supplies a flag that indicates whether or not the
        returned handle is to be inherited by a new process during
        process creation.  A value of TRUE indicates that the new
        process will inherit the handle.

    dwThreadId - Supplies the thread id of the thread to open.

Return Value:

    NON-NULL - Returns an open handle to the specified thread.  The
        handle may be used by the calling process in any API that
        requires a handle to a thread.  If the open is successful, the
        handle is granted access to the thread object only to the
        extent that it requested access through the DesiredAccess
        parameter.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = (HANDLE)LongToHandle(dwThreadId);
    ClientId.UniqueProcess = (HANDLE)NULL;

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenThread(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}


BOOL
APIENTRY
SetThreadPriority(
    HANDLE hThread,
    int nPriority
    )

/*++

Routine Description:

    The specified thread's priority can be set using SetThreadPriority.

    A thread's priority may be set using SetThreadPriority.  This call
    allows the thread's relative execution importance to be communicated
    to the system.  The system normally schedules threads according to
    their priority.  The system is free to temporarily boost the
    priority of a thread when signifigant events occur (e.g.  keyboard
    or mouse input...).  Similarly, as a thread runs without blocking,
    the system will decay its priority.  The system will never decay the
    priority below the value set by this call.

    In the absence of system originated priority boosts, threads will be
    scheduled in a round-robin fashion at each priority level from
    THREAD_PRIORITY_TIME_CRITICAL to THREAD_PRIORITY_IDLE.  Only when there
    are no runnable threads at a higher level, will scheduling of
    threads at a lower level take place.

    All threads initially start at THREAD_PRIORITY_NORMAL.

    If for some reason the thread needs more priority, it can be
    switched to THREAD_PRIORITY_ABOVE_NORMAL or THREAD_PRIORITY_HIGHEST.
    Switching to THREAD_PRIORITY_TIME_CRITICAL should only be done in extreme
    situations.  Since these threads are given the highes priority, they
    should only run in short bursts.  Running for long durations will
    soak up the systems processing bandwidth starving threads at lower
    levels.

    If a thread needs to do low priority work, or should only run there
    is nothing else to do, its priority should be set to
    THREAD_PRIORITY_BELOW_NORMAL or THREAD_PRIORITY_LOWEST.  For extreme
    cases, THREAD_PRIORITY_IDLE can be used.

    Care must be taken when manipulating priorites.  If priorities are
    used carelessly (every thread is set to THREAD_PRIORITY_TIME_CRITICAL),
    the effects of priority modifications can produce undesireable
    effects (e.g.  starvation, no effect...).

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    nPriority - Supplies the priority value for the thread.  The
        following five priority values (ordered from lowest priority to
        highest priority) are allowed.

        nPriority Values:

        THREAD_PRIORITY_IDLE - The thread's priority should be set to
            the lowest possible settable priority.

        THREAD_PRIORITY_LOWEST - The thread's priority should be set to
            the next lowest possible settable priority.

        THREAD_PRIORITY_BELOW_NORMAL - The thread's priority should be
            set to just below normal.

        THREAD_PRIORITY_NORMAL - The thread's priority should be set to
            the normal priority value.  This is the value that all
            threads begin execution at.

        THREAD_PRIORITY_ABOVE_NORMAL - The thread's priority should be
            set to just above normal priority.

        THREAD_PRIORITY_HIGHEST - The thread's priority should be set to
            the next highest possible settable priority.

        THREAD_PRIORITY_TIME_CRITICAL - The thread's priority should be set
            to the highest possible settable priority.  This priority is
            very likely to interfere with normal operation of the
            system.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    NTSTATUS Status;
    LONG BasePriority;

    BasePriority = (LONG)nPriority;


    //
    // saturation is indicated by calling with a value of 16 or -16
    //

    if ( BasePriority == THREAD_PRIORITY_TIME_CRITICAL ) {
        BasePriority = ((HIGH_PRIORITY + 1) / 2);
        }
    else if ( BasePriority == THREAD_PRIORITY_IDLE ) {
        BasePriority = -((HIGH_PRIORITY + 1) / 2);
        }
    Status = NtSetInformationThread(
                hThread,
                ThreadBasePriority,
                &BasePriority,
                sizeof(BasePriority)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;
}

int
APIENTRY
GetThreadPriority(
    HANDLE hThread
    )

/*++

Routine Description:

    The specified thread's priority can be read using GetThreadPriority.

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

Return Value:

    The value of the thread's current priority is returned.  If an error
    occured, the value THREAD_PRIORITY_ERROR_RETURN is returned.
    Extended error status is available using GetLastError.

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION BasicInfo;
    int returnvalue;

    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (int)THREAD_PRIORITY_ERROR_RETURN;
        }

    returnvalue = (int)BasicInfo.BasePriority;
    if ( returnvalue == ((HIGH_PRIORITY + 1) / 2) ) {
        returnvalue = THREAD_PRIORITY_TIME_CRITICAL;
        }
    else if ( returnvalue == -((HIGH_PRIORITY + 1) / 2) ) {
        returnvalue = THREAD_PRIORITY_IDLE;
        }
    return returnvalue;
}

BOOL
WINAPI
SetThreadPriorityBoost(
    HANDLE hThread,
    BOOL bDisablePriorityBoost
    )
{
    NTSTATUS Status;
    ULONG DisableBoost;

    DisableBoost = bDisablePriorityBoost ? 1 : 0;

    Status = NtSetInformationThread(
                hThread,
                ThreadPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;

}

BOOL
WINAPI
GetThreadPriorityBoost(
    HANDLE hThread,
    PBOOL pDisablePriorityBoost
    )
{
    NTSTATUS Status;
    DWORD DisableBoost;

    Status = NtQueryInformationThread(
                hThread,
                ThreadPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }


    *pDisablePriorityBoost = DisableBoost;

    return TRUE;
}

VOID
APIENTRY
ExitThread(
    DWORD dwExitCode
    )

/*++

Routine Description:

    The current thread can exit using ExitThread.

    ExitThread is the prefered method of exiting a thread.  When this
    API is called (either explicitly or by returning from a thread
    procedure), The current thread's stack is deallocated and the thread
    terminates.  If the thread is the last thread in the process when
    this API is called, the behavior of this API does not change.  DLLs
    are not notified as a result of a call to ExitThread.

Arguments:

    dwExitCode - Supplies the termination status for the thread.

Return Value:

    None.

--*/

{
    MEMORY_BASIC_INFORMATION MemInfo;
    NTSTATUS st;
    ULONG LastThread;
    PTEB Teb;

#if DBG
    PRTL_CRITICAL_SECTION LoaderLock;
#endif

    Teb = NtCurrentTeb();

#if DBG

    //
    // Assert on exiting while holding loader lock
    //
    LoaderLock = NtCurrentPeb()->LoaderLock;
    if (LoaderLock) {
        ASSERT(Teb->ClientId.UniqueThread != LoaderLock->OwningThread);
    }
#endif
    st = NtQueryInformationThread(
            NtCurrentThread(),
            ThreadAmILastThread,
            &LastThread,
            sizeof(LastThread),
            NULL
            );
    if ( st == STATUS_SUCCESS && LastThread ) {
        ExitProcess(dwExitCode);
    } else {
        
        RtlFreeThreadActivationContextStack();
        LdrShutdownThread();
        if (Teb->TlsExpansionSlots) {
            //
            // Serialize with TlsXXX functions so the kernel code that zero's tls slots
            // wont' trash heap
            //
            RtlAcquirePebLock();
            try {
                RtlFreeHeap(RtlProcessHeap(),0,Teb->TlsExpansionSlots);
                Teb->TlsExpansionSlots = NULL;
            } finally {
                RtlReleasePebLock();
            }
        }

        Teb->FreeStackOnTermination = TRUE;
        NtTerminateThread (NULL, (NTSTATUS)dwExitCode);
        ExitProcess(dwExitCode);
    }
}



BOOL
APIENTRY
TerminateThread(
    HANDLE hThread,
    DWORD dwExitCode
    )

/*++

Routine Description:

    A thread may be terminated using TerminateThread.

    TerminateThread is used to cause a thread to terminate user-mode
    execution.  There is nothing a thread can to to predict or prevent
    when this occurs.  If a process has a handle with appropriate
    termination access to the thread or to the threads process, then the
    thread can be unconditionally terminated without notice.  When this
    occurs, the target thread has no chance to execute any user-mode
    code and its initial stack is not deallocated.  The thread attains a
    state of signaled satisfying any waits on the thread.  The thread's
    termination status is updated from its initial value of
    STATUS_PENDING to the value of the TerminationStatus parameter.
    Terminating a thread does not remove a thread from the system.  The
    thread is not removed from the system until the last handle to the
    thread is closed.

Arguments:

    hThread - Supplies a handle to the thread to terminate.  The handle
        must have been created with THREAD_TERMINATE access.

    dwExitCode - Supplies the termination status for the thread.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;

#if DBG
    PRTL_CRITICAL_SECTION LoaderLock;
    HANDLE ThreadId;
    THREAD_BASIC_INFORMATION ThreadInfo;
#endif

    if ( hThread == NULL ) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
        }

    //
    // Assert on suicide while holding loader lock
    //

#if DBG
    LoaderLock = NtCurrentPeb()->LoaderLock;
    if (LoaderLock) {
        Status = NtQueryInformationThread(
                                hThread,
                                ThreadBasicInformation,
                                &ThreadInfo,
                                sizeof(ThreadInfo),
                                NULL
                                );

        if (NT_SUCCESS(Status)) {
            ASSERT( NtCurrentTeb()->ClientId.UniqueThread != ThreadInfo.ClientId.UniqueThread ||
                    NtCurrentTeb()->ClientId.UniqueThread != LoaderLock->OwningThread);
            }
        }
#endif

    Status = NtTerminateThread(hThread,(NTSTATUS)dwExitCode);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
APIENTRY
GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    )

/*++

Routine Description:

    The termination status of a thread can be read using
    GetExitCodeThread.

    If a Thread is in the signaled state, calling this function returns
    the termination status of the thread.  If the thread is not yet
    signaled, the termination status returned is STILL_ACTIVE.

Arguments:

    hThread - Supplies a handle to the thread whose termination status is
        to be read.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

    lpExitCode - Returns the current termination status of the
        thread.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION BasicInformation;

    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        *lpExitCode = BasicInformation.ExitStatus;
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

HANDLE
APIENTRY
GetCurrentThread(
    VOID
    )

/*++

Routine Description:

    A pseudo handle to the current thread may be retrieved using
    GetCurrentThread.

    A special constant is exported by Win32 that is interpreted as a
    handle to the current thread.  This handle may be used to specify
    the current thread whenever a thread handle is required.  On Win32,
    this handle has THREAD_ALL_ACCESS to the current thread.  On
    NT/Win32, this handle has the maximum access allowed by any security
    descriptor placed on the current thread.

Arguments:

    None.

Return Value:

    Returns the pseudo handle of the current thread.

--*/

{
    return NtCurrentThread();
}

DWORD
APIENTRY
GetCurrentThreadId(
    VOID
    )

/*++

Routine Description:

The thread ID of the current thread may be retrieved using
GetCurrentThreadId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the thread ID of the currently
    executing thread.  The return value may be used to identify a thread
    in the system.

--*/

{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);
}

BOOL
APIENTRY
GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    )

/*++

Routine Description:

    The context of a specified thread can be retreived using
    GetThreadContext.

    This function is used to retreive the context of the specified
    thread.  The API allows selective context to be retrieved based on
    the value of the ContextFlags field of the context structure.  The
    specified thread does not have to be being debugged in order for
    this API to operate.  The caller must simply have a handle to the
    thread that was created with THREAD_GET_CONTEXT access.

Arguments:

    hThread - Supplies an open handle to a thread whose context is to be
        retreived.  The handle must have been created with
        THREAD_GET_CONTEXT access to the thread.

    lpContext - Supplies the address of a context structure that
        receives the appropriate context of the specified thread.  The
        value of the ContextFlags field of this structure specifies
        which portions of a threads context are to be retreived.  The
        context structure is highly machine specific.  There are
        currently two versions of the context structure.  One version
        exists for x86 processors, and another exists for MIPS
        processors.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;

    Status = NtGetContextThread(hThread,lpContext);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOL
APIENTRY
SetThreadContext(
    HANDLE hThread,
    CONST CONTEXT *lpContext
    )

/*++

Routine Description:

    This function is used to set the context in the specified thread.
    The API allows selective context to be set based on the value of the
    ContextFlags field of the context structure.  The specified thread
    does not have to be being debugged in order for this API to operate.
    The caller must simply have a handle to the thread that was created
    with THREAD_SET_CONTEXT access.

Arguments:

    hThread - Supplies an open handle to a thread whose context is to be
        written.  The handle must have been created with
        THREAD_SET_CONTEXT access to the thread.

    lpContext - Supplies the address of a context structure that
        contains the context that is to be set in the specified thread.
        The value of the ContextFlags field of this structure specifies
        which portions of a threads context are to be set.  Some values
        in the context structure are not settable and are silently set
        to the correct value.  This includes cpu status register bits
        that specify the priviledged processor mode, debug register
        global enabling bits, and other state that must be completely
        controlled by the operating system.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetContextThread(hThread,(PCONTEXT)lpContext);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

DWORD
APIENTRY
SuspendThread(
    HANDLE hThread
    )

/*++

Routine Description:

    A thread can be suspended using SuspendThread.

    Suspending a thread causes the thread to stop executing user-mode
    (or application) code.  Each thread has a suspend count (with a
    maximum value of MAXIMUM_SUSPEND_COUNT).  If the suspend count is
    greater than zero, the thread is suspended; otherwise, the thread is
    not suspended and is eligible for execution.

    Calling SuspendThread causes the target thread's suspend count to
    increment.  Attempting to increment past the maximum suspend count
    causes an error without incrementing the count.

Arguments:

    hThread - Supplies a handle to the thread that is to be suspended.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
         GetLastError.

    Other - The target thread was suspended. The return value is the thread's
        previous suspend count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtSuspendThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

DWORD
APIENTRY
ResumeThread(
    IN HANDLE hThread
    )

/*++

Routine Description:

    A thread can be resumed using ResumeThread.

    Resuming a thread object checks the suspend count of the subject
    thread.  If the suspend count is zero, then the thread is not
    currently suspended and no operation is performed.  Otherwise, the
    subject thread's suspend count is decremented.  If the resultant
    value is zero , then the execution of the subject thread is resumed.

    The previous suspend count is returned as the function value.  If
    the return value is zero, then the subject thread was not previously
    suspended.  If the return value is one, then the subject thread's
    the subject thread is still suspended and must be resumed the number
    of times specified by the return value minus one before it will
    actually resume execution.

    Note that while reporting debug events, all threads withing the
    reporting process are frozen.  This has nothing to do with
    SuspendThread or ResumeThread.  Debuggers are expected to use
    SuspendThread and ResumeThread to limit the set of threads that can
    execute within a process.  By suspending all threads in a process
    except for the one reporting a debug event, it is possible to
    "single step" a single thread.  The other threads will not be
    released by a continue if they are suspended.

Arguments:

    hThread - Supplies a handle to the thread that is to be resumed.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
        GetLastError.

    Other - The target thread was resumed (or was not previously
        suspended).  The return value is the thread's previous suspend
        count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtResumeThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

VOID
APIENTRY
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST ULONG_PTR *lpArguments
    )

/*++

Routine Description:

    Raising an exception causes the exception dispatcher to go through
    its search for an exception handler.  This includes debugger
    notification, frame based handler searching, and system default
    actions.

Arguments:

    dwExceptionCode - Supplies the exception code of the exception being
        raised.  This value may be obtained in exception filters and in
        exception handlers by calling GetExceptionCode.

    dwExceptionFlags - Supplies a set of flags associated with the exception.

    dwExceptionFlags Flags:

        EXCEPTION_NONCONTINUABLE - The exception is non-continuable.
            Returning EXCEPTION_CONTINUE_EXECUTION from an exception
            marked in this way causes the
            STATUS_NONCONTINUABLE_EXCEPTION exception.

    nNumberOfArguments - Supplies the number of arguments associated
        with the exception.  This value may not exceed
        EXCEPTION_MAXIMUM_PARAMETERS.  This parameter is ignored if
        lpArguments is NULL.

    lpArguments - An optional parameter, that if present supplies the
        arguments for the exception.

Return Value:

    None.

--*/

{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG_PTR s,d;
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = (PVOID)RaiseException;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG_PTR)lpArguments;
        d = ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }
    RtlRaiseException(&ExceptionRecord);
}


UINT
GetErrorMode();

BOOLEAN BasepAlreadyHadHardError = FALSE;

LPTOP_LEVEL_EXCEPTION_FILTER BasepCurrentTopLevelFilter;

LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    )

/*++

Routine Description:

    This function allows an application to supersede the top level
    exception handler that Win32 places at the top of each thread and
    process.

    If an exception occurs, and it makes it to the Win32 unhandled
    exception filter, and the process is not being debugged, the Win32
    filter will call the unhandled exception filter specified by
    lpTopLevelExceptionFilter.

    This filter may return:

        EXCEPTION_EXECUTE_HANDLER - Return from the Win32
            UnhandledExceptionFilter and execute the associated
            exception handler.  This will usually result in process
            termination

        EXCEPTION_CONTINUE_EXECUTION - Return from the Win32
            UnhandledExceptionFilter and continue execution from the
            point of the exception.  The filter is of course free to
            modify the continuation state my modifying the passed
            exception information.

        EXCEPTION_CONTINUE_SEARCH - Proceed with normal execution of the
            Win32 UnhandledExceptionFilter.  e.g.  obey the SetErrorMode
            flags, or invoke the Application Error popup.

    This function is not a general vectored exception handling
    mechanism.  It is intended to be used to establish a per-process
    exception filter that can monitor unhandled exceptions at the
    process level and respond to these exceptions appropriately.

Arguments:

    lpTopLevelExceptionFilter - Supplies the address of a top level
        filter function that will be called whenever the Win32
        UnhandledExceptionFilter gets control, and the process is NOT
        being debugged.  A value of NULL specifies default handling
        within the Win32 UnhandledExceptionFilter.


Return Value:

    This function returns the address of the previous exception filter
    established with this API.  A value of NULL means that there is no
    current top level handler.

--*/

{
    LPTOP_LEVEL_EXCEPTION_FILTER PreviousTopLevelFilter;

    PreviousTopLevelFilter = BasepCurrentTopLevelFilter;
    BasepCurrentTopLevelFilter = lpTopLevelExceptionFilter;

    return PreviousTopLevelFilter;
}

LONG
BasepCheckForReadOnlyResource(
    PVOID Va
    )
{
    SIZE_T RegionSize;
    ULONG OldProtect;
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemInfo;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    ULONG ResourceSize;
    char *rbase, *va;
    LONG ReturnValue;

    //
    // Locate the base address that continas this va
    //

    Status = NtQueryVirtualMemory(
                NtCurrentProcess(),
                Va,
                MemoryBasicInformation,
                (PVOID)&MemInfo,
                sizeof(MemInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return EXCEPTION_CONTINUE_SEARCH;
        }

    //
    // if the va is readonly and in an image then continue
    //

    if ( !((MemInfo.Protect == PAGE_READONLY) && (MemInfo.Type == MEM_IMAGE)) ){
        return EXCEPTION_CONTINUE_SEARCH;
        }

    ReturnValue = EXCEPTION_CONTINUE_SEARCH;

    try {
        ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData(MemInfo.AllocationBase,
                                         TRUE,
                                         IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                         &ResourceSize
                                         );

        rbase = (char *)ResourceDirectory;
        va = (char *)Va;

        if ( rbase && va >= rbase && va < rbase+ResourceSize ) {
            RegionSize = 1;
            Status = NtProtectVirtualMemory(
                        NtCurrentProcess(),
                        &va,
                        &RegionSize,
                        PAGE_READWRITE,
                        &OldProtect
                        );
            if ( NT_SUCCESS(Status) ) {
                ReturnValue = EXCEPTION_CONTINUE_EXECUTION;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ;
        }

    return ReturnValue;
}

// 
// Used for fault reporting in UnhandledExceptionFilter
//
static CHAR *StrStrIA(const CHAR *cs1, const CHAR *cs2)
{
    CHAR *cp = (CHAR *)cs1;
    CHAR *s1, *s2;

    while (*cp != '\0')
    {
        s1 = cp;
        s2 = (CHAR *)cs2;

        while (*s1 != '\0' && *s2 !='\0' && (tolower(*s1) - tolower(*s2)) == 0)
            s1++, s2++;

        if (*s2 == '\0')
             return(cp);

        cp++;
    }

    return(NULL);
}


#if 0
//#ifdef _X86_

LPVOID g_pvStack = NULL;
// need to turn this warning off due to the fact that we jump directly to
//  a function in the assembly below.
#pragma warning(disable : 4414)

// define the new stack size to be 0.5MB
#define NEWSTACKSIZE 128 * 4096

LONG UnhandledExceptionFilterEx(struct _EXCEPTION_POINTERS *ExceptionInfo);

// In the case of x86, use this wrapper function to detect if we've hit a 
//  stack overflow or not.  If we have, it's possibly that we'll AV at some
//  point in this function due to growing the stack out of the last stack
//  page.  So we want to work around it by allocating a new stack and using
//  that for the exception filter.
// Need to use __declspec(naked) to make sure that the compiler doesn't start
//  pushing stuff onto the stack in the fn prologue
__declspec(naked) LONG
UnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    _asm
    {
        // if it isn't a stack overflow exception, we don't have to worry about
        //  using stack space.  Need to use a jmp call here because I can't use 
        //  'return' in a naked function & I want to use as little stack space 
        //  as possible.  The jmp means that UnhandledExceptionFilterEx will take
        //  care of cleaning up the stack.
        // if (ExceptionInfo->ExceptionRecord->ExceptionCode != EXCEPTION_STACK_OVERFLOW)
        //     goto UnhandledExceptionFilterEx
        mov  eax, [esp+4]
        mov  ecx, [eax]
        cmp  dword ptr [ecx], 0xC00000FD	
        jne  UnhandledExceptionFilterEx

        // allocate the new stack
        // pvStack = VirtualAlloc(NULL, NEWSTACKSIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        push PAGE_READWRITE            // Protection
        push MEM_RESERVE | MEM_COMMIT  // Allocation
        push NEWSTACKSIZE              // Size
        push 0                         // Address
        call dword ptr [VirtualAlloc]

        // if the call to VirtualAlloc failed, we can't do much else.  Just let
        //  the filter take over & possibly fail.  
        // if (pvStack == NULL)
        //	    UnhandledExceptionFilterEx();
        test eax, eax
        jz   UnhandledExceptionFilterEx

        // Stack grows top down, so set the top of the stack appropriately
        // g_pvStack += NEWSTACKSIZE;
        lea  eax, [eax+NEWSTACKSIZE]

        // @edx = pExceptionInfo
        mov  edx, [esp+4]

        // Push old esp on new stack; point stack pointer to new stack
        mov  [eax-4], esp
        mov  [eax-8], esi
        mov  esi, eax
        lea  esp, [eax-16]

        // GeneralUnhandledExceptionFilterEx(pExceptionInfo);
        push edx
        call UnhandledExceptionFilterEx

        // Reset the old stack pointer
        mov  edx, esi
        mov  esi, [edx-8]
        mov  esp, [edx-4]

        // We need to now free up the memory we allocated above.  It's necessary
        //  to free it up because the app could have registered a global 
        //  exception filter & it could have done some magic to let the process
        //  remain alive.  If we knew we were terminating now, we could just 
        //  let it go and have the system take care of it, but we don't so we
        //  can't.

        // we need to return the result of UnhandledExceptionFilterEx which is 
        //  currently in @eax.  However, VirtualFree will trash @eax so we 
        //  gotta save it.  Use the 4 bytes on the stack where pExceptionInfo
        //  parameter is sitting to store @eax.  We don't need that value 
        //  anymore and we're going to reclaim that space anyway at the end of 
        //  this fn.
        mov  [esp+4], eax

        // g_pvStack -= NEWSTACKSIZE
        lea  eax, [edx-NEWSTACKSIZE]

        // VirtualFree(pStack, 0, MEM_DECOMMIT | MEM_RELEASE);
        push MEM_RELEASE
        push 0
        push eax
        call dword ptr [VirtualFree]

        // move the result of the call to UnhandledExceptionFilterEx back into
        //  @eax
        mov  eax, [esp+4]

        // pop 4 bytes off the stack cuz that's what the calling function
        //  pushed on
        ret  4
    }
}

#pragma warning(default : 4414)

//  The real exception filter that we call after munging the stack
LONG
UnhandledExceptionFilterEx(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
#else 
LONG
UnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
#endif
{
    EFaultRepRetVal frrv = frrvErrNoDW;
    NTSTATUS Status;
    ULONG_PTR Parameters[ 4 ];
    ULONG Response;
    HANDLE DebugPort;
    CHAR AeDebuggerCmdLine[256];
    CHAR AeAutoDebugString[8];
    BOOLEAN AeAutoDebug;
    ULONG ResponseFlag;
    LONG FilterReturn;
    PRTL_CRITICAL_SECTION PebLockPointer;
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimit;

    //
    // If we take a write fault, then attempt to make the memory writable. If this
    // succeeds, then silently proceed.
    //

    if ( ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION
        && ExceptionInfo->ExceptionRecord->ExceptionInformation[0] ) {

        FilterReturn = BasepCheckForReadOnlyResource((PVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[1]);

        if ( FilterReturn == EXCEPTION_CONTINUE_EXECUTION ) {
            return FilterReturn;
            }
        }

    //
    // If the process is being debugged, just let the exception happen
    // so that the debugger can see it. This way the debugger can ignore
    // all first chance exceptions.
    //

    DebugPort = (HANDLE)NULL;
    Status = NtQueryInformationProcess(
                GetCurrentProcess(),
                ProcessDebugPort,
                (PVOID)&DebugPort,
                sizeof(DebugPort),
                NULL
                );

    if ( NT_SUCCESS(Status) && DebugPort ) {

        //
        // Output a verifier_stop message for certain exception codes
        // if app_verifier is enabled and process runs under debugger.
        //

        if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {

            static LONG NoMessageYet = 0;

            if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION) {

                if (InterlockedExchange(&NoMessageYet, 1) == 0) {

                    VERIFIER_STOP (APPLICATION_VERIFIER_ACCESS_VIOLATION | APPLICATION_VERIFIER_NO_BREAK,
                                   "access violation exception for current stack trace",
                                   ExceptionInfo->ExceptionRecord->ExceptionInformation[1],
                                   "Invalid address being accessed",
                                   ExceptionInfo->ExceptionRecord->ExceptionAddress,
                                   "Code performing invalid access",
                                   ExceptionInfo->ExceptionRecord, 
                                   ".exr (exception record)", 
                                   ExceptionInfo->ContextRecord, 
                                   ".cxr (context record)");
                }
            }
            
            if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_INVALID_HANDLE) {

                if (InterlockedExchange(&NoMessageYet, 1) == 0) {

                    VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_HANDLE | APPLICATION_VERIFIER_NO_BREAK,
                                   "invalid handle exception for current stack trace",
                                   0, NULL, 0, NULL, 0, NULL, 0, NULL);
                }
            }
        }


        //
        // Process is being debugged.
        // Return a code that specifies that the exception
        // processing is to continue
        //
        
        return EXCEPTION_CONTINUE_SEARCH;
    }

    if ( BasepCurrentTopLevelFilter ) {
        FilterReturn = (BasepCurrentTopLevelFilter)(ExceptionInfo);
        if ( FilterReturn == EXCEPTION_EXECUTE_HANDLER ||
             FilterReturn == EXCEPTION_CONTINUE_EXECUTION ) {
            return FilterReturn;
            }
        }

    if ( GetErrorMode() & SEM_NOGPFAULTERRORBOX ) {
        return EXCEPTION_EXECUTE_HANDLER;
        }

    //
    // See if the process's job has been programmed to NOGPFAULTERRORBOX
    //
    Status = NtQueryInformationJobObject(
                NULL,
                JobObjectBasicLimitInformation,
                &BasicLimit,
                sizeof(BasicLimit),
                NULL
                );
    if ( NT_SUCCESS(Status) && (BasicLimit.LimitFlags & JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION) ) {
        return EXCEPTION_EXECUTE_HANDLER;
        }

    //
    // The process is not being debugged, so do the hard error
    // popup.
    //

    Parameters[ 0 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionCode;
    Parameters[ 1 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress;

    //
    // For inpage i/o errors, juggle the real status code to overwrite the
    // read/write field
    //

    if ( ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_IN_PAGE_ERROR ) {
        Parameters[ 2 ] = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 2 ];
        }
    else {
        Parameters[ 2 ] = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 0 ];
        }

    Parameters[ 3 ] = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];

    //
    // See if a debugger has been programmed in. If so, use the
    // debugger specified. If not then there is no AE Cancel support
    // DEVL systems will default the debugger command line. Retail
    // systems will not.
    // Also, check to see if we need to report the exception up to anyone
    //

    ResponseFlag = OptionOk;
    AeAutoDebug = FALSE;

    //
    // If we are holding the PebLock, then the createprocess will fail
    // because a new thread will also need this lock. Avoid this by peeking
    // inside the PebLock and looking to see if we own it. If we do, then just allow
    // a regular popup.
    //

    PebLockPointer = NtCurrentPeb()->FastPebLock;

    if ( PebLockPointer->OwningThread != NtCurrentTeb()->ClientId.UniqueThread ) {
        
        PRTL_CRITICAL_SECTION   LoaderLockPointer;
        HMODULE                 hmodFaultRep = NULL;

        try {
            if ( GetProfileString(
                    "AeDebug",
                    "Debugger",
                    NULL,
                    AeDebuggerCmdLine,
                    sizeof(AeDebuggerCmdLine)-1
                    ) ) {
                ResponseFlag = OptionOkCancel;
                }

            if ( GetProfileString(
                    "AeDebug",
                    "Auto",
                    "0",
                    AeAutoDebugString,
                    sizeof(AeAutoDebugString)-1
                    ) ) {

                if ( !strcmp(AeAutoDebugString,"1") ) {
                    if ( ResponseFlag == OptionOkCancel ) {
                        AeAutoDebug = TRUE;
                        }
                    }
                }

            // 
            // Attempt to report the fault back to Microsoft.  ReportFault 
            //  will return the following:
            //  frrvErrNoDW:    Always show our own fault notification.
            // 
            //  frrvErrTimeout: see frrvOkHeadless
            //  frrvOkQueued:   see frrvOkHeadless
            //  frrvOkHeadless: If we need to ask whether to launch a debugger,
            //                   then we ask.  Otherwise, show nothing else.
            //
            //  frrvOk:         see frrvOkManifest
            //  frrvOkManifest: We're done.  Show nothing else.
            //
            //  frrvLaunchDebugger: Launch the configured debugger.
            //

            LoaderLockPointer = NtCurrentPeb()->LoaderLock;
            frrv = frrvErrNoDW;
            if ( BasepAlreadyHadHardError == FALSE &&
                 LoaderLockPointer->OwningThread != NtCurrentTeb()->ClientId.UniqueThread &&
                 ( AeAutoDebug == FALSE ||
                   StrStrIA(AeDebuggerCmdLine, "drwtsn32") != NULL ))
            {
                WCHAR wszDll[MAX_PATH];
                PVOID   pvLdrLockCookie;
                ULONG   ulLockState;

                wszDll[0] = 0;

                if (GetSystemDirectoryW(wszDll, sizeof(wszDll) / sizeof(WCHAR)))
                    wcscat(wszDll, L"\\faultrep.dll"); 
                else
                    wszDll[0] = 0;
 
                // make sure that no one else owns the loader lock because we
                //  could otherwise deadlock
                LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY, &ulLockState, 
                                  &pvLdrLockCookie);
                if (ulLockState == LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED) {
                    hmodFaultRep = LoadLibraryExW(wszDll, NULL, 0);
                    LdrUnlockLoaderLock(0, pvLdrLockCookie);
                }
                
                if (hmodFaultRep != NULL)
                {
                    pfn_REPORTFAULT  pfn;
                    DWORD            dwDebug;

                    // parameter 2 to ReportFault should be:
                    //  froNoDebugWait: don't display a debug button but wait 
                    //                   for DW to finish- this is a special 
                    //                   case to make sure DW is done before 
                    //                   Dr. Watson starts
                    //  froNoDebugWait : don't display a debug button
                    //  froDebug : display a debug button and wait for DW to 
                    //              finish
                    if (ResponseFlag == OptionOkCancel)
                        dwDebug = (AeAutoDebug) ? froNoDebugWait : froDebug;
                    else
                        dwDebug = froNoDebug;

                    pfn = (pfn_REPORTFAULT)GetProcAddress(hmodFaultRep, 
                                                          "ReportFault");
                    if (pfn != NULL)
                        frrv = (*pfn)(ExceptionInfo, dwDebug);

                    FreeLibrary(hmodFaultRep);
                    hmodFaultRep = NULL;
                }
            }

            // 
            // Since we're supposed to launch the debugger anyway, just set the 
            // AeAutoDebug flag to true to minimize code munging below
            //
            if ( frrv == frrvLaunchDebugger )
                AeAutoDebug = TRUE;

            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            ResponseFlag = OptionOk;
            AeAutoDebug = FALSE;
            frrv = frrvErrNoDW;
            if (hmodFaultRep != NULL)
                FreeLibrary(hmodFaultRep);
            }
        }

    // 
    // only display this dialog if we couldn't show DW & we're not set to 
    //  automatically launch a debugger.  The conditions here are:
    //  1.  cannot be directly launching a debugger (auto == 1)
    //  2a. DW must have failed to launch
    //      -or- 
    //      we needed to ask the user if he wanted to debug but could not (due
    //       to either no UI being shown or us not being able to wait long enuf
    //       to find out.)
    if ( !AeAutoDebug && 
         ( frrv == frrvErrNoDW || 
           ( ResponseFlag == OptionOkCancel && 
             ( frrv == frrvErrTimeout || frrv == frrvOkQueued || 
               frrv == frrvOkHeadless ) ) ) )
        {
        Status =NtRaiseHardError( STATUS_UNHANDLED_EXCEPTION | HARDERROR_OVERRIDE_ERRORMODE,
                                  4,
                                  0,
                                  Parameters,
                                  BasepAlreadyHadHardError ? OptionOk : ResponseFlag,
                                  &Response
                                );

        }
    else {
        Status = STATUS_SUCCESS;
        Response = (AeAutoDebug) ? ResponseCancel : ResponseOk;
        }

    //
    // Internally, send OkCancel. If we get back Ok then die.
    // If we get back Cancel, then enter the debugger
    //

    if ( NT_SUCCESS(Status) && Response == ResponseCancel && BasepAlreadyHadHardError == FALSE) {
        if ( !BaseRunningInServerProcess ) {
            BOOL b;
            STARTUPINFO StartupInfo;
            PROCESS_INFORMATION ProcessInformation;
            CHAR CmdLine[256];
            NTSTATUS Status;
            HANDLE EventHandle;
            SECURITY_ATTRIBUTES sa;
            HANDLE CurrentProcess;
            HANDLE CurrentThread;

            //
            // Duplicate the processes handle. We make it inheritable so the debugger will get a copy of it.
            // We do this to prevent the process ID from being reused if this process gets killed before the
            // attach occurs. Process ID are reused very quickly and attaching to the wrong process is
            // confusing.
            //
            if (!DuplicateHandle (GetCurrentProcess (),
                                  GetCurrentProcess (),
                                  GetCurrentProcess (),
                                  &CurrentProcess,
                                  0,
                                  TRUE,
                                  DUPLICATE_SAME_ACCESS)) {
                CurrentProcess = NULL;
            }

            if (!DuplicateHandle (GetCurrentProcess (),
                                  GetCurrentThread (),
                                  GetCurrentProcess (),
                                  &CurrentThread,
                                  0,
                                  TRUE,
                                  DUPLICATE_SAME_ACCESS)) {
                CurrentThread = NULL;
            }

            sa.nLength = sizeof(sa);
            sa.lpSecurityDescriptor = NULL;
            sa.bInheritHandle = TRUE;
            EventHandle = CreateEvent(&sa,TRUE,FALSE,NULL);
            RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
            sprintf(CmdLine,AeDebuggerCmdLine,GetCurrentProcessId(),EventHandle);
            StartupInfo.cb = sizeof(StartupInfo);
            StartupInfo.lpDesktop = "Winsta0\\Default";
            CsrIdentifyAlertableThread();
            b =  CreateProcess(
                    NULL,
                    CmdLine,
                    NULL,
                    NULL,
                    TRUE,
                    0,
                    NULL,
                    NULL,
                    &StartupInfo,
                    &ProcessInformation
                    );

            if (CurrentProcess != NULL) {
                CloseHandle (CurrentProcess);
            }
            if (CurrentThread != NULL) {
                CloseHandle (CurrentThread);
            }
            if ( b && EventHandle) {

                //
                // Do an alertable wait on the event
                //

                do {
                    HANDLE WaitHandles[2];

                    WaitHandles[0] = EventHandle;
                    WaitHandles[1] = ProcessInformation.hProcess;
                    Status = NtWaitForMultipleObjects (2,
                                                       WaitHandles,
                                                       WaitAny,
                                                       TRUE,
                                                       NULL);
                } while (Status == STATUS_USER_APC || Status == STATUS_ALERTED);

                //
                // If the debugger process died then see if the debugger is now
                // attached by another thread
                //
                if (Status == 1) {
                    Status = NtQueryInformationProcess (GetCurrentProcess(),
                                                        ProcessDebugPort,
                                                        &DebugPort,
                                                        sizeof (DebugPort),
                                                        NULL);
                    if (!NT_SUCCESS (Status) || DebugPort == NULL) {
                        BasepAlreadyHadHardError = TRUE;
                    }
                }
                CloseHandle (EventHandle);
                CloseHandle (ProcessInformation.hProcess);
                CloseHandle (ProcessInformation.hThread);

                return EXCEPTION_CONTINUE_SEARCH;
            }

        }
        BasepAlreadyHadHardError = TRUE;
    }

#if DBG
    if (!NT_SUCCESS( Status )) {
        DbgPrint( "BASEDLL: Unhandled exception: %lx  IP: %x\n",
                  ExceptionInfo->ExceptionRecord->ExceptionCode,
                  ExceptionInfo->ExceptionRecord->ExceptionAddress
                );
        }
#endif
    if ( BasepAlreadyHadHardError ) {
        NtTerminateProcess(NtCurrentProcess(),ExceptionInfo->ExceptionRecord->ExceptionCode);
        }
    return EXCEPTION_EXECUTE_HANDLER;
}



DWORD
APIENTRY
TlsAlloc(
    VOID
    )

/*++

Routine Description:

    A TLS index may be allocated using TlsAlloc.  Win32 garuntees a
    minimum number of TLS indexes are available in each process.  The
    constant TLS_MINIMUM_AVAILABLE defines the minimum number of
    available indexes.  This minimum is at least 64 for all Win32
    systems.

Arguments:

    None.

Return Value:

    Not-0xffffffff - Returns a TLS index that may be used in a
        subsequent call to TlsFree, TlsSetValue, or TlsGetValue.  The
        storage associated with the index is initialized to NULL.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    PPEB Peb;
    PTEB Teb;
    DWORD Index;

    Peb = NtCurrentPeb();
    Teb = NtCurrentTeb();

    RtlAcquirePebLock();
    try {

        Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsBitmap,1,0);
        if ( Index == 0xffffffff ) {
            Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsExpansionBitmap,1,0);
            if ( Index == 0xffffffff ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                }
            else {
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlClearBits((PRTL_BITMAP)Peb->TlsExpansionBitmap,Index,1);
                        Index = 0xffffffff;
                        BaseSetLastNTError(STATUS_NO_MEMORY);
                        return Index;
                        }
                    }
                Teb->TlsExpansionSlots[Index] = NULL;
                Index += TLS_MINIMUM_AVAILABLE;
                }
            }
        else {
            Teb->TlsSlots[Index] = NULL;
            }
        }
    finally {
        RtlReleasePebLock();
        }
    
    return Index;
}

LPVOID
APIENTRY
TlsGetValue(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    This function is used to retrive the value in the TLS storage
    associated with the specified index.

    If the index is valid this function clears the value returned by
    GetLastError(), and returns the value stored in the TLS slot
    associated with the specified index.  Otherwise a value of NULL is
    returned with GetLastError updated appropriately.

    It is expected, that DLLs will use TlsAlloc and TlsGetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

Return Value:

    NON-NULL - The function was successful. The value is the data stored
        in the TLS slot associated with the specified index.

    NULL - The operation failed, or the value associated with the
        specified index was NULL.  Extended error status is available
        using GetLastError.  If this returns non-zero, the index was
        invalid.

--*/
{
    PTEB Teb;
    LPVOID *Slot;

    Teb = NtCurrentTeb();

    if ( dwTlsIndex < TLS_MINIMUM_AVAILABLE ) {
        Slot = &Teb->TlsSlots[dwTlsIndex];
        Teb->LastErrorValue = 0;
        return *Slot;
        }
    else {
        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE+TLS_EXPANSION_SLOTS ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return NULL;
            }
        else {
            Teb->LastErrorValue = 0;
            if ( Teb->TlsExpansionSlots ) {
                return  Teb->TlsExpansionSlots[dwTlsIndex-TLS_MINIMUM_AVAILABLE];
                }
            else {
                return NULL;
                }
            }
        }
}

BOOL
APIENTRY
TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    )

/*++

Routine Description:

    This function is used to store a value in the TLS storage associated
    with the specified index.

    If the index is valid this function stores the value and returns
    TRUE. Otherwise a value of FALSE is returned.

    It is expected, that DLLs will use TlsAlloc and TlsSetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

    lpTlsValue - Supplies the value to be stored in the TLS Slot.

Return Value:

    TRUE - The function was successful. The value lpTlsValue was
        stored.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PTEB Teb;

    Teb = NtCurrentTeb();

    if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
        dwTlsIndex -= TLS_MINIMUM_AVAILABLE;
        if ( dwTlsIndex < TLS_EXPANSION_SLOTS ) {
            if ( !Teb->TlsExpansionSlots ) {
                RtlAcquirePebLock();
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlReleasePebLock();
                        BaseSetLastNTError(STATUS_NO_MEMORY);
                        return FALSE;
                        }
                    }
                RtlReleasePebLock();
                }
            Teb->TlsExpansionSlots[dwTlsIndex] = lpTlsValue;
            }
        else {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }
        }
    else {
        Teb->TlsSlots[dwTlsIndex] = lpTlsValue;
        }
    return TRUE;
}

BOOL
APIENTRY
TlsFree(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    A valid TLS index may be free'd using TlsFree.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  If the
        index is a valid index, it is released by this call and is made
        available for reuse.  DLLs should be carefull to release any
        per-thread data pointed to by all of their threads TLS slots
        before calling this function.  It is expected that DLLs will
        only call this function (if at ALL) during their process detach
        routine.

Return Value:

    TRUE - The operation was successful.  Calling TlsTranslateIndex with
        this index will fail.  TlsAlloc is free to reallocate this
        index.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PPEB Peb;
    BOOLEAN ValidIndex;
    PRTL_BITMAP TlsBitmap;
    NTSTATUS Status;
    DWORD Index2;

    Peb = NtCurrentPeb();

    RtlAcquirePebLock();
    try {

        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
            Index2 = dwTlsIndex - TLS_MINIMUM_AVAILABLE;
            if ( Index2 >= TLS_EXPANSION_SLOTS ) {
                ValidIndex = FALSE;
                }
            else {
                TlsBitmap = (PRTL_BITMAP)Peb->TlsExpansionBitmap;
                ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
                }
            }
        else {
            TlsBitmap = (PRTL_BITMAP)Peb->TlsBitmap;
            Index2 = dwTlsIndex;
            ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
            }
        if ( ValidIndex ) {

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadZeroTlsCell,
                        &dwTlsIndex,
                        sizeof(dwTlsIndex)
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
                }

            RtlClearBits(TlsBitmap,Index2,1);
            }
        else {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            }
        }
    finally {
        RtlReleasePebLock();
        }
    return ValidIndex;
}



BOOL
WINAPI
GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    )

/*++

Routine Description:

    This function is used to return various timing information about the
    thread specified by hThread.

    All times are in units of 100ns increments. For lpCreationTime and lpExitTime,
    the times are in terms of the SYSTEM time or GMT time.

Arguments:

    hThread - Supplies an open handle to the specified thread.  The
        handle must have been created with THREAD_QUERY_INFORMATION
        access.

    lpCreationTime - Returns a creation time of the thread.

    lpExitTime - Returns the exit time of a thread.  If the thread has
        not exited, this value is not defined.

    lpKernelTime - Returns the amount of time that this thread has
        executed in kernel-mode.

    lpUserTime - Returns the amount of time that this thread has
        executed in user-mode.


Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/


{
    NTSTATUS Status;
    KERNEL_USER_TIMES TimeInfo;

    Status = NtQueryInformationThread(
                hThread,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    *lpCreationTime = *(LPFILETIME)&TimeInfo.CreateTime;
    *lpExitTime = *(LPFILETIME)&TimeInfo.ExitTime;
    *lpKernelTime = *(LPFILETIME)&TimeInfo.KernelTime;
    *lpUserTime = *(LPFILETIME)&TimeInfo.UserTime;

    return TRUE;
}

BOOL
WINAPI
GetThreadIOPendingFlag(
    IN HANDLE hThread,
    OUT PBOOL lpIOIsPending
    )

/*++

Routine Description:

    This function is used to determine whether the thread in question
    has any IO requests pending.

Arguments:

    hThread - Specifies an open handle to the desired thread.  The
              handle must have been created with
              THREAD_QUERY_INFORMATION access.

    lpIOIsPending - Specifes the location to receive the flag.

Return Value:

    TRUE - The call was successful.

    FALSE - The call failed.  Extended error status is available
        using GetLastError().

--*/

{
    NTSTATUS Status;
    ULONG Pending;

    Status = NtQueryInformationThread(hThread,
                                      ThreadIsIoPending,
                                      &Pending,
                                      sizeof(Pending),
                                      NULL);
    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    *lpIOIsPending = (Pending ? TRUE : FALSE);
    return TRUE;
}

DWORD_PTR
WINAPI
SetThreadAffinityMask(
    HANDLE hThread,
    DWORD_PTR dwThreadAffinityMask
    )

/*++

Routine Description:

    This function is used to set the specified thread's processor
    affinity mask.  The thread affinity mask is a bit vector where each
    bit represents the processors that the thread is allowed to run on.
    The affinity mask MUST be a proper subset of the containing process'
    process level affinity mask.

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    dwThreadAffinityMask - Supplies the affinity mask to be used for the
        specified thread.

Return Value:

    non-0 - The API was successful.  The return value is the previous
        affinity mask for the thread.

    0 - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    THREAD_BASIC_INFORMATION BasicInformation;
    NTSTATUS Status;
    DWORD_PTR rv;
    DWORD_PTR LocalThreadAffinityMask;


    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        rv = 0;
        }
    else {
        LocalThreadAffinityMask = dwThreadAffinityMask;

        Status = NtSetInformationThread(
                    hThread,
                    ThreadAffinityMask,
                    &LocalThreadAffinityMask,
                    sizeof(LocalThreadAffinityMask)
                    );
        if ( !NT_SUCCESS(Status) ) {
            rv = 0;
            }
        else {
            rv = BasicInformation.AffinityMask;
            }
        }


    if ( !rv ) {
        BaseSetLastNTError(Status);
        }

    return rv;
}

VOID
BaseDispatchAPC(
    LPVOID lpApcArgument1,
    LPVOID lpApcArgument2,
    LPVOID lpApcArgument3
    )
{
    PAPCFUNC pfnAPC;
    ULONG_PTR dwData;
    PACTIVATION_CONTEXT ActivationContext;
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    pfnAPC = (PAPCFUNC) lpApcArgument1;
    dwData = (ULONG_PTR) lpApcArgument2;
    ActivationContext = (PACTIVATION_CONTEXT) lpApcArgument3;

    if (ActivationContext == INVALID_ACTIVATION_CONTEXT) {
        (*pfnAPC)(dwData);
    } else {
        RtlActivateActivationContextUnsafeFast(&ActivationFrame, ActivationContext);
        __try {
            (*pfnAPC)(dwData);
        } __finally {
            RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
            RtlReleaseActivationContext(ActivationContext);
        }
    }
}


WINBASEAPI
DWORD
WINAPI
QueueUserAPC(
    PAPCFUNC pfnAPC,
    HANDLE hThread,
    ULONG_PTR dwData
    )
/*++

Routine Description:

    This function is used to queue a user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait.

Arguments:

    pfnAPC - Supplies the address of the APC routine to execute when the
        APC fires.

    hHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    dwData - Supplies a DWORD passed to the APC

Return Value:

    TRUE - The operations was successful

    FALSE - The operation failed. GetLastError() is not defined.

--*/

{
    NTSTATUS Status;
    PVOID Argument1 = (PVOID) pfnAPC;
    PVOID Argument2 = (PVOID) dwData;
    PVOID Argument3 = NULL;
    ACTIVATION_CONTEXT_BASIC_INFORMATION acbi = { 0 };

    Status =
        RtlQueryInformationActivationContext(
            RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,
            NULL,
            0,
            ActivationContextBasicInformation,
            &acbi,
            sizeof(acbi),
            NULL);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("SXS: %s failing because RtlQueryInformationActivationContext() returned status %08lx\n", __FUNCTION__, Status);
        return FALSE;
    }

    Argument3 = acbi.ActivationContext;

    if (acbi.Flags & ACTIVATION_CONTEXT_FLAG_NO_INHERIT) {
        // We're not supposed to propogate the activation context; set it to a value to indicate such.
        Argument3 = INVALID_ACTIVATION_CONTEXT;
    }

    Status = NtQueueApcThread(
                hThread,
                &BaseDispatchAPC,
                Argument1,
                Argument2,
                Argument3
                );

    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }
    return 1;
}


DWORD
WINAPI
SetThreadIdealProcessor(
    HANDLE hThread,
    DWORD dwIdealProcessor
    )
{
    NTSTATUS Status;
    ULONG rv;

    Status = NtSetInformationThread(
                hThread,
                ThreadIdealProcessor,
                &dwIdealProcessor,
                sizeof(dwIdealProcessor)
                );
    if ( !NT_SUCCESS(Status) ) {
        rv = (DWORD)0xFFFFFFFF;
        BaseSetLastNTError(Status);
        }
    else {
        rv = (ULONG)Status;
        }

    return rv;
}

WINBASEAPI
LPVOID
WINAPI
CreateFiber(
    SIZE_T dwStackSize,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    )
/*++

Routine Description:

    This function creates a fiber that executing at lpStartAddress as soon
    as a thread is switched to it.

Arguments:

    dwStackSize    - Commit size of the stack
    lpStartAddress - Routine that the fiber will start running
    lpParameter    - Arbitrary context that is passed to the fiber

Return Value:

    LPVOID - Handle to the Fiber

--*/
{
    return CreateFiberEx (dwStackSize, // dwStackCommitSize
                          0,           // dwStackReserveSize
                          0,           // dwFlags
                          lpStartAddress,
                          lpParameter);
}

WINBASEAPI
LPVOID
WINAPI
CreateFiberEx(
    SIZE_T dwStackCommitSize,
    SIZE_T dwStackReserveSize,
    DWORD dwFlags,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    )
/*++

Routine Description:

    This function creates a fiber that executing at lpStartAddress as soon
    as a thread is switched to it.

Arguments:

    dwStackCommitSize  - Commit size of the stack
    dwStackReserveSize - Reserve size of the stack
    dwFlags            - Reserved for future use
    lpStartAddress     - Routine that the fiber will start running
    lpParameter        - Arbitrary context that is passed to the fiber

Return Value:

    LPVOID - Handle to the Fiber

--*/
{

    NTSTATUS Status;
    PFIBER Fiber;
    INITIAL_TEB InitialTeb;

    //
    //  Reserve these flags for later use
    //
    if (dwFlags != 0) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    Fiber = RtlAllocateHeap (RtlProcessHeap (), MAKE_TAG (TMP_TAG), sizeof (*Fiber));
    if (Fiber == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return Fiber;
    }

    Status = BaseCreateStack (NtCurrentProcess(),
                              dwStackCommitSize,
                              dwStackReserveSize,
                              &InitialTeb);

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        RtlFreeHeap (RtlProcessHeap(), 0, Fiber);
        return NULL;
    }

    Fiber->FiberData = lpParameter;
    Fiber->StackBase = InitialTeb.StackBase;
    Fiber->StackLimit = InitialTeb.StackLimit;
    Fiber->DeallocationStack = InitialTeb.StackAllocationBase;
    Fiber->ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)-1;
    Fiber->Wx86Tib = NULL;

#ifdef _IA64_

    Fiber->BStoreLimit = InitialTeb.BStoreLimit;
    Fiber->DeallocationBStore = (PVOID) ((ULONG_PTR)InitialTeb.StackBase +
                      ((ULONG_PTR)InitialTeb.StackBase - (ULONG_PTR)InitialTeb.StackAllocationBase));

#endif // _IA64_

    //
    // Create an initial context for the new fiber.
    //

    BaseInitializeContext (&Fiber->FiberContext,
                           lpParameter,
                           (PVOID)lpStartAddress,
                           InitialTeb.StackBase,
                           BaseContextTypeFiber);

    return Fiber;
}

WINBASEAPI
VOID
WINAPI
DeleteFiber(
    LPVOID lpFiber
    )
{
    SIZE_T dwStackSize;
    PFIBER Fiber = lpFiber;
    PTEB Teb;

    //
    // If the current fiber makes this call, then it's just a thread exit
    //
    Teb = NtCurrentTeb();
    if (Teb->NtTib.FiberData == Fiber) {
        //
        // Free the fiber data if there is some.
        //

        if (Teb->HasFiberData) {

            Fiber = Teb->NtTib.FiberData;    

            if (Fiber != NULL) {
                RtlFreeHeap(RtlProcessHeap(),0,Fiber);
            }
        }

        ExitThread(1);
    }

    dwStackSize = 0;

    NtFreeVirtualMemory (NtCurrentProcess(),
                         &Fiber->DeallocationStack,
                         &dwStackSize,
                         MEM_RELEASE);

#if defined (WX86)

    if (Fiber->Wx86Tib && Fiber->Wx86Tib->Size == sizeof(WX86TIB)) {
        PVOID BaseAddress = Fiber->Wx86Tib->DeallocationStack;

        dwStackSize = 0;

        NtFreeVirtualMemory (NtCurrentProcess(),
                             &BaseAddress,
                             &dwStackSize,
                             MEM_RELEASE);
    }
#endif

    RtlFreeHeap(RtlProcessHeap(),0,Fiber);
}


WINBASEAPI
LPVOID
WINAPI
ConvertThreadToFiber(
    LPVOID lpParameter
    )
{

    PFIBER Fiber;
    PTEB Teb;

    Fiber = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), sizeof(*Fiber) );
    if (Fiber == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return Fiber;
    }
    Teb = NtCurrentTeb();
    Fiber->FiberData = lpParameter;
    Fiber->StackBase = Teb->NtTib.StackBase;
    Fiber->StackLimit = Teb->NtTib.StackLimit;
    Fiber->DeallocationStack = Teb->DeallocationStack;
    Fiber->ExceptionList = Teb->NtTib.ExceptionList;

#ifdef _IA64_

    Fiber->BStoreLimit = Teb->BStoreLimit;
    Fiber->DeallocationBStore = Teb->DeallocationBStore;

#endif // _IA64_

    Fiber->Wx86Tib = NULL;
    Teb->NtTib.FiberData = Fiber;
    Teb->HasFiberData = TRUE;

    return Fiber;
}

WINBASEAPI
BOOL
WINAPI
ConvertFiberToThread(
    VOID
    )
{

    PFIBER Fiber;
    PTEB Teb;

    Teb = NtCurrentTeb();

    if (!Teb->HasFiberData) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Teb->HasFiberData = FALSE;

    Fiber = Teb->NtTib.FiberData;
    Teb->NtTib.FiberData = NULL;
    if (Fiber != NULL) {
        RtlFreeHeap (RtlProcessHeap (), 0, Fiber);
    }

    return TRUE;
}

BOOL
WINAPI
SwitchToThread(
    VOID
    )

/*++

Routine Description:

    This function causes a yield from the running thread to any other
    thread that is ready and can run on the current processor.  The
    yield will be effective for up to one quantum and then the yielding
    thread will be scheduled again according to its priority and
    whatever other threads may also be avaliable to run.  The thread
    that yields will not bounce to another processor even it another
    processor is idle or running a lower priority thread.

Arguments:

    None

Return Value:

    TRUE - Calling this function caused a switch to another thread to occur
    FALSE - There were no other ready threads, so no context switch occured

--*/

{

    if (NtYieldExecution() == STATUS_NO_YIELD_PERFORMED) {
        return FALSE;
    } else {
        return TRUE;
    }
}


BOOL
WINAPI
RegisterWaitForSingleObject(
    PHANDLE phNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
/*++

Routine Description:

    This function registers a wait for a particular object, with an optional
    timeout.  This differs from WaitForSingleObject because the wait is performed
    by a different thread that combines several such calls for efficiency.  The
    function supplied in Callback is called when the object is signalled, or the
    timeout expires.

Arguments:

    phNewWaitObject - pointer to new WaitObject returned by this function.

    hObject -   HANDLE to a Win32 kernel object (Event, Mutex, File, Process,
                Thread, etc.) that will be waited on.  Note:  if the object
                handle does not immediately return to the not-signalled state,
                e.g. an auto-reset event, then either WT_EXECUTEINWAITTHREAD or
                WT_EXECUTEONLYONCE should be specified.  Otherwise, the thread
                pool will continue to fire the callbacks. If WT_EXECUTEINWAITTHREAD
                is specified, the the object should be deregistered or reset in the
                callback.

    Callback -  Function that will be called when the object is signalled or the
                timer expires.

    Context -   Context that will be passed to the callback function.

    dwMilliseconds - timeout for the wait. Each time the timer is fired or the event
                is fired, the timer is reset (except if WT_EXECUTEONLYONCE is set).

    dwFlags -   Flags indicating options for this wait:
                WT_EXECUTEDEFAULT       - Default (0)
                WT_EXECUTEINIOTHREAD    - Select an I/O thread for execution
                WT_EXECUTEINUITHREAD    - Select a UI thread for execution
                WT_EXECUTEINWAITTHREAD  - Execute in the thread that handles waits
                WT_EXECUTEONLYONCE      - The callback function will be called only once
                WT_EXECUTELONGFUNCTION  - The Callback function can potentially block
                                          for a long time. Is valid only if
                                          WT_EXECUTEINWAITTHREAD flag is not set.
Return Value:

    FALSE - an error occurred, use GetLastError() for more information.

    TRUE - success.

--*/
{
    NTSTATUS Status ;
    PPEB Peb;

    *phNewWaitObject = NULL;
    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) )
    {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
    }

    if (CONSOLE_HANDLE(hObject) && VerifyConsoleIoHandle(hObject))
    {
        hObject = GetConsoleInputWaitHandle();
    }

    Status = RtlRegisterWait(
                phNewWaitObject,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                dwFlags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;

}


HANDLE
WINAPI
RegisterWaitForSingleObjectEx(
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
/*++

Routine Description:

    This function registers a wait for a particular object, with an optional
    timeout.  This differs from WaitForSingleObject because the wait is performed
    by a different thread that combines several such calls for efficiency.  The
    function supplied in Callback is called when the object is signalled, or the
    timeout expires.

Arguments:

    hObject -   HANDLE to a Win32 kernel object (Event, Mutex, File, Process,
                Thread, etc.) that will be waited on.  Note:  if the object
                handle does not immediately return to the not-signalled state,
                e.g. an auto-reset event, then either WT_EXECUTEINWAITTHREAD or
                WT_EXECUTEONLYONCE should be specified.  Otherwise, the thread
                pool will continue to fire the callbacks. If WT_EXECUTEINWAITTHREAD
                is specified, the the object should be deregistered or reset in the
                callback.

    Callback -  Function that will be called when the object is signalled or the
                timer expires.

    Context -   Context that will be passed to the callback function.

    dwMilliseconds - timeout for the wait. Each time the timer is fired or the event
                is fired, the timer is reset (except if WT_EXECUTEONLYONCE is set).

    dwFlags -   Flags indicating options for this wait:
                WT_EXECUTEDEFAULT       - Default (0)
                WT_EXECUTEINIOTHREAD    - Select an I/O thread for execution
                WT_EXECUTEINUITHREAD    - Select a UI thread for execution
                WT_EXECUTEINWAITTHREAD  - Execute in the thread that handles waits
                WT_EXECUTEONLYONCE      - The callback function will be called only once
                WT_EXECUTELONGFUNCTION  - The Callback function can potentially block
                                          for a long time. Is valid only if
                                          WT_EXECUTEINWAITTHREAD flag is not set.
Return Value:

    NULL - an error occurred, use GetLastError() for more information.

    non-NULL - a virtual handle that can be passed later to
               UnregisterWait

--*/
{
    HANDLE WaitHandle ;
    NTSTATUS Status ;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) )
    {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
    }

    if (CONSOLE_HANDLE(hObject) && VerifyConsoleIoHandle(hObject))
    {
        hObject = GetConsoleInputWaitHandle();
    }

    Status = RtlRegisterWait(
                &WaitHandle,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                dwFlags );

    if ( NT_SUCCESS( Status ) )
    {
        return WaitHandle ;
    }

    BaseSetLastNTError( Status );

    return NULL ;

}

BOOL
WINAPI
UnregisterWait(
    HANDLE WaitHandle
    )
/*++

Routine Description:

    This function cancels a wait for a particular object.
    All objects that were registered by the RtlWaitForSingleObject(Ex) call
    should be deregistered. This is a non-blocking call, and the associated
    callback function can still be executing after the return of this function.

Arguments:

    WaitHandle - Handle returned from RegisterWaitForSingleObject(Ex)

Return Value:

    TRUE - The wait was cancelled
    FALSE - an error occurred or a callback function was still executing,
            use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( WaitHandle )
    {
        Status = RtlDeregisterWait( WaitHandle );

        // set error if it is a non-blocking call and STATUS_PENDING was returned

        if ( Status == STATUS_PENDING  || !NT_SUCCESS( Status ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }

        return TRUE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}


BOOL
WINAPI
UnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent
    )
/*++

Routine Description:

    This function cancels a wait for a particular object.
    All objects that were registered by the RtlWaitForSingleObject(Ex) call
    should be deregistered.

Arguments:

    WaitHandle - Handle returned from RegisterWaitForSingleObject

    CompletionEvent - Handle to wait on for completion.
        NULL - NonBlocking call.
        INVALID_HANDLE_VALUE - Blocking call. Block till all Callback functions
                    associated with the WaitHandle have completed
        Event - NonBlocking call. The Object is deregistered. The Event is signalled
                    when the last callback function has completed execution.
Return Value:

    TRUE - The wait was cancelled
    FALSE - an error occurred or a callback was still executing,
            use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( WaitHandle )
    {
        Status = RtlDeregisterWaitEx( WaitHandle, CompletionEvent );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        
        if ( (CompletionEvent != INVALID_HANDLE_VALUE && Status == STATUS_PENDING)
            || ( ! NT_SUCCESS( Status ) ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
        
        return TRUE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}

BOOL
WINAPI
QueueUserWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PVOID Context,
    ULONG Flags
    )
/*++

Routine Description:

    This function queues a work item to a thread out of the thread pool.  The
    function passed is invoked in a different thread, and passed the Context
    pointer.  The caller can specify whether the thread pool should select
    a thread that can have I/O pending, or any thread.

Arguments:

    Function -  Function to call

    Context -   Pointer passed to the function when it is invoked.

    Flags   -
        - WT_EXECUTEINIOTHREAD
                Indictes to the thread pool that this thread will perform
                I/O.  A thread that starts an asynchronous I/O operation
                must wait for it to complete.  If a thread exits with
                outstanding I/O requests, those requests will be cancelled.
                This flag is a hint to the thread pool that this function
                will start I/O, so that a thread which can have pending I/O
                will be used.

        - WT_EXECUTELONGFUNCTION
                Indicates to the thread pool that the function might block
                for a long time.

Return Value:

    TRUE - The work item was queued to another thread.
    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    Status = RtlQueueWorkItem(
                (WORKERCALLBACKFUNC) Function,
                Context,
                Flags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}

BOOL
WINAPI
BindIoCompletionCallback (
    HANDLE FileHandle,
    LPOVERLAPPED_COMPLETION_ROUTINE Function,
    ULONG Flags
    )
/*++

Routine Description:

    This function binds the FileHandle opened for overlapped operations
    to the IO completion port associated with worker threads.

Arguments:

    FileHandle -  File Handle on which IO operations will be initiated.

    Function -    Function executed in a non-IO worker thread when the
                  IO operation completes.

    Flags   -     Currently set to 0. Not used.

Return Value:

    TRUE - The file handle was associated with the IO completion port.
    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    Status = RtlSetIoCompletionCallback(
                FileHandle,
                (APC_CALLBACK_FUNCTION) Function,
                Flags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}


//+---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   BasepCreateDefaultTimerQueue
//
//  Synopsis:   Creates the default timer queue for the process
//
//  Arguments:  (none)
//
//  History:    5-26-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
BasepCreateDefaultTimerQueue(
    VOID
    )
{
    NTSTATUS Status ;

    while ( 1 )
    {
        if ( !InterlockedExchange( &BasepTimerQueueInitFlag, 1 ) )
        {
            //
            // Force the done flag to 0.  If it was 1, so one already tried to
            // init and failed.
            //

            InterlockedExchange( &BasepTimerQueueDoneFlag, 0 );

            Status = RtlCreateTimerQueue( &BasepDefaultTimerQueue );

            if ( NT_SUCCESS( Status ) )
            {
                InterlockedIncrement( &BasepTimerQueueDoneFlag );

                return TRUE ;
            }

            //
            // This is awkward.  We aren't able to create a timer queue,
            // probably because of low memory.  We will fail this call, but decrement
            // the init flag, so that others can try again later.  Need to increment
            // the done flag, or any other threads would be stuck.
            //

            BaseSetLastNTError( Status );

            InterlockedIncrement( &BasepTimerQueueDoneFlag );

            InterlockedDecrement( &BasepTimerQueueInitFlag );

            return FALSE ;
        }
        else
        {
            LARGE_INTEGER TimeOut ;

            TimeOut.QuadPart = -1 * 10 * 10000 ;

            //
            // yield the quantum so that the other thread can
            // try to create the timer queue.
            //

            while ( !BasepTimerQueueDoneFlag )
            {
                NtDelayExecution( FALSE, &TimeOut );
            }

            //
            // Make sure it was created.  Otherwise, try it again (memory might have
            // freed up).  This way, every thread gets an individual chance to create
            // the queue if another thread failed.
            //

            if ( BasepDefaultTimerQueue )
            {
                return TRUE ;
            }

        }
    }
}

HANDLE
WINAPI
CreateTimerQueue(
    VOID
    )
/*++

Routine Description:

    This function creates a queue for timers.  Timers on a timer queue are
    lightweight objects that allow the caller to specify a function to
    be called at some point in the future.  Any number of timers can be
    created in a particular timer queue.

Arguments:

    None.

Return Value:

    non-NULL  - a timer queue handle that can be passed to SetTimerQueueTimer,
                ChangeTimerQueueTimer, CancelTimerQueueTimer, and
                DeleteTimerQueue.

    NULL - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;
    HANDLE Handle ;

    Status = RtlCreateTimerQueue( &Handle );

    if ( NT_SUCCESS( Status ) )
    {
        return Handle ;
    }

    BaseSetLastNTError( Status );

    return NULL ;

}


BOOL
WINAPI
CreateTimerQueueTimer(
    PHANDLE phNewTimer,
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    ULONG Flags
    )
/*++

Routine Description:

    This function creates a timer queue timer, a lightweight timer that
    will fire at the DueTime, and then every Period milliseconds afterwards.
    When the timer fires, the function passed in Callback will be invoked,
    and passed the Parameter pointer.

Arguments:

    phNewTimer - pointer to new timer handle

    TimerQueue - Timer Queue to attach this timer to.  NULL indicates that the
                 default process timer queue be used.

    Function -  Function to call

    Context -   Pointer passed to the function when it is invoked.

    DueTime -   Time from now that the timer should fire, expressed in
                milliseconds. If set to INFINITE, then it will never fire.
                If set to 0, then it will fire immediately.

    Period -    Time in between firings of this timer.
                If 0, then it is a one shot timer.

    Flags  -  by default the Callback function is queued to a non-IO worker thread.

            - WT_EXECUTEINIOTHREAD
                Indictes to the thread pool that this thread will perform
                I/O.  A thread that starts an asynchronous I/O operation
                must wait for it to complete.  If a thread exits with
                outstanding I/O requests, those requests will be cancelled.
                This flag is a hint to the thread pool that this function
                will start I/O, so that a thread with I/O already pending
                will be used.

            - WT_EXECUTEINTIMERTHREAD
                The callback function will be executed in the timer thread.

            - WT_EXECUTELONGFUNCTION
                Indicates that the function might block for a long time. Useful
                only if it is queued to a worker thread.

Return Value:

    TRUE -  no error

    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    *phNewTimer = NULL ;

    //
    // if the passed timer queue is NULL, use the default one.  If it is null,
    // call the initializer that will do it in a nice thread safe fashion.
    //

    if ( !TimerQueue )
    {
        if ( !BasepDefaultTimerQueue )
        {
            if ( !BasepCreateDefaultTimerQueue( ) )
            {
                return FALSE ;
            }
        }

        TimerQueue = BasepDefaultTimerQueue ;
    }

    Status = RtlCreateTimer(
                TimerQueue,
                phNewTimer,
                Callback,
                Parameter,
                DueTime,
                Period,
                Flags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;

}



BOOL
WINAPI
ChangeTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    ULONG DueTime,
    ULONG Period
    )
/*++

Routine Description:

    This function updates a timer queue timer created with SetTimerQueueTimer.

Arguments:

    TimerQueue - Timer Queue to attach this timer to.  NULL indicates the default
                 process timer queue.

    Timer -     Handle returned from SetTimerQueueTimer.

    DueTime -   Time from now that the timer should fire, expressed in
                milliseconds.

    Period -    Time in between firings of this timer. If set to 0, then it becomes
                a one shot timer.


Return Value:

    TRUE - the timer was changed

    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    //
    // Use the default timer queue if none was passed in.  If there isn't one, then
    // the process hasn't created one with SetTimerQueueTimer, and that's an error.
    //

    if ( !TimerQueue )
    {
        TimerQueue = BasepDefaultTimerQueue ;

        if ( !TimerQueue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );

            return FALSE ;
        }
    }

    Status = RtlUpdateTimer( TimerQueue,
                             Timer,
                             DueTime,
                             Period );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}


BOOL
WINAPI
DeleteTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    HANDLE CompletionEvent
    )
/*++

Routine Description:

    This function cancels a timer queue timer created with SetTimerQueueTimer.

Arguments:

    TimerQueue - Timer Queue that this timer was created on.

    Timer -     Handle returned from SetTimerQueueTimer.

    CompletionEvent -
            - NULL : NonBlocking call. returns immediately.
            - INVALID_HANDLE_VALUE : Blocking call. Returns after all callbacks have executed
            - Event (handle to an event) : NonBlocking call. Returns immediately.
                    Event signalled after all callbacks have executed.

Return Value:

    TRUE - the timer was cancelled.

    FALSE - an error occurred or the call is pending, use GetLastError()
            for more information.

--*/
{
    NTSTATUS Status ;

    //
    // Use the default timer queue if none was passed in.  If there isn't one, then
    // the process hasn't created one with SetTimerQueueTimer, and that's an error.
    //

    if ( !TimerQueue )
    {
        TimerQueue = BasepDefaultTimerQueue ;

        if ( !TimerQueue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );

            return FALSE ;
        }
    }

    Status = RtlDeleteTimer( TimerQueue, Timer, CompletionEvent );

    // set error if it is a non-blocking call and STATUS_PENDING was returned
    
    if ( (CompletionEvent != INVALID_HANDLE_VALUE && Status == STATUS_PENDING)
        || ( ! NT_SUCCESS( Status ) ) )
    {

        BaseSetLastNTError( Status );
        return FALSE;
    }
    
    return TRUE ;

}


BOOL
WINAPI
DeleteTimerQueueEx(
    HANDLE TimerQueue,
    HANDLE CompletionEvent
    )
/*++

Routine Description:

    This function deletes a timer queue created with CreateTimerQueue.
    Any pending timers on the timer queue are cancelled and deleted.

Arguments:

    TimerQueue - Timer Queue to delete.

    CompletionEvent -
            - NULL : NonBlocking call. returns immediately.
            - INVALID_HANDLE_VALUE : Blocking call. Returns after all callbacks
                    have executed
            - Event (handle to an event) : NonBlocking call. Returns immediately.
                    Event signalled after all callbacks have executed.

Return Value:

    TRUE - the timer queue was deleted.

    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( TimerQueue )
    {
        Status = RtlDeleteTimerQueueEx( TimerQueue, CompletionEvent );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        
        if ( (CompletionEvent != INVALID_HANDLE_VALUE && Status == STATUS_PENDING)
            || ( ! NT_SUCCESS( Status ) ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
       
        return TRUE ;

    }


    SetLastError( ERROR_INVALID_HANDLE );
    return FALSE ;
}

BOOL
WINAPI
ThreadPoolCleanup (
    ULONG Flags
    )
/*++

Routine Description:

    Called by terminating process for thread pool to cleanup and
    delete all its threads.

Arguments:

    Flags - currently not used

Return Value:

    NO_ERROR

--*/
{

    // RtlThreadPoolCleanup( Flags ) ;

    return TRUE ;
}


/*OBSOLETE FUNCTION - REPLACED BY CreateTimerQueueTimer */
HANDLE
WINAPI
SetTimerQueueTimer(
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    BOOL PreferIo
    )
/*OBSOLETE FUNCTION - REPLACED BY CreateTimerQueueTimer */
{
    NTSTATUS Status ;
    HANDLE Handle ;

    //
    // if the passed timer queue is NULL, use the default one.  If it is null,
    // call the initializer that will do it in a nice thread safe fashion.
    //

    if ( !TimerQueue )
    {
        if ( !BasepDefaultTimerQueue )
        {
            if ( !BasepCreateDefaultTimerQueue( ) )
            {
                return NULL ;
            }
        }

        TimerQueue = BasepDefaultTimerQueue ;
    }

    Status = RtlCreateTimer(
                TimerQueue,
                &Handle,
                Callback,
                Parameter,
                DueTime,
                Period,
                (PreferIo ? WT_EXECUTEINIOTHREAD : 0 ) );

    if ( NT_SUCCESS( Status ) )
    {
        return Handle ;
    }

    BaseSetLastNTError( Status );

    return NULL ;
}


/*OBSOLETE: Replaced by DeleteTimerQueueEx */
BOOL
WINAPI
DeleteTimerQueue(
    HANDLE TimerQueue
    )
/*++

  OBSOLETE: Replaced by DeleteTimerQueueEx

Routine Description:

    This function deletes a timer queue created with CreateTimerQueue.
    Any pending timers on the timer queue are cancelled and deleted.
    This is a non-blocking call. Callbacks might still be running after
    this call returns.

Arguments:

    TimerQueue - Timer Queue to delete.

Return Value:

    TRUE - the timer queue was deleted.

    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if (TimerQueue)
    {
        Status = RtlDeleteTimerQueueEx( TimerQueue, NULL );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        /*
        if ( Status == STATUS_PENDING || ! NT_SUCCESS( Status ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
        */
        return TRUE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}


/*OBSOLETE: USE DeleteTimerQueueTimer*/
BOOL
WINAPI
CancelTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer
    )
/*OBSOLETE: USE DeleteTimerQueueTimer*/
{
    NTSTATUS Status ;

    //
    // Use the default timer queue if none was passed in.  If there isn't one, then
    // the process hasn't created one with SetTimerQueueTimer, and that's an error.
    //

    if ( !TimerQueue )
    {
        TimerQueue = BasepDefaultTimerQueue ;

        if ( !TimerQueue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );

            return FALSE ;
        }
    }

    Status = RtlDeleteTimer( TimerQueue, Timer, NULL );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tfile.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tfile.c

Abstract:

    Test program for Win32 Base File API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <memory.h>

#define xassert ASSERT

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE iFile,oFile,fFile,mFile,n1,o1;
    DWORD n,n2;
    LONG Size;
    BYTE buff[512],cbuff[512];
    DWORD attr;
    FILETIME Mtime, Mtime0, Mtime1;
    PWIN32_FIND_DATA FindFileData;
    BOOL b;
    WORD w1,w2;
    DWORD dw,spc,bps,fc,tc;
    LPSTR base;
    LPSTR l;
    OFSTRUCT reopen1, reopen2;
    DWORD volsn[2];

    printf("Drives = 0x%lx\n",GetLogicalDrives());
    n = GetLogicalDriveStrings(511,buff);
    if ( n < 512 ) {
        l = buff;
        while ( *l ) {
            printf("%s\n",l);
            n2 = strlen(l);
            l += (n2+1);;
            }
        }
    n = GetLogicalDriveStringsW(511,buff);
    xassert(!SetCurrentDirectory("X:\\"));

    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "e:\\nt\\dll\\nul",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    FindClose(fFile);

    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "e:\\",
                FindFileData
                );
    xassert(fFile == INVALID_HANDLE_VALUE);

    b = GetVolumeInformation("",NULL,0,volsn,NULL,NULL,NULL,0);
    assert(!b);

    b = GetVolumeInformation("e:\\",NULL,0,volsn,NULL,NULL,NULL,0);
    assert(b);

    w2 = GetTempFileName("e:\\zzzxtmp","zz",0,buff);
    xassert(w2 == 0 );

    b = GetDiskFreeSpace(NULL,&spc,&bps,&fc,&tc);
    xassert(b && spc && (bps == 512) && fc && tc);
    printf("SPC = %d, BPS = %d, FC = %d, TC = %d\n",spc,bps,fc,tc);

    SearchPath(
        ".;e:\\nt;e:\\nt\\dll",
        "base",
        ".dll",
        512,
        cbuff,
        NULL
        );

    SearchPath(
        NULL,
        "win386.exe",
        ".EXe",
        512,
        cbuff,
        NULL
        );

    (VOID)argc;
    (VOID)argv;
    (VOID)envp;

#if 0
    CreateDirectory("e:\\zyx",NULL);
    xassert(SetCurrentDirectory("e:\\zyx"));
    *buff = '\0';
    xassert(GetTempPath(8,buff) == 7 && !_strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(7,buff) == 7 && !_strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(6,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(5,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(4,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(3,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(2,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(1,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(0,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
#endif
    xassert(SetCurrentDirectory("e:\\nt"));
    b = SetEnvironmentVariable("TMP","d:\\tmp");
    xassert(b);
#if 0
    *buff = '\0';
    xassert(GetTempPath(8,buff) == 7 && !_strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(7,buff) == 7 && !_strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(6,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(5,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(4,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(3,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(2,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(1,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(0,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
#endif
    b = SetEnvironmentVariable("TMP","d:\\tmp\\");
    xassert(b);
#if 0
    *buff = '\0';
    xassert(GetTempPath(8,buff) == 7 && !_strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(7,buff) == 7 && !_strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(6,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(5,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(4,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(3,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(2,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(1,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(0,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
#endif
    w1 = GetTempFileName("e:\\tmp\\","foo",0,buff);
    iFile = CreateFile(
                buff,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(iFile != INVALID_HANDLE_VALUE);
    w2 = GetTempFileName("e:\\tmp","foobar",w1,buff);
    xassert(w1 == w2);
    oFile = CreateFile(
                buff,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile == INVALID_HANDLE_VALUE);

    CloseHandle(iFile);
    xassert(CopyFile("e:\\nt\\dll\\usersrv.dll",buff,FALSE));
    DeleteFile("xyzzy");
    xassert(MoveFile(buff,"xyzzy"));
    xassert(!DeleteFile(buff));
    DeleteFile("rrxyzzy");
    xassert(MoveFile("xyzzy","rrxyzzy"));

    oFile = CreateFile(
                "rrxyzzy",
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile != INVALID_HANDLE_VALUE);

    iFile = CreateFile(
                "e:\\nt\\dll\\usersrv.dll",
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(iFile != INVALID_HANDLE_VALUE);

    fFile = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,8192,NULL);
    xassert(fFile);
    base = MapViewOfFile(fFile,FILE_MAP_WRITE,0,0,0);
    xassert(base);
    strcpy(base,"Hello World\n");
    printf("%s",base);
    xassert(UnmapViewOfFile(base));
    CloseHandle(fFile);
    fFile = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READONLY,0,8192,NULL);
    xassert(fFile);
    CloseHandle(fFile);
    fFile = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READONLY,0,0,NULL);
    xassert(!fFile);

    mFile = CreateFileMapping(oFile,NULL,PAGE_READONLY,0,0,NULL);
    xassert(mFile);
    n1 = CreateFileMapping(oFile,NULL,PAGE_READONLY,0,0,"named-map");
    xassert(n1);
    o1 = OpenFileMapping(FILE_MAP_WRITE,FALSE,"named-map");
    xassert(o1);
    base = MapViewOfFile(o1,FILE_MAP_WRITE,0,0,0);
    xassert(!base);
    base = MapViewOfFile(n1,FILE_MAP_READ,0,0,0);
    xassert(base);

    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "e:\\nt\\dll\\usersrv.dll",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);

    l = LocalAlloc(LMEM_ZEROINIT,FindFileData->nFileSizeLow);
    xassert(l);
    b = ReadFile(iFile,l,FindFileData->nFileSizeLow,&n,NULL);
    xassert(b);
    xassert(n == FindFileData->nFileSizeLow);
    CloseHandle(oFile);
    xassert(memcmp(l,base,FindFileData->nFileSizeLow) == 0 );

    xassert(DeleteFile("rrxyzzy"));

    w2 = GetTempFileName("e:\\tmp","foobar",(WORD)0xf7ff,buff);
    xassert(w2 == 0xf7ff);
    oFile = CreateFile(
                buff,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile == INVALID_HANDLE_VALUE);

    w2 = GetTempFileName("e:\\xtmp","foobar",0,buff);
    xassert(w2 == 0);

    xassert(!RemoveDirectory("e:\\"));

    xassert(SetCurrentDirectory("e:\\nt"));
    xassert(!RemoveDirectory("."));
    n = GetCurrentDirectory(0,buff);
    xassert(n == 5);
    n = GetCurrentDirectory(4,buff);
    xassert(n == 5);
    *buff = '\0';
    n = GetCurrentDirectory(5,buff);
    xassert(n == 5 && strcmp(buff,"e:\\nt") == 0 );
    *buff = '\0';
    n = GetCurrentDirectory(500,buff);
    xassert(n == 5 && strcmp(buff,"e:\\nt") == 0 );

    xassert(SetCurrentDirectory("e:\\"));
    *buff = '\0';
    n = GetCurrentDirectory(500,buff);
    xassert(n == 3 && strcmp(buff,"e:\\") == 0 );
    *buff = '\0';
    n = GetCurrentDirectory(3,buff);
    xassert(n == 3 && strcmp(buff,"e:\\") == 0 );
    *buff = '\0';
    n = GetCurrentDirectory(2,buff);
    xassert(n == 3 && strcmp(buff,"e:\\") != 0 );
    xassert(SetCurrentDirectory("e:\\nt"));
    *buff = '\0';
    n = GetCurrentDirectory(500,buff);
    xassert(n == 5 && strcmp(buff,"e:\\nt") == 0 );
    xassert(SetCurrentDirectory("."));
    *buff = '\0';
    n = GetCurrentDirectory(500,buff);
    xassert(n == 5 && strcmp(buff,"e:\\nt") == 0 );

    xassert(GetDriveType("Z:\\") == 1);
    xassert(GetDriveType(".") == 1);
    xassert(GetDriveType("e:\\NT") == 1);
    xassert(GetDriveType(NULL) == DRIVE_FIXED);
    xassert(GetDriveType("e:\\") == DRIVE_FIXED);
    xassert(GetDriveType("A:\\") == DRIVE_REMOVABLE);


    xassert(!CreateDirectory(".",NULL));
    xassert(CreateDirectory("xyzzy",NULL));
    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "xyzzy\\*.*",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData->dwFileAttributes,
            FindFileData->nFileSizeLow,
            FindFileData->cFileName
            );
        b = FindNextFile(fFile,FindFileData);
        }
    FindClose(fFile);
    xassert(!FindClose(fFile));

    xassert(RemoveDirectory("xyzzy"));

    iFile = CreateFile(
                "",
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(iFile == INVALID_HANDLE_VALUE);

    iFile = CreateFile(
                "nt.cfg",
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(iFile != INVALID_HANDLE_VALUE);
    xassert(!FlushFileBuffers(iFile));

    xassert(LockFile(iFile,0,0,10,0));
    xassert(LockFile(iFile,10,0,10,0));
    xassert(!LockFile(iFile,1,0,1,0));
    xassert(!LockFile(iFile,0,0,11,0));
    xassert(!LockFile(iFile,0,0,20,0));
    xassert(!UnlockFile(iFile,1,0,1,0));
    xassert(!UnlockFile(iFile,0,0,11,0));
    xassert(!UnlockFile(iFile,0,0,20,0));
    xassert(UnlockFile(iFile,0,0,10,0));
    xassert(UnlockFile(iFile,10,0,10,0));
    xassert(LockFile(iFile,0,0,10,0));
    xassert(LockFile(iFile,10,0,10,0));
    fFile = CreateFile(
                "nt.cfg",
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = ReadFile(fFile,&buff,1, &n, NULL);
    xassert(!b);
    xassert(SetFilePointer(INVALID_HANDLE_VALUE,0,NULL,FILE_BEGIN) == 0xffffffff);
    b = ReadFile(fFile,&buff,11, &n, NULL);
    xassert(SetFilePointer(fFile,0,NULL,FILE_BEGIN) == 0);
    b = ReadFile(fFile,&buff,11, &n, NULL);
    xassert(!b);
    xassert(SetFilePointer(fFile,10,NULL,FILE_BEGIN) == 10);
    b = ReadFile(fFile,&buff,1,&n,NULL);
    xassert(!b);
    xassert(SetFilePointer(fFile,10,NULL,FILE_BEGIN) == 10);
    b = ReadFile(fFile,&buff,1,&n,NULL);
    xassert(!b);
    xassert(SetFilePointer(fFile,20,NULL,FILE_BEGIN) == 20);
    b = ReadFile(fFile,&buff,1, &n, NULL);
    xassert(b && n == 1);
    xassert(UnlockFile(iFile,0,0,10,0));
    xassert(UnlockFile(iFile,10,0,10,0));
    CloseHandle(fFile);
    SetHandleCount(255);

    oFile = CreateFile(
            "ntos3.cfg",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_HIDDEN,
            NULL
            );
    xassert(oFile != INVALID_HANDLE_VALUE);
    xassert(FlushFileBuffers(oFile));

    //
    // Copy iFile to oFile
    //

    Size = 0;
    b = ReadFile(iFile,&buff,512, &n, NULL);
    while(b && n){
        Size += n;
        b = WriteFile(oFile,&buff,n, &n, NULL);
        xassert(b && n);
        b = ReadFile(iFile,&buff,512, &n, NULL);
        }

    //
    // Make sure that we can not truncate a read only file
    //

    xassert(!SetEndOfFile(iFile));

    //
    // Go back to beginning of the iFile
    //

    xassert(SetFilePointer(iFile,0,NULL,FILE_BEGIN) == 0);
    xassert(SetFilePointer(oFile,-Size,NULL,FILE_CURRENT) == 0);

    b = ReadFile(iFile,&buff,512, &n, NULL);
    xassert(b && n);
    b = ReadFile(oFile,&cbuff,n, &n2, NULL);
    xassert(b && (n2 == n) );
    while(n && (n == n2) ){
        xassert(memcmp(&buff,&cbuff,n) == 0);
        ReadFile(iFile,&buff,512, &n, NULL);
        ReadFile(oFile,&cbuff,n, &n2, NULL);
        xassert(n2 == n);
        }
    printf("End of Loop. n2 = %ld GLE = 0x%lx\n",n2,GetLastError());

    //
    // Truncate the file to 128 bytes
    //

    xassert(SetFilePointer(oFile,128,NULL,FILE_BEGIN) == 128);
    xassert(SetEndOfFile(oFile));

    xassert(SetFilePointer(oFile,0,NULL,FILE_BEGIN) == 0);
    xassert(SetFilePointer(oFile,0,NULL,FILE_END) != -1);
    xassert(SetFilePointer(oFile,0,NULL,FILE_BEGIN) == 0);
    ReadFile(oFile,&cbuff,512, &n2, NULL);
    xassert(n2 == 128);

    CloseHandle(iFile);
    CloseHandle(oFile);

    oFile = CreateFile(
            "ntos3.cfg",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
    xassert(oFile == INVALID_HANDLE_VALUE);

    attr = GetFileAttributes("ntos3.cfg");
    xassert(attr == (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));

    xassert(SetFileAttributes("ntos3.cfg", FILE_ATTRIBUTE_NORMAL));

    attr = GetFileAttributes("ntos3.cfg");
    xassert(attr == FILE_ATTRIBUTE_NORMAL);

    oFile = CreateFile(
                "ntos3.cfg",
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile != INVALID_HANDLE_VALUE);


    xassert(!DeleteFile("ntos3.cfg"));
    CloseHandle(oFile);

    xassert(DeleteFile("ntos3.cfg"));
    oFile = CreateFile(
                "ntos3.cfg",
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile == INVALID_HANDLE_VALUE);

    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "dll\\*.*",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData->dwFileAttributes,
            FindFileData->nFileSizeLow,
            FindFileData->cFileName
            );
        b = FindNextFile(fFile,FindFileData);
        }
    FindClose(fFile);
    xassert(!FindClose(fFile));

    n = GetWindowsDirectory(cbuff,512);
    printf("Windows directory %s length %d\n",cbuff,n);
    strcat(cbuff,"\\*.*");
    fFile =  FindFirstFile(
                cbuff,
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData->dwFileAttributes,
            FindFileData->nFileSizeLow,
            FindFileData->cFileName
            );
        b = FindNextFile(fFile,FindFileData);
        }
    FindClose(fFile);
    xassert(!FindClose(fFile));

    GetSystemDirectory(cbuff,512);
    strcat(cbuff,"\\*.*");
    fFile =  FindFirstFile(
                cbuff,
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData->dwFileAttributes,
            FindFileData->nFileSizeLow,
            FindFileData->cFileName
            );
        b = FindNextFile(fFile,FindFileData);
        }
    FindClose(fFile);
    xassert(!FindClose(fFile));

    iFile = (HANDLE)OpenFile("xyzzy.ggg",&reopen1, OF_PARSE);
    xassert(iFile == 0);
    dw = GetFullPathName("xyzzy.ggg",512,buff,&l);
    xassert(!_stricmp(buff,&reopen1.szPathName[0]));

    iFile = (HANDLE)OpenFile("",&reopen1, OF_READ);
    xassert(iFile == INVALID_HANDLE_VALUE);

    iFile = (HANDLE)OpenFile("ls.exe",&reopen1, OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    xassert(!_stricmp("e:\\nt\\bin\\ls.exe",&reopen1.szPathName[0]));
    CloseHandle(iFile);
    reopen2 = reopen1;
    iFile = (HANDLE)OpenFile("ls.exe",&reopen1, OF_VERIFY | OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    xassert(!_stricmp("e:\\nt\\bin\\ls.exe",&reopen1.szPathName[0]));
    CloseHandle(iFile);
    iFile = (HANDLE)OpenFile("",&reopen1, OF_REOPEN | OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    xassert(!_stricmp("e:\\nt\\bin\\ls.exe",&reopen1.szPathName[0]));
    CloseHandle(iFile);
    iFile = (HANDLE)OpenFile("ls.exe",&reopen2, OF_VERIFY | OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    xassert(!_stricmp("e:\\nt\\bin\\ls.exe",&reopen2.szPathName[0]));
    CloseHandle(iFile);
    iFile = (HANDLE)OpenFile("ls.exe",&reopen2, OF_EXIST );
    xassert(!CloseHandle(iFile));
    xassert(CopyFile("e:\\nt\\bin\\ls.exe","xxx.xxx",FALSE));
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_EXIST );
    xassert(!CloseHandle(iFile));
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_READWRITE );
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    Sleep(3000);
    b = WriteFile(iFile,"Hello World",12,&n,NULL);
    xassert(b && n == 12);
    CloseHandle(iFile);
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_VERIFY | OF_READ);
    xassert(iFile == INVALID_HANDLE_VALUE);
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_DELETE );
    xassert(!CloseHandle(iFile));
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_EXIST );
    printf("iFile %lx nErrCode %d\n",iFile,reopen1.nErrCode);
    xassert(iFile == INVALID_HANDLE_VALUE && reopen1.nErrCode == ERROR_FILE_NOT_FOUND);

    fFile =  FindFirstFile(
                "e:\\nt\\nt.cfg",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    iFile = (HANDLE)OpenFile("e:\\nt\\nt.cfg",&reopen1, OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    n = GetFileSize(iFile,NULL);
    xassert(n != -1);
    xassert(n==FindFileData->nFileSizeLow);
    FindClose(fFile);
    CloseHandle(iFile);

    xassert(CopyFile("e:\\nt\\bin\\ls.exe","xxx.xxx",FALSE));
    iFile = _lopen("xxx.xxx",OF_READ);
    xassert(iFile != INVALID_HANDLE_VALUE);
    oFile = _lcreat("xxx.zzz",0);
    xassert(oFile != INVALID_HANDLE_VALUE);

    Size = 0;
    b = ReadFile(iFile,&buff,512, &n, NULL);
    while(b && n){
        Size += n;
        b = WriteFile(oFile,&buff,n, &n, NULL);
        xassert(b && n);
        b = ReadFile(iFile,&buff,512, &n, NULL);
        }
    CloseHandle(iFile);
    CloseHandle(oFile);

    iFile = _lopen("xxx.xxx",OF_WRITE);
    xassert(iFile != INVALID_HANDLE_VALUE);
    CloseHandle(iFile);
    iFile = _lopen("xxx.xxx",OF_READ);
    b = ReadFile(iFile,&buff,512, &n, NULL);
    xassert(b && n == 0 && GetLastError() == 0);

    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tlfn.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tlfn.c

Abstract:

    Test program for GetShortPathName and GetLongPathName

Author:

    William Hsieh (williamh) 26-Mar-1997

Revision History:

--*/

#undef UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>
#include "basedll.h"

BOOL
CreateTestDirs(LPSTR BasePath, DWORD Depth);
BOOL
DeleteTestDirs(LPSTR BasePath, DWORD Depth);

DWORD
DoTest(LPSTR BasePath, DWORD Depth);

BOOL
DoNullPathTest();

LPSTR	g_BasePath = "C:\\LongDirectoryForTesting";
#define MAX_SUBDIRS  22
// Note that NT file APIs strips trailing white chars automatically,
// thus, path name such as "12345678.12 " will be created as
// "12345678.12". Do not put something like this in the following table
// or the test will fail.
// The TestDepth controls the depth of the testing sub-dirs this program
// creates. It could take a long time to complete the test if TestDepth
// is set to larger than 3. With TestDepth set to 1, the program only tests
// the BasePath. You can always manually test a particular pathname
// by running "tlfn 1 yourpath". In this case, the given directory will not
// be removed by this program.
//
LPSTR	g_subdir[MAX_SUBDIRS] = {
    "12345678.123",
    "12345678.1",
    "8.1",
    "8.123",
    "12345678.1",
    "12345678",
    " 2345678.  3",
    "       8.1 3",
    "1      8. 23",
    "123  678.123",
    "123  678.1 3",
    ".1",
    "..2",
    "...3",
    "1  4 6 8........1 3",
    "1      8..123",
    "12345678..1 3",
    "12345678.12345678",
    "1234567890123456.1111",
    "123456789.123",
    "12345678.1234",
    "12345   1"
    };

CHAR	g_ShortName[MAX_PATH + 1];
CHAR	g_LongName[MAX_PATH + 1];

DWORD	g_TestDepth = 3;


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD FailCount;
    LPSTR   BasePath;
    DWORD TestDepth;

    TestDepth =  g_TestDepth;
    BasePath = g_BasePath;

    if (argc > 1 && argv[1])
    {
	TestDepth = atoi(argv[1]);
    }
    if (argc > 2 && argv[2])
    {
	BasePath = argv[2];
    }
    printf("Test depth = %d, Base path = %s\n", TestDepth, BasePath);


    if (!DoNullPathTest()) {
	printf("NullPath test Failed\n");
	return FALSE;
	}
    printf("Null Path test passed\n");

    if (TestDepth != 1 || BasePath == g_BasePath) {
	printf("\n\nCreating testing sub-directories.....\n\n\n");

	if (!CreateTestDirs(BasePath, TestDepth))
	    {
	    printf("Unable to create test path names\n");
	    return FALSE;
	    }
	}

    printf("Start testing....\n");



    FailCount = DoTest(BasePath, TestDepth);

    if (!FailCount)
	printf("Test passed\n");
    else
	printf("Test not passed, failed count = %ld\n", FailCount);

    if (TestDepth != 1 || BasePath == g_BasePath)  {
	printf("Removing test sub-directories\n\n\n");
	DeleteTestDirs(BasePath, TestDepth);
    }
    return TRUE;
}


BOOL
CreateTestDirs(
    LPTSTR BasePath,
    DWORD Depth
    )
{
    int len;
    CHAR szBase[MAX_PATH + 1];
    BOOL    Result;
    DWORD dw;

    Result = TRUE;
    dw = GetFileAttributes(BasePath);
    if (dw == 0xFFFFFFFF)
    {
	if (!CreateDirectory(BasePath, NULL))
	{
	    printf("CreateTestDirs::Unable to create base directory, error = %ld\n",
		    GetLastError());
	    return FALSE;
	}
    }
    dw = GetFileAttributes(BasePath);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
	return FALSE;
    if (Depth > 1)
    {
	int i;
	len = strlen(BasePath);
	strcpy(szBase, BasePath);
	for (i = 0; i < MAX_SUBDIRS; i++)
	{
	    szBase[len] = '\\';
	    strcpy((szBase + len + 1), g_subdir[(Depth & 1) ? i : MAX_SUBDIRS - i - 1]);
	    if (!CreateTestDirs(szBase, Depth - 1))
	    {
		Result = FALSE;
		break;
	    }
	}
    }
    return Result;
}


BOOL
DeleteTestDirs(
    LPSTR BasePath,
    DWORD Depth
    )
{
    int i, len;
    CHAR Temp[MAX_PATH + 1];
    strcpy(Temp, BasePath);
    len = strlen(BasePath);

    if (Depth)
    {
	for (i = 0; i < MAX_SUBDIRS; i++)
	{
	    Temp[len] = '\\';
	    strcpy((Temp + len + 1), g_subdir[(Depth & 1) ?i : MAX_SUBDIRS - i - 1]);
	    DeleteTestDirs(Temp, Depth - 1);
	}
    }
    RemoveDirectory(BasePath);
    return TRUE;
}

DWORD
DoTest(
    LPSTR   BasePath,
    DWORD   Depth
    )
{

    DWORD dw, dwTemp;
    DWORD FailCount;

    LPSTR ShortPath, LongPath;
    CHAR FunnyBuffer[1];
    ASSERT(Depth >= 1);
    ASSERT(BasePath);

    FailCount = 0;

    // this should fail
    dw = GetShortPathName(BasePath, NULL, 0);
    dwTemp = GetShortPathName(BasePath, FunnyBuffer, sizeof(FunnyBuffer) / sizeof(CHAR));
    ASSERT(dw == dwTemp);
    dwTemp = GetShortPathName(BasePath, NULL, 0xffff);
    ASSERT(dw == dwTemp);
    dwTemp = GetShortPathName(BasePath, FunnyBuffer, 0);
    ASSERT(dwTemp == dw);
    ShortPath = (LPTSTR)malloc(dw * sizeof(CHAR));
    if (!ShortPath) {
	printf("Not enough memory\n");
	return 0;
	}
    dwTemp = GetShortPathName(BasePath, ShortPath, dw - 1);
    ASSERT(dwTemp == dw);
    dwTemp  = GetShortPathName(BasePath, ShortPath, dw);
    ASSERT(dwTemp && dwTemp + 1 == dw);
    printf("\"%s\" L-S -> \"%s\"\n", BasePath, ShortPath);
    strcpy(g_LongName, BasePath);
    dw = GetShortPathName(g_LongName, g_LongName, dwTemp - 1);
    if (_stricmp(BasePath, g_LongName))
    {
	printf("Overwrite source string\n");
	ASSERT(FALSE);
	strcpy(g_LongName, BasePath);
    }
    dw = GetShortPathName(g_LongName, g_LongName, dwTemp + 1);
    ASSERT(dw == dwTemp);
    if (_stricmp(ShortPath, g_LongName)) {
	printf("GetShortPathName mismatch with different desitination buffer\n");
	ASSERT(FALSE);
	}
    dw = GetLongPathName(ShortPath, NULL, 0);
    dwTemp = GetLongPathName(ShortPath, FunnyBuffer, sizeof(FunnyBuffer) / sizeof(CHAR));
    ASSERT(dw == dwTemp);
    dwTemp = GetLongPathName(ShortPath, NULL, 0xffff);
    ASSERT(dwTemp == dw);
    dwTemp = GetLongPathName(ShortPath, FunnyBuffer, 0);
    ASSERT(dw == dwTemp);
    LongPath = (LPSTR)malloc(dw * sizeof(CHAR));
    if (!LongPath) {
	printf("Not enough memory\n");
	free(ShortPath);
	return(0);
    }
    dwTemp = GetLongPathName(ShortPath, LongPath, dw - 1);
    ASSERT( dw == dwTemp);
    dwTemp = GetLongPathName(ShortPath, LongPath, dw);
    ASSERT(dwTemp && dwTemp + 1 == dw);
    printf("\"%s\" S-L -> \"%s\"\n", ShortPath, LongPath);
    strcpy(g_ShortName, ShortPath);
    dw = GetLongPathName(g_ShortName, g_ShortName, dwTemp - 1);
    if (_stricmp(ShortPath, g_ShortName))
    {
	printf("Overwrite source string\n");
	ASSERT(FALSE);
	strcpy(g_ShortName, ShortPath);
    }
    dw = GetLongPathName(g_ShortName, g_ShortName, dwTemp + 1);
    ASSERT(dw == dwTemp);
    if (_stricmp(LongPath, g_ShortName)) {
	printf("GetLongPathName mismatch with different desitination buffer\n");
	ASSERT(FALSE);
	}

    if (_stricmp(LongPath, BasePath))
    {
	FailCount++;
	printf("round trip does not match\n");
	ASSERT(FALSE);
    }
    if(Depth > 1) {
	int i, len;
	CHAR TempName[MAX_PATH + 1];
	len = strlen(BasePath);
	strcpy(TempName, BasePath);
	for (i = 0; i < MAX_SUBDIRS; i++)
	{
	    TempName[len] = '\\';
	    strcpy((TempName + len + 1), g_subdir[(Depth & 1) ?i : MAX_SUBDIRS - i - 1]);
	    FailCount += DoTest(TempName, Depth - 1);
	}
    }
    free(ShortPath);
    free(LongPath);
    return FailCount;
}





BOOL
DoNullPathTest()
{

    CHAR ShortName[1];
    CHAR LongName[1];
    DWORD dw;

    LongName[0] = '\0';
    dw = GetShortPathName(LongName, ShortName, 0);
    ASSERT(dw == 1);
    dw = GetShortPathName(LongName, ShortName, 1);
    ASSERT(dw == 0);
    ShortName[0] = '\0';
    dw = GetLongPathName(ShortName, LongName, 0);
    ASSERT(dw == 1);
    dw = GetLongPathName(ShortName, LongName, 1);
    ASSERT(dw == 0);
    return (dw == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tmscli.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tmscli.c

Abstract:

    Test program to Win32 mailslot API calls

Author:

    Manny Weiser (mannyw) 5-May-1991

Revision History:

--*/

#include "stdio.h"
#include "windows.h"

char Buffer[] = "This is a message";

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
        
{
    BOOL success;
    HANDLE handle;
    LPSTR mailslotName =  "\\\\.\\mailslot\\asdf";
    
    DWORD bytesWritten;
    
    handle = CreateFile( mailslotName,
                         GENERIC_WRITE,
                         FILE_SHARE_WRITE | FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         0 );

    if (handle == (HANDLE)-1) {
        printf ("Failed to open mailslot ""%s""\n", mailslotName);
        printf ("Error = %lx\n", GetLastError() );
        return 1;
    }
    
    printf ("Successfully opened the mailslot.\n");
    

    success = WriteFile( handle,
                         Buffer,
                         sizeof(Buffer),
                         &bytesWritten,
                         NULL );
                    
    if (!success) {
        printf ("Failed to read mailslot\n");
        return 1;
    } else {
        printf ("Successfully wrote %d bytes '%s'\n", bytesWritten, Buffer );
    }
                         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tnpsrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tnpsrv.c

Abstract:

    This program creates a single instance of the pipe \cw\testpipe,
    awaits for a connection. While a client wants to talk it will echo
    data back to the client. When the client closes the pipe tnpsrv will
    wait for another client.

Author:

    Colin Watson (ColinW) 19-March-1991

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE S1;
    DWORD Size;
    DWORD Dummy;
    CHAR Data[1024];

    S1 = CreateNamedPipe("\\\\.\\Pipe\\cw\\testpipe",
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_WAIT | PIPE_READMODE_MESSAGE| PIPE_TYPE_MESSAGE,
            1,  // One instance only
            sizeof(Data),
            sizeof(Data),
            0,
            NULL);

    assert(S1 != INVALID_HANDLE_VALUE);

    while (1) {

        printf("Waiting for connection\n");
        if ( FALSE == ConnectNamedPipe( S1, NULL )) {
            printf("Server ReadFile returned Error %lx\n", GetLastError() );
            break;
            }

        while (1) {

            printf("Server now Reading\n");
            if ( FALSE == ReadFile(S1,Data, sizeof(Data), &Size, NULL) ) {
                printf("Server ReadFile returned Error %lx\n", GetLastError() );
                break;
                }

            printf("Server Reading Done %s\n",Data);

            printf("Server Writing\n");
            if ( FALSE == WriteFile(S1, Data, Size, &Dummy, NULL) ) {
                printf("Server WriteFile returned Error %lx\n", GetLastError() );
                break;
                }

            printf("Server Writing Done\n");
            }

        if ( FALSE == DisconnectNamedPipe( S1 ) ) {
            printf("Server WriteFile returned Error %lx\n", GetLastError() );
            break;
            }
        }

    CloseHandle(S1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tnpipe.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

DWORD Size;
LPSTR WriteData = "Hello World\n";

VOID
ClientThread(
    LPVOID ThreadParameter
    )
{
    DWORD n;
    HANDLE C1;
    LPSTR l;

    printf("Create client...\n");
    C1 = CreateFile("\\\\.\\Pipe\\cw\\testpipe",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,       // Security Attributes
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL
            );

    if ( C1 == INVALID_HANDLE_VALUE ) {
        DWORD Status;
        printf("CreateFile returned Error %lx\n", Status = GetLastError() );
        }

    printf("Client writing...\n");

    assert( TRUE == WriteFile(C1,WriteData,Size, &n, NULL) );
    assert( n==Size );
    printf("Client done Writing...\n");

    // Get WriteData back from the server
    l = LocalAlloc(LMEM_ZEROINIT,Size);
    assert(l);
    printf("Client reading\n");

    assert( TRUE == ReadFile(C1,l,Size, &n, NULL));

    printf("Client reading Done %s\n",l);
    Sleep(10000);
    printf("Client done Sleeping...\n");
}


int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD n;
    LPSTR l;
    HANDLE Thread;
    HANDLE S1,S2,S3;    //  Server handles
    DWORD ThreadId;
    DWORD Dummy;
    OVERLAPPED S1Overlapped;

    S1 = CreateNamedPipe("\\\\.\\Pipe\\cw\\testpipe",
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_WAIT | PIPE_READMODE_MESSAGE| PIPE_TYPE_MESSAGE,
            2,
            1024,
            1024,
            0,
            NULL);

    assert(S1 != INVALID_HANDLE_VALUE);

    S2 = CreateNamedPipe("\\\\.\\Pipe\\cw\\testpipe",
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_WAIT | PIPE_READMODE_MESSAGE| PIPE_TYPE_MESSAGE,
            992, //IGNORED
            0,   //IGNORED
            0,   //IGNORED
            0,   //IGNORED
            NULL);

    assert(S2 != INVALID_HANDLE_VALUE);

    S3 = CreateNamedPipe("\\\\.\\Pipe\\cw\\testpipe",
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_WAIT | PIPE_READMODE_MESSAGE| PIPE_TYPE_MESSAGE,
            992,
            0,
            0,
            0,
            NULL);

    assert( S3 == INVALID_HANDLE_VALUE );   //Should fail - Used all instances

    S1Overlapped.hEvent = NULL;
    assert( FALSE == ConnectNamedPipe( S1, &S1Overlapped ));
    assert( ERROR_IO_PENDING == GetLastError());

    assert( FALSE == GetOverlappedResult( S1, &S1Overlapped, &Dummy, FALSE ));
    assert( ERROR_IO_INCOMPLETE == GetLastError());

    Size = strlen(WriteData)+1;
    l = LocalAlloc(LMEM_ZEROINIT,Size);
    assert(l);

    Thread = CreateThread(NULL,0L,ClientThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);

    printf("Waiting for connection\n");
    assert( TRUE == GetOverlappedResult( S1, &S1Overlapped, &Dummy, TRUE ));

    printf("Connected, Server now Reading\n");
    if ( FALSE == ReadFile(S1,l,Size, &n, &S1Overlapped) ) {
        DWORD Status;
        printf("Server ReadFile returned Error %lx\n", Status = GetLastError() );

        if ( Status == ERROR_IO_PENDING ) {
            printf("Server got ERROR_IO_PENDING ok,Waiting for data\n");
            assert( TRUE == GetOverlappedResult( S1, &S1Overlapped, &Dummy, TRUE ));
            }

        }
    printf("Server Reading Done %s\n",l);

    printf("Server Writing\n");
    if ( FALSE == WriteFile(S1,l,Size, &n, &S1Overlapped) ) {
        DWORD Status;
        printf("Server WriteFile returned Error %lx\n", Status = GetLastError() );

        if ( Status == ERROR_IO_PENDING ) {
            printf("Server got ERROR_IO_PENDING ok,Waiting for transfer complete\n");
            assert( TRUE == GetOverlappedResult( S1, &S1Overlapped, &Dummy, TRUE ));
            }

        }
    printf("Server Writing Done %s\n",l);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\toolhelp.c ===
/*++

 Copyright (c) 1996 Microsoft Corporation

Module Name:

    tlhelp32.c

Abstract:

    NT implementation of win95 ToolHelp API's

Author:

    John Daly

Environment:

    NT Only

Notes:

    Version 1.0
    structure definitions/documentation in tlhelp32.h


Revision History:

    John Daly (johndaly) 5-Apr-1996
        initial implementation

--*/

#include "basedll.h"
#pragma hdrstop

#include "tlhelp32.h"

#define BUFFER_SIZE 64*1024
#define ARRAYSIZE(x)        (sizeof(x) / sizeof(x[0]))

/*
 snapshot structure

 This is mapped onto the beginning of the memory we use to hold the information.

*/
typedef struct tagSNAPSHOTSTATE {
    /* item list counts */
    ULONG    HeapListCount;
    ULONG    ProcessCount;
    ULONG    ModuleCount;
    ULONG    ThreadCount;
    /* item list head pointers */
    PHEAPLIST32         HeapListHead;
    PPROCESSENTRY32W    ProcessListHead;
    PMODULEENTRY32W     ModuleListHead;
    PTHREADENTRY32      ThreadListHead;
    /* item list current indexes */
    ULONG   HeapListIndex;
    ULONG   ProcessListIndex;
    ULONG   ModuleListIndex;
    ULONG   ThreadListIndex;
    /* data begins here... */
    UCHAR    DataBegin;
}SNAPSHOTSTATE;
typedef SNAPSHOTSTATE * PSNAPSHOTSTATE;


//
// private functions
//

NTSTATUS
ThpCreateRawSnap(
    IN ULONG dwFlags,
    IN ULONG th32ProcessID,
    PUCHAR *RawProcess,
    PRTL_DEBUG_INFORMATION *RawModule,
    PRTL_DEBUG_INFORMATION *RawDebugInfo);

NTSTATUS
ThpAllocateSnapshotSection(
    OUT PHANDLE SnapSection,
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    PUCHAR RawProcess,
    PRTL_DEBUG_INFORMATION RawModule,
    PRTL_DEBUG_INFORMATION RawDebugInfo);

NTSTATUS
ThpProcessToSnap(
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    IN HANDLE SnapSection,
    PUCHAR RawProcess,
    PRTL_DEBUG_INFORMATION RawModule,
    PRTL_DEBUG_INFORMATION RawDebugInfo);

HANDLE
WINAPI
CreateToolhelp32Snapshot(
    IN DWORD dwFlags,
    IN DWORD th32ProcessID)
/*++

Routine Description:

    Takes a snapshot of the Win32 processes, heaps, modules, and threads used
    by the Win32 processes. Returns an open handle to the specified snapshot if
    successful or  -1 otherwise.

    NOTE that all of the snapshots are global except for the heap and module
    lists which are process specific. To enumerate the heap or module state for
    all WIN32 processes call with TH32CS_SNAPALL and the current process. Then
    for each process in the TH32CS_SNAPPROCESS list that isn't the current
    process, do a call with just TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.

    Use CloseHandle to destroy the snapshot

    This function is not multi-thread safe.  All of the other functions are.

Arguments:

    dwFlags - Supplies switches to specify action as follows:
        TH32CS_INHERIT  Indicates that the snapshot handle is to be inheritable.
        TH32CS_SNAPALL  Equivalent to specifying the TH32CS_SNAPHEAPLIST,
                        TH32CS_SNAPMODULE, TH32CS_SNAPPROCESS, and
                        TH32CS_SNAPTHREAD values.
        TH32CS_SNAPHEAPLIST     Includes the heap list of the specified Win32
                                process in the snapshot.
        TH32CS_SNAPMODULE       Includes the module list of the specified Win32
                                process in the snapshot.
        TH32CS_SNAPPROCESS      Includes the Win32 process list in the snapshot.
        TH32CS_SNAPTHREAD       Includes the Win32 thread list in the snapshot.

    th32ProcessID - Supplies a Win32 process identifier. This parameter can be
        zero to indicate the current process. This parameter is used when the
        TH32CS_SNAPHEAPLIST or TH32CS_SNAPMODULE value is specified. Otherwise,
        it is ignored. The snapshot taken by this function is examined by the
        other tool help functions to provide their results.  Access to the
        snapshot is read only. The snapshot handle acts like a Win32 object
        handle and is subject to the same rules regarding which processes and
        threads it is valid in.

Return Value:

    Returns an open handle to the specified snapshot if successful or -1 if not.
    To retrieve an extended error status code generated by this function, use
    the GetLastError function.
    To destroy the snapshot, use the CloseHandle function.

--*/
{
    HANDLE SnapSection;
    PUCHAR RawProcess;
    PRTL_DEBUG_INFORMATION RawModule;
    PRTL_DEBUG_INFORMATION RawDebugInfo;
    NTSTATUS Status = 0;

    if (th32ProcessID == 0) {
        th32ProcessID = GetCurrentProcessId();
    }

    //
    // process the requested data types
    //

    Status = ThpCreateRawSnap(dwFlags,
                              th32ProcessID,
                              &RawProcess,
                              &RawModule,
                              &RawDebugInfo);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return (HANDLE)-1;
    }

    Status = ThpAllocateSnapshotSection(&SnapSection,
                                        dwFlags,
                                        th32ProcessID,
                                        RawProcess,
                                        RawModule,
                                        RawDebugInfo);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return (HANDLE)-1;
    }

    Status = ThpProcessToSnap(dwFlags,
                              th32ProcessID,
                              SnapSection,
                              RawProcess,
                              RawModule,
                              RawDebugInfo);

    if (!NT_SUCCESS(Status)) {
        CloseHandle(SnapSection);
        BaseSetLastNTError(Status);
        return (HANDLE)-1;
    }

    return SnapSection;
}


BOOL
WINAPI
Heap32ListFirst(
   IN HANDLE SnapSection,
   IN OUT LPHEAPLIST32 lphl)
/*++

Routine Description:

    Retrieves information about the first heap that has been allocated by a
    specified Win32 process.

Arguments:

    SnapSection - Supplies the handle of the snapshot returned from a previous
        call to the CreateToolhelp32Snapshot function.

    lphl - Returns a HEAPLIST32 structure.  The calling application must set
        the dwSize member of HEAPLIST32 to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the heap list has been copied to the buffer
    or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function when no heap list exists or the snapshot does not contain
    heap list information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    BOOL retv = FALSE;

    if (!lphl || lphl->dwSize != sizeof(HEAPLIST32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->HeapListCount == 0) {
        RtlZeroMemory((PUCHAR)lphl + sizeof(SIZE_T), (lphl->dwSize - sizeof(SIZE_T)));
        SetLastError(ERROR_NO_MORE_FILES);
    } else {
        memcpy(lphl,
               (LPHEAPLIST32)((ULONG_PTR)SnapshotBase + (ULONG_PTR)SnapshotBase->HeapListHead),
               sizeof(HEAPLIST32));
        retv = TRUE;
        SnapshotBase->HeapListIndex = 1;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);
    return retv;
}


BOOL
WINAPI
Heap32ListNext(
   IN HANDLE SnapSection,
   IN OUT LPHEAPLIST32 lphl)
/*++

Routine Description:

    Retrieves information about the next heap that has been allocated by a
    Win32 process.

Arguments:

    SnapSection - Supplies the handle of the snapshot returned from a previous
        call to the CreateToolhelp32Snapshot function.

   lphl - Returns a HEAPLIST32 structure. The calling application must set the
        dwSize member of HEAPLIST32 to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the heap list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function when no more entries in the heap list exist.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    BOOL retv = FALSE;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;

    if (!lphl || lphl->dwSize != sizeof(HEAPLIST32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->HeapListIndex < SnapshotBase->HeapListCount) {
        memcpy(lphl,
               (LPHEAPLIST32)((ULONG_PTR)SnapshotBase + (ULONG_PTR)(&SnapshotBase->HeapListHead[SnapshotBase->HeapListIndex++])),
               sizeof(HEAPLIST32));
        retv = TRUE;
    } else {
        SetLastError(ERROR_NO_MORE_FILES);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return(retv);
}


BOOL
WINAPI
Heap32First(
   IN OUT LPHEAPENTRY32 lphe,
   IN DWORD th32ProcessID,
   IN ULONG_PTR th32HeapID)
/*++

Routine Description:

    Retrieves information about the first block of a heap that has been
    allocated by a Win32 process.  Also, create a snapshot of that heap so
    the Heap32Next functions can walk them.

Arguments:

    lphe - Returns a HEAPENTRY32 structure.  The calling application must set
        the dwSize member to the size, in bytes, of the structure.

    th32ProcessID - Supplies the identifier of the Win32 process context that
        owns the heap.

    th32HeapID - Supplies the identifier of the heap to enumerate.

Return Value:

    Returns TRUE if information for the first heap block has been copied to the buffer
    or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function if the heap is invalid or empty.

Notes:

    since there is no way to save heap snapshots or delete heap snapshots in any way that
    makes sense (because this info is not associated with snapshots etc), the information
    needs to be generated completely for each call.  This is very expensive, it would be
    a good idea to redesign this API...
    We could try and cheat by preserving snapshots until they are completyely iterated or
    until a new one is taken, etc, but we will just end up with a bunch of memory leaks

--*/
{
    PRTL_DEBUG_INFORMATION ThRawHeapDebugInfo;
    ULONG HeapListCount;
    PRTL_HEAP_ENTRY p;
    PRTL_HEAP_INFORMATION HeapInfo;
    ULONG HeapEntryAddress;
    NTSTATUS Status = 0;
    BOOL retv = FALSE;

    if (!lphe || lphe->dwSize != sizeof(HEAPENTRY32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    //
    // take snapshot
    //

    ThRawHeapDebugInfo = RtlCreateQueryDebugBuffer(0, FALSE);
    if(ThRawHeapDebugInfo == 0)
    {
        return STATUS_UNSUCCESSFUL;
    }
    Status = RtlQueryProcessDebugInformation((HANDLE)LongToHandle(th32ProcessID),
                                          RTL_QUERY_PROCESS_HEAP_SUMMARY |
                                          RTL_QUERY_PROCESS_HEAP_ENTRIES,
                                          ThRawHeapDebugInfo);
    if (!NT_SUCCESS(Status))    {
        RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // query snapshot
    //

    for (HeapListCount = 0;
         HeapListCount < ThRawHeapDebugInfo->Heaps->NumberOfHeaps;
         HeapListCount++) {

        HeapInfo = &ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount];

        if ((ULONG_PTR)HeapInfo->BaseAddress == th32HeapID) {

            p = HeapInfo->Entries;

            lphe->dwResvd = 0;
            lphe->dwLockCount = 0;
            lphe->th32HeapID = th32HeapID;
            lphe->th32ProcessID = th32ProcessID;
            lphe->hHandle = (HANDLE)th32HeapID;// try this way

            // walk up to first non-segment block (I am assuming there is always one)
            // skip segments - can you have 2 in a row?
            // is first block always a segment?
            // We translate the heap flags to the most appropriate LF32_xxx values
            while(RTL_HEAP_SEGMENT & p->Flags)  {
                lphe->dwAddress = (ULONG_PTR)p->u.s2.FirstBlock + ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].EntryOverhead;    // reset this
                ++lphe->dwResvd;
                ++p;
            }

            //
            // munge flags
            //

            //----------------------------------------------
            if ((p->Flags & RTL_HEAP_BUSY)                ||
                (p->Flags & RTL_HEAP_SETTABLE_VALUE)      ||
                (p->Flags & RTL_HEAP_SETTABLE_FLAG2)      ||
                (p->Flags & RTL_HEAP_SETTABLE_FLAG3)      ||
                (p->Flags & RTL_HEAP_SETTABLE_FLAGS)      ||
                (p->Flags & RTL_HEAP_PROTECTED_ENTRY)
                ) {
                lphe->dwFlags = LF32_FIXED;
            }
            else if ( p->Flags & RTL_HEAP_SETTABLE_FLAG1) {
                lphe->dwFlags = LF32_MOVEABLE;
            }
            else if ( p->Flags & RTL_HEAP_UNCOMMITTED_RANGE) {
                lphe->dwFlags = LF32_FREE;
            }
            //----------------------------------------------

            lphe->dwBlockSize = p->Size;
            retv = TRUE;
            break;
        }
    }

    //
    // free snapshot
    //

    RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);

    return retv;

}


BOOL
WINAPI
Heap32Next(
   IN OUT LPHEAPENTRY32 lphe)
/*++

Routine Description:

    Retrieves information about the next block of a heap that has been
    allocated by a Win32 process.

Arguments:

    lphe - Returns a HEAPENTRY32 structure.  The calling application must set
        the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if information about the next block in the heap has been
    copied to the buffer or FALSE otherwise. The ERROR_NO_MORE_FILES error
    value is returned by the GetLastError function when no more objects in
    the heap exist.

note:

    this function can be prone to error since the heap can change between
    calls to get heaplists, Heap32First, etc.  There is no good way to
    manage a snapshot using this model, so we just get to live with it.

--*/
{
    PRTL_DEBUG_INFORMATION ThRawHeapDebugInfo;
    PRTL_HEAP_ENTRY p;
    PRTL_HEAP_INFORMATION HeapInfo;
    ULONG HeapListCount;
    BOOL retv = FALSE;
    BOOL hit_seg = FALSE;
    NTSTATUS Status = 0;

    if (!lphe || lphe->dwSize != sizeof(HEAPENTRY32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    //
    // take snapshot
    //

    ThRawHeapDebugInfo = RtlCreateQueryDebugBuffer(0, FALSE);
    if(ThRawHeapDebugInfo == 0)
    {
        return STATUS_UNSUCCESSFUL;
    }
    Status = RtlQueryProcessDebugInformation((HANDLE)LongToHandle(lphe->th32ProcessID),
                                          RTL_QUERY_PROCESS_HEAP_SUMMARY |
                                          RTL_QUERY_PROCESS_HEAP_ENTRIES,
                                          ThRawHeapDebugInfo);
    if (!NT_SUCCESS(Status))    {
        RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // get index to correct heap list heap list - th32HeapID / baseadress
    //

    for (HeapListCount = 0; HeapListCount < ThRawHeapDebugInfo->Heaps->NumberOfHeaps; ++HeapListCount)
    {
        if((ULONG_PTR)ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].BaseAddress == lphe->th32HeapID)
        {
            break;
        }
    }

    //
    // ran out of heaps
    //

    if(HeapListCount >= ThRawHeapDebugInfo->Heaps->NumberOfHeaps)
    {
        RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    //
    // check for last entry
    //

    ++lphe->dwResvd;    // point to next one

    if(lphe->dwResvd >= ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].NumberOfEntries)
    {
        RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    //
    // point to correct heap entry - index of this is kept in lphe->dwResvd
    //
    p = (PRTL_HEAP_ENTRY)&ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].Entries[lphe->dwResvd];

    // keep segments in lphe->hHandle
    while(RTL_HEAP_SEGMENT & p->Flags)  {
        lphe->dwAddress = (ULONG_PTR)p->u.s2.FirstBlock + ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].EntryOverhead;// reset this
        if(lphe->dwResvd >= ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].NumberOfEntries)
        {
            RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
            SetLastError(ERROR_NO_MORE_FILES);
            return FALSE;
        }
        ++lphe->dwResvd;
        ++p;
        hit_seg = TRUE;
    }

    //
    // calculate the address
    // normally, we could add the size of the previous block to the existing (last) address
    // to get the current address, but this is only for blocks that do not follow a segment
    // I am assuming that there will always be a segment first
    // current address = last address() + last size
    // by the time we reach this point, either we have just exited from scannin a segment, or
    // p-> is pointing at a non-segment entry.
    //

    if(hit_seg == FALSE)
    {
        lphe->dwAddress += lphe->dwBlockSize;
    }

    lphe->dwBlockSize = p->Size;

    //
    // munge flags
    //

    // We translate the heap flags to the most appropriate LF32_xxx values
    //----------------------------------------------
    if( (p->Flags & RTL_HEAP_BUSY)                ||
        (p->Flags & RTL_HEAP_SETTABLE_VALUE)      ||
        (p->Flags & RTL_HEAP_SETTABLE_FLAG2)      ||
        (p->Flags & RTL_HEAP_SETTABLE_FLAG3)      ||
        (p->Flags & RTL_HEAP_SETTABLE_FLAGS)      ||
        (p->Flags & RTL_HEAP_PROTECTED_ENTRY)
        ) {
        lphe->dwFlags = LF32_FIXED;
    }
    else if( p->Flags & RTL_HEAP_SETTABLE_FLAG1) {
        lphe->dwFlags = LF32_MOVEABLE;
    }
    else if( p->Flags & RTL_HEAP_UNCOMMITTED_RANGE) {
        lphe->dwFlags = LF32_FREE;
    }
    //----------------------------------------------

    retv = TRUE;

    //
    // free snapshot
    //

    RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);

    return(retv);
}


BOOL
WINAPI
Toolhelp32ReadProcessMemory(
   IN DWORD th32ProcessID,
   IN LPCVOID lpBaseAddress,
   OUT PUCHAR lpBuffer,
   IN SIZE_T cbRead,
   OUT SIZE_T *lpNumberOfBytesRead)
/*++

Routine Description:

    Copies memory allocated to another process into an application-supplied
    buffer.  This function is for people who are to lazy to open
    the process themselves.

Arguments:

    th32ProcessID - Supplies the Identifier of the Win32 process whose memory
        is being copied. This parameter can be zero to copy the memory of the
        current process.

    lpBaseAddress - Supplies the base address in the specified process to read.
        Before transferring any data, the system verifies that all data in the
        base address and memory of the specified size is accessible for read
        access. If this is the case, the function proceeds. Otherwise, the
        function fails.

    lpBuffer - Returns the requested data

    cbRead - Supplies the number of bytes to read from the specified process.

    lpNumberOfBytesRead - Returns the number of bytes copied to the buffer. If
        this parameter is NULL, it is ignored.

Return Value:

    Returns TRUE if successful.

--*/
{
    HANDLE hProcess;
    BOOL RetVal;

    hProcess = OpenProcess(PROCESS_VM_READ, FALSE, th32ProcessID);
    if (hProcess == NULL) {
        return FALSE;
    }

    RetVal = ReadProcessMemory(hProcess,
                               lpBaseAddress,
                               lpBuffer,
                               cbRead,
                               lpNumberOfBytesRead);

    CloseHandle(hProcess);
    return RetVal;
}


BOOL
WINAPI
Process32FirstW(
   IN HANDLE SnapSection,
   IN OUT LPPROCESSENTRY32W lppe)
/*++

Routine Description:

    Retrieves information about the first Win32 process encountered in a system
    snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lppe - Returns a PROCESSENTRY32W structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the process list has been copied to the buffer
    or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function if no processes exist or the snapshot does not contain
    process information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    BOOL    retv = FALSE;

    if (!lppe || lppe->dwSize != sizeof(PROCESSENTRY32W)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ProcessCount == 0) {
        memset((PUCHAR)lppe + 4, 0, lppe->dwSize - 4);
        SetLastError(ERROR_NO_MORE_FILES);
    } else {
        memcpy(lppe,
               (LPPROCESSENTRY32W)((ULONG_PTR)SnapshotBase + (ULONG_PTR)SnapshotBase->ProcessListHead),
               sizeof(PROCESSENTRY32W));
        SnapshotBase->ProcessListIndex = 1;
        retv = TRUE;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return retv;
}

BOOL
WINAPI
Process32First(
   IN HANDLE SnapSection,
   IN OUT LPPROCESSENTRY32 lppe)
/*++

Routine Description:

    ANSI version of Process32FirstW.

    Retrieves information about the first Win32 process encountered in a system
    snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lppe - Returns a PROCESSENTRY32 structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the process list has been copied to the buffer
    or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function if no processes exist or the snapshot does not contain
    process information.

--*/
{
    PROCESSENTRY32W pe32w;
    BOOL b;

    if (lppe == NULL || (lppe->dwSize < sizeof(PROCESSENTRY32))) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    // Thunk to Process32FirstW
    pe32w.dwSize = sizeof(pe32w);
    b = Process32FirstW(SnapSection,&pe32w);

    WideCharToMultiByte(CP_ACP, 0,
                        pe32w.szExeFile, -1,
                        lppe->szExeFile, ARRAYSIZE(lppe->szExeFile),
                        0, 0);

    lppe->cntUsage = pe32w.cntUsage;    // meaningless on NT, copy anyway
    lppe->th32ProcessID = pe32w.th32ProcessID;
    lppe->th32DefaultHeapID = pe32w.th32DefaultHeapID;
    lppe->th32ModuleID = pe32w.th32ModuleID;
    lppe->cntThreads = pe32w.cntThreads;
    lppe->th32ParentProcessID = pe32w.th32ParentProcessID;
    lppe->pcPriClassBase = pe32w.pcPriClassBase;
    lppe->dwFlags = pe32w.dwFlags;

    return b;
}


BOOL
WINAPI
Process32NextW(
   IN HANDLE SnapSection,
   IN OUT LPPROCESSENTRY32W lppe)
/*++

Routine Description:

    Retrieves information about the next Win32 process recorded in a system snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lppe - Returns a PROCESSENTRY32W structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the process list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no processes exist or the snapshot does not contain process information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    BOOL    retv = FALSE;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;

    if (!lppe || lppe->dwSize != sizeof(PROCESSENTRY32W)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ProcessListIndex < SnapshotBase->ProcessCount) {
        memcpy(lppe,
               (LPPROCESSENTRY32W)((ULONG_PTR)SnapshotBase + (ULONG_PTR)(&SnapshotBase->ProcessListHead[SnapshotBase->ProcessListIndex++])),
               sizeof(PROCESSENTRY32W));
        retv = TRUE;
    } else {
        SetLastError(ERROR_NO_MORE_FILES);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return retv;
}

BOOL
WINAPI
Process32Next(
   IN HANDLE SnapSection,
   IN OUT LPPROCESSENTRY32 lppe)
/*++

Routine Description:

    ANSI version of Process32NextW

    Retrieves information about the next Win32 process recorded in a system snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lppe - Returns a PROCESSENTRY32 structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the process list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no processes exist or the snapshot does not contain process information.

--*/
{
    PROCESSENTRY32W pe32w;
    BOOL b;

    if (lppe == NULL || (lppe->dwSize < sizeof(PROCESSENTRY32))) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    // Thunk to Process32NextW
    pe32w.dwSize = sizeof(pe32w);
    b = Process32NextW(SnapSection,&pe32w);

    WideCharToMultiByte(CP_ACP, 0,
                        pe32w.szExeFile, -1,
                        lppe->szExeFile, ARRAYSIZE(lppe->szExeFile),
                        0, 0);

    lppe->cntUsage = pe32w.cntUsage;    // meaningless on NT, copy anyway
    lppe->th32ProcessID = pe32w.th32ProcessID;
    lppe->th32DefaultHeapID = pe32w.th32DefaultHeapID;
    lppe->th32ModuleID = pe32w.th32ModuleID;
    lppe->cntThreads = pe32w.cntThreads;
    lppe->th32ParentProcessID = pe32w.th32ParentProcessID;
    lppe->pcPriClassBase = pe32w.pcPriClassBase;
    lppe->dwFlags = pe32w.dwFlags;

    return b;
}


BOOL
WINAPI
Thread32First(
   IN HANDLE SnapSection,
   IN OUT LPTHREADENTRY32 lpte)
/*++

Routine Description:

    Retrieves information about the first thread of any Win32 process
    encountered in a system snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous
        call to the CreateToolhelp32Snapshot function.

    lpte - Returns a THREADENTRY32 structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the thread list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no threads exist or the snapshot does not contain thread information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    BOOL    retv = FALSE;

    if (!lpte || lpte->dwSize != sizeof(THREADENTRY32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ThreadCount == 0) {
        memset((PUCHAR)lpte + 4, 0, lpte->dwSize - 4);
        SetLastError(ERROR_NO_MORE_FILES);
    } else {
        memcpy(lpte,
               (LPTHREADENTRY32)((ULONG_PTR)SnapshotBase + (ULONG_PTR)SnapshotBase->ThreadListHead),
               sizeof(THREADENTRY32));
               SnapshotBase->ThreadListIndex = 1;
        retv = TRUE;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return(retv);
}


BOOL
WINAPI
Thread32Next(
   IN HANDLE SnapSection,
   IN OUT LPTHREADENTRY32 lpte)
/*++

Routine Description:

    Retrieves information about the next thread of any Win32 process encountered in the
    system memory snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lpte - Reeturns a THREADENTRY32 structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the thread list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no threads exist or the snapshot does not contain thread information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    BOOL    retv = FALSE;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;

    if (!lpte || lpte->dwSize != sizeof(THREADENTRY32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ThreadListIndex < SnapshotBase->ThreadCount) {
        memcpy(lpte,
               (PTHREADENTRY32)((ULONG_PTR)SnapshotBase + (ULONG_PTR)(&SnapshotBase->ThreadListHead[SnapshotBase->ThreadListIndex++])),
               sizeof(THREADENTRY32));
        retv = TRUE;
    } else {
        SetLastError(ERROR_NO_MORE_FILES);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return(retv);
}


BOOL
WINAPI
Module32FirstW(
   IN HANDLE SnapSection,
   IN OUT LPMODULEENTRY32W lpme)
/*++

Routine Description:

    Retrieves information about the first module associated with a Win32 process.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lpme - Returns a buffer containing a MODULEENTRY32W structure.  The caller
        must set the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the module list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no modules exist or the snapshot does not contain module information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    BOOL    retv = FALSE;

    if (!lpme || lpme->dwSize != sizeof(MODULEENTRY32W)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ModuleCount == 0) {
        memset((PUCHAR)lpme + 4, 0, lpme->dwSize - 4);
        SetLastError(ERROR_NO_MORE_FILES);
    } else {
        memcpy(lpme,
               (PMODULEENTRY32W)((ULONG_PTR)SnapshotBase + (ULONG_PTR)SnapshotBase->ModuleListHead),
               sizeof(MODULEENTRY32W));
        SnapshotBase->ModuleListIndex = 1;
        retv = TRUE;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return retv;
}

BOOL
WINAPI
Module32First(
   IN HANDLE SnapSection,
   IN OUT LPMODULEENTRY32 lpme)
/*++

Routine Description:

    ANSI version of Module32FirstW.

    Retrieves information about the first module associated with a Win32 process.

Arguments:

    SnapSection - Supplies the handle of the snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lpme - Returns a buffer containing a MODULEENTRY32 structure.  The caller
        must set the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the module list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no modules exist or the snapshot does not contain module information.

--*/
{
    MODULEENTRY32W me32w;
    DWORD dwSizeToCopy;
    BOOL b;

    if (lpme == NULL || (lpme->dwSize < sizeof(MODULEENTRY32))) {
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
    }

    // Thunk to Module32FirstW
    me32w.dwSize = sizeof(me32w);
    b = Module32FirstW(SnapSection,&me32w);

    WideCharToMultiByte(CP_ACP, 0,
                        me32w.szExePath, -1,
                        lpme->szExePath, ARRAYSIZE(lpme->szExePath),
                        0, 0);

    WideCharToMultiByte(CP_ACP, 0,
                        me32w.szModule, -1,
                        lpme->szModule, ARRAYSIZE(lpme->szModule),
                        0, 0);

    lpme->th32ModuleID  = me32w.th32ModuleID;
    lpme->th32ProcessID = me32w.th32ProcessID;
    lpme->GlblcntUsage  = me32w.GlblcntUsage;
    lpme->ProccntUsage  = me32w.ProccntUsage;
    lpme->modBaseAddr   = me32w.modBaseAddr;
    lpme->modBaseSize   = me32w.modBaseSize;
    lpme->hModule       = me32w.hModule;

    return b;
}


BOOL
WINAPI
Module32NextW(
   IN HANDLE SnapSection,
   IN OUT LPMODULEENTRY32W lpme)
/*++

Routine Description:

    Retrieves information about the next module associated with a Win32 process or thread.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to CreateToolhelp32Snapshot.

    lpme - Returns a MODULEENTRY32W structure.  The calling application must set
        the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the module list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no more modules exist.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    BOOL    retv = FALSE;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;

    if (!lpme || lpme->dwSize != sizeof(MODULEENTRY32W)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ModuleListIndex < SnapshotBase->ModuleCount) {
        memcpy(lpme,
               (LPMODULEENTRY32W)((ULONG_PTR)SnapshotBase + (ULONG_PTR)(&SnapshotBase->ModuleListHead[SnapshotBase->ModuleListIndex++])),
               sizeof(MODULEENTRY32W));
        retv = TRUE;
    } else {
        SetLastError(ERROR_NO_MORE_FILES);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return(retv);
}


BOOL
WINAPI
Module32Next(
   IN HANDLE SnapSection,
   IN OUT LPMODULEENTRY32 lpme)
/*++

Routine Description:

    ANSI version of Module32NextW.

    Retrieves information about the next module associated with a Win32 process or thread.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to CreateToolhelp32Snapshot.

    lpme - Returns a MODULEENTRY32 structure.  The calling application must set
        the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the module list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no more modules exist.

--*/
{
    MODULEENTRY32W me32w;
    BOOL b;

    if (lpme == NULL || (lpme->dwSize < sizeof(MODULEENTRY32))) {
         SetLastError(ERROR_INVALID_DATA);
         return FALSE;
    }

    // Thunk to Module32NextW
    me32w.dwSize = sizeof(me32w);
    b = Module32NextW(SnapSection,&me32w);

    WideCharToMultiByte(CP_ACP, 0,
                        me32w.szModule, -1,
                        lpme->szModule, ARRAYSIZE(lpme->szModule),
                        0, 0);

    WideCharToMultiByte(CP_ACP, 0,
                        me32w.szExePath, -1,
                        lpme->szExePath, ARRAYSIZE(lpme->szExePath),
                        0, 0);

    lpme->th32ModuleID  = me32w.th32ModuleID;
    lpme->GlblcntUsage  = me32w.GlblcntUsage;
    lpme->ProccntUsage  = me32w.ProccntUsage;
    lpme->modBaseAddr   = me32w.modBaseAddr;
    lpme->modBaseSize   = me32w.modBaseSize;
    lpme->hModule       = me32w.hModule;

    return b;
}

NTSTATUS
ThpCreateRawSnap(
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    PUCHAR *RawProcess,
    PRTL_DEBUG_INFORMATION *RawModule,
    PRTL_DEBUG_INFORMATION *RawDebugInfo)
/*++

Routine Description:

    This function gets raw snapshots for the data types specified by dwFlags.

Arguments:

    th32ProcessID - Supplies a WIN32 process ID.  See CreateToolhelp32Snapshot
        for full description.

    dwFlags - Supplies switches requesting various data.  See
        CreateToolhelp32Snapshot for full description

Return Value:

    NTSTATUS as appropriate

--*/
{
    NTSTATUS Status = 0;
    ULONG BufferSize = BUFFER_SIZE;
    SIZE_T stBufferSize = BUFFER_SIZE;

    //
    // get process/thread/module/heap info
    //

    *RawProcess = NULL;
    *RawModule = NULL;
    *RawDebugInfo = NULL;

    if((dwFlags & TH32CS_SNAPPROCESS) || (dwFlags & TH32CS_SNAPTHREAD)){
        do {
            try {
                stBufferSize = BufferSize;
                Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                                 RawProcess,
                                                 0,
                                                 &stBufferSize,
                                                 MEM_COMMIT,
                                                 PAGE_READWRITE);
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                Status = GetExceptionCode();
            }

            if (!NT_SUCCESS(Status)) {
                break;
            }

            BufferSize = (ULONG)stBufferSize;
            //
            // get all of the status information */
            //
            Status = NtQuerySystemInformation(SystemProcessInformation,
                      *RawProcess,
                      BufferSize,
                      NULL);

            if (Status == STATUS_INFO_LENGTH_MISMATCH)   {
                NtFreeVirtualMemory(NtCurrentProcess(),
                                    RawProcess,
                                    &stBufferSize,
                                    MEM_RELEASE);
                *RawProcess = NULL;
                BufferSize += 8192;
            }

        } while(Status == STATUS_INFO_LENGTH_MISMATCH);
    }

    //
    // get module information
    //

    if((dwFlags & TH32CS_SNAPMODULE) || (dwFlags & TH32CS_SNAPMODULE32))
    {
        if (NT_SUCCESS(Status))    {
            *RawModule = RtlCreateQueryDebugBuffer(0, FALSE);
            if (!*RawModule) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }

        if (NT_SUCCESS(Status)) {
            Status = RtlQueryProcessDebugInformation((HANDLE)LongToHandle(th32ProcessID),
                                                     RTL_QUERY_PROCESS_NONINVASIVE |
                                                     ((dwFlags & TH32CS_SNAPMODULE) ? RTL_QUERY_PROCESS_MODULES : 0) |
                                                     ((dwFlags & TH32CS_SNAPMODULE32) ? RTL_QUERY_PROCESS_MODULES32 : 0),
                                                      *RawModule);
        }
    }

    //
    // get the heap summary information for the specified process */
    //

    if (dwFlags & TH32CS_SNAPHEAPLIST)   {
        if (NT_SUCCESS(Status))    {

            *RawDebugInfo = RtlCreateQueryDebugBuffer(0, FALSE);
            if (!*RawDebugInfo) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
        if (NT_SUCCESS(Status)) {
            Status = RtlQueryProcessDebugInformation((HANDLE)LongToHandle(th32ProcessID),
                                                      RTL_QUERY_PROCESS_HEAP_SUMMARY,
                                                      *RawDebugInfo);
        }
    }


    if (!NT_SUCCESS(Status))    {
        if (*RawProcess) {
            SIZE_T Size = 0;
            NtFreeVirtualMemory(NtCurrentProcess(),
                                RawProcess,
                                &Size,
                                MEM_RELEASE);
            *RawProcess = NULL;
        }
        if (*RawModule) {
            RtlDestroyQueryDebugBuffer(*RawModule);
            *RawModule = NULL;
        }
        if (*RawDebugInfo) {
            RtlDestroyQueryDebugBuffer(*RawDebugInfo);
            *RawDebugInfo = NULL;
        }
    }

    return Status;
}


NTSTATUS
ThpAllocateSnapshotSection(
    OUT PHANDLE SnapSection,
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    PUCHAR RawProcess,
    PRTL_DEBUG_INFORMATION RawModule,
    PRTL_DEBUG_INFORMATION RawDebugInfo)
/*++

Routine Description:

    This function calculates the size of the snapshot and allocates a
    file mapping object for it in the pagefile.
    Also, initialize snapshot information in the header

Arguments:

    th32ProcessID - Supplies a WIN32 process ID.  See CreateToolhelp32Snapshot
        for full description.

    dwFlags - Supplies switches describing requested data.  See
        CreateToolhelp32Snapshot for full description.

    th32ProcessID -

    RawProcess -

    RawDebugInfo -

Return Value:

    Handle to to the mapping object if successful, -1 otherwise

--*/
{
    NTSTATUS Status = 0;
    PSNAPSHOTSTATE SnapshotBase;
    SECURITY_ATTRIBUTES SecurityAttributes;
    LPSECURITY_ATTRIBUTES lpSecurityAttributes;
    ULONG SnapShotSize;
    ULONG Offset1;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    LARGE_INTEGER SectionOffset;
    LARGE_INTEGER SectionSize;
    SIZE_T ViewSize;
    SIZE_T Size;
    ULONG ProcessCount = 0;
    ULONG HeapListCount = 0;
    ULONG ModuleCount = 0;
    ULONG ThreadCount = 0;

    SnapShotSize = sizeof(SNAPSHOTSTATE);

    Offset1 = 0;

    //
    // calculate the required snapshot size
    //

    if ((dwFlags & TH32CS_SNAPPROCESS) || (dwFlags & TH32CS_SNAPTHREAD)) {
        do {
            ProcessCount++;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&RawProcess[Offset1];
            Offset1 += ProcessInfo->NextEntryOffset;
            ThreadCount += ProcessInfo->NumberOfThreads;
        } while (ProcessInfo->NextEntryOffset != 0);

        if (dwFlags & TH32CS_SNAPPROCESS) {
            SnapShotSize += ProcessCount * sizeof(PROCESSENTRY32W);
        }
        if (dwFlags & TH32CS_SNAPTHREAD) {
            SnapShotSize += ThreadCount * sizeof(THREADENTRY32);
        }
    }

    if (dwFlags & TH32CS_SNAPMODULE) {
        SnapShotSize += RawModule->Modules->NumberOfModules * sizeof(MODULEENTRY32W);
        ModuleCount = RawModule->Modules->NumberOfModules;
    }

    if (dwFlags & TH32CS_SNAPHEAPLIST)   {
        SnapShotSize += RawDebugInfo->Heaps->NumberOfHeaps * sizeof(HEAPLIST32);
        HeapListCount = RawDebugInfo->Heaps->NumberOfHeaps;
    }

    //
    // Create a security object if needed
    //

    if (dwFlags & TH32CS_INHERIT) {
        SecurityAttributes.lpSecurityDescriptor = NULL;
        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttributes.bInheritHandle = TRUE;
        lpSecurityAttributes = &SecurityAttributes;
    } else {
        lpSecurityAttributes = NULL;
    }

    //
    // create a pagefile section to contain the snapshot
    //

    pObja = BaseFormatObjectAttributes(&Obja, lpSecurityAttributes, NULL);

    SectionSize.LowPart = SnapShotSize;
    SectionSize.HighPart = 0;

    Status = NtCreateSection(SnapSection,
                STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
                pObja,
                &SectionSize,
                PAGE_READWRITE,
                SEC_COMMIT,
                NULL);

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(*SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    //
    // free all memory if failure
    //

    if ( !NT_SUCCESS(Status) ) {
        CloseHandle(*SnapSection);

        if ((dwFlags & TH32CS_SNAPTHREAD) || (dwFlags & TH32CS_SNAPPROCESS)){

        Size = 0;
        NtFreeVirtualMemory(NtCurrentProcess(),
                            &RawProcess,
                            &Size,
                            MEM_RELEASE);

        }

        if (dwFlags & TH32CS_SNAPPROCESS) {
            RtlDestroyQueryDebugBuffer(RawModule);
        }

        if (dwFlags & TH32CS_SNAPHEAPLIST) {
            RtlDestroyQueryDebugBuffer(RawDebugInfo);
        }

        return Status;
    }

    SnapshotBase->ProcessCount  = ProcessCount;
    SnapshotBase->HeapListCount = HeapListCount;
    SnapshotBase->ModuleCount   = ModuleCount;
    SnapshotBase->ThreadCount   = ThreadCount;

    //
    // return resources
    //

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return STATUS_SUCCESS;
}


NTSTATUS
ThpCopyAnsiToUnicode(
    PWCHAR Dest,
    PUCHAR Src,
    USHORT Max)
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    UnicodeString.Buffer = Dest;
    UnicodeString.MaximumLength = Max;

    RtlInitAnsiString(&AnsiString, Src);

    return RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
}


NTSTATUS
ThpProcessToSnap(
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    IN HANDLE SnapSection,
    PUCHAR RawProcess,
    PRTL_DEBUG_INFORMATION RawModule,
    PRTL_DEBUG_INFORMATION RawDebugInfo)
/*++

Routine Description:

    This function processes the data in the raw dumps specified by dwFlage into
    a mapped file.

Arguments:

    dwFlags - Supplies switches describing the data requested.  See
        CreateToolhelp32Snapshot for full description.

    th32ProcessID - Supplies a WIN32 process ID. See CreateToolhelp32Snapshot
        for full description.

    SnapSection - Supplies handle to section allocated by ThpAllocateSnapshotSection.

    RawProcess -

    RawDebugInfo -

Return Value:

    TRUE if successful, FALSE if there was a problem encountered

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    PUCHAR BufferWriteAddr;  /* working pointer into out process data - usually points at end */
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    SIZE_T Size;

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    BufferWriteAddr = &SnapshotBase->DataBegin;

    //
    // write heap list to snapshot
    // some of this code adapted from dh.c
    //
    if (dwFlags & TH32CS_SNAPHEAPLIST) {
        ULONG HeapListCount = 0;
        ULONG HeapEntryCount = 0;
        LPHEAPLIST32 pHeapList;

        SnapshotBase->HeapListHead = (PHEAPLIST32)(BufferWriteAddr - (PUCHAR)SnapshotBase);
        pHeapList = (LPHEAPLIST32)BufferWriteAddr;

        // heaplist
        for (HeapListCount = 0; HeapListCount < SnapshotBase->HeapListCount; HeapListCount++){
            pHeapList->dwSize = sizeof(HEAPLIST32);
            pHeapList->th32ProcessID = th32ProcessID;
            /* handle = baseaddress = ID we will use internally */
            pHeapList->th32HeapID = (ULONG_PTR)RawDebugInfo->Heaps->Heaps[HeapListCount].BaseAddress;
            pHeapList->dwFlags = RawDebugInfo->Heaps->Heaps[HeapListCount].Flags;
            ++pHeapList;
        }
        // update the pointer to the write area
        BufferWriteAddr = (PCHAR)(BufferWriteAddr + HeapListCount * sizeof(HEAPLIST32));
        RtlDestroyQueryDebugBuffer(RawDebugInfo);
    }

    //
    // write module list to snapshot
    //
    if (dwFlags & TH32CS_SNAPMODULE) {
        LPMODULEENTRY32W pModule;
        ULONG Offset1 = 0;
        ULONG mCount = 0;
        PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;

        SnapshotBase->ModuleListHead = (PMODULEENTRY32W)(BufferWriteAddr - (PUCHAR)SnapshotBase);

        //
        // get module info from buffer
        //

        pModule = (LPMODULEENTRY32W)(BufferWriteAddr);
        ModuleInfo = &RawModule->Modules->Modules[ 0 ];
        for (mCount = 0; mCount < RawModule->Modules->NumberOfModules; mCount++)   {

            pModule->dwSize = sizeof(MODULEENTRY32W);

            pModule->th32ProcessID = th32ProcessID;

            //
            // base == handle
            //

            pModule->hModule = ModuleInfo->ImageBase;

            //
            // Base address of module in th32ProcessID's context
            //

            pModule->modBaseAddr = ModuleInfo->ImageBase;

            //
            // Path
            //

            ThpCopyAnsiToUnicode(pModule->szExePath,
                                 ModuleInfo->FullPathName,
                                 sizeof(pModule->szExePath));

            //
            // module name
            //

            ThpCopyAnsiToUnicode(pModule->szModule,
                                 &ModuleInfo->FullPathName[ModuleInfo->OffsetToFileName],
                                 sizeof(pModule->szModule));

            //
            // Size in bytes of module starting at modBaseAddr
            //

            pModule->modBaseSize = ModuleInfo->ImageSize;


            //
            // these are meaningless on NT
            // but some apps may care... Gruntz (bugid 327009)
            // was failing because th32ModuleID was 0, so
            // now we stick in the address of the Module descriptor
            //
            // However it turns out that a pointer doesn't fit in a DWORD,
            // so we stick in the value 1 instead.
            //

            pModule->th32ModuleID = 1;
            pModule->GlblcntUsage = ModuleInfo->LoadCount;  // will be 0xffff
            pModule->ProccntUsage = ModuleInfo->LoadCount;  // will be 0xffff

            ++ModuleInfo;
            ++pModule;
        }

        //
        // update the pointer to the write area
        //
        BufferWriteAddr = (PCHAR)(BufferWriteAddr + mCount * sizeof(MODULEENTRY32W));
        RtlDestroyQueryDebugBuffer(RawModule);
    }

    //
    // write process list to snapshot
    //
    if (dwFlags & TH32CS_SNAPPROCESS) {

        PSYSTEM_PROCESS_INFORMATION ProcessInfo;
        LPPROCESSENTRY32W pEntry;
        ULONG cProcess = 0;
        ULONG Offset1 = 0;

        SnapshotBase->ProcessListHead = (PPROCESSENTRY32W)(BufferWriteAddr - (PUCHAR)SnapshotBase);
        pEntry = (LPPROCESSENTRY32W)(BufferWriteAddr + cProcess * sizeof(PROCESSENTRY32W));

        do {
            /* get process info from buffer */
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&RawProcess[Offset1];

            pEntry->dwSize              = sizeof(PROCESSENTRY32W);
            pEntry->th32ProcessID       = HandleToUlong(ProcessInfo->UniqueProcessId);
            pEntry->pcPriClassBase      = ProcessInfo->BasePriority;
            pEntry->cntThreads          = ProcessInfo->NumberOfThreads;
            pEntry->th32ParentProcessID = HandleToUlong(ProcessInfo->InheritedFromUniqueProcessId);
            pEntry->cntUsage            = 0;
            pEntry->th32DefaultHeapID   = 0;
            pEntry->th32ModuleID        = 0;
            pEntry->dwFlags             = 0;

            // Path
            if (ProcessInfo->ImageName.Buffer == NULL) {
                lstrcpyW(pEntry->szExeFile, L"[System Process]");
            } else {
                if (ProcessInfo->ImageName.Length >= ARRAYSIZE(pEntry->szExeFile)) {
                    ProcessInfo->ImageName.Length = ARRAYSIZE(pEntry->szExeFile)-1;
                }
                memcpy(pEntry->szExeFile, ProcessInfo->ImageName.Buffer, ProcessInfo->ImageName.Length);
                pEntry->szExeFile[ProcessInfo->ImageName.Length] = TEXT('\0');
            }

            Offset1 += ProcessInfo->NextEntryOffset;
            ++cProcess;
            ++pEntry;

        } while (ProcessInfo->NextEntryOffset != 0);

        // update the pointer to the write area
        BufferWriteAddr = (PCHAR)(BufferWriteAddr + cProcess * sizeof(PROCESSENTRY32W));
    }

    //
    // write thread list to snapshot
    //

    if (dwFlags & TH32CS_SNAPTHREAD) {
        PSYSTEM_PROCESS_INFORMATION ProcessInfo;
        PSYSTEM_THREAD_INFORMATION ThreadInfo;
        LPTHREADENTRY32 tEntry;
        ULONG Offset1 = 0;
        ULONG cThread = 0;

        SnapshotBase->ThreadListHead = (PTHREADENTRY32)(BufferWriteAddr - (PUCHAR)SnapshotBase);
        tEntry = (LPTHREADENTRY32)(BufferWriteAddr + cThread * sizeof(THREADENTRY32));

        do {
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&RawProcess[Offset1];
            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

            for (cThread = 0; cThread < ProcessInfo->NumberOfThreads; cThread++) {

                tEntry->dwSize              = sizeof(THREADENTRY32);
                tEntry->th32ThreadID        = HandleToUlong(ThreadInfo->ClientId.UniqueThread);
                tEntry->th32OwnerProcessID  = HandleToUlong(ThreadInfo->ClientId.UniqueProcess);
                tEntry->tpBasePri           = ThreadInfo->BasePriority;
                tEntry->tpDeltaPri          = 0;
                tEntry->cntUsage            = 0;
                tEntry->dwFlags             = 0;

            ++ThreadInfo;
            ++tEntry;
            }

            Offset1 += ProcessInfo->NextEntryOffset;

        } while (ProcessInfo->NextEntryOffset != 0);

        BufferWriteAddr = (PUCHAR)(BufferWriteAddr + cThread * sizeof(THREADENTRY32)); // update the pointer to the write area
    }

    if ((dwFlags & TH32CS_SNAPTHREAD) || (dwFlags & TH32CS_SNAPPROCESS)){

        Size = 0;
        NtFreeVirtualMemory(NtCurrentProcess(),
                            &RawProcess,
                            &Size,
                            MEM_RELEASE);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tmssrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tmslot.c

Abstract:

    Test program to Win32 mailslot API calls

Author:

    Manny Weiser (mannyw) 5-Mar-1991

Revision History:

--*/

#include "stdio.h"
#include "windows.h"

#define BUFFER_SIZE   100

char Buffer[BUFFER_SIZE];

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )

{
    BOOL success;
    HANDLE handle;
    LPSTR mailslotName =  "\\\\.\\mailslot\\asdf";

    DWORD maxMessageSize, nextSize, messageCount, readTimeout;
    DWORD bytesRead;

    handle = CreateMailslot( mailslotName,
                             100,
                             MAILSLOT_WAIT_FOREVER,
                             NULL );

    if (handle == (HANDLE)-1) {
        printf ("Failed to open mailslot ""%s""\n", mailslotName);
        return 1;
    }

    printf ("Successfully opened the mailslot.\n");

    success = SetMailslotInfo( handle,
                               atoi( argv[1] ) );
    if (!success) {
        printf ("Failed to set information for mailslot\n");
        return 1;
    }

    printf ("Set mailslot timeout to %d\n", atoi(argv[1]) );

    success = GetMailslotInfo( handle,
                               &maxMessageSize,
                               &nextSize,
                               &messageCount,
                               &readTimeout );

    if (!success) {
        printf ("Failed to get information for mailslot\n");
        return 1;
    }

    printf ("Max message size  = %d\n", maxMessageSize );
    printf ("Next message size = %d\n", nextSize );
    printf ("Message count     = %d\n", messageCount );
    printf ("Read timeout      = %u\n", readTimeout );

    success = ReadFile( handle,
                        Buffer,
                        BUFFER_SIZE,
                        &bytesRead,
                        NULL );

    if (!success) {
        printf ("Failed to read mailslot\n");
        return 1;
    } else {
        printf ("Successfully read %d bytes '%s'\n", bytesRead, Buffer );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tnpcli.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tnpcli.c

Abstract:

    This program makes simple client calls to tnpsrv.c

Author:

    Colin Watson (ColinW) 19-March-1991

Revision History:

--*/
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

CHAR* WriteData1 = "Hello Mars\n";
CHAR* WriteData2 = "Hello Jupiter\n";

int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE C1;
    DWORD Size;
    DWORD Dummy;
    DWORD Count;
    CHAR Data[1024];
    OVERLAPPED Overlapped;

    printf("Create client...\n");

    C1 = CreateFile("\\\\.\\Pipe\\cw\\testpipe",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,       // Security Attributes
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
    for ( Count = 1; Count < 10; Count++ ) {

        printf("Client Writing...\n");
        if ( FALSE == WriteFile(C1, WriteData1, strlen(WriteData1)+1, &Dummy, NULL) ) {
            printf("Client WriteFile returned Error %lx\n", GetLastError() );
            }

        while (1) {
            printf("Client now Peeking...\n");
            if ( FALSE == PeekNamedPipe(C1,Data, sizeof(Data), &Size, NULL, NULL) ) {
                printf("Client PeekNamedPipe returned Error %lx\n", GetLastError() );
                break;
                }

            if ( Size ) {
                printf("Client PeekNamedPipe Done %lx: %s\n", Size, Data);
                break;
                }
            else {
                printf("Client PeekNamedPipe Done, no data yet, sleep 1 sec\n");
                Sleep(1000);
                }
            }

        printf("Client now Reading...\n");
        if ( FALSE == ReadFile(C1,Data, sizeof(Data), &Size, NULL) ) {
            printf("Client ReadFile returned Error %lx\n", GetLastError() );
            }

        printf("Client Reading Done %lx: %s\n", Size, Data);
        }

    {
        DWORD Flags;
        DWORD OutBufferSize;
        DWORD InBufferSize;
        DWORD MaxInstances;

        printf("Client call GetNamedPipeInfo....\n");

        if ( FALSE == GetNamedPipeInfo(C1, &Flags, &OutBufferSize, &InBufferSize, &MaxInstances) ){
            printf("Client GetNamedPipeInfo returned Error %lx\n", GetLastError() );
            }
        else {
            printf("Flags %lx, OutBufferSize %lx, InBufferSize %lx, MaxInstances %lx\n",
                Flags, OutBufferSize, InBufferSize, MaxInstances);
            }
        }

    {
        DWORD State;
        DWORD CurInstances;

        printf("Client call GetNamedPipeHandleState....\n");

        if ( FALSE == GetNamedPipeHandleState(C1, &State, &CurInstances, NULL, NULL, NULL, 0) ){
            printf("Client GetNamedPipeHandleState returned Error %lx\n", GetLastError() );
            }
        else {
            printf("State %lx, CurInstances %lx\n", State, CurInstances );
            }

        }

    printf("Client attempting 10 second WaitNamedPipe- should timeout...\n");

    if ( FALSE == WaitNamedPipe("\\\\.\\Pipe\\cw\\testpipe", 10000, NULL) ) {
            printf("Client WaitNamedPipe returned Error %lx\n", GetLastError() );
            }

    printf("WaitNamedPipe complete\n");

    printf("Client attempting 10 second WaitNamedPipe- should timeout...\n");

    Overlapped.hEvent = CreateEvent(NULL,TRUE,TRUE);

    if ( FALSE == WaitNamedPipe("\\\\.\\Pipe\\cw\\testpipe", 10000, &Overlapped) ) {
            printf("Client WaitNamedPipe returned Error %lx\n", GetLastError() );
            if ( GetLastError() == ERROR_IO_PENDING ) {
                printf("Server got ERROR_IO_PENDING ok,Waiting for pipe\n");
                assert( FALSE == GetOverlappedResult(NULL , &Overlapped, &Dummy, TRUE ));
                printf("Client WaitNamedPipe returned Error Ok %lx\n", GetLastError() );
                }
            }

    printf("WaitNamedPipe complete\nClient closing...\n");
    CloseHandle(C1);
    printf("Client closed\n");

    printf("Client attempting 10 second WaitNamedPipe- should work...\n");

    if ( FALSE == WaitNamedPipe("\\\\.\\Pipe\\cw\\testpipe", 10000, NULL) ) {
            printf("Client WaitNamedPipe returned Error %lx\n", GetLastError() );
            }

    printf("WaitNamedPipeComplete\n");

    for ( Count = 1; Count < 5; Count++ ) {

        printf("Client CallNamedPipe...\n");

        if ( FALSE == CallNamedPipe(
            "\\\\.\\Pipe\\cw\\testpipe",
            WriteData2,
            strlen(WriteData2)+1,
            Data,
            sizeof(Data),
            &Size,
            10000   // Ten second timeout
            ) ) {
            printf("CallNamedPipe returned Error %lx\n", GetLastError() );
            }
        printf("Client CallNamedPipe Done %lx: %s\n", Size, Data);
        }

    printf("CallNamedPipe complete\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\trd.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tfile.c

Abstract:

    Test program for Win32 Base File API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <memory.h>

#define xassert ASSERT

typedef struct _aio {
    LIST_ENTRY Links;
    HANDLE ReadHandle;
    HANDLE WriteHandle;
    LPVOID Buffer;
    OVERLAPPED Overlapped;
} AIO, *PAIO;

HANDLE IoReadsDoneEvent;
HANDLE IoWritesDoneEvent;
HANDLE IoWorkerListLock;
HANDLE IoWorkerListSemaphore;
LIST_ENTRY IoRequestList;
ULONG IoCount;
ULONG IoReadCount;
ULONG IoWriteCount;
#define BSIZE 2048


VOID
WriteIoComplete(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    )
{
    PAIO paio;

    //
    // If an I/O error occured, display the error and then exit
    //

    if ( dwErrorCode ) {
        printf("FATAL I/O Error %ld I/O Context %lx.%lx\n",
            dwErrorCode,
            lpOverlapped,
            lpOverlapped->hEvent
            );
        ExitProcess(dwErrorCode);
        }
    paio = (PAIO)CONTAINING_RECORD(lpOverlapped,AIO,Overlapped);
    if ( InterlockedDecrement(&IoWriteCount) == 0 ) {
        SetEvent(IoWritesDoneEvent);
        }
    LocalFree(paio->Buffer);
    LocalFree(paio);
}

VOID
ReadIoComplete(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    )
{
    PAIO paio;
    BOOL IoOperationStatus;

    //
    // If an I/O error occured, display the error and then exit
    //

    if ( dwErrorCode ) {
        printf("FATAL I/O Error %ld I/O Context %lx.%lx\n",
            dwErrorCode,
            lpOverlapped,
            lpOverlapped->hEvent
            );
        ExitProcess(dwErrorCode);
        }
    paio = (PAIO)CONTAINING_RECORD(lpOverlapped,AIO,Overlapped);
//printf("%s",paio->Buffer);

    IoOperationStatus = WriteFileEx(
                            paio->WriteHandle,
                            paio->Buffer,
                            dwNumberOfBytesTransfered,
                            &paio->Overlapped,
                            WriteIoComplete
                            );

    //
    // Test to see if I/O was queued successfully
    //

    if ( !IoOperationStatus ) {
        if ( GetLastError() != ERROR_HANDLE_EOF ) {
            printf("FATAL I/O Error %ld\n",
                GetLastError()
                );
            ExitProcess(1);
            }
        }

    if ( InterlockedDecrement(&IoReadCount) == 0 ) {
        SetEvent(IoReadsDoneEvent);
        }
}

VOID
IoWorkerThread(
    PVOID Unused
    )
{
    HANDLE HandleVector[2];
    DWORD CompletionStatus;
    PAIO paio;
    BOOL IoOperationStatus;

    HandleVector[0] = IoWorkerListLock;
    HandleVector[1] = IoWorkerListSemaphore;

    for(;;){

        //
        // Do an alertable wait on the handle vector. Both objects
        // becoming signaled at the same time means there is an
        // I/O request in the queue, and the caller has exclusive
        // access to the queue
        //


        CompletionStatus = WaitForMultipleObjectsEx(
                                2,
                                HandleVector,
                                TRUE,
                                0xffffffff,
                                TRUE
                                );

        //
        // If the wait failed, error out
        //

        if ( CompletionStatus == 0xffffffff ) {
            printf("FATAL WAIT ERROR %ld\n",GetLastError());
            ExitProcess(1);
            }

        //
        // If an I/O completion occured, then wait for another
        // I/O request or I/O completion
        //

        if ( CompletionStatus != WAIT_IO_COMPLETION ) {

            //
            // Wait was satisfied. We now have exclusive ownership of the
            // I/O request queue, and there is something on the queue.
            // Note that to insert something on the queue, the inserter
            // gets the list lock (mutex), inserts an entry, signals the
            // list semaphore, and finally releases the list lock
            //

            paio = (PAIO)RemoveHeadList(&IoRequestList);

            ReleaseMutex(IoWorkerListLock);

            IoOperationStatus = ReadFileEx(
                                    paio->ReadHandle,
                                    paio->Buffer,
                                    paio->Overlapped.Internal,
                                    &paio->Overlapped,
                                    ReadIoComplete
                                    );

            //
            // Test to see if I/O was queued successfully
            //

            if ( !IoOperationStatus ) {
                if ( GetLastError() != ERROR_HANDLE_EOF ) {
                    printf("FATAL I/O Error %ld\n",
                        GetLastError()
                        );
                    ExitProcess(1);
                    }
                }

            //
            // The I/O was successfully queued. Go back into the alertable
            // wait waiting for I/O completion, or for more I/O requests
            //

            }
        }

}

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE iFile,oFile;
    DWORD FileSize;
    PAIO paio;
    DWORD WaitStatus;
    DWORD Offset;
    HANDLE CompletionHandles[2];
    HANDLE Thread;
    DWORD ThreadId;

    if ( argc < 2 ) {
        printf("Usage: trd source-file destination-file\n");
        }

    iFile = CreateFile(
                argv[1],
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_OVERLAPPED,
                NULL
                );
    if ( iFile == INVALID_HANDLE_VALUE ) {
        printf("OPEN %s failed %ld\n",argv[1],GetLastError());
        ExitProcess(1);
        }

    oFile = CreateFile(
                argv[2],
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_FLAG_OVERLAPPED,
                NULL
                );
    if ( oFile == INVALID_HANDLE_VALUE ) {
        printf("OPEN %s failed %ld\n",argv[2],GetLastError());
        ExitProcess(1);
        }

    IoReadsDoneEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    IoWritesDoneEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    IoWorkerListLock = CreateMutex(NULL,FALSE,NULL);;
    IoWorkerListSemaphore = CreateSemaphore(NULL,0,0x7fffffff,NULL);
    xassert(IoReadsDoneEvent);
    xassert(IoWritesDoneEvent);
    xassert(IoWorkerListLock);
    xassert(IoWorkerListSemaphore);
    InitializeListHead(&IoRequestList);

    Thread = CreateThread(NULL,0L,IoWorkerThread,0,0,&ThreadId);
    xassert(Thread);

    Offset = 0;
    FileSize = GetFileSize(iFile,NULL);

    WaitStatus = WaitForSingleObject(IoWorkerListLock,-1);
    xassert(WaitStatus == 0);

    while(FileSize >= BSIZE) {
        FileSize -= BSIZE;
        paio = LocalAlloc(LMEM_ZEROINIT,sizeof(*paio));
        xassert(paio);
        paio->Buffer = LocalAlloc(LMEM_ZEROINIT,BSIZE+1);
        xassert(paio->Buffer);
        paio->ReadHandle = iFile;
        paio->WriteHandle = oFile;
        paio->Overlapped.Internal = BSIZE;
        paio->Overlapped.Offset = Offset;
        Offset += BSIZE;
        IoCount++;
        if ( IoCount & 1 ) {
            InsertTailList(&IoRequestList,&paio->Links);
            }
        else {
            InsertHeadList(&IoRequestList,&paio->Links);
            }
        ReleaseSemaphore(IoWorkerListSemaphore,1,NULL);
        }
    if ( FileSize != 0 ) {
        paio = LocalAlloc(LMEM_ZEROINIT,sizeof(*paio));
        xassert(paio);
        paio->Buffer = LocalAlloc(LMEM_ZEROINIT,FileSize+1);
        xassert(paio->Buffer);
        paio->ReadHandle = iFile;
        paio->WriteHandle = oFile;
	paio->Overlapped.interlockInternal = FileSize;
        paio->Overlapped.Offset = Offset;
        IoCount++;
        if ( IoCount & 1 ) {
            InsertTailList(&IoRequestList,&paio->Links);
            }
        else {
            InsertHeadList(&IoRequestList,&paio->Links);
            }
        ReleaseSemaphore(IoWorkerListSemaphore,1,NULL);
        }
    IoReadCount = IoCount;
    IoWriteCount = IoCount;
    ReleaseMutex(IoWorkerListLock);

    CompletionHandles[0] = IoReadsDoneEvent;
    CompletionHandles[1] = IoWritesDoneEvent;

    WaitStatus = WaitForMultipleObjects(2,CompletionHandles,TRUE,0xffffffff);
    xassert(WaitStatus != 0xffffffff);
    CloseHandle(iFile);
    CloseHandle(oFile);
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tprof.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tprof.c

Abstract:

    Win32 Base API Test Program for Profile File Management calls

Author:

    Steve Wood (stevewo) 26-Oct-1990

Revision History:

--*/

#include <stdio.h>
#include <string.h>

#define WIN32_CONSOLE_APP
#include <windows.h>


void
DumpProfile(
    LPTSTR ProfileFileName
    )
{
    LPTSTR Sections, Section;
    LPTSTR Keywords, Keyword;
    LPTSTR KeyValue;

    Sections = LocalAlloc( 0, 4096 * sizeof( *Sections ) );
    Keywords = LocalAlloc( 0, 4096 * sizeof( *Keywords ) );
    KeyValue = LocalAlloc( 0, 1024 * sizeof( *KeyValue ) );

#ifdef UNICODE
    printf( "\nDump of %ws\n",
#else
    printf( "\nDump of %s\n",
#endif
            ProfileFileName ? ProfileFileName : TEXT("win.ini")
          );
    *Sections = TEXT('\0');
    if (!GetPrivateProfileString( NULL, NULL, NULL,
                                  Sections, 4096 * sizeof( *Sections ),
                                  ProfileFileName
                                )
       ) {
        printf( "*** Unable to read - rc == %d\n", GetLastError() );
        }

    Section = Sections;
    while (*Section) {
#ifdef UNICODE
        printf( "[%ws]\n",
#else
        printf( "[%s]\n",
#endif
                Section
              );
        *Keywords = TEXT('\0');
        GetPrivateProfileString( Section, NULL, NULL,
                                 Keywords, 4096 * sizeof( *Keywords ),
                                 ProfileFileName
                               );
        Keyword = Keywords;
        while (*Keyword) {
            GetPrivateProfileString( Section, Keyword, NULL,
                                     KeyValue, 1024 * sizeof( *KeyValue ),
                                     ProfileFileName
                                   );
#ifdef UNICODE
            printf( "    %ws=%ws\n",
#else
            printf( "    %s=%s\n",
#endif
                    Keyword, KeyValue
                  );

            while (*Keyword++) {
                }
            }

        while (*Section++) {
            }
        }

    LocalFree( Sections );
    LocalFree( Keywords );
    LocalFree( KeyValue );

    return;
}

void
DumpSection(
    LPTSTR ProfileFileName,
    LPTSTR SectionName
    )
{
    LPTSTR SectionValue;
    LPTSTR s;

    SectionValue = LocalAlloc( 0, 4096 * sizeof( TCHAR ) );

#ifdef UNICODE
    printf( "\nDump of Section %ws in %ws\n",
#else
    printf( "\nDump of Section %s in %s\n",
#endif
              SectionName,
              ProfileFileName ? ProfileFileName : TEXT("win.ini")
            );

    *SectionValue = TEXT('\0');
    GetPrivateProfileSection( SectionName,
                              SectionValue, 4096 * sizeof( TCHAR ),
                              ProfileFileName
                            );
#ifdef UNICODE
    printf( "[%ws]\n",
#else
    printf( "[%s]\n",
#endif
            SectionName
          );
    s = SectionValue;
    while (*s) {
#ifdef UNICODE
        printf( "    %ws\n", s );
#else
        printf( "    %s\n", s );
#endif

        while (*s++) {
            }
        }

    LocalFree( SectionValue );
    return;
}

#define MAX_SECTIONS 32
#define MAX_KEYWORDS 32

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    ULONG n;
    int SectionNumber, KeyNumber;
    LPTSTR SectionValue, KeyValue, Keyword;
    TCHAR SectionName[ 32 ], KeyName[ 32 ], KeyValueBuffer[ 32 ], Buffer[ 32 ];
    FILE *fh;

    printf( "TPROF: Entering Test Program\n" );

    SectionValue = LocalAlloc( 0, 4096 * sizeof( TCHAR ) );
    KeyValue = LocalAlloc( 0, 1024 * sizeof( TCHAR ) );

#if 0
    for (SectionNumber=0; SectionNumber<MAX_SECTIONS; SectionNumber++) {
        sprintf( SectionName, "Section%02u", SectionNumber );
        for (KeyNumber=0; KeyNumber<MAX_KEYWORDS; KeyNumber++) {
            sprintf( KeyName, "KeyName%02u", KeyNumber );
            sprintf( KeyValueBuffer, "KeyValue%02u_%02u", SectionNumber, KeyNumber );
            if (!WritePrivateProfileString( SectionName, KeyName, KeyValueBuffer, "foo.ini"  )) {
                fprintf( stderr, "WriteProfileString( test.ini, [%s].%s=%s )  errno == %u\n",
                         SectionName, KeyName, KeyValueBuffer, GetLastError()
                       );
                }

            GetPrivateProfileString( SectionName, KeyName, "bogus", Buffer, sizeof( Buffer ), "foo.ini" );

            if (strcmp( Buffer, KeyValueBuffer )) {
                fprintf( stderr, "Write: %s != %s, errno == %u\n", KeyValueBuffer, Buffer, GetLastError() );
                }
            }
        }

    for (SectionNumber=0; SectionNumber<MAX_SECTIONS; SectionNumber++) {
        sprintf( SectionName, "Section%02u", SectionNumber );
        for (KeyNumber=0; KeyNumber<MAX_KEYWORDS; KeyNumber++) {
            sprintf( KeyName, "KeyName%02u", KeyNumber );
            sprintf( KeyValueBuffer, "KeyValue%02u_%02u", SectionNumber, KeyNumber );

            GetPrivateProfileString( SectionName, KeyName, "bogus", Buffer, sizeof( Buffer ), "foo.ini" );

            if (strcmp( Buffer, KeyValueBuffer )) {
                fprintf( stderr, "Read: %s != %s, errno == %u\n", KeyValueBuffer, Buffer, GetLastError() );
                }
            }
        }

    for (SectionNumber=0; SectionNumber<MAX_SECTIONS; SectionNumber++) {
        sprintf( SectionName, "Section%02u", SectionNumber );
        for (KeyNumber=0; KeyNumber<MAX_KEYWORDS; KeyNumber++) {
            sprintf( KeyName, "KeyName%02u", KeyNumber );
            sprintf( KeyValueBuffer, "KeyValue%02u_%02u", SectionNumber, KeyNumber );

            if (!WritePrivateProfileString( SectionName, KeyName, NULL, "foo.ini"  )) {
                fprintf( stderr, "WriteProfileString( test.ini, [%s].%s (delete) )  errno == %u\n",
                         SectionName, KeyName, GetLastError()
                       );
                }

            GetPrivateProfileString( SectionName, KeyName, "bogus", Buffer, sizeof( Buffer ), "foo.ini" );

            if (strcmp( Buffer, "bogus" )) {
                fprintf( stderr, "Delete: bogus != %s, errno == %u\n", Buffer, GetLastError() );
                }
            }
        }

    exit( 0 );
#endif

    WriteProfileString( TEXT("TESTINI"), TEXT("Key1"), TEXT("100abc") );
    n = GetProfileString( TEXT("ports"), NULL, TEXT(""), SectionValue, 4096 * sizeof( TCHAR ) );
    Keyword = SectionValue;
    printf( "Keywords in win.ini[ports]\n" );
    while (*Keyword) {
#ifdef UNICODE
        printf( "    %ws\n", Keyword );
#else
        printf( "    %s\n", Keyword );
#endif
        while (*Keyword++) {
            }
        }

    n = GetProfileString( TEXT("ports"), NULL, NULL, SectionValue, 4096 );
    Keyword = SectionValue;
    printf( "Keywords in win.ini[ports]\n" );
    while (*Keyword) {
#ifdef UNICODE
        printf( "    %ws\n", Keyword );
#else
        printf( "    %s\n", Keyword );
#endif
        while (*Keyword++) {
            }
        }

    DeleteFile( TEXT("\\nt\\windows\\test.ini") );
    fh = fopen( "\\nt\\windows\\test.ini", "w" );
    fclose( fh );

    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("StrApp"), TEXT("StrKey"), TEXT("StrVal"), TEXT("test.ini"));
    DumpProfile( TEXT("test.ini") );


    DeleteFile( TEXT("test.ini") );
    fh = fopen( "\\nt\\test.ini", "w" );
    fprintf( fh, "[IncompleteSectionWithoutTrailingBracket\n\n" );
    fprintf( fh, "[StrApp]\n" );
    fprintf( fh, "StrKey=xxxxxx\n" );
    fclose( fh );

    DumpProfile( TEXT("test.ini") );

    if (!WritePrivateProfileString( TEXT("StrApp"), TEXT("StrKey"), TEXT("StrVal"), TEXT("test.ini"))) {
        printf( "*** Write failed - rc == %d\n", GetLastError() );
        }
    else {
        DumpProfile( TEXT("test.ini") );
        }

    DeleteFile( "test.ini" );

    fh = fopen( "\\nt\\windows\\test.ini", "w" );
    fprintf( fh, "[a]\n" );
    fprintf( fh, "a1=b1\n" );
    fprintf( fh, "[b]\n" );
    fprintf( fh, "a2=b2\n" );
    fclose( fh );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileSection( TEXT("Section2"),
        TEXT("Keyword21=Value21\0Keyword22=Value22\0Keyword23=Value23\0Keyword24=\0"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    n = GetPrivateProfileString( TEXT("a"), TEXT("\0"), TEXT("Default"),
                                 KeyValue, 1024 * sizeof( TCHAR ),
                                 TEXT("test.ini")
                               );
#ifdef UNICODE
    printf( "GetPrivateProfileString( a, \\0, Default ) == %ld '%ws'\n", n, KeyValue );
#else
    printf( "GetPrivateProfileString( a, \\0, Default ) == %ld '%s'\n", n, KeyValue );
#endif

    n = GetPrivateProfileInt( TEXT("a"), TEXT("\0"), 123, TEXT("test.ini") );
    printf( "GetPrivateProfileString( a, \\0, 123 ) == %ld\n", n );

    WritePrivateProfileString( TEXT("a"), NULL, NULL, TEXT("test.ini") );

    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"), TEXT("Key1"), TEXT("100abc"), TEXT("test.ini") );

    WritePrivateProfileString( TEXT("    TESTINI    "),
        TEXT("    Key1    "),
        TEXT("  Val1   "),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    printf( "GetProfileInt( 123 ) == %ld\n",
            GetProfileInt( TEXT("AAAAA"), TEXT("XXXXX"), 123 )
          );

    printf( "GetProfileInt( -123 ) == %ld\n",
            GetProfileInt( TEXT("AAAAA"), TEXT("XXXXX"), -123 )
          );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key1"),
        NULL,
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key2"),
        TEXT("Val2"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key2"),
        TEXT(""),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key2"),
        NULL,
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key3"),
        TEXT("Val3"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        NULL,
        TEXT("Something"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("Section1"),
        TEXT("Keyword11"),
        TEXT("Value11"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileSection( TEXT("Section2"),
        TEXT("Keyword21=Value21\0Keyword22=Value22\0Keyword23=Value23\0Keyword24=\0"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("Section1"),
        TEXT("Keyword12"),
        TEXT("Value12"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    n = GetPrivateProfileSection( TEXT("Section1"),
                                  SectionValue, 4096 * sizeof( TCHAR ),
                                  TEXT("test.ini")
                                );
#if 0
    if (n != 36 ||
        strcmp( SectionValue, "Keyword11=Value11" ) ||
        strcmp( SectionValue+18, "Keyword12=Value12" )
       ) {
        printf( "*** test.ini[ Section1 ] is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section1"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword25", "Default25",
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n != 9 || strcmp( KeyValue, "Default25" )) {
        printf( "*** test.ini[ Section2 ].Keyword25 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword24", NULL,
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n || strcmp( KeyValue, "" )) {
        printf( "*** test.ini[ Section2 ].Keyword24 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword23", NULL,
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n != 7 || strcmp( KeyValue, "Value23" )) {
        printf( "*** test.ini[ Section2 ].Keyword23 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword22", NULL,
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n != 7 || strcmp( KeyValue, "Value22" )) {
        printf( "*** test.ini[ Section2 ].Keyword22 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword21", NULL,
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n != 7 || strcmp( KeyValue, "Value21" )) {
        printf( "*** test.ini[ Section2 ].Keyword21 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    DumpProfile( "test.ini" );

    printf( "Deleting [Section1]Keyword11\n" );
    WritePrivateProfileString( "Section1",
        "Keyword11",
        NULL,
        "test.ini"
        );
    DumpProfile( "test.ini" );

    printf( "Deleting all keywords in [Section1]\n" );
    WritePrivateProfileSection( "Section1",
        "",
        "test.ini"
        );
    DumpProfile( "test.ini" );

    printf( "Deleting [Section1]\n" );
    WritePrivateProfileString( "Section1",
        NULL,
        NULL,
        "test.ini"
        );
    DumpProfile( "test.ini" );

    printf( "Setting [Section2]Keyword21=\n" );
    WritePrivateProfileString( "Section2",
        "Keyword21",
        "",
        "test.ini"
        );
#endif
    DumpProfile( TEXT("test.ini") );
    DumpProfile( NULL );
    DumpSection( NULL, TEXT("Extensions")  );

    printf( "TPROF: Exiting Test Program\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\unbufw.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

//
// Unbuffered write test
//

#define TEST_REPEAT_COUNT   10

//
// File is 20mb
//

#define BUFFER_SIZE         (64*1024)
#define NUMBER_OF_WRITES    (320*1)

int BufferSize;
int NumberOfWrites;

char *Buffer;

BOOL fSequentialNew;
BOOL fBufferdIo;
BOOL fRaw;
BOOL fWrite = TRUE;
LPSTR FileName;

VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    );


VOID
ShowUsage(
    VOID
    );

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp
    )
{
    DWORD Start[TEST_REPEAT_COUNT];
    DWORD End[TEST_REPEAT_COUNT];
    DWORD Diff;
    double fDiff, fSec, fKb, fSumKbs;
    int TestNumber;
    HANDLE hFile, hPort;
    OVERLAPPED ov;
    LPOVERLAPPED ov2;
    int WriteCount;
    DWORD n,n2,key;
    BOOL b;
    int PendingIoCount;
    DWORD Version;
    DWORD FileFlags;
    char chChar, *pchChar;

    Version = GetVersion() >> 16;

    FileName = "unbufw.dat";
    fSequentialNew = FALSE;
    fBufferdIo = FALSE;
    fRaw = FALSE;

    BufferSize = BUFFER_SIZE;
    NumberOfWrites = ( (20*(1024*1024)) / BufferSize);

    while (--argc) {
        pchChar = *++argv;
        if (*pchChar == '/' || *pchChar == '-') {
            while (chChar = *++pchChar) {
                ParseSwitch( chChar, &argc, &argv );
                }
            }
        }




    if ( argc > 1 ) {
        FileName = argv[1];
        }
    else {
        }

    fSumKbs = 0.0;

    Buffer = VirtualAlloc(NULL,BUFFER_SIZE,MEM_COMMIT,PAGE_READWRITE);
    if ( !Buffer ) {
        printf("Error allocating buffer %d\n",GetLastError());
        return 99;
        }

    FileFlags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;

    if ( !fBufferdIo ) {
        FileFlags |= FILE_FLAG_NO_BUFFERING;
        }

    DeleteFile(FileName);

    for (TestNumber = 0; TestNumber < TEST_REPEAT_COUNT; TestNumber++ ) {


        hFile = CreateFile(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    fRaw ? OPEN_EXISTING : OPEN_ALWAYS,
                    FileFlags,
                    NULL
                    );
        if ( hFile == INVALID_HANDLE_VALUE ) {
            printf("Error opening file %s %d\n",FileName,GetLastError());
            return 99;
            }

        hPort = CreateIoCompletionPort(
                    hFile,
                    NULL,
                    (DWORD)hFile,
                    0
                    );
        if ( !hPort ) {
            printf("Error creating completion port %d\n",FileName,GetLastError());
            return 99;
            }

        ZeroMemory(&ov,sizeof(ov));

        if ( TestNumber == 0 && fSequentialNew == FALSE) {

            Start[TestNumber] = GetTickCount();

            //
            // Make sure the file is written out to the end...
            //
            ov.Offset = (NUMBER_OF_WRITES * BUFFER_SIZE) - 1024;

            b = WriteFile(hFile,Buffer,1024,&n,&ov);
            if ( !b && GetLastError() != ERROR_IO_PENDING ) {
                printf("Error in pre-write %d\n",GetLastError());
                return 99;
                }
            b = GetQueuedCompletionStatus(
                    hPort,
                    &n2,
                    &key,
                    &ov2,
                    (DWORD)-1
                    );
            if ( !b ) {
                printf("Error picking up completion pre-write %d\n",GetLastError());
                return 99;
                }

            End[TestNumber] = GetTickCount();

            Diff = End[TestNumber] - Start[TestNumber];

            fDiff = Diff;
            fSec = fDiff/1000.0;
            fKb = ( (NumberOfWrites * BufferSize) / 1024 );

            printf("First Write %2dMb Written in %3.3fs I/O Rate %4.3f Kb/S\n\n",
                (NumberOfWrites * BufferSize) / ( 1024 * 1024),
                fSec,
                fKb / fSec
                );
            }

        ov.Offset = 0;

        PendingIoCount = 0;

        Start[TestNumber] = GetTickCount();

        //
        // Issue the writes
        //

        for (WriteCount = 0; WriteCount < NumberOfWrites; WriteCount++){
reissuewrite:
            if ( fWrite ) {
                b = WriteFile(hFile,Buffer,BufferSize,&n,&ov);
                }
            else {
                b = ReadFile(hFile,Buffer,BufferSize,&n,&ov);
                }
            if ( !b && GetLastError() != ERROR_IO_PENDING ) {

                //
                // we reached our limit on outstanding I/Os
                //

                if ( GetLastError() == ERROR_INVALID_USER_BUFFER ||
                     GetLastError() == ERROR_NOT_ENOUGH_QUOTA ||
                     GetLastError() == ERROR_NOT_ENOUGH_MEMORY ) {

                    //
                    // wait for an outstanding I/O to complete and then go again
                    //
                    b = GetQueuedCompletionStatus(
                            hPort,
                            &n2,
                            &key,
                            &ov2,
                            (DWORD)-1
                            );
                    if ( !b ) {
                        printf("Error picking up completion write %d\n",GetLastError());
                        return 99;
                        }

                    PendingIoCount--;
                    goto reissuewrite;
                    }
                else {
                    printf("Error in write %d (pending count = %d)\n",GetLastError(),PendingIoCount);
                    return 99;
                    }
                }
            PendingIoCount++;
            ov.Offset += BufferSize;
            }

        //
        // Pick up the I/O completion
        //

        for (WriteCount = 0; WriteCount < PendingIoCount; WriteCount++){
            b = GetQueuedCompletionStatus(
                    hPort,
                    &n2,
                    &key,
                    &ov2,
                    (DWORD)-1
                    );
            if ( !b ) {
                printf("Error picking up completion write %d\n",GetLastError());
                return 99;
                }
            }

        End[TestNumber] = GetTickCount();

        CloseHandle(hFile);

        if ( Version > 613 ) {
            CloseHandle(hPort);
            }

        //
        // Dump the results
        //

        Diff = End[TestNumber] - Start[TestNumber];

        fDiff = Diff;
        fSec = fDiff/1000.0;
        fKb = ( (NumberOfWrites * BufferSize) / 1024 );

        printf("Test %2d %2dMb Written in %3.3fs I/O Rate %4.3f Kb/S\n",
            TestNumber,
            (NumberOfWrites * BufferSize) / ( 1024 * 1024),
            fSec,
            fKb / fSec
            );

        fSumKbs += (fKb / fSec);

        if ( fSequentialNew ) {
            DeleteFile(FileName);
            }

        }

    DeleteFile(FileName);

    //
    // Average
    //

    printf("\n Average Throughput %4.3f\n\n",
            fSumKbs/TEST_REPEAT_COUNT
            );
}


VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    )
{
    int bs;
    switch (toupper( chSwitch )) {

        case '?':
            ShowUsage();
            break;

        case 'F':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            FileName =  *(*pArgv);
            break;

        case 'K':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            bs = strtoul( *(*pArgv), NULL, 10 );
            bs *= 1024;
            if ( bs > BUFFER_SIZE ) {
                ShowUsage();
                }

            BufferSize = bs;
            NumberOfWrites = ( (20*(1024*1024)) / BufferSize);

            break;


        case 'S':
            fSequentialNew = TRUE;
            break;

        case 'R':
            fRaw = TRUE;
            break;

        case 'B':
            fBufferdIo = TRUE;
            break;

        case 'X':
            fWrite = FALSE;
            break;


        default:
            fprintf( stderr, "UNBUFW: Invalid switch - /%c\n", chSwitch );
            ShowUsage();
            break;

        }
}


VOID
ShowUsage(
    VOID
    )
{
    fputs( "usage: UNBUFW [switches]\n"
           "              [-f filename] supplies the output filename\n"
           "              [-s] write sequentially without pre-allocating the file\n"
           "              [-r] use raw I/O\n"
           "              [-b] use buffered I/O instead of unbuffered I/O\n"
           "              [-x] do reads instead of writes\n"
           "              [-k write-size] use write-size k as write-size (64 is max)\n",
           stderr );

    exit( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\ttask.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ttask.c

Abstract:

    Test program for Win32 Base File API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

typedef struct _CMDSHOW {
    WORD wMustBe2;
    WORD wShowWindowValue;
} CMDSHOW, *PCMDSHOW;

typedef struct _LOAD_MODULE_PARAMS {
    LPSTR lpEnvAddress;
    LPSTR lpCmdLine;
    PCMDSHOW lpCmdShow;
    DWORD dwReserved;
} LOAD_MODULE_PARAMS, *PLOAD_MODULE_PARAMS;

HANDLE Event1, Event2;

VOID
WaitTestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;
    printf("In Test Thread... Parameter %ld\n",ThreadParameter);

    assert(SetEvent(Event1));

    st = WaitForSingleObject(Event2,-1);
    assert(st == 0);

    printf("Test Thread Exiting... Parameter %ld\n",ThreadParameter);

    ExitThread((DWORD)ThreadParameter);
}

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    LPSTR s;
    SYSTEMTIME DateAndTime;
    CHAR ImageName[256];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;

    printf("In Test Thread... Parameter %ld\n",ThreadParameter);
    GetSystemTime(&DateAndTime);
    printf("%d/%d/%d @ %d:%d.%d\n",
        DateAndTime.wMonth,
        DateAndTime.wDay,
        DateAndTime.wYear,
        DateAndTime.wHour,
        DateAndTime.wMinute,
        DateAndTime.wSecond
        );

    DateAndTime.wMonth = 3;
    DateAndTime.wDay = 23;
    DateAndTime.wYear = 1961;
    DateAndTime.wHour = 7;
    DateAndTime.wMinute = 31;
    DateAndTime.wSecond = 0;

#if 0
    assert(SetSystemTime(&DateAndTime));
    GetSystemTime(&DateAndTime);

    assert(DateAndTime.wMonth == 3);
    assert(DateAndTime.wDay == 23);
    assert(DateAndTime.wYear == 1961);
    assert(DateAndTime.wHour == 7);

    DateAndTime.wMonth = 13;
    assert(!SetSystemTime(&DateAndTime));

    printf("%s\n",GetCommandLine());

    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_HIGHEST);
    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_LOWEST));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_LOWEST);
    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_ABOVE_NORMAL));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_ABOVE_NORMAL);
    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_BELOW_NORMAL);
    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_NORMAL);
    assert(!SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST+1));
    assert(GetThreadPriority(GetCurrentProcess()) == THREAD_PRIORITY_ERROR_RETURN);

    assert(GetModuleFileName(0,ImageName,256) < 255);

    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.lpReserved = "UsedByShell";
    StartupInfo.lpDesktop = "MarksDesktop";
    StartupInfo.lpTitle = "MarksTestTitle";
    StartupInfo.dwX = 0;
    StartupInfo.dwY = 1;
    StartupInfo.dwXSize = 10;
    StartupInfo.dwYSize = 10;
    StartupInfo.dwFlags = 0;//STARTF_SHELLOVERRIDE;
    StartupInfo.wShowWindow = 0;//SW_SHOWDEFAULT;
    StartupInfo.lpReserved2 = 0;
    StartupInfo.cbReserved2 = 0;

    assert( CreateProcess(
                NULL,
                "ttask +",
                NULL,
                NULL,
                TRUE,
                0,
                NULL,
                NULL,
                &StartupInfo,
                &ProcessInformation
                ) );
    WaitForSingleObject(ProcessInformation.hProcess,-1);
#endif
    ExitThread((DWORD)ThreadParameter);
}


DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    CRITICAL_SECTION Crit;
    HANDLE Event, Semaphore, Mutex, Thread, Process;
    HANDLE NEvent, NSemaphore, NMutex;
    HANDLE OEvent, OSemaphore, OMutex;
    DWORD st;
    DWORD ThreadId;
    CHAR ImageName[256];
    CHAR CommandLine[256];
    CHAR Environment[256];
    CMDSHOW cs;
    LOAD_MODULE_PARAMS lmp;
    LPSTR *s;
    int i;
    DWORD psp;

    (VOID)envp;

    try {
        RaiseException(4,0,0,NULL);
        }
    except(EXCEPTION_EXECUTE_HANDLER){
        printf("In Handler %lx\n",GetExceptionCode());
    }

    i = 0;
    s = argv;
    while(i < argc) {
        printf("argv[%ld] %s\n",i,*s);
        i++;
        s++;
        }
#if 0
    printf("TTASK CommandLine %s\n",GetCommandLine());
    if ( strchr(GetCommandLine(),'+') ) {
        printf("TTASK CommandLine %s\n",GetCommandLine());
        return 1;
        }
    Process=OpenProcess(PROCESS_ALL_ACCESS,FALSE,GetCurrentProcessId());
    assert(Process);
    assert(GetModuleFileName(0,ImageName,256) < 255);
    assert(GetModuleFileName(0,CommandLine,256) < 255);
    strcat(CommandLine," -- + --");

    assert(WinExec(CommandLine,0) == 32);

    lmp.lpEnvAddress = Environment;
    lmp.lpCmdLine = CommandLine;
    lmp.dwReserved = 0;
    lmp.lpCmdShow = &cs;
    cs.wMustBe2 = 2;
    cs.wShowWindowValue = 3;

    RtlFillMemory(Environment,256,'\0');
    strcpy(Environment,"PATH=C:\\FOOBAR;C:\\NT\\DLL");
    strcpy(&Environment[strlen("PATH=C:\\FOOBAR;C:\\NT\\DLL")+1],"XYZZY=X");

    assert(LoadModule(ImageName,&lmp) == 32);
#endif
    InitializeCriticalSection(&Crit);
    Event = CreateEvent(NULL,TRUE,TRUE,NULL);
    Semaphore = CreateSemaphore(NULL,1,256,NULL);
    Mutex = CreateMutex(NULL,FALSE,NULL);

    assert(Event);
    assert(Semaphore);
    assert(Mutex);

    NEvent = CreateEvent(NULL,TRUE,TRUE,"named-event");
    NSemaphore = CreateSemaphore(NULL,1,256,"named-semaphore");
    NMutex = CreateMutex(NULL,FALSE,"named-mutex");

    assert(NEvent);
    assert(NSemaphore);
    assert(NMutex);

    OEvent = OpenEvent(EVENT_ALL_ACCESS,FALSE,"named-event");
    OSemaphore = OpenSemaphore(SEMAPHORE_ALL_ACCESS,FALSE,"named-semaphore");
    OMutex = OpenMutex(MUTEX_ALL_ACCESS,FALSE,"named-mutex");

    assert(OEvent);
    assert(OSemaphore);
    assert(OMutex);

    EnterCriticalSection(&Crit);
    LeaveCriticalSection(&Crit);

    st = WaitForSingleObject(Event,-1);
    assert(st == 0);

    st = WaitForSingleObject(Semaphore,-1);
    assert(st == 0);

    st = WaitForSingleObject(Semaphore,0);
    assert(st == WAIT_TIMEOUT);

    assert(ReleaseSemaphore(Semaphore,1,NULL));

    st = WaitForSingleObject(Mutex,-1);
    assert(st == 0);

    assert(ReleaseMutex(Mutex));

    st = WaitForSingleObject(OEvent,-1);
    assert(st == 0);

    st = WaitForSingleObject(OSemaphore,-1);
    assert(st == 0);

    st = WaitForSingleObject(NSemaphore,0);
    assert(st == WAIT_TIMEOUT);

    assert(ReleaseSemaphore(NSemaphore,1,NULL));

    st = WaitForSingleObject(OMutex,-1);
    assert(st == 0);

    assert(ReleaseMutex(NMutex));

    Thread = CreateThread(NULL,0L,TestThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);

    st = WaitForSingleObject(Thread,-1);
    assert(st == 0);

    assert(GetExitCodeThread(Thread,&st));
    assert(st = 99);

    CloseHandle(Thread);

    Event1 = CreateEvent(NULL,TRUE,FALSE,NULL);
    Event2 = CreateEvent(NULL,TRUE,FALSE,NULL);

    Thread = CreateThread(NULL,0L,WaitTestThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);

    st = WaitForSingleObject(Event1,-1);
    assert(st == 0);

    //
    // thread should now be waiting on event2
    //

    psp = SuspendThread(Thread);
    assert(psp==0);

    assert(SetEvent(Event2));

    psp = SuspendThread(Thread);
    assert(psp==1);

    psp = ResumeThread(Thread);
    assert(psp==2);

    psp = ResumeThread(Thread);
    assert(psp==1);

    st = WaitForSingleObject(Thread,-1);
    assert(st == 0);

    assert(GetExitCodeThread(Thread,&st));
    assert(st = 99);

    CloseHandle(Thread);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tse.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tse.c

Abstract:

    This module tests windows security api.

Author:

    Robert Reichel (RobertRe) 01-Jan-92

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <stdarg.h>
#include <assert.h>
#include <stdio.h>



#define _TST_USER_      // User mode test

#define BUFFER_SIZE 256



////////////////////////////////////////////////////////////////////////
//                                                                    //
//   Global Variables                                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////


LUID SystemAuthenticationId = SYSTEM_LUID;

//
// Universal well known SIDs
//

PSID  NullSid;
PSID  WorldSid;
PSID  LocalSid;
PSID  CreatorOwnerSid;

//
// Sids defined by NT
//

PSID NtAuthoritySid;

PSID DialupSid;
PSID NetworkSid;
PSID BatchSid;
PSID InteractiveSid;
PSID LocalSystemSid;



//
//  Well known privilege values
//


LUID SeCreateTokenPrivilege;
LUID SeAssignPrimaryTokenPrivilege;
LUID SeLockMemoryPrivilege;
LUID SeIncreaseQuotaPrivilege;
LUID SeUnsolicitedInputPrivilege;
LUID SeTcbPrivilege;
LUID SeSecurityPrivilege;
LUID SeTakeOwnershipPrivilege;
LUID SeLoadDriverPrivilege;
LUID SeCreatePagefilePrivilege;
LUID SeIncreaseBasePriorityPrivilege;
LUID SeSystemProfilePrivilege;
LUID SeSystemtimePrivilege;
LUID SeProfileSingleProcessPrivilege;
LUID SeCreatePermanentPrivilege;
LUID SeBackupPrivilege;
LUID SeRestorePrivilege;
LUID SeShutdownPrivilege;
LUID SeDebugPrivilege;
LUID SeAuditPrivilege;
LUID SeSystemEnvironmentPrivilege;
LUID SeChangeNotifyPrivilege;
LUID SeRemoteShutdownPrivilege;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//   Internal Prototypes                                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
TestLookupSid();

VOID
TestLookupName();

void
TestGetPrivNameW(
    LPWSTR *PrivName,
    PLUID  lpLuid
    );
void
TestGetPrivNameA(
    LPSTR *PrivName,
    PLUID  lpLuid
    );

VOID
TestLookupPrivilegeValue();

void
TestLookupPrivilegeValueW(
    PLUID lpLuid
    );

void
TestLookupPrivilegeValueA(
    PLUID lpLuid
    );

VOID
TestLookupPrivilegeName();

void
TestLookupPrivilegeNameW(
    PLUID lpLuid
    );

void
TestLookupPrivilegeNameA(
    PLUID lpLuid
    );

VOID
TestLookupPrivilegeDisplayName();

void
TestLookupPrivilegeDisplayNameW(
    PLUID lpLuid
    );

void
TestLookupPrivilegeDisplayNameA(
    PLUID lpLuid
    );


void
initialize (void);

void
TestLookupSidW(
    IN PSID Sid
    );

void
TestLookupSidA(
    IN PSID Sid
    );

void
TestLookupNameW(
    LPWSTR Name
    );

void
DumpWCharString(
    PWSTR String
    );

VOID
DisplayAccountSid(
    PSID Sid
    );

VOID
DisplayUse(
    IN SID_NAME_USE  Use
    );

void
initialize (void)
{

    ULONG SidWithZeroSubAuthorities;
    ULONG SidWithOneSubAuthority;
    ULONG SidWithThreeSubAuthorities;
    ULONG SidWithFourSubAuthorities;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;


    //
    //  The following SID sizes need to be allocated
    //

    SidWithZeroSubAuthorities  = GetSidLengthRequired( 0 );
    SidWithOneSubAuthority     = GetSidLengthRequired( 1 );
    SidWithThreeSubAuthorities = GetSidLengthRequired( 3 );
    SidWithFourSubAuthorities  = GetSidLengthRequired( 4 );

    //
    //  Allocate and initialize the universal SIDs
    //

    NullSid         = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    WorldSid        = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    LocalSid        = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    CreatorOwnerSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);

    InitializeSid( NullSid,    &NullSidAuthority, 1 );
    InitializeSid( WorldSid,   &WorldSidAuthority, 1 );
    InitializeSid( LocalSid,   &LocalSidAuthority, 1 );
    InitializeSid( CreatorOwnerSid, &CreatorSidAuthority, 1 );

    *(GetSidSubAuthority( NullSid, 0 ))         = SECURITY_NULL_RID;
    *(GetSidSubAuthority( WorldSid, 0 ))        = SECURITY_WORLD_RID;
    *(GetSidSubAuthority( LocalSid, 0 ))        = SECURITY_LOCAL_RID;
    *(GetSidSubAuthority( CreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //

    NtAuthoritySid  = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithZeroSubAuthorities);
    DialupSid       = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    NetworkSid      = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    BatchSid        = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    InteractiveSid  = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    LocalSystemSid  = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);

    InitializeSid( NtAuthoritySid,   &NtAuthority, 0 );
    InitializeSid( DialupSid,        &NtAuthority, 1 );
    InitializeSid( NetworkSid,       &NtAuthority, 1 );
    InitializeSid( BatchSid,         &NtAuthority, 1 );
    InitializeSid( InteractiveSid,   &NtAuthority, 1 );
    InitializeSid( LocalSystemSid,   &NtAuthority, 1 );

    *(GetSidSubAuthority( DialupSid,       0 )) = SECURITY_DIALUP_RID;
    *(GetSidSubAuthority( NetworkSid,      0 )) = SECURITY_NETWORK_RID;
    *(GetSidSubAuthority( BatchSid,        0 )) = SECURITY_BATCH_RID;
    *(GetSidSubAuthority( InteractiveSid,  0 )) = SECURITY_INTERACTIVE_RID;
    *(GetSidSubAuthority( LocalSystemSid,  0 )) = SECURITY_LOCAL_SYSTEM_RID;


    //
    // Initialize the well known privilege values
    //

    SeCreateTokenPrivilege =
        RtlConvertLongToLargeInteger(SE_CREATE_TOKEN_PRIVILEGE);
    SeAssignPrimaryTokenPrivilege =
        RtlConvertLongToLargeInteger(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE);
    SeLockMemoryPrivilege =
        RtlConvertLongToLargeInteger(SE_LOCK_MEMORY_PRIVILEGE);
    SeIncreaseQuotaPrivilege =
        RtlConvertLongToLargeInteger(SE_INCREASE_QUOTA_PRIVILEGE);
    SeUnsolicitedInputPrivilege =
        RtlConvertLongToLargeInteger(SE_UNSOLICITED_INPUT_PRIVILEGE);
    SeTcbPrivilege =
        RtlConvertLongToLargeInteger(SE_TCB_PRIVILEGE);
    SeSecurityPrivilege =
        RtlConvertLongToLargeInteger(SE_SECURITY_PRIVILEGE);
    SeTakeOwnershipPrivilege =
        RtlConvertLongToLargeInteger(SE_TAKE_OWNERSHIP_PRIVILEGE);
    SeLoadDriverPrivilege =
        RtlConvertLongToLargeInteger(SE_LOAD_DRIVER_PRIVILEGE);
    SeCreatePagefilePrivilege =
        RtlConvertLongToLargeInteger(SE_CREATE_PAGEFILE_PRIVILEGE);
    SeIncreaseBasePriorityPrivilege =
        RtlConvertLongToLargeInteger(SE_INC_BASE_PRIORITY_PRIVILEGE);
    SeSystemProfilePrivilege =
        RtlConvertLongToLargeInteger(SE_SYSTEM_PROFILE_PRIVILEGE);
    SeSystemtimePrivilege =
        RtlConvertLongToLargeInteger(SE_SYSTEMTIME_PRIVILEGE);
    SeProfileSingleProcessPrivilege =
        RtlConvertLongToLargeInteger(SE_PROF_SINGLE_PROCESS_PRIVILEGE);
    SeCreatePermanentPrivilege =
        RtlConvertLongToLargeInteger(SE_CREATE_PERMANENT_PRIVILEGE);
    SeBackupPrivilege =
        RtlConvertLongToLargeInteger(SE_BACKUP_PRIVILEGE);
    SeRestorePrivilege =
        RtlConvertLongToLargeInteger(SE_RESTORE_PRIVILEGE);
    SeShutdownPrivilege =
        RtlConvertLongToLargeInteger(SE_SHUTDOWN_PRIVILEGE);
    SeDebugPrivilege =
        RtlConvertLongToLargeInteger(SE_DEBUG_PRIVILEGE);
    SeAuditPrivilege =
        RtlConvertLongToLargeInteger(SE_AUDIT_PRIVILEGE);
    SeSystemEnvironmentPrivilege =
        RtlConvertLongToLargeInteger(SE_SYSTEM_ENVIRONMENT_PRIVILEGE);
    SeChangeNotifyPrivilege =
        RtlConvertLongToLargeInteger(SE_CHANGE_NOTIFY_PRIVILEGE);
    SeRemoteShutdownPrivilege =
        RtlConvertLongToLargeInteger(SE_REMOTE_SHUTDOWN_PRIVILEGE);


}

void
TestLookupSidW(
    IN PSID Sid
    )

{
    //
    // LookupAccountSidW test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    DWORD         cbReferencedDomainName = 0;
    DWORD         cbSid = 0;
    WCHAR         Name[BUFFER_SIZE];
    SID_NAME_USE  peUse = SidTypeUser;
    WCHAR         ReferencedDomainName[BUFFER_SIZE];


    printf("      LookupW call . . . . . . . . . . . . . . . . . ");

    cbName = 0;
    cbReferencedDomainName = 0;

    Bool = LookupAccountSidW(
               NULL,
               Sid,
               Name,
               &cbName,
               ReferencedDomainName,
               &cbReferencedDomainName,
               &peUse
               );
    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
        printf("        Domain Name Length: %d\n", cbReferencedDomainName);
    } else {


        Bool = LookupAccountSidW(
                   NULL,
                   Sid,
                   Name,
                   &cbName,
                   ReferencedDomainName,
                   &cbReferencedDomainName,
                   &peUse
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *");
            DumpWCharString( Name );
            printf("*\n");
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
            printf("        Domain Name:        *");
            DumpWCharString( ReferencedDomainName );
            printf("*\n");
            printf("        Use:                ");
            DisplayUse( peUse );
            printf("\n\n");
        }
    }
}





void
TestLookupSidA(
    IN PSID Sid
    )
{
    UCHAR Name[BUFFER_SIZE];
    UCHAR ReferencedDomainName[BUFFER_SIZE];
    BOOL  Bool;
    DWORD cbName = 0;
    DWORD cbReferencedDomainName = 0;
    SID_NAME_USE peUse;

    printf("      LookupA call . . . . . . . . . . . . . . . . . ");

    Bool = LookupAccountSidA(
               NULL,
               Sid,
               Name,
               &cbName,
               ReferencedDomainName,
               &cbReferencedDomainName,
               &peUse
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
        printf("        Domain Name Length: %d\n", cbReferencedDomainName);
    } else {


        Bool = LookupAccountSidA(
                   NULL,
                   Sid,
                   Name,
                   &cbName,
                   ReferencedDomainName,
                   &cbReferencedDomainName,
                   &peUse
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *%s*\n",Name);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
            printf("        Domain Name:        *%s*\n", ReferencedDomainName );
            printf("        Use:                ");
            DisplayUse( peUse );
            printf("\n\n");
        }
    }

}


void
TestLookupNameW(
    LPWSTR Name
    )

{

    //
    // LookupAccountNameW test
    //

    BOOL          Bool;
    DWORD         cbSid = 0;
    UCHAR         Sid[BUFFER_SIZE];
    SID_NAME_USE  peUse = SidTypeUser;
    DWORD         cbReferencedDomainName = 0;
    WCHAR         ReferencedDomainName[BUFFER_SIZE];


    printf("      LookupW call . . . . . . . . . . . . . . . . . ");


    Bool = LookupAccountNameW(
               NULL,
               Name,
               Sid,
               &cbSid,
               ReferencedDomainName,
               &cbReferencedDomainName,
               &peUse
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Sid  Length:        %d\n", cbSid);
        printf("        Domain Name Length: %d\n", cbReferencedDomainName);
    } else {


        Bool = LookupAccountNameW(
                   NULL,
                   Name,
                   Sid,
                   &cbSid,
                   ReferencedDomainName,
                   &cbReferencedDomainName,
                   &peUse
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Sid  Length:        %d\n", cbSid);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
        } else {
            printf("Succeeded\n");
            printf("        Sid  Length:        %d\n", cbSid);
            printf("        Sid:                ");
            DisplayAccountSid( Sid );
            printf("\n");
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
            printf("        Domain Name:        *");
            DumpWCharString( ReferencedDomainName );
            printf("*\n");
            printf("        Use:                ");
            DisplayUse( peUse );
            printf("\n\n");
        }
    }

}


void
TestLookupNameA(
    LPSTR Name
    )

{

    //
    // LookupAccountNameA test
    //

    BOOL          Bool;
    DWORD         cbSid = 0;
    UCHAR         Sid[BUFFER_SIZE];
    SID_NAME_USE  peUse = SidTypeUser;
    DWORD         cbReferencedDomainName = 0;
    UCHAR         ReferencedDomainName[BUFFER_SIZE];


    printf("      LookupA call . . . . . . . . . . . . . . . . . ");


    Bool = LookupAccountNameA(
               NULL,
               Name,
               Sid,
               &cbSid,
               ReferencedDomainName,
               &cbReferencedDomainName,
               &peUse
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Sid  Length:        %d\n", cbSid);
        printf("        Domain Name Length: %d\n", cbReferencedDomainName);
    } else {


        Bool = LookupAccountNameA(
                   NULL,
                   Name,
                   Sid,
                   &cbSid,
                   ReferencedDomainName,
                   &cbReferencedDomainName,
                   &peUse
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Sid  Length:        %d\n", cbSid);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
        } else {
            printf("Succeeded\n");
            printf("        Sid  Length:        %d\n", cbSid);
            printf("        Sid:                ");
            DisplayAccountSid( Sid );
            printf("\n");
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
            printf("        Domain Name:        *%s*\n", ReferencedDomainName);
            printf("        Use:                ");
            DisplayUse( peUse );
            printf("\n\n");
        }
    }

}


void
TestLookupPrivilegeDisplayNameW(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeDisplayNameW test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    WCHAR         Name[BUFFER_SIZE];
    DWORD         LanguageId;
    LPWSTR        PrivName;


    printf("      LookupW call . . . . . . . . . . . . . . . . . ");


    TestGetPrivNameW( &PrivName, lpLuid );
    Bool = LookupPrivilegeDisplayNameW(
               NULL,
               PrivName,
               Name,
               &cbName,
               &LanguageId
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
    } else {


        Bool = LookupPrivilegeDisplayNameW(
                   NULL,
                   PrivName,
                   Name,
                   &cbName,
                   &LanguageId
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *");
            DumpWCharString( Name );
            printf("*\n");
            printf("        LanguageID:         %d\n", LanguageId);
            printf("\n\n");
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, PrivName );
    return;
}


void
TestLookupPrivilegeDisplayNameA(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeDisplayNameA test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    UCHAR         Name[BUFFER_SIZE];
    DWORD         LanguageId;
    LPSTR         PrivName;


    printf("      LookupA call . . . . . . . . . . . . . . . . . ");


    TestGetPrivNameA( &PrivName, lpLuid );
    Bool = LookupPrivilegeDisplayNameA(
               NULL,
               PrivName,
               Name,
               &cbName,
               &LanguageId
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
    } else {


        Bool = LookupPrivilegeDisplayNameA(
                   NULL,
                   PrivName,
                   Name,
                   &cbName,
               &LanguageId
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *%s*\n", Name);
            printf("        LanguageID:         %d\n", LanguageId);
            printf("\n\n");
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, PrivName );
    return;
}


void
TestLookupPrivilegeValueA(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeValueA test
    //

    BOOL          Bool;
    LPSTR         PrivName;
    LUID          ReturnedValue;


    TestGetPrivNameA( &PrivName, lpLuid );

    printf("      LookupA call . . . . . . . . . . . . . . . . . ");


    Bool = LookupPrivilegeValueA(
               NULL,
               PrivName,
               &ReturnedValue
               );

    if ( !Bool ) {
        printf("** FAILED **\n");
        printf("        Status:             %d\n", GetLastError());
    } else {

        if (ReturnedValue.LowPart  != lpLuid->LowPart ||
            ReturnedValue.HighPart != lpLuid->HighPart) {
            printf("** FAILED **\n");
            printf("        Value mismatch.\n");
            printf("        Passed Value:    {0x%lx, 0x%lx}\n",
                            lpLuid->HighPart,lpLuid->LowPart);
            printf("        Retrieved Value: {0x%lx, 0x%lx}\n",
                            ReturnedValue.HighPart,ReturnedValue.LowPart);

        } else {
            printf("Succeeded\n");
        }
    }
    printf("\n\n");

    RtlFreeHeap( RtlProcessHeap(), 0, PrivName );
    return;
}

void
TestLookupPrivilegeValueW(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeValueW test
    //

    BOOL          Bool;
    LPWSTR        PrivName;
    LUID          ReturnedValue;

    TestGetPrivNameW( &PrivName, lpLuid );

    printf("      LookupW call . . . . . . . . . . . . . . . . . ");


    Bool = LookupPrivilegeValueW(
               NULL,
               PrivName,
               &ReturnedValue
               );

    if ( !Bool ) {
        printf("** FAILED **\n");
        printf("        Status:             %d\n", GetLastError());
    } else {

        if (ReturnedValue.LowPart  != lpLuid->LowPart ||
            ReturnedValue.HighPart != lpLuid->HighPart) {
            printf("** FAILED **\n");
            printf("        Value mismatch.\n");
            printf("        Passed Value:    {0x%lx, 0x%lx}\n",
                            lpLuid->HighPart,lpLuid->LowPart);
            printf("        Retrieved Value: {0x%lx, 0x%lx}\n",
                            ReturnedValue.HighPart,ReturnedValue.LowPart);

        } else {
            printf("Succeeded\n");
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, PrivName );
    return;
}


void
TestGetPrivNameW(
    LPWSTR *PrivName,
    PLUID  lpLuid
    )
{


    BOOL          Bool;
    DWORD         cbName = 0;
    PWCHAR        Name = NULL;


    Bool = LookupPrivilegeNameW(
               NULL,
               lpLuid,
               Name,
               &cbName
               );
    ASSERT( !Bool && GetLastError() == ERROR_INSUFFICIENT_BUFFER );

    Name = RtlAllocateHeap( RtlProcessHeap(), 0, (cbName+1)*sizeof(WCHAR) );

    Bool = LookupPrivilegeNameW(
               NULL,
               lpLuid,
               Name,
               &cbName
               );
    ASSERT(Bool);

    (*PrivName) = (LPWSTR)Name;

    return;
}


void
TestGetPrivNameA(
    LPSTR *PrivName,
    PLUID  lpLuid
    )
{


    BOOL          Bool;
    DWORD         cbName = 0;
    PCHAR         Name = NULL;


    Bool = LookupPrivilegeNameA(
               NULL,
               lpLuid,
               Name,
               &cbName
               );
    ASSERT( !Bool && GetLastError() == ERROR_INSUFFICIENT_BUFFER );

    Name = RtlAllocateHeap( RtlProcessHeap(), 0, (cbName+1)*sizeof(CHAR) );

    Bool = LookupPrivilegeNameA(
               NULL,
               lpLuid,
               Name,
               &cbName
               );
    ASSERT(Bool);

    (*PrivName) = (LPSTR)Name;

    return;
}


void
TestLookupPrivilegeNameW(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeNameW test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    WCHAR         Name[BUFFER_SIZE];


    printf("      LookupW call . . . . . . . . . . . . . . . . . ");


    Bool = LookupPrivilegeNameW(
               NULL,
               lpLuid,
               Name,
               &cbName
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
    } else {


        Bool = LookupPrivilegeNameW(
                   NULL,
                   lpLuid,
                   Name,
                   &cbName
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *");
            DumpWCharString( Name );
            printf("*\n");
            printf("\n\n");
        }
    }

    return;
}


void
TestLookupPrivilegeNameA(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeNameA test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    UCHAR         Name[BUFFER_SIZE];


    printf("      LookupA call . . . . . . . . . . . . . . . . . ");


    Bool = LookupPrivilegeNameA(
               NULL,
               lpLuid,
               Name,
               &cbName
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
    } else {


        Bool = LookupPrivilegeNameA(
                   NULL,
                   lpLuid,
                   Name,
                   &cbName
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *%s*\n", Name);
            printf("\n\n");
        }
    }

}


VOID
DisplayUse(
    IN SID_NAME_USE  Use
    )
{

    switch (Use) {
    case SidTypeUser:
        printf("user");
        break;

    case SidTypeGroup:
        printf("group");
        break;

    case SidTypeDomain:
        printf("domain");
        break;

    case SidTypeAlias:
        printf("alias");
        break;

    case SidTypeWellKnownGroup:
        printf("well known group");
        break;

    case SidTypeDeletedAccount:
        printf("deleted account");
        break;

    case SidTypeInvalid:
        printf("invalid to lsa");
        break;

    case SidTypeUnknown:
        printf("unknown to lsa");
        break;

    default:
        printf("** invalid use value returned **");

    }

}

void
DumpWCharString(
    PWSTR String
    )
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;

    RtlInitUnicodeString( &Unicode, String );
//    DbgPrint("*%Z*\n",&Unicode);
//    DbgPrint("  Length: %d\n", Unicode.Length);
//    DbgPrint("  Max: %d\n", Unicode.MaximumLength);
    RtlUnicodeStringToAnsiString( &AnsiString, &Unicode, TRUE );
    AnsiString.Buffer[AnsiString.Length]=0; // null terminate it
    printf("%s", AnsiString.Buffer );
    RtlFreeAnsiString( &AnsiString );
    return;
}

VOID
DisplayAccountSid(
    PSID Sid
    )
{
    UCHAR i;
    ULONG Tmp;
    PSID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    UCHAR SubAuthorityCount;

    IdentifierAuthority = RtlIdentifierAuthoritySid(Sid);

    //
    // HACK! HACK!
    // The next line prints the revision of the SID.  Since there is no
    // rtl routine which gives us the SID revision, we must make due.
    // luckily, the revision field is the first field in the SID, so we
    // can just cast the pointer.
    //

    printf("S-%u-", (USHORT) *((PUCHAR) Sid) );

    if (  (IdentifierAuthority->Value[0] != 0)  ||
          (IdentifierAuthority->Value[1] != 0)     ){
        printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    IdentifierAuthority->Value[0],
                    IdentifierAuthority->Value[1],
                    IdentifierAuthority->Value[2],
                    IdentifierAuthority->Value[3],
                    IdentifierAuthority->Value[4],
                    IdentifierAuthority->Value[5] );
    } else {
        Tmp = IdentifierAuthority->Value[5]          +
              (IdentifierAuthority->Value[4] <<  8)  +
              (IdentifierAuthority->Value[3] << 16)  +
              (IdentifierAuthority->Value[2] << 24);
        printf("%lu", Tmp);
    }

    SubAuthorityCount = *RtlSubAuthorityCountSid(Sid);
    for (i=0;i<SubAuthorityCount ;i++ ) {
        printf("-%lu", (*RtlSubAuthoritySid(Sid, i)));
    }
    printf("\n");
}



VOID
TestLookupSid()
{


    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       Sid -> Name test                                              //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("\n\n\n");
    printf("  Sid lookup . . . . . . . . . . . . . . . . . . suite\n");

    printf("    Lookup NullSid\n");
    TestLookupSidW( NullSid ); TestLookupSidA( NullSid );

    printf("    Lookup WorldSid\n");
    TestLookupSidW( WorldSid ); TestLookupSidA( WorldSid );

    printf("    Lookup LocalSid\n");
    TestLookupSidW( LocalSid ); TestLookupSidA( LocalSid );

    printf("    Lookup CreatorOwnerSid\n");
    TestLookupSidW( CreatorOwnerSid ); TestLookupSidA( CreatorOwnerSid );

    printf("    Lookup NtAuthoritySid\n");
    TestLookupSidW( NtAuthoritySid ); TestLookupSidA( NtAuthoritySid );

    printf("    Lookup DialupSid\n");
    TestLookupSidW( DialupSid ); TestLookupSidA( DialupSid );

    printf("    Lookup NetworkSid\n");
    TestLookupSidW( NetworkSid ); TestLookupSidA( NetworkSid );

    printf("    Lookup BatchSid\n");
    TestLookupSidW( BatchSid ); TestLookupSidA( BatchSid );

    printf("    Lookup InteractiveSid\n");
    TestLookupSidW( InteractiveSid ); TestLookupSidA( InteractiveSid );

    printf("    Lookup LocalSystemSid\n");
    TestLookupSidW( LocalSystemSid ); TestLookupSidA( LocalSystemSid );

    printf("\n\n\n");
    return;
}


VOID
TestLookupName()
{


    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       Name -> Sid test                                              //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("  Name Lookup  . . . . . . . . . . . . . . . . . suite\n");

    printf("    Lookup Null\n");
    TestLookupNameW( L"" ); TestLookupNameA( "" );

    printf("    Lookup World\n");
    TestLookupNameW( L"World" ); TestLookupNameA( "World" );

    printf("    Lookup Local\n");
    TestLookupNameW( L"Local" ); TestLookupNameA( "Local" );

    printf("    Lookup CreatorOwner\n");
    TestLookupNameW( L"CreatorOwner" ); TestLookupNameA( "CreatorOwner" );

    printf("    Lookup NtAuthority\n");
    TestLookupNameW( L"NtAuthority" ); TestLookupNameA( "NtAuthority" );

    printf("    Lookup DialupName\n");
    TestLookupNameW( L"DialupName" ); TestLookupNameA( "DialupName" );

    printf("    Lookup Network\n");
    TestLookupNameW( L"Network" ); TestLookupNameA( "Network" );

    printf("    Lookup Batch\n");
    TestLookupNameW( L"Batch" ); TestLookupNameA( "Batch" );

    printf("    Lookup Interactive\n");
    TestLookupNameW( L"Interactive" ); TestLookupNameA( "Interactive" );

    printf("    Look up LocalSystem\n");
    TestLookupNameW( L"LocalSystem" ); TestLookupNameA( "LocalSystem" );

    printf("\n\n\n");
    return;

}

VOID
TestLookupPrivilegeValue()
{

    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       LookupPrivilegeValue Tests                                    //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("\n\n\n");
    printf("  Privilege Value Lookup . . . . . . . . . . . . suite\n");

    printf("    Lookup SeCreateTokenPrivilege\n");
    TestLookupPrivilegeValueW( &SeCreateTokenPrivilege );
    TestLookupPrivilegeValueA( &SeCreateTokenPrivilege );

    printf("    Lookup SeAssignPrimaryTokenPrivilege\n");
    TestLookupPrivilegeValueW( &SeAssignPrimaryTokenPrivilege );
    TestLookupPrivilegeValueA( &SeAssignPrimaryTokenPrivilege );

    printf("    Lookup SeLockMemoryPrivilege\n");
    TestLookupPrivilegeValueW( &SeLockMemoryPrivilege );
    TestLookupPrivilegeValueA( &SeLockMemoryPrivilege );

    printf("    Lookup SeIncreaseQuotaPrivilege\n");
    TestLookupPrivilegeValueW( &SeIncreaseQuotaPrivilege );
    TestLookupPrivilegeValueA( &SeIncreaseQuotaPrivilege );

    printf("    Lookup SeUnsolicitedInputPrivilege\n");
    TestLookupPrivilegeValueW( &SeUnsolicitedInputPrivilege );
    TestLookupPrivilegeValueA( &SeUnsolicitedInputPrivilege );

    printf("    Lookup SeTcbPrivilege\n");
    TestLookupPrivilegeValueW( &SeTcbPrivilege );
    TestLookupPrivilegeValueA( &SeTcbPrivilege );

    printf("    Lookup SeSecurityPrivilege\n");
    TestLookupPrivilegeValueW( &SeSecurityPrivilege );
    TestLookupPrivilegeValueA( &SeSecurityPrivilege );

    printf("    Lookup SeTakeOwnershipPrivilege\n");
    TestLookupPrivilegeValueW( &SeTakeOwnershipPrivilege );
    TestLookupPrivilegeValueA( &SeTakeOwnershipPrivilege );

    printf("    Lookup SeLoadDriverPrivilege\n");
    TestLookupPrivilegeValueW( &SeLoadDriverPrivilege );
    TestLookupPrivilegeValueA( &SeLoadDriverPrivilege );

    printf("    Lookup SeCreatePagefilePrivilege\n");
    TestLookupPrivilegeValueW( &SeCreatePagefilePrivilege );
    TestLookupPrivilegeValueA( &SeCreatePagefilePrivilege );

    printf("    Lookup SeIncreaseBasePriorityPrivilege\n");
    TestLookupPrivilegeValueW( &SeIncreaseBasePriorityPrivilege );
    TestLookupPrivilegeValueA( &SeIncreaseBasePriorityPrivilege );

    printf("    Lookup SeSystemProfilePrivilege\n");
    TestLookupPrivilegeValueW( &SeSystemProfilePrivilege );
    TestLookupPrivilegeValueA( &SeSystemProfilePrivilege );

    printf("    Lookup SeSystemtimePrivilege\n");
    TestLookupPrivilegeValueW( &SeSystemtimePrivilege );
    TestLookupPrivilegeValueA( &SeSystemtimePrivilege );

    printf("    Lookup SeProfileSingleProcessPrivilege\n");
    TestLookupPrivilegeValueW( &SeProfileSingleProcessPrivilege );
    TestLookupPrivilegeValueA( &SeProfileSingleProcessPrivilege );

    printf("    Lookup SeCreatePermanentPrivilege\n");
    TestLookupPrivilegeValueW( &SeCreatePermanentPrivilege );
    TestLookupPrivilegeValueA( &SeCreatePermanentPrivilege );

    printf("    Lookup SeBackupPrivilege\n");
    TestLookupPrivilegeValueW( &SeBackupPrivilege );
    TestLookupPrivilegeValueA( &SeBackupPrivilege );

    printf("    Lookup SeRestorePrivilege\n");
    TestLookupPrivilegeValueW( &SeRestorePrivilege );
    TestLookupPrivilegeValueA( &SeRestorePrivilege );

    printf("    Lookup SeShutdownPrivilege\n");
    TestLookupPrivilegeValueW( &SeShutdownPrivilege );
    TestLookupPrivilegeValueA( &SeShutdownPrivilege );

    printf("    Lookup SeDebugPrivilege\n");
    TestLookupPrivilegeValueW( &SeDebugPrivilege );
    TestLookupPrivilegeValueA( &SeDebugPrivilege );

    printf("    Lookup SeAuditPrivilege\n");
    TestLookupPrivilegeValueW( &SeAuditPrivilege );
    TestLookupPrivilegeValueA( &SeAuditPrivilege );

    printf("    Lookup SeSystemEnvironmentPrivilege\n");
    TestLookupPrivilegeValueW( &SeSystemEnvironmentPrivilege );
    TestLookupPrivilegeValueA( &SeSystemEnvironmentPrivilege );

    printf("    Lookup SeChangeNotifyPrivilege\n");
    TestLookupPrivilegeValueW( &SeChangeNotifyPrivilege );
    TestLookupPrivilegeValueA( &SeChangeNotifyPrivilege );

    printf("    Lookup SeRemoteShutdownPrivilege\n");
    TestLookupPrivilegeValueW( &SeRemoteShutdownPrivilege );
    TestLookupPrivilegeValueA( &SeRemoteShutdownPrivilege );

    printf("\n\n\n");
    return;
}

VOID
TestLookupPrivilegeName()
{
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       LookupPrivilegeName  Tests                                    //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("\n\n\n");
    printf("  Privilege Name Lookup  . . . . . . . . . . . . suite\n");


    printf("    Lookup SeCreateTokenPrivilege\n");
    TestLookupPrivilegeNameW( &SeCreateTokenPrivilege );
    TestLookupPrivilegeNameA( &SeCreateTokenPrivilege );

    printf("    Lookup SeAssignPrimaryTokenPrivilege\n");
    TestLookupPrivilegeNameW( &SeAssignPrimaryTokenPrivilege );
    TestLookupPrivilegeNameA( &SeAssignPrimaryTokenPrivilege );

    printf("    Lookup SeLockMemoryPrivilege\n");
    TestLookupPrivilegeNameW( &SeLockMemoryPrivilege );
    TestLookupPrivilegeNameA( &SeLockMemoryPrivilege );

    printf("    Lookup SeIncreaseQuotaPrivilege\n");
    TestLookupPrivilegeNameW( &SeIncreaseQuotaPrivilege );
    TestLookupPrivilegeNameA( &SeIncreaseQuotaPrivilege );

    printf("    Lookup SeUnsolicitedInputPrivilege\n");
    TestLookupPrivilegeNameW( &SeUnsolicitedInputPrivilege );
    TestLookupPrivilegeNameA( &SeUnsolicitedInputPrivilege );

    printf("    Lookup SeTcbPrivilege\n");
    TestLookupPrivilegeNameW( &SeTcbPrivilege );
    TestLookupPrivilegeNameA( &SeTcbPrivilege );

    printf("    Lookup SeSecurityPrivilege\n");
    TestLookupPrivilegeNameW( &SeSecurityPrivilege );
    TestLookupPrivilegeNameA( &SeSecurityPrivilege );

    printf("    Lookup SeTakeOwnershipPrivilege\n");
    TestLookupPrivilegeNameW( &SeTakeOwnershipPrivilege );
    TestLookupPrivilegeNameA( &SeTakeOwnershipPrivilege );

    printf("    Lookup SeLoadDriverPrivilege\n");
    TestLookupPrivilegeNameW( &SeLoadDriverPrivilege );
    TestLookupPrivilegeNameA( &SeLoadDriverPrivilege );


    printf("    Lookup SeCreatePagefilePrivilege\n");
    TestLookupPrivilegeNameW( &SeCreatePagefilePrivilege );
    TestLookupPrivilegeNameA( &SeCreatePagefilePrivilege );

    printf("    Lookup SeIncreaseBasePriorityPrivilege\n");
    TestLookupPrivilegeNameW( &SeIncreaseBasePriorityPrivilege );
    TestLookupPrivilegeNameA( &SeIncreaseBasePriorityPrivilege );

    printf("    Lookup SeSystemProfilePrivilege\n");
    TestLookupPrivilegeNameW( &SeSystemProfilePrivilege );
    TestLookupPrivilegeNameA( &SeSystemProfilePrivilege );

    printf("    Lookup SeSystemtimePrivilege\n");
    TestLookupPrivilegeNameW( &SeSystemtimePrivilege );
    TestLookupPrivilegeNameA( &SeSystemtimePrivilege );

    printf("    Lookup SeProfileSingleProcessPrivilege\n");
    TestLookupPrivilegeNameW( &SeProfileSingleProcessPrivilege );
    TestLookupPrivilegeNameA( &SeProfileSingleProcessPrivilege );

    printf("    Lookup SeCreatePermanentPrivilege\n");
    TestLookupPrivilegeNameW( &SeCreatePermanentPrivilege );
    TestLookupPrivilegeNameA( &SeCreatePermanentPrivilege );

    printf("    Lookup SeBackupPrivilege\n");
    TestLookupPrivilegeNameW( &SeBackupPrivilege );
    TestLookupPrivilegeNameA( &SeBackupPrivilege );

    printf("    Lookup SeRestorePrivilege\n");
    TestLookupPrivilegeNameW( &SeRestorePrivilege );
    TestLookupPrivilegeNameA( &SeRestorePrivilege );

    printf("    Lookup SeShutdownPrivilege\n");
    TestLookupPrivilegeNameW( &SeShutdownPrivilege );
    TestLookupPrivilegeNameA( &SeShutdownPrivilege );

    printf("    Lookup SeDebugPrivilege\n");
    TestLookupPrivilegeNameW( &SeDebugPrivilege );
    TestLookupPrivilegeNameA( &SeDebugPrivilege );

    printf("    Lookup SeAuditPrivilege\n");
    TestLookupPrivilegeNameW( &SeAuditPrivilege );
    TestLookupPrivilegeNameA( &SeAuditPrivilege );

    printf("    Lookup SeSystemEnvironmentPrivilege\n");
    TestLookupPrivilegeNameW( &SeSystemEnvironmentPrivilege );
    TestLookupPrivilegeNameA( &SeSystemEnvironmentPrivilege );

    printf("    Lookup SeChangeNotifyPrivilege\n");
    TestLookupPrivilegeNameW( &SeChangeNotifyPrivilege );
    TestLookupPrivilegeNameA( &SeChangeNotifyPrivilege );

    printf("    Lookup SeRemoteShutdownPrivilege\n");
    TestLookupPrivilegeNameW( &SeRemoteShutdownPrivilege );
    TestLookupPrivilegeNameA( &SeRemoteShutdownPrivilege );

    printf("\n\n\n");
    return;
}

VOID
TestLookupPrivilegeDisplayName()
{
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       LookupPrivilegeDisplayName Tests                              //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("  Privilege Display Name Lookup  . . . . . . . . suite\n");


    printf("    Lookup SeCreateTokenPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeCreateTokenPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeCreateTokenPrivilege );

    printf("    Lookup SeAssignPrimaryTokenPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeAssignPrimaryTokenPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeAssignPrimaryTokenPrivilege );

    printf("    Lookup SeLockMemoryPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeLockMemoryPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeLockMemoryPrivilege );

    printf("    Lookup SeIncreaseQuotaPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeIncreaseQuotaPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeIncreaseQuotaPrivilege );

    printf("    Lookup SeUnsolicitedInputPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeUnsolicitedInputPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeUnsolicitedInputPrivilege );

    printf("    Lookup SeTcbPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeTcbPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeTcbPrivilege );

    printf("    Lookup SeSecurityPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeSecurityPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeSecurityPrivilege );

    printf("    Lookup SeTakeOwnershipPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeTakeOwnershipPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeTakeOwnershipPrivilege );

    printf("    Lookup SeLoadDriverPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeLoadDriverPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeLoadDriverPrivilege );

    printf("    Lookup SeCreatePagefilePrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeCreatePagefilePrivilege );
    TestLookupPrivilegeDisplayNameA( &SeCreatePagefilePrivilege );

    printf("    Lookup SeIncreaseBasePriorityPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeIncreaseBasePriorityPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeIncreaseBasePriorityPrivilege );

    printf("    Lookup SeSystemProfilePrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeSystemProfilePrivilege );
    TestLookupPrivilegeDisplayNameA( &SeSystemProfilePrivilege );

    printf("    Lookup SeSystemtimePrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeSystemtimePrivilege );
    TestLookupPrivilegeDisplayNameA( &SeSystemtimePrivilege );

    printf("    Lookup SeProfileSingleProcessPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeProfileSingleProcessPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeProfileSingleProcessPrivilege );

    printf("    Lookup SeCreatePermanentPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeCreatePermanentPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeCreatePermanentPrivilege );

    printf("    Lookup SeBackupPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeBackupPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeBackupPrivilege );

    printf("    Lookup SeRestorePrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeRestorePrivilege );
    TestLookupPrivilegeDisplayNameA( &SeRestorePrivilege );

    printf("    Lookup SeShutdownPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeShutdownPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeShutdownPrivilege );

    printf("    Lookup SeDebugPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeDebugPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeDebugPrivilege );

    printf("    Lookup SeAuditPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeAuditPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeAuditPrivilege );

    printf("    Lookup SeSystemEnvironmentPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeSystemEnvironmentPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeSystemEnvironmentPrivilege );

    printf("    Lookup SeChangeNotifyPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeChangeNotifyPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeChangeNotifyPrivilege );

    printf("    Lookup SeRemoteShutdownPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeRemoteShutdownPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeRemoteShutdownPrivilege );

    printf("\n\n\n");
    return;
}

int
main (void)
{

    initialize();

    TestLookupSid();

    TestLookupName();


    TestLookupPrivilegeName();

    TestLookupPrivilegeValue();

    TestLookupPrivilegeDisplayName();


    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\updres.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    updres.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define	DEFAULT_CODEPAGE	1252
#define	MAJOR_RESOURCE_VERSION	4
#define	MINOR_RESOURCE_VERSION	0

#define BUTTONCODE	0x80
#define EDITCODE	0x81
#define STATICCODE	0x82
#define LISTBOXCODE	0x83
#define SCROLLBARCODE	0x84
#define COMBOBOXCODE	0x85

#define	SEEK_SET	0
#define	SEEK_CUR	1
#define	SEEK_END	2
#define	MAXSTR		(256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//

#define ID_WORD 0xffff

//typedef	WCHAR	*PWCHAR;

typedef struct MY_STRING {
	ULONG discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct MY_STRING *pnext;
		  ULONG  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  *sz;
		} ss;
		WORD     Ordinal;
	} uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz

typedef struct _RESNAME {
        struct _RESNAME *pnext;	// The first three fields should be the
        PSDATA Name;		// same in both res structures
        ULONG   OffsetToData;

        PSDATA	Type;
	ULONG	SectionNumber;
        ULONG	DataSize;
        ULONG_PTR   OffsetToDataEntry;
        USHORT  ResourceNumber;
        USHORT  NumberOfLanguages;
        WORD	LanguageId;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
        struct _RESTYPE *pnext;	// The first three fields should be the
        PSDATA Type;		// same in both res structures
        ULONG   OffsetToData;

        struct _RESNAME *NameHeadID;
        struct _RESNAME *NameHeadName;
        ULONG  NumberOfNamesID;
        ULONG  NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;

typedef struct _UPDATEDATA {
        ULONG	cbStringTable;
        PSDATA	StringHead;
        PRESNAME	ResHead;
        PRESTYPE	ResTypeHeadID;
        PRESTYPE	ResTypeHeadName;
        LONG	Status;
        HANDLE	hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG		(sizeof(LONG))
#define BUFSIZE		(4L * 1024L)

/* functions for adding/deleting resources to update list */

LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG  cb
    );

PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    );

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fName,
    INT cb,
    PVOID lpData
    );

BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fType,
    INT	fName
    );

/* Prototypes for Enumeration done in BeginUpdateResource */

BOOL
EnumTypesFunc(
    HANDLE hModule,
    LPWSTR lpType,
    LPARAM lParam
    );

BOOL
EnumNamesFunc(
    HANDLE hModule,
    LPWSTR lpName,
    LPWSTR lpType,
    LPARAM lParam
    );

BOOL
EnumLangsFunc(
    HANDLE hModule,
    LPWSTR lpType,
    LPWSTR lpName,
    WORD languages,
    LPARAM lParam
    );

/* Prototypes for genral worker functions in updres.c */

LONG
WriteResFile(
    IN HANDLE	hUpdate,
    IN WCHAR	*pDstname
    );

VOID
FreeData(
    PUPDATEDATA pUpd
    );

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME pResSave
    );

LONG
PatchRVAs(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    PIMAGE_NT_HEADERS pNew,
    ULONG OldSize);

LONG
PatchDebug(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32DebugOld,
    PIMAGE_SECTION_HEADER po32DebugNew,
    PIMAGE_SECTION_HEADER po32DebugDirOld,
    PIMAGE_SECTION_HEADER po32DebugDirNew,
    PIMAGE_NT_HEADERS pOld,
    PIMAGE_NT_HEADERS pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\updrsrc.cpp ===
/******************************************************************************

    PROGRAM: updres.c

    PURPOSE: Contains API Entry points and routines for updating resource
                sections in exe/dll

    FUNCTIONS:

        EndUpdateResource(HANDLE, BOOL)         - end update, write changes
        UpdateResource(HANDLE, LPSTR, LPSTR, WORD, PVOID)
                                                - update individual resource
        BeginUpdateResource(LPSTR)              - begin update

*******************************************************************************/

#include "basedll.h"
#pragma hdrstop

#include <updrsrc.h>

char    *pchPad = "PADDINGXXPADDING";
char    *pchZero = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";


/****************************************************************************
**
** API entry points
**
****************************************************************************/


HANDLE
APIENTRY
BeginUpdateResourceW(
                    LPCWSTR pwch,
                    BOOL bDeleteExistingResources
                    )

/*++
    Routine Description
        Begins an update of resources.  Save away the name
        and current resources in a list, using EnumResourceXxx
        api set.

    Parameters:

        lpFileName - Supplies the name of the executable file that the
        resource specified by lpType/lpName/language will be updated
        in.  This file must be able to be opened for writing (ie, not
        currently executing, etc.)  The file may be fully qualified,
        or if not, the current directory is assumed.  It must be a
        valid Windows executable file.

        bDeleteExistingResources - if TRUE, existing resources are
        deleted, and only new resources will appear in the result.
        Otherwise, all resources in the input file will be in the
        output file unless specifically deleted or replaced.

    Return Value:

    NULL - The file specified was not able to be opened for writing.
    Either it was not an executable image, the executable image is
    already loaded, or the filename did not exist.  More information may
    be available via GetLastError api.

    HANDLE - A handle to be passed to the UpdateResource and
    EndUpdateResources function.
--*/

{
    HMODULE     hModule;
    PUPDATEDATA pUpdate;
    HANDLE      hUpdate;
    LPWSTR      pFileName;
    DWORD       attr;

    SetLastError(NO_ERROR);
    if (pwch == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    hUpdate = GlobalAlloc(GHND, sizeof(UPDATEDATA));
    if (hUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    pUpdate->Status = NO_ERROR;
    pUpdate->hFileName = GlobalAlloc(GHND, (wcslen(pwch)+1)*sizeof(WCHAR));
    if (pUpdate->hFileName == NULL) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pFileName = (LPWSTR)GlobalLock(pUpdate->hFileName);
    if (pFileName == NULL) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    wcscpy(pFileName, pwch);
    GlobalUnlock(pUpdate->hFileName);

    attr = GetFileAttributesW(pFileName);
    if (attr == 0xffffffff) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        return NULL;
    } else if (attr & (FILE_ATTRIBUTE_READONLY |
                       FILE_ATTRIBUTE_SYSTEM |
                       FILE_ATTRIBUTE_HIDDEN |
                       FILE_ATTRIBUTE_DIRECTORY)) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_WRITE_PROTECT);
        return NULL;
    }

    if (bDeleteExistingResources)
        ;
    else {
        hModule = LoadLibraryExW(pwch, NULL,LOAD_LIBRARY_AS_DATAFILE| DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL) {
            GlobalUnlock(hUpdate);
            GlobalFree(hUpdate);
            if (GetLastError() == NO_ERROR)
                SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        } else
            EnumResourceTypesW(hModule, (ENUMRESTYPEPROCW)EnumTypesFunc, (LONG_PTR)pUpdate);
        FreeLibrary(hModule);
    }

    if (pUpdate->Status != NO_ERROR) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        // return code set by enum functions
        return NULL;
    }
    GlobalUnlock(hUpdate);
    return hUpdate;
}



HANDLE
APIENTRY
BeginUpdateResourceA(
                    LPCSTR pch,
                    BOOL bDeleteExistingResources
                    )

/*++
    Routine Description

    ASCII entry point.  Convert filename to UNICODE and call
    the UNICODE entry point.

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString, pch);
    Status = RtlAnsiStringToUnicodeString(Unicode, &AnsiString, FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            //BaseSetLastNTError(Status);
            SetLastError(RtlNtStatusToDosError(Status));
        }
        return FALSE;
    }

    return BeginUpdateResourceW((LPCWSTR)Unicode->Buffer,bDeleteExistingResources);
}



BOOL
APIENTRY
UpdateResourceW(
               HANDLE      hUpdate,
               LPCWSTR     lpType,
               LPCWSTR     lpName,
               WORD        language,
               LPVOID      lpData,
               ULONG       cb
               )

/*++
    Routine Description
        This routine adds, deletes or modifies the input resource
        in the list initialized by BeginUpdateResource.  The modify
        case is simple, the add is easy, the delete is hard.
        The ASCII entry point converts inputs to UNICODE.

    Parameters:

        hUpdateFile - The handle returned by the BeginUpdateResources
        function.

        lpType - Points to a null-terminated character string that
        represents the type name of the resource to be updated or
        added.  May be an integer value passed to MAKEINTRESOURCE
        macro.  For predefined resource types, the lpType parameter
        should be one of the following values:

          RT_ACCELERATOR - Accelerator table
          RT_BITMAP - Bitmap resource
          RT_DIALOG - Dialog box
          RT_FONT - Font resource
          RT_FONTDIR - Font directory resource
          RT_MENU - Menu resource
          RT_RCDATA - User-defined resource (raw data)
          RT_VERSION - Version resource
          RT_ICON - Icon resource
          RT_CURSOR - Cursor resource



        lpName - Points to a null-terminated character string that
        represents the name of the resource to be updated or added.
        May be an integer value passed to MAKEINTRESOURCE macro.

        language - Is the word value that specifies the language of the
        resource to be updated.  A complete list of values is
        available in winnls.h.

        lpData - A pointer to the raw data to be inserted into the
        executable image's resource table and data.  If the data is
        one of the predefined types, it must be valid and properly
        aligned.  If lpData is NULL, the specified resource is to be
        deleted from the executable image.

        cb - count of bytes in the data.

    Return Value:

    TRUE - The resource specified was successfully replaced in, or added
    to, the specified executable image.

    FALSE/NULL - The resource specified was not successfully added to or
    updated in the executable image.  More information may be available
    via GetLastError api.
--*/


{
    PUPDATEDATA pUpdate;
    PSDATA      Type;
    PSDATA      Name;
    PVOID       lpCopy;
    LONG        fRet;

    SetLastError(0);
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL) {
        // GlobalLock set last error, nothing to unlock.
        return FALSE;
    }
    Name = AddStringOrID(lpName, pUpdate);
    if (Name == NULL) {
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    Type = AddStringOrID(lpType, pUpdate);
    if (Type == NULL) {
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    if (cb == 0) {
        lpCopy = NULL;
    } else {
        lpCopy = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
        if (lpCopy == NULL) {
            pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
            GlobalUnlock(hUpdate);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        RtlCopyMemory(lpCopy, lpData, cb);
    }
    fRet = AddResource(Type, Name, language, pUpdate, lpCopy, cb);
    GlobalUnlock(hUpdate);
    if (fRet == NO_ERROR)
        return TRUE;
    else {
        if (lpCopy != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, lpCopy);
        SetLastError(fRet);
        return FALSE;
    }
}



BOOL
APIENTRY
UpdateResourceA(
               HANDLE      hUpdate,
               LPCSTR      lpType,
               LPCSTR      lpName,
               WORD        language,
               LPVOID      lpData,
               ULONG       cb
               )
{
    LPCWSTR     lpwType;
    LPCWSTR     lpwName;
    INT         cch;
    UNICODE_STRING UnicodeType;
    UNICODE_STRING UnicodeName;
    STRING      string;
    BOOL        result;

    if ((ULONG_PTR)lpType >= LDR_RESOURCE_ID_NAME_MINVAL) {
        cch = strlen(lpType);
        string.Length = (USHORT)cch;
        string.MaximumLength = (USHORT)cch;
        string.Buffer = (PCHAR)lpType;
        RtlAnsiStringToUnicodeString(&UnicodeType, &string, TRUE);
        lpwType = (LPCWSTR)UnicodeType.Buffer;
    } else {
        lpwType = (LPCWSTR)lpType;
        RtlInitUnicodeString(&UnicodeType, NULL);
    }
    if ((ULONG_PTR)lpName >= LDR_RESOURCE_ID_NAME_MINVAL) {
        cch = strlen(lpName);
        string.Length = (USHORT)cch;
        string.MaximumLength = (USHORT)cch;
        string.Buffer = (PCHAR)lpName;
        RtlAnsiStringToUnicodeString(&UnicodeName, &string, TRUE);
        lpwName = (LPCWSTR)UnicodeName.Buffer;
    } else {
        lpwName = (LPCWSTR)lpName;
        RtlInitUnicodeString(&UnicodeName, NULL);
    }

    result = UpdateResourceW(hUpdate, lpwType, lpwName, language, lpData, cb);
    RtlFreeUnicodeString(&UnicodeType);
    RtlFreeUnicodeString(&UnicodeName);
    return result;
}


BOOL
APIENTRY
EndUpdateResourceW(
                  HANDLE      hUpdate,
                  BOOL        fDiscard
                  )

/*++
    Routine Description
        Finishes the UpdateResource action.  Copies the
        input file to a temporary, adds the resources left
        in the list (hUpdate) to the exe.

    Parameters:

        hUpdateFile - The handle returned by the BeginUpdateResources
        function.

        fDiscard - If TRUE, discards all the updates, frees all memory.

    Return Value:

    FALSE - The file specified was not able to be written.  More
    information may be available via GetLastError api.

    TRUE -  The accumulated resources specified by UpdateResource calls
    were written to the executable file specified by the hUpdateFile
    handle.
--*/

{
    LPWSTR      pFileName;
    PUPDATEDATA pUpdate;
    WCHAR       pTempFileName[MAX_PATH];
    INT         cch;
    LPWSTR      p;
    LONG        rc;
    DWORD       LastError = 0;

    SetLastError(0);
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (fDiscard) {
        rc = NO_ERROR;
    } else {
        if (pUpdate == NULL) {
            return FALSE;
        }
        pFileName = (LPWSTR)GlobalLock(pUpdate->hFileName);
        if (pFileName != NULL) {
            wcscpy(pTempFileName, pFileName);
            cch = wcslen(pTempFileName);
            p = pTempFileName + cch;
            while (*p != L'\\' && p >= pTempFileName)
                p--;
            *(p+1) = 0;
            rc = GetTempFileNameW(pTempFileName, L"RCX", 0, pTempFileName);
            if (rc == 0) {
                rc = GetTempPathW(MAX_PATH, pTempFileName);
                if (rc == 0) {
                    pTempFileName[0] = L'.';
                    pTempFileName[1] = L'\\';
                    pTempFileName[2] = 0;
                }
                rc = GetTempFileNameW(pTempFileName, L"RCX", 0, pTempFileName);
                if (rc == 0) {
                    rc = GetLastError();
                } else {
                    rc = WriteResFile(hUpdate, pTempFileName);
                    if (rc == NO_ERROR) {
                        DeleteFileW(pFileName);
                        MoveFileW(pTempFileName, pFileName);
                    } else {
                        LastError = rc;
                        DeleteFileW(pTempFileName);
                    }
                }
            } else {
                rc = WriteResFile(hUpdate, pTempFileName);
                if (rc == NO_ERROR) {
                    DeleteFileW(pFileName);
                    MoveFileW(pTempFileName, pFileName);
                } else {
                    LastError = rc;
                    DeleteFileW(pTempFileName);
                }
            }
            GlobalUnlock(pUpdate->hFileName);
        }
        GlobalFree(pUpdate->hFileName);
    }

    if (pUpdate != NULL) {
        FreeData(pUpdate);
        GlobalUnlock(hUpdate);
    }
    GlobalFree(hUpdate);

    SetLastError(LastError);
    return rc?FALSE:TRUE;
}


BOOL
APIENTRY
EndUpdateResourceA(
                  HANDLE      hUpdate,
                  BOOL        fDiscard)
/*++
    Routine Description
        Ascii version - see above for description.
--*/
{
    return EndUpdateResourceW(hUpdate, fDiscard);
}


/**********************************************************************
**
**  End of API entry points.
**
**  Beginning of private entry points for worker routines to do the
**  real work.
**
***********************************************************************/


BOOL
EnumTypesFunc(
             HANDLE hModule,
             LPWSTR lpType,
             LPARAM lParam
             )
{

    EnumResourceNamesW((HINSTANCE)hModule, lpType, (ENUMRESNAMEPROCW)EnumNamesFunc, lParam);

    return TRUE;
}



BOOL
EnumNamesFunc(
             HANDLE hModule,
             LPWSTR lpType,
             LPWSTR lpName,
             LPARAM lParam
             )
{

    EnumResourceLanguagesW((HINSTANCE)hModule, lpType, lpName, (ENUMRESLANGPROCW)EnumLangsFunc, lParam);
    return TRUE;
}



BOOL
EnumLangsFunc(
             HANDLE hModule,
             LPWSTR lpType,
             LPWSTR lpName,
             WORD language,
             LPARAM lParam
             )
{
    HANDLE      hResInfo;
    LONG        fError;
    PSDATA      Type;
    PSDATA      Name;
    ULONG       cb;
    PVOID       lpData;
    HANDLE      hResource;
    PVOID       lpResource;

    hResInfo = FindResourceExW((HINSTANCE)hModule, lpType, lpName, language);
    if (hResInfo == NULL) {
        return FALSE;
    } else {
        Type = AddStringOrID(lpType, (PUPDATEDATA)lParam);
        if (Type == NULL) {
            ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
        Name = AddStringOrID(lpName, (PUPDATEDATA)lParam);
        if (Name == NULL) {
            ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }

        cb = SizeofResource((HINSTANCE)hModule, (HRSRC)hResInfo);
        if (cb == 0) {
            return FALSE;
        }
        lpData = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
        if (lpData == NULL) {
            return FALSE;
        }
        RtlZeroMemory(lpData, cb);

        hResource = LoadResource((HINSTANCE)hModule, (HRSRC)hResInfo);
        if (hResource == NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, lpData);
            return FALSE;
        }

        lpResource = (PVOID)LockResource(hResource);
        if (lpResource == NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, lpData);
            return FALSE;
        }

        RtlCopyMemory(lpData, lpResource, cb);
        (VOID)UnlockResource(hResource);
        (VOID)FreeResource(hResource);

        fError = AddResource(Type, Name, language, (PUPDATEDATA)lParam, lpData, cb);
        if (fError != NO_ERROR) {
            ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }

    return TRUE;
}


VOID
FreeOne(
       PRESNAME pRes
       )
{
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes->OffsetToDataEntry);
    if (IS_ID == pRes->Name->discriminant) {
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes->Name);
    }
    if (IS_ID == pRes->Type->discriminant) {
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes->Type);
    }
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes);
}


VOID
FreeData(
        PUPDATEDATA pUpd
        )
{
    PRESTYPE    pType;
    PRESNAME    pRes;
    PSDATA      pstring, pStringTmp;

    for (pType=pUpd->ResTypeHeadID ; pUpd->ResTypeHeadID ; pType=pUpd->ResTypeHeadID) {
        pUpd->ResTypeHeadID = pUpd->ResTypeHeadID->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pType);
    }

    for (pType=pUpd->ResTypeHeadName ; pUpd->ResTypeHeadName ; pType=pUpd->ResTypeHeadName) {
        pUpd->ResTypeHeadName = pUpd->ResTypeHeadName->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pType);
    }

    pstring = pUpd->StringHead;
    while (pstring != NULL) {
        pStringTmp = pstring->uu.ss.pnext;
        if (pstring->discriminant == IS_STRING)
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring->szStr);
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
        pstring = pStringTmp;
    }

    return;
}


/*+++

    Routines to register strings

---*/

//
//  Resources are DWORD aligned and may be in any order.
//

#define TABLE_ALIGN  4
#define DATA_ALIGN  4L



PSDATA
AddStringOrID(
             LPCWSTR     lp,
             PUPDATEDATA pupd
             )
{
    USHORT cb;
    PSDATA pstring;
    PPSDATA ppstring;

    if ((ULONG_PTR)lp < LDR_RESOURCE_ID_NAME_MINVAL) {
        //
        // an ID
        //
        pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(SDATA));
        if (pstring == NULL)
            return NULL;
        RtlZeroMemory((PVOID)pstring, sizeof(SDATA));
        pstring->discriminant = IS_ID;

        pstring->uu.Ordinal = (WORD)((ULONG_PTR)lp & 0x0000ffff);
    } else {
        //
        // a string
        //
        cb = wcslen(lp) + 1;
        ppstring = &pupd->StringHead;

        while ((pstring = *ppstring) != NULL) {
            if (!wcsncmp(pstring->szStr, lp, cb))
                break;
            ppstring = &(pstring->uu.ss.pnext);
        }

        if (!pstring) {

            //
            // allocate a new one
            //

            pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(),
                                              MAKE_TAG( RES_TAG ) | HEAP_ZERO_MEMORY,
                                              sizeof(SDATA)
                                             );
            if (pstring == NULL)
                return NULL;
            RtlZeroMemory((PVOID)pstring, sizeof(SDATA));

            pstring->szStr = (WCHAR*)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                                                     cb*sizeof(WCHAR));
            if (pstring->szStr == NULL) {
                RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
                return NULL;
            }
            pstring->discriminant = IS_STRING;
            pstring->OffsetToString = pupd->cbStringTable;

            pstring->cbData = sizeof(pstring->cbsz) + cb * sizeof(WCHAR);
            pstring->cbsz = cb - 1;     /* don't include zero terminator */
            RtlCopyMemory(pstring->szStr, lp, cb*sizeof(WCHAR));

            pupd->cbStringTable += pstring->cbData;

            pstring->uu.ss.pnext=NULL;
            *ppstring=pstring;
        }
    }

    return(pstring);
}
//
// add a resource into the resource directory hiearchy
//


LONG
AddResource(
           IN PSDATA Type,
           IN PSDATA Name,
           IN WORD Language,
           IN PUPDATEDATA pupd,
           IN PVOID lpData,
           IN ULONG cb
           )
{
    PRESTYPE  pType;
    PPRESTYPE ppType;
    PRESNAME  pName;
    PRESNAME  pNameM;
    PPRESNAME ppName = NULL;
    BOOL fTypeID=(Type->discriminant == IS_ID);
    BOOL fNameID=(Name->discriminant == IS_ID);
    BOOL fSame=FALSE;
    int iCompare;

    //
    // figure out which list to store it in
    //

    ppType = fTypeID ? &pupd->ResTypeHeadID : &pupd->ResTypeHeadName;

    //
    // Try to find the Type in the list
    //

    while ((pType=*ppType) != NULL) {
        if (pType->Type->uu.Ordinal == Type->uu.Ordinal) {
            ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
            break;
        }
        if (fTypeID) {
            if (Type->uu.Ordinal < pType->Type->uu.Ordinal)
                break;
        } else {
            if (wcscmp(Type->szStr, pType->Type->szStr) < 0)
                break;
        }
        ppType = &(pType->pnext);
    }

    //
    // Create a new type if needed
    //

    if (ppName == NULL) {
        pType = (PRESTYPE)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESTYPE));
        if (pType == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        RtlZeroMemory((PVOID)pType, sizeof(RESTYPE));
        pType->pnext = *ppType;
        *ppType = pType;
        pType->Type = Type;
        ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
    }

    //
    // Find proper place for name
    //

    while ( (pName = *ppName) != NULL) {
        if (fNameID) {
            if (Name->uu.Ordinal == pName->Name->uu.Ordinal) {
                fSame = TRUE;
                break;
            }
            if (Name->uu.Ordinal < pName->Name->uu.Ordinal)
                break;
        } else {
            iCompare = wcscmp(Name->szStr, pName->Name->szStr );
            if (iCompare == 0) {
                fSame = TRUE;
                break;
            } else if (iCompare < 0) {
                break;
            }
        }
        ppName = &(pName->pnext);
    }

    //
    // check for delete/modify
    //

    if (fSame) {                                /* same name, new language */
        if (pName->NumberOfLanguages == 1) {    /* one language currently ? */
            if (Language == pName->LanguageId) {        /* REPLACE || DELETE */
                pName->DataSize = cb;
                if (lpData == NULL) {                   /* DELETE */
                    return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
                }
                RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                if (IS_ID == Type->discriminant) {
                    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Type);
                }
                if (IS_ID == Name->discriminant) {
                    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Name);
                }
                pName->OffsetToDataEntry = (ULONG_PTR)lpData;
                return NO_ERROR;
            } else {
                if (lpData == NULL) {                   /* no data but new? */
                    return ERROR_INVALID_PARAMETER;     /* badness */
                }
                return InsertResourceIntoLangList(pupd, Type, Name, pType, pName, Language, fNameID, cb, lpData);
            }
        } else {                                  /* many languages currently */
            pNameM = pName;                     /* save head of lang list   */
            while ( (pName = *ppName) != NULL) {/* find insertion point     */
                if (!(fNameID ? pName->Name->uu.Ordinal == (*ppName)->Name->uu.Ordinal :
                      !wcscmp(pName->Name->uu.ss.sz, (*ppName)->Name->uu.ss.sz)) ||
                    Language <= pName->LanguageId)      /* here? */
                    break;                              /* yes   */
                ppName = &(pName->pnext);       /* traverse language list */
            }

            if (pName && Language == pName->LanguageId) { /* language found? */
                if (lpData == NULL) {                     /* DELETE          */
                    return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
                }

                pName->DataSize = cb;                   /* REPLACE */
                RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                if (IS_ID == Type->discriminant) {
                    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Type);
                }
                if (IS_ID == Name->discriminant) {
                    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Name);
                }
                pName->OffsetToDataEntry = (ULONG_PTR)lpData;
                return NO_ERROR;
            } else {                                      /* add new language */
                return InsertResourceIntoLangList(pupd, Type, Name, pType, pNameM, Language, fNameID, cb, lpData);
            }
        }
    } else {                                      /* unique name */
        if (lpData == NULL) {                   /* can't delete new name */
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // add new name/language
    //

    if (!fSame) {
        if (fNameID)
            pType->NumberOfNamesID++;
        else
            pType->NumberOfNamesName++;
    }

    pName = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    RtlZeroMemory((PVOID)pName, sizeof(RESNAME));
    pName->pnext = *ppName;
    *ppName = pName;
    pName->Name = Name;
    pName->Type = Type;
    pName->NumberOfLanguages = 1;
    pName->LanguageId = Language;
    pName->DataSize = cb;
    pName->OffsetToDataEntry = (ULONG_PTR)lpData;

    return NO_ERROR;
}


BOOL
DeleteResourceFromList(
                      PUPDATEDATA pUpd,
                      PRESTYPE pType,
                      PRESNAME pName,
                      INT Language,
                      INT fType,
                      INT fName
                      )
{
    PPRESTYPE   ppType;
    PPRESNAME   ppName;
    PRESNAME    pNameT;

    /* find previous type node */
    ppType = fType ? &pUpd->ResTypeHeadID : &pUpd->ResTypeHeadName;
    while (*ppType != pType) {
        ppType = &((*ppType)->pnext);
    }

    /* find previous type node */
    ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
    pNameT = NULL;
    while (*ppName != pName) {
        if (pNameT == NULL) {           /* find first Name in lang list */
            if (fName) {
                if ((*ppName)->Name->uu.Ordinal == pName->Name->uu.Ordinal) {
                    pNameT = *ppName;
                }
            } else {
                if (wcscmp((*ppName)->Name->szStr, pName->Name->szStr) == 0) {
                    pNameT = *ppName;
                }
            }
        }
        ppName = &((*ppName)->pnext);
    }

    if (pNameT == NULL) {       /* first of this name? */
        pNameT = pName->pnext;  /* then (possibly) make next head of lang */
        if (pNameT != NULL) {
            if (fName) {
                if (pNameT->Name->uu.Ordinal == pName->Name->uu.Ordinal) {
                    pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
                }
            } else {
                if (wcscmp(pNameT->Name->szStr, pName->Name->szStr) == 0) {
                    pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
                }
            }
        }
    } else
        pNameT->NumberOfLanguages--;

    if (pNameT) {
        if (pNameT->NumberOfLanguages == 0) {
            if (fName)
                pType->NumberOfNamesID -= 1;
            else
                pType->NumberOfNamesName -= 1;
        }
    }

    *ppName = pName->pnext;             /* link to next */
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pName->OffsetToDataEntry);
    RtlFreeHeap(RtlProcessHeap(), 0, pName);    /* and free */

    if (*ppName == NULL) {              /* type list completely empty? */
        *ppType = pType->pnext;                 /* link to next */
        RtlFreeHeap(RtlProcessHeap(), 0, pType);        /* and free */
    }

    return NO_ERROR;
}

BOOL
InsertResourceIntoLangList(
                          PUPDATEDATA pUpd,
                          PSDATA Type,
                          PSDATA Name,
                          PRESTYPE pType,
                          PRESNAME pName,
                          INT Language,
                          INT fName,
                          INT cb,
                          PVOID lpData
                          )
{
    PRESNAME    pNameM;
    PRESNAME    pNameNew;
    PPRESNAME   ppName;

    pNameNew = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pNameNew == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    RtlZeroMemory((PVOID)pNameNew, sizeof(RESNAME));
    pNameNew->Name = Name;
    pNameNew->Type = Type;
    pNameNew->LanguageId = (WORD)Language;
    pNameNew->DataSize = cb;
    pNameNew->OffsetToDataEntry = (ULONG_PTR)lpData;

    if (Language < pName->LanguageId) {         /* have to add to the front */
        pNameNew->NumberOfLanguages = pName->NumberOfLanguages + 1;
        pName->NumberOfLanguages = 1;

        ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
        /* don't have to look for NULL at end of list !!!                    */
        while (pName != *ppName) {              /* find insertion point        */
            ppName = &((*ppName)->pnext);       /* traverse language list    */
        }
        pNameNew->pnext = *ppName;              /* insert                    */
        *ppName = pNameNew;
    } else {
        pNameM = pName;
        pName->NumberOfLanguages += 1;
        while ( (pName != NULL) &&
                (fName ? Name->uu.Ordinal == pName->Name->uu.Ordinal :
                 !wcscmp(Name->uu.ss.sz, pName->Name->uu.ss.sz))) {                        /* find insertion point        */
            if (Language <= pName->LanguageId)      /* here?                    */
                break;                                /* yes                        */
            pNameM = pName;
            pName = pName->pnext;                    /* traverse language list    */
        }
        pName = pNameM->pnext;
        pNameM->pnext = pNameNew;
        pNameNew->pnext = pName;
    }
    return NO_ERROR;
}


/*
 * Utility routines
 */


ULONG
FilePos(int fh)
{

    return _llseek(fh, 0L, SEEK_CUR);
}



ULONG
MuMoveFilePos( INT fh, ULONG pos )
{
    return _llseek( fh, pos, SEEK_SET );
}



ULONG
MuWrite( INT fh, PVOID p, ULONG n )
{
    ULONG       n1;

    if ((n1 = _lwrite(fh, (const char *)p, n)) != n) {
        return n1;
    } else
        return 0;
}



ULONG
MuRead(INT fh, UCHAR*p, ULONG n )
{
    ULONG       n1;

    if ((n1 = _lread( fh, p, n )) != n) {
        return n1;
    } else
        return 0;
}



BOOL
MuCopy( INT srcfh, INT dstfh, ULONG nbytes )
{
    ULONG       n;
    ULONG       cb=0L;
    PUCHAR      pb;

    pb = (PUCHAR)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), BUFSIZE);
    if (pb == NULL)
        return 0;
    RtlZeroMemory((PVOID)pb, BUFSIZE);

    while (nbytes) {
        if (nbytes <= BUFSIZE)
            n = nbytes;
        else
            n = BUFSIZE;
        nbytes -= n;

        if (!MuRead( srcfh, pb, n )) {
            cb += n;
            MuWrite( dstfh, pb, n );
        } else {
            RtlFreeHeap(RtlProcessHeap(), 0, pb);
            return cb;
        }
    }
    RtlFreeHeap(RtlProcessHeap(), 0, pb);
    return cb;
}



VOID
SetResdata(
          PIMAGE_RESOURCE_DATA_ENTRY  pResData,
          ULONG                       offset,
          ULONG                       size)
{
    pResData->OffsetToData = offset;
    pResData->Size = size;
    pResData->CodePage = DEFAULT_CODEPAGE;
    pResData->Reserved = 0L;
}


__inline VOID
SetRestab(
         PIMAGE_RESOURCE_DIRECTORY   pRestab,
         LONG                        time,
         WORD                        cNamed,
         WORD                        cId)
{
    pRestab->Characteristics = 0L;
    pRestab->TimeDateStamp = time;
    pRestab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pRestab->MinorVersion = MINOR_RESOURCE_VERSION;
    pRestab->NumberOfNamedEntries = cNamed;
    pRestab->NumberOfIdEntries = cId;
}


PIMAGE_SECTION_HEADER
FindSection(
           PIMAGE_SECTION_HEADER       pObjBottom,
           PIMAGE_SECTION_HEADER       pObjTop,
           LPSTR pName
           )
{
    while (pObjBottom < pObjTop) {
        if (strcmp((const char *)&pObjBottom->Name[0], pName) == 0)
            return pObjBottom;
        pObjBottom++;
    }

    return NULL;
}


ULONG
AssignResourceToSection(
                       PRESNAME    *ppRes,         /* resource to assign */
                       ULONG       ExtraSectionOffset,     /* offset between .rsrc and .rsrc1 */
                       ULONG       Offset,         /* next available offset in section */
                       LONG        Size,           /* Maximum size of .rsrc */
                       PLONG       pSizeRsrc1
                       )
{
    ULONG       cb;

    /* Assign this res to this section */
    cb = ROUNDUP((*ppRes)->DataSize, CBLONG);
    if (Offset < ExtraSectionOffset && Offset + cb > (ULONG)Size) {
        *pSizeRsrc1 = Offset;
        Offset = ExtraSectionOffset;
        DPrintf((DebugBuf, "<<< Secondary resource section @%#08lx >>>\n", Offset));
    }
    (*ppRes)->OffsetToData = Offset;
    *ppRes = (*ppRes)->pnext;
    DPrintf((DebugBuf, "    --> %#08lx bytes at %#08lx\n", cb, Offset));
    return Offset + cb;
}

//
// Adjust debug directory table.
//
// The following code instantiates the PatchDebug function template twice.
// Once to generate code for 32-bit image headers and once to generate
// code for 64-bit image headers.
//

template
LONG
PatchDebug<IMAGE_NT_HEADERS32>(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER pDebugOld,
    PIMAGE_SECTION_HEADER pDebugNew,
    PIMAGE_SECTION_HEADER pDebugDirOld,
    PIMAGE_SECTION_HEADER pDebugDirNew,
    IMAGE_NT_HEADERS32 *pOld,
    IMAGE_NT_HEADERS32 *pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData
    );

template
LONG
PatchDebug<IMAGE_NT_HEADERS64>(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER pDebugOld,
    PIMAGE_SECTION_HEADER pDebugNew,
    PIMAGE_SECTION_HEADER pDebugDirOld,
    PIMAGE_SECTION_HEADER pDebugDirNew,
    IMAGE_NT_HEADERS64 *pOld,
    IMAGE_NT_HEADERS64 *pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData
    );

//
// Patch various RVAs in the specified file to compensate for extra
// section table entries.
//
// The following code instantiates the PatchRVAs function template twice.
// Once to generate code for 32-bit image headers and once to generate
// code for 64-bit image headers.
//

template
LONG
PatchRVAs<IMAGE_NT_HEADERS32>(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    IMAGE_NT_HEADERS32 *pNew,
    ULONG OldSize
    );

template
LONG
PatchRVAs<IMAGE_NT_HEADERS64>(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    IMAGE_NT_HEADERS64 *pNew,
    ULONG OldSize
    );

/***************************** Main Worker Function ***************************
* LONG PEWriteResFile
*
* This function writes the resources to the named executable file.
* It assumes that resources have no fixups (even any existing resources
* that it removes from the executable.)  It places all the resources into
* one or two sections. The resources are packed tightly into the section,
* being aligned on dword boundaries.  Each section is padded to a file
* sector size (no invalid or zero-filled pages), and each
* resource is padded to the afore-mentioned dword boundary.  This
* function uses the capabilities of the NT system to enable it to easily
* manipulate the data:  to wit, it assumes that the system can allocate
* any sized piece of data, in particular the section and resource tables.
* If it did not, it might have to deal with temporary files (the system
* may have to grow the swap file, but that's what the system is for.)
*
* Return values are:
*     TRUE  - file was written succesfully.
*     FALSE - file was not written succesfully.
*
* Effects:
*
* History:
* Thur Apr 27, 1989        by     Floyd Rogers      [floydr]
*   Created.
* 12/8/89   sanfords    Added multiple section support.
* 12/11/90  floydr      Modified for new (NT) Linear Exe format
* 1/18/92   vich        Modified for new (NT) Portable Exe format
* 5/8/92    bryant    General cleanup so resonexe can work with unicode
* 6/9/92    floydr    incorporate bryan's changes
* 6/15/92   floydr    debug section separate from debug table
* 9/25/92   floydr    account for .rsrc not being last-1
* 9/28/92   floydr    account for adding lots of resources by adding
*                     a second .rsrc section.
\****************************************************************************/

//
// The following code instantiates the PEWriteResource function template
// twice. Once to generate code for 32-bit image headers and once to
// generate code for 64-bit image headers.
//

template
LONG
PEWriteResource<IMAGE_NT_HEADERS32> (
    INT inpfh,
    INT outfh,
    ULONG cbOldexe,
    PUPDATEDATA pUpdate,
    IMAGE_NT_HEADERS32 *NtHeader
    );

template
LONG
PEWriteResource<IMAGE_NT_HEADERS64> (
    INT inpfh,
    INT outfh,
    ULONG cbOldexe,
    PUPDATEDATA pUpdate,
    IMAGE_NT_HEADERS64 *NtHeader
    );

LONG
PEWriteResFile(
    INT inpfh,
    INT outfh,
    ULONG cbOldexe,
    PUPDATEDATA pUpdate
    )

{

    IMAGE_NT_HEADERS32 Old;

    //
    // Position file to start of NT header and read the image header.
    //

    MuMoveFilePos(inpfh, cbOldexe);
    MuRead(inpfh, (PUCHAR)&Old, sizeof(IMAGE_NT_HEADERS32));

    //
    // If the file is not an NT image, then return an error.
    //

    if (Old.Signature != IMAGE_NT_SIGNATURE) {
        return ERROR_INVALID_EXE_SIGNATURE;
    }

    //
    // If the file is not an executable or a dll, then return an error.
    //

    if ((Old.FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0 &&
        (Old.FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) {
        return ERROR_EXE_MARKED_INVALID;
    }

    //
    // Call the proper function dependent on the machine type.
    //

    if (Old.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return PEWriteResource(inpfh, outfh, cbOldexe, pUpdate, (IMAGE_NT_HEADERS64 *)&Old);
    } else if (Old.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return PEWriteResource(inpfh, outfh, cbOldexe, pUpdate, (IMAGE_NT_HEADERS32 *)&Old);
    } else {
        return ERROR_BAD_EXE_FORMAT;
    }
}

/***************************************************************************
 * WriteResSection
 *
 * This routine writes out the resources asked for into the current section.
 * It pads resources to dword (4-byte) boundaries.
 **************************************************************************/

PRESNAME
WriteResSection(
               PUPDATEDATA pUpdate,
               INT outfh,
               ULONG align,
               ULONG cbLeft,
               PRESNAME    pResSave
               )
{
    ULONG   cbB=0;            /* bytes in current section    */
    ULONG   cbT;            /* bytes in current section    */
    ULONG   size;
    PRESNAME    pRes;
    PRESTYPE    pType;
    BOOL        fName;
    PVOID       lpData;

    /* Output contents associated with each resource */
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
        pRes = pType->NameHeadName;
        fName = TRUE;
        loop1:
        for ( ; pRes ; pRes = pRes->pnext) {
            if (pResSave != NULL && pRes != pResSave)
                continue;
            pResSave = NULL;
#if DBG
            if (pType->Type->discriminant == IS_STRING) {
                DPrintf((DebugBuf, "    "));
                DPrintfu((pType->Type->szStr));
                DPrintfn((DebugBuf, "."));
            } else {
                DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
            }
            if (pRes->Name->discriminant == IS_STRING) {
                DPrintfu((pRes->Name->szStr));
            } else {
                DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
            }
#endif
            lpData = (PVOID)pRes->OffsetToDataEntry;
            DPrintfn((DebugBuf, "\n"));

            /* if there is room in the current section, write it there */
            size = pRes->DataSize;
            if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
                DPrintf((DebugBuf, "Writing resource: %#04lx bytes @%#08lx\n", size, FilePos(outfh)));
                MuWrite(outfh, lpData, size);
                /* pad resource     */
                cbT = REMAINDER(size, CBLONG);
#if DBG
                if (cbT != 0) {
                    DPrintf((DebugBuf, "Writing small pad: %#04lx bytes @%#08lx\n", cbT, FilePos(outfh)));
                }
#endif
                MuWrite(outfh, pchPad, cbT);    /* dword    */
                cbB += size + cbT;
                cbLeft -= size + cbT;       /* less left    */
                continue;       /* next resource    */
            } else {          /* will fill up section    */
                DPrintf((DebugBuf, "Done with .rsrc section\n"));
                goto write_pad;
            }
        }
        if (fName) {
            fName = FALSE;
            pRes = pType->NameHeadID;
            goto loop1;
        }
        pType = pType->pnext;
    }

    pType = pUpdate->ResTypeHeadID;
    while (pType) {
        pRes = pType->NameHeadName;
        fName = TRUE;
        loop2:
        for ( ; pRes ; pRes = pRes->pnext) {
            if (pResSave != NULL && pRes != pResSave)
                continue;
            pResSave = NULL;
#if DBG
            if (pType->Type->discriminant == IS_STRING) {
                DPrintf((DebugBuf, "    "));
                DPrintfu((pType->Type->szStr));
                DPrintfn((DebugBuf, "."));
            } else {
                DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
            }
            if (pRes->Name->discriminant == IS_STRING) {
                DPrintfu((pRes->Name->szStr));
            } else {
                DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
            }
#endif
            lpData = (PVOID)pRes->OffsetToDataEntry;
            DPrintfn((DebugBuf, "\n"));

            /* if there is room in the current section, write it there */
            size = pRes->DataSize;
            if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
                DPrintf((DebugBuf, "Writing resource: %#04lx bytes @%#08lx\n", size, FilePos(outfh)));
                MuWrite(outfh, lpData, size);
                /* pad resource     */
                cbT = REMAINDER(size, CBLONG);
#if DBG
                if (cbT != 0) {
                    DPrintf((DebugBuf, "Writing small pad: %#04lx bytes @%#08lx\n", cbT, FilePos(outfh)));
                }
#endif
                MuWrite(outfh, pchPad, cbT);    /* dword    */
                cbB += size + cbT;
                cbLeft -= size + cbT;       /* less left    */
                continue;       /* next resource    */
            } else {          /* will fill up section    */
                DPrintf((DebugBuf, "Done with .rsrc section\n"));
                goto write_pad;
            }
        }
        if (fName) {
            fName = FALSE;
            pRes = pType->NameHeadID;
            goto loop2;
        }
        pType = pType->pnext;
    }
    pRes = NULL;

    write_pad:
    /* pad to alignment boundary */
    cbB = FilePos(outfh);
    cbT = ROUNDUP(cbB, align);
    cbLeft = cbT - cbB;
    DPrintf((DebugBuf, "Writing file sector pad: %#04lx bytes @%#08lx\n", cbLeft, FilePos(outfh)));
    if (cbLeft != 0) {
        while (cbLeft >= cbPadMax) {
            MuWrite(outfh, pchPad, cbPadMax);
            cbLeft -= cbPadMax;
        }
        MuWrite(outfh, pchPad, cbLeft);
    }
    return pRes;
}



#if DBG

void
wchprintf(WCHAR*wch)
{
    UNICODE_STRING ustring;
    STRING      string;
    char        buf[257];
    ustring.MaximumLength = ustring.Length = wcslen(wch) * sizeof(WCHAR);
    ustring.Buffer = wch;

    string.Length = 0;
    string.MaximumLength = 256;
    string.Buffer = buf;

    RtlUnicodeStringToAnsiString(&string, &ustring, FALSE);
    buf[string.Length] = '\000';
    DPrintfn((DebugBuf, "%s", buf));
}
#endif


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteResFile() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/


LONG
WriteResFile(
            HANDLE      hUpdate,
            WCHAR       *pDstname)
{
    INT         inpfh;
    INT         outfh;
    ULONG       onewexe;
    IMAGE_DOS_HEADER    oldexe;
    PUPDATEDATA pUpdate;
    INT         rc;
    WCHAR       *pFilename;

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL) {
        return GetLastError();
    }
    pFilename = (WCHAR*)GlobalLock(pUpdate->hFileName);
    if (pFilename == NULL) {
        GlobalUnlock(hUpdate);
        return GetLastError();
    }

    /* open the original exe file */
    inpfh = HandleToUlong(CreateFileW(pFilename, GENERIC_READ,
                             0 /*exclusive access*/, NULL /* security attr */,
                             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    GlobalUnlock(pUpdate->hFileName);
    if (inpfh == -1) {
        GlobalUnlock(hUpdate);
        return ERROR_OPEN_FAILED;
    }

    /* read the old format EXE header */
    rc = _lread(inpfh, (char*)&oldexe, sizeof(oldexe));
    if (rc != sizeof(oldexe)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_READ_FAULT;
    }

    /* make sure its really an EXE file */
    if (oldexe.e_magic != IMAGE_DOS_SIGNATURE) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_INVALID_EXE_SIGNATURE;
    }

    /* make sure theres a new EXE header floating around somewhere */
    if (!(onewexe = oldexe.e_lfanew)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_BAD_EXE_FORMAT;
    }

    outfh = HandleToUlong(CreateFileW(pDstname, GENERIC_READ|GENERIC_WRITE,
                             0 /*exclusive access*/, NULL /* security attr */,
                             CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL));

    if (outfh != -1) {
        rc = PEWriteResFile(inpfh, outfh, onewexe, pUpdate);
        _lclose(outfh);
    }
    _lclose(inpfh);
    GlobalUnlock(hUpdate);
    return rc;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\tth.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    old tth.c

Abstract:

    Test program for Win32 Base File API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <memory.h>
#include <process.h>

#define xassert ASSERT
int izero;
int i,j;
#define BASESPIN 1000000

#define NULL_SERVER_SWITCHES 10000
#define PATH_CONVERSION_TEST 1000

//
// Define local types.
//

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    ULONG ContextSwitches;
    ULONG FirstLevelFills;
    ULONG SecondLevelFills;
    ULONG SystemCalls;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    ULONG ContextSwitches;
    LARGE_INTEGER Duration;
    ULONG FirstLevelFills;
    ULONG Length;
    ULONG Performance;
    ULONG SecondLevelFills;
    NTSTATUS Status;
    ULONG SystemCalls;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;


    //
    // Print results and announce end of test.
    //

    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StopTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    Duration = RtlLargeIntegerSubtract(PerfInfo->StopTime, PerfInfo->StartTime);
    Length = Duration.LowPart / 10000;
    printf("        Test time in milliseconds %d\n", Length);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = PerfInfo->Iterations * 1000 / Length;
    printf("        Iterations per second     %d\n", Performance);

    ContextSwitches = SystemInfo.ContextSwitches - PerfInfo->ContextSwitches;
    FirstLevelFills = SystemInfo.FirstLevelTbFills - PerfInfo->FirstLevelFills;
    SecondLevelFills = SystemInfo.SecondLevelTbFills - PerfInfo->SecondLevelFills;
    SystemCalls = SystemInfo.SystemCalls - PerfInfo->SystemCalls;
    printf("        First Level TB Fills      %d\n", FirstLevelFills);
    printf("        Second Level TB Fills     %d\n", SecondLevelFills);
    printf("        Total Context Switches    %d\n", ContextSwitches);
    printf("        Number of System Calls    %d\n", SystemCalls);

    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    )

{

    NTSTATUS Status;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StartTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    PerfInfo->ContextSwitches = SystemInfo.ContextSwitches;
    PerfInfo->FirstLevelFills = SystemInfo.FirstLevelTbFills;
    PerfInfo->SecondLevelFills = SystemInfo.SecondLevelTbFills;
    PerfInfo->SystemCalls = SystemInfo.SystemCalls;
    return;
}

VOID
ScrollTest()
{
    COORD dest,cp;
    SMALL_RECT Sm;
    CHAR_INFO ci;
    CONSOLE_SCREEN_BUFFER_INFO sbi;
    HANDLE ScreenHandle;
    SMALL_RECT Window;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &sbi);

    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 79;
    Window.Bottom = 49;

    dest.X = 0;
    dest.Y = 0;

    ci.Char.AsciiChar = ' ';
    ci.Attributes = sbi.wAttributes;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window);

    cp.X = 0;
    cp.Y = 0;

    Sm.Left      = 0;
    Sm.Top       = 1;
    Sm.Right     = 79;
    Sm.Bottom    = 49;

    ScrollConsoleScreenBuffer(GetStdHandle(STD_OUTPUT_HANDLE),
                              &Sm,
                              NULL,
                              dest,
                              &ci);

}






VOID
WinWordOpenFileTest()
{
    PERFINFO PerfInfo;
    ULONG Index;
    OFSTRUCT ofstr;
    HANDLE iFile;

    StartBenchMark("WinWord OpenFile)",
                   3,
                   &PerfInfo);

    for ( Index=0;Index<3;Index++){
        iFile = (HANDLE)OpenFile("foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\winword.ini",&ofstr, 0x20);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\perftest.doc",&ofstr, 0x22);
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\custom.dic",&ofstr, 0x4022 );
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\sp_am.exc",&ofstr, 0x4040 );
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:~doc3d08.tmp",&ofstr, 0x1022);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\tempx.doc",&ofstr, 0xa022 );
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\~$rftest.doc",&ofstr, 0x4012 );
        iFile = (HANDLE)OpenFile("foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:~doc391f.tmp",&ofstr, 0x1022);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\tempy.doc",&ofstr, 0xa022 );
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\winword.ini",&ofstr, 0x12);
    }

    FinishBenchMark(&PerfInfo);
}

VOID
gettictst(int x)
{
    PERFINFO PerfInfo;
    ULONG i,j;
    ULONG tnt,tw32;

    if ( !x ) {
        StartBenchMark("NtGetTickCount)",
                       100000,
                       &PerfInfo);
        for ( i=0;i<100000;i++){
            j = GetTickCount();
        }

        FinishBenchMark(&PerfInfo);

        }
    else {
        while(1)GetTickCount();
        }
}

VOID
latst()
{
    PERFINFO PerfInfo;
    ULONG i,j;
    HANDLE h1, h2, h3, h4, h5;

    StartBenchMark("LocalAlloc/Free)",
                   200,
                   &PerfInfo);
    for ( i=0;i<200/5;i++){
        h1 = LocalAlloc(0, 500);
        h2 = LocalAlloc(0, 600);
        h3 = LocalAlloc(0, 700);
        LocalFree(h2);
        h4 = LocalAlloc(0, 1000);
        h5 = LocalAlloc(0, 100);
        LocalFree(h1);
        LocalFree(h3);
        LocalFree(h4);
        LocalFree(h5);
    }

    FinishBenchMark(&PerfInfo);

}

VOID
WinWordGetDriveTypeTest()
{
    PERFINFO PerfInfo;
    ULONG Index,Reps;
    OFSTRUCT ofstr;
    HANDLE iFile;
    CHAR DiskName[4];
    WCHAR WDiskName[4];

//    StartBenchMark("WinWord GetDriveType (1-26)",
//                   26,
//                   &PerfInfo);
//
//    for ( Index=1;Index<27;Index++){
//        GetDriveType(Index);
//    }
//
//    FinishBenchMark(&PerfInfo);

    DiskName[0]='a';
    DiskName[1]=':';
    DiskName[2]='\\';
    DiskName[3]='\0';
    StartBenchMark("WinWord GetDriveTypeA (a-z)",
                   100,
                   &PerfInfo);

    for(Reps=0;Reps<100;Reps++){
        for ( Index=0;Index<26;Index++){
            DiskName[0]='a'+Index;
            GetDriveTypeA(DiskName);
            }
        }

    FinishBenchMark(&PerfInfo);

    WDiskName[0]=(WCHAR)'a';
    WDiskName[1]=(WCHAR)':';
    WDiskName[2]=(WCHAR)'\\';
    WDiskName[3]=(WCHAR)'\0';
    StartBenchMark("WinWord GetDriveTypeW (a-z)",
                   100,
                   &PerfInfo);

    for(Reps=0;Reps<100;Reps++){
        for ( Index=0;Index<26;Index++){
            WDiskName[0]=(WCHAR)'a'+Index;
            GetDriveTypeW(WDiskName);
            }
        }

    FinishBenchMark(&PerfInfo);
}

VOID
BogusOrdinalTest()
{
    HANDLE hBase;
    FARPROC z;

    WaitForSingleObject(0,-2);
    hBase = GetModuleHandle("base");
    xassert(hBase);
    z = GetProcAddress(hBase,0x00001345);
}


VOID
NullServerSwitchTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    ULONG Index;

    StartBenchMark("Null Server Call Benchmark)",
                   NULL_SERVER_SWITCHES,
                   &PerfInfo);


    for (Index = 0; Index < NULL_SERVER_SWITCHES; Index += 1) {
        CsrIdentifyAlertableThread();
    }
    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    return;
}

VOID
PathConvertTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    ULONG Index;
    UNICODE_STRING FileName;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;

    StartBenchMark("Path Conversion Test (foo)",
                   PATH_CONVERSION_TEST,
                   &PerfInfo);


    for (Index = 0; Index < PATH_CONVERSION_TEST; Index += 1) {
        RtlDosPathNameToNtPathName_U(
            L"foo",
            &FileName,
            NULL,
            &RelativeName
            );
        RtlFreeHeap(RtlProcessHeap(),FileName.Buffer);
    }
    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    StartBenchMark("Path Conversion Test (e:\\nt\\windows\\foo)",
                   PATH_CONVERSION_TEST,
                   &PerfInfo);


    for (Index = 0; Index < PATH_CONVERSION_TEST; Index += 1) {
        RtlDosPathNameToNtPathName_U(
            L"e:\\nt\\windows\\foo",
            &FileName,
            NULL,
            &RelativeName
            );
        RtlFreeHeap(RtlProcessHeap(),FileName.Buffer);
    }
    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    return;
}

z(){}

bar()
{
    for (i=0;i<2*BASESPIN;i++)j = i++;
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
}
foo()
{
    for (i=0;i<BASESPIN;i++)j = i++;
    bar();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
}
proftst()
{
    for (i=0;i<BASESPIN;i++)j = i++;
    foo();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
}

VOID
probtst(
    VOID
    )
{
    LPVOID ReadOnly;
    LPVOID ReadWrite;
    LPVOID ReadWrite2;
    LPVOID NoReadWrite;
    LPVOID MappedReadWrite;
    LPVOID p;
    HANDLE MappedFile;
    LPSTR l;
    LPWSTR w;
    BOOL b;

    ReadOnly = VirtualAlloc(NULL,4096,MEM_COMMIT,PAGE_READONLY);
    ASSERT(ReadOnly);

    ASSERT(!IsBadReadPtr(ReadOnly,1024));
    ASSERT(!IsBadReadPtr(ReadOnly,4096));
    ASSERT(IsBadReadPtr(ReadOnly,4097));
    ASSERT(!IsBadHugeReadPtr(ReadOnly,1024));
    ASSERT(!IsBadHugeReadPtr(ReadOnly,4096));
    ASSERT(IsBadHugeReadPtr(ReadOnly,4097));

    ASSERT(IsBadWritePtr(ReadOnly,1024));
    ASSERT(IsBadWritePtr(ReadOnly,4096));
    ASSERT(IsBadWritePtr(ReadOnly,4097));
    ASSERT(IsBadHugeWritePtr(ReadOnly,1024));
    ASSERT(IsBadHugeWritePtr(ReadOnly,4096));
    ASSERT(IsBadHugeWritePtr(ReadOnly,4097));

    ReadWrite = VirtualAlloc(NULL,4096,MEM_COMMIT,PAGE_READWRITE);
    ASSERT(ReadWrite);

    ASSERT(!IsBadReadPtr(ReadWrite,1024));
    ASSERT(!IsBadReadPtr(ReadWrite,4096));
    ASSERT(IsBadReadPtr(ReadWrite,4097));
    ASSERT(!IsBadHugeReadPtr(ReadWrite,1024));
    ASSERT(!IsBadHugeReadPtr(ReadWrite,4096));
    ASSERT(IsBadHugeReadPtr(ReadWrite,4097));

    ASSERT(!IsBadWritePtr(ReadWrite,1024));
    ASSERT(!IsBadWritePtr(ReadWrite,4096));
    ASSERT(IsBadWritePtr(ReadWrite,4097));
    ASSERT(!IsBadHugeWritePtr(ReadWrite,1024));
    ASSERT(!IsBadHugeWritePtr(ReadWrite,4096));
    ASSERT(IsBadHugeWritePtr(ReadWrite,4097));

    NoReadWrite = VirtualAlloc(NULL,4096,MEM_COMMIT,PAGE_NOACCESS);
    ASSERT(NoReadWrite);

    ASSERT(IsBadReadPtr(NoReadWrite,1024));
    ASSERT(IsBadReadPtr(NoReadWrite,4096));
    ASSERT(IsBadReadPtr(NoReadWrite,4097));
    ASSERT(IsBadHugeReadPtr(NoReadWrite,1024));
    ASSERT(IsBadHugeReadPtr(NoReadWrite,4096));
    ASSERT(IsBadHugeReadPtr(NoReadWrite,4097));

    ASSERT(IsBadWritePtr(NoReadWrite,1024));
    ASSERT(IsBadWritePtr(NoReadWrite,4096));
    ASSERT(IsBadWritePtr(NoReadWrite,4097));
    ASSERT(IsBadHugeWritePtr(NoReadWrite,1024));
    ASSERT(IsBadHugeWritePtr(NoReadWrite,4096));
    ASSERT(IsBadHugeWritePtr(NoReadWrite,4097));

    l = ReadWrite;
    l[4092]='a';
    l[4093]='b';
    l[4094]='c';
    l[4095]='\0';
    ASSERT(!IsBadStringPtrA(&l[4092],2));
    ASSERT(!IsBadStringPtrA(&l[4092],3));
    ASSERT(!IsBadStringPtrA(&l[4092],4));
    ASSERT(!IsBadStringPtrA(&l[4092],5));
    l[4095]='d';
    ASSERT(!IsBadStringPtrA(&l[4092],2));
    ASSERT(!IsBadStringPtrA(&l[4092],3));
    ASSERT(!IsBadStringPtrA(&l[4092],4));
    ASSERT(IsBadStringPtrA(&l[4092],5));

    w = ReadWrite;
    w[2044]=(WCHAR)'a';
    w[2045]=(WCHAR)'b';
    w[2046]=(WCHAR)'c';
    w[2047]=UNICODE_NULL;
    ASSERT(!IsBadStringPtrW(&w[2044],2));
    ASSERT(!IsBadStringPtrW(&w[2044],3));
    ASSERT(!IsBadStringPtrW(&w[2044],4));
    ASSERT(!IsBadStringPtrW(&w[2044],5));
    w[2047]=(WCHAR)'d';
    ASSERT(!IsBadStringPtrW(&w[2044],2));
    ASSERT(!IsBadStringPtrW(&w[2044],3));
    ASSERT(!IsBadStringPtrW(&w[2044],4));
    ASSERT(IsBadStringPtrW(&w[2044],5));

    ReadWrite2 = VirtualAlloc(NULL,4096,MEM_COMMIT,PAGE_READWRITE);
    ASSERT(ReadWrite2);

    ASSERT(VirtualLock(ReadWrite2,4096));
    ASSERT(VirtualUnlock(ReadWrite2,4));
    ASSERT(!VirtualUnlock(ReadWrite2,4));
    ASSERT(!VirtualLock(ReadWrite2,4097));
    ASSERT(!VirtualUnlock(ReadWrite2,4097));
    ASSERT(VirtualLock(ReadWrite2,4096));
    ASSERT(VirtualUnlock(ReadWrite2,4096));
    ASSERT(!VirtualUnlock(ReadWrite2,4096));

    MappedFile = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,8192,NULL);
    ASSERT(MappedFile);
    MappedReadWrite = MapViewOfFileEx(MappedFile,FILE_MAP_WRITE,0,0,0,(LPVOID)0x50000000);
    ASSERT(MappedReadWrite);

    p = MapViewOfFileEx(MappedFile,FILE_MAP_WRITE,0,0,0,(LPVOID)GetModuleHandle(NULL));
    ASSERT(!p);

    ASSERT(SetPriorityClass(GetCurrentProcess(),IDLE_PRIORITY_CLASS));
    ASSERT(GetPriorityClass(GetCurrentProcess()) == IDLE_PRIORITY_CLASS);

    ASSERT(SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS));
    ASSERT(GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS);

    ASSERT(SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS));
    ASSERT(GetPriorityClass(GetCurrentProcess()) == HIGH_PRIORITY_CLASS);

    ASSERT(SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS));
    ASSERT(GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS);

}


void
notifytst()
{
    HANDLE nHandle;
    DWORD wret;
    HANDLE fFile;
    WIN32_FIND_DATA FindFileData;
    int n;
    BOOL b;

    fFile =  FindFirstFile(
                "c:\\*.*",
                &FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    n = 0;
    b = TRUE;
    while(b) {
        n++;
        b = FindNextFile(fFile,&FindFileData);
        }
    FindClose(fFile);
    printf("%d files\n",n);

    nHandle = FindFirstChangeNotification(
                "C:\\",
                TRUE,
                FILE_NOTIFY_CHANGE_NAME
                );
    xassert(nHandle != INVALID_HANDLE_VALUE);

    wret = WaitForSingleObject(nHandle,-1);
    xassert(wret == 0);

    fFile =  FindFirstFile(
                "c:\\*.*",
                &FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    n = 0;
    b = TRUE;
    while(b) {
        n++;
        b = FindNextFile(fFile,&FindFileData);
        }
    FindClose(fFile);
    printf("%d files\n",n);

    b = FindNextChangeNotification(nHandle);
    xassert(b);

    wret = WaitForSingleObject(nHandle,-1);
    xassert(wret == 0);

    fFile =  FindFirstFile(
                "c:\\*.*",
                &FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    n = 0;
    b = TRUE;
    while(b) {
        n++;
        b = FindNextFile(fFile,&FindFileData);
        }
    FindClose(fFile);
    printf("%d files\n",n);

    xassert(FindCloseChangeNotification(nHandle));
    xassert(!FindCloseChangeNotification(nHandle));
}

void
openiftst()
{
    HANDLE NEvent, NSemaphore, NMutex;
    HANDLE sEvent, sSemaphore, sMutex;

    NEvent = CreateEvent(NULL,TRUE,TRUE,"named-event");
    xassert(NEvent);
    xassert(GetLastError()==0);
    sEvent = CreateEvent(NULL,TRUE,TRUE,"named-event");
    xassert(sEvent);
    xassert(GetLastError()==ERROR_ALREADY_EXISTS);
    NSemaphore = CreateSemaphore(NULL,1,256,"named-event");

    NSemaphore = CreateSemaphore(NULL,1,256,"named-semaphore");
    xassert(NSemaphore);
    xassert(GetLastError()==0);
    sSemaphore = CreateSemaphore(NULL,1,256,"named-semaphore");
    xassert(sSemaphore);
    xassert(GetLastError()==ERROR_ALREADY_EXISTS);

    NMutex = CreateMutex(NULL,FALSE,"named-mutex");
    xassert(NMutex);
    xassert(GetLastError()==0);
    sMutex = CreateMutex(NULL,FALSE,"named-mutex");
    xassert(sMutex);
    xassert(GetLastError()==ERROR_ALREADY_EXISTS);

}

void
NewRip(int flag, LPSTR str)
{
    DWORD ExceptionArguments[3];
    try {
        ExceptionArguments[0]=strlen(str);
        ExceptionArguments[1]=(DWORD)str;
        ExceptionArguments[2]=(DWORD)flag;
        RaiseException(0x0eab7190,0,3,ExceptionArguments);
        }
    except(EXCEPTION_EXECUTE_HANDLER) {
        ;
        }
}

void
Ofprompt()
{
    HFILE h;
    OFSTRUCT of;

    SetErrorMode(SEM_NOOPENFILEERRORBOX);
    h = OpenFile("e:\\nt\\xt.cfg",&of,OF_PROMPT);
    printf("OpenFile(e:\\nt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());

    h = OpenFile("e:\\zznt\\xt.cfg",&of,OF_PROMPT);
    printf("OpenFile(e:\\zznt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());

    h = OpenFile("e:\\nt\\xt.cfg",&of,OF_PROMPT | OF_CANCEL);
    printf("OpenFile(e:\\nt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());
    SetErrorMode(0);
    h = OpenFile("e:\\nt\\xt.cfg",&of,OF_PROMPT);
    printf("OpenFile(e:\\nt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());

    h = OpenFile("e:\\zznt\\xt.cfg",&of,OF_PROMPT);
    printf("OpenFile(e:\\zznt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());

    h = OpenFile("e:\\nt\\xt.cfg",&of,OF_PROMPT | OF_CANCEL);
    printf("OpenFile(e:\\nt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());
}
void
rtldevn()
{
    UNICODE_STRING ustr;
    ANSI_STRING astr;
    CHAR buf[256];
    DWORD dw;

    printf("name -> ");
    scanf("%s",buf);
    RtlInitAnsiString(&astr,buf);
    RtlAnsiStringToUnicodeString(&ustr,&astr,TRUE);

    dw = RtlIsDosDeviceName_U(ustr.Buffer);

    printf("dw %x Name %s \n",dw,buf);
}

typedef struct _CMDSHOW {
    WORD wMustBe2;
    WORD wShowWindowValue;
} CMDSHOW, *PCMDSHOW;
typedef struct _LOAD_MODULE_PARAMS {
    LPSTR lpEnvAddress;
    LPSTR lpCmdLine;
    PCMDSHOW lpCmdShow;
    DWORD dwReserved;
} LOAD_MODULE_PARAMS, *PLOAD_MODULE_PARAMS;

typedef DWORD (*PFNWAITFORINPUTIDLE)(HANDLE hProcess, DWORD dwMilliseconds);
void
cptst()
{
    CHAR buf[256];
    CHAR cline[256];
    DWORD dw;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    LOAD_MODULE_PARAMS lmp;
    CHAR Environment[256];
    CMDSHOW cs;
    PFNWAITFORINPUTIDLE WaitForInputIdleRoutine;
    HANDLE hMod;

    hMod = LoadLibrary("user32");
    WaitForInputIdleRoutine = GetProcAddress(hMod,"WaitForInputIdle");

    printf("name -> ");
    scanf("%s",buf);

    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    SetLastError(0);
    CreateProcess(
        NULL,
        buf,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation
        );
    (WaitForInputIdleRoutine)(ProcessInformation.hProcess,10000);
    printf("GLE %d\n",GetLastError());
    SetLastError(0);
    printf("WINEXEC %d\n",WinExec(buf,0));

    SetLastError(0);
    lmp.lpEnvAddress = Environment;
    lmp.lpCmdLine = cline;
    lmp.dwReserved = 0;
    lmp.lpCmdShow = &cs;
    cs.wMustBe2 = 2;
    cs.wShowWindowValue = 3;
    cline[0] = strlen(buf);
    RtlMoveMemory(&cline[1],buf,cline[0]);
    cline[cline[0]+1] = 0x0d;
    printf("LOADMOD %d\n",LoadModule(buf,&lmp));
}

void
spawntst()
{
    CHAR buf[256];
    int i;

    printf("name -> ");
    scanf("%s",buf);
    i = _spawnlp(_P_WAIT,buf,"-l",NULL);
}

void
badproctst()
{
    CHAR buf[256];
    DWORD dw;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    LOAD_MODULE_PARAMS lmp;
    CHAR Environment[256];
    CMDSHOW cs;

    printf("name -> ");
    scanf("%s",buf);

    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    SetLastError(0);
    CreateProcess(
        NULL,
        buf,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        "*",
        &StartupInfo,
        &ProcessInformation
        );
    printf("GLE %d\n",GetLastError());
}

void
copytst()
{
    CHAR src[256];
    CHAR dst[256];
    BOOL b;

    printf("src -> ");
    scanf("%s",src);
    printf("dst -> ");
    scanf("%s",dst);

    b = CopyFile(src,dst,FALSE);
}

void
fftst()
{
    CHAR buf[256];
    HANDLE fFile;
    WIN32_FIND_DATA FindFileData;
    BOOL b;

    printf("pattern -> ");
    scanf("%s",buf);

    fFile =  FindFirstFile(
                buf,
                &FindFileData
                );
    if ( fFile == INVALID_HANDLE_VALUE ){
        printf("findfirst %s failed %d\n",buf,GetLastError());
        return;
        }

    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData.dwFileAttributes,
            FindFileData.nFileSizeLow,
            FindFileData.cFileName
            );
        b = FindNextFile(fFile,&FindFileData);
        }
    FindClose(fFile);
}

void
oftst()
{
    OFSTRUCT OfStruct;
    HFILE rv;

    rv = OpenFile("",&OfStruct, OF_EXIST);
    printf("rv %d\n",rv);

    rv = OpenFile(NULL,&OfStruct, OF_EXIST);
    printf("rv %d\n",rv);

    rv = OpenFile(" ",&OfStruct, OF_EXIST);
    printf("rv %d\n",rv);
}

void
spath()
{

    char cbuff[512];

    SearchPath(
        "c:\\nt;c:\\xytty;c:\\nt\\system",
        "kernel32",
        ".dll",
        512,
        cbuff,
        NULL
        );
    printf("%s\n",cbuff);
}

void
muldivtst()
{
    int answer,number,numerator,denom,result;
    PERFINFO PerfInfo;
    ULONG Index;

    StartBenchMark("MulDiv)",
                   50000,
                   &PerfInfo);

    for(Index=0;Index<50000;Index++){
    //
    // answer = -24
    //
    number = -18;
    numerator = 96;
    denom = 72;
    answer = -24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = -24
    //
    number = 18;
    numerator = -96;
    denom = 72;
    answer = -24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = 24
    //
    number = -18;
    numerator = -96;
    denom = 72;
    answer = 24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = -24
    //
    number = -18;
    numerator = -96;
    denom = -72;
    answer = -24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = -24
    //
    number = -18;
    numerator = -96;
    denom = -72;
    answer = -24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = 24
    //
    number = 18;
    numerator = -96;
    denom = -72;
    answer = 24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");


    //
    // answer = 2
    //
    number = 4;
    numerator = 2;
    denom = 5;
    answer = 2;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = 500
    //

    number = 100;
    numerator = 10;
    denom = 2;
    answer = 500;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = 3b9aca00
    //

    number = 1000000;
    numerator = 1000000;
    denom = 1000;
    answer = 0x3b9aca00;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=0x%lx %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    }
    FinishBenchMark(&PerfInfo);

}

void
dname()
{
    UNICODE_STRING LinkName;
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE LinkHandle;
    NTSTATUS Status;
    ULONG i;
    PWCHAR p;
    WCHAR DeviceNameBuffer[MAXIMUM_FILENAME_LENGTH];

    RtlInitUnicodeString(&LinkName,L"\\DosDevices\\A:");
    p = (PWCHAR)LinkName.Buffer;
    p = p+12;
    for(i=0;i<26;i++){
        *p = (WCHAR)'A'+i;

        InitializeObjectAttributes(
            &Obja,
            &LinkName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
        Status = NtOpenSymbolicLinkObject(
                    &LinkHandle,
                    SYMBOLIC_LINK_QUERY,
                    &Obja
                    );
        if (NT_SUCCESS( Status )) {

            //
            // Open succeeded, Now get the link value
            //

            DeviceName.Length = 0;
            DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
            DeviceName.Buffer = DeviceNameBuffer;

            Status = NtQuerySymbolicLinkObject(
                        LinkHandle,
                        &DeviceName,
                        NULL
                        );
            NtClose(LinkHandle);
            if ( NT_SUCCESS(Status) ) {
                printf("%wZ -> %wZ\n",&LinkName,&DeviceName);
                }
            }
        }

}

void
mfextst()
{
    MoveFileExW(L"C:\\tmp\\xx.xx", NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
}

CRITICAL_SECTION cs;

VOID
StartBounce(PVOID pThreadBlockInfo)
{
    EnterCriticalSection(&cs);
    Sleep(-1);
}

void
lockuptst()
{
    HANDLE hThread;
    DWORD id;

    InitializeCriticalSection(&cs);

    hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)StartBounce,
                    0,
                    0,
                    &id
                    );
    EnterCriticalSection(&cs);
    Sleep(-1);
}
void
getdisktst()
{
    BOOL b;
    DWORD spc,bps,fc,tc;

    b = GetDiskFreeSpace(NULL,&spc,&bps,&fc,&tc);
    printf("GetDiskFreeSpace NULL %s\n",b ? "WORKED" : "FAILED" );

    b = GetDiskFreeSpace("C:\\",&spc,&bps,&fc,&tc);
    printf("GetDiskFreeSpace C:\\ %s\n",b ? "WORKED" : "FAILED" );

    b = GetDiskFreeSpace("C:\\WINNT\\",&spc,&bps,&fc,&tc);
    printf("GetDiskFreeSpace C:\\winnt\\ %s\n",b ? "WORKED" : "FAILED" );
}

void
DoChoice(
    int Choice
    )
{
    NTSTATUS Status;
    LONG *p;

top:
    printf("exception test\n");
    printf("1 Access Violation(r)\n");
    printf("2 Access Violation(w)\n");
    printf("3 Array Bounds    \n");
    printf("4 Int Divide By Zero\n");
    printf("5 Software 0x77\n");
    printf("6 bigpath\n");
    printf("7 set default harderror\n");
    printf("8 proftests\n");
    printf("9 probetests\n");
    printf("10 notifytests\n");
    printf("11 openif\n");
    printf("12 null server\n");
    printf("13 path convert\n");
    printf("14 bogus ordinal\n");
    printf("15 winword openfile\n");
    printf("16 scroll test\n");
    printf("17 winword getdrivetype\n");
    printf("18 dorip\n");
    printf("19 Ofprompt\n");
    printf("20 rtldevn\n");
    printf("21 cptst\n");
    printf("22 oftst\n");
    printf("23 dname\n");
    printf("24 fftst\n");
    printf("25 copy\n");
    printf("26 badproc\n");
    printf("27 loadlib\n");
    printf("28 gettictst(0)\n");
    printf("29 latst\n");
    printf("30 gettictst(1)\n");
    printf("31 spath\n");
    printf("32 spawntst\n");
    printf("33 muldivtst\n");
    printf("34 mfextst\n");
    printf("35 lockuptst\n");
    printf("36 getdisktst\n");

    printf("Enter Choice --> ");
    scanf("%d",&Choice);
    printf("Good Choice... %d\n",Choice);

    switch ( Choice ) {
    case 1:
        SetErrorMode(SEM_NOGPFAULTERRORBOX);
        printf("Good Choice... %d\n",Choice);
        p = (int *)0xbaadadd0;
        Choice = *p;
        break;

    case 2:
        printf("Good Choice... %d\n",Choice);
        p = (int *)0xbaadadd0;
        *p = Choice;
        break;

    case 3:
        printf("Good Choice... %d\n",Choice);
        RtlRaiseStatus(STATUS_ARRAY_BOUNDS_EXCEEDED);
        break;

    case 4:
        printf("Good Choice... %d\n",Choice);
        Choice = Choice/izero;
        break;

    case 5:
        printf("Good Choice... %d\n",Choice);
        {
            UINT b;
            b = SetErrorMode(SEM_FAILCRITICALERRORS);
            xassert(b == 0);
            b = SetErrorMode(0);
            xassert(b == SEM_FAILCRITICALERRORS);
        }
        RtlRaiseStatus(0x77);
        break;

    case 6:
        printf("Good Choice... %d\n",Choice);
        {
            DWORD Bsize;
            DWORD Rsize;
            LPSTR Buff;
            LPSTR Ruff;
            DWORD Rvalue;
            LPSTR whocares;
            int i;

            printf("Enter Size --> ");
            scanf("%d",&Bsize);
            printf("Enter RSize --> ");
            scanf("%d",&Rsize);

            Buff = LocalAlloc(0,Bsize+1);
            xassert(Buff);
            Ruff = LocalAlloc(0,Bsize+1);
            xassert(Buff);
            RtlFillMemory(Buff,Bsize,'a');
            Buff[0]='c';
            Buff[1]=':';
            Buff[2]='\\';
            Buff[Bsize+1] = '\0';
            Rvalue = GetFullPathName(Buff,Rsize,Ruff,&whocares);
            i = strcmp(Buff,Ruff);
            printf("Bsize %d Rsize %d Rvalue %d i=%d \n",Bsize,Rsize,Rvalue,i);

        }
        break;

    case 7:
        printf("Good Choice... %d\n",Choice);
        Status = NtSetDefaultHardErrorPort(NULL);
        xassert(Status == STATUS_PRIVILEGE_NOT_HELD);
        break;
    case 8:
        printf("Good Choice... %d\n",Choice);
        proftst();
        break;
    case 9:
        printf("Good Choice... %d\n",Choice);
        probtst();
        break;

    case 10:
        printf("Good Choice... %d\n",Choice);
        notifytst();
        break;

    case 11:
        printf("Good Choice... %d\n",Choice);
        openiftst();
        break;

    case 12:
        printf("Good Choice... %d\n",Choice);
        NullServerSwitchTest();
        break;

    case 13:
        PathConvertTest();
        break;

    case 14:
        BogusOrdinalTest();
        break;

    case 15:
        WinWordOpenFileTest();
        break;

    case 16:
        ScrollTest();
        break;

    case 17:
        WinWordGetDriveTypeTest();
        break;
    case 18:
        NewRip(0,"Just a warning\n");
        NewRip(1,"We Are Hosed\n");
        break;

    case 19:
        Ofprompt();
        break;

    case 20:
        rtldevn();
        break;

    case 21:
        cptst();
        break;

    case 22:
        oftst();
        break;

    case 23:
        dname();
        break;

    case 24:
        fftst();
        break;

    case 25:
        copytst();
        break;

    case 26:
        badproctst();
        break;

    case 27:
        {
        HANDLE hmods,hmodc,hmodw;
        hmods = LoadLibrary("shell32");
        hmodc = LoadLibrary("cmd.exe");
        hmodw = LoadLibrary("winspool.drv");
        FreeLibrary(hmods);
        FreeLibrary(hmodc);
        FreeLibrary(hmodw);
        }
        break;

    case 28:
        gettictst(0);
        break;

    case 29:
        latst();
        break;

    case 30:
        gettictst(1);
        break;

    case 31:
        spath();
        break;

    case 32:
        spawntst();
        break;

    case 33:
        muldivtst();
        break;

    case 34:
        mfextst();
        break;

    case 35:
        lockuptst();
        break;

    case 36:
        getdisktst();
        break;

    default:
        printf( "Bad choice: %d\n", Choice );
        return;
    }

    return;
}

//#define NtCurrentTebAsm() {PTEB Teb;_asm{mov eax,fs:[0x24]};,Teb;}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    int Choice;
    char b[512];


  //  PTEB x;
  //
  //  x = NtCurrentTebAsm();

    GetDriveTypeW(L"A:\\");
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_HIGHEST);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_LOWEST));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_LOWEST);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_ABOVE_NORMAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_ABOVE_NORMAL);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_BELOW_NORMAL);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_NORMAL);

    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_IDLE));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_IDLE);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_TIME_CRITICAL);

    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_NORMAL);

    xassert(!SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST+1));
    xassert(GetThreadPriority(GetCurrentProcess()) == THREAD_PRIORITY_ERROR_RETURN);

    SetErrorMode(0);

    GetSystemDirectory(b,512);
    printf("%s\n",b);
    GetWindowsDirectory(b,512);
    printf("%s\n",b);
    printf("TEBSIZE %d\n",sizeof(TEB));
    Choice = GetModuleFileName(NULL,b,512);
    if ( strlen(b) != Choice ) {
        printf("BAD strlen(b) = %d Choice %d b= %s\n",strlen(b),Choice,b);
        }
    else {
        printf("OK strlen(b) = %d Choice %d b= %s\n",strlen(b),Choice,b);
        }
    if (argc > 1) {
        while (--argc) {
            DoChoice( atoi( *++argv ) );
            }
        }
    else {
        while (TRUE) {
            DoChoice( Choice );
            }
        }
    //GetUserNameW(b,1);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\ustubs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ustubs.c

Abstract:

    Unicode stubs

Author:

    Mark Lucovsky (markl) 18-Apr-1991

Revision History:

--*/

#include "basedll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\vdm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdm.c

Abstract:

    This module implements Win32 APIs for VDMs

Author:

    Sudeepb Bharati (sudeepb) 04-Sep-1991

Revision History:

--*/

#include "basedll.h"
#include "apcompat.h"
#pragma hdrstop

BOOL
APIENTRY
GetBinaryTypeA(
    IN  LPCSTR   lpApplicationName,
    OUT LPDWORD  lpBinaryType
    )

/*++

Routine Description: ANSI version of GetBinaryTypeW.
    This API returns the binary type of lpApplicationName.

Arguments:
    lpApplicationName - Full pathname of the binary
    lpBinaryType - pointer where binary type will be returned.

Return Value:
    TRUE - if SUCCESS; lpBinaryType has following
                SCS_64BIT_BINARY    - Win64 Binary
                SCS_32BIT_BINARY    - Win32 Binary
                SCS_DOS_BINARY      - DOS Binary
                SCS_WOW_BINARY      - Windows 3.X Binary
                SCS_PIF_BINARY      - PIF file
                SCS_POSIX_BINARY    - POSIX Binary
                SCS_OS216_BINARY    - OS/2 Binary
    FALSE - if file not found or of unknown type. More info with GetLastError
--*/
{
    NTSTATUS Status;
    PUNICODE_STRING CommandLine;
    ANSI_STRING AnsiString;
    UNICODE_STRING DynamicCommandLine;
    BOOLEAN bReturn = FALSE;

    CommandLine = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpApplicationName);
    if ( (ULONG)AnsiString.Length<<1 < (ULONG)NtCurrentTeb()->StaticUnicodeString.MaximumLength ) {
        DynamicCommandLine.Buffer = NULL;
        Status = RtlAnsiStringToUnicodeString(CommandLine,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = RtlAnsiStringToUnicodeString(&DynamicCommandLine,&AnsiString,TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }

    bReturn = (BOOLEAN)GetBinaryTypeW(
             DynamicCommandLine.Buffer ? DynamicCommandLine.Buffer : CommandLine->Buffer,
             lpBinaryType);

    RtlFreeUnicodeString(&DynamicCommandLine);

    return((BOOL)bReturn);

}


BOOL
WINAPI
GetBinaryTypeW(
    IN  LPCWSTR  lpApplicationName,
    OUT LPDWORD  lpBinaryType
    )

/*++

Routine Description: Unicode version.
    This API returns the binary type of lpApplicationName.

Arguments:
    lpApplicationName - Full pathname of the binary
    lpBinaryType - pointer where binary type will be returned.

Return Value:
    TRUE - if SUCCESS; lpBinaryType has following
                SCS_64BIT_BINARY    - Win64 Binary
                SCS_32BIT_BINARY    - Win32 Binary
                SCS_DOS_BINARY      - DOS Binary
                SCS_WOW_BINARY      - Windows 3.X Binary
                SCS_PIF_BINARY      - PIF file
                SCS_POSIX_BINARY    - POSIX Binary
                SCS_OS216_BINARY    - OS/2 Binary
    FALSE - if file not found or of unknown type. More info with GetLastError
--*/

{
    NTSTATUS Status;
    UNICODE_STRING PathName;
    RTL_RELATIVE_NAME RelativeName;
    BOOLEAN TranslationStatus;
    OBJECT_ATTRIBUTES Obja;
    PVOID FreeBuffer = NULL;
    HANDLE FileHandle, SectionHandle=NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    LONG fBinaryType = SCS_THIS_PLATFORM_BINARY;
    BOOLEAN bReturn = FALSE;
    SECTION_IMAGE_INFORMATION ImageInformation;


    try {
        //
        // Translate to an NT name.
        //

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                // DynamicCommandLine.Buffer ? DynamicCommandLine.Buffer : CommandLine->Buffer,
                                lpApplicationName,
                                &PathName,
                                NULL,
                                &RelativeName
                                );

        if ( !TranslationStatus ) {
            BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
            goto GBTtryexit;
            }

        FreeBuffer = PathName.Buffer;

        if ( RelativeName.RelativeName.Length ) {
            PathName = *(PUNICODE_STRING)&RelativeName.RelativeName;
            }
        else {
            RelativeName.ContainingDirectory = NULL;
            }

        InitializeObjectAttributes(
            &Obja,
            &PathName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );

        //
        // Open the file for execute access
        //

        Status = NtOpenFile(
                    &FileHandle,
                    SYNCHRONIZE | FILE_EXECUTE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                    );
        if (!NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            goto GBTtryexit;
            }

        //
        // Create a section object backed by the file
        //

        Status = NtCreateSection(
                    &SectionHandle,
                    SECTION_ALL_ACCESS,
                    NULL,
                    NULL,
                    PAGE_EXECUTE,
                    SEC_IMAGE,
                    FileHandle
                    );
        NtClose(FileHandle);

        if (!NT_SUCCESS(Status) ) {

            SectionHandle = NULL;

            switch (Status) {
                case STATUS_INVALID_IMAGE_NE_FORMAT:
#if defined(i386) && defined(OS2_SUPPORT_ENABLED)
                    fBinaryType = SCS_OS216_BINARY;
                    break;
#endif

                case STATUS_INVALID_IMAGE_PROTECT:
                    fBinaryType = SCS_DOS_BINARY;
                    break;

                case STATUS_INVALID_IMAGE_WIN_16:
                    fBinaryType = SCS_WOW_BINARY;
                    break;

                case STATUS_INVALID_IMAGE_NOT_MZ:
                    fBinaryType = BaseIsDosApplication(&PathName, Status);
                    if (!fBinaryType){
                        BaseSetLastNTError(Status);
                        goto GBTtryexit;
                    }
                    fBinaryType = (fBinaryType  == BINARY_TYPE_DOS_PIF) ?
                                  SCS_PIF_BINARY : SCS_DOS_BINARY;
                    break;

                case STATUS_INVALID_IMAGE_WIN_32:
                    fBinaryType = SCS_32BIT_BINARY;
                    break;

                case STATUS_INVALID_IMAGE_WIN_64:
                    fBinaryType = SCS_64BIT_BINARY;
                    break;

                default:
                    BaseSetLastNTError(Status);
                    goto GBTtryexit;
                }
            }
        else {
            //
            // Query the section
            //

            Status = NtQuerySection(
                        SectionHandle,
                        SectionImageInformation,
                        &ImageInformation,
                        sizeof( ImageInformation ),
                        NULL
                        );

            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError(Status);
                goto GBTtryexit;
            }

            if (ImageInformation.ImageCharacteristics & IMAGE_FILE_DLL) {
                SetLastError(ERROR_BAD_EXE_FORMAT);
                goto GBTtryexit;
            }

            if (ImageInformation.Machine !=
                    RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress)->FileHeader.Machine) {

#ifdef MIPS
                if ( ImageInformation.Machine == IMAGE_FILE_MACHINE_R3000 ||
                     ImageInformation.Machine == IMAGE_FILE_MACHINE_R4000 ) {
                    ;
                }
                else {
                    SetLastError(ERROR_BAD_EXE_FORMAT);
                    goto GBTtryexit;
                }
#else
        switch ( ImageInformation.Machine ) {
        case IMAGE_FILE_MACHINE_I386:
          fBinaryType = SCS_32BIT_BINARY;
          break;

#if defined(BUILD_WOW6432)
        //
        // GetBinaryType (64-bit image) from an application running on win64
        // will fall to here since the 64-bit kernel allows creation of 32-bit/64-bit
        // image sections.
        //
        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AMD64:
            fBinaryType = SCS_64BIT_BINARY;
            break;
#endif

        default:
          SetLastError(ERROR_BAD_EXE_FORMAT);
          goto GBTtryexit;
        }
#endif // MIPS
            }
        else if ( ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_WINDOWS_GUI &&
                ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_WINDOWS_CUI ) {


                if ( ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_POSIX_CUI ) {
                    fBinaryType = SCS_POSIX_BINARY;
                }
            }


        }

        *lpBinaryType = fBinaryType;

        bReturn = TRUE;

GBTtryexit:;
        }
    finally {

        if (SectionHandle)
            NtClose(SectionHandle);

        if (FreeBuffer)
            RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
    return bReturn;
}


VOID
APIENTRY
VDMOperationStarted
(
    BOOL    IsWowCaller
    )

/*++

Routine Description:
    This routine is used by MVDM to tell base that it has hooked
    ctrl-c handler with console. If the cmd window is killed
    before VDM could hook ctrl-c, then we wont get a chance to
    cleanup our data structures. The absence of this call tells
    base that it has to clean up the resources next time a
    call is made to create a VDM.

Arguments:
    IsWowCaller - TRUE if the caller is WOWVDM

Return Value:

    None
--*/

{
    BaseUpdateVDMEntry(UPDATE_VDM_HOOKED_CTRLC,
                       NULL,
                       0,
                       IsWowCaller);
    return;
}


BOOL
APIENTRY
GetNextVDMCommand(
    PVDMINFO lpVDMInfo
    )

/*++

Routine Description:
    This routine is used by MVDM to get a new command to execute. The
    VDM is blocked untill a DOS/WOW binary is encountered.


Arguments:
    lpVDMInfo - pointer to VDMINFO where new DOS command and other
                enviornment information is returned.

    if lpVDMInfo is NULL, then the caller is
    asking whether its the first VDM in the system.

Return Value:

    TRUE - The operation was successful. lpVDMInfo is filled in.

    FALSE/NULL - The operation failed.

--*/

{

    NTSTATUS Status;
    BASE_API_MSG m;
    PBASE_GET_NEXT_VDM_COMMAND_MSG a = &m.u.GetNextVDMCommand;
    PBASE_EXIT_VDM_MSG c = &m.u.ExitVDM;
    PBASE_IS_FIRST_VDM_MSG d = &m.u.IsFirstVDM;
    PBASE_SET_REENTER_COUNT_MSG e = &m.u.SetReenterCount;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    ULONG Len,nPointers;
    USHORT VDMStateSave;

    // Special case to query the first VDM In the system.
    if(lpVDMInfo == NULL){
        Status = CsrClientCallServer(
                          (PCSR_API_MSG)&m,
                          NULL,
                          CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                              BasepIsFirstVDM
                                              ),
                          sizeof( *d )
                          );

        if (NT_SUCCESS(Status)) {
            return(d->FirstVDM);
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }

    // Special case to increment/decrement the re-enterancy count

    if (lpVDMInfo->VDMState == INCREMENT_REENTER_COUNT ||
        lpVDMInfo->VDMState == DECREMENT_REENTER_COUNT) {

        e->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;
        e->fIncDec = lpVDMInfo->VDMState;
        Status = CsrClientCallServer(
                        (PCSR_API_MSG)&m,
                        NULL,
                        CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                             BasepSetReenterCount
                                           ),
                        sizeof( *e )
                       );
        if (NT_SUCCESS(Status)) {
            return TRUE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
    }

    VDMStateSave = lpVDMInfo->VDMState;

    // console handle is always passed on in this case
    // wow is differentiated by a parameter a->VDMState
    // a->VDMState & ASKING_FOR_WOW_BINARY indicates wow

    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    if (lpVDMInfo->VDMState & ASKING_FOR_PIF) {
       a->iTask = lpVDMInfo->iTask;
    }
    else {
       a->iTask = 0;
    }

    a->AppLen = lpVDMInfo->AppLen;
    a->PifLen = lpVDMInfo->PifLen;
    a->CmdLen = lpVDMInfo->CmdSize;
    a->EnvLen = lpVDMInfo->EnviornmentSize;
    a->ExitCode = lpVDMInfo->ErrorCode;
    a->VDMState = VDMStateSave;
    a->WaitObjectForVDM = 0;
    a->DesktopLen = lpVDMInfo->DesktopLen;
    a->TitleLen = lpVDMInfo->TitleLen;
    a->ReservedLen = lpVDMInfo->ReservedLen;
    a->CurDirectoryLen = lpVDMInfo->CurDirectoryLen;

    // Find the total space for capture buffer

      // startup info
    Len = ROUND_UP(sizeof(STARTUPINFOA),4);
    nPointers = 1;

    if (lpVDMInfo->CmdSize) {
        Len += ROUND_UP(a->CmdLen,4);
        nPointers++;
        }

    if (lpVDMInfo->AppLen) {
        Len +=ROUND_UP(a->AppLen,4);
        nPointers++;
        }

    if (lpVDMInfo->PifLen) {
        Len +=ROUND_UP(a->PifLen,4);
        nPointers++;
        }

    if (lpVDMInfo->Enviornment) {
        nPointers++;
        Len+= (lpVDMInfo->EnviornmentSize) ?
                     ROUND_UP(lpVDMInfo->EnviornmentSize, 4) : 4;
        }

    if (lpVDMInfo->CurDirectoryLen == 0)
        a->CurDirectory = NULL;
    else{
        Len += ROUND_UP(lpVDMInfo->CurDirectoryLen,4);
        nPointers++;
        }

    if (lpVDMInfo->DesktopLen == 0)
        a->Desktop = NULL;
    else {
        Len += ROUND_UP(lpVDMInfo->DesktopLen,4);
        nPointers++;
        }

    if (lpVDMInfo->TitleLen == 0)
        a->Title = NULL;
    else {
        Len += ROUND_UP(lpVDMInfo->TitleLen,4);
        nPointers++;
        }

    if (lpVDMInfo->ReservedLen == 0)
        a->Reserved = NULL;
    else {
        Len += ROUND_UP(lpVDMInfo->ReservedLen,4);
        nPointers++;
        }

    CaptureBuffer = CsrAllocateCaptureBuffer(nPointers, Len);
    if (CaptureBuffer == NULL) {
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return FALSE;
        }

    if (lpVDMInfo->CmdLine) {
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->CmdSize,
                                   (PVOID *)&a->CmdLine
                                 );
        }
    else {
        a->CmdLine = NULL;
        }


    if (lpVDMInfo->AppLen) {
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->AppLen,
                                   (PVOID *)&a->AppName
                                 );
        }
    else {
        a->AppName = NULL;
        }

    if (lpVDMInfo->PifLen) {
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->PifLen,
                                   (PVOID *)&a->PifFile
                                 );
        }
    else {
        a->PifFile = NULL;
        }


    if (lpVDMInfo->EnviornmentSize) {
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->EnviornmentSize,
                                   (PVOID *)&a->Env
                                 );
        }
    else {
        a->Env = NULL;
        }

    if (lpVDMInfo->CurDirectoryLen)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->CurDirectoryLen,
                                   (PVOID *)&a->CurDirectory
                                 );
    else
        a->CurDirectory = NULL;


    CsrAllocateMessagePointer( CaptureBuffer,
                               sizeof(STARTUPINFOA),
                               (PVOID *)&a->StartupInfo
                             );

    if (lpVDMInfo->DesktopLen)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->DesktopLen,
                                   (PVOID *)&a->Desktop
                                 );
    else
        a->Desktop = NULL;

    if (lpVDMInfo->TitleLen)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->TitleLen,
                                   (PVOID *)&a->Title
                                 );
    else
        a->Title = NULL;

    if (lpVDMInfo->ReservedLen)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->ReservedLen,
                                   (PVOID *)&a->Reserved
                                 );
    else
        a->Reserved = NULL;

retry:
    Status = CsrClientCallServer(
                        (PCSR_API_MSG)&m,
                        CaptureBuffer,
                        CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                            BasepGetNextVDMCommand
                                           ),
                        sizeof( *a )
                        );

    if (a->WaitObjectForVDM) {
        Status = NtWaitForSingleObject(a->WaitObjectForVDM,FALSE,NULL);
        if (Status != STATUS_SUCCESS){
            BaseSetLastNTError(Status);
            return FALSE;
            }
        else {
            a->VDMState |= ASKING_FOR_SECOND_TIME;
            a->ExitCode = 0;
            goto retry;
            }
        }

    if (NT_SUCCESS(Status)) {
        Status = (NTSTATUS)m.ReturnValue;
        }


    if (!NT_SUCCESS( Status )) {
        if (Status == STATUS_INVALID_PARAMETER) {
            //This means one of the buffer size is less than required.
            lpVDMInfo->CmdSize = a->CmdLen;
            lpVDMInfo->AppLen = a->AppLen;
            lpVDMInfo->PifLen = a->PifLen;
            lpVDMInfo->EnviornmentSize = a->EnvLen;
            lpVDMInfo->CurDirectoryLen = a->CurDirectoryLen;
            lpVDMInfo->DesktopLen      = a->DesktopLen;
            lpVDMInfo->TitleLen        = a->TitleLen;
            lpVDMInfo->ReservedLen     = a->ReservedLen;
            }
        else {
            lpVDMInfo->CmdSize = 0;
            lpVDMInfo->AppLen = 0;
            lpVDMInfo->PifLen = 0;
            lpVDMInfo->EnviornmentSize = 0;
            lpVDMInfo->CurDirectoryLen = 0;
            lpVDMInfo->DesktopLen      = 0;
            lpVDMInfo->TitleLen        = 0;
            lpVDMInfo->ReservedLen     = 0;
            }
        CsrFreeCaptureBuffer( CaptureBuffer );
        BaseSetLastNTError(Status);
        return FALSE;
    }


    try {

        if (lpVDMInfo->CmdSize)
            RtlMoveMemory(lpVDMInfo->CmdLine,
                          a->CmdLine,
                          a->CmdLen);


        if (lpVDMInfo->AppLen)
            RtlMoveMemory(lpVDMInfo->AppName,
                          a->AppName,
                          a->AppLen);

        if (lpVDMInfo->PifLen)
            RtlMoveMemory(lpVDMInfo->PifFile,
                          a->PifFile,
                          a->PifLen);


        if (lpVDMInfo->Enviornment)
            RtlMoveMemory(lpVDMInfo->Enviornment,
                          a->Env,
                          a->EnvLen);


        if (lpVDMInfo->CurDirectoryLen)
            RtlMoveMemory(lpVDMInfo->CurDirectory,
                          a->CurDirectory,
                          a->CurDirectoryLen);

        if (a->VDMState & STARTUP_INFO_RETURNED)
            RtlMoveMemory(&lpVDMInfo->StartupInfo,
                          a->StartupInfo,
                          sizeof(STARTUPINFOA));

        if (lpVDMInfo->DesktopLen){
            RtlMoveMemory(lpVDMInfo->Desktop,
                          a->Desktop,
                          a->DesktopLen);
            lpVDMInfo->StartupInfo.lpDesktop = lpVDMInfo->Desktop;
        }


        if (lpVDMInfo->TitleLen){
            RtlMoveMemory(lpVDMInfo->Title,
                          a->Title,
                          a->TitleLen);
            lpVDMInfo->StartupInfo.lpTitle = lpVDMInfo->Title;
        }

        if (lpVDMInfo->ReservedLen){
            RtlMoveMemory(lpVDMInfo->Reserved,
                          a->Reserved,
                          a->ReservedLen);
            lpVDMInfo->StartupInfo.lpReserved = lpVDMInfo->Reserved;
        }

        lpVDMInfo->CmdSize = a->CmdLen;
        lpVDMInfo->AppLen = a->AppLen;
        lpVDMInfo->PifLen = a->PifLen;
        lpVDMInfo->EnviornmentSize = a->EnvLen;
        if (a->VDMState & STARTUP_INFO_RETURNED)
            lpVDMInfo->VDMState = STARTUP_INFO_RETURNED;
        else
            lpVDMInfo->VDMState = 0;
        lpVDMInfo->CurDrive = a->CurrentDrive;
        lpVDMInfo->StdIn  = a->StdIn;
        lpVDMInfo->StdOut = a->StdOut;
        lpVDMInfo->StdErr = a->StdErr;
        lpVDMInfo->iTask = a->iTask;
        lpVDMInfo->CodePage = a->CodePage;
        lpVDMInfo->CurDirectoryLen = a->CurDirectoryLen;
        lpVDMInfo->DesktopLen = a->DesktopLen;
        lpVDMInfo->TitleLen = a->TitleLen;
        lpVDMInfo->ReservedLen = a->ReservedLen;
        lpVDMInfo->dwCreationFlags = a->dwCreationFlags;
        lpVDMInfo->fComingFromBat = a->fComingFromBat;

        CsrFreeCaptureBuffer( CaptureBuffer );
        return TRUE;
        }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        BaseSetLastNTError(GetExceptionCode());
        CsrFreeCaptureBuffer( CaptureBuffer );
        return FALSE;
        }
}

VOID
APIENTRY
ExitVDM(
    BOOL IsWowCaller,
    ULONG iWowTask
    )

/*++

Routine Description:
    This routine is used by MVDM to exit.


Arguments:
    IsWowCaller - TRUE if the caller is WOWVDM.
                  FALSE if the caller is DOSVDM
                  This parameter is obsolete as basesrv knows about the kind
                  of vdm that is calling us


    iWowTask - if IsWowCaller == FALSE then Dont Care
             - if IsWowCaller == TRUE && iWowTask != -1 kill iWowTask task
             - if IsWowCaller == TRUE && iWowTask == -1 kill all wow task

Return Value:
    None

--*/

{

    NTSTATUS Status;
    BASE_API_MSG m;
    PBASE_EXIT_VDM_MSG c = &m.u.ExitVDM;

    c->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    if (IsWowCaller) {
       c->iWowTask = iWowTask;
    }
    else {
       c->iWowTask = 0;
    }

    // this parameter means
    c->WaitObjectForVDM =0;

    Status = CsrClientCallServer(
                      (PCSR_API_MSG)&m,
                      NULL,
                      CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                           BasepExitVDM
                                         ),
                      sizeof( *c )
                      );
    if (NT_SUCCESS(Status) && c->WaitObjectForVDM) {
        NtClose (c->WaitObjectForVDM);
        }

    return;
}

/*++

Routine Description:
    Set new VDM current directories

Arguments:
    cchCurDir - length of buffer in bytes
    lpszCurDir - buffer to return the current director of NTVDM

Return Value:
    TRUE if function succeed
    FALSE if function failed, GetLastError() has the error code
--*/


BOOL
APIENTRY
SetVDMCurrentDirectories(
    IN ULONG  cchCurDirs,
    IN LPSTR  lpszzCurDirs
    )
{
    NTSTATUS Status;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    BASE_API_MSG m;
    PBASE_GET_SET_VDM_CUR_DIRS_MSG a = &m.u.GetSetVDMCurDirs;

    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;
    // caller must have a valid console(WOW will fail)
    if (a->ConsoleHandle == (HANDLE) -1) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }
    if (cchCurDirs && lpszzCurDirs) {
        // get capture buffer, one pointer in the message

        CaptureBuffer = CsrAllocateCaptureBuffer(1, cchCurDirs);
        if (CaptureBuffer == NULL) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
            return FALSE;
            }

        CsrAllocateMessagePointer( CaptureBuffer,
                                   cchCurDirs,
                                   (PVOID *)&a->lpszzCurDirs
                                   );

        a->cchCurDirs = cchCurDirs;
        try {
            RtlMoveMemory(a->lpszzCurDirs, lpszzCurDirs, cchCurDirs);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            BaseSetLastNTError(GetExceptionCode());
            CsrFreeCaptureBuffer(CaptureBuffer);
            return FALSE;
        }
        Status = CsrClientCallServer(
                            (PCSR_API_MSG)&m,
                            CaptureBuffer,
                            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                BasepSetVDMCurDirs
                                                ),
                            sizeof( *a )
                            );
        CsrFreeCaptureBuffer(CaptureBuffer);

        if (!NT_SUCCESS(Status) || !NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }
    return TRUE;
}




/*++

Routine Description:
    To return current directory of NTVDM.
    This allows the parent process(CMD.EXE in most cases) to keep track the
    current directory after each VDM execution.
    NOTE: this function doesn't apply to wow

Arguments:
    cchCurDir - length of buffer in bytes
    lpszCurDir - buffer to return the current director of NTVDM

    Note: We don't require the process id to the running VDM because
          current directories are global to every VDMs under a single NTVDM
          control -- each console handle has its own current directories
Return Value:
    ULONG - (1). number of bytes written to the given buffer if succeed
            (2). lentgh of the current directory including NULL
                 if the provided buffer is not large enough
            (3). 0  then GetLastError() has the error code
--*/


ULONG
APIENTRY
GetVDMCurrentDirectories(
    IN ULONG  cchCurDirs,
    IN LPSTR  lpszzCurDirs
    )
{
    NTSTATUS Status;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    BASE_API_MSG m;
    PBASE_GET_SET_VDM_CUR_DIRS_MSG a = &m.u.GetSetVDMCurDirs;


    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;
    if (a->ConsoleHandle == (HANDLE) -1) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return 0L;
    }
    if (cchCurDirs && lpszzCurDirs) {
        CaptureBuffer = CsrAllocateCaptureBuffer(1, cchCurDirs);
        if (CaptureBuffer == NULL) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
            return FALSE;
            }

        CsrAllocateMessagePointer( CaptureBuffer,
                                   cchCurDirs,
                                   (PVOID *)&a->lpszzCurDirs
                                   );

        a->cchCurDirs = cchCurDirs;
    }
    else {
        a->cchCurDirs = 0;
        a->lpszzCurDirs = NULL;
        CaptureBuffer = NULL;
    }

    m.ReturnValue = 0xffffffff;

    Status = CsrClientCallServer(
                         (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                             BasepGetVDMCurDirs
                                             ),
                         sizeof( *a )
                         );

    if (m.ReturnValue == 0xffffffff) {
        a->cchCurDirs = 0;
        }

    if (NT_SUCCESS(Status)) {
        Status = m.ReturnValue;
        }

    if (NT_SUCCESS(Status)) {

        try {
            RtlMoveMemory(lpszzCurDirs, a->lpszzCurDirs, a->cchCurDirs);
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            a->cchCurDirs = 0;
            }
        }
    else {
        BaseSetLastNTError(Status);
        }

    if (CaptureBuffer) {
        CsrFreeCaptureBuffer(CaptureBuffer);
        }

    return a->cchCurDirs;
}


VOID
APIENTRY
CmdBatNotification(
    IN  ULONG   fBeginEnd
    )

/*++

Routine Description:
    This API lets base know about .bat processing from cmd. This is
    required by VDM, so that it can decided correctly when to  put
    command.com prompt on TSRs. If the command came from .bat file
    then VDM should'nt put its prompt. This is important for
    ventura publisher and civilization apps.

Arguments:
    fBeginEnd - CMD_BAT_OPERATION_STARTING  -> .BAT processing is starting
                CMD_BAT_OPERATION_TERMINATING -> .BAT processing is ending

Return Value:
    None
--*/

{
#if defined(BUILD_WOW6432)
    
    // 32-bit cmd.exe calls this in WOW64, but there is no VDM support, so
    // no need for a WOW64 thunk for it.
    UNREFERENCED_PARAMETER(fBeginEnd);

#else
    BASE_API_MSG m;
    PBASE_BAT_NOTIFICATION_MSG a = &m.u.BatNotification;

    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    if (a->ConsoleHandle == (HANDLE) -1)
        return;

    a->fBeginEnd = fBeginEnd;

    CsrClientCallServer((PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                             BasepBatNotification
                                             ),
                         sizeof( *a )
                         );
#endif
    return;
}


NTSTATUS
APIENTRY
RegisterWowExec(
    IN  HANDLE   hwndWowExec
    )

/*++

Routine Description:
    This API gives basesrv the window handle for the shared WowExec so
    it can send WM_WOWEXECSTARTAPP messages to WowExec.  This
    saves having a thread in WOW dedicated to GetNextVDMCommand.

Arguments:
    hwndWowExec - Win32 window handle for WowExec in shared WOW VDM.
                  Separate WOW VDMs don't register their WowExec handle
                  because they never get commands from base.
                  NULL is passed to de-register any given wowexec

Return Value:
   If hwndWowExec != NULL then returns success if wow had been registered successfully
   if hwndWowExec == NULL then returns success if no tasks are pending to be executed
--*/

{
    BASE_API_MSG m;
    PBASE_REGISTER_WOWEXEC_MSG a = &m.u.RegisterWowExec;
    NTSTATUS Status;

    a->hwndWowExec   = hwndWowExec;
    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    Status = CsrClientCallServer((PCSR_API_MSG)&m,
                                  NULL,
                                  CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                      BasepRegisterWowExec
                                                      ),
                                  sizeof( *a )
                                 );
    return Status;
}


/*++

Routine Description:
    This routine is used to close standard IO handles before returning to the
    caller


Arguments:
    pVDMInfo - VDM Info record containing stdio handles

Return Value:
    None

--*/
VOID
BaseCloseStandardHandle(
    IN PVDMINFO pVDMInfo
    )
{
    if (pVDMInfo->StdIn)
        NtClose (pVDMInfo->StdIn);

    if (pVDMInfo->StdOut)
        NtClose (pVDMInfo->StdOut);

    if (pVDMInfo->StdErr)
        NtClose (pVDMInfo->StdErr);

    pVDMInfo->StdIn  = 0;
    pVDMInfo->StdOut = 0;
    pVDMInfo->StdErr = 0;
}

#ifdef OLD_CFG_BASED

BOOL
BaseGetVDMKeyword(
    PCHAR KeywordLine,
    PCONFIG_KEYWORD *pKeywordLine,
    PCHAR KeywordSize,
    PULONG VdmSize
    )
{
    NTSTATUS Status;
    PCONFIG_FILE ConfigFile;
    PCONFIG_SECTION Section;
    STRING SectionName, KeywordName;
    PCONFIG_KEYWORD pKeywordSize;

    //
    // Retrieve the VDM configuration information from the config file
    //

    Status = RtlOpenConfigFile( NULL, &ConfigFile );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    //
    // Find WOW section of config file
    //

    RtlInitString( &SectionName, "WOW" );
    Section = RtlLocateSectionConfigFile( ConfigFile, &SectionName );
    if (Section == NULL) {
        RtlCloseConfigFile( ConfigFile );
        return FALSE;
    }

    //
    // Get command line
    //

    RtlInitString( &KeywordName, KeywordLine );
    *pKeywordLine = RtlLocateKeywordConfigFile( Section, &KeywordName );
    if (*pKeywordLine == NULL) {
        RtlCloseConfigFile( ConfigFile );
        return FALSE;
    }
    //
    // Get Vdm size
    //

    RtlInitString( &KeywordName, KeywordSize );
    pKeywordSize = RtlLocateKeywordConfigFile( Section, &KeywordName );
    if (pKeywordSize == NULL) {
        *VdmSize = 1024L * 1024L * 16L;
    } else {
        Status = RtlCharToInteger( pKeywordSize->Value.Buffer, 0, VdmSize );
        if (!NT_SUCCESS( Status )) {
            *VdmSize = 1024L * 1024L * 16L;
        } else {
            *VdmSize *= 1024L * 1024L;   // convert to MB
        }
    }
    return TRUE;
}

#endif

BOOL
BaseGetVDMKeyword(
    LPWSTR  KeywordLine,
    LPSTR   KeywordLineValue,
    LPDWORD KeywordLineSize,
    LPWSTR  KeywordSize,
    LPDWORD VdmSize
    )
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString,UnicodeTemp;
    UNICODE_STRING KeyName;
    ANSI_STRING AnsiString;
    LPWSTR UnicodeBuffer,Temp;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey = NULL;
    PKEY_VALUE_FULL_INFORMATION pKeyValueInformation;

    //
    // Allocate Work buffer
    //

    UnicodeBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ), FULL_INFO_BUFFER_SIZE);
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    // Open the WOW key

    RtlInitUnicodeString (&KeyName, WOW_ROOT);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

    if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
        BaseSetLastNTError(NtStatus);
        return FALSE;
    }

    if (!GetVDMConfigValue(hKey,KeywordLine,UnicodeBuffer)) {
        NtClose (hKey);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        return(FALSE);
    }

    //
    // Now convert back to ANSI for the caller after doing all the substitution
    //
    pKeyValueInformation = (PVOID)UnicodeBuffer;
    Temp = (LPWSTR)((PBYTE) pKeyValueInformation + pKeyValueInformation->DataOffset);
    RtlInitUnicodeString( &UnicodeString, Temp );
    UnicodeTemp.Buffer =  (LPWSTR)KeywordLineValue;
    UnicodeTemp.Length =  0;
    UnicodeTemp.MaximumLength = MAX_VDM_CFG_LINE;
    NtStatus = RtlExpandEnvironmentStrings_U    (NULL,&UnicodeString, &UnicodeTemp, NULL);
    if (!NT_SUCCESS( NtStatus )){
        NtClose (hKey);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        return FALSE;
    }
    wcscpy(UnicodeString.Buffer,UnicodeTemp.Buffer);
    UnicodeString.Length = UnicodeTemp.Length;

    //
    // Set up an ANSI_STRING that points to the user's buffer
    //

    AnsiString.MaximumLength = (USHORT) *KeywordLineSize;
    AnsiString.Length = 0;
    AnsiString.Buffer = KeywordLineValue;


    RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

    *KeywordLineSize = AnsiString.Length;

    // Always set the VDMSize to 16Mb. (This is for reservation only)
    // Actual commit is done by SAS_INIT.
    //
    // jarbats
    // for meow subsystem we need more than 16mb reserved for
    // loading win32 pe exes
    // VDMSize is set to 32Mb.

    *VdmSize = 32L;             //default value is 32
    *VdmSize *= 1024L * 1024L;  // convert From MB

    NtClose (hKey);
    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
    return(TRUE);

}

BOOL
GetVDMConfigValue(
    HANDLE hKey,
    LPWSTR Keyword,
    LPWSTR UnicodeBuffer
    )
{
    NTSTATUS NtStatus;
    UNICODE_STRING ValueName;
    PKEY_VALUE_FULL_INFORMATION pKeyValueInformation = (PVOID) UnicodeBuffer;
    ULONG ValueLength;

    RtlInitUnicodeString(&ValueName, Keyword);
    NtStatus = NtQueryValueKey(hKey,
                               &ValueName,
                               KeyValueFullInformation,
                               pKeyValueInformation,
                               FULL_INFO_BUFFER_SIZE,
                               &ValueLength);

    if (NT_SUCCESS(NtStatus))
            return TRUE;
    else {
         BaseSetLastNTError (NtStatus);
         return FALSE;
    }
}



NTSTATUS
BaseCheckVDMp(
    IN  ULONG BinaryType,
    IN  PCWCH lpApplicationName,
    IN  PCWCH lpCommandLine,
    IN  PCWCH lpCurrentDirectory,
    IN  ANSI_STRING *pAnsiStringEnv,
    IN  PBASE_API_MSG m,
    IN OUT PULONG iTask,
    IN  DWORD dwCreationFlags,
    LPSTARTUPINFOW lpStartupInfo
    )
/*++

Routine Description:

    This routine calls the windows server to find out if the VDM for the
    current session is already present. If so, a new process is'nt created
    instead the DOS binary is dispatched to the existing VDM. Otherwise,
    a new VDM process is created. This routine also passes the app name
    and command line to the server in DOS int21/0ah style which is later
    passed by the server to the VDM.

Arguments:

    BinaryType - DOS/WOW binary
    lpApplicationName -- pointer to the full path name of the executable.
    lpCommandLine -- command line
    lpCurrentDirectory - Current directory
    lpEnvironment,     - Envirinment strings
    m - pointer to the base api message.
    iTask - taskid for win16 apps, and no-console dos apps
    dwCreationFlags - creation flags as passed to createprocess
    lpStartupInfo =- pointer to startupinfo as passed to createprocess


Return Value:

    OEM vs. ANSI:
    The command line, Application Name, title are converted to OEM strings,
    suitable for the VDM. All other strings are returned as ANSI.

    returns nt status code of the last operation
    STATUS_ACCESS_DENIED -- Operation failed (desktop access denied)
    STATUS_SUCCESS       -- Operation sucseeded

--*/
{

    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PPEB Peb;
    PBASE_CHECKVDM_MSG b= (PBASE_CHECKVDM_MSG)&m->u.CheckVDM;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    ANSI_STRING AnsiStringCurrentDir,AnsiStringDesktop;
    ANSI_STRING AnsiStringReserved, AnsiStringPif;
    OEM_STRING OemStringCmd, OemStringAppName, OemStringTitle;
    UNICODE_STRING UnicodeString;
    PCHAR pch, Buffer = NULL;
    ULONG Len;
    ULONG bufPointers;
    LPWSTR wsBuffer;
    LPWSTR wsAppName;
    LPWSTR wsPifName;
    LPWSTR wsCmdLine;
    LPWSTR wsPif=(PWSTR)".\0p\0i\0f\0\0";    // L".pif"
    LPWSTR wsSharedWowPif=L"wowexec.pif";
    PWCHAR pwch;
    BOOLEAN bNewConsole;
    DWORD   dw, dwTotal, Length;
    WCHAR   wchBuffer[MAX_PATH + 1];
    ULONG BinarySubType;
    LPWSTR lpAllocatedReserved = NULL;
    DWORD   HandleFlags;

    // does a trivial test of the environment
    if (!ARGUMENT_PRESENT(pAnsiStringEnv) ||
        pAnsiStringEnv->Length > MAXIMUM_VDM_ENVIORNMENT) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
        }

    wsCmdLine = wsAppName = NULL;
    OemStringCmd.Buffer = NULL;
    OemStringAppName.Buffer = NULL;
    AnsiStringCurrentDir.Buffer = NULL;
    AnsiStringDesktop.Buffer = NULL;
    AnsiStringPif.Buffer = NULL;
    OemStringTitle.Buffer = NULL;
    AnsiStringReserved.Buffer = NULL;
    wsBuffer = NULL;
    wsPifName = NULL;

    BinarySubType = BinaryType & BINARY_SUBTYPE_MASK;
    BinaryType = BinaryType & ~BINARY_SUBTYPE_MASK;
    bNewConsole = !NtCurrentPeb()->ProcessParameters->ConsoleHandle ||
                  (dwCreationFlags & CREATE_NEW_CONSOLE);

    try {

        if (BinaryType == BINARY_TYPE_DOS) {

            Peb = NtCurrentPeb();
            if (lpStartupInfo && lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) {
                b->StdIn = lpStartupInfo->hStdInput;
                b->StdOut = lpStartupInfo->hStdOutput;
                b->StdErr = lpStartupInfo->hStdError;

                }
            else {
                b->StdIn = Peb->ProcessParameters->StandardInput;
                b->StdOut = Peb->ProcessParameters->StandardOutput;
                b->StdErr = Peb->ProcessParameters->StandardError;

                //
                // Verify that the standard handles ntvdm process will inherit
                // from the calling process are real handles. They are not
                // handles if the calling process was created with
                // STARTF_USEHOTKEY | STARTF_HASSHELLDATA.
                // Note that CreateProcess clears STARTF_USESTANDHANDLES
                // if either STARTF_USEHOTKEY or STARTF_HASSHELLDATA is set.
                //
                if (Peb->ProcessParameters->WindowFlags &
                    (STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {

                    if (b->StdIn && !CONSOLE_HANDLE(b->StdIn) &&
                        !GetHandleInformation(b->StdIn, &HandleFlags))
                        b->StdIn = 0;
                    if (b->StdOut && !CONSOLE_HANDLE(b->StdOut) &&
                        !GetHandleInformation(b->StdOut, &HandleFlags)) {
                        if (b->StdErr == b->StdOut)
                            b->StdErr = 0;
                        b->StdOut = 0;
                        }
                    if (b->StdErr && b->StdErr != b->StdOut &&
                        !CONSOLE_HANDLE(b->StdErr) &&
                        !GetHandleInformation(b->StdErr, &HandleFlags))
                        b->StdErr = 0;
                    }
                }
            if (CONSOLE_HANDLE((b->StdIn)))
                b->StdIn = 0;

            if (CONSOLE_HANDLE((b->StdOut)))
                b->StdOut = 0;

            if (CONSOLE_HANDLE((b->StdErr)))
                b->StdErr = 0;
            }


        if (BinaryType == BINARY_TYPE_SEPWOW) {
            bNewConsole = TRUE;
            }

        //
        // Convert Unicode Application Name to Oem short name
        //
             // skiping leading white space
        while(*lpApplicationName == (WCHAR)' ' || *lpApplicationName == (WCHAR)'\t' ) {
              lpApplicationName++;
              }

             // space for short AppName
        Len = wcslen(lpApplicationName);
        dwTotal = Len + 1 + MAX_PATH;
        wsAppName =  RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG(VDM_TAG),
                                    dwTotal * sizeof(WCHAR)
                                    );
        if (wsAppName == NULL) {
            Status = STATUS_NO_MEMORY;
            goto BCVTryExit;
            }

        dw = GetShortPathNameW(lpApplicationName, wsAppName, dwTotal);
        // If getting the short name is impossible, stop right here.
        // We can not execute a 16bits biranry if we can not find
        // its appropriate short name alias. Sorry HPFS, Sorry NFS

        if (0 == dw || dw > dwTotal) {
            Status = STATUS_OBJECT_PATH_INVALID;
            goto BCVTryExit;
            }

        RtlInitUnicodeString(&UnicodeString, wsAppName);
        Status = RtlUnicodeStringToOemString(&OemStringAppName,
                                             &UnicodeString,
                                             TRUE
                                             );
        if (!NT_SUCCESS(Status) ){            
            goto BCVTryExit;
            }


        //
        // Find len of basename excluding extension,
        // for CommandTail max len check.
        //
        dw = OemStringAppName.Length;
        pch = OemStringAppName.Buffer;
        Length = 1;        // start at one for space between cmdname & cmdtail
        while (dw-- && *pch != '.') {
            if (*pch == '\\') {
                Length = 1;
                }
            else {
                Length++;
                }
            pch++;
            }


        //
        // Find the beg of the command tail to pass as the CmdLine
        //

        Len = wcslen(lpApplicationName);

        if (L'"' == lpCommandLine[0]) {

            //
            // Application name is quoted, skip the quoted text
            // to get command tail.
            //

            pwch = (LPWSTR)&lpCommandLine[1];
            while (*pwch && L'"' != *pwch++) {
                ;
            }

        } else if (Len <= wcslen(lpCommandLine) &&
            0 == _wcsnicmp(lpApplicationName, lpCommandLine, Len)) {

            //
            // Application path is also on the command line, skip past
            // that to reach the command tail instead of looking for
            // the first white space.
            //

            pwch = (LPWSTR)lpCommandLine + Len;

        } else {

            //
            // We assume first token is exename (argv[0]).
            //

            pwch = (LPWSTR)lpCommandLine;

               // skip leading white characters
            while (*pwch != UNICODE_NULL &&
                   (*pwch == (WCHAR) ' ' || *pwch == (WCHAR) '\t')) {
                pwch++;
                }

               // skip first token
            if (*pwch == (WCHAR) '\"') {    // quotes as delimiter
                pwch++;
                while (*pwch && *pwch++ != '\"') {
                      ;
                      }
                }
            else {                         // white space as delimiter
                while (*pwch && *pwch != ' ' && *pwch != '\t') {
                       pwch++;
                       }
                }
        }

        //
        // pwch points past the application name, now skip any trailing
        // whitespace.
        //

        while (*pwch && (L' ' == *pwch || L'\t' == *pwch)) {
            pwch++;
        }

        wsCmdLine = pwch;
        dw = wcslen(wsCmdLine);

        // convert to oem
        UnicodeString.Length = (USHORT)(dw * sizeof(WCHAR));
        UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);
        UnicodeString.Buffer = wsCmdLine;
        Status = RtlUnicodeStringToOemString(
                    &OemStringCmd,
                    &UnicodeString,
                    TRUE);

        if (!NT_SUCCESS(Status) ){            
            goto BCVTryExit;
            }

        //
        // check len of command line for dos compatibility
        //
        if (OemStringCmd.Length >= MAXIMUM_VDM_COMMAND_LENGTH - Length) {
            Status = STATUS_INVALID_PARAMETER;
            goto BCVTryExit;
            }


        //
        // Search for matching pif file. Search order is AppName dir,
        // followed by win32 default search path. For the shared wow, pif
        // is wowexec.pif if it exists.
        //
        wsBuffer = RtlAllocateHeap(RtlProcessHeap(),MAKE_TAG( VDM_TAG ),MAX_PATH*sizeof(WCHAR));
        if (!wsBuffer) {
            Status = STATUS_NO_MEMORY;
            goto BCVTryExit;
            }

        wsPifName = RtlAllocateHeap(RtlProcessHeap(),MAKE_TAG( VDM_TAG ),MAX_PATH*sizeof(WCHAR));
        if (!wsPifName) {
            Status = STATUS_NO_MEMORY;
            goto BCVTryExit;
            }

        if (BinaryType == BINARY_TYPE_WIN16) {
            wcscpy(wsBuffer, wsSharedWowPif);
            Len = 0;
            }
        else {
            // start with fully qualified app name
            wcscpy(wsBuffer, lpApplicationName);

             // strip extension if any
            pwch = wcsrchr(wsBuffer, (WCHAR)'.');
            // dos application must have an extention
            if (pwch == NULL) {
                 Status = STATUS_INVALID_PARAMETER;
                 goto BCVTryExit;
                }
            wcscpy(pwch, wsPif);
            Len = GetFileAttributesW(wsBuffer);
            if (Len == (DWORD)(-1) || (Len & FILE_ATTRIBUTE_DIRECTORY)) {
                Len = 0;
                }
            else {
                Len = wcslen(wsBuffer) + 1;
                wcsncpy(wsPifName, wsBuffer, Len);
                }
            }

        if (!Len)  {  // try basename

               // find beg of basename
            pwch = wcsrchr(wsBuffer, (WCHAR)'\\');
            if (!pwch ) {
                 pwch = wcsrchr(wsBuffer, (WCHAR)':');
                 }

               // move basename to beg of wsBuffer
            if (pwch++) {
                 while (*pwch != UNICODE_NULL &&
                        *pwch != (WCHAR)' '   && *pwch != (WCHAR)'\t' )
                       {
                        wsBuffer[Len++] = *pwch++;
                        }
                 wsBuffer[Len] = UNICODE_NULL;
                 }

            if (Len)  {
                Len = SearchPathW(
                            NULL,
                            wsBuffer,
                            wsPif,              // L".pif"
                            MAX_PATH,
                            wsPifName,
                            NULL
                            );
                if (Len >= MAX_PATH) {
                    Status = STATUS_NO_MEMORY;
                    goto BCVTryExit;
                    }
                }
            }

        if (!Len)
            *wsPifName = UNICODE_NULL;



        if (!ARGUMENT_PRESENT( lpCurrentDirectory )) {

            dw = RtlGetCurrentDirectory_U(sizeof (wchBuffer), wchBuffer);

            wchBuffer[dw / sizeof(WCHAR)] = UNICODE_NULL;
            dw = GetShortPathNameW(wchBuffer,
                                   wchBuffer,
                                   sizeof(wchBuffer) / sizeof(WCHAR)
                                   );
            if (dw > sizeof(wchBuffer) / sizeof(WCHAR))
                goto BCVTryExit;

            else if (dw == 0) {
                RtlInitUnicodeString(&UnicodeString, wchBuffer);
                dw = UnicodeString.Length / sizeof(WCHAR);
                }
            else {
                UnicodeString.Length = (USHORT)(dw * sizeof(WCHAR));
                UnicodeString.Buffer = wchBuffer;
                UnicodeString.MaximumLength = (USHORT)sizeof(wchBuffer);
                }
            // DOS limit of 64 includes the final NULL but not the leading
            // drive and slash. So here we should be checking the ansi length
            // of current directory + 1 (for NULL) - 3 (for c:\).
            if ( dw - 2 <= MAXIMUM_VDM_CURRENT_DIR ) {
                Status = RtlUnicodeStringToAnsiString(
                                                      &AnsiStringCurrentDir,
                                                      &UnicodeString,
                                                      TRUE
                                                     );
                }
            else {
                Status = STATUS_INVALID_PARAMETER;                
                }

            if ( !NT_SUCCESS(Status) ) {                
                goto BCVTryExit;
                }
            }
        else {

            // first get a full path name
            dw = GetFullPathNameW(lpCurrentDirectory,
                                   sizeof(wchBuffer) / sizeof(WCHAR),
                                   wchBuffer,
                                   NULL);
            if (0 != dw && dw <= sizeof(wchBuffer) / sizeof(WCHAR)) {
               dw = GetShortPathNameW(wchBuffer,
                                      wchBuffer,
                                      sizeof(wchBuffer) / sizeof(WCHAR));
            }
            if (dw > sizeof(wchBuffer) / sizeof(WCHAR))
                goto BCVTryExit;

            if (dw != 0) {
                UnicodeString.Buffer = wchBuffer;
                UnicodeString.Length = (USHORT)(dw * sizeof(WCHAR));
                UnicodeString.MaximumLength = sizeof(wchBuffer);
                }
            else
                RtlInitUnicodeString(&UnicodeString, lpCurrentDirectory);

            Status = RtlUnicodeStringToAnsiString(
                &AnsiStringCurrentDir,
                &UnicodeString,
                TRUE);

            if ( !NT_SUCCESS(Status) ){
                goto BCVTryExit;
               }

            // DOS limit of 64 includes the final NULL but not the leading
            // drive and slash. So here we should be checking the ansi length
            // of current directory + 1 (for NULL) - 3 (for c:\).
            if((AnsiStringCurrentDir.Length - 2) > MAXIMUM_VDM_CURRENT_DIR) {
                Status = STATUS_INVALID_PARAMETER;
                goto BCVTryExit;
                }
            }

        // NT allows applications to use UNC name as their current directory.
        // while NTVDM can't do that. We will end up a weird drive number
        // like '\' - 'a') here ????????????????????????????????
        // 
        // Place Current Drive
        if(AnsiStringCurrentDir.Buffer[0] <= 'Z')
            b->CurDrive = AnsiStringCurrentDir.Buffer[0] - 'A';
        else
            b->CurDrive = AnsiStringCurrentDir.Buffer[0] - 'a';

        //
        // Hotkey info in NT traditionally is specified in the
        // startupinfo.lpReserved field, but Win95 added a
        // duplicate mechanism.  If the Win95 method was used,
        // map it to the NT method here so the rest of the
        // VDM code only has to deal with one method.
        //
        // If the caller was specified a hotkey
        // in lpReserved as well as using STARTF_USEHOTKEY,
        // the STARTF_USEHOTKEY hotkey will take precedence.
        //

        if (lpStartupInfo && lpStartupInfo->dwFlags & STARTF_USEHOTKEY) {

            DWORD cbAlloc = sizeof(WCHAR) *
                            (20 +                            // "hotkey.4294967295 " (MAXULONG)
                             (lpStartupInfo->lpReserved      // length of prev lpReserved
                              ? wcslen(lpStartupInfo->lpReserved)
                              : 0
                             ) +
                             1                               // NULL terminator
                            );


            lpAllocatedReserved = RtlAllocateHeap(RtlProcessHeap(),
                                                  MAKE_TAG( VDM_TAG ),
                                                  cbAlloc
                                                 );
            if (lpAllocatedReserved) {

                swprintf(lpAllocatedReserved,
                         L"hotkey.%u %s",
                         HandleToUlong(lpStartupInfo->hStdInput),
                         lpStartupInfo->lpReserved ? lpStartupInfo->lpReserved : L""
                         );

                lpStartupInfo->dwFlags &= ~STARTF_USEHOTKEY;
                lpStartupInfo->hStdInput = 0;
                lpStartupInfo->lpReserved = lpAllocatedReserved;

            }

        }


        //
        // Allocate Capture Buffer
        //
        //
        bufPointers = 2;  // CmdLine, AppName

        //
        // CmdLine for capture buffer, 3 for 0xd,0xa and NULL
        //
        Len = ROUND_UP((OemStringCmd.Length + 3),4);

        // AppName, 1 for NULL
        Len += ROUND_UP((OemStringAppName.Length + 1),4);

        // Env
        if (pAnsiStringEnv->Length) {
            bufPointers++;
            Len += ROUND_UP(pAnsiStringEnv->Length, 4);
            }

        // CurrentDir
        if (AnsiStringCurrentDir.Length){
            bufPointers++;
            Len += ROUND_UP((AnsiStringCurrentDir.Length +1),4); // 1 for NULL
            }


        // pif file name, 1 for NULL
        if (wsPifName && *wsPifName != UNICODE_NULL) {
            bufPointers++;
            RtlInitUnicodeString(&UnicodeString,wsPifName);
            Status = RtlUnicodeStringToAnsiString(&AnsiStringPif,
                                                  &UnicodeString,
                                                  TRUE
                                                  );
            if ( !NT_SUCCESS(Status) ){                
                goto BCVTryExit;
                }

            Len += ROUND_UP((AnsiStringPif.Length+1),4);
            }

        //
        // startupinfo space
        //
        if (lpStartupInfo) {
            Len += ROUND_UP(sizeof(STARTUPINFOA),4);
            bufPointers++;
            if (lpStartupInfo->lpDesktop) {
                bufPointers++;
                RtlInitUnicodeString(&UnicodeString,lpStartupInfo->lpDesktop);
                Status = RtlUnicodeStringToAnsiString(
                            &AnsiStringDesktop,
                            &UnicodeString,
                            TRUE);

                if ( !NT_SUCCESS(Status) ){
                    goto BCVTryExit;
                    }
                Len += ROUND_UP((AnsiStringDesktop.Length+1),4);
                }

            if (lpStartupInfo->lpTitle) {
                bufPointers++;
                RtlInitUnicodeString(&UnicodeString,lpStartupInfo->lpTitle);
                Status = RtlUnicodeStringToOemString(
                            &OemStringTitle,
                            &UnicodeString,
                            TRUE);

                if ( !NT_SUCCESS(Status) ){
                    goto BCVTryExit;
                    }
                Len += ROUND_UP((OemStringTitle.Length+1),4);
                }

            if (lpStartupInfo->lpReserved) {
                bufPointers++;
                RtlInitUnicodeString(&UnicodeString,lpStartupInfo->lpReserved);
                Status = RtlUnicodeStringToAnsiString(
                            &AnsiStringReserved,
                            &UnicodeString,
                            TRUE);

                if ( !NT_SUCCESS(Status) ){
                    goto BCVTryExit;
                    }
                Len += ROUND_UP((AnsiStringReserved.Length+1),4);
                }
            }


        // capture message buffer
        CaptureBuffer = CsrAllocateCaptureBuffer(bufPointers, Len);
        if (CaptureBuffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto BCVTryExit;
            }

        // Allocate CmdLine pointer
        CsrAllocateMessagePointer( CaptureBuffer,
                                   ROUND_UP((OemStringCmd.Length + 3),4),
                                   (PVOID *)&b->CmdLine
                                 );

        // Copy Command Line
        RtlMoveMemory (b->CmdLine, OemStringCmd.Buffer, OemStringCmd.Length);
        b->CmdLine[OemStringCmd.Length] = 0xd;
        b->CmdLine[OemStringCmd.Length+1] = 0xa;
        b->CmdLine[OemStringCmd.Length+2] = 0;
        b->CmdLen = (USHORT)(OemStringCmd.Length + 3);

        // Allocate AppName pointer
        CsrAllocateMessagePointer( CaptureBuffer,
                                   ROUND_UP((OemStringAppName.Length + 1),4),
                                   (PVOID *)&b->AppName
                                 );

        // Copy AppName
        RtlMoveMemory (b->AppName,
                       OemStringAppName.Buffer,
                       OemStringAppName.Length
                       );
        b->AppName[OemStringAppName.Length] = 0;
        b->AppLen = OemStringAppName.Length + 1;




        // Allocate PifFile pointer, Copy PifFile name
        if(AnsiStringPif.Buffer) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((AnsiStringPif.Length + 1),4),
                                       (PVOID *)&b->PifFile
                                     );

            RtlMoveMemory(b->PifFile,
                          AnsiStringPif.Buffer,
                          AnsiStringPif.Length);

            b->PifFile[AnsiStringPif.Length] = 0;
            b->PifLen = AnsiStringPif.Length + 1;

            }
        else {
            b->PifLen = 0;
            b->PifFile = NULL;
            }



        // Allocate Env pointer, Copy Env strings
        if(pAnsiStringEnv->Length) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((pAnsiStringEnv->Length),4),
                                       (PVOID *)&b->Env
                                     );

            RtlMoveMemory(b->Env,
                          pAnsiStringEnv->Buffer,
                          pAnsiStringEnv->Length);

            b->EnvLen = pAnsiStringEnv->Length;

            }
        else {
            b->EnvLen = 0;
            b->Env = NULL;
            }


        if(AnsiStringCurrentDir.Length) {
            // Allocate Curdir pointer
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((AnsiStringCurrentDir.Length + 1),4),
                                       (PVOID *)&b->CurDirectory
                                       );
            // copy cur directory
            RtlMoveMemory (b->CurDirectory,
                           AnsiStringCurrentDir.Buffer,
                           AnsiStringCurrentDir.Length+1);

            b->CurDirectoryLen = AnsiStringCurrentDir.Length+1;
            }
        else {
            b->CurDirectory = NULL;
            b->CurDirectoryLen = 0;
            }

        // Allocate startupinfo pointer
        if (lpStartupInfo) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP(sizeof(STARTUPINFOA),4),
                                       (PVOID *)&b->StartupInfo
                                     );
            // Copy startupinfo
            b->StartupInfo->dwX  =  lpStartupInfo->dwX;
            b->StartupInfo->dwY  =  lpStartupInfo->dwY;
            b->StartupInfo->dwXSize      =  lpStartupInfo->dwXSize;
            b->StartupInfo->dwYSize      =  lpStartupInfo->dwYSize;
            b->StartupInfo->dwXCountChars=      lpStartupInfo->dwXCountChars;
            b->StartupInfo->dwYCountChars=      lpStartupInfo->dwYCountChars;
            b->StartupInfo->dwFillAttribute=lpStartupInfo->dwFillAttribute;
            b->StartupInfo->dwFlags      =  lpStartupInfo->dwFlags;
            b->StartupInfo->wShowWindow =       lpStartupInfo->wShowWindow;
            b->StartupInfo->cb           =  sizeof(STARTUPINFOA);
            }
        else {
            b->StartupInfo = NULL;
            }

        // Allocate pointer for Desktop info if needed
        if (AnsiStringDesktop.Buffer) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((AnsiStringDesktop.Length + 1),4),
                                       (PVOID *)&b->Desktop
                                     );
            // Copy desktop string
            RtlMoveMemory (b->Desktop,
                           AnsiStringDesktop.Buffer,
                           AnsiStringDesktop.Length+1);
            b->DesktopLen =AnsiStringDesktop.Length+1;
            }
        else {
            b->Desktop = NULL;
            b->DesktopLen =0;
            }

        // Allocate pointer for Title info if needed
        if (OemStringTitle.Buffer) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((OemStringTitle.Length + 1),4),
                                       (PVOID *)&b->Title
                                     );
            // Copy title string
            RtlMoveMemory (b->Title,
                           OemStringTitle.Buffer,
                           OemStringTitle.Length+1);
            b->TitleLen = OemStringTitle.Length+1;
            }
        else {
            b->Title = NULL;
            b->TitleLen = 0;
            }

        // Allocate pointer for Reserved field if needed
        if (AnsiStringReserved.Buffer) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((AnsiStringReserved.Length + 1),4),
                                       (PVOID *)&b->Reserved
                                     );
            // Copy reserved string
            RtlMoveMemory (b->Reserved,
                           AnsiStringReserved.Buffer,
                           AnsiStringReserved.Length+1);
            b->ReservedLen = AnsiStringReserved.Length+1;
            }
        else {
            b->Reserved = NULL;
            b->ReservedLen = 0;
            }

        // VadimB: this code is of no consequence to our marvelous new
        // architecture for tracking shared wows.
        // Reason: the checkvdm command is executed within the context of
        // a parent process thus at this point ConsoleHandle is of any
        // interest only to DOS apps.

        if (BinaryType == BINARY_TYPE_WIN16)
            b->ConsoleHandle = (HANDLE)-1;
        else if (bNewConsole)
            b->ConsoleHandle = 0;
        else
            b->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

        b->VDMState = FALSE;
        b->BinaryType = BinaryType;
        b->CodePage = (ULONG) GetConsoleCP ();
        b->dwCreationFlags = dwCreationFlags;


        Status = CsrClientCallServer(
                          (PCSR_API_MSG)m,
                          CaptureBuffer,
                          CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                               BasepCheckVDM
                                             ),
                          sizeof( *b )
                          );

        // if desktop access is denied, then we try again with the
        // current default desktop
        //

        if ((STATUS_ACCESS_DENIED == Status) && (0 == b->DesktopLen)) {
            CsrFreeCaptureBuffer(CaptureBuffer);
            goto BCVTryExit;
           }
            

        CsrFreeCaptureBuffer(CaptureBuffer);

        if (!NT_SUCCESS(Status) || !NT_SUCCESS((NTSTATUS)m->ReturnValue)) {
            Status = (NTSTATUS)m->ReturnValue;
            goto BCVTryExit;
            }


        // VadimB: This iTask could be :
        //   (*) If not wow task - then dos task id (items below are not
        //       relevant for this case)
        //   (*) Shared wow exists and ready - this is a wow task id
        //       that is unique across all the shared wows

        *iTask = b->iTask;
        Status = STATUS_SUCCESS;

BCVTryExit:;
        BaseSetLastNTError(Status);
        }

    finally {
        if(Buffer != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Buffer);

        if(wsBuffer != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)wsBuffer);

        if(wsPifName != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)wsPifName);

        if(OemStringCmd.Buffer != NULL)
            RtlFreeOemString(&OemStringCmd);

        if(OemStringAppName.Buffer != NULL)
            RtlFreeOemString(&OemStringAppName);

        if(AnsiStringPif.Buffer != NULL)
           RtlFreeAnsiString(&AnsiStringPif);

        if(AnsiStringCurrentDir.Buffer != NULL)
            RtlFreeAnsiString(&AnsiStringCurrentDir);

        if(AnsiStringDesktop.Buffer != NULL)
            RtlFreeAnsiString(&AnsiStringDesktop);

        if(OemStringTitle.Buffer != NULL)
            RtlFreeAnsiString(&OemStringTitle);

        if(AnsiStringReserved.Buffer != NULL)
            RtlFreeAnsiString(&AnsiStringReserved);

        if (wsAppName != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, wsAppName);

        if (lpAllocatedReserved != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, lpAllocatedReserved);

        }

    return Status;
}


/* 
   jarbats
   Some apps send startupinfo with bad desktop name
   as a result, basecheckvdm will fail with because
   access to the desktop can't be obtained
   in that case we attempt again with the parents desktop
   
*/


BOOL
BaseCheckVDM(
    IN  ULONG BinaryType,
    IN  PCWCH lpApplicationName,
    IN  PCWCH lpCommandLine,
    IN  PCWCH lpCurrentDirectory,
    IN  ANSI_STRING *pAnsiStringEnv,
    IN  PBASE_API_MSG m,
    IN OUT PULONG iTask,
    IN  DWORD dwCreationFlags,
    LPSTARTUPINFOW lpStartupInfo
    ) {

   NTSTATUS Status;
   LPWSTR lpDesktopOld;

   Status = BaseCheckVDMp(
                         BinaryType,
                         lpApplicationName,
                         lpCommandLine,
                         lpCurrentDirectory,
                         pAnsiStringEnv,
                         m,
                         iTask,
                         dwCreationFlags,
                         lpStartupInfo
                        );

   if ( Status == STATUS_ACCESS_DENIED ) {
        
        lpDesktopOld = lpStartupInfo->lpDesktop;
                                      
        lpStartupInfo->lpDesktop =
                 (LPWSTR)((PRTL_USER_PROCESS_PARAMETERS)NtCurrentPeb()->
                     ProcessParameters)->DesktopInfo.Buffer;
          
        Status = BaseCheckVDMp(
                              BinaryType,
                              lpApplicationName,
                              lpCommandLine,
                              lpCurrentDirectory,
                              pAnsiStringEnv,
                              m,
                              iTask,
                              dwCreationFlags,
                              lpStartupInfo
                             );

        if (!NT_SUCCESS(Status)) {
            lpStartupInfo->lpDesktop = lpDesktopOld;
           } 
      }

   return NT_SUCCESS(Status);
}  


BOOL
BaseUpdateVDMEntry(
    IN ULONG UpdateIndex,
    IN OUT HANDLE *WaitHandle,
    IN ULONG IndexInfo,
    IN ULONG BinaryType
    )
{
    NTSTATUS Status;
    BASE_API_MSG m;
    PBASE_UPDATE_VDM_ENTRY_MSG c = &m.u.UpdateVDMEntry;

    switch (UpdateIndex) {
        case UPDATE_VDM_UNDO_CREATION:
            c->iTask = HandleToUlong(*WaitHandle);
            c->VDMCreationState = (USHORT)IndexInfo;
            break;
        case UPDATE_VDM_PROCESS_HANDLE:
            c->VDMProcessHandle = *WaitHandle;  // Actually this is VDM handle
            c->iTask = IndexInfo;
            break;
        }

    // VadimB: this ConsoleHandle is of no consequence to the
    // shared wow tracking mechanism

    if(BinaryType == BINARY_TYPE_WIN16)
        c->ConsoleHandle = (HANDLE)-1;
    else if (c->iTask)
        c->ConsoleHandle = 0;
    else
        c->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    c->EntryIndex = (WORD)UpdateIndex;
    c->BinaryType = BinaryType;


    Status = CsrClientCallServer(
                      (PCSR_API_MSG)&m,
                      NULL,
                      CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                           BasepUpdateVDMEntry
                                         ),
                      sizeof( *c )
                      );

    if (!NT_SUCCESS(Status) || !NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
        BaseSetLastNTError((NTSTATUS)m.ReturnValue);
        return FALSE;
        }

    switch (UpdateIndex) {
        case UPDATE_VDM_UNDO_CREATION:
            break;
        case UPDATE_VDM_PROCESS_HANDLE:
            *WaitHandle = c->WaitObjectForParent;
            break;
    }
    return TRUE;
}




ULONG
BaseIsDosApplication(
    IN PUNICODE_STRING PathName,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    Determines if app is a ".com" or a ".pif" type of app
    by looking at the extension, and the Status from NtCreateSection
    for PAGE_EXECUTE.

Arguments:

    PathName    -- Supplies a pointer to the path string
    Status      -- Status code from CreateSection call
    bNewConsole -- Pif can exec only from a new console

Return Value:

    file is a com\pif dos application
    SCS_DOS_BINARY - ".com", may also be a .exe extension
    SCS_PIF_BINARY - ".pif"


    0 -- file is not a dos application, may be a .bat or .cmd file

--*/
{
    UNICODE_STRING String;

         // check for .com extension
    String.Length = BaseDotComSuffixName.Length;
    String.Buffer = &(PathName->Buffer[(PathName->Length - String.Length) /
                    sizeof(WCHAR)]);

    if (RtlEqualUnicodeString(&String, &BaseDotComSuffixName, TRUE))
        return BINARY_TYPE_DOS_COM;


        // check for .pif extension
    String.Length = BaseDotPifSuffixName.Length;
    String.Buffer = &(PathName->Buffer[(PathName->Length - String.Length) /
                    sizeof(WCHAR)]);

    if (RtlEqualUnicodeString(&String, &BaseDotPifSuffixName, TRUE))
        return BINARY_TYPE_DOS_PIF;


        // check for .exe extension
    String.Length = BaseDotExeSuffixName.Length;
    String.Buffer = &(PathName->Buffer[(PathName->Length - String.Length) /
        sizeof(WCHAR)]);

    if (RtlEqualUnicodeString(&String, &BaseDotExeSuffixName, TRUE))
        return BINARY_TYPE_DOS_EXE;

    return 0;
}



BOOL
BaseGetVdmConfigInfo(
    IN  LPCWSTR CommandLine,
    IN  ULONG   DosSeqId,
    IN  ULONG   BinaryType,
    IN  PUNICODE_STRING CmdLineString,
    IN OUT PULONG VdmSize
    )
/*++

Routine Description:

    This routine locates the VDM configuration information for Wow vdms in
    the system configuration file.  It also reconstructs the commandline so
    that we can start the VDM.  The new command line is composed from the
    information in the configuration file + the old command line.

Arguments:

    CommandLine -- pointer to a string pointer that is used to pass the
        command line string

    DosSeqId - new console session id. This parameter is also valid for
               shared wow as it is passed to ntvdm as -i parameter. Another
               parameter to identify shared wow is passed to ntvdm as
               '-ws' where 'w' stands for wow app, 's' stands for separate
               In response to this 's' parameter ntvdm launches a
               separate wow (one-time shot). By default, ntvdm starts a shared
               wow.

    VdmSize --entry:
              If set to 1 construct command line for MEOW
              return: the size in bytes of the VDM to be created

    BinaryType - dos, sharedwow, sepwow


Return Value:

    TRUE -- VDM configuration information was available
    FALSE -- VDM configuration information was not available

Notes:

--*/
{
    NTSTATUS Status;
    BOOL bRet;
    DWORD dw;
    ANSI_STRING AnsiString;
    LPSTR NewCmdLine=NULL;
    PCH   pSrc, pDst, pch;
    ULONG Len;
    char CmdLine[MAX_VDM_CFG_LINE];
    BOOL bMeow =(1 == *VdmSize);

    CmdLineString->Buffer = NULL;

    Len = MAX_VDM_CFG_LINE;


    if (BinaryType == BINARY_TYPE_DOS) {
        bRet = BaseGetVDMKeyword(CMDLINE, CmdLine, &Len, DOSSIZE, VdmSize);
        }
    else {
        bRet = BaseGetVDMKeyword(WOWCMDLINE, CmdLine, &Len, WOWSIZE, VdmSize);
        }

    if (!bRet) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
        }

    //
    // Allocate memory to replace the CommandLine
    // extra space is needed for long->short name conversion,
    // separate wow, and extension.
    //

    NewCmdLine = RtlAllocateHeap(RtlProcessHeap(),
                                 MAKE_TAG( VDM_TAG ),
                                 MAX_PATH + MAX_VDM_CFG_LINE
                                 );
    if (!NewCmdLine) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
        }


    //
    // Copy over the cmdline checking for special args
    // and locating the beg of wowkernel
    //
    pSrc = CmdLine;
    pDst = NewCmdLine;


    //
    // first token must be "\\%SystemRoot%\\system32\\ntvdm", search
    // for the tail of the pathname to traverse possible long file name
    // safely.
    //
    pch = strstr(pSrc, "\\system32\\ntvdm");
    if (!pch) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
        }

    // mov pch to trailing space in "ntvdm "
    while (*pch && *pch != ' ') {
        pch++;
        }

    //
    // copy first token (ntvdm path name), surrounded by quotes for
    // possible long file name
    //
   *pDst++ = '\"';
    while (pSrc < pch) {
       *pDst++ = *pSrc++;
       }
    *pDst++ = '\"';


    //
    // Add -f arg, so ntvdm knows it wasn't invoked directly
    //
    *pDst++ = ' ';
    *pDst++ = '-';
    *pDst++ = 'f';

    //
    // Add DosSeqId for new console
    //
    if (DosSeqId) {
        sprintf(pDst, " -i%lx", DosSeqId);
        pDst += strlen(pDst);
        }

    //
    // Copy over everything up to the " -a " (exclusive)
    // CAVEAT: we assume -a is last
    //
    pch = strstr(pSrc, " -a ");
    if (pch) {
        while (pSrc < pch) {
           *pDst++ = *pSrc++;
           }
        }
    else {
        while (*pSrc) {
           *pDst++ = *pSrc++;
           }
        }

    *pDst = '\0';


    //
    // for wow -a is mandatory to specify win16 krnl, and is expected
    // to be the last cmdline parameter
    //
    if (BinaryType != BINARY_TYPE_DOS) { // shared wow, sep wow
        PCH pWowKernel;

        if (!*pSrc) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }

        //
        // Add -w to tell ntvdm its wow (mandatory)
        //
        *pDst++ = ' ';
        *pDst++ = '-';
        *pDst++ = 'w';

        //
        // identify that this wow is a separate wow by -ws
        //

        if (BINARY_TYPE_SEPWOW == BinaryType) {
           *pDst++ = 's';
        }

        //
        // identify that this wow is a MEOW process by -wsm
        //

        if (bMeow) {
            *pDst++ = 'm';
        }

        //
        // copy over the " -a WowKernelPathname" argument
        // and locate beg of WowKernelPathname in destination
        //
        pWowKernel = pDst;
        while (*pSrc) {
           *pDst++ = *pSrc++;
           }
        pWowKernel += 4;      // find beg of WowKernelPathaname
        while (*pWowKernel == ' ') {
           pWowKernel++;
           }

        //
        // If meow process, change krnl386 to mekr386
        //
        if (bMeow) {            
            pch=strrchr(pWowKernel,'\\');
            strcpy(pch+1,"mekr386.exe");            
            }
        else {

            //
            // Append file extension to destination
            //
            strcpy(pDst, ".exe");
            }

        //
        // convert wowkernel to short name
        //
        Len = MAX_PATH + MAX_VDM_CFG_LINE - (ULONG)((ULONG_PTR)pWowKernel - (ULONG_PTR)NewCmdLine) -1;
        dw = GetShortPathNameA(pWowKernel, pWowKernel, Len);
        if (dw > Len) {
            RtlFreeHeap(RtlProcessHeap(), 0, NewCmdLine);
            return FALSE;
            }
        }

    RtlInitAnsiString(&AnsiString, NewCmdLine);
    Status = RtlAnsiStringToUnicodeString(CmdLineString, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        RtlFreeHeap(RtlProcessHeap(), 0, NewCmdLine);
        CmdLineString->Buffer = NULL;
        return FALSE;
        }

    RtlFreeHeap(RtlProcessHeap(), 0, NewCmdLine);
    return TRUE;
}





BOOL
BaseCheckForVDM(
    IN HANDLE hProcess,
    OUT LPDWORD lpExitCode
    )
{
    NTSTATUS Status;
    EVENT_BASIC_INFORMATION ebi;
    BASE_API_MSG m;
    PBASE_GET_VDM_EXIT_CODE_MSG a = &m.u.GetVDMExitCode;

    Status = NtQueryEvent (
                hProcess,
                EventBasicInformation,
                &ebi,
                sizeof(ebi),
                NULL);

    if(!NT_SUCCESS(Status))
        return FALSE;

    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;
    a->hParent = hProcess;
    Status = CsrClientCallServer(
                      (PCSR_API_MSG)&m,
                      NULL,
                      CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                      BasepGetVDMExitCode),
                      sizeof( *a )
                      );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
        }

    *lpExitCode = (DWORD)a->ExitCode;

    return TRUE;
}




DWORD
APIENTRY
GetShortPathNameA(
    IN  LPCSTR  lpszLongPath,
    IN  LPSTR   lpShortPath,
    IN  DWORD   cchBuffer
    )
{
    UNICODE_STRING  UString, UStringRet;
    ANSI_STRING     AString;
    NTSTATUS        Status;
    WCHAR           TempPathW[MAX_PATH];
    LPWSTR          lpShortPathW = NULL;
    DWORD           ReturnValue;
    DWORD           ReturnValueW;

    if (lpszLongPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
        }
    // We have to initialize it before the "try" statement
    AString.Buffer = NULL;
    UString.Buffer = NULL;

    ReturnValue = 0;
    ReturnValueW = 0;

    try {
        if (!Basep8BitStringToDynamicUnicodeString(&UString, lpszLongPath )) {
            goto gspTryExit;
            }

        // we have to get the real converted path in order to find out
        // the required length. An UNICODE char does not necessarily convert
        // to one ANSI char(A DBCS is basically TWO ANSI char!!!!!).
        // First, we use the buffer allocated from the stack. If the buffer
        // is too small, we then allocate it from heap.
        // A check of (lpShortPathW && TempPathW != lpShortPathW) will reveal
        // if we have allocated a buffer from heap and need to release it.
        lpShortPathW = TempPathW;
        ReturnValueW = GetShortPathNameW(UString.Buffer, lpShortPathW, sizeof(TempPathW) / sizeof(WCHAR));
        if (ReturnValueW >= sizeof(TempPathW) / sizeof(WCHAR))
            {
            // the stack-based buffer is too small. Allocate a new buffer
            // from heap.
            lpShortPathW = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                        ReturnValueW * sizeof(WCHAR)
                                        );
            if (lpShortPathW) {
                ReturnValueW = GetShortPathNameW(UString.Buffer, lpShortPathW, ReturnValueW);
                }
            else {
                ReturnValueW = 0;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                }
            }

        if (ReturnValueW)
            {
            // we are here because we have something interesting left to do.
            // Convert the UNICODE path name to ANSI(or OEM).
            UString.MaximumLength = (USHORT)((ReturnValueW + 1) * sizeof(WCHAR));
            UStringRet.Buffer = lpShortPathW;
            UStringRet.Length = (USHORT)(ReturnValueW * sizeof(WCHAR));
            Status = BasepUnicodeStringTo8BitString(&AString,
                                                    &UStringRet,
                                                    TRUE
                                                    );

            if (!NT_SUCCESS(Status))
                {
                BaseSetLastNTError(Status);
                ReturnValue=0;
                goto gspTryExit;
                }
            // now AString.Length contains the size of the converted path
            // name. If the caller provides enough buffer, copy the
            // path name.
            ReturnValue = AString.Length;
            if (ARGUMENT_PRESENT(lpShortPath) && cchBuffer > ReturnValue)
                {
                RtlMoveMemory(lpShortPath, AString.Buffer, ReturnValue);
                // terminate the string with NULL char
                lpShortPath[ReturnValue] = '\0';
                }
            else
                {
                // either the caller does not provide a buffer or
                // the provided buffer is too small return the required size,
                // including the terminated null char
                ReturnValue++;
                }
            }
gspTryExit:;
        }

    finally {
            if (UString.Buffer)
                RtlFreeUnicodeString(&UString);
            if (AString.Buffer)
                RtlFreeAnsiString(&AString);
            if (lpShortPathW && lpShortPathW != TempPathW)
                RtlFreeHeap(RtlProcessHeap(), 0, lpShortPathW);
        }
    return ReturnValue;
}
/****
GetShortPathName

Description:
    This function converts the given path name to its short form if
     needed. The conversion  may not be necessary and in that case,
     this function simply copies down the given name to the return buffer.
    The caller can have the return buffer set equal to the given path name
     address.

Parameters:
    lpszLongPath -  Points to a NULL terminated string.
    lpszShortPath - Buffer address to return the short name.
    cchBuffer - Buffer size in char of lpszShortPath.

Return Value
    If the GetShortPathName function succeeds, the return value is the length,
    in characters, of the string copied to lpszShortPath,
    not including the terminating
    null character.

    If the lpszShortPath is too small, the return value is
    the size of the buffer, in
    characters, required to hold the path.

    If the function fails, the return value is zero. To get
    extended error information, use
    the GetLastError function.

Remarks:
    The "short name" can be longer than its "long name". lpszLongPath doesn't
    have to be a fully qualified path name or a long path name.

****/

DWORD
APIENTRY
GetShortPathNameW(
    IN  LPCWSTR lpszLongPath,
    IN  LPWSTR  lpszShortPath,
    IN  DWORD   cchBuffer
    )
{

    LPCWSTR         pcs;
    LPWSTR          pSrcCopy, pSrc, pFirst, pLast, pDst;
    WCHAR           wch;
    HANDLE          FindHandle;
    WIN32_FIND_DATAW        FindData;
    LPWSTR          Buffer;
    DWORD           ReturnLen=0, Length;
    UINT PrevErrorMode;
    if (!ARGUMENT_PRESENT(lpszLongPath)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
        }

    //
    // override the error mode since we will be touching the media.
    // This is to prevent file system's pop-up when the given path does not
    // exist or the media is not available.
    // we are doing this because we can not depend on the caller's current
    // error mode. NOTE: the old error mode must be restored.
    PrevErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    try {
        Buffer = NULL;
        pSrcCopy = NULL;
        // first, make sure the given path exist
        if (0xFFFFFFFF == GetFileAttributesW(lpszLongPath))
        {
            //
            // (bjm - 3/17/99)
            // This behavior (failing if the file does not exist) is new (to NT) with NT 5.
            // (It's the Win9x behavior.)
            // Give an exception to Norton AntiVirus Uninstall.
            // If we fail this call, there will be a registry value left behind in VDD that'll cause
            // undeserved ugly messages for a user.  Norton AV Uninstall counts on NT 4 behavior
            // which did not care if the file existed to do this conversion.  This was changed in
            // NT 5.0 to match Win9x behavior.
            //
            if ( !NtCurrentPeb() || !APPCOMPATFLAG(KACF_OLDGETSHORTPATHNAME) )
            {
                // last error has been set by GetFileAttributes
                ReturnLen = 0;
                goto gsnTryExit;
            }
        }

        pcs = SkipPathTypeIndicator_U(lpszLongPath);
        if (!pcs || *pcs == UNICODE_NULL || !FindLFNorSFN_U((LPWSTR)pcs, &pFirst, &pLast, TRUE))
            {
            // nothing to convert, copy down the source string
            // to the buffer if necessary

            ReturnLen = wcslen(lpszLongPath);
            if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath))
                {
                if (lpszShortPath != lpszLongPath)
                    RtlMoveMemory(lpszShortPath, lpszLongPath,
                                  (ReturnLen + 1) * sizeof(WCHAR)
                                  );
                }
            else {
                // the caller does not provide enough buffer, return
                // necessary string length plus the terminated null char
                ReturnLen++;
                }
            goto gsnTryExit;
            }

        // conversions  are necessary, make a local copy of the string
        // because we have to party on it.

        ASSERT(!pSrcCopy);

        // get the source string length
        Length  = wcslen(lpszLongPath) + 1;

        pSrcCopy = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                   Length * sizeof(WCHAR)
                                   );
        if (!pSrcCopy) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto gsnTryExit;
            }
        wcsncpy(pSrcCopy, lpszLongPath, Length);
        // pFirst points to the first char of the very first LFN in the path
        // pLast points to the char right after the last char of the very
        // first LFN in the path. *pLast could be UNICODE_NULL
        pFirst = pSrcCopy + (pFirst - lpszLongPath);
        pLast = pSrcCopy  + (pLast - lpszLongPath);
        //
        // We allow lpszShortPath be overlapped with lpszLongPath so
        // allocate a local buffer.

        pDst = lpszShortPath;
        if (cchBuffer > 0 && ARGUMENT_PRESENT(lpszShortPath) &&
            (lpszShortPath >= lpszLongPath &&lpszShortPath < lpszLongPath + Length ||
             lpszShortPath < lpszLongPath && lpszShortPath + cchBuffer >= lpszLongPath))
            {
            ASSERT(!Buffer);

            Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                           cchBuffer * sizeof(WCHAR));
            if (!Buffer){
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto gsnTryExit;
            }
            pDst = Buffer;
        }

        pSrc = pSrcCopy;

        ReturnLen = 0;
        do {
            // there are three pointers involve in the conversion loop:
            // pSrc, pFirst and pLast. Their relationship
            // is:
            //
            // "c:\long~1.1\\foo.bar\\long~2.2\\bar"
            //  ^          ^          ^       ^
            //  |          |          |       |
            //  |          pSrc       pFirst  pLast
            //  pSrcCopy
            //
            // pSrcCopy always points to the very first char of the entire
            // path.
            //
            // chars between pSrc(included) and pFirst(not included)
            // do not need conversion so we simply copy them.
            // chars between pFirst(included) and pLast(not included)
            // need conversion.
            //
            Length = (ULONG)(pFirst - pSrc);
            if (Length) {
                ReturnLen += Length;
                if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath)) {
                    RtlMoveMemory(pDst, pSrc, Length * sizeof(WCHAR));
                    pDst += Length;
                    }
                }
            wch = *pLast;
            *pLast = UNICODE_NULL;
            FindHandle = FindFirstFileW(pSrcCopy, &FindData);
            *pLast = wch;
            if (INVALID_HANDLE_VALUE != FindHandle) {
                FindClose(FindHandle);
                // if no short name could be found, copy the original name.
                // the origian name starts with pFirst(included) and ends
                // with pLast(excluded).
                if (!(Length = wcslen(FindData.cAlternateFileName)))
                    Length = (ULONG)(pLast - pFirst);
                else
                    pFirst = FindData.cAlternateFileName;
                ReturnLen += Length;
                if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath))
                    {
                    RtlMoveMemory(pDst, pFirst, Length * sizeof(WCHAR));
                    pDst += Length;
                    }
                 }
            else {
                // part of the path does not exist, fail the function
                //
                ReturnLen = 0;
                break;
                }
            // move to next path name
            pSrc = pLast;
            if (*pLast == UNICODE_NULL)
                break;
            }while (FindLFNorSFN_U(pSrc, &pFirst, &pLast, TRUE));

        // if ReturnLen == 0, we fail somewhere inside while loop.
        if (ReturnLen) {
            // (*pSrc == UNICODE_NULL) means the last pathname is a LFN which
            // has been dealt with. otherwise, the substring pointed by
            // pSrc is a legal short path name and we have to copy it
            //Length could be zero
            Length = wcslen(pSrc);
            ReturnLen += Length;
            if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath))
                {
                //include the terminated null char
                RtlMoveMemory(pDst, pSrc, (Length + 1)* sizeof(WCHAR));
                if (Buffer)
                    RtlMoveMemory(lpszShortPath, Buffer, (ReturnLen + 1) * sizeof(WCHAR));
                }
            else
                // not enough buffer, the return value counts the terminated NULL
                ReturnLen++;
            }
gsnTryExit:;
        }
    finally {
         if (Buffer)
            RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
         if (pSrcCopy)
            RtlFreeHeap(RtlProcessHeap(), 0, pSrcCopy);

         // restore the error mode
         SetErrorMode(PrevErrorMode);
        }

    return ReturnLen;
}

/**
   function to create VDM environment for the new executable.
   Input:   lpEnvironmen = optinal environment strings prototype in UNICODE.
                           If it is NULL, this function use the environment
                           block attached to the process
            pAStringEnv  = pointer to a ANSI_STRING to receive the
                           new environment strings.
            pUStringEnv  = pointer to a UNICODE_STRING to receive the
                           new environment strings.
    Output: FALSE if the creattion failed.
            TRUE  creation successful, pAStringEnv has been setup.

    This function was provided so that BaseCheckVdm can have correct
    environment(includes the newly create NTVDM process). This was done
    because before command.com gets the next command, users can have
    tons of things specified in config.sys and autoexec.bat which
    may rely on current directory of each drive.
**/
BOOL BaseCreateVDMEnvironment(
    PWCHAR lpEnvironment,
    ANSI_STRING * pAStringEnv,
    UNICODE_STRING  *pUStringEnv
    )
{
    WCHAR  *pEnv, *pDst, *EnvStrings=NULL,* pTmp, *pNewEnv=NULL;
    DWORD   cchEnv, dw, Length, dwRemain;
    NTSTATUS    Status;
    UINT        NameType;
    BOOL        bRet = FALSE;
    SIZE_T      EnvSize;

    if (!ARGUMENT_PRESENT(pAStringEnv) || !ARGUMENT_PRESENT(pUStringEnv)){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }
    try {
        // the environment strings are shared by every thread of the same
        // process. Since we have no idea of what the caller process
        // is, we have to grab the entire environment to our local buffer in one
        // shot then we can walk through the strings.
        // Note that if another thread makes call to RtlSetEnvironmentVariable
        // then we are out of sync. It is a problem of process structure and
        // I don't want to think about it now.
        // The funny thing is that we have to assume the environment
        // is a block of strings(otherwise, how can we do it?)t, nothing more and
        // nothing less. If someday and somebody dares to change it, he will be
        // the one to blame. If the caller(CreateProcess)
        // provides the environment, we assume it is safe to walk through it.
        //

        if (lpEnvironment == NULL) {
            // create a new environment and inherit the current process env
            Status = RtlCreateEnvironment(TRUE, (PVOID *)&EnvStrings);
            if (!NT_SUCCESS(Status))
                goto bveTryExit;
            }
        else
            EnvStrings = lpEnvironment;

        if (EnvStrings == NULL) {
            SetLastError(ERROR_BAD_ENVIRONMENT);
            goto bveTryExit;
            }
        // figure out how long the environment is
        // why can Rtl just provides such a function for us?
        //
        cchEnv = 0;
        pEnv = EnvStrings;
        // environment is double-null terminated
        while (!(*pEnv++ == UNICODE_NULL && *pEnv == UNICODE_NULL))
            cchEnv++;
        // count the last two NULLs
        cchEnv += 2;
        // we don't want to change the original environment, so
        // make a local buffer for it.
        EnvSize = (cchEnv + MAX_PATH) * sizeof(WCHAR);
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pNewEnv,
                                          0,
                                          &EnvSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS(Status) ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            pNewEnv = NULL;
            goto bveTryExit;
            }
        // give the last two for null
        dwRemain = MAX_PATH - 2;
        // now walk through the environment string
        pEnv = EnvStrings;
        // the new environmet will be
        pDst = pNewEnv;
        while (*pEnv != UNICODE_NULL) {
            // current directory environment has the form as:
            // "=d:=d:\pathname" where d: is the drive designator.
            if (pEnv[0] == L'=')
                {
                if ((pEnv[1] >= L'A' && pEnv[1] <= L'Z' || pEnv[1] >= L'a' && pEnv[1] <= L'z') &&
                     pEnv[2] == L':' && pEnv[3] == L'=' && wcslen(pEnv) >= 7)
                    {
                    // hack hack!!!!
                    // if the path points to the root directory,
                    // bypass the conversion. Dos or Wow keeps current directory
                    // for every valid drive. If we do the conversion for
                    // every current directory, it could take several
                    // seconds on removable drives, especially, on
                    // floppy drives.
                    if (pEnv[7] == UNICODE_NULL &&
                        (pEnv[6] == L'\\' || pEnv[6] == L'/') &&
                        pEnv[5] == L':' &&
                        (pEnv[4] >= L'A' && pEnv[4] <= L'Z' ||
                         pEnv[4] >= L'a' && pEnv[4] <= L'z'))
                        {
                        NameType = ENV_NAME_TYPE_NO_PATH;
                        }
                    else
                        {
                        // copy "=N:=", where N is the drive letter
                        *pDst++ = *pEnv++;*pDst++ = *pEnv++;
                        *pDst++ = *pEnv++;*pDst++ = *pEnv++;
                        NameType = ENV_NAME_TYPE_SINGLE_PATH;
                        }
                    }
                else {
                    // a weird environment was detected.
                    // treat it as no path
                    NameType = ENV_NAME_TYPE_NO_PATH;
                    }
                }
            else {
                pTmp = pEnv;
                // copy down the name and the '='
                while (*pEnv != UNICODE_NULL && (*pDst++ = *pEnv++) != L'=')
                    ;
                NameType = BaseGetEnvNameType_U(pTmp, (DWORD)(pEnv - pTmp) - 1);
                }

            if (NameType == ENV_NAME_TYPE_NO_PATH) {
                while ((*pDst++ = *pEnv++) != UNICODE_NULL)
                    ;
                }
            else if (NameType == ENV_NAME_TYPE_SINGLE_PATH) {
                    Length = wcslen(pEnv) + 1;
                    dw = GetShortPathNameW(pEnv, pDst, Length + dwRemain);
                    // if the conversion failed, we simply pass down the original
                    // one no matter what the reason is. This is done because we
                    // are doing the environment strings.
                    if (dw == 0 || dw >= Length + dwRemain){
                        RtlMoveMemory(pDst, pEnv, Length * sizeof(WCHAR));
                        dw = Length - 1;
                        }
                    pDst += dw + 1;
                    pEnv += Length;
                    if (dw > Length)
                        dwRemain -= dw - Length;
                    }
                 else {
                    // multiple path name found.
                    // the character ';' is used for seperator
                     pTmp = pEnv;
                     while(*pEnv != UNICODE_NULL) {
                        if (*pEnv == L';') {
                            // length not include the ';'
                            Length = (DWORD)(pEnv - pTmp);
                            if (Length > 0) {
                                *pEnv = UNICODE_NULL;
                                dw = GetShortPathNameW(pTmp, pDst, Length + 1 + dwRemain);
                                // again, if the conversion failed, use the original one
                                if (dw == 0 || dw > Length + dwRemain) {
                                    RtlMoveMemory(pDst, pTmp, Length * sizeof(WCHAR));
                                    dw = Length;
                                    }
                                pDst += dw;
                                *pDst++ = *pEnv++ = L';';
                                if (dw > Length)
                                    dwRemain -= dw - Length;
                                }
                             // skip all consecutive ';'
                             while (*pEnv == L';')
                                *pDst++ = *pEnv++;
                             pTmp = pEnv;
                             }
                        else
                            pEnv++;
                        }
                    // convert the last one
                    if ((Length = (DWORD)(pEnv - pTmp)) != 0) {
                        dw = GetShortPathNameW(pTmp, pDst, Length+1 + dwRemain);
                        if (dw == 0 || dw > Length) {
                            RtlMoveMemory(pDst, pTmp, Length * sizeof(WCHAR));
                            dw = Length;
                            }
                        pDst += dw;
                        if (dw > Length)
                            dwRemain -= dw - Length;
                        }
                    *pDst++ = *pEnv++;
                    }
            }
        *pDst++ = UNICODE_NULL;
        cchEnv = (ULONG)((ULONG_PTR)pDst - (ULONG_PTR)pNewEnv);
        pUStringEnv->MaximumLength = pUStringEnv->Length = (USHORT)cchEnv;
        pUStringEnv->Buffer = pNewEnv;
        Status = RtlUnicodeStringToAnsiString(pAStringEnv,
                                              pUStringEnv,
                                              TRUE
                                              );

        if (!NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
        } else {
            pNewEnv = NULL;
            bRet = TRUE;
        }
bveTryExit:;
        }
    finally {
        if (lpEnvironment == NULL && EnvStrings != NULL) {
            RtlDestroyEnvironment(EnvStrings);
        }
        if (pNewEnv != NULL) {
            pUStringEnv->Length = pUStringEnv->MaximumLength = 0;
            pUStringEnv->Buffer = NULL;
            pAStringEnv->Length = pAStringEnv->MaximumLength = 0;
            pAStringEnv->Buffer = NULL;
            Status = NtFreeVirtualMemory (NtCurrentProcess(),
                                          &pNewEnv,
                                          &EnvSize,
                                          MEM_DECOMMIT);
            ASSERT (NT_SUCCESS (Status));
        }
    }
    return bRet;
}
/**
    Destroy the environment block created by BaseCreateVDMEnvironment
    Input: ANSI_STRING * pAnsiStringVDMEnv
                      Environment block in ANSI, should be freed via
                      RtlFreeAnsiString
           UNICODE_STRING * pUnicodeStringEnv
                      Environment block in UNICODE. The Buffer should
                      be freed with RtlFreeHeap.
    Output: should always be TRUE.

**/

BOOL
BaseDestroyVDMEnvironment(
    ANSI_STRING *pAStringEnv,
    UNICODE_STRING *pUStringEnv
    )
{
    if (pAStringEnv->Buffer)
        RtlFreeAnsiString(pAStringEnv);
    if (pUStringEnv->Buffer) {
        NTSTATUS Status;
        SIZE_T RegionSize;

        //
        // Free the specified environment variable block.
        //

        RegionSize = 0;
        Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                      &pUStringEnv->Buffer,
                                      &RegionSize,
                                      MEM_RELEASE
                                    );
    }
    return TRUE;

}

/**
    This function returns the name type of the given environment variable name
    The name type has three possibilities. Each one represents if the
    given name can have pathnames as its value.
     ENV_NAME_TYPE_NO_PATH:   no pathname can be its value
     ENV_NAME_TYPE_SINGLE_PATH: single pathname
     ENV_NAME_MULTIPLE_PATH: multiple path


    SIDE NOTE:
        Currently, nt can not installed on a long path and it seems
        that systemroot and windir are never be in long path.

**/
UINT
BaseGetEnvNameType_U(WCHAR * Name, DWORD NameLength)
{


// so far we only take care of five predefined names:
// PATH
// WINDIR and
// SYSTEMROOT.
// TEMP
// TMP
//
static ENV_INFO     EnvInfoTable[STD_ENV_NAME_COUNT] = {
    {ENV_NAME_TYPE_MULTIPLE_PATH, ENV_NAME_PATH_LEN, ENV_NAME_PATH},
    {ENV_NAME_TYPE_SINGLE_PATH, ENV_NAME_WINDIR_LEN, ENV_NAME_WINDIR},
    {ENV_NAME_TYPE_SINGLE_PATH, ENV_NAME_SYSTEMROOT_LEN, ENV_NAME_SYSTEMROOT},
    {ENV_NAME_TYPE_MULTIPLE_PATH, ENV_NAME_TEMP_LEN, ENV_NAME_TEMP},
    {ENV_NAME_TYPE_MULTIPLE_PATH, ENV_NAME_TMP_LEN, ENV_NAME_TMP}
    };



   UINT NameType;
   int  i;


    NameType = ENV_NAME_TYPE_NO_PATH;
    for (i = 0; i < STD_ENV_NAME_COUNT; i++) {
        if (EnvInfoTable[i].NameLength == NameLength &&
            !_wcsnicmp(EnvInfoTable[i].Name, Name, NameLength)) {
            NameType = EnvInfoTable[i].NameType;
            break;
            }
        }
    return NameType;
}


DWORD
APIENTRY
GetLongPathNameA(
    IN  LPCSTR  lpszShortPath,
    IN  LPSTR   lpLongPath,
    IN  DWORD   cchBuffer
    )
{
    UNICODE_STRING  UString, UStringRet;
    ANSI_STRING     AString;
    NTSTATUS        Status;
    LPWSTR          lpLongPathW = NULL;
    WCHAR           TempPathW[MAX_PATH];
    DWORD           ReturnValue, ReturnValueW;


    if (lpszShortPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
        }

    AString.Buffer = NULL;
    UString.Buffer = NULL;

    ReturnValue = 0;
    ReturnValueW = 0;

    try {
        if (!Basep8BitStringToDynamicUnicodeString(&UString, lpszShortPath )) {
            goto glpTryExit;
            }

        // we have to get the real converted path in order to find out
        // the required length. An UNICODE char does not necessarily convert
        // to one ANSI char(A DBCS is basically TWO ANSI char!!!!!).
        // First, we use the buffer allocated from the stack. If the buffer
        // is too small, we then allocate it from heap.
        // A check of (lpLongPathW && TempPathW != lpLongPathW) will reveal
        // if we have allocated a buffer from heap and need to release it.
        lpLongPathW = TempPathW;
        ReturnValueW = GetLongPathNameW(UString.Buffer, lpLongPathW, sizeof(TempPathW) / sizeof(WCHAR));
        if (ReturnValueW >= sizeof(TempPathW) / sizeof(WCHAR))
            {
            // the stack-based buffer is too small. Allocate a new buffer
            // from heap.
            lpLongPathW = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                        ReturnValueW * sizeof(WCHAR)
                                        );
            if (lpLongPathW) {
                ReturnValueW = GetLongPathNameW(UString.Buffer, lpLongPathW, ReturnValueW);
                }
            else {
                ReturnValueW = 0;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                }
            }

        if (ReturnValueW)
            {
            // we are here because we have something interesting left to do.
            // Convert the UNICODE path name to ANSI(or OEM).
            UString.MaximumLength = (USHORT)((ReturnValueW + 1) * sizeof(WCHAR));
            UStringRet.Buffer = lpLongPathW;
            UStringRet.Length = (USHORT)(ReturnValueW * sizeof(WCHAR));
            Status = BasepUnicodeStringTo8BitString(&AString,
                                                    &UStringRet,
                                                    TRUE
                                                    );

            if (!NT_SUCCESS(Status))
                {
                BaseSetLastNTError(Status);
                ReturnValue=0;
                goto glpTryExit;
                }
            // now AString.Length contains the size of the converted path
            // name. If the caller provides enough buffer, copy the
            // path name.
            ReturnValue = AString.Length;
            if (ARGUMENT_PRESENT(lpLongPath) && cchBuffer > ReturnValue)
                {
                RtlMoveMemory(lpLongPath, AString.Buffer, ReturnValue);
                // terminate the buffer with NULL char.
                lpLongPath[ReturnValue] = '\0';
                }
            else
                {
                // either the caller does not provide a buffer or
                // the provided buffer is too small, return the required size,
                // including the terminated null char.
                ReturnValue++;
                }
            }
glpTryExit:;
        }

    finally {
            if (UString.Buffer)
                RtlFreeUnicodeString(&UString);
            if (AString.Buffer)
                RtlFreeAnsiString(&AString);
            if (lpLongPathW && lpLongPathW != TempPathW)
                RtlFreeHeap(RtlProcessHeap(), 0, lpLongPathW);
        }
    return ReturnValue;
}

DWORD
APIENTRY
GetLongPathNameW(
    IN  LPCWSTR lpszShortPath,
    IN  LPWSTR  lpszLongPath,
    IN  DWORD   cchBuffer
)
{

    LPCWSTR pcs;
    DWORD ReturnLen, Length;
    LPWSTR pSrc, pSrcCopy, pFirst, pLast, Buffer, pDst;
    WCHAR   wch;
    HANDLE          FindHandle;
    WIN32_FIND_DATAW        FindData;
    UINT PrevErrorMode;

    if (!ARGUMENT_PRESENT(lpszShortPath)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
        }
    //
    // override the error mode since we will be touching the media.
    // This is to prevent file system's pop-up when the given path does not
    // exist or the media is not available.
    // we are doing this because we can not depend on the caller's current
    // error mode. NOTE: the old error mode must be restored.
    PrevErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    try {

        Buffer = NULL;
        pSrcCopy = NULL;
        // first make sure the given path exist.
        //
        if (0xFFFFFFFF == GetFileAttributesW(lpszShortPath))
        {
            // last error has been set by GetFileAttributes
            ReturnLen = 0;
            goto glnTryExit;
        }
        pcs = SkipPathTypeIndicator_U(lpszShortPath);
        if (!pcs || *pcs == UNICODE_NULL || !FindLFNorSFN_U((LPWSTR)pcs, &pFirst, &pLast, FALSE))
            {
            // The path is ok and does not need conversion at all.
            // Check if we need to do copy
            ReturnLen = wcslen(lpszShortPath);
            if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszLongPath))
                {
                if (lpszLongPath != lpszShortPath)
                    RtlMoveMemory(lpszLongPath, lpszShortPath,
                                      (ReturnLen + 1)* sizeof(WCHAR)
                                      );
                }
            else {
                // No buffer or buffer too small, the return size
                // has to count the terminated NULL char
                ReturnLen++;
                }
            goto glnTryExit;
            }


        // conversions  are necessary, make a local copy of the string
        // because we have to party on it.

        ASSERT(!pSrcCopy);

        Length = wcslen(lpszShortPath) + 1;
        pSrcCopy = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                   Length * sizeof(WCHAR)
                                   );
        if (!pSrcCopy) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto glnTryExit;
            }
        RtlMoveMemory(pSrcCopy, lpszShortPath, Length * sizeof(WCHAR));
        // pFirst points to the first char of the very first SFN in the path
        // pLast points to the char right after the last char of the very
        // first SFN in the path. *pLast could be UNICODE_NULL
        pFirst = pSrcCopy + (pFirst - lpszShortPath);
        pLast = pSrcCopy + (pLast - lpszShortPath);
        //
        // We allow lpszShortPath be overlapped with lpszLongPath so
        // allocate a local buffer if necessary:
        // (1) the caller does provide a legitimate buffer and
        // (2) the buffer overlaps with lpszShortName

        pDst = lpszLongPath;
        if (cchBuffer && ARGUMENT_PRESENT(lpszLongPath) &&
            (lpszLongPath >= lpszShortPath && lpszLongPath < lpszShortPath + Length ||
             lpszLongPath < lpszShortPath && lpszLongPath + cchBuffer >= lpszShortPath))
            {
            ASSERT(!Buffer);

            Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                           cchBuffer * sizeof(WCHAR));
            if (!Buffer){
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto glnTryExit;
                }
            pDst = Buffer;
            }

        pSrc = pSrcCopy;
        ReturnLen = 0;
        do {
            // there are three pointers involve in the conversion loop:
            // pSrc, pFirst and pLast. Their relationship
            // is:
            //
            // "c:\long~1.1\\foo.bar\\long~2.2\\bar"
            //  ^          ^          ^       ^
            //  |          |          |       |
            //  |          pSrc       pFirst  pLast
            //  pSrcCopy
            //
            // pSrcCopy always points to the very first char of the entire
            // path.
            //
            // chars between pSrc(included) and pFirst(not included)
            // do not need conversion so we simply copy them.
            // chars between pFirst(included) and pLast(not included)
            // need conversion.
            //
            Length = (ULONG)(pFirst - pSrc);
            ReturnLen += Length;
            if (Length && cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath))
                {
                RtlMoveMemory(pDst, pSrc, Length * sizeof(WCHAR));
                pDst += Length;
                }
            // now try to convert the name, chars between pFirst and (pLast - 1)
            wch = *pLast;
            *pLast = UNICODE_NULL;
            FindHandle = FindFirstFileW(pSrcCopy, &FindData);
            *pLast = wch;
            if (FindHandle != INVALID_HANDLE_VALUE){
                FindClose(FindHandle);
                // if no long name, copy the original name
                // starts with pFirst(included) and ends with pLast(excluded)
                if (!(Length = wcslen(FindData.cFileName)))
                    Length = (ULONG)(pLast - pFirst);
                else
                    pFirst = FindData.cFileName;
                ReturnLen += Length;
                if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszLongPath))
                    {
                    RtlMoveMemory(pDst, pFirst, Length * sizeof(WCHAR));
                    pDst += Length;
                    }
                }
            else {
                // invalid path, reset the length, mark the error and
                // bail out of the loop. We will be copying the source
                // to destination later.
                //
                ReturnLen = 0;
                break;
                }
            pSrc = pLast;
            if (*pSrc == UNICODE_NULL)
                break;
            } while (FindLFNorSFN_U(pSrc, &pFirst, &pLast, FALSE));

        if (ReturnLen) {
            //copy the rest of the path from pSrc. This may only contain
            //a single NULL char
            Length = wcslen(pSrc);
            ReturnLen += Length;
            if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszLongPath))
                {
                RtlMoveMemory(pDst, pSrc, (Length + 1) * sizeof(WCHAR));
                if (Buffer)
                    RtlMoveMemory(lpszLongPath, Buffer, (ReturnLen + 1) * sizeof(WCHAR));
                }
            else
                ReturnLen++;
            }

glnTryExit:
        ;
        }
        finally {
            if (pSrcCopy)
                RtlFreeHeap(RtlProcessHeap(), 0, pSrcCopy);
            if (Buffer)
                RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
            }

    // restore error mode.
    SetErrorMode(PrevErrorMode);
    return ReturnLen;
}

/**
    Search for SFN(Short File Name) or LFN(Long File Name) in the
    given path depends on FindLFN.

    Input: LPWSTR Path
                The given path name. Does not have to be fully qualified.
                However, path type separaters are not allowed.
           LPWSTR* ppFirst
                To return the pointer points to the first char
                of the name found.
           LPWSTR* ppLast
                To return the pointer points the char right after
                the last char of the name found.
           BOOL FindLFN
                TRUE to search for LFN, otherwise, search for SFN

    Output:
            TRUE
                if the target file name type is found, ppFirst and
                ppLast are filled with pointers.
            FALSE
                if the target file name type not found.

    Remark: "\\." and "\\.." are special cases. When encountered, they
            are ignored and the function continue to search


**/
BOOL
FindLFNorSFN_U(
    LPWSTR  Path,
    LPWSTR* ppFirst,
    LPWSTR* ppLast,
    BOOL    FindLFN
    )
{
    LPWSTR pFirst, pLast;
    BOOL TargetFound;

    ASSERT(Path);

    pFirst = Path;

    TargetFound = FALSE;

    while(TRUE) {
        //skip over leading path separator
        // it is legal to have multiple path separators in between
        // name such as "foobar\\\\\\multiplepathchar"
        while (*pFirst != UNICODE_NULL  && (*pFirst == L'\\' || *pFirst == L'/'))
            pFirst++;
        if (*pFirst == UNICODE_NULL)
            break;
        pLast = pFirst + 1;
        while (*pLast != UNICODE_NULL && *pLast != L'\\' && *pLast != L'/')
            pLast++;
        if (FindLFN)
            TargetFound = !IsShortName_U(pFirst, (int)(pLast - pFirst));
        else
            TargetFound = !IsLongName_U(pFirst, (int)(pLast - pFirst));
        if (TargetFound) {
            if(ppFirst && ppLast) {
                *ppFirst = pFirst;
                // pLast point to the last char of the path/file name
                *ppLast = pLast;
                }
            break;
            }
        if (*pLast == UNICODE_NULL)
            break;
        pFirst = pLast + 1;
        }
    return TargetFound;
}
LPCWSTR
SkipPathTypeIndicator_U(
    LPCWSTR Path
    )
{
    RTL_PATH_TYPE   RtlPathType;
    LPCWSTR         pFirst;
    DWORD           Count;

    RtlPathType = RtlDetermineDosPathNameType_U(Path);
    switch (RtlPathType) {
        // form: "\\server_name\share_name\rest_of_the_path"
        case RtlPathTypeUncAbsolute:
        case RtlPathTypeLocalDevice:
            pFirst = Path + 2;
            Count = 2;
            // guard for UNICODE_NULL is necessary because
            // RtlDetermineDosPathNameType_U doesn't really
            // verify an UNC name.
            while (Count && *pFirst != UNICODE_NULL) {
                if (*pFirst == L'\\' || *pFirst == L'/')
                    Count--;
                pFirst++;
                }
            break;

        // form: "\\."
        case RtlPathTypeRootLocalDevice:
            pFirst = NULL;
            break;

        // form: "D:\rest_of_the_path"
        case RtlPathTypeDriveAbsolute:
            pFirst = Path + 3;
            break;

        // form: "D:rest_of_the_path"
        case RtlPathTypeDriveRelative:
            pFirst = Path + 2;
            break;

        // form: "\rest_of_the_path"
        case RtlPathTypeRooted:
            pFirst = Path + 1;
            break;

        // form: "rest_of_the_path"
        case RtlPathTypeRelative:
            pFirst = Path;
            break;

        default:
            pFirst = NULL;
            break;
        }
    return pFirst;
}

/**
    This function determines if the given name is a valid short name.
    This function only does "obvious" testing since there are not precise
    ways to cover all the file systems(each file system has its own
    file name domain(for example, FAT allows all extended chars and space char
    while NTFS **may** not).
    The main purpose is to help the caller decide if a long to short name
    conversion is necessary. When in doubt, this function simply tells the
    caller that the given name is NOT a short name so that caller would
    do whatever it takes to convert the name.
    This function applies strict rules in deciding if the given name
    is a valid short name. For example, a name containing any extended chars
    is treated as invalid; a name with embedded space chars is also treated
    as invalid.
    A name is a valid short name if ALL the following conditions are met:
    (1). total length <= 13.
    (2). 0 < base name length <= 8.
    (3). extention name length <= 3.
    (4). only one '.' is allowed and must not be the first char.
    (5). every char must be legal defined by the IllegalMask array.

    null path, "." and ".." are treated valid.

    Input: LPCWSTR Name -  points to the name to be checked. It does not
                           have to be NULL terminated.

           int Length - Length of the name, not including teminated NULL char.

    output: TRUE - if the given name is a short file name.
            FALSE - if the given name is not a short file name
**/

// bit set -> char is illegal
DWORD   IllegalMask[] =

{
    // code 0x00 - 0x1F --> all illegal
    0xFFFFFFFF,
    // code 0x20 - 0x3f --> 0x20,0x22,0x2A-0x2C,0x2F and 0x3A-0x3F are illegal
    0xFC009C05,
    // code 0x40 - 0x5F --> 0x5B-0x5D are illegal
    0x38000000,
    // code 0x60 - 0x7F --> 0x7C is illegal
    0x10000000
};

BOOL
IsShortName_U(
    LPCWSTR Name,
    int     Length
    )
{
    int Index;
    BOOL ExtensionFound;
    DWORD      dwStatus;
    UNICODE_STRING UnicodeName;
    ANSI_STRING AnsiString;
    UCHAR      AnsiBuffer[MAX_PATH];
    UCHAR      Char;

    ASSERT(Name);

    // total length must less than 13(8.3 = 8 + 1 + 3 = 12)
    if (Length > 12)
        return FALSE;
    //  "" or "." or ".."
    if (!Length)
        return TRUE;
    if (L'.' == *Name)
    {
        // "." or ".."
        if (1 == Length || (2 == Length && L'.' == Name[1]))
            return TRUE;
        else
            // '.' can not be the first char(base name length is 0)
            return FALSE;
    }

    UnicodeName.Buffer = (LPWSTR)Name;
    UnicodeName.Length =
    UnicodeName.MaximumLength = (USHORT)(Length * sizeof(WCHAR));

    AnsiString.Buffer = AnsiBuffer;
    AnsiString.Length = 0;
    AnsiString.MaximumLength = MAX_PATH; // make a dangerous assumption

    dwStatus = BasepUnicodeStringTo8BitString(&AnsiString,
                                              &UnicodeName,
                                              FALSE);
    if (! NT_SUCCESS(dwStatus)) {
         return(FALSE);
    }

    // all trivial cases are tested, now we have to walk through the name
    ExtensionFound = FALSE;
    for (Index = 0; Index < AnsiString.Length; Index++)
    {
        Char = AnsiString.Buffer[Index];

        // Skip over and Dbcs characters
        if (IsDBCSLeadByte(Char)) {
            //
            //  1) if we're looking at base part ( !ExtensionPresent ) and the 8th byte
            //     is in the dbcs leading byte range, it's error ( Index == 7 ). If the
            //     length of base part is more than 8 ( Index > 7 ), it's definitely error.
            //
            //  2) if the last byte ( Index == DbcsName.Length - 1 ) is in the dbcs leading
            //     byte range, it's error
            //
            if ((!ExtensionFound && (Index >= 7)) ||
                (Index == AnsiString.Length - 1)) {
                return FALSE;
            }
            Index += 1;
            continue;
        }

        // make sure the char is legal
        if (Char > 0x7F || IllegalMask[Char / 32] & (1 << (Char % 32)))
            return FALSE;

        if ('.' == Char)
        {
            // (1) can have only one '.'
            // (2) can not have more than 3 chars following.
            if (ExtensionFound || Length - (Index + 1) > 3)
            {
                return FALSE;
            }
            ExtensionFound = TRUE;
        }
        // base length > 8 chars
        if (Index >= 8 && !ExtensionFound)
            return FALSE;
    }
    return TRUE;

}

/**
    This function determines if the given name is a valid long name.
    This function only does "obvious" testing since there are not precise
    ways to cover all the file systems(each file system has its own
    file name domain(for example, FAT allows all extended chars and space char
    while NTFS **may** not)
    This function helps the caller to determine if a short to long name
    conversion is necessary. When in doubt, this function simply tells the
    caller that the given name is NOT a long name so that caller would
    do whatever it takes to convert the name.
    A name is a valid long name if one of the following conditions is met:
    (1). total length >= 13.
    (2). 0 == base name length ||  base name length > 8.
    (3). extention name length > 3.
    (4). '.' is the first char.
    (5). muitlple '.'


    null path, "." and ".." are treat as valid long name.

    Input: LPCWSTR Name -  points to the name to be checked. It does not
                           have to be NULL terminated.

           int Length - Length of the name, not including teminated NULL char.

    output: TRUE - if the given name is a long file name.
            FALSE - if the given name is not a long file name
**/


BOOL
IsLongName_U(
    LPCWSTR Name,
    int Length
    )
{
    int Index;
    BOOL ExtensionFound;
    // (1) NULL path
    // (2) total length > 12
    // (3) . is the first char (cover "." and "..")
    if (!Length || Length > 12 || L'.' == *Name)
        return TRUE;
    ExtensionFound = FALSE;
    for (Index = 0; Index < Length; Index++)
    {
        if (L'.' == Name[Index])
        {
            // multiple . or extension longer than 3
            if (ExtensionFound || Length - (Index + 1) > 3)
                return TRUE;
            ExtensionFound = TRUE;
        }
        // base length longer than 8
        if (Index >= 8 && !ExtensionFound)
            return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\winlinks.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    winlink.c

Abstract:

    This module implements Win32 CreateHardLink

Author:

    Felipe Cabrera (cabrera) 28-Feb-1997

Revision History:

--*/

#include "basedll.h"

BOOL
APIENTRY
CreateHardLinkA(
    LPCSTR lpLinkName,
    LPCSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    ANSI thunk to CreateHardLinkW

--*/

{
    PUNICODE_STRING Unicode;
    UNICODE_STRING UnicodeExistingFileName;
    BOOL ReturnValue;

    Unicode = Basep8BitStringToStaticUnicodeString( lpLinkName );
    if (Unicode == NULL) {
        return FALSE;
    }
    
    if ( ARGUMENT_PRESENT(lpExistingFileName) ) {
        if (!Basep8BitStringToDynamicUnicodeString( &UnicodeExistingFileName, lpExistingFileName )) {
            return FALSE;
            }
        }
    else {
        UnicodeExistingFileName.Buffer = NULL;
        }

    ReturnValue = CreateHardLinkW((LPCWSTR)Unicode->Buffer, (LPCWSTR)UnicodeExistingFileName.Buffer, lpSecurityAttributes);

    RtlFreeUnicodeString(&UnicodeExistingFileName);

    return ReturnValue;
}


BOOL
APIENTRY
CreateHardLinkW(
    LPCWSTR lpLinkName,
    LPCWSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A file can be made to be a hard link to an existing file.
    The existing file can be a reparse point or not.

Arguments:

    lpLinkName - Supplies the name of a file that is to be to be made a hard link. As
        this is to be a new hard link, there should be no file or directory present
        with this name.

    lpExistingFileName - Supplies the name of an existing file that is the target for
        the hard link.
        
    lpSecurityAttributes - this is currently not used

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    UNICODE_STRING OldFileName;
    UNICODE_STRING NewFileName;
    PVOID FreeBuffer;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_LINK_INFORMATION NewName;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOLEAN ReturnValue = FALSE;

    //
    // Check to see that both names are present.
    //

    if ( !ARGUMENT_PRESENT(lpLinkName) ||
         !ARGUMENT_PRESENT(lpExistingFileName) ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    OldFileName.Buffer = NULL;
    NewFileName.Buffer = NULL;

    try {
        
        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpExistingFileName,
                                &OldFileName,
                                NULL,
                                NULL
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            __leave;
        }

        //
        // Initialize the object name.
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &OldFileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        //
        // Account the inheritance of the security descriptor. Note: this argument has no effect currently
        //

        if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
            ObjectAttributes.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        }

        //
        // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior.
        // Thus, the hard link is established to the local entity, be it a reparse
        // point or not.
        //

        Status = NtOpenFile(
                     &FileHandle,
                     FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                     &ObjectAttributes,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     FILE_FLAG_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT
                     );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            __leave;
        }

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpLinkName,
                                &NewFileName,
                                NULL,
                                NULL
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            __leave;
        }

        NewName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), NewFileName.Length+sizeof(*NewName));

        if ( NewName == NULL ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        RtlMoveMemory(NewName->FileName, NewFileName.Buffer, NewFileName.Length);
        NewName->ReplaceIfExists = FALSE;
        NewName->RootDirectory = NULL;
        NewName->FileNameLength = NewFileName.Length;

        Status = NtSetInformationFile(
                     FileHandle,
                     &IoStatusBlock,
                     NewName,
                     NewFileName.Length+sizeof(*NewName),
                     FileLinkInformation
                     );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            __leave;
        }
            
        ReturnValue = TRUE;
    
    } finally {

        //
        // Cleanup allocate memory and handles
        //  

        if (FileHandle != INVALID_HANDLE_VALUE) {
            NtClose( FileHandle );
        }

        if (NewFileName.Buffer != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, NewFileName.Buffer);
        }
        
        if (OldFileName.Buffer != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, OldFileName.Buffer);
        }
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\vdm.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdm.h

Abstract:

    This module contains MVDM related interface prototypes

Author:

    Sudeep Bharati (sudeepb) 04-Jan-1992

Revision History:

--*/


BOOL
BaseGetVdmConfigInfo(
    IN  LPCWSTR CommandLine,
    IN  ULONG  DosSeqId,
    IN  ULONG  BinaryType,
    IN  PUNICODE_STRING CmdLineString,
    OUT PULONG VdmSize
    );

ULONG
BaseIsDosApplication(
    IN PUNICODE_STRING PathName,
    IN NTSTATUS Status
    );

BOOL
BaseUpdateVDMEntry(
    IN ULONG UpdateIndex,
    IN OUT HANDLE *WaitHandle,
    IN ULONG IndexInfo,
    IN ULONG BinaryType
    );

BOOL
BaseCheckVDM(
    IN	ULONG BinaryType,
    IN	PCWCH lpApplicationName,
    IN	PCWCH lpCommandLine,
    IN  PCWCH lpCurrentDirectory,
    IN	ANSI_STRING *pAnsiStringEnv,
    IN	PBASE_API_MSG m,
    IN OUT PULONG iTask,
    IN	DWORD dwCreationFlags,
    LPSTARTUPINFOW lpStartupInfo
    );

VOID
BaseCloseStandardHandle(
    IN PVDMINFO pVDMInfo
    );

BOOL
BaseGetVDMKeyword(
    LPWSTR  KeywordLine,
    LPSTR   KeywordLineValue,
    LPDWORD KeywordLineSize,
    LPWSTR  KeywordSize,
    LPDWORD VdmSize
    );

BOOL
BaseCheckForVDM(
    IN HANDLE hProcess,
    OUT LPDWORD lpExitCode
    );

BOOL
GetVDMConfigValue(
    HANDLE hKey,
    LPWSTR Keyword,
    LPWSTR UnicodeBuffer
    );

BOOL
BaseCreateVDMEnvironment(
    LPWSTR  lpEnvironment,
    ANSI_STRING *pAStringEnv,
    UNICODE_STRING *pUStringEnv
    );
BOOL
BaseDestroyVDMEnvironment(
    ANSI_STRING *pAStringEnv,
    UNICODE_STRING *pUStringEnv
);

UINT
BaseGetEnvNameType_U(
    WCHAR   * Name,
    DWORD   NameLength
);


LPCWSTR
SkipPathTypeIndicator_U(
    LPCWSTR Path
    );

BOOL
FindLFNorSFN_U(
    LPWSTR  Path,
    LPWSTR* ppFirst,
    LPWSTR* ppLast,
    BOOL    FindLFN
    );
BOOL
IsShortName_U(
    LPCWSTR Name,
    int     Length
    );
BOOL
IsLongName_U(
    LPCWSTR Name,
    int     Length
    );

#define MAX_VDM_NESTING 8

#define DEFAULT_ENV_LENGTH 256

#define MAX_VDM_CFG_LINE   256

#define FULL_INFO_BUFFER_SIZE (sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_VDM_CFG_LINE)


#define WOW_ROOT \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\WOW"

#define CMDLINE    L"cmdline"
#define DOSSIZE    L"size"
#define WOWCMDLINE L"wowcmdline"
#define WOWSIZE    L"wowsize"

#define CHECKDOSCONSOLE 0
#define CHECKWOWCONSOLE 1
#define ASSUMENOCONSOLE 2


extern HANDLE	hVDM[];


#define STD_ENV_NAME_COUNT	    5

// Define environment variables we need to convert their values to
// short path name in BaseCreateVdmEnvironment function.
#define ENV_NAME_PATH		L"PATH"
#define ENV_NAME_PATH_LEN	4

#define ENV_NAME_WINDIR 	L"WINDIR"
#define ENV_NAME_WINDIR_LEN	6

#define ENV_NAME_SYSTEMROOT	L"SYSTEMROOT"
#define ENV_NAME_SYSTEMROOT_LEN 10

#define ENV_NAME_TEMP		L"TEMP"
#define ENV_NAME_TEMP_LEN	4

#define ENV_NAME_TMP		L"TMP"
#define ENV_NAME_TMP_LEN	3


// ENV_NAME_TYPE
#define ENV_NAME_TYPE_NO_PATH		1
#define ENV_NAME_TYPE_SINGLE_PATH	2
#define ENV_NAME_TYPE_MULTIPLE_PATH	3

typedef struct	_ENV_INFO {
    UINT    NameType;
    UINT    NameLength;
    WCHAR   *Name;
} ENV_INFO, * PENV_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\updrsrc.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    updres.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define DPrintf(a)
#define DPrintfn(a)
#define DPrintfu(a)

#define cbPadMax    16L

#define	DEFAULT_CODEPAGE	1252
#define	MAJOR_RESOURCE_VERSION	4
#define	MINOR_RESOURCE_VERSION	0

#define BUTTONCODE	0x80
#define EDITCODE	0x81
#define STATICCODE	0x82
#define LISTBOXCODE	0x83
#define SCROLLBARCODE	0x84
#define COMBOBOXCODE	0x85

#define	SEEK_SET	0
#define	SEEK_CUR	1
#define	SEEK_END	2
#define	MAXSTR		(256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//

#define ID_WORD 0xffff

//typedef	WCHAR	*PWCHAR;

typedef struct MY_STRING {
	ULONG discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct MY_STRING *pnext;
		  ULONG  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  *sz;
		} ss;
		WORD     Ordinal;
	} uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz

typedef struct _RESNAME {
        struct _RESNAME *pnext;	// The first three fields should be the
        PSDATA Name;		// same in both res structures
        ULONG   OffsetToData;

        PSDATA	Type;
	ULONG	SectionNumber;
        ULONG	DataSize;
        ULONG_PTR   OffsetToDataEntry;
        USHORT  ResourceNumber;
        USHORT  NumberOfLanguages;
        WORD	LanguageId;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
        struct _RESTYPE *pnext;	// The first three fields should be the
        PSDATA Type;		// same in both res structures
        ULONG   OffsetToData;

        struct _RESNAME *NameHeadID;
        struct _RESNAME *NameHeadName;
        ULONG  NumberOfNamesID;
        ULONG  NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;

typedef struct _UPDATEDATA {
        ULONG	cbStringTable;
        PSDATA	StringHead;
        PRESNAME	ResHead;
        PRESTYPE	ResTypeHeadID;
        PRESTYPE	ResTypeHeadName;
        LONG	Status;
        HANDLE	hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG		(sizeof(LONG))
#define BUFSIZE		(4L * 1024L)

/* functions for adding/deleting resources to update list */

LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG  cb
    );

PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    );

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fName,
    INT cb,
    PVOID lpData
    );

BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fType,
    INT	fName
    );

/* Prototypes for Enumeration done in BeginUpdateResource */

BOOL
EnumTypesFunc(
    HANDLE hModule,
    LPWSTR lpType,
    LPARAM lParam
    );

BOOL
EnumNamesFunc(
    HANDLE hModule,
    LPWSTR lpName,
    LPWSTR lpType,
    LPARAM lParam
    );

BOOL
EnumLangsFunc(
    HANDLE hModule,
    LPWSTR lpType,
    LPWSTR lpName,
    WORD languages,
    LPARAM lParam
    );

/* Prototypes for genral worker functions in updres.c */

LONG
WriteResFile(
    IN HANDLE	hUpdate,
    IN WCHAR	*pDstname
    );

VOID
FreeData(
    PUPDATEDATA pUpd
    );

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME pResSave
    );

//
// Template for patch debug information function.
//

template<class NT_HEADER_TYPE>
LONG
PatchDebug(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER pDebugOld,
    PIMAGE_SECTION_HEADER pDebugNew,
    PIMAGE_SECTION_HEADER pDebugDirOld,
    PIMAGE_SECTION_HEADER pDebugDirNew,
    NT_HEADER_TYPE *pOld,
    NT_HEADER_TYPE *pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData
    )

{

    PIMAGE_DEBUG_DIRECTORY pDbgLast;
    PIMAGE_DEBUG_DIRECTORY pDbgSave;
    PIMAGE_DEBUG_DIRECTORY pDbg;
    ULONG       ib;
    ULONG       adjust;
    ULONG       ibNew;

    if (pDebugDirOld == NULL || pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size==0)
        return NO_ERROR;

    pDbgSave = pDbg = (PIMAGE_DEBUG_DIRECTORY)RtlAllocateHeap(
                                                             RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                                                             pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    if (pDbg == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    if (pDebugOld) {
        DPrintf((DebugBuf, "Patching dbg directory: @%#08lx ==> @%#08lx\n",
                 pDebugOld->PointerToRawData, pDebugNew->PointerToRawData));
    } else
        adjust = *pPointerToRawData;    /* passed in EOF of new file */

    ib = pOld->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress - pDebugDirOld->VirtualAddress;
    MuMoveFilePos(inpfh, pDebugDirOld->PointerToRawData+ib);
    pDbgLast = pDbg + (pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size)/sizeof(IMAGE_DEBUG_DIRECTORY);
    MuRead(inpfh, (PUCHAR)pDbg, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

    if (pDebugOld == NULL) {
        /* find 1st entry - use for offset */
        DPrintf((DebugBuf, "Adjust: %#08lx\n",adjust));
        for (ibNew=0xffffffff ; pDbg<pDbgLast ; pDbg++)
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld &&
                pDbg->PointerToRawData < ibNew
               )
                ibNew = pDbg->PointerToRawData;

        if (ibNew != 0xffffffff)
            *pPointerToRawData = ibNew;
        else
            *pPointerToRawData = _llseek(inpfh, 0L, SEEK_END);
        for (pDbg=pDbgSave ; pDbg<pDbgLast ; pDbg++) {
            DPrintf((DebugBuf, "Old debug file offset: %#08lx\n",
                     pDbg->PointerToRawData));
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld)
                pDbg->PointerToRawData += adjust - ibNew;
            DPrintf((DebugBuf, "New debug file offset: %#08lx\n",
                     pDbg->PointerToRawData));
        }
    } else {
        for ( ; pDbg<pDbgLast ; pDbg++) {
            DPrintf((DebugBuf, "Old debug addr: %#08lx, file offset: %#08lx\n",
                     pDbg->AddressOfRawData,
                     pDbg->PointerToRawData));
            pDbg->AddressOfRawData += pDebugNew->VirtualAddress -
                                      pDebugOld->VirtualAddress;
            pDbg->PointerToRawData += pDebugNew->PointerToRawData -
                                      pDebugOld->PointerToRawData;
            DPrintf((DebugBuf, "New debug addr: %#08lx, file offset: %#08lx\n",
                     pDbg->AddressOfRawData,
                     pDbg->PointerToRawData));
        }
    }

    MuMoveFilePos(outfh, pDebugDirNew->PointerToRawData+ib);
    MuWrite(outfh, (PUCHAR)pDbgSave, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    RtlFreeHeap(RtlProcessHeap(), 0, pDbgSave);

    return NO_ERROR;
}

//
// Template for patch debug information function.
//

template<class NT_HEADER_TYPE>
LONG
PatchRVAs(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    NT_HEADER_TYPE *pNew,
    ULONG OldSize
    )

{
    ULONG hdrdelta;
    ULONG offset, rvaiat, offiat, iat;
    IMAGE_EXPORT_DIRECTORY Exp;
    IMAGE_IMPORT_DESCRIPTOR Imp;
    ULONG i, cmod, cimp;

    hdrdelta = pNew->OptionalHeader.SizeOfHeaders - OldSize;
    if (hdrdelta == 0) {
        return NO_ERROR;
    }

    //
    // Patch export section RVAs
    //

    DPrintf((DebugBuf, "Export offset=%08lx, hdrsize=%08lx\n",
             pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,
             pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0) {
        DPrintf((DebugBuf, "No exports to patch\n"));
    } else if (offset >= pNew->OptionalHeader.SizeOfHeaders) {
        DPrintf((DebugBuf, "No exports in header to patch\n"));
    } else {
        MuMoveFilePos(inpfh, offset - hdrdelta);
        MuRead(inpfh, (PUCHAR) &Exp, sizeof(Exp));
        Exp.Name += hdrdelta;
        (ULONG)Exp.AddressOfFunctions += hdrdelta;
        (ULONG)Exp.AddressOfNames += hdrdelta;
        (ULONG)Exp.AddressOfNameOrdinals += hdrdelta;
        MuMoveFilePos(outfh, offset);
        MuWrite(outfh, (PUCHAR) &Exp, sizeof(Exp));
    }

    //
    // Patch import section RVAs
    //

    DPrintf((DebugBuf, "Import offset=%08lx, hdrsize=%08lx\n",
             pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
             pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) == 0) {
        DPrintf((DebugBuf, "No imports to patch\n"));
    } else if (offset >= pNew->OptionalHeader.SizeOfHeaders) {
        DPrintf((DebugBuf, "No imports in header to patch\n"));
    } else {
        for (cimp = cmod = 0; ; cmod++) {
            MuMoveFilePos(inpfh, offset + cmod * sizeof(Imp) - hdrdelta);
            MuRead(inpfh, (PUCHAR) &Imp, sizeof(Imp));
            if (Imp.FirstThunk == 0) {
                break;
            }
            Imp.Name += hdrdelta;
            MuMoveFilePos(outfh, offset + cmod * sizeof(Imp));
            MuWrite(outfh, (PUCHAR) &Imp, sizeof(Imp));

            rvaiat = (ULONG)Imp.FirstThunk;
            DPrintf((DebugBuf, "RVAIAT = %#08lx\n", (ULONG)rvaiat));
            for (i = 0; i < pNew->FileHeader.NumberOfSections; i++) {
                if (rvaiat >= po32[i].VirtualAddress &&
                    rvaiat < po32[i].VirtualAddress + po32[i].SizeOfRawData) {

                    offiat = rvaiat - po32[i].VirtualAddress + po32[i].PointerToRawData;
                    goto found;
                }
            }
            DPrintf((DebugBuf, "IAT not found\n"));
            return ERROR_INVALID_DATA;
            found:
            DPrintf((DebugBuf, "IAT offset: @%#08lx ==> @%#08lx\n",
                     offiat - pagedelta,
                     offiat));
            MuMoveFilePos(inpfh, offiat - pagedelta);
            MuMoveFilePos(outfh, offiat);
            for (;;) {
                MuRead(inpfh, (PUCHAR) &iat, sizeof(iat));
                if (iat == 0) {
                    break;
                }
                if ((iat & IMAGE_ORDINAL_FLAG) == 0) {  // if import by name
                    DPrintf((DebugBuf, "Patching IAT: %08lx + %04lx ==> %08lx\n",
                             iat,
                             hdrdelta,
                             iat + hdrdelta));
                    iat += hdrdelta;
                    cimp++;
                }
                MuWrite(outfh, (PUCHAR) &iat, sizeof(iat)); // Avoids seeking
            }
        }
        DPrintf((DebugBuf, "%u import module name RVAs patched\n", cmod));
        DPrintf((DebugBuf, "%u IAT name RVAs patched\n", cimp));
        if (cmod == 0) {
            DPrintf((DebugBuf, "No import modules to patch\n"));
        }
        if (cimp == 0) {
            DPrintf((DebugBuf, "No import name RVAs to patch\n"));
        }
    }

    return NO_ERROR;
}

//
// Template for write resource function.
//

template<class NT_HEADER_TYPE>
LONG
PEWriteResource(
    INT inpfh,
    INT outfh,
    ULONG cbOldexe,
    PUPDATEDATA pUpdate,
    NT_HEADER_TYPE *NtHeader
    )

{

    NT_HEADER_TYPE Old;         /* original header */
    NT_HEADER_TYPE New;         /* working header */
    PRESNAME    pRes;
    PRESNAME    pResSave;
    PRESTYPE    pType;
    ULONG       clock = 0;
    ULONG       cbName=0;       /* count of bytes in name strings */
    ULONG       cbType=0;       /* count of bytes in type strings */
    ULONG       cTypeStr=0;     /* count of strings */
    ULONG       cNameStr=0;     /* count of strings */
    LONG        cb;             /* temp byte count and file index */
    ULONG       cTypes = 0L;    /* count of resource types      */
    ULONG       cNames = 0L;    /* Count of names for multiple languages/name */
    ULONG       cRes = 0L;      /* count of resources      */
    ULONG       cbRestab;       /* count of resources      */
    LONG        cbNew = 0L;     /* general count */
    ULONG       ibObjTab;
    ULONG       ibObjTabEnd;
    ULONG       ibNewObjTabEnd;
    ULONG       ibSave;
    ULONG       adjust=0;
    PIMAGE_SECTION_HEADER pObjtblOld,
    pObjtblNew,
    pObjDebug,
    pObjResourceOld,
    pObjResourceNew,
    pObjResourceOldX,
    pObjDebugDirOld,
    pObjDebugDirNew,
    pObjNew,
    pObjOld,
    pObjLast;
    PUCHAR      p;
    PIMAGE_RESOURCE_DIRECTORY   pResTab;
    PIMAGE_RESOURCE_DIRECTORY   pResTabN;
    PIMAGE_RESOURCE_DIRECTORY   pResTabL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY     pResDirL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY     pResDirN;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY     pResDirT;
    PIMAGE_RESOURCE_DATA_ENTRY  pResData;
    PUSHORT     pResStr;
    PUSHORT     pResStrEnd;
    PSDATA      pPreviousName;
    LONG        nObjResource=-1;
    LONG        nObjResourceX=-1;
    ULONG       cbResource;
    ULONG       cbMustPad = 0;
    ULONG       ibMaxDbgOffsetOld;

    MuMoveFilePos(inpfh, cbOldexe);
    MuRead(inpfh, (PUCHAR)&Old, sizeof(NT_HEADER_TYPE));
    ibObjTab = cbOldexe + sizeof(NT_HEADER_TYPE);

    ibObjTabEnd = ibObjTab + Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    ibNewObjTabEnd = ibObjTabEnd;

    DPrintfn((DebugBuf, "\n"));

    /* New header is like old one.                  */
    RtlCopyMemory(&New, &Old, sizeof(NT_HEADER_TYPE));

    /* Read section table */
    pObjtblOld = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                                                        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    if (pObjtblOld == NULL) {
        cb = ERROR_NOT_ENOUGH_MEMORY;
        goto AbortExit;
    }

    RtlZeroMemory((PVOID)pObjtblOld, Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER));
    DPrintf((DebugBuf, "Old section table: %#08lx bytes at %#08lx(mem)\n",
             Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
             pObjtblOld));
    MuMoveFilePos(inpfh, ibObjTab);
    MuRead(inpfh, (PUCHAR)pObjtblOld,
           Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    pObjLast = pObjtblOld + Old.FileHeader.NumberOfSections;
    ibMaxDbgOffsetOld = 0;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
        if (pObjOld->PointerToRawData > ibMaxDbgOffsetOld) {
            ibMaxDbgOffsetOld = pObjOld->PointerToRawData + pObjOld->SizeOfRawData;
        }
    }
    DPrintf((DebugBuf, "Maximum debug offset in old file: %08x\n", ibMaxDbgOffsetOld ));

    /*
     * First, count up the resources.  We need this information
     * to discover how much room for header information to allocate
     * in the resource section.  cRes tells us how
     * many language directory entries/tables.  cNames and cTypes
     * is used for the respective tables and/or entries.  cbName totals
     * the bytes required to store the alpha names (including the leading
     * length word).  cNameStr counts these strings.
     */
    DPrintf((DebugBuf, "Beginning loop to count resources\n"));

    /* first, count those in the named type list */
    cbResource = 0;
    //DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
            //DPrintf((DebugBuf, "Resource type "));
            //DPrintfu((pType->Type->szStr));
            //DPrintfn((DebugBuf, "\n"));
            cTypes++;
            cTypeStr++;
            cbType += (pType->Type->cbsz + 1) * sizeof(WORD);

            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
            pRes = pType->NameHeadName;
            while (pRes) {
                //DPrintf((DebugBuf, "Resource "));
                //DPrintfu((pRes->Name->szStr));
                //DPrintfn((DebugBuf, "\n"));
                cRes++;
                if (pPreviousName == NULL || wcscmp(pPreviousName->szStr, pRes->Name->szStr) != 0) {
                    cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
                    cNameStr++;
                    cNames++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
            pRes = pType->NameHeadID;
            while (pRes) {
                //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
                cRes++;
                if (pPreviousName == NULL ||
                    pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }
        }
        pType = pType->pnext;
    }

    /* second, count those in the ID type list */
    //DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
            //DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
            cTypes++;
            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
            pRes = pType->NameHeadName;
            while (pRes) {
                //DPrintf((DebugBuf, "Resource "));
                //DPrintfu((pRes->Name->szStr));
                //DPrintfn((DebugBuf, "\n"));
                cRes++;
                if (pPreviousName == NULL || wcscmp(pPreviousName->szStr, pRes->Name->szStr) != 0) {
                    cNames++;
                    cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
                    cNameStr++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
            pRes = pType->NameHeadID;
            while (pRes) {
                //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
                cRes++;
                if (pPreviousName == NULL || pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }
        }
        pType = pType->pnext;
    }
    cb = REMAINDER(cbName + cbType, CBLONG);

    /* Add up the number of bytes needed to store the directory.  There is
     * one type table with cTypes entries.  They point to cTypes name tables
     * that have a total of cNames entries.  Each of them points to a language
     * table and there are a total of cRes entries in all the language tables.
     * Finally, we have the space needed for the Directory string entries,
     * some extra padding to attain the desired alignment, and the space for
     * cRes data entry headers.
     */
    cbRestab =   sizeof(IMAGE_RESOURCE_DIRECTORY) +     /* root dir (types) */
                 cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
                 cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +     /* subdir2 (names) */
                 cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
                 cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +     /* subdir3 (langs) */
                 cRes   * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
                 (cbName + cbType) +                             /* name/type strings */
                 cb +                                            /* padding */
                 cRes   * sizeof(IMAGE_RESOURCE_DATA_ENTRY);     /* data entries */

    cbResource += cbRestab;             /* add in the resource table */

    // Find any current resource sections

    pObjResourceOld = FindSection(pObjtblOld, pObjLast, ".rsrc");
    pObjResourceOldX = FindSection(pObjtblOld, pObjLast, ".rsrc1");
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if ((pObjResourceOld == NULL)) {
        cb = 0x7fffffff;                /* can fill forever */
    } else if (pObjResourceOld + 1 == pObjResourceOldX) {
        nObjResource = (ULONG)(pObjResourceOld - pObjtblOld);
        DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
        DPrintf((DebugBuf,"Merging old Resource extra section #%lu\n", nObjResource+2));
        cb = 0x7fffffff;                /* merge resource sections */
    } else if ((pObjResourceOld + 1) >= pObjLast) {
        nObjResource = (ULONG)(pObjResourceOld - pObjtblOld);
        cb = 0x7fffffff;        /* can fill forever (.rsrc is the last entry) */
    } else {
        nObjResource = (ULONG)(pObjResourceOld - pObjtblOld);
        DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
        if (pObjOld) {
            cb = (pObjResourceOld+1)->VirtualAddress - pObjResourceOld->VirtualAddress;
        } else {
            cb = 0x7fffffff;
        }
        if (cbRestab > (ULONG)cb) {
            DPrintf((DebugBuf, "Resource Table Too Large\n"));
            return ERROR_INVALID_DATA;
        }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */

    if (pObjResourceOld != NULL && cbResource > (ULONG)cb) {
        if (pObjOld == pObjResourceOld + 1) {
            DPrintf((DebugBuf, "Large resource section  pushes .reloc\n"));
            cb = 0x7fffffff;            /* can fill forever */
        } else if (pObjResourceOldX == NULL) {
            DPrintf((DebugBuf, "Too much resource data for old .rsrc section\n"));
            nObjResourceX = (ULONG)(pObjOld - pObjtblOld);
            adjust = pObjOld->VirtualAddress - pObjResourceOld->VirtualAddress;
        } else {          /* have already merged .rsrc & .rsrc1, if possible */
            DPrintf((DebugBuf, ".rsrc1 section not empty\n"));
            nObjResourceX = (ULONG)(pObjResourceOldX - pObjtblOld);
            adjust = pObjResourceOldX->VirtualAddress - pObjResourceOld ->VirtualAddress;
        }
    }

    /*
     * Walk the type lists and figure out where the Data entry header will
     * go.  Keep a running total of the size for each data element so we
     * can store this in the section header.
     */
    DPrintf((DebugBuf, "Beginning loop to assign resources to addresses\n"));

    /* first, those in the named type list */

    cbResource = cbRestab;      /* assign resource table to 1st rsrc section */
                                /* adjust == offset to .rsrc1 */
                                /* cb == size availble in .rsrc */
    cbNew = 0;                  /* count of bytes in second .rsrc */
    DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
            DPrintf((DebugBuf, "Resource type "));
            DPrintfu((pType->Type->szStr));
            DPrintfn((DebugBuf, "\n"));
            pRes = pType->NameHeadName;
            while (pRes) {
                DPrintf((DebugBuf, "Resource "));
                DPrintfu((pRes->Name->szStr));
                DPrintfn((DebugBuf, "\n"));
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
            pRes = pType->NameHeadID;
            while (pRes) {
                DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
        }
        pType = pType->pnext;
    }

    /* then, count those in the ID type list */

    DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
            DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
            pRes = pType->NameHeadName;
            while (pRes) {
                DPrintf((DebugBuf, "Resource "));
                DPrintfu((pRes->Name->szStr));
                DPrintfn((DebugBuf, "\n"));
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
            pRes = pType->NameHeadID;
            while (pRes) {
                DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
        }
        pType = pType->pnext;
    }
    /*
     * At this point:
     * cbResource has offset of first byte past the last resource.
     * cbNew has the count of bytes in the first resource section,
     * if there are two sections.
     */
    if (cbNew == 0)
        cbNew = cbResource;

    /*
     * Discover where the Debug info is (if any)?
     */
    pObjDebug = FindSection(pObjtblOld, pObjLast, ".debug");
    if (pObjDebug != NULL) {
        if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress  == 0) {
            DPrintf((DebugBuf, ".debug section but no debug directory\n"));
            return ERROR_INVALID_DATA;
        }
        if (pObjDebug != pObjLast-1) {
            DPrintf((DebugBuf, "debug section not last section in file\n"));
            return ERROR_INVALID_DATA;
        }
        DPrintf((DebugBuf, "Debug section: %#08lx bytes @%#08lx\n",
                 pObjDebug->SizeOfRawData,
                 pObjDebug->PointerToRawData));
    }
    pObjDebugDirOld = NULL;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
        if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress >= pObjOld->VirtualAddress &&
            Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress < pObjOld->VirtualAddress+pObjOld->SizeOfRawData) {
            pObjDebugDirOld = pObjOld;
            break;
        }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (nObjResource == -1) {           /* no old resource section */
        if (pObjOld != NULL)
            nObjResource = (ULONG)(pObjOld - pObjtblOld);
        else if (pObjDebug != NULL)
            nObjResource = (ULONG)(pObjDebug - pObjtblOld);
        else
            nObjResource = New.FileHeader.NumberOfSections;
        New.FileHeader.NumberOfSections++;
    }

    DPrintf((DebugBuf, "Resources assigned to section #%lu\n", nObjResource+1));
    if (nObjResourceX != -1) {
        if (pObjResourceOldX != NULL) {
            nObjResourceX = (ULONG)(pObjResourceOldX - pObjtblOld);
            New.FileHeader.NumberOfSections--;
        } else if (pObjOld != NULL)
            nObjResourceX = (ULONG)(pObjOld - pObjtblOld);
        else if (pObjDebug != NULL)
            nObjResourceX = (ULONG)(pObjDebug - pObjtblOld);
        else
            nObjResourceX = New.FileHeader.NumberOfSections;
        New.FileHeader.NumberOfSections++;
        DPrintf((DebugBuf, "Extra resources assigned to section #%lu\n", nObjResourceX+1));
    } else if (pObjResourceOldX != NULL) {        /* Was old .rsrc1 section? */
        DPrintf((DebugBuf, "Extra resource section deleted\n"));
        New.FileHeader.NumberOfSections--;      /* yes, delete it */
    }

    /*
     * If we had to add anything to the header (section table),
     * then we have to update the header size and rva's in the header.
     */
    adjust = (New.FileHeader.NumberOfSections - Old.FileHeader.NumberOfSections) * sizeof(IMAGE_SECTION_HEADER);
    cb = Old.OptionalHeader.SizeOfHeaders -
         (Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER) +
          sizeof(NT_HEADER_TYPE) + cbOldexe );
    if (adjust > (ULONG)cb) {
        int i;

        adjust -= cb;
        DPrintf((DebugBuf, "Adjusting header RVAs by %#08lx\n", adjust));
        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++) {
            if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
                New.OptionalHeader.DataDirectory[i].VirtualAddress < New.OptionalHeader.SizeOfHeaders) {
                DPrintf((DebugBuf, "Adjusting unit[%s] RVA from %#08lx to %#08lx\n",
                         apszUnit[i],
                         New.OptionalHeader.DataDirectory[i].VirtualAddress,
                         New.OptionalHeader.DataDirectory[i].VirtualAddress + adjust));
                New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
            }
        }
        New.OptionalHeader.SizeOfHeaders += adjust;
    } else if (adjust > 0) {
        int i;

        //
        // Loop over DataDirectory entries and look for any entries that point to
        // information stored in the 'dead' space after the section table but before
        // the SizeOfHeaders length.
        //
        DPrintf((DebugBuf, "Checking header RVAs for 'dead' space usage\n"));
        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++) {
            if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
                New.OptionalHeader.DataDirectory[i].VirtualAddress < Old.OptionalHeader.SizeOfHeaders) {
                DPrintf((DebugBuf, "Adjusting unit[%s] RVA from %#08lx to %#08lx\n",
                         apszUnit[i],
                         New.OptionalHeader.DataDirectory[i].VirtualAddress,
                         New.OptionalHeader.DataDirectory[i].VirtualAddress + adjust));
                New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
            }
        }
    }
    ibNewObjTabEnd += adjust;

    /* Allocate storage for new section table                */
    cb = New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    pObjtblNew = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), (short)cb);
    if (pObjtblNew == NULL) {
        cb = ERROR_NOT_ENOUGH_MEMORY;
        goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblNew, cb);
    DPrintf((DebugBuf, "New section table: %#08lx bytes at %#08lx\n", cb, pObjtblNew));
    pObjResourceNew = pObjtblNew + nObjResource;

    /*
     * copy old section table to new
     */
    adjust = 0;                 /* adjustment to virtual address */
    for (pObjOld=pObjtblOld,pObjNew=pObjtblNew ; pObjOld<pObjLast ; pObjOld++) {
        if (pObjOld == pObjResourceOldX) {
            if (nObjResourceX == -1) {
                // we have to move back all the other section.
                // the .rsrc1 is bigger than what we need
                // adjust must be a negative number
                if (pObjOld+1 < pObjLast) {
                    adjust -= (pObjOld+1)->VirtualAddress - pObjOld->VirtualAddress;
                }
            }
            continue;
        } else if (pObjNew == pObjResourceNew) {
            DPrintf((DebugBuf, "Resource Section %i\n", nObjResource+1));
            cb = ROUNDUP(cbNew, New.OptionalHeader.FileAlignment);
            if (pObjResourceOld == NULL) {
                adjust = ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
                RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
                strcpy((char *)pObjNew->Name, ".rsrc");
                pObjNew->VirtualAddress = pObjOld->VirtualAddress;
                pObjNew->PointerToRawData = pObjOld->PointerToRawData;
                pObjNew->Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA;
                pObjNew->SizeOfRawData = cb;
                pObjNew->Misc.VirtualSize = cbNew;
            } else {
                *pObjNew = *pObjOld;    /* copy obj table entry */
                pObjNew->SizeOfRawData = cb;
                pObjNew->Misc.VirtualSize = cbNew;
                if (pObjNew->SizeOfRawData == pObjOld->SizeOfRawData) {
                    adjust = 0;
                } else if (pObjNew->SizeOfRawData > pObjOld->SizeOfRawData) {
                    adjust += ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
                    if (pObjOld+1 < pObjLast) {
                        // if there are more entries after pObjOld, shift those back as well 
                        adjust -= ((pObjOld+1)->VirtualAddress - pObjOld->VirtualAddress);
                    }
                } else {          /* is smaller, but pad so will be valid */
                    adjust = 0;
                    pObjNew->SizeOfRawData = pObjResourceOld->SizeOfRawData;
                    /* if legoized, the VS could be > RawSize !!! */
                    pObjNew->Misc.VirtualSize = pObjResourceOld->Misc.VirtualSize;
                    cbMustPad = pObjResourceOld->SizeOfRawData;
                }
            }
            pObjNew++;
            if (pObjResourceOld == NULL)
                goto rest_of_table;
        } else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {
            DPrintf((DebugBuf, "Additional Resource Section %i\n",
                     nObjResourceX+1));
            RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
            strcpy((char *)pObjNew->Name, ".rsrc1");
            /*
             * Before we copy the virtual address we have to move back the
             * .reloc * virtual address. Otherwise we will keep moving the
             * reloc VirtualAddress forward.
             * We will have to move back the address of .rsrc1
             */
            if (pObjResourceOldX == NULL) {
                // This is the first time we have a .rsrc1
                pObjNew->VirtualAddress = pObjOld->VirtualAddress;
                pObjNew->Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA;
                adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
                         pObjResourceNew->VirtualAddress - pObjNew->VirtualAddress;
                DPrintf((DebugBuf, "Added .rsrc1. VirtualAddress %lu\t adjust: %lu\n", pObjNew->VirtualAddress, adjust ));
            } else {
                // we already have an .rsrc1 use the position of that and
                // calculate the new adjust
                pObjNew->VirtualAddress = pObjResourceOldX->VirtualAddress;
                pObjNew->Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA;

                DPrintf((DebugBuf, ".rsrc1 Keep old position.\t\tVirtualAddress %lu\t", pObjNew->VirtualAddress ));
                // Check if we have enough room in the old .rsrc1
                // Include the full size of the section, data + roundup
                if (cbResource -
                    (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress) <=
                    pObjOld->VirtualAddress - pObjNew->VirtualAddress ) {
                    // we have to move back all the other section.
                    // the .rsrc1 is bigger than what we need
                    // adjust must be a negative number
                    // calc new adjust size
                    adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
                             pObjResourceNew->VirtualAddress -
                             pObjOld->VirtualAddress;
                    DPrintf((DebugBuf, "adjust: %ld\tsmall: New %lu\tOld %lu\n", adjust,
                             cbResource -
                             (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
                             pObjOld->VirtualAddress - pObjNew->VirtualAddress));
                } else {
                    // we have to move the section again.
                    // The .rsrc1 is too small

                    adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
                             pObjResourceNew->VirtualAddress -
                             pObjOld->VirtualAddress;
                    DPrintf((DebugBuf, "adjust: %lu\tsmall: New %lu\tOld %lu\n", adjust,
                             cbResource -
                             (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
                             pObjOld->VirtualAddress - pObjNew->VirtualAddress));
                }
            }
            pObjNew++;
            goto rest_of_table;
        } else if (pObjNew < pObjResourceNew) {
            DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
                     pObjOld - pObjtblOld + 1, pObjNew));
            *pObjNew++ = *pObjOld;              /* copy obj table entry */
        } else {
            rest_of_table:
            DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
                     pObjOld - pObjtblOld + 1, pObjNew));
            DPrintf((DebugBuf, "adjusting VirtualAddress by %#08lx\n", adjust));
            *pObjNew++ = *pObjOld;
            (pObjNew-1)->VirtualAddress += adjust;
        }
    }


    pObjNew = pObjtblNew + New.FileHeader.NumberOfSections - 1;
    New.OptionalHeader.SizeOfImage = ROUNDUP(pObjNew->VirtualAddress +
                                             pObjNew->SizeOfRawData,
                                             New.OptionalHeader.SectionAlignment);

    /* allocate room to build the resource directory/tables in */
    pResTab = (PIMAGE_RESOURCE_DIRECTORY)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cbRestab);
    if (pResTab == NULL) {
        cb = ERROR_NOT_ENOUGH_MEMORY;
        goto AbortExit;
    }

    /* First, setup the "root" type directory table.  It will be followed by */
    /* Types directory entries.                                              */

    RtlZeroMemory((PVOID)pResTab, cbRestab);
    DPrintf((DebugBuf, "resource directory tables: %#08lx bytes at %#08lx(mem)\n", cbRestab, pResTab));
    p = (PUCHAR)pResTab;
    SetRestab(pResTab, clock, (USHORT)cTypeStr, (USHORT)(cTypes - cTypeStr));

    /* Calculate the start of the various parts of the resource table.  */
    /* We need the start of the Type/Name/Language directories as well  */
    /* as the start of the UNICODE strings and the actual data nodes.   */

    pResDirT = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTab + 1);

    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirT) +
                                                 cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirN) +
                                                 cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +
                                                 cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResData = (PIMAGE_RESOURCE_DATA_ENTRY)(((PUCHAR)pResDirL) +
                                            cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +
                                            cRes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResStr  = (PUSHORT)(((PUCHAR)pResData) +
                         cRes * sizeof(IMAGE_RESOURCE_DATA_ENTRY));

    pResStrEnd = (PUSHORT)(((PUCHAR)pResStr) + cbName + cbType);

    /*
     * Loop over type table, building the PE resource table.
     */

    /*
     * *****************************************************************
     * This code doesn't sort the table - the TYPEINFO and RESINFO    **
     * insertion code in rcp.c (AddResType and SaveResFile) do the    **
     * insertion by ordinal type and name, so we don't have to sort   **
     * it at this point.                                              **
     * *****************************************************************
     */
    DPrintf((DebugBuf, "building resource directory\n"));

    // First, add all the entries in the Types: Alpha list.

    DPrintf((DebugBuf, "Walk the type: Alpha list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
        DPrintf((DebugBuf, "resource type "));
        DPrintfu((pType->Type->szStr));
        DPrintfn((DebugBuf, "\n"));

        pResDirT->Name = (ULONG)((((PUCHAR)pResStr) - p) |
                                 IMAGE_RESOURCE_NAME_IS_STRING);
        pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
                                         IMAGE_RESOURCE_DATA_IS_DIRECTORY);
        pResDirT++;

        *pResStr = pType->Type->cbsz;
        wcsncpy((WCHAR*)(pResStr+1), pType->Type->szStr, pType->Type->cbsz);
        pResStr += pType->Type->cbsz + 1;

        pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
        SetRestab(pResTabN, clock, (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
        pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

        pRes = pType->NameHeadName;
        while (pRes) {
            DPrintf((DebugBuf, "resource "));
            DPrintfu((pRes->Name->szStr));
            DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL || wcscmp(pPreviousName->szStr,pRes->Name->szStr) != 0) {
                // Setup a new name directory

                pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
                                         IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                                                 IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                // Copy the alpha name to a string entry

                *pResStr = pRes->Name->cbsz;
                wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
                pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
                       pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
                       pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pPreviousName = NULL;

        pRes = pType->NameHeadID;
        while (pRes) {
            DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL || pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

                pResDirN->Name = pRes->Name->uu.Ordinal;
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                                                 IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
                       pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
                       pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pType = pType->pnext;
    }

    //  Do the same thing, but this time, use the Types: ID list.

    DPrintf((DebugBuf, "Walk the type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType) {
        DPrintf((DebugBuf, "resource type %hu\n", pType->Type->uu.Ordinal));

        pResDirT->Name = (ULONG)pType->Type->uu.Ordinal;
        pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
                                         IMAGE_RESOURCE_DATA_IS_DIRECTORY);
        pResDirT++;

        pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
        SetRestab(pResTabN, clock, (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
        pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

        pRes = pType->NameHeadName;
        while (pRes) {
            DPrintf((DebugBuf, "resource "));
            DPrintfu((pRes->Name->szStr));
            DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL || wcscmp(pPreviousName->szStr,pRes->Name->szStr) != 0) {
                // Setup a new name directory

                pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
                                         IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                                                 IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                // Copy the alpha name to a string entry.

                *pResStr = pRes->Name->cbsz;
                wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
                pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
                       pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
                       pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pPreviousName = NULL;

        pRes = pType->NameHeadID;
        while (pRes) {
            DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL || pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

                pResDirN->Name = pRes->Name->uu.Ordinal;
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                                                 IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
                       pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
                       pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pType = pType->pnext;
    }
    DPrintf((DebugBuf, "Zeroing %u bytes after strings at %#08lx(mem)\n",
             (pResStrEnd - pResStr) * sizeof(*pResStr), pResStr));
    while (pResStr < pResStrEnd) {
        *pResStr++ = 0;
    }

#if DBG
    {
        USHORT  j = 0;
        PUSHORT pus = (PUSHORT)pResTab;

        while (pus < (PUSHORT)pResData) {
            DPrintf((DebugBuf, "%04x\t%04x %04x %04x %04x %04x %04x %04x %04x\n",
                     j,
                     *pus,
                     *(pus + 1),
                     *(pus + 2),
                     *(pus + 3),
                     *(pus + 4),
                     *(pus + 5),
                     *(pus + 6),
                     *(pus + 7)));
            pus += 8;
            j += 16;
        }
    }
#endif /* DBG */

    /*
     * copy the Old exe header and stub, and allocate room for the PE header.
     */
    DPrintf((DebugBuf, "copying through PE header: %#08lx bytes @0x0\n",
             cbOldexe + sizeof(NT_HEADER_TYPE)));
    MuMoveFilePos(inpfh, 0L);
    MuCopy(inpfh, outfh, cbOldexe + sizeof(NT_HEADER_TYPE));

    /*
     * Copy rest of file header
     */
    DPrintf((DebugBuf, "skipping section table: %#08lx bytes @%#08lx\n",
             New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
             FilePos(outfh)));
    DPrintf((DebugBuf, "copying hdr data: %#08lx bytes @%#08lx ==> @%#08lx\n",
             Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd,
             ibObjTabEnd,
             ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
             Old.OptionalHeader.SizeOfHeaders));

    MuMoveFilePos(outfh, ibNewObjTabEnd + New.OptionalHeader.SizeOfHeaders -
                  Old.OptionalHeader.SizeOfHeaders);
    MuMoveFilePos(inpfh, ibObjTabEnd);
    MuCopy(inpfh, outfh, Old.OptionalHeader.SizeOfHeaders - ibNewObjTabEnd);

    /*
     * copy existing image sections
     */

    /* Align data sections on sector boundary           */
    cb = REMAINDER(New.OptionalHeader.SizeOfHeaders, New.OptionalHeader.FileAlignment);
    New.OptionalHeader.SizeOfHeaders += cb;
    DPrintf((DebugBuf, "padding header with %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
    while (cb >= cbPadMax) {
        MuWrite(outfh, pchZero, cbPadMax);
        cb -= cbPadMax;
    }
    MuWrite(outfh, pchZero, cb);

    cb = ROUNDUP(Old.OptionalHeader.SizeOfHeaders, Old.OptionalHeader.FileAlignment);
    MuMoveFilePos(inpfh, cb);

    /* copy one section at a time */
    New.OptionalHeader.SizeOfInitializedData = 0;
    for (pObjOld = pObjtblOld , pObjNew = pObjtblNew ;
        pObjOld < pObjLast ;
        pObjNew++) {
        if (pObjOld == pObjResourceOldX)
            pObjOld++;
        if (pObjNew == pObjResourceNew) {

            /* Write new resource section */
            DPrintf((DebugBuf, "Primary resource section %i to %#08lx\n", nObjResource+1, FilePos(outfh)));

            pObjNew->PointerToRawData = FilePos(outfh);
            New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = pObjResourceNew->VirtualAddress;
            New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = cbResource;
            ibSave = FilePos(outfh);
            DPrintf((DebugBuf, "writing resource header data: %#08lx bytes @%#08lx\n", cbRestab, ibSave));
            MuWrite(outfh, (PUCHAR)pResTab, cbRestab);

            pResSave = WriteResSection(pUpdate, outfh,
                                       New.OptionalHeader.FileAlignment,
                                       pObjResourceNew->SizeOfRawData-cbRestab,
                                       NULL);
            cb = FilePos(outfh);
            DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
                     cb - ibSave - cbRestab, ibSave + cbRestab));
            if (cbMustPad != 0) {
                cbMustPad -= cb - ibSave;
                DPrintf((DebugBuf, "writing MUNGE pad: %#04lx bytes @%#08lx\n",
                         cbMustPad, cb));
                /* assumes that cbMustPad % cbpadMax == 0 */
                while (cbMustPad > 0) {
                    MuWrite(outfh, pchZero, cbPadMax);
                    cbMustPad -= cbPadMax;
                }
                cb = FilePos(outfh);
            }
            if (nObjResourceX == -1) {
                MuMoveFilePos(outfh, ibSave);
                DPrintf((DebugBuf,
                         "re-writing resource directory: %#08x bytes @%#08lx\n",
                         cbRestab, ibSave));
                MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
                MuMoveFilePos(outfh, cb);
                cb = FilePos(inpfh);
                MuMoveFilePos(inpfh, cb+pObjOld->SizeOfRawData);
            }
            New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
            if (pObjResourceOld == NULL) {
                pObjNew++;
                goto next_section;
            } else
                pObjOld++;
        } else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {

            /* Write new resource section */
            DPrintf((DebugBuf, "Secondary resource section %i @%#08lx\n", nObjResourceX+1, FilePos(outfh)));

            pObjNew->PointerToRawData = FilePos(outfh);
            (void)WriteResSection(pUpdate, outfh,
                                  New.OptionalHeader.FileAlignment, 0xffffffff, pResSave);
            cb = FilePos(outfh);
            pObjNew->SizeOfRawData = cb - pObjNew->PointerToRawData;
            pObjNew->Misc.VirtualSize = pObjNew->SizeOfRawData;
            DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
                     pObjNew->SizeOfRawData, pObjNew->PointerToRawData));
            MuMoveFilePos(outfh, ibSave);
            DPrintf((DebugBuf,
                     "re-writing resource directory: %#08x bytes @%#08lx\n",
                     cbRestab, ibSave));
            MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
            MuMoveFilePos(outfh, cb);
            New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
            pObjNew++;
            goto next_section;
        } else {
            if (pObjNew < pObjResourceNew &&
                pObjOld->PointerToRawData != 0 &&
                pObjOld->PointerToRawData != FilePos(outfh)) {
                MuMoveFilePos(outfh, pObjOld->PointerToRawData);
            }
            next_section:
            DPrintf((DebugBuf, "copying section %i @%#08lx\n", pObjNew-pObjtblNew+1, FilePos(outfh)));
            if (pObjOld->PointerToRawData != 0) {
                pObjNew->PointerToRawData = FilePos(outfh);
                MuMoveFilePos(inpfh, pObjOld->PointerToRawData);
                MuCopy(inpfh, outfh, pObjOld->SizeOfRawData);
            }
            if (pObjOld == pObjDebugDirOld) {
                pObjDebugDirNew = pObjNew;
            }
            if ((pObjNew->Characteristics&IMAGE_SCN_CNT_INITIALIZED_DATA) != 0)
                New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
            pObjOld++;
        }
    }
    if (pObjResourceOldX != NULL)
        New.OptionalHeader.SizeOfInitializedData -= pObjResourceOldX->SizeOfRawData;


    /* Update the address of the relocation table */
    pObjNew = FindSection(pObjtblNew,
                          pObjtblNew+New.FileHeader.NumberOfSections,
                          ".reloc");
    if (pObjNew != NULL) {
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = pObjNew->VirtualAddress;
    }

    /*
     * Write new section table out.
     */
    DPrintf((DebugBuf, "Writing new section table: %#08x bytes @%#08lx\n",
             New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
             ibObjTab));
    MuMoveFilePos(outfh, ibObjTab);
    MuWrite(outfh, (PUCHAR)pObjtblNew, New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

    /* Seek to end of output file and issue truncating write */

    adjust = _llseek(outfh, 0L, SEEK_END);
    MuWrite(outfh, NULL, 0);
    DPrintf((DebugBuf, "File size is: %#08lx\n", adjust));

    /* If a debug section, fix up the debug table */

    pObjNew = FindSection(pObjtblNew, pObjtblNew+New.FileHeader.NumberOfSections, ".debug");
    cb = PatchDebug(inpfh, outfh, pObjDebug, pObjNew, pObjDebugDirOld, pObjDebugDirNew,
                    &Old, &New, ibMaxDbgOffsetOld, &adjust);

    if (cb == NO_ERROR) {
        if (pObjResourceOld == NULL) {
            cb = (LONG)pObjResourceNew->SizeOfRawData;

        } else {
            cb = (LONG)pObjResourceOld->SizeOfRawData - (LONG)pObjResourceNew->SizeOfRawData;
        }

        cb = PatchRVAs(inpfh, outfh, pObjtblNew, cb, &New, Old.OptionalHeader.SizeOfHeaders);
    }

    /* copy NOTMAPPED debug info */

    if ((pObjDebugDirOld != NULL) &&
        (pObjDebug == NULL) &&
        (New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size != 0)) {

        ULONG ibt;

        ibSave = _llseek(inpfh, 0L, SEEK_END);  /* copy debug data */
        ibt = _llseek(outfh, 0L, SEEK_END);     /* to EOF */
        if (New.FileHeader.PointerToSymbolTable != 0) {
            New.FileHeader.PointerToSymbolTable += ibt - adjust;
        }

        MuMoveFilePos(inpfh, adjust);   /* returned by PatchDebug */
        DPrintf((DebugBuf, "Copying NOTMAPPED Debug Information, %#08lx bytes\n", ibSave-adjust));
        MuCopy(inpfh, outfh, ibSave-adjust);
    }

    //
    // Write updated PE header.
    //

    MuMoveFilePos(outfh, cbOldexe);
    MuWrite(outfh, (char*)&New, sizeof(NT_HEADER_TYPE));

    /* free up allocated memory */

    RtlFreeHeap(RtlProcessHeap(), 0, pObjtblOld);
    RtlFreeHeap(RtlProcessHeap(), 0, pResTab);

AbortExit:
    RtlFreeHeap(RtlProcessHeap(), 0, pObjtblNew);
    return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\volmount.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    volmount.c

Abstract:

    This file contains the implementation for the Volume Mount Point API.

Author:

    Norbert P. Kusters (norbertk) 22-Dec-1997

Revision History:

--*/

#include "basedll.h"
#include "initguid.h"
#include "mountmgr.h"

// NOTE, this structure is here because it was not defined in NTIOAPI.H.
// This should be taken out in the future.
// This is stolen from NTFS.H

typedef struct _REPARSE_INDEX_KEY {

    //
    //  The tag of the reparse point.
    //

    ULONG FileReparseTag;

    //
    //  The file record Id where the reparse point is set.
    //

    LARGE_INTEGER FileId;

} REPARSE_INDEX_KEY, *PREPARSE_INDEX_KEY;

HANDLE
WINAPI
FindFirstVolumeA(
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    )

{
    ANSI_STRING     ansiVolumeName;
    UNICODE_STRING  unicodeVolumeName;
    HANDLE          h;
    NTSTATUS        status;

    ansiVolumeName.Buffer = lpszVolumeName;
    ansiVolumeName.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeName.Buffer = NULL;
    unicodeVolumeName.MaximumLength = 0;

    try {

        unicodeVolumeName.MaximumLength = (ansiVolumeName.MaximumLength + 1)*
                                          sizeof(WCHAR);
        unicodeVolumeName.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeName.MaximumLength);
        if (!unicodeVolumeName.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return INVALID_HANDLE_VALUE;
        }

        h = FindFirstVolumeW(unicodeVolumeName.Buffer, cchBufferLength);

        if (h != INVALID_HANDLE_VALUE) {

            RtlInitUnicodeString(&unicodeVolumeName, unicodeVolumeName.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeName,
                                                    &unicodeVolumeName, FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                return INVALID_HANDLE_VALUE;
            }

            ansiVolumeName.Buffer[ansiVolumeName.Length] = 0;
        }

    } finally {

        if (unicodeVolumeName.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeName.Buffer);
        }
    }

    return h;
}

HANDLE
WINAPI
FindFirstVolumeW(
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine kicks off the enumeration of all volumes in the system.

Arguments:

    lpszVolumeName  - Returns the first volume name in the system.

    cchBufferLength - Supplies the size of the preceeding buffer.

Return Value:

    A valid handle or INVALID_HANDLE_VALUE.

--*/

{
    HANDLE                  h;
    MOUNTMGR_MOUNT_POINT    point;
    PMOUNTMGR_MOUNT_POINTS  points;
    BOOL                    b;
    DWORD                   bytes;

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, 0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return INVALID_HANDLE_VALUE;
    }

    RtlZeroMemory(&point, sizeof(point));

    points = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                             sizeof(MOUNTMGR_MOUNT_POINTS));
    if (!points) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return INVALID_HANDLE_VALUE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, &point, sizeof(point),
                        points, sizeof(MOUNTMGR_MOUNT_POINTS), &bytes, NULL);
    while (!b && GetLastError() == ERROR_MORE_DATA) {
        bytes = points->Size;
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        points = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), bytes);
        if (!points) {
            CloseHandle(h);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return INVALID_HANDLE_VALUE;
        }

        b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, &point,
                            sizeof(point), points, bytes, &bytes, NULL);
    }

    CloseHandle(h);

    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        return INVALID_HANDLE_VALUE;
    }

    b = FindNextVolumeW((HANDLE) points, lpszVolumeName, cchBufferLength);
    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        return INVALID_HANDLE_VALUE;
    }

    return (HANDLE) points;
}

BOOL
WINAPI
FindNextVolumeA(
    HANDLE hFindVolume,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    )

{
    ANSI_STRING     ansiVolumeName;
    UNICODE_STRING  unicodeVolumeName;
    BOOL            b;
    NTSTATUS        status;

    ansiVolumeName.Buffer = lpszVolumeName;
    ansiVolumeName.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeName.Buffer = NULL;
    unicodeVolumeName.MaximumLength = 0;

    try {

        unicodeVolumeName.MaximumLength = (ansiVolumeName.MaximumLength + 1)*
                                          sizeof(WCHAR);
        unicodeVolumeName.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeName.MaximumLength);
        if (!unicodeVolumeName.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        b = FindNextVolumeW(hFindVolume, unicodeVolumeName.Buffer,
                            cchBufferLength);

        if (b) {

            RtlInitUnicodeString(&unicodeVolumeName, unicodeVolumeName.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeName,
                                                    &unicodeVolumeName, FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                return FALSE;
            }

            ansiVolumeName.Buffer[ansiVolumeName.Length] = 0;
        }

    } finally {

        if (unicodeVolumeName.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeName.Buffer);
        }
    }

    return b;
}

BOOL
WINAPI
FindNextVolumeW(
    HANDLE hFindVolume,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine continues the enumeration of all volumes in the system.

Arguments:

    hFindVolume     - Supplies the find volume handle.

    lpszVolumeName  - Returns the first volume name in the system.

    cchBufferLength - Supplies the size of the preceeding buffer.

Return Value:

    FALSE   - Failure.  The error code is returned in GetLastError().

    TRUE    - Success.

--*/

{
    PMOUNTMGR_MOUNT_POINTS  points = hFindVolume;
    DWORD                   i, j;
    PMOUNTMGR_MOUNT_POINT   point, point2;
    UNICODE_STRING          symName, symName2, devName, devName2;

    for (i = 0; i < points->NumberOfMountPoints; i++) {

        point = &points->MountPoints[i];
        if (!point->SymbolicLinkNameOffset) {
            continue;
        }

        symName.Length = symName.MaximumLength = point->SymbolicLinkNameLength;
        symName.Buffer = (PWSTR) ((PCHAR) points +
                                  point->SymbolicLinkNameOffset);

        if (!MOUNTMGR_IS_NT_VOLUME_NAME(&symName)) {
            point->SymbolicLinkNameOffset = 0;
            continue;
        }

        devName.Length = devName.MaximumLength = point->DeviceNameLength;
        devName.Buffer = (PWSTR) ((PCHAR) points +
                                  point->DeviceNameOffset);

        for (j = i + 1; j < points->NumberOfMountPoints; j++) {

            point2 = &points->MountPoints[j];
            if (!point2->SymbolicLinkNameOffset) {
                continue;
            }

            symName2.Length = symName2.MaximumLength =
                    point2->SymbolicLinkNameLength;
            symName2.Buffer = (PWSTR) ((PCHAR) points +
                                       point2->SymbolicLinkNameOffset);

            if (!MOUNTMGR_IS_NT_VOLUME_NAME(&symName2)) {
                point2->SymbolicLinkNameOffset = 0;
                continue;
            }

            devName2.Length = devName2.MaximumLength =
                    point2->DeviceNameLength;
            devName2.Buffer = (PWSTR) ((PCHAR) points +
                                       point2->DeviceNameOffset);

            if (RtlEqualUnicodeString(&devName, &devName2, TRUE)) {
                point2->SymbolicLinkNameOffset = 0;
            }
        }

        break;
    }

    if (i == points->NumberOfMountPoints) {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    if (cchBufferLength*sizeof(WCHAR) < point->SymbolicLinkNameLength +
        2*sizeof(WCHAR)) {

        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        return FALSE;
    }

    RtlCopyMemory(lpszVolumeName, (PCHAR) points +
                  point->SymbolicLinkNameOffset,
                  point->SymbolicLinkNameLength);
    lpszVolumeName[1] = '\\';
    lpszVolumeName[point->SymbolicLinkNameLength/sizeof(WCHAR)] = '\\';
    lpszVolumeName[point->SymbolicLinkNameLength/sizeof(WCHAR) + 1] = 0;

    point->SymbolicLinkNameOffset = 0;

    return TRUE;
}

BOOL
WINAPI
FindVolumeClose(
    HANDLE hFindVolume
    )

{
    RtlFreeHeap(RtlProcessHeap(), 0, hFindVolume);
    return TRUE;
}

HANDLE
WINAPI
FindFirstVolumeMountPointA(
    LPCSTR lpszRootPathName,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    )

{
    PUNICODE_STRING unicodeRootPathName;
    ANSI_STRING     ansiVolumeMountPoint;
    UNICODE_STRING  unicodeVolumeMountPoint;
    HANDLE          h;
    NTSTATUS        status;

    unicodeRootPathName =
            Basep8BitStringToStaticUnicodeString(lpszRootPathName);
    if (!unicodeRootPathName) {
        return INVALID_HANDLE_VALUE;
    }

    ansiVolumeMountPoint.Buffer = lpszVolumeMountPoint;
    ansiVolumeMountPoint.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeMountPoint.Buffer = NULL;
    unicodeVolumeMountPoint.MaximumLength = 0;

    try {

        unicodeVolumeMountPoint.MaximumLength =
                (ansiVolumeMountPoint.MaximumLength + 1)*sizeof(WCHAR);
        unicodeVolumeMountPoint.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeMountPoint.MaximumLength);
        if (!unicodeVolumeMountPoint.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return INVALID_HANDLE_VALUE;
        }

        h = FindFirstVolumeMountPointW(unicodeRootPathName->Buffer,
                                       unicodeVolumeMountPoint.Buffer,
                                       cchBufferLength);

        if (h != INVALID_HANDLE_VALUE) {

            RtlInitUnicodeString(&unicodeVolumeMountPoint,
                                 unicodeVolumeMountPoint.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeMountPoint,
                                                    &unicodeVolumeMountPoint,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                return INVALID_HANDLE_VALUE;
            }

            ansiVolumeMountPoint.Buffer[ansiVolumeMountPoint.Length] = 0;
        }

    } finally {

        if (unicodeVolumeMountPoint.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeMountPoint.Buffer);
        }
    }

    return h;
}

BOOL
FindNextVolumeMountPointHelper(
    HANDLE hFindVolumeMountPoint,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength,
    BOOL FirstTimeCalled
    )

/*++

Routine Description:

    This routine continues the enumeration of all volume mount point on the
    given volume.

Arguments:

    hFindVolumeMountPoint   - Supplies the handle for the enumeration.

    lpszVolumeMountPoint    - Returns the volume mount point.

    cchBufferLength         - Supplies the volume mount point buffer length.

    FirstTimeCalled         - Supplies whether or not this is being called
                                from FindFirst or from FindNext.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    REPARSE_INDEX_KEY                   reparseKey;
    UNICODE_STRING                      reparseName;
    NTSTATUS                            status;
    IO_STATUS_BLOCK                     ioStatus;
    FILE_REPARSE_POINT_INFORMATION      reparseInfo;
    UNICODE_STRING                      fileId;
    OBJECT_ATTRIBUTES                   oa;
    HANDLE                              h;
    PREPARSE_DATA_BUFFER                reparse;
    BOOL                                b;
    DWORD                               bytes;
    UNICODE_STRING                      mountName;
    DWORD                               nameInfoSize;
    PFILE_NAME_INFORMATION              nameInfo;

    for (;;) {

        if (FirstTimeCalled) {
            FirstTimeCalled = FALSE;
            RtlZeroMemory(&reparseKey, sizeof(reparseKey));
            reparseKey.FileReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
            reparseName.Length = reparseName.MaximumLength = sizeof(reparseKey);
            reparseName.Buffer = (PWCHAR) &reparseKey;
            status = NtQueryDirectoryFile(hFindVolumeMountPoint,
                                          NULL, NULL, NULL, &ioStatus,
                                          &reparseInfo, sizeof(reparseInfo),
                                          FileReparsePointInformation, TRUE,
                                          &reparseName, FALSE);
        } else {
            status = NtQueryDirectoryFile(hFindVolumeMountPoint,
                                          NULL, NULL, NULL, &ioStatus,
                                          &reparseInfo, sizeof(reparseInfo),
                                          FileReparsePointInformation, TRUE,
                                          NULL, FALSE);
        }

        if (!NT_SUCCESS(status)) {
            BaseSetLastNTError(status);
            return FALSE;
        }

        if (reparseInfo.Tag != IO_REPARSE_TAG_MOUNT_POINT) {
            SetLastError(ERROR_NO_MORE_FILES);
            return FALSE;
        }

        fileId.Length = sizeof(reparseInfo.FileReference);
        fileId.MaximumLength = fileId.Length;
        fileId.Buffer = (PWSTR) &reparseInfo.FileReference;

        InitializeObjectAttributes(&oa, &fileId, 0, hFindVolumeMountPoint,
                                   NULL);

        status = NtOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT);
        if (!NT_SUCCESS(status)) {
            BaseSetLastNTError(status);
            return FALSE;
        }

        reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                  MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
        if (!reparse) {
            CloseHandle(h);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        b = DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                            MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &bytes, NULL);

        if (!b || reparse->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT) {
            RtlFreeHeap(RtlProcessHeap(), 0, reparse);
            CloseHandle(h);
            return FALSE;
        }

        mountName.Length = mountName.MaximumLength =
                reparse->MountPointReparseBuffer.SubstituteNameLength;
        mountName.Buffer = (PWSTR)
                ((PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                 reparse->MountPointReparseBuffer.SubstituteNameOffset);

        if (!MOUNTMGR_IS_NT_VOLUME_NAME_WB(&mountName)) {
            RtlFreeHeap(RtlProcessHeap(), 0, reparse);
            CloseHandle(h);
            continue;
        }

        RtlFreeHeap(RtlProcessHeap(), 0, reparse);

        nameInfoSize = FIELD_OFFSET(FILE_NAME_INFORMATION, FileName) +
                       (cchBufferLength - 1)*sizeof(WCHAR);
        nameInfo = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                   nameInfoSize);
        if (!nameInfo) {
            CloseHandle(h);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        status = NtQueryInformationFile(h, &ioStatus, nameInfo, nameInfoSize,
                                        FileNameInformation);
        if (!NT_SUCCESS(status)) {
            RtlFreeHeap(RtlProcessHeap(), 0, nameInfo);
            CloseHandle(h);
            BaseSetLastNTError(status);
            return FALSE;
        }

        RtlCopyMemory(lpszVolumeMountPoint, &nameInfo->FileName[1],
                      nameInfo->FileNameLength - sizeof(WCHAR));
        lpszVolumeMountPoint[nameInfo->FileNameLength/sizeof(WCHAR) - 1] = '\\';
        lpszVolumeMountPoint[nameInfo->FileNameLength/sizeof(WCHAR)] = 0;

        RtlFreeHeap(RtlProcessHeap(), 0, nameInfo);
        CloseHandle(h);
        break;
    }

    return TRUE;
}

HANDLE
WINAPI
FindFirstVolumeMountPointW(
    LPCWSTR lpszRootPathName,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine kicks off the enumeration of all volume mount point on the
    given volume.

Arguments:

    lpszRootPathName        - Supplies the root path name.

    lpszVolumeMountPoint    - Returns the volume mount point.

    cchBufferLength         - Supplies the volume mount point buffer length.

Return Value:

    A handle or INVALID_HANDLE_VALUE.

--*/

{
    UNICODE_STRING                  unicodeRootPathName;
    UNICODE_STRING                  reparseSuffix, reparseName;
    HANDLE                          h;
    BOOL                            b;

    RtlInitUnicodeString(&unicodeRootPathName, lpszRootPathName);
    if (unicodeRootPathName.Buffer[
        unicodeRootPathName.Length/sizeof(WCHAR) - 1] != '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return INVALID_HANDLE_VALUE;
    }

    RtlInitUnicodeString(&reparseSuffix,
                         L"$Extend\\$Reparse:$R:$INDEX_ALLOCATION");

    reparseName.MaximumLength = unicodeRootPathName.Length +
                                reparseSuffix.Length + sizeof(WCHAR);
    reparseName.Length = 0;
    reparseName.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                         reparseName.MaximumLength);
    if (!reparseName.Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return INVALID_HANDLE_VALUE;
    }

    RtlCopyUnicodeString(&reparseName, &unicodeRootPathName);
    RtlAppendUnicodeStringToString(&reparseName, &reparseSuffix);
    reparseName.Buffer[reparseName.Length/sizeof(WCHAR)] = 0;

    h = CreateFileW(reparseName.Buffer, GENERIC_READ, FILE_SHARE_READ, NULL,
                    OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS |
                    SECURITY_IMPERSONATION, NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, reparseName.Buffer);

    if (h == INVALID_HANDLE_VALUE) {
        return INVALID_HANDLE_VALUE;
    }

    b = FindNextVolumeMountPointHelper(h, lpszVolumeMountPoint,
                                       cchBufferLength, TRUE);
    if (!b) {
        CloseHandle(h);
        return INVALID_HANDLE_VALUE;
    }

    return h;
}

BOOL
WINAPI
FindNextVolumeMountPointA(
    HANDLE hFindVolumeMountPoint,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    )

{
    ANSI_STRING     ansiVolumeMountPoint;
    UNICODE_STRING  unicodeVolumeMountPoint;
    BOOL            b;
    NTSTATUS        status;

    ansiVolumeMountPoint.Buffer = lpszVolumeMountPoint;
    ansiVolumeMountPoint.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeMountPoint.Buffer = NULL;
    unicodeVolumeMountPoint.MaximumLength = 0;

    try {

        unicodeVolumeMountPoint.MaximumLength =
                (ansiVolumeMountPoint.MaximumLength + 1)*sizeof(WCHAR);
        unicodeVolumeMountPoint.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeMountPoint.MaximumLength);
        if (!unicodeVolumeMountPoint.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        b = FindNextVolumeMountPointW(hFindVolumeMountPoint,
                                      unicodeVolumeMountPoint.Buffer,
                                      cchBufferLength);

        if (b) {

            RtlInitUnicodeString(&unicodeVolumeMountPoint,
                                 unicodeVolumeMountPoint.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeMountPoint,
                                                    &unicodeVolumeMountPoint,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                return FALSE;
            }

            ansiVolumeMountPoint.Buffer[ansiVolumeMountPoint.Length] = 0;
        }

    } finally {

        if (unicodeVolumeMountPoint.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeMountPoint.Buffer);
        }
    }

    return b;
}

BOOL
IsThisAVolumeName(
    LPCWSTR     Name,
    PBOOLEAN    IsVolume
    )

/*++

Routine Description:

    This routine takes the given NT name and determines whether or not
    the name points to a volume.

Arguments:

    Name        - Supplies the name.

    IsVolume    - Returns whether or not the given name is a volume.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING          name;
    PMOUNTMGR_MOUNT_POINT   point;
    MOUNTMGR_MOUNT_POINTS   points;
    HANDLE                  h;
    BOOL                    b;
    DWORD                   bytes;

    RtlInitUnicodeString(&name, Name);
    if (name.Buffer[name.Length/sizeof(WCHAR) - 1] == '\\') {
        name.Length -= sizeof(WCHAR);
    }
    point = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                            name.Length + sizeof(MOUNTMGR_MOUNT_POINT));
    if (!point) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlZeroMemory(point, sizeof(MOUNTMGR_MOUNT_POINT));
    point->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    point->DeviceNameLength = name.Length;
    RtlCopyMemory((PCHAR) point + point->DeviceNameOffset, name.Buffer,
                  point->DeviceNameLength);

    if (name.Length >= 4 && name.Buffer[1] == '\\') {
        ((PWSTR) ((PCHAR) point + point->DeviceNameOffset))[1] = '?';
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, 0, FILE_SHARE_READ |
                    FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, point);
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, point,
                        name.Length + sizeof(MOUNTMGR_MOUNT_POINT),
                        &points, sizeof(MOUNTMGR_MOUNT_POINTS), &bytes, NULL);
    if (b) {
        if (points.NumberOfMountPoints) {
            *IsVolume = TRUE;
        } else {
            *IsVolume = FALSE;
        }
    } else {
        if (GetLastError() == ERROR_MORE_DATA) {
            *IsVolume = TRUE;
        } else {
            *IsVolume = FALSE;
        }
    }

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, point);

    return TRUE;
}

BOOL
WINAPI
FindNextVolumeMountPointW(
    HANDLE hFindVolumeMountPoint,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine continues the enumeration of all volume mount point on the
    given volume.

Arguments:

    hFindVolumeMountPoint   - Supplies the handle for the enumeration.

    lpszVolumeMountPoint    - Returns the volume mount point.

    cchBufferLength         - Supplies the volume mount point buffer length.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    return FindNextVolumeMountPointHelper(hFindVolumeMountPoint,
                                          lpszVolumeMountPoint,
                                          cchBufferLength, FALSE);
}

BOOL
WINAPI
FindVolumeMountPointClose(
    HANDLE hFindVolumeMountPoint
    )

{
    return CloseHandle(hFindVolumeMountPoint);
}

BOOL
WINAPI
GetVolumeNameForVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    )

{
    PUNICODE_STRING unicodeVolumeMountPoint;
    ANSI_STRING     ansiVolumeName;
    UNICODE_STRING  unicodeVolumeName;
    BOOL            b;
    NTSTATUS        status;

    unicodeVolumeMountPoint =
            Basep8BitStringToStaticUnicodeString(lpszVolumeMountPoint);
    if (!unicodeVolumeMountPoint) {
        return FALSE;
    }

    ansiVolumeName.Buffer = lpszVolumeName;
    ansiVolumeName.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeName.Buffer = NULL;
    unicodeVolumeName.MaximumLength = 0;

    try {

        unicodeVolumeName.MaximumLength =
                (ansiVolumeName.MaximumLength + 1)*sizeof(WCHAR);
        unicodeVolumeName.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeName.MaximumLength);
        if (!unicodeVolumeName.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        b = GetVolumeNameForVolumeMountPointW(unicodeVolumeMountPoint->Buffer,
                                              unicodeVolumeName.Buffer,
                                              cchBufferLength);

        if (b) {

            RtlInitUnicodeString(&unicodeVolumeName,
                                 unicodeVolumeName.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeName,
                                                    &unicodeVolumeName,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                return FALSE;
            }

            ansiVolumeName.Buffer[ansiVolumeName.Length] = 0;
        }

    } finally {

        if (unicodeVolumeName.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeName.Buffer);
        }
    }

    return b;
}

BOOL
GetVolumeNameForRoot(
    LPCWSTR DeviceName,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine queries the volume name for the given NT device name.

Arguments:

    DeviceName      - Supplies a DOS device name terminated by a '\'.

    lpszVolumeName  - Returns the volume name pointed to by the DOS
                        device name.

    cchBufferLength - Supplies the size of the preceeding buffer.

Return Value:

    FALSE   - Failure.  The error code is returned in GetLastError().

    TRUE    - Success.

--*/

{
    NTSTATUS                status;
    UNICODE_STRING          devicePath, symName;
    OBJECT_ATTRIBUTES       oa;
    HANDLE                  h;
    IO_STATUS_BLOCK         ioStatus;
    WCHAR                   buffer[MAX_PATH];
    PMOUNTDEV_NAME          name;
    BOOL                    b;
    DWORD                   bytes, i;
    PMOUNTMGR_MOUNT_POINT   point;
    PMOUNTMGR_MOUNT_POINTS  points;

    if (GetDriveTypeW(DeviceName) == DRIVE_REMOTE) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    if (!RtlDosPathNameToNtPathName_U(DeviceName, &devicePath, NULL, NULL)) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    if (devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 1] == '\\') {
        devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 1] = 0;
        devicePath.Length -= sizeof(WCHAR);
    }

    if (devicePath.Length >= 2*sizeof(WCHAR) &&
        devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 1] == ':') {

        devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 2] = (WCHAR)
            toupper(devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 2]);
    }

    InitializeObjectAttributes(&oa, &devicePath, OBJ_CASE_INSENSITIVE,
                               NULL, NULL);

    status = NtOpenFile(&h, FILE_READ_ATTRIBUTES | SYNCHRONIZE, &oa,
                        &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(status)) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        SetLastError(RtlNtStatusToDosError(status));
        return FALSE;
    }

    name = (PMOUNTDEV_NAME) buffer;
    b = DeviceIoControl(h, IOCTL_MOUNTDEV_QUERY_DEVICE_NAME, NULL, 0, name,
                        MAX_PATH*sizeof(WCHAR), &bytes, NULL);
    NtClose(h);

    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        return FALSE;
    }

    RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);

    devicePath.Length = name->NameLength;
    devicePath.MaximumLength = devicePath.Length + sizeof(WCHAR);

    devicePath.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                        MAKE_TAG(TMP_TAG),
                                        devicePath.MaximumLength);
    if (!devicePath.Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlCopyMemory(devicePath.Buffer, name->Name, name->NameLength);
    devicePath.Buffer[devicePath.Length/sizeof(WCHAR)] = 0;

    point = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                            devicePath.Length + sizeof(MOUNTMGR_MOUNT_POINT));
    if (!point) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlZeroMemory(point, sizeof(MOUNTMGR_MOUNT_POINT));
    point->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    point->DeviceNameLength = devicePath.Length;
    RtlCopyMemory((PCHAR) point + point->DeviceNameOffset,
                  devicePath.Buffer, point->DeviceNameLength);

    RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);

    points = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                             sizeof(MOUNTMGR_MOUNT_POINTS));
    if (!points) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RtlFreeHeap(RtlProcessHeap(), 0, point);
        return FALSE;
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, 0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        RtlFreeHeap(RtlProcessHeap(), 0, point);
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, point,
                        devicePath.Length + sizeof(MOUNTMGR_MOUNT_POINT),
                        points, sizeof(MOUNTMGR_MOUNT_POINTS), &bytes, NULL);
    while (!b && GetLastError() == ERROR_MORE_DATA) {
        bytes = points->Size;
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        points = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), bytes);
        if (!points) {
            CloseHandle(h);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            RtlFreeHeap(RtlProcessHeap(), 0, point);
            return FALSE;
        }

        b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, point,
                            devicePath.Length + sizeof(MOUNTMGR_MOUNT_POINT),
                            points, bytes, &bytes, NULL);
    }

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, point);

    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for (i = 0; i < points->NumberOfMountPoints; i++) {

        symName.Length = symName.MaximumLength =
                points->MountPoints[i].SymbolicLinkNameLength;
        symName.Buffer = (PWSTR) ((PCHAR) points +
                         points->MountPoints[i].SymbolicLinkNameOffset);

        if (MOUNTMGR_IS_NT_VOLUME_NAME(&symName)) {
            break;
        }
    }

    if (i == points->NumberOfMountPoints) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (cchBufferLength*sizeof(WCHAR) < symName.Length + 2*sizeof(WCHAR)) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        return FALSE;
    }

    RtlCopyMemory(lpszVolumeName, symName.Buffer, symName.Length);
    lpszVolumeName[1] = '\\';
    lpszVolumeName[symName.Length/sizeof(WCHAR)] = '\\';
    lpszVolumeName[symName.Length/sizeof(WCHAR) + 1] = 0;

    RtlFreeHeap(RtlProcessHeap(), 0, points);

    return TRUE;
}

BOOL
BasepGetVolumeNameFromReparsePoint(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength,
    PBOOL ResultOfOpen
    )

{
    HANDLE                  h;
    PREPARSE_DATA_BUFFER    reparse;
    BOOL                    b;
    DWORD                   bytes;
    UNICODE_STRING          mountName;
    WCHAR                   c;

    h = CreateFileW(lpszVolumeMountPoint, 0, FILE_SHARE_READ |
                    FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OPEN_REPARSE_POINT |
                    FILE_FLAG_BACKUP_SEMANTICS, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        if (ResultOfOpen) {
            *ResultOfOpen = FALSE;
        }
        return FALSE;
    }

    if (ResultOfOpen) {
        *ResultOfOpen = TRUE;
    }

    reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                              MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    b = DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                        MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &bytes, NULL);
    CloseHandle(h);

    if (!b || reparse->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT) {
        RtlFreeHeap(RtlProcessHeap(), 0, reparse);
        return FALSE;
    }

    if (cchBufferLength*sizeof(WCHAR) <
        reparse->MountPointReparseBuffer.SubstituteNameLength + sizeof(WCHAR)) {

        RtlFreeHeap(RtlProcessHeap(), 0, reparse);
        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        return FALSE;
    }

    RtlCopyMemory(lpszVolumeName,
                  (PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                  reparse->MountPointReparseBuffer.SubstituteNameOffset,
                  reparse->MountPointReparseBuffer.SubstituteNameLength);

    c = lpszVolumeName[1];
    lpszVolumeName[1] = '\\';
    lpszVolumeName[reparse->MountPointReparseBuffer.SubstituteNameLength/
                   sizeof(WCHAR)] = 0;

    mountName.Length = mountName.MaximumLength =
            reparse->MountPointReparseBuffer.SubstituteNameLength;
    mountName.Buffer = lpszVolumeName;

    RtlFreeHeap(RtlProcessHeap(), 0, reparse);

    if (!MOUNTMGR_IS_DOS_VOLUME_NAME_WB(&mountName)) {
        lpszVolumeName[1] = c;
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}

BOOL
BasepGetVolumeNameForVolumeMountPoint(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength,
    PBOOL ResultOfOpen
    )

/*++

Routine Description:

    This routine returns the volume name for a given volume mount point.

Arguments:

    lpszVolumeMountPoint    - Supplies the volume mount point.

    lpszVolumeName          - Returns the volume name.

    cchBufferLength         - Supplies the size of the volume name buffer.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING  unicodeVolumeMountPoint;
    BOOL            b;

    if (ResultOfOpen) {
        *ResultOfOpen = TRUE;
    }

    RtlInitUnicodeString(&unicodeVolumeMountPoint, lpszVolumeMountPoint);
    if (unicodeVolumeMountPoint.Buffer[
        unicodeVolumeMountPoint.Length/sizeof(WCHAR) - 1] != '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        if (lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return FALSE;
    }

    if (unicodeVolumeMountPoint.Length == 6 &&
        unicodeVolumeMountPoint.Buffer[1] == ':') {

        b = GetVolumeNameForRoot(lpszVolumeMountPoint, lpszVolumeName,
                                 cchBufferLength);
        if (!b && lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return b;
    }

    if (unicodeVolumeMountPoint.Length == 14 &&
        unicodeVolumeMountPoint.Buffer[0] == '\\' &&
        unicodeVolumeMountPoint.Buffer[1] == '\\' &&
        (unicodeVolumeMountPoint.Buffer[2] == '.' ||
         unicodeVolumeMountPoint.Buffer[2] == '?') &&
        unicodeVolumeMountPoint.Buffer[3] == '\\' &&
        unicodeVolumeMountPoint.Buffer[5] == ':') {

        b = GetVolumeNameForRoot(lpszVolumeMountPoint + 4,
                                 lpszVolumeName, cchBufferLength);
        if (!b && lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return b;
    }

    if (GetVolumeNameForRoot(lpszVolumeMountPoint, lpszVolumeName,
                             cchBufferLength)) {

        return TRUE;
    }

    b = BasepGetVolumeNameFromReparsePoint(lpszVolumeMountPoint,
                                           lpszVolumeName, cchBufferLength,
                                           ResultOfOpen);
    if (!b && lpszVolumeName && cchBufferLength >= 1) {
        *lpszVolumeName = 0;
    }

    return b;
}

BOOL
WINAPI
GetVolumeNameForVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine returns the volume name for a given volume mount point.

Arguments:

    lpszVolumeMountPoint    - Supplies the volume mount point.

    lpszVolumeName          - Returns the volume name.

    cchBufferLength         - Supplies the size of the volume name buffer.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    return BasepGetVolumeNameForVolumeMountPoint(lpszVolumeMountPoint,
                                                 lpszVolumeName,
                                                 cchBufferLength, NULL);
}

BOOL
WINAPI
SetVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPCSTR lpszVolumeName
    )

{
    PUNICODE_STRING unicodeVolumeMountPoint;
    UNICODE_STRING  unicodeVolumeName;
    BOOL            b;

    unicodeVolumeMountPoint = Basep8BitStringToStaticUnicodeString(
                              lpszVolumeMountPoint);
    if (!unicodeVolumeMountPoint) {
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString(&unicodeVolumeName,
                                               lpszVolumeName)) {
        return FALSE;
    }

    b = SetVolumeMountPointW(unicodeVolumeMountPoint->Buffer,
                             unicodeVolumeName.Buffer);

    RtlFreeUnicodeString(&unicodeVolumeName);

    return b;
}

BOOL
SetVolumeNameForRoot(
    LPCWSTR DeviceName,
    LPCWSTR lpszVolumeName
    )

/*++

Routine Description:

    This routine sets the volume name for the given DOS device name.

Arguments:

    DeviceName      - Supplies a DOS device name terminated by a '\'.

    lpszVolumeName  - Supplies the volume name that the DOS device name
                        will point to.

Return Value:

    FALSE   - Failure.  The error code is returned in GetLastError().

    TRUE    - Success.

--*/

{
    UNICODE_STRING                  devicePath, volumeName;
    DWORD                           inputLength;
    PMOUNTMGR_CREATE_POINT_INPUT    input;
    HANDLE                          h;
    BOOL                            b;
    DWORD                           bytes;

    devicePath.Length = 28;
    devicePath.MaximumLength = devicePath.Length + sizeof(WCHAR);
    devicePath.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                        devicePath.MaximumLength);
    if (!devicePath.Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    RtlCopyMemory(devicePath.Buffer, L"\\DosDevices\\", 24);

    devicePath.Buffer[12] = (WCHAR)toupper(DeviceName[0]);
    devicePath.Buffer[13] = ':';
    devicePath.Buffer[14] = 0;

    RtlInitUnicodeString(&volumeName, lpszVolumeName);
    volumeName.Length -= sizeof(WCHAR);

    inputLength = sizeof(MOUNTMGR_CREATE_POINT_INPUT) + devicePath.Length +
                  volumeName.Length;
    input = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), inputLength);
    if (!input) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    input->SymbolicLinkNameLength = devicePath.Length;
    input->DeviceNameOffset = input->SymbolicLinkNameOffset +
                              input->SymbolicLinkNameLength;
    input->DeviceNameLength = volumeName.Length;
    RtlCopyMemory((PCHAR) input + input->SymbolicLinkNameOffset,
                  devicePath.Buffer, input->SymbolicLinkNameLength);
    RtlCopyMemory((PCHAR) input + input->DeviceNameOffset, volumeName.Buffer,
                  input->DeviceNameLength);
    ((PWSTR) ((PCHAR) input + input->DeviceNameOffset))[1] = '?';

    RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, input);
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_CREATE_POINT, input, inputLength,
                        NULL, 0, &bytes, NULL);

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, input);

    return b;
}

VOID
NotifyMountMgr(
    LPCWSTR lpszVolumeMountPoint,
    LPCWSTR lpszVolumeName,
    BOOL IsPointCreated
    )

/*++

Routine Description:

    This routine notifies the mount mgr that a volume mount point was
    created or deleted so that the mount mgr can update the remote database on
    the volume where the mount point was created or deleted.

Arguments:

    lpszVolumeMountPoint    - Supplies the directory where the volume mount
                                point resides.

    lpszVolumeName          - Supplies the volume name.

    IsPointCreated          - Supplies wheter or not the point was created or
                                deleted.

Return Value:

    None.

--*/

{
    UNICODE_STRING                  unicodeSourceVolumeName;
    UNICODE_STRING                  unicodeTargetVolumeName;
    DWORD                           inputSize;
    PMOUNTMGR_VOLUME_MOUNT_POINT    input;
    HANDLE                          h;
    DWORD                           ioControl, bytes;

    if (!RtlDosPathNameToNtPathName_U(lpszVolumeMountPoint,
                                      &unicodeSourceVolumeName, NULL, NULL)) {

        return;
    }

    RtlInitUnicodeString(&unicodeTargetVolumeName, lpszVolumeName);
    unicodeSourceVolumeName.Length -= sizeof(WCHAR);
    unicodeTargetVolumeName.Length -= sizeof(WCHAR);

    inputSize = sizeof(MOUNTMGR_VOLUME_MOUNT_POINT) +
                unicodeSourceVolumeName.Length +
                unicodeTargetVolumeName.Length;
    input = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), inputSize);
    if (!input) {
        RtlFreeHeap(RtlProcessHeap(), 0, unicodeSourceVolumeName.Buffer);
        return;
    }

    input->SourceVolumeNameOffset = sizeof(MOUNTMGR_VOLUME_MOUNT_POINT);
    input->SourceVolumeNameLength = unicodeSourceVolumeName.Length;
    input->TargetVolumeNameOffset = input->SourceVolumeNameOffset +
                                    input->SourceVolumeNameLength;
    input->TargetVolumeNameLength = unicodeTargetVolumeName.Length;

    RtlCopyMemory((PCHAR) input + input->SourceVolumeNameOffset,
                  unicodeSourceVolumeName.Buffer,
                  input->SourceVolumeNameLength);

    RtlCopyMemory((PCHAR) input + input->TargetVolumeNameOffset,
                  unicodeTargetVolumeName.Buffer,
                  input->TargetVolumeNameLength);

    ((PWSTR) ((PCHAR) input + input->TargetVolumeNameOffset))[1] = '?';

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, input);
        RtlFreeHeap(RtlProcessHeap(), 0, unicodeSourceVolumeName.Buffer);
        return;
    }

    if (IsPointCreated) {
        ioControl = IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED;
    } else {
        ioControl = IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED;
    }

    DeviceIoControl(h, ioControl, input, inputSize, NULL, 0, &bytes, NULL);

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, input);
    RtlFreeHeap(RtlProcessHeap(), 0, unicodeSourceVolumeName.Buffer);
}

BOOL
WINAPI
SetVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPCWSTR lpszVolumeName
    )

/*++

Routine Description:

    This routine sets a mount point on the given directory pointed to by
    'VolumeMountPoint' which points to the volume given by 'VolumeName'.
    In the case when 'VolumeMountPoint' is of the form "D:\", the drive
    letter for the given volume is set to 'D:'.

Arguments:

    lpszVolumeMountPoint    - Supplies the directory where the volume mount
                                point will reside.

    lpszVolumeName          - Supplies the volume name.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING          unicodeVolumeMountPoint;
    UNICODE_STRING          unicodeVolumeName;
    BOOLEAN                 isVolume;
    BOOL                    b;
    WCHAR                   volumeMountPointVolumePrefix[MAX_PATH];
    HANDLE                  h;
    PREPARSE_DATA_BUFFER    reparse;
    DWORD                   bytes;

    if (GetVolumeNameForVolumeMountPointW(lpszVolumeMountPoint,
                                          volumeMountPointVolumePrefix,
                                          MAX_PATH) ||
        GetLastError() == ERROR_FILENAME_EXCED_RANGE) {

        SetLastError(ERROR_DIR_NOT_EMPTY);
        return FALSE;
    }

    RtlInitUnicodeString(&unicodeVolumeMountPoint, lpszVolumeMountPoint);
    RtlInitUnicodeString(&unicodeVolumeName, lpszVolumeName);

    if (unicodeVolumeMountPoint.Length == 0 ||
        unicodeVolumeName.Length == 0) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (unicodeVolumeMountPoint.Buffer[
        unicodeVolumeMountPoint.Length/sizeof(WCHAR) - 1] != '\\' ||
        unicodeVolumeName.Buffer[
        unicodeVolumeName.Length/sizeof(WCHAR) - 1] != '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
    }

    if (!MOUNTMGR_IS_DOS_VOLUME_NAME_WB(&unicodeVolumeName)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!IsThisAVolumeName(lpszVolumeName, &isVolume)) {
        return FALSE;
    }
    if (!isVolume) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (unicodeVolumeMountPoint.Length == 6 &&
        unicodeVolumeMountPoint.Buffer[1] == ':') {

        return SetVolumeNameForRoot(lpszVolumeMountPoint, lpszVolumeName);
    }

    if (unicodeVolumeMountPoint.Length == 14 &&
        unicodeVolumeMountPoint.Buffer[0] == '\\' &&
        unicodeVolumeMountPoint.Buffer[1] == '\\' &&
        (unicodeVolumeMountPoint.Buffer[2] == '.' ||
         unicodeVolumeMountPoint.Buffer[2] == '?') &&
        unicodeVolumeMountPoint.Buffer[3] == '\\' &&
        unicodeVolumeMountPoint.Buffer[5] == ':') {

        return SetVolumeNameForRoot(lpszVolumeMountPoint + 4, lpszVolumeName);
    }

    if (GetDriveTypeW(lpszVolumeMountPoint) != DRIVE_FIXED) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    CloseHandle(h);

    h = CreateFileW(lpszVolumeMountPoint, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OPEN_REPARSE_POINT |
                    FILE_FLAG_BACKUP_SEMANTICS, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                              MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    reparse->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
    reparse->ReparseDataLength = (USHORT) (FIELD_OFFSET(REPARSE_DATA_BUFFER,
                                              MountPointReparseBuffer.PathBuffer) -
                                 REPARSE_DATA_BUFFER_HEADER_SIZE +
                                 unicodeVolumeName.Length + 2*sizeof(WCHAR));
    reparse->Reserved = 0;
    reparse->MountPointReparseBuffer.SubstituteNameOffset = 0;
    reparse->MountPointReparseBuffer.SubstituteNameLength = unicodeVolumeName.Length;
    reparse->MountPointReparseBuffer.PrintNameOffset =
            reparse->MountPointReparseBuffer.SubstituteNameLength +
            sizeof(WCHAR);
    reparse->MountPointReparseBuffer.PrintNameLength = 0;

    CopyMemory(reparse->MountPointReparseBuffer.PathBuffer,
               unicodeVolumeName.Buffer,
               reparse->MountPointReparseBuffer.SubstituteNameLength);

    reparse->MountPointReparseBuffer.PathBuffer[1] = '?';
    reparse->MountPointReparseBuffer.PathBuffer[
            unicodeVolumeName.Length/sizeof(WCHAR)] = 0;
    reparse->MountPointReparseBuffer.PathBuffer[
            unicodeVolumeName.Length/sizeof(WCHAR) + 1] = 0;

    b = DeviceIoControl(h, FSCTL_SET_REPARSE_POINT, reparse,
                        REPARSE_DATA_BUFFER_HEADER_SIZE +
                        reparse->ReparseDataLength, NULL, 0, &bytes, NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, reparse);
    CloseHandle(h);

    if (b) {
        NotifyMountMgr(lpszVolumeMountPoint, lpszVolumeName, TRUE);
    }

    return b;
}

BOOL
WINAPI
DeleteVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint
    )

{
    PUNICODE_STRING unicodeVolumeMountPoint;
    BOOL            b;

    unicodeVolumeMountPoint = Basep8BitStringToStaticUnicodeString(
                              lpszVolumeMountPoint);
    if (!unicodeVolumeMountPoint) {
        return FALSE;
    }

    b = DeleteVolumeMountPointW(unicodeVolumeMountPoint->Buffer);

    return b;
}

BOOL
DeleteVolumeNameForRoot(
    LPCWSTR DeviceName
    )

/*++

Routine Description:

    This routine deletes the given DOS device name.

Arguments:

    DeviceName  - Supplies a DOS device name terminated by a '\'.

Return Value:

    FALSE   - Failure.  The error code is returned in GetLastError().

    TRUE    - Success.

--*/

{
    UNICODE_STRING          devicePath;
    DWORD                   inputLength;
    PMOUNTMGR_MOUNT_POINT   input;
    DWORD                   outputLength;
    PMOUNTMGR_MOUNT_POINTS  output;
    HANDLE                  h;
    BOOL                    b;
    DWORD                   bytes;

    devicePath.Length = 28;
    devicePath.MaximumLength = devicePath.Length + sizeof(WCHAR);
    devicePath.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                        devicePath.MaximumLength);
    if (!devicePath.Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    RtlCopyMemory(devicePath.Buffer, L"\\DosDevices\\", 24);

    devicePath.Buffer[12] = (WCHAR)toupper(DeviceName[0]);
    devicePath.Buffer[13] = ':';
    devicePath.Buffer[14] = 0;

    inputLength = sizeof(MOUNTMGR_MOUNT_POINT) + devicePath.Length;
    input = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), inputLength);
    if (!input) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlZeroMemory(input, sizeof(MOUNTMGR_MOUNT_POINT));
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    input->SymbolicLinkNameLength = devicePath.Length;
    RtlCopyMemory((PCHAR) input + input->SymbolicLinkNameOffset,
                  devicePath.Buffer, input->SymbolicLinkNameLength);

    RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);

    outputLength = sizeof(MOUNTMGR_MOUNT_POINTS) + 3*MAX_PATH*sizeof(WCHAR);
    output = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                             outputLength);
    if (!output) {
        RtlFreeHeap(RtlProcessHeap(), 0, input);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, output);
        RtlFreeHeap(RtlProcessHeap(), 0, input);
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_DELETE_POINTS, input, inputLength,
                        output, outputLength, &bytes, NULL);

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, output);
    RtlFreeHeap(RtlProcessHeap(), 0, input);

    return b;
}

BOOL
WINAPI
DeleteVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint
    )

/*++

Routine Description:

    This routine removes the NTFS junction point from the given directory
    or remove the drive letter symbolic link pointing to the given volume.

Arguments:

    lpszVolumeMountPoint    - Supplies the volume mount piont.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING          unicodeVolumeMountPoint;
    HANDLE                  h;
    PREPARSE_DATA_BUFFER    reparse;
    BOOL                    b;
    DWORD                   bytes;
    UNICODE_STRING          substituteName;

    RtlInitUnicodeString(&unicodeVolumeMountPoint, lpszVolumeMountPoint);

    if (unicodeVolumeMountPoint.Buffer[
        unicodeVolumeMountPoint.Length/sizeof(WCHAR) - 1] != '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
    }

    if (unicodeVolumeMountPoint.Length == 6 &&
        unicodeVolumeMountPoint.Buffer[1] == ':') {

        return DeleteVolumeNameForRoot(lpszVolumeMountPoint);
    }

    if (unicodeVolumeMountPoint.Length == 14 &&
        unicodeVolumeMountPoint.Buffer[0] == '\\' &&
        unicodeVolumeMountPoint.Buffer[1] == '\\' &&
        (unicodeVolumeMountPoint.Buffer[2] == '.' ||
         unicodeVolumeMountPoint.Buffer[2] == '?') &&
        unicodeVolumeMountPoint.Buffer[3] == '\\' &&
        unicodeVolumeMountPoint.Buffer[5] == ':') {

        return DeleteVolumeNameForRoot(lpszVolumeMountPoint + 4);
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    CloseHandle(h);

    h = CreateFileW(lpszVolumeMountPoint, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                    FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                    INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                              MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    b = DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                        MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &bytes, NULL);

    if (!b || reparse->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT) {
        RtlFreeHeap(RtlProcessHeap(), 0, reparse);
        CloseHandle(h);
        return FALSE;
    }

    substituteName.MaximumLength = substituteName.Length =
            reparse->MountPointReparseBuffer.SubstituteNameLength;
    substituteName.Buffer = (PWSTR)
            ((PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
             reparse->MountPointReparseBuffer.SubstituteNameOffset);

    if (!MOUNTMGR_IS_NT_VOLUME_NAME_WB(&substituteName)) {
        RtlFreeHeap(RtlProcessHeap(), 0, reparse);
        CloseHandle(h);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    reparse->ReparseDataLength = 0;

    b = DeviceIoControl(h, FSCTL_DELETE_REPARSE_POINT, reparse,
                        REPARSE_DATA_BUFFER_HEADER_SIZE, NULL, 0, &bytes,
                        NULL);

    CloseHandle(h);

    if (b) {
        substituteName.Buffer[1] = '\\';
        substituteName.Buffer[substituteName.Length/sizeof(WCHAR)] = 0;
        NotifyMountMgr(lpszVolumeMountPoint, substituteName.Buffer,
                       FALSE);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, reparse);

    return b;
}

BOOL
WINAPI
GetVolumePathNameA(
    LPCSTR lpszFileName,
    LPSTR lpszVolumePathName,
    DWORD cchBufferLength
    )

{
    PUNICODE_STRING unicodeFileName;
    ANSI_STRING     ansiVolumePathName;
    UNICODE_STRING  unicodeVolumePathName;
    BOOL            b;
    NTSTATUS        status;

    unicodeFileName = Basep8BitStringToStaticUnicodeString(lpszFileName);
    if (!unicodeFileName) {
        return FALSE;
    }

    ansiVolumePathName.Buffer = lpszVolumePathName;
    ansiVolumePathName.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumePathName.Buffer = NULL;
    unicodeVolumePathName.MaximumLength = 0;

    try {

        unicodeVolumePathName.MaximumLength =
                (ansiVolumePathName.MaximumLength + 1)*sizeof(WCHAR);
        unicodeVolumePathName.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumePathName.MaximumLength);
        if (!unicodeVolumePathName.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        b = GetVolumePathNameW(unicodeFileName->Buffer,
                               unicodeVolumePathName.Buffer,
                               cchBufferLength);

        if (b) {

            RtlInitUnicodeString(&unicodeVolumePathName,
                                 unicodeVolumePathName.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumePathName,
                                                    &unicodeVolumePathName,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                return FALSE;
            }

            ansiVolumePathName.Buffer[ansiVolumePathName.Length] = 0;
        }

    } finally {

        if (unicodeVolumePathName.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumePathName.Buffer);
        }
    }

    return b;
}

BOOL
WINAPI
GetVolumePathNameW(
    LPCWSTR lpszFileName,
    LPWSTR lpszVolumePathName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine will return a full path whose prefix is the longest prefix
    that represents a volume.

Arguments:

    lpszFileName        - Supplies the file name.

    lpszVolumePathName  - Returns the volume path name.

    cchBufferLength     - Supplies the volume path name buffer length.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    DWORD           fullPathLength;
    PWSTR           fullPath, p;
    WCHAR           c;
    UNICODE_STRING  name, dosName, prefix;
    BOOL            b, resultOfOpen;
    PWSTR           volumeName;
    DWORD           i;

    fullPathLength = GetFullPathNameW(lpszFileName, 0, NULL, NULL);
    if (!fullPathLength) {
        return FALSE;
    }
    fullPathLength += 10;

    fullPath = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                               fullPathLength*sizeof(WCHAR));
    if (!fullPath) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (!GetFullPathNameW(lpszFileName, fullPathLength, fullPath, &p)) {
        RtlFreeHeap(RtlProcessHeap(), 0, fullPath);
        return FALSE;
    }

    RtlInitUnicodeString(&name, fullPath);

    //
    // Append a trailing backslash to start the search.
    //

    if (name.Buffer[(name.Length/sizeof(WCHAR)) - 1] != '\\') {
        name.Length += sizeof(WCHAR);
        name.Buffer[(name.Length/sizeof(WCHAR)) - 1] = '\\';
        name.Buffer[name.Length/sizeof(WCHAR)] = 0;
    }

    volumeName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!volumeName) {
        RtlFreeHeap(RtlProcessHeap(), 0, fullPath);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    p = NULL;
    c = 0;

    for (;;) {

        b = BasepGetVolumeNameForVolumeMountPoint(
                name.Buffer, volumeName, MAXIMUM_REPARSE_DATA_BUFFER_SIZE/
                sizeof(WCHAR), &resultOfOpen);
        if (b) {
            break;
        }

        if (!resultOfOpen && GetLastError() == ERROR_ACCESS_DENIED) {
            resultOfOpen = TRUE;
        }

        if (*volumeName) {
            RtlFreeHeap(RtlProcessHeap(), 0, fullPath);

            if (volumeName[0] == '\\' && volumeName[1] == '?' &&
                volumeName[2] == '?' && volumeName[3] == '\\') {

                if (volumeName[4] && volumeName[5] == ':') {
                    RtlInitUnicodeString(&name, volumeName);
                    MoveMemory(volumeName, volumeName + 4,
                               name.Length - 3*sizeof(WCHAR));
                } else {
                    volumeName[1] = '\\';
                }

                b = GetVolumePathNameW(volumeName, lpszVolumePathName,
                                       cchBufferLength);

            } else {

                RtlInitUnicodeString(&name, volumeName);
                RtlInitUnicodeString(&prefix, L"\\\\?\\GLOBALROOT");
                dosName.Length = name.Length + prefix.Length;
                dosName.MaximumLength = dosName.Length + sizeof(WCHAR);
                dosName.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                                 MAKE_TAG(TMP_TAG),
                                                 dosName.MaximumLength);
                if (!dosName.Buffer) {
                    RtlFreeHeap(RtlProcessHeap(), 0, volumeName);
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }

                CopyMemory(dosName.Buffer, prefix.Buffer, prefix.Length);
                CopyMemory((PCHAR) dosName.Buffer + prefix.Length,
                           name.Buffer, name.Length);
                dosName.Buffer[dosName.Length/sizeof(WCHAR)] = 0;

                b = GetVolumePathNameW(dosName.Buffer, lpszVolumePathName,
                                       cchBufferLength);

                RtlFreeHeap(RtlProcessHeap(), 0, dosName.Buffer);
            }

            RtlFreeHeap(RtlProcessHeap(), 0, volumeName);

            return b;
        }

        if (!resultOfOpen && p) {
            *p = c;
            RtlInitUnicodeString(&name, fullPath);
            break;
        }

        if (name.Length <= sizeof(WCHAR)) {
            break;
        }

        for (i = name.Length/sizeof(WCHAR) - 2; i > 0; i--) {
            if (name.Buffer[i] == '\\') {
                break;
            }
        }
        if (!i) {
            break;
        }

        if (resultOfOpen) {
            p = &name.Buffer[i + 1];
            c = *p;
            *p = 0;
        } else {
            name.Buffer[i + 1] = 0;
        }

        RtlInitUnicodeString(&name, fullPath);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, volumeName);

    if (!resultOfOpen && !p) {
        RtlFreeHeap(RtlProcessHeap(), 0, fullPath);
        return FALSE;
    }

    if (cchBufferLength*sizeof(WCHAR) < name.Length + sizeof(WCHAR)) {
        RtlFreeHeap(RtlProcessHeap(), 0, fullPath);
        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        return FALSE;
    }

    RtlCopyMemory(lpszVolumePathName, name.Buffer, name.Length);
    lpszVolumePathName[name.Length/sizeof(WCHAR)] = 0;
    RtlFreeHeap(RtlProcessHeap(), 0, fullPath);

    return TRUE;
}

BOOL
GetVolumePathNamesForVolumeNameA(
    LPCSTR lpszVolumeName,
    LPSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    )

{
    PUNICODE_STRING unicodeVolumeName;
    ANSI_STRING     ansiVolumePathNames;
    UNICODE_STRING  unicodeVolumePathNames;
    BOOL            b;
    NTSTATUS        status;
    DWORD           len;

    unicodeVolumeName = Basep8BitStringToStaticUnicodeString(lpszVolumeName);
    if (!unicodeVolumeName) {
        return FALSE;
    }

    ansiVolumePathNames.Buffer = lpszVolumePathNames;
    ansiVolumePathNames.MaximumLength = (USHORT) cchBufferLength;
    unicodeVolumePathNames.Buffer = NULL;
    unicodeVolumePathNames.MaximumLength = 0;

    try {

        unicodeVolumePathNames.MaximumLength =
                ansiVolumePathNames.MaximumLength*sizeof(WCHAR);
        if (unicodeVolumePathNames.MaximumLength) {
            unicodeVolumePathNames.Buffer =
                    RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                    unicodeVolumePathNames.MaximumLength);
            if (!unicodeVolumePathNames.Buffer) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
        } else {
            unicodeVolumePathNames.Buffer = NULL;
        }

        b = GetVolumePathNamesForVolumeNameW(unicodeVolumeName->Buffer,
                                             unicodeVolumePathNames.Buffer,
                                             cchBufferLength, &len);

        if (b || GetLastError() == ERROR_MORE_DATA) {

            if (b) {
                unicodeVolumePathNames.Length = (USHORT) len*sizeof(WCHAR);
            } else {
                unicodeVolumePathNames.Length = (USHORT)
                        cchBufferLength*sizeof(WCHAR);
            }

            status = BasepUnicodeStringTo8BitString(&ansiVolumePathNames,
                                                    &unicodeVolumePathNames,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                return FALSE;
            }

            if (lpcchReturnLength) {
                if (b) {
                    *lpcchReturnLength = ansiVolumePathNames.Length/sizeof(WCHAR);
                } else {
                    // Give an upper bound for the ANSI length since we
                    // don't actually know it.
                    *lpcchReturnLength = 2*len;
                }
            }
        }

    } finally {

        if (unicodeVolumePathNames.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumePathNames.Buffer);
        }
    }

    return b;
}

BOOL
GetVolumePathNamesForVolumeNameW(
    LPCWSTR lpszVolumeName,
    LPWSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    )

/*++

Routine Description:

    This routine returns a Multi-Sz list of volume path names for the
    given volume name.  The returned 'lpcchReturnLength' will include the
    extra tailing null characteristic of a Multi-Sz unless ERROR_MORE_DATA
    is returned in which case the list returned is as long as possible
    and may contain a part of a volume path.

Arguments:

    lpszVolumeName      - Supplies the volume name.

    lpszVolumePathNames - Returns the volume path names.

    cchBufferLength     - Supplies the size of the return buffer.

    lpcchReturnLength   - Returns the number of characters copied back to the
                            return buffer on success or the total number
                            of characters necessary for the buffer on
                            ERROR_MORE_DATA.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING          unicodeVolumeName;
    PMOUNTMGR_TARGET_NAME   targetName;
    HANDLE                  h;
    BOOL                    b;
    DWORD                   bytes, len, i, j, n;
    PMOUNTMGR_VOLUME_PATHS  volumePaths;

    RtlInitUnicodeString(&unicodeVolumeName, lpszVolumeName);
    if (unicodeVolumeName.Buffer[unicodeVolumeName.Length/sizeof(WCHAR) - 1] !=
        '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
    }

    if (!MOUNTMGR_IS_DOS_VOLUME_NAME_WB(&unicodeVolumeName)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    targetName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                 MAX_PATH*sizeof(WCHAR));
    if (!targetName) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    ZeroMemory(targetName, MAX_PATH*sizeof(WCHAR));
    targetName->DeviceNameLength = unicodeVolumeName.Length - sizeof(WCHAR);
    RtlCopyMemory(targetName->DeviceName, lpszVolumeName,
                  targetName->DeviceNameLength);
    targetName->DeviceName[1] = '?';

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, 0, FILE_SHARE_READ |
                    FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, targetName);
        return FALSE;
    }

    len = sizeof(MOUNTMGR_VOLUME_PATHS);
    volumePaths = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), len);
    if (!volumePaths) {
        CloseHandle(h);
        RtlFreeHeap(RtlProcessHeap(), 0, targetName);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    for (;;) {

        b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS,
                            targetName, MAX_PATH*sizeof(WCHAR), volumePaths,
                            len, &bytes, NULL);
        if (b) {
            break;
        }

        if (GetLastError() != ERROR_MORE_DATA) {
            RtlFreeHeap(RtlProcessHeap(), 0, volumePaths);
            RtlFreeHeap(RtlProcessHeap(), 0, targetName);
            return FALSE;
        }

        len = sizeof(MOUNTMGR_VOLUME_PATHS) + volumePaths->MultiSzLength;
        RtlFreeHeap(RtlProcessHeap(), 0, volumePaths);
        volumePaths = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                      len);
        if (!volumePaths) {
            CloseHandle(h);
            RtlFreeHeap(RtlProcessHeap(), 0, targetName);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, targetName);

    n = 0;
    for (i = 0, j = 0; i < cchBufferLength &&
         j < volumePaths->MultiSzLength/sizeof(WCHAR) - 1; i++, j++) {

        if (!volumePaths->MultiSz[j]) {
            n++;
            lpszVolumePathNames[i++] = '\\';
            if (i == cchBufferLength) {
                break;
            }
        }

        lpszVolumePathNames[i] = volumePaths->MultiSz[j];
    }

    for (; j < volumePaths->MultiSzLength/sizeof(WCHAR) - 1; j++) {
        if (!volumePaths->MultiSz[j]) {
            n++;
        }
    }

    if (i < cchBufferLength) {
        b = TRUE;
        lpszVolumePathNames[i++] = 0;
        if (lpcchReturnLength) {
            *lpcchReturnLength = i;
        }
    } else {
        b = FALSE;
        SetLastError(ERROR_MORE_DATA);
        if (lpcchReturnLength) {
            *lpcchReturnLength = volumePaths->MultiSzLength/sizeof(WCHAR) + n;
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, volumePaths);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\w98stubs.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:


Abstract:

    Stubs for Win98 api's.  Actual implementation is unimportant
    since the functions are only used to generate the implib.

Author:

    Bryan Tuttle (bryant) 5-Aug-1998

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

DWORD
GetHandleContext(HANDLE handle)
{
    KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL, "Unsupported API - kernel32!GetHandleContext() called\n"));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL
SetHandleContext(HANDLE handle, DWORD context)
{
    KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL, "Unsupported API - kernel32!SetHandleContext() called\n"));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

HANDLE
CreateSocketHandle(void)
{
    KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL, "Unsupported API - kernel32!CreateSocketHandle() called\n"));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\winperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    winperf.c

Abstract:

    Test program for checking performance of Win32 API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "basedll.h"

//
// Define local types.
//
#define EVENT_PAIR_ITERATIONS               20000
#define NULL_API_ITERATIONS                 10000
#define DOMAIN_LOCK_ITERATIONS              40000
#define CRITICAL_SECTION_LOCK_ITERATIONS    80000
#define MUTEX_LOCK_ITERATIONS               20000

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    );
VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    );


VOID
GetTickCountTest(
    VOID
    );

VOID
EventPairTest (
    VOID
    );

VOID
QuickLpcTest (
    VOID
    );

VOID
SlowLpcTest (
    VOID
    );

VOID
DomainLockTest (
    VOID
    );

VOID
CriticalSectionLockTest (
    VOID
    );

VOID
MutexLockTest (
    VOID
    );


DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    (VOID)argc;
    (VOID)argv;
    (VOID)envp;

    GetTickCountTest();
    EventPairTest();
    QuickLpcTest();
    SlowLpcTest();
    DomainLockTest();
    CriticalSectionLockTest();
    MutexLockTest();
    ExitProcess(0);
}

HANDLE EventPair;

VOID
EventPairClient(
    LPVOID ThreadParameter
    )
{
    NTSTATUS Status;

    //
    // Client does a NtSetLowWaitHighEventPair
    //

    do {
        Status = NtSetLowWaitHighEventPair(EventPair);
        }
    while (NT_SUCCESS(Status));

    ExitThread((DWORD)Status);
}


VOID
EventPairTest (
    VOID
    )

{
    ULONG Index;
    PERFINFO PerfInfo;
    HANDLE Thread;
    DWORD tid;

    ASSERT(NT_SUCCESS(NtCreateEventPair(&EventPair,EVENT_PAIR_ALL_ACCESS,NULL)));
    Thread = CreateThread(NULL,0L,EventPairClient,(LPVOID)99,0,&tid);

    Index = EVENT_PAIR_ITERATIONS;
    StartBenchMark("Event Pair Benchmark",
                   EVENT_PAIR_ITERATIONS, &PerfInfo);

    NtWaitLowEventPair(EventPair);
    while (Index--) {
        NtSetHighWaitLowEventPair(EventPair);
        }
    FinishBenchMark(&PerfInfo);

    NtAlertThread(Thread);
    CloseHandle(Thread);
    CloseHandle(EventPair);
    return;
}

VOID
GetTickCountTest (
    VOID
    )

{
    ULONG Index;
    PERFINFO PerfInfo;
    HANDLE Thread;

    Index = EVENT_PAIR_ITERATIONS;
    StartBenchMark("Get Tick Count Benchmark",
                   EVENT_PAIR_ITERATIONS, &PerfInfo);
    while (Index--) {
        GetTickCount();
        }
    FinishBenchMark(&PerfInfo);

    return;
}

VOID
QuickLpcTest (
    VOID
    )
{

    ULONG Index;
    PERFINFO PerfInfo;
    PCSR_NULLAPICALL_MSG Msg;
    QLPC_ACTION Action;


    CsrClientThreadConnect();

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Quick Lpc Benchmark (no data)",
                   NULL_API_ITERATIONS, &PerfInfo);
    while (Index--) {
        Msg = (PCSR_NULLAPICALL_MSG)
              CsrClientPushMessage( CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                         BasepNullApiCall
                                                       ),
                                    sizeof( CSR_NULLAPICALL_MSG )
                                  );
        Msg->CountArguments = 0;
	ASSERT( CsrClientSendMessage( (PVOID) Msg, &Action ) == 0 );
        CsrClientPopMessage( (PVOID) Msg );
        }

    FinishBenchMark(&PerfInfo);

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Quick Lpc Benchmark (40 bytes of data)",
                   NULL_API_ITERATIONS, &PerfInfo);

    while (Index--) {
        Msg = (PCSR_NULLAPICALL_MSG)
              CsrClientPushMessage( CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                         BasepNullApiCall
                                                       ),
                                    sizeof( CSR_NULLAPICALL_MSG )
                                  );
        Msg->CountArguments = -10;
        Msg->FastArguments[ 0 ] = 0;
        Msg->FastArguments[ 1 ] = 1;
        Msg->FastArguments[ 2 ] = 2;
        Msg->FastArguments[ 3 ] = 3;
        Msg->FastArguments[ 4 ] = 4;
        Msg->FastArguments[ 5 ] = 5;
        Msg->FastArguments[ 6 ] = 6;
        Msg->FastArguments[ 7 ] = 7;
        Msg->FastArguments[ 8 ] = 8;
        Msg->FastArguments[ 9 ] = 9;

	ASSERT( CsrClientSendMessage( (PVOID) Msg, &Action ) == 10 );
        CsrClientPopMessage( (PVOID) Msg );
        }
    FinishBenchMark(&PerfInfo);

    return;
}

ULONG
BaseNullApiCall(
    IN LONG CountArguments,
    IN PCHAR *Arguments OPTIONAL
    );

ULONG NullApiImmediateArguments[] = {
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9
};

PCHAR NullApiTextArguments[] = {
    "123456789012345678901234567890",
    "123456789012345678901234567890",
    "123456789012345678901234567890123456789012345678901234567890",
    NULL
};


VOID
SlowLpcTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Normal Lpc Benchmark (no data)",
                   NULL_API_ITERATIONS, &PerfInfo);
    while (Index--) {
        BaseNullApiCall( 0, (PCHAR *)NULL );
        }
    FinishBenchMark(&PerfInfo);

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Normal Lpc Benchmark (64 bytes of immediate data)",
                   NULL_API_ITERATIONS, &PerfInfo);
    while (Index--) {
        BaseNullApiCall( -10, (PCHAR *)NullApiImmediateArguments );
        }
    FinishBenchMark(&PerfInfo);

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Normal Lpc Benchmark (124 bytes of data)",
                   NULL_API_ITERATIONS, &PerfInfo);
    while (Index--) {
        BaseNullApiCall( 3, NullApiTextArguments );
        }
    FinishBenchMark(&PerfInfo);

    return;
}

VOID
DomainLockTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Domain Lock Benchmark",
                   DOMAIN_LOCK_ITERATIONS, &PerfInfo);

    for (Index = 0; Index < DOMAIN_LOCK_ITERATIONS; Index += 1) {
        NtLockDisplayGroup(0);
        NtUnlockDisplayGroup(0);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    return;
}

VOID
CriticalSectionLockTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;
    CRITICAL_SECTION Crit;

    InitializeCriticalSection(&Crit);

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Critical Section Benchmark",
                   CRITICAL_SECTION_LOCK_ITERATIONS, &PerfInfo);

    //
    // Repeatedly call a short system service.
    //

    for (Index = 0; Index < CRITICAL_SECTION_LOCK_ITERATIONS; Index += 1) {
        EnterCriticalSection(&Crit);
        LeaveCriticalSection(&Crit);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    return;
}


VOID
MutexLockTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;
    HANDLE Mutex;

    Mutex = CreateMutex(NULL,FALSE,NULL);

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Mutex Benchmark",
                   MUTEX_LOCK_ITERATIONS, &PerfInfo);

    //
    // Repeatedly call a short system service.
    //

    for (Index = 0; Index < MUTEX_LOCK_ITERATIONS; Index += 1) {
        WaitForSingleObject(Mutex,-1);
        ReleaseMutex(Mutex);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    return;
}

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    LARGE_INTEGER Duration;
    ULONG Length;
    ULONG Performance;

    //
    // Print results and announce end of test.
    //

    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StopTime);
    Duration = RtlLargeIntegerSubtract(PerfInfo->StopTime, PerfInfo->StartTime);
    Length = Duration.LowPart / 10000;
    DbgPrint("        Test time in milliseconds %d\n", Length);
    DbgPrint("        Number of iterations      %d\n", PerfInfo->Iterations);
    Performance = PerfInfo->Iterations * 1000 / Length;
    DbgPrint("        Iterations per second     %d\n", Performance);
    DbgPrint("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    )

{

    //
    // Announce start of test and the number of iterations.
    //

    DbgPrint("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StartTime);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\winlzexp.c ===
/*
** winlzexp.c - Windows LZExpand library routines for manipulating compressed
**              files.
**
** Author:  DavidDi
*/


/*
** Notes:
** -----
**
** The LZInit() function returns either DOS handles or LZFile struct
** identifiers of some kind, depending upon how it is called.  The LZ
** functions LZSeek(), LZRead(), and LZClose() needed some way to
** differentiate between DOS file handles and the LZFile struct identifiers.
** As the functions stand now, they use DOS file handles as themselves, and
** table offsets as LZFile identifiers.  The table offsets are incremented by
** some base value, LZ_TABLE_BIAS, in order to push their values past all
** possible DOS file handle values.  The table offsets (- LZ_TABLE_BIAS) are
** used as indices in rghLZFileTable[] to retrieve a global handle to an
** LZFile struct.  The table of global handles is allocated statically from
** the DLL's data segment.  The LZFile struct's are allocated from global
** heap space and are moveable.  This scheme might also be implemented as a
** linked list of global handles.
**
** Now the resulting benefit from this scheme is that DOS file handles and
** LZFile struct identifiers can be differentiated, since DOS file handles
** are always < LZ_TABLE_BIAS, and LZFile struct identifiers are always
** >= LZ_TABLE_BIAS.  This dichotomy may be used in macros, like the sample
** ones provided in lzexpand.h, to select the appropriate function to call
** (e.g., LZSeek() or _llseek()) in order to avoid the overhead of an extra
** function call for uncompressed files.  LZSeek(), LZRead(), and LZClose()
** are, however, "smart" enough to figure out whether they are dealing with
** DOS file handles or table offsets, and take action appropriately.  As an
** extreme example, LZOpenFile(), LZSeek(), LZRead, and LZClose() can be used
** as replacements for OpenFile(), _llseek(), _lread(), and _lclose.  In this
** case, the program using the DLL functions could call them without ever
** caring whether the files it was reading were LZ compressed or not.
*/


/* WIN32 MODS

**  Since the above is a DOS only hack, I have to change the logic for
** for the 0-255 file handle deal'o.  The original code, tests greater than
** LZ_TABLE_BIAS for file structures.  What I will do, is convert file handles
** returned from OpenFile, to a range 0-255.  Once the test is complete, I'll
** use the file handle as an offset into a 255 element array, which will
** contain the WIN32 file handle.  So there will be an additional array
** fhWin32File[255], which will be allocated sequencially starting at 0.
** Unfortunately, this means everywhere the file handle is used, must be converted
*/

// Headers
///////////
#include <basedll.h>
#define LZA_DLL
#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"
#include "lzcommon.h"

#include "lzpriv.h"
#include "wchar.h"

#if DEBUG
#include "stdio.h"
#endif

// Globals
///////////

// Semaphore for File Table allocation
RTL_CRITICAL_SECTION semTable;
BOOL fCSInit = FALSE;

// table of handles to LZFile structs
HANDLE rghLZFileTable[MAX_LZFILES] = {0};

// next free entry in rghLZFileTable[]
static INT iNextLZFileEntry = 0;

HFILE fhWin32File[MAX_LZFILES] = {0};

/*
** int  APIENTRY LZInit(int hWin32File);
**
** Sets up LZFile struct for a file that has already been opened by
** OpenFile().
**
** Arguments:  hWin32File - source DOS file handle
**
** Returns:    int - LZFile struct table offset or DOS file handle if
**                   successful.  One of the LZERROR_ codes if unsuccessful.
**
** Globals:    iNextLZFile entry advanced, or returned to beginning from end.
*/
INT  APIENTRY LZInit(INT hWin32File)
{
   HANDLE hLZFile;            // handle to new LZFile struct
   LZFile *lpLZ;          // pointer to new LZFile struct
   FH FHComp;                 // header info structure from input file
   BOOL bHdr;                 // holds GetHdr() return value
   INT iTableIndex,           // holds rghLZFileTable[] slot to be filled by
                              //    new LZFile struct handle
       iStartEntry;           // original value of iNextLZFileEntry

   LONG cblInSize = 0;
   INT nRet;

   if (!fCSInit) {
       if (!NT_SUCCESS(RtlInitializeCriticalSection(&semTable))) {
           return LZERROR_GLOBALLOC;
       }
       fCSInit = TRUE;
   }

   // Did the read succeed?
   if ((bHdr = GetHdr((FH *)&FHComp, hWin32File, &cblInSize)) != TRUE
       && cblInSize >= (LONG)HEADER_LEN) {

      return(LZERROR_BADINHANDLE);
   }

   // Check for uncompressed input file.
   if (bHdr != TRUE || IsCompressed(& FHComp) != TRUE)
   {
      // This is an uncompressed file - rewind it.
      if (FSEEK(hWin32File, 0L, SEEK_SET) != 0L) {
         return(LZERROR_BADINHANDLE);
      }
      else {
         // And return DOS file handle.
        return(ConvertWin32FHToDos(hWin32File));
     }
   }

   // Check compression algorithm used.
   if (RecognizeCompAlg(FHComp.byteAlgorithm) != TRUE) {
      return(LZERROR_UNKNOWNALG);
   }

   // Find next free rghLZFileTable[] entry.  N.b., we depend upon LZClose()
   // to free unused entries up.
   RtlEnterCriticalSection(&semTable);

   iStartEntry = iNextLZFileEntry;

   while (rghLZFileTable[iNextLZFileEntry] != NULL)
   {
      if (++iNextLZFileEntry >= MAX_LZFILES)
         // Return to beginning of table.
         iNextLZFileEntry = 0;

      if (iNextLZFileEntry == iStartEntry) {
         // We've gone full circle through rghLZFileTable[].
         // It's full, so bail out.
         nRet = LZERROR_GLOBALLOC;
         goto LZInitExit;
      }
   }

   // Keep track of the rghLZFileTable() slot to be filled by a handle to the
   // new LZFile struct.
   iTableIndex = iNextLZFileEntry;

   // Allocate global storage for the new LZFile struct, initializing all
   // fields to 0.

   hLZFile = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (DWORD)sizeof(LZFile));
   if (!hLZFile) {

      nRet = LZERROR_GLOBALLOC;
      goto LZInitExit;
   }

   // Lock that baby up.
   if ((lpLZ = (LZFile *)GlobalLock(hLZFile)) == NULL)
   {
      GlobalFree(hLZFile);

      nRet =LZERROR_GLOBLOCK;
      goto LZInitExit;
   }

   // Initialize the new LZFile struct's general information fields.
   lpLZ->dosh = hWin32File;
   lpLZ->byteAlgorithm = FHComp.byteAlgorithm;
   lpLZ->wFlags = 0;
   lpLZ->cbulUncompSize = FHComp.cbulUncompSize;
   lpLZ->cbulCompSize = FHComp.cbulCompSize;
   lpLZ->lCurSeekPos = 0L;

   // LZRead/LZSeeks expansion data is kept on a per file basis
   lpLZ->pLZI = NULL;

   // Enter new handle in table of handles.
   rghLZFileTable[iTableIndex] = hLZFile;

   /* WIN32 NOTE, dont need convert below, as forces a non file handle
    * to the API.
    */

   GlobalUnlock(hLZFile);

   // Advance to next free entry.
   if (++iNextLZFileEntry >= MAX_LZFILES)
      iNextLZFileEntry = 0;

   nRet = LZ_TABLE_BIAS + iTableIndex;

LZInitExit:

   RtlLeaveCriticalSection(&semTable);

   // Return rghLZFileTable[] offset of the new LZFile struct's handle's
   // entry + the table bias.
   return(nRet);
}


/*
** int  APIENTRY GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer);
**
** Looks in the header of a compressed file to find its original expanded
** name.
**
** Arguments:  lpszSource - name of input file
**             lpszBuffer - pointer to a buffer that will be filled in with
**                          the expanded name of the compressed source file
**
** Returns:    int - TRUE if successful.  One of the LZERROR_ codes if
**                   unsuccessful.
**
** Globals:    none
*/
INT  APIENTRY GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer)
{
   INT doshSource,         // source DOS file handle
       bHdr;               // holds GetHdr() return value
   FH FHComp;              // header info structure from input file
   OFSTRUCT ofOpenBuf;     // source struct for OpenFile() call
   LONG cblInSize = 0;

   // Try to open the source file.
   if ((doshSource = (HFILE)MOpenFile(lpszSource, (LPOFSTRUCT)(& ofOpenBuf), OF_READ))
       == -1)
      return(LZERROR_BADVALUE);

   // Get the compressed file header.
   if ((bHdr = GetHdr((FH *)&FHComp, doshSource, &cblInSize)) != TRUE
       && cblInSize >= (LONG)HEADER_LEN)
   {
      FCLOSE(doshSource);
      return(LZERROR_BADVALUE);
   }

   // Close source file.
   FCLOSE(doshSource);

   // Return expanded name same as source name for uncompressed files.
   STRCPY(lpszBuffer, lpszSource);

   // Check for compressed input file.
   if (bHdr == TRUE && IsCompressed(& FHComp) == TRUE)
      MakeExpandedName(lpszBuffer, FHComp.byteExtensionChar);

   return(TRUE);
}

/*
** int  APIENTRY GetExpandedNameW(LPSTR lpszSource, LPSTR lpszBuffer);
**
** Wide Character version of GetExpandedName.  Converts the filename to
** the ANSI Character set and calls the ANSI version.
**
*/
INT  APIENTRY GetExpandedNameW(LPWSTR lpszSource, LPWSTR lpszBuffer)
{
    UNICODE_STRING TempW;
    ANSI_STRING TempA;
    NTSTATUS Status;
    NTSTATUS StatusR;
    CHAR szBuffer[MAX_PATH];


    TempW.Buffer = lpszSource;
    TempW.Length = wcslen(lpszSource)*sizeof(WCHAR);
    TempW.MaximumLength = TempW.Length + sizeof(WCHAR);

    TempA.Buffer = szBuffer;
    TempA.MaximumLength = MAX_PATH;
    StatusR = RtlUnicodeStringToAnsiString(&TempA, &TempW, FALSE);
    if (!NT_SUCCESS(StatusR))
        return LZERROR_GLOBALLOC;

    Status = GetExpandedNameA(szBuffer, (LPSTR)lpszBuffer);

    if (Status != -1) {
        strcpy(szBuffer, (LPSTR)lpszBuffer);
        TempA.Length = (USHORT) strlen(szBuffer);
        TempA.MaximumLength = TempA.Length+sizeof(CHAR);

        TempW.Buffer = lpszBuffer;
        TempW.MaximumLength = MAX_PATH;
        StatusR = RtlAnsiStringToUnicodeString(&TempW, &TempA, FALSE);
        if (!NT_SUCCESS(StatusR))
            return LZERROR_GLOBALLOC;
    }

    return Status;
}


//
// INT  LZCreateFileW(LPCWSTR lpFileName, DWORD fdwAccess)
//
// Opens a file (using CreateFile) and sets up an LZFile struct for
// expanding it.
//
// Arguments:  lpFileName  - name of input file
//             fdwAccess   - CreateFile access type - (e.g. GENERIC_READ)
//             fdwShareMode - Share mode  - (e.g. FILE_SHARE_READ)
//             fdwCreate - Action to be taken - (e.g. OPEN_EXISTING)
//
// Returns:    INT - LZFile struct table offset or WIN32 file HANDLE if
//             successful.  One of the LZERROR_ codes if unsuccessful.
//
INT
LZCreateFileW(
    LPWSTR lpFileName,
    DWORD fdwAccess,
    DWORD fdwShareMode,
    DWORD fdwCreate,
    LPWSTR lpCompressedName)
{
    HANDLE hWin32;           // WIN32 file HANDLE returned from CreateFileW()
    INT lzh;                 // LZ File struct ID returned from LZInit()
    static WCHAR pszCompName[MAX_PATH];  // buffer for compressed name

    lstrcpyW((LPWSTR)pszCompName, lpFileName);

    // Just for Vlad, only try to open the compressed version of the original
    // file name if we can't find the original file.  All other errors get
    // returned immediately.

    hWin32 = CreateFileW(pszCompName, fdwAccess, fdwShareMode, NULL, fdwCreate,
        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hWin32 == INVALID_HANDLE_VALUE) {
        DWORD dwErr = GetLastError();

        if (dwErr == ERROR_FILE_NOT_FOUND) {

            // Let's try to open the file of the corresponding compressed name.
            MakeCompressedNameW((LPWSTR)pszCompName);

            hWin32 = CreateFileW(pszCompName, fdwAccess, fdwShareMode,
                NULL, fdwCreate, FILE_ATTRIBUTE_NORMAL, NULL);
        }
    }

     // Error opening file?
     if (hWin32 == INVALID_HANDLE_VALUE) {
        return(LZERROR_BADINHANDLE);
     }

    // Don't call LZinit() on files opened in other read only mode

    if (fdwCreate != OPEN_EXISTING) {
       lzh = ConvertWin32FHToDos((HFILE)((DWORD_PTR)hWin32));
       if (lzh == LZERROR_GLOBALLOC) {
          CloseHandle(hWin32);
       }

       return(lzh);
    }

    // File has been opened with read-only action - call LZInit() to detect
    // whether or not it's an LZ file, and to create structures for expansion
    // if it is an LZ file.
    lzh = LZInit((INT)((DWORD_PTR)hWin32));

    // Close DOS file handle if LZInit() is unsuccessful.
    if (lzh < 0)
       CloseHandle(hWin32);

    // Pass real file name to caller
    //
    // we believe the caller have enough buffer.
    //
    if( lpCompressedName != NULL )
        lstrcpyW(lpCompressedName,pszCompName);

    // Return LZ struct ID or LZERROR_ code.
    return(lzh);
}


/*
** int  APIENTRY LZOpenFileA(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuf,
**                           WORD wStyle);
**
** Opens a file and sets up an LZFile struct for expanding it.
**
** Arguments:  lpFileName  - name of input file
**             lpReOpenBuf - pointer to LPOFSTRUCT to be used by OpenFile()
**             wStyle      - OpenFile() action to take
**
** Returns:    int - LZFile struct table offset or DOS file handle if
**                   successful.  One of the LZERROR_ codes if unsuccessful.
**
** Globals:    none
*/
INT APIENTRY LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
{
   INT dosh,                     // DOS file handle returned from OpenFile()
       lzh;                      // LZ File struct ID returned from LZInit()
   CHAR pszCompName[MAX_PATH];   // buffer for compressed name

   STRCPY((LPSTR)pszCompName, lpFileName);

   // Just for Vlad, only try to open the compressed version of the original
   // file name if we can't find the original file.  All other errors get
   // returned immediately.

   if ((dosh = OpenFile(pszCompName, lpReOpenBuf, wStyle)) == -1 &&
       lpReOpenBuf->nErrCode == DEE_FILENOTFOUND)
   {
      // Let's try to open the file of the corresponding compressed name.
      MakeCompressedName(pszCompName);

      dosh = (HFILE) MOpenFile((LPSTR)pszCompName, lpReOpenBuf, wStyle);
   }

   // Error opening file?
   if (dosh == -1)
      return(LZERROR_BADINHANDLE);

   // Don't call LZinit() on files opened in other than O_RDONLY mode.
   // Ignore the SHARE bits.
   if ((wStyle & STYLE_MASK) != OF_READ) {
      lzh = ConvertWin32FHToDos(dosh);
      if (lzh == LZERROR_GLOBALLOC) {
         FCLOSE(dosh);
      }
      return(lzh);
   }

   // File has been opened with OF_READ style - call LZInit() to detect
   // whether or not it's an LZ file, and to create structures for expansion
   // if it is an LZ file.
   lzh = LZInit(dosh);

   // Close DOS file handle if LZInit() is unsuccessful.
   if (lzh < 0)
      FCLOSE(dosh);

   // Return LZ struct ID or LZERROR_ code.
   return(lzh);
}

/*
** int  APIENTRY LZOpenFileW(LPCWSTR lpFileName, LPOFSTRUCT lpReOpenBuf,
**                           WORD wStyle);
**
** Wide Character version of LZOpenFile.  Converts the filename to
** the ANSI Character set and calls the ANSI version.
**
*/
INT APIENTRY LZOpenFileW(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
{
    UNICODE_STRING FileName;
    ANSI_STRING AnsiString;
    NTSTATUS StatusR;
    CHAR szFileName[MAX_PATH];


    FileName.Buffer = lpFileName;
    FileName.Length = wcslen(lpFileName)*sizeof(WCHAR);
    FileName.MaximumLength = FileName.Length + sizeof(WCHAR);

    AnsiString.Buffer = szFileName;
    AnsiString.MaximumLength = MAX_PATH;
    StatusR = RtlUnicodeStringToAnsiString(&AnsiString, &FileName, FALSE);
    if (!NT_SUCCESS(StatusR))
        return LZERROR_GLOBALLOC;

    return(LZOpenFileA(szFileName, lpReOpenBuf, wStyle));
}



/*
** LONG  APIENTRY LZSeek(int oLZFile, long lSeekTo, int nMode);
**
** Works like _llseek(), but in the expanded image of a compressed file,
** without expanding the compressed file to disk.
**
** Arguments:  oLZFile - source LZFile struct identifier or DOS file handle
**             lSeekTo - number of bytes past nMode target to seek
**             nMode   - seek mode as in _llseek()
**
** Returns:    LONG - Offset of the seek target if successful.  One of the
**                    LZERROR_ codes if unsuccessful.
**
** Globals:    none
*/
LONG APIENTRY
LZSeek(
   INT oLZFile,
   LONG lSeekTo,
   INT nMode)
{
   HANDLE hSourceStruct;      // handle to LZFile struct
   LZFile *lpLZ;          // pointer to LZFile struct
   LONG lExpSeekTarget;       // target seek offset

   // Check input LZFile struct indentifier / DOS file handle.
   if (oLZFile < 0 || oLZFile >= LZ_TABLE_BIAS + MAX_LZFILES)
      return(LZERROR_BADINHANDLE);

   // We were passed a regular DOS file handle, so just do an _llseek() on it.
   if (oLZFile < LZ_TABLE_BIAS)
      return(FSEEK(ConvertDosFHToWin32(oLZFile), lSeekTo, nMode));

   // We're dealing with a compressed file.  Get the associated LZFile struct.
   hSourceStruct = rghLZFileTable[oLZFile - LZ_TABLE_BIAS];

   if ((lpLZ = (LZFile *)GlobalLock(hSourceStruct)) == NULL)
      return(LZERROR_GLOBLOCK);

   // Figure out what our seek target is.
   if (nMode == SEEK_SET)
      lExpSeekTarget = 0L;
   else if (nMode == SEEK_CUR)
      lExpSeekTarget = lpLZ->lCurSeekPos;
   else if (nMode == SEEK_END)
      lExpSeekTarget = (LONG)lpLZ->cbulUncompSize;
   else
   {
      GlobalUnlock(hSourceStruct);
      return(LZERROR_BADVALUE);
   }

   // Add bias.
   lExpSeekTarget += lSeekTo;

   // Make sure the desired expanded file position is in the expanded file
   // bounds.  It's only an error to seek before the beginning of the file;
   // it's not an error to seek after the end of the file, as in _llseek().
   if (lExpSeekTarget < 0L)
   {
      GlobalUnlock(hSourceStruct);
      return(LZERROR_BADVALUE);
   }

   // Seek target is ok.  Set the file pointer for the expanded file image.
   lpLZ->lCurSeekPos = lExpSeekTarget;

   GlobalUnlock(hSourceStruct);

   // Return the offset of the seek target.
   return(lExpSeekTarget);
}


/*
** int  APIENTRY LZRead(int oLZFile, LPSTR lpBuf, int nCount);
**
** Works like _lread(), but in the expanded image of a compressed file,
** without expanding the compressed file to disk.
**
** Arguments:  oLZFile - source LZFile struct identifier or DOS file handle
**             lpBuf   - pointer to destination buffer for bytes read
**             nCount  - number of bytes to read
**
** Returns:    int - Number of bytes copied to destination buffer if
**                   successful.  One of the LZERROR_ codes if unsuccessful.
**
** Globals:    none
*/
INT  APIENTRY LZRead(INT oLZFile, LPSTR lpBuf, INT nCount)
{
   INT f;
   HANDLE hSourceStruct;      // handle to LZFile struct
   LZFile *lpLZ;          // pointer to LZFile struct

   INT cbWritten = 0,         // total number of bytes copied to
                              //    destination buffer
       cbCopied,              // number of bytes copied to destination
                              // buffer during each read iteration
       iCurReadPos,           // current read offset in expanded buffer
       nNumExpBufBytes;       // number of bytes in expanded data buffer
   LONG lNextDecodeTarget,    // expanded file image read target for decoding
        lStartCopyOffset,     // expanded file buffer offset where we should
                              //    start copying to destination buffer (cast
                              //    to iCurReadPos when this start position
                              //    is actually in the buffer)
        lNextExpEndOffset;    // expanded file offset of the start of the
                              //    next desired block of expanded data
   BOOL bRestartDecoding;     // flag indicating whether or not decoding
                              //    needs to be restarted, set to TRUE when
                              //    the current seek position is smaller than
                              //    the offset of the beginning of the
                              //    expanded file buffer
   BYTE *lpbyteBuf;           // byte pointer version of lpBuf

   LONG lExpBufStart;
   LONG lExpBufEnd;

   PLZINFO pLZI;

   // Check input LZFile struct indentifier / DOS file handle.
   if (oLZFile < 0 || oLZFile >= LZ_TABLE_BIAS + MAX_LZFILES)
      return(LZERROR_BADINHANDLE);

   // Can't read a negative number of bytes.
   if (nCount < 0)
      return(LZERROR_BADVALUE);

   // We were passed a regular DOS file handle, so just do an _lread() on it.
   if (oLZFile < LZ_TABLE_BIAS)
      return(FREAD(ConvertDosFHToWin32(oLZFile), lpBuf, nCount));

   // We're dealing with a compressed file.  Get the associated LZFile struct.
   hSourceStruct = rghLZFileTable[oLZFile - LZ_TABLE_BIAS];

   if ((lpLZ = (LZFile *)GlobalLock(hSourceStruct)) == NULL)
      return(LZERROR_GLOBLOCK);

   if (!(pLZI = lpLZ->pLZI)) {
      // Initialize buffers
      lpLZ->pLZI = InitGlobalBuffers(EXP_BUF_LEN, MAX_RING_BUF_LEN, IN_BUF_LEN + 1);

      if (!(pLZI = lpLZ->pLZI)) {
         return(LZERROR_GLOBALLOC);
      }

      ResetBuffers();
   }

   lExpBufStart = pLZI->cblOutSize - (LONG)(pLZI->pbyteOutBuf - pLZI->rgbyteOutBuf);
   lExpBufEnd = (LONG)(pLZI->pbyteOutBufEnd - pLZI->rgbyteOutBuf);

   // Do we need to restart decoding?
   if (! (lpLZ->wFlags & LZF_INITIALIZED))
   {
      lpLZ->wFlags |= LZF_INITIALIZED;
      bRestartDecoding = TRUE;
   }
   else if (lpLZ->lCurSeekPos < lExpBufStart)
      bRestartDecoding = TRUE;
   else
      bRestartDecoding = FALSE;

   // Set up byte pointer version of lpBuf.
   lpbyteBuf = lpBuf;

   // Copy bytes until buffer is filled or EOF in expanded file image is
   // reached.
   while (nCount > 0 && lpLZ->lCurSeekPos < (LONG)lpLZ->cbulUncompSize)
   {
      /* How many expanded data bytes are in the expanded data buffer?
       * (pbyteOutBuf points AFTER the last valid byte in rgbyteOutBuf[].)
       */
      nNumExpBufBytes = (INT)(pLZI->pbyteOutBuf - pLZI->rgbyteOutBuf);

      /* Is the start of the desired expanded data currently in the bounds of
       * the expanded data buffer?
       */
      lStartCopyOffset = lpLZ->lCurSeekPos - lExpBufStart;
      if (lStartCopyOffset < lExpBufEnd)
         /* It's ok to set iCurReadPos to a negative value here, since we
          * will only use expanded data from the expanded data buffer if
          * iCurReadPos is non-negative.
          */
         iCurReadPos = (INT)lStartCopyOffset;
      else
         iCurReadPos = -1;

      /* Now, if iCurReadPos > 0, some of the expanded data in the expanded
       * data buffer should be copied to the caller's buffer.  If not, we
       * need to continue expanding or restart expanding.
       */
      if (iCurReadPos >= 0)
      {
         /* Copy available expanded data from expanded data buffer. */
         for (cbCopied = 0;
              iCurReadPos < nNumExpBufBytes && nCount > 0;
              cbCopied++, nCount--)
            *lpbyteBuf++ = pLZI->rgbyteOutBuf[iCurReadPos++];

         // Update expanded file pointer.
         lpLZ->lCurSeekPos += (LONG)cbCopied;

         // Keep track of bytes written to buffer.
         cbWritten += cbCopied;
      }

      /* Expand more data, restarting the expansion process first if
       * necessary.
       */
      if (nCount > 0 && lpLZ->lCurSeekPos < (LONG)lpLZ->cbulUncompSize)
      {
         /* If we get here, we've copied all the available expanded data out
          * of rgbyteOutBuf[], through pbyteOutBuf, and we need to expand
          * more data.
          */

         /* Where is the end of the next desired expanded data block? */
         if (bRestartDecoding)
         {
            /* Seek back to start of target data, allowing for buffer
             * overflow.
             */
            lNextExpEndOffset = lpLZ->lCurSeekPos - MAX_OVERRUN;

            /* Don't try to read before offset 0! */
            if (lNextExpEndOffset < 0)
               lNextExpEndOffset = 0;
         }
         else
            /* Continue decoding. */
            lNextExpEndOffset = lExpBufStart
                                + (LONG)nNumExpBufBytes
                                + lExpBufEnd
                                - MAX_OVERRUN;

         /* How much farther should we expand?  The target decoding offset
          * should be the smallest expanded file offset of the following:
          *
          *    1) the last byte in the largest expanded data block that will
          *       safely fit in the expanded data buffer, while guaranteeing
          *       that the start of this block is also in the expanded data
          *       buffer
          *    2) the last requested expanded data byte
          *    3) the last byte in the expanded file
          */
         lNextDecodeTarget = MIN(lNextExpEndOffset,
                                 MIN(lpLZ->lCurSeekPos + (LONG)nCount,
                                     (LONG)lpLZ->cbulUncompSize - 1L));

         // Reset expanded data buffer to empty state.
         pLZI->pbyteOutBuf = pLZI->rgbyteOutBuf;

         // Refill rgbyteOutBuf[] with expanded data.
         switch (lpLZ->byteAlgorithm)
         {
            case ALG_FIRST:
               f = LZDecode(lpLZ->dosh, NO_DOSH, lNextDecodeTarget,
                  bRestartDecoding, TRUE, pLZI);
               break;

            default:
               f = LZERROR_UNKNOWNALG;
               break;
         }

         // Did the decoding go ok?
         if (f != TRUE)
         {
            // Uh oh.  Something went wrong.
            GlobalUnlock(hSourceStruct);
            return(f);
         }

         /* Now how many expanded data bytes are in the expanded data buffer?
          * (pbyteOutBuf points AFTER the last valid byte in rgbyteOutBuf[].)
          */
#if DEBUG
         printf("pbyteOutBuf: 0x%x,  rgbyteOutBuf: 0x%x \n", pLZI->pbyteOutBuf, pLZI->rgbyteOutBuf);
#endif

         nNumExpBufBytes = (INT)(pLZI->pbyteOutBuf - pLZI->rgbyteOutBuf);

         /* Check to make sure we actually read some bytes. */
         if (nNumExpBufBytes <= 0)
         {
            GlobalUnlock(hSourceStruct);
            return(LZERROR_READ);
         }

         /* What is the offset of the start of the expanded data buffer in
          * the expanded file image?
          */
         lExpBufStart = pLZI->cblOutSize - (LONG)nNumExpBufBytes;

         /* Did LZDecode() satisfy the read request, or did the compressed
          * file end prematurely?
          */
         if (pLZI->cblOutSize < lNextDecodeTarget)
         {
            /* Oh oh.  lNextDecodeTarget cannot exceed the expanded file
             * bounds, so the compressed file must have ended prematurely.
             */
            GlobalUnlock(hSourceStruct);
            return(LZERROR_READ);
         }

         // Reset flag so we continue decoding where we left off.
         bRestartDecoding = FALSE;
      }
   }

   GlobalUnlock(hSourceStruct);

   // Return number of bytes copied to destination buffer.
   return(cbWritten);
}

//
// VOID  LZCloseFile(INT oLZFile);
//
// Close a file and free the associated LZFile struct.
//
// Arguments:  oLZFile - source LZFile struct identifier or WIN32 file handle
//
// Returns:    VOID
//
// Globals:    rghLZFileTable[] entry cleared.
//

VOID
LZCloseFile(
    INT oLZFile)
{
   HANDLE hSourceStruct;      // handle to LZFile struct
   LZFile *lpLZ;          // pointer to LZFile struct

   // Check input LZFile struct indentifier / DOS file handle.
   if (oLZFile < 0 || oLZFile >= LZ_TABLE_BIAS + MAX_LZFILES)
      return;

   // We were passed a regular DOS file handle, so just close it.
   if (oLZFile < LZ_TABLE_BIAS) {
      CloseHandle((HANDLE)IntToPtr(ConvertDosFHToWin32(oLZFile)));
      // also need to clean out the file array entry
      fhWin32File[oLZFile] = 0;

      return;
   }

   // We're dealing with a compressed file.  Get the associated LZFile struct.
   hSourceStruct = rghLZFileTable[oLZFile - LZ_TABLE_BIAS];

   // Clear rghLZFIleTable[] entry.
   rghLZFileTable[oLZFile - LZ_TABLE_BIAS] = NULL;

   // Close the file and free the associated LZFile struct.
   if ((lpLZ = (LZFile *)GlobalLock(hSourceStruct)) != NULL)
   {
      CloseHandle((HANDLE)IntToPtr(lpLZ->dosh));

      if (lpLZ->pLZI) {
         FreeGlobalBuffers(lpLZ->pLZI);
      }

      GlobalUnlock(hSourceStruct);

      GlobalFree(hSourceStruct);

   }

   return;
}


/*
** VOID  APIENTRY LZClose(int oLZFile);
**
** Close a file and free the associated LZFile struct.
**
** Arguments:  oLZFile - source LZFile struct identifier or DOS file handle
**
** Returns:    VOID
**
** Globals:    rghLZFileTable[] entry cleared.
*/
VOID  APIENTRY LZClose(INT oLZFile)
{
   HANDLE hSourceStruct;      // handle to LZFile struct
   LZFile *lpLZ;          // pointer to LZFile struct

   // Check input LZFile struct indentifier / DOS file handle.
   if (oLZFile < 0 || oLZFile >= LZ_TABLE_BIAS + MAX_LZFILES)
      return;

   // We were passed a regular DOS file handle, so just close it.
   if (oLZFile < LZ_TABLE_BIAS)
   {
      FCLOSE(ConvertDosFHToWin32(oLZFile));
      /* also need to clean out the file array entry */
      fhWin32File[oLZFile] = 0;

      return;
   }

   // We're dealing with a compressed file.  Get the associated LZFile struct.
   hSourceStruct = rghLZFileTable[oLZFile - LZ_TABLE_BIAS];

   // Clear rghLZFIleTable[] entry.
   rghLZFileTable[oLZFile - LZ_TABLE_BIAS] = NULL;

   // Close the file and free the associated LZFile struct.
   if ((lpLZ = (LZFile *)GlobalLock(hSourceStruct)) != NULL)
   {
      FCLOSE(lpLZ->dosh);

      if (lpLZ->pLZI) {
         FreeGlobalBuffers(lpLZ->pLZI);
      }

      GlobalUnlock(hSourceStruct);

      GlobalFree(hSourceStruct);

   }

   return;
}


/* WIN32 MODS   */

INT ConvertWin32FHToDos(HFILE DoshSource)
{
    INT x;

    if (!fCSInit) {
        if (!NT_SUCCESS(RtlInitializeCriticalSection(&semTable))) {
            return LZERROR_GLOBALLOC;
        }
        fCSInit = TRUE;
    }
 
    /* here we are given an NT file handle, need save this into
     * fhWin32File[], test for overflow, also need see
     * if there is a free slot in the array */

    /* If error, return greater than MAX_LZFILES */

    RtlEnterCriticalSection(&semTable);

    /* walk array, looking for a free slot (free slot = 0) */
    for(x = 0; x < MAX_LZFILES; x++){
        if(fhWin32File[x] == 0)
            break;
    }
    if(x < MAX_LZFILES){
       /* no overflow, save into array*/
       fhWin32File[x] = DoshSource;
    }
    else{
       x = LZERROR_GLOBALLOC;
    }

    RtlLeaveCriticalSection(&semTable);

    return(x);

}


HFILE ConvertDosFHToWin32(INT DoshSource)
{

    /* here, we are given the pseudo Dos File Handle, need convert to
     * real file handle, for use by API.
     */

    if (DoshSource >= MAX_LZFILES || DoshSource < 0 ||
        fhWin32File[DoshSource] == 0) {
        return (HFILE)DoshSource;
    }
    else{
        return(fhWin32File[DoshSource]);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\alpha\context.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains the context management routines for
    Win32

Author:

    Mark Lucovsky (markl) 28-Sep-1990

Revision History:

    Thomas Van Baak (tvb) 22-Jul-1992

        Adapted for Alpha AXP.

--*/

#include "basedll.h"

VOID
BaseInitializeContext (
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL,
    IN BASE_CONTEXT_TYPE ContextType
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    Parameter - Supplies the thread's parameter.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

    NewThread - Supplies a flag that specifies that this is a new
        thread, or a new process.

Return Value:

    None.

--*/

{
    ULONG temp;
    PPEB Peb;

    Peb = NtCurrentPeb();

    //
    // Initialize the control registers.
    // So that the thread begins at BaseThreadStart
    //

    RtlZeroMemory((PVOID)Context, sizeof(CONTEXT));
    Context->IntGp = 1;
    Context->IntSp = (ULONGLONG)(LONG_PTR)InitialSp;
    Context->IntRa = 1;
    Context->ContextFlags = CONTEXT_FULL;
    if ( ContextType != BaseContextTypeProcess ) {
        if ( ContextType == BaseContextTypeThread ) {
            Context->Fir = (ULONGLONG)(LONG_PTR)BaseThreadStart;
        } else {
            Context->Fir = (ULONGLONG)(LONG_PTR)BaseFiberStart;
        }
        Context->IntA0 = (ULONGLONG)(LONG_PTR)InitialPc;
        Context->IntA1 = (ULONGLONG)(LONG_PTR)Parameter;
        Context->IntGp = (ULONGLONG)(LONG_PTR)RtlImageDirectoryEntryToData(
                           Peb->ImageBaseAddress,
                           TRUE,
                           IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
                           &temp
                           );
        }
    else {
        Context->Fir = (ULONGLONG)(LONG_PTR)BaseProcessStart;
        Context->IntA0 = (ULONGLONG)(LONG_PTR)InitialPc;
        }
}

VOID
BaseFiberStart(
    VOID
    )

/*++

Routine Description:

    This function is called to start a Win32 fiber. Its purpose
    is to call BaseThreadStart, getting the necessary arguments
    from the fiber context record.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PFIBER Fiber;

    Fiber = GetCurrentFiber();
    BaseThreadStart( (LPTHREAD_START_ROUTINE)Fiber->FiberContext.IntA0,
                     (LPVOID)Fiber->FiberContext.IntA1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\alpha\thunk.s ===
//       TITLE("Win32 Thunks")
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    thunk.s
//
// Abstract:
//
//    This module implements Win32 functions that must be written in assembler.
//
// Author:
//
//    Mark Lucovsky (markl) 5-Oct-1990
//
// Revision History:
//
//    Thomas Van Baak (tvb) 21-Jul-1992
//
//        Adapted for Alpha AXP.
//
//--

#include "ksalpha.h"

        SBTTL("Switch Stack Then Terminate")
//++
//
// VOID
// BaseSwitchStackThenTerminate (
//     IN PVOID StackLimit,
//     IN PVOID NewStack,
//     IN DWORD ExitCode
//     )
//
// Routine Description:
//
//     This API is called during thread termination to delete a thread's
//     stack, switch to a stack in the thread's TEB, and then terminate.
//
// Arguments:
//
//     StackLimit (a0) - Supplies the address of the stack to be freed.
//
//     NewStack (a1) - Supplies an address within the terminating thread's TE
//         that is to be used as its temporary stack while exiting.
//
//     ExitCode (a2) - Supplies the termination status that the thread
//         is to exit with.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(BaseSwitchStackThenTerminate)

//
// Switch stacks and then jump to BaseFreeStackAndTerminate.
//

        mov     a1, sp                  // set new stack pointer
        mov     a2, a1                  // set exit code argument
        br      zero, BaseFreeStackAndTerminate // jump

        .end BaseSwitchStackThenTerminate

//++
//
// VOID
// WINAPI
// SwitchToFiber (
//     LPVOID lpFiber
//     )
//
// Routine Description:
//
//     This function saves the state of the current fiber and switches
//     to the new fiber.
//
// Arguments:
//
//      CurrentFiber - Supplies the address of the current fiber.
//
//      NewFiber - Supplies the address of the new fiber.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(SwitchToFiber)

        GET_THREAD_ENVIRONMENT_BLOCK    // get current TEB address

//
// Get current fiber address.
//

        LDP     a1, TeFiberData(v0)     //

//
// Set new deallocation stack and fiber data in TEB.
//

        LDP     t0, FbDeallocationStack(a0) // set deallocation stack address
        STP     t0, TeDeallocationStack(v0) //
        STP     a0, TeFiberData(v0)     // set new fiber address

//
// Save stack limit.
//

        LDP     t1, TeStackLimit(v0)    // save current stack limit
        STP     t1, FbStackLimit(a1)    //

//
// Save nonvolatile integer state.
//

        stq     s0, CxIntS0 + FbFiberContext(a1) //
        stq     s1, CxIntS1 + FbFiberContext(a1) //
        stq     s2, CxIntS2 + FbFiberContext(a1) //
        stq     s3, CxIntS3 + FbFiberContext(a1) //
        stq     s4, CxIntS4 + FbFiberContext(a1) //
        stq     s5, CxIntS5 + FbFiberContext(a1) //
        stq     fp, CxIntFp + FbFiberContext(a1) //

//
// Save nonvolatile float state.
//

        stt     f2, CxFltF2 + FbFiberContext(a1) //
        stt     f3, CxFltF3 + FbFiberContext(a1) //
        stt     f4, CxFltF4 + FbFiberContext(a1) //
        stt     f5, CxFltF5 + FbFiberContext(a1) //
        stt     f6, CxFltF6 + FbFiberContext(a1) //
        stt     f7, CxFltF7 + FbFiberContext(a1) //
        stt     f8, CxFltF8 + FbFiberContext(a1) //
        stt     f9, CxFltF9 + FbFiberContext(a1) //

//
// Save RA and SP.
//

        stq     ra, CxFir + FbFiberContext(a1) //
        stq     sp, CxIntSp + FbFiberContext(a1) //

//
// Restore new fiber's stack base and stack limit.
//

        LDP     t0, FbStackBase(a0)     // restore StackBase
        STP     t0, TeStackBase(v0)     //
        LDP     t1, FbStackLimit(a0)    // restore StackLimit
        STP     t1, TeStackLimit(v0)    //

//
// Restore nonvolatile integer state.
//

        ldq     s0, CxIntS0 + FbFiberContext(a0) //
        ldq     s1, CxIntS1 + FbFiberContext(a0) //
        ldq     s2, CxIntS2 + FbFiberContext(a0) //
        ldq     s3, CxIntS3 + FbFiberContext(a0) //
        ldq     s4, CxIntS4 + FbFiberContext(a0) //
        ldq     s5, CxIntS5 + FbFiberContext(a0) //
        ldq     fp, CxIntFp + FbFiberContext(a0) //

//
// Restore nonvolatile float state
//
        ldt     f2, CxFltF2 + FbFiberContext(a0) //
        ldt     f3, CxFltF3 + FbFiberContext(a0) //
        ldt     f4, CxFltF4 + FbFiberContext(a0) //
        ldt     f5, CxFltF5 + FbFiberContext(a0) //
        ldt     f6, CxFltF6 + FbFiberContext(a0) //
        ldt     f7, CxFltF7 + FbFiberContext(a0) //
        ldt     f8, CxFltF8 + FbFiberContext(a0) //
        ldt     f9, CxFltF9 + FbFiberContext(a0) //

//
// Swap x86 exception list pointer, wx86tib.
//

        ldl     t1, 0(v0)               // save current exception list
        stl     t1, FbExceptionList(a1) //
        LDP     t0, TeVdm(v0)           // save current emulator TIB address
        STP     t0, FbWx86Tib(a1)       //
        ldl     t0, FbExceptionList(a0) // set next exception list
        stl     t0, 0(v0)               //
        LDP     t0, FbWx86Tib(a0)       // set next emulator TIB address
        STP     t0, TeVdm(v0)           //

//
// Restore RA and SP.
//

        ldq     ra, CxFir + FbFiberContext(a0) //
        ldq     sp, CxIntSp + FbFiberContext(a0) //
        ret     zero, (ra)

        .end    BasepSwitchToFiber

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\amd64\context.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains the platform specific context management routines.

Author:

    David N. Cutler (davec) 8-Jul-2000

--*/

#include "basedll.h"

//
// CALLFRAME represents the layout of the stack upon entry to a function,
// including home locations for the first four parameters.
//

typedef struct _CALL_FRAME {
    PVOID ReturnAddress;
    PVOID Param1Home;
    PVOID Param2Home;
    PVOID Param3Home;
    PVOID Param4Home;
} CALL_FRAME, *PCALL_FRAME;

C_ASSERT((sizeof(CALL_FRAME) % 16) == 8);


VOID
BaseInitializeContext (
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL,
    IN BASE_CONTEXT_TYPE ContextType
    )

/*++

Routine Description:

    This function initializes a context structure for use is an subsequent
    call to create a thread.

Arguments:

    Context - Supplies a pointer to context record to be initialized.

    Parameter - Supplies the thread's parameter.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

    NewThread - Supplies a flag that specifies that this is a new thread,
        fiber, or process.

Return Value:

    None.

--*/

{
    PCALL_FRAME CallFrame;

    //
    // Initialize the context record so the thread will start execution
    // in the proper routine.
    //

    RtlZeroMemory((PVOID)Context, sizeof(CONTEXT));
    Context->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;

    //
    // Build dummy call frame and return address on the stack.
    //

    CallFrame = (PCALL_FRAME)InitialSp - 1;
    CallFrame->ReturnAddress = NULL;

    Context->Rsp = (ULONG64)CallFrame;

    //
    // Initialize the start up parameters.
    //

    Context->Rcx = (ULONG64)InitialPc;
    Context->Rdx = (ULONG64)Parameter;

    //
    // Initialize the starting address dependent on the type of startup.
    //

    if (ContextType == BaseContextTypeProcess) {
        Context->Rip = (ULONG64)BaseProcessStart;

    } else if (ContextType == BaseContextTypeThread ) {
        Context->Rip = (ULONG64)BaseThreadStart;

    } else {
        Context->Rip = (ULONG64)BaseFiberStart;
    }

    return;
}

VOID
BaseFiberStart (
    VOID
    )

/*++

Routine Description:

    This function starts a fiber by calling the thread start up routine with
    the proper parameters.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PFIBER Fiber;

    Fiber = GetCurrentFiber();
    BaseThreadStart((LPTHREAD_START_ROUTINE)Fiber->FiberContext.Rcx,
                    (LPVOID)Fiber->FiberContext.Rdx);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\xx.c ===
#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    OutputDebugString("Thread Started\n");
    while(1);
}

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE Thread;
    DWORD ThreadId;
    DWORD st;

    Thread = CreateThread(NULL,0L,TestThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);

    Sleep(3000);
    OutputDebugString("Out of Sleep\n");

    TerminateThread(Thread,1);

    st = WaitForSingleObject(Thread,-1);
    assert(st == 0);

    assert(GetExitCodeThread(Thread,&st));
    assert(st = 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\wmbnch.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <memory.h>
#include <process.h>

#define WAIT_MULTIPLE_ITERATIONS 10000
HANDLE WaitHandles[64];

//
// Define local types.
//

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    ULONG ContextSwitches;
    ULONG FirstLevelFills;
    ULONG SecondLevelFills;
    ULONG SystemCalls;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    ULONG ContextSwitches;
    LARGE_INTEGER Duration;
    ULONG FirstLevelFills;
    ULONG Length;
    ULONG Performance;
    ULONG SecondLevelFills;
    NTSTATUS Status;
    ULONG SystemCalls;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;


    //
    // Print results and announce end of test.
    //

    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StopTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    Duration = RtlLargeIntegerSubtract(PerfInfo->StopTime, PerfInfo->StartTime);
    Length = Duration.LowPart / 10000;
    printf("        Test time in milliseconds %d\n", Length);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = PerfInfo->Iterations * 1000 / Length;
    printf("        Iterations per second     %d\n", Performance);

    ContextSwitches = SystemInfo.ContextSwitches - PerfInfo->ContextSwitches;
    FirstLevelFills = SystemInfo.FirstLevelTbFills - PerfInfo->FirstLevelFills;
    SecondLevelFills = SystemInfo.SecondLevelTbFills - PerfInfo->SecondLevelFills;
    SystemCalls = SystemInfo.SystemCalls - PerfInfo->SystemCalls;
    printf("        First Level TB Fills      %d\n", FirstLevelFills);
    printf("        Second Level TB Fills     %d\n", SecondLevelFills);
    printf("        Total Context Switches    %d\n", ContextSwitches);
    printf("        Number of System Calls    %d\n", SystemCalls);

    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    )

{

    NTSTATUS Status;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StartTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    PerfInfo->ContextSwitches = SystemInfo.ContextSwitches;
    PerfInfo->FirstLevelFills = SystemInfo.FirstLevelTbFills;
    PerfInfo->SecondLevelFills = SystemInfo.SecondLevelTbFills;
    PerfInfo->SystemCalls = SystemInfo.SystemCalls;
    return;
}


VOID
WaitMultipleTest()
{
    PERFINFO PerfInfo;
    int i;

    StartBenchMark(
        "Wait Single Object",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForSingleObject(WaitHandles[0],INFINITE);   // Wait Single Object
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 1 Object",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(1,WaitHandles,FALSE,INFINITE);   // Wait Any, 1 Object
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 8 Objects",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(8,WaitHandles,FALSE,INFINITE);   // Wait Any, 8 Objects
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 16 Objects",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(16,WaitHandles,FALSE,INFINITE);   // Wait Any, 16 Objects
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 32 Objects",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(32,WaitHandles,FALSE,INFINITE);   // Wait Any, 32 Objects
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 64 Objects",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(64,WaitHandles,FALSE,INFINITE);   // Wait Any, 64 Objects
        }

    FinishBenchMark(&PerfInfo);
}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    int i;

    for(i=0;i<64;i++){
        WaitHandles[i] = CreateEvent(NULL,TRUE,TRUE,NULL);
        }
    WaitMultipleTest();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\alpha\critsect.s ===
//      TITLE("Interlocked Increment and Decrement Support")
//++
//
// Copyright (c) 1991  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    critsect.s
//
// Abstract:
//
//    This module implements functions to support user mode critical sections.
//    It contains some code from ntos\dll\alpha\critsect.s but without the Rtl
//    prefix.
//
// Author:
//
//    David N. Cutler 29-Apr-1992
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//    Thomas Van Baak (tvb) 22-Jul-1992
//
//        Adapted for Alpha AXP.
//
//--

#include "ksalpha.h"

        SBTTL("Interlocked Increment")
//++
//
// LONG
// InterlockedIncrement(
//    IN PLONG Addend
//    )
//
// Routine Description:
//
//    This function performs an interlocked increment on the addend variable.
//
//    This function and its companion are assuming that the count will never
//    be incremented past 2**31 - 1.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       incremented.
//
// Return Value:
//
//    A negative value is returned if the updated value is less than zero,
//    a zero value is returned if the updated value is zero, and a nonzero
//    positive value is returned if the updated value is greater than zero.
//
//--

        LEAF_ENTRY(InterlockedIncrement)

10:     mb                              // synchronize memory access
        ldl_l   v0, 0(a0)               // get addend value - locked
        addl    v0, 1, v0               // increment addend value
        mov     v0, t0                  // copy updated value to t0 for store
        stl_c   t0, 0(a0)               // store conditionally
        beq     t0, 20f                 // if eq, conditional store failed
        mb                              // synchronize memory access
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

20:     br      zero, 10b               // go try load again

        .end    InterlockedIncrement

        SBTTL("InterlockedDecrement")
//++
//
// LONG
// InterlockedDecrement(
//    IN PLONG Addend
//    )
//
// Routine Description:
//
//    This function performs an interlocked decrement on the addend variable.
//
//    This function and its companion are assuming that the count will never
//    be decremented past 2**31 - 1.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       decremented.
//
// Return Value:
//
//    A negative value is returned if the updated value is less than zero,
//    a zero value is returned if the updated value is zero, and a nonzero
//    positive value is returned if the updated value is greater than zero.
//
//--

        LEAF_ENTRY(InterlockedDecrement)

10:     mb                              // synchronize memory access
        ldl_l   v0, 0(a0)               // get addend value - locked
        subl    v0, 1, v0               // decrement addend value
        mov     v0, t0                  // copy updated value to t0 for store
        stl_c   t0, 0(a0)               // store conditionally
        beq     t0, 20f                 // if eq, conditional store failed
        mb                              // synchronize memory access
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

20:     br      zero, 10b               // go try load again

        .end    InterlockedDecrement

        SBTTL("Interlocked Exchange")
//++
//
// ULONG
// InterlockedExchange (
//    IN PULONG Source,
//    IN ULONG Value
//    )
//
// Routine Description:
//
//    This function performs an interlocked exchange of a longword value with
//    a longword in memory and returns the memory value.
//
// Arguments:
//
//    Source (a0) - Supplies a pointer to a variable whose value is to be
//       exchanged.
//
//    Value (a1) - Supplies the value to exchange with the source value.
//
// Return Value:
//
//    The source value is returned as the function value.
//
//--

        LEAF_ENTRY(InterlockedExchange)

10:     mb                              // synchronize memory access
        ldl_l   v0,0(a0)                // get current source value
        xor     a1,zero,t0              // set exchange value
        stl_c   t0,0(a0)                // replace source value
        beq     t0,20f                  // if eq, conditional store failed
        mb                              // synchronize memory access
        ret     zero,(ra)               // else/ return old value to caller

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

20:     br      zero,10b                // go try spin lock again

        .end    InterlockedExchange

        SBTTL("Interlocked Compare Exchange")
//++
//
// LONG
// InterlockedCompareExchange (
//    IN OUT PLONG *Destination,
//    IN LONG Exchange,
//    IN LONG Comperand
//    )
//
// Routine Description:
//
//    This function performs an interlocked compare of the destination
//    value with the comperand value. If the destination value is equal
//    to the comperand value, then the exchange value is stored in the
//    destination. Otherwise, no opeation is performed.
//
// Arguments:
//
//    Destination (a0) - Supplies a pointer to the destination value.
//
//    Exchange (a1) - Supplies the exchange.
//
//    Comperand (a2) - Supplies the comperand value.
//
// Return Value:
//
//    The initial destination value is returned as the function value.
//
//--

        LEAF_ENTRY(InterlockedCompareExchange)

10:     mb                              // synchronize memory accesss
        ldl_l   v0, 0(a0)               // get current addend value
        bis     a1, zero, t0            // copy exchange value for store
        cmpeq   v0, a2, t1              // check if operands match
        beq     t1, 20f                 // if eq, operands mismatch
        stl_c   t0, 0(a0)               // store updated addend value
        beq     t0,25f                  // if eq, store conditional failed
        mb                              // synchronize memory access
20:     ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

25:     br      zero, 10b               // go try spin lock again

        .end    InterlockedCompareExchange

        SBTTL("Interlocked Exchange Add")
//++
//
// LONG
// InterlockedExchangeAdd (
//    IN PLONG Addend,
//    IN ULONG Increment
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of an increment value to an
//    addend variable of type unsigned long. The initial value of the addend
//    variable is returned as the function value.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       adjusted by the increment value.
//
//    Increment (a1) - Supplies the increment value to be added to the
//       addend variable.
//
// Return Value:
//
//    The initial value of the addend variable.
//
//--

        LEAF_ENTRY(InterlockedExchangeAdd)

10:     mb                              // synchronize memory access
        ldl_l   v0, 0(a0)               // get current addend value - locked
        addl    v0, a1, t0              // increment addend value
        stl_c   t0, 0(a0)               // store updated value - conditionally
        beq     t0, 20f                 // if eq, conditional store failed
        mb                              // synchronize memory access
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

20:     br      zero, 10b               // go try spin lock again

        .end    InterlockedExchangeAdd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\char\bm.c ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>


#define FIVEK   5000
#define TENK    10000
#define ONEHUNK 100000
#define ONEMIL  1000000
#define MEMORY_TEST 200000000

VOID
_fastcall
MemToReg (
    IN ULONG Count,
    IN PULONG Address
    );

VOID
_fastcall
RegToMem (
    IN ULONG Count,
    IN PULONG Address
    );

//
// Define local types.
//

typedef struct _PERFINFO {
    DWORD StartTime;
    DWORD StopTime;
    LPSTR Title;
    DWORD Iterations;
} PERFINFO, *PPERFINFO;

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    DWORD ContextSwitches;
    DWORD Duration;
    DWORD Performance;


    //
    // Print results and announce end of test.
    //

    PerfInfo->StopTime = GetTickCount();

    Duration = PerfInfo->StopTime - PerfInfo->StartTime;
    printf("        Test time in milliseconds %d\n", Duration);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = PerfInfo->Iterations * 1000 / Duration;
    printf("        Iterations per second     %d\n", Performance);


    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN DWORD Iterations,
    IN PPERFINFO PerfInfo
    )

{

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    PerfInfo->StartTime = GetTickCount();
    return;
}

VOID
VqTest(
    VOID
    )

{

    PERFINFO PerfInfo;
    int i;
    PVOID Pv;
    DWORD dw;
    MEMORY_BASIC_INFORMATION BasicInfo;

    //
    // Reserve 64k and commit one page
    //
    Pv = VirtualAlloc(NULL,65536,MEM_RESERVE,PAGE_READWRITE);
    if ( !Pv ) {
        printf("Virtual Alloc(a) Failed %d\n",GetLastError());
        ExitProcess(1);
        }
    Pv = VirtualAlloc(Pv,4096,MEM_COMMIT,PAGE_READWRITE);
    if ( !Pv ) {
        printf("Virtual Alloc(b) Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS);

    StartBenchMark(
        "Virtual Query Test",
        5*ONEHUNK,
        &PerfInfo
        );

    for ( i=0;i<5*ONEHUNK;i++) {
        dw = VirtualQuery(Pv,&BasicInfo,sizeof(BasicInfo));
        }

    FinishBenchMark(&PerfInfo);

    SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
}

VOID
MulDivTest(
    VOID
    )

{

    PERFINFO PerfInfo;
    int i;

    SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS);

    StartBenchMark(
        "MulDiv(4,2,5) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(4,2,5);
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "MulDiv(-4,2,5) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(-4,2,5);
        }

    FinishBenchMark(&PerfInfo);


    StartBenchMark(
        "MulDiv(4,-2,5) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(4,-2,5);
        }

    FinishBenchMark(&PerfInfo);


    StartBenchMark(
        "MulDiv(-4,-2,5) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(-4,-2,5);
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "MulDiv(0x10,0x400,0) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(0x10,0x400,0);
        }

    FinishBenchMark(&PerfInfo);


    StartBenchMark(
        "MulDiv(0x10,0x40000000,2) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(0x10,0x40000000,2);
        }

    FinishBenchMark(&PerfInfo);

    SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
}

VOID
GfaTest(
    LPSTR Str
    )

{

    PERFINFO PerfInfo;
    int i;

    StartBenchMark(
        "GetFileAttributes Test",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {
        GetFileAttributes(Str);
        }

    FinishBenchMark(&PerfInfo);
}

VOID
GmhTest(
    VOID
    )

{

    PERFINFO PerfInfo;
    int i;

    StartBenchMark(
        "GetModuleHandle Test",
        ONEHUNK,
        &PerfInfo
        );

    for ( i=0;i<ONEHUNK;i++) {
        GetModuleHandle("kernel32.dll");
        }

    FinishBenchMark(&PerfInfo);
}

LPVOID Fibers[2];

VOID
FiberRoutine1(
    LPVOID lpParameter
    )
{
    for(;;) {
        SwitchToFiber(Fibers[0]);
        }
}

VOID
FiberRoutine0(
    LPVOID lpParameter
    )
{
    PERFINFO PerfInfo;
    int i;

    StartBenchMark(
        "Fiber Switch Test",
        ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<ONEMIL;i++) {
        SwitchToFiber(Fibers[1]);
        }

    FinishBenchMark(&PerfInfo);
}

VOID
FibTst(
    VOID
    )

{

    Fibers[0] = ConvertThreadToFiber((LPVOID)0);
    Fibers[1] = CreateFiber(0,FiberRoutine1,(LPVOID)1);
    FiberRoutine0((LPVOID)1);
}

VOID
MemoryTest (
    VOID
    )

{

    PULONG Address;
    CHAR Buffer[512];
    ULONG Count;
    PERFINFO PerfInfo;

    //
    // Memory to register - aligned.
    //

    Address = (PULONG)(((ULONG)(&Buffer[128]) + 3) & ~3);
    StartBenchMark("Memory To Register Aligned Test",
                   MEMORY_TEST,
                   &PerfInfo);

    MemToReg(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Memory to register - unaligned within cache line
    //

    Address = (PULONG)((((ULONG)(&Buffer[256]) + 127) & ~127) + 1);
    StartBenchMark("Memory To Register Unaligned Within Cache Line Test",
                   MEMORY_TEST,
                   &PerfInfo);

    MemToReg(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Memory to register - unaligned across cache line
    //

    Address = (PULONG)((((ULONG)(&Buffer[256]) + 127) & ~127) - 1);
    StartBenchMark("Memory To Register Unaligned Across Cache Line Test",
                   MEMORY_TEST / 2,
                   &PerfInfo);

    MemToReg(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Register to memory - aligned.
    //

    Address = (PULONG)(((ULONG)(&Buffer[256]) + 3) & ~3);
    StartBenchMark("Register To Memory Aligned Test",
                   MEMORY_TEST,
                   &PerfInfo);

    RegToMem(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Register to Memory - unaligned within cache line
    //

    Address = (PULONG)((((ULONG)(&Buffer[256]) + 127) & ~127) + 1);
    StartBenchMark("Register To Memory Unaligned Within Cache Line Test",
                   MEMORY_TEST,
                   &PerfInfo);

    RegToMem(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Register to Memory - unaligned across cache line
    //

    Address = (PULONG)((((ULONG)(&Buffer[256]) + 127) & ~127) - 1);
    StartBenchMark("Register To Memory Unaligned Across Cache Line Test",
                   MEMORY_TEST / 2,
                   &PerfInfo);

    RegToMem(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    return;
}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

//    VqTest();
//    MulDivTest();
//    GmhTest();
//    if ( argc > 1 ) {
//        GfaTest(argv[1]);
//        }

//    FibTst();


    MemoryTest();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\amd64\fiber.asm ===
title  "Fiber Switch"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   fiber.asm
;
; Abstract:
;
;   This module implements the platform specific fiber swtich code.
;
; Author:
;
;   David N. Cutler (davec) 7-Jul-2000
;
;--

include ksamd64.inc

;++
;
; VOID
; SwitchToFiber(
;     PFIBER NewFiber
;     )
;
; Routine Description:
;
;   This function saves the state of the current fiber and switches to the
;   specified fiber.
;
; Arguments:
;
;   NewFiber (rcx) - Supplies the address of the new fiber.
;
; Return Value:
;
;   None
;
;--

        LEAF_ENTRY SwitchToFiber, _TEXT$00

        mov     rdx, gs:[TeSelf]        ; get TEB address
        mov     rax, TeFiberData[rdx]   ; get current fiber address

;
; Set new deallocation stack and fiber data in TEB.
;

        mov     r8, FbDeallocationStack[rcx] ; set deallocation stack address
        mov     TeDeallocationStack[rdx], r8 ;
        mov     TeFiberData[rdx], rcx   ; set new fiber address

;
; Save stack limit.
;

        mov     r8, TeStackLimit[rdx]   ; save current stack limit
        mov     FbStackLimit[rax], r8   ;

;
; Save the nonvolitile state of the current fiber.
;

        lea     r8, FbFiberContext[rax] ; get fiber context record address
        mov     CxRbx[r8], rbx          ; save nonvolatile integer registers
        mov     CxRbp[r8], rbp          ;
        mov     CxRsi[r8], rsi          ;
        mov     CxRdi[r8], rdi          ;
        mov     CxR12[r8], r12          ;
        mov     CxR13[r8], r13          ;
        mov     CxR14[r8], r14          ;
        mov     CxR15[r8], r15          ;
        movq    CxXmm6[r8], xmm6        ; save nonvolatile floating registers
        movq    CxXmm7[r8], xmm7        ;
        movq    CxXmm8[r8], xmm8        ;
        movq    CxXmm9[r8], xmm9        ;
        movq    CxXmm10[r8], xmm10      ;
        movq    CxXmm11[r8], xmm11      ;
        movq    CxXmm12[r8], xmm12      ;
        movq    CxXmm13[r8], xmm13      ;
        movq    CxXmm14[r8], xmm14      ;
        movq    CxXmm15[r8], xmm15      ;
        mov     r9, [rsp]               ; save return address
        mov     CxRip[r8], r9           ;
        mov     CxRsp[r8], rsp          ; save stack pointer

;
; Restore the new fiber stack base and stack limit.
;

        mov     r8, FbStackBase[rcx]    ; restore stack base
        mov     TeStackBase[rdx], r8    ;
        mov     r8, FbStackLimit[rcx]   ; restore stack limit
        mov     TeStackLimit[rdx], r8   ;

;
; Restore nonvolitile state of the new fiber.
;

        lea     r8, FbFiberContext[rcx] ; get fiber context address
        mov     rbx, CxRbx[r8]          ; restore nonvolatile integer registers
        mov     rbp, CxRbp[r8]          ;
        mov     rsi, CxRsi[r8]          ;
        mov     rdi, CxRdi[r8]          ;
        mov     r12, CxR12[r8]          ;
        mov     r13, CxR13[r8]          ;
        mov     r14, CxR14[r8]          ;
        mov     r15, CxR15[r8]          ;
        movq    xmm6, CxXmm6[r8]        ; restore nonvolatile floating registers
        movq    xmm7, CxXmm7[r8]        ;
        movq    xmm8, CxXmm8[r8]        ;
        movq    xmm9, CxXmm9[r8]        ;
        movq    xmm10, CxXmm10[r8]      ;
        movq    xmm11, CxXmm11[r8]      ;
        movq    xmm12, CxXmm12[r8]      ;
        movq    xmm13, CxXmm13[r8]      ;
        movq    xmm14, CxXmm14[r8]      ;
        movq    xmm15, CxXmm15[r8]      ;
        mov     rsp, CxRsp[r8]          ; restore stack pointer
        ret                             ;

        LEAF_END SwitchToFiber, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\char\fibtst.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

LPVOID Fibers[4];

VOID
FiberRoutine(
    LPVOID lpParameter
    )
{
    DWORD FiberId;

    FiberId = (DWORD)GetFiberData();

    printf("Init: In Fiber %d, %x Param %d\n",FiberId,GetCurrentFiber(),lpParameter);

    while(1) {
        printf("In Fiber %d %d\n",FiberId,(DWORD)GetFiberData() );
        Sleep(10);
        if ( FiberId == 3 ) {
            SwitchToFiber(Fibers[0]);
            }
        else {
            SwitchToFiber(Fibers[FiberId+1]);
            }
        }
}

int _cdecl main(void)
{
    DWORD IdealProcessor;

    IdealProcessor = SetThreadIdealProcessor(GetCurrentThread(),MAXIMUM_PROCESSORS);
    printf("IdealProcessor %d\n",IdealProcessor);


    Fibers[0] = ConvertThreadToFiber((LPVOID)0);
    Fibers[1] = CreateFiber(0,FiberRoutine,(LPVOID)1);
    Fibers[2] = CreateFiber(0,FiberRoutine,(LPVOID)2);
    Fibers[3] = CreateFiber(0,FiberRoutine,(LPVOID)3);

    FiberRoutine((LPVOID)99);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\char\tlst.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>


_declspec(thread)   DWORD Id;


VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;

    Id = GetCurrentThreadId();

    printf("    TEST THREAD Id = %d vs %d\n",Id,GetCurrentThreadId());

    Sleep(1000);

    printf("    TEST THREAD Id = %d vs %d\n",Id,GetCurrentThreadId());

    ExitThread(0);
}













int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    HANDLE Thread;
    DWORD ThreadId;
    int i;

    Id = GetCurrentThreadId();

    printf("MAIN THREAD Id = %d vs %d\n",Id,GetCurrentThreadId());

    for(i=0;i<10;i++) {
        Thread = CreateThread(NULL,0L,(PVOID)TestThread,(LPVOID)99,0,&ThreadId);

        if ( !Thread ) {
            printf("Thread creation failed %d\n",GetLastError());
            }
        WaitForSingleObject(Thread,INFINITE);
        CloseHandle(Thread);

        printf("\nMAIN THREAD Id = %d vs %d\n",Id,GetCurrentThreadId());
        }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\char\lastress.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

typedef DWORD ERESOURCE;

#include "\nt\private\ntos\inc\heap.h"

#define ITERATIONS 1000
#define SIZES 10

DWORD Sizes[SIZES] = {
                      100,
                      10,
                      128,
                      256,
                      256,
                      100,
                      32,
                      64,
                      64,
                      100
                     };

VOID
LaThread(PVOID h)
{
    int i,j;
    PVOID p;

    WaitForSingleObject((HANDLE)h,INFINITE);

    for(i=0;i<ITERATIONS;i++){
        for(j=0;j<SIZES;j++) {
            if ( j & 1 ) {
                p = LocalAlloc(LMEM_FIXED,Sizes[j]);
                }
            else {
                p = LocalAlloc(LMEM_ZEROINIT,Sizes[j]);
                }
            if ( p ) {
                LocalFree(p);
                }
            else {
                printf("Alloc In Thread Failed\n");
                ExitProcess(1);
                }
            }
        }
}

VOID
StartTest(
    DWORD SpinCount,
    DWORD ThreadCount
    )
{
    PHANDLE Threads,p;
    HANDLE hStartEvent;
    DWORD Id;
    DWORD i;
    PHEAP ProcessHeap;
    PRTL_CRITICAL_SECTION HeapLock;
    DWORD Start,End;

    ProcessHeap = (PHEAP)NtCurrentPeb()->ProcessHeap;
    HeapLock = &ProcessHeap->LockVariable->Lock.CriticalSection;
    if ( HeapLock ) {
        HeapLock->DebugInfo->ContentionCount = 0;
        if ( SpinCount != 0xffffffff) {
            HeapLock->SpinCount = SpinCount;
            }
        }
    hStartEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if ( !hStartEvent ) {
        printf("CreateEvent Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    if ( ThreadCount < 2 ) {
        ThreadCount = 2;
        }
    if ( ThreadCount > 64 ) {
        ThreadCount = 64;
        }

    Threads = LocalAlloc(LMEM_ZEROINIT,sizeof(HANDLE)*ThreadCount);
    if ( !Threads ) {
        printf("Alloc Threads Failed\n");
        ExitProcess(1);
        }
    for(i=0,p=Threads;i<ThreadCount;i++,p++){

        *p = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE)LaThread,
                (PVOID)hStartEvent,
                0,
                &Id
                );

        if ( !*p ) {
            printf("CreateThread Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        }
    Start = GetTickCount();
    SetEvent(hStartEvent);

    if ( WaitForMultipleObjects(ThreadCount,Threads,TRUE,INFINITE) == WAIT_FAILED ) {
        printf("WaitMultiple Failed %d\n",GetLastError());
        ExitProcess(1);
        }
    End = GetTickCount();

    for(i=0,p=Threads;i<ThreadCount;i++,p++){
        CloseHandle(*p);
        }
    CloseHandle(hStartEvent);

    if ( !HeapLock ) {
        HeapLock = &ProcessHeap->LockVariable->Lock.CriticalSection;
        if ( !HeapLock ) {
            printf("No Heap Lock found\n");
            ExitProcess(1);
            }
        }
    printf("Heap Contention Threads %2d SpinCount %5d -> Contention %7d TickCount %d\n",ThreadCount,SpinCount,HeapLock->DebugInfo->ContentionCount,End-Start);

}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    StartTest(0xffffffff,2);
    StartTest(0,2);
    StartTest(1000,2);
    StartTest(3000,2);
    StartTest(4000,2);
    StartTest(5000,2);
    StartTest(10000,2);

    printf("\n");

    StartTest(0,4);
    StartTest(1000,4);
    StartTest(3000,4);
    StartTest(4000,4);
    StartTest(5000,4);
    StartTest(10000,4);

    printf("\n");

    StartTest(0,5);
    StartTest(1000,5);
    StartTest(3000,5);
    StartTest(4000,5);
    StartTest(5000,5);
    StartTest(10000,5);

    printf("\n");

    StartTest(0,6);
    StartTest(1000,6);
    StartTest(3000,6);
    StartTest(4000,6);
    StartTest(5000,6);
    StartTest(10000,6);

    printf("\n");

    StartTest(0,8);
    StartTest(1000,8);
    StartTest(3000,8);
    StartTest(4000,8);
    StartTest(5000,8);
    StartTest(10000,8);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\char\smpscale.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

BOOL fShowScaling;

#define MAX_THREADS 32


//
// - hStartOfRace is a manual reset event that is signalled when
//   all of the threads are supposed to cut loose and begin working
//
// - hEndOfRace is a manual reset event that is signalled once the end time
//   has been retrieved and it is ok for the threads to exit
//

HANDLE hStartOfRace;
HANDLE hEndOfRace;


//
// - ThreadReadyDoneEvents are an array of autoclearing events. The threads
//   initially signal these events once they have reached their start routines
//   and are ready to being processing. Once they are done processing, they
//   signal thier event to indicate that they are done processing.
//
// - ThreadHandles are an array of thread handles to the worker threads. The
//   main thread waits on these to know when all of the threads have exited.
//

HANDLE ThreadReadyDoneEvents[MAX_THREADS];
HANDLE ThreadHandles[MAX_THREADS];

DWORD WorkerThread(PVOID ThreadIndex);
DWORD ThreadId;
DWORD StartTicks, EndTicks;
HANDLE IoHandle;

#define SIXTY_FOUR_K    (64*1024)
#define SIXTEEN_K       (16*1024)
unsigned int InitialBuffer[SIXTY_FOUR_K/sizeof(unsigned int)];
#define NUMBER_OF_WRITES ((1024*1024*8)/SIXTY_FOUR_K)
#define BUFFER_MAX  (64*1024)
#define FILE_SIZE ((1024*1024*8)-BUFFER_MAX)

/*
// Each thread has a THREAD_WORK structure. This contains the address
// of the cells that this thread is responsible for, and the number of
// cells it is supposed to process.
*/

typedef struct _THREAD_WORK {
    unsigned long *CellVector;
    int NumberOfCells;
    int RecalcResult;
    BOOL GlobalMode;
} THREAD_WORK, *PTHREAD_WORK;

unsigned int GlobalData[MAX_THREADS];
THREAD_WORK ThreadWork[MAX_THREADS];
#define ONE_MB      (1024*1024)

unsigned long Mb = 16;
unsigned long ExpectedRecalcValue;
unsigned long ActualRecalcValue;
unsigned long ContentionValue;
int fGlobalMode;
int WorkIndex;
int BufferSize;
unsigned long *CellVector;



DWORD
DoAnInteration(
    int NumberOfThreads,
    BOOL GlobalMode
    )
{
    int i;
    int fShowUsage;
    char c, *p, *whocares;
    int NumberOfDwords;
    int CNumberOfDwords;
    int DwordsPerThread;
    char *Answer;
    unsigned long x;

    fGlobalMode = 0;

    BufferSize = 1024;

    hStartOfRace = CreateEvent(NULL,TRUE,FALSE,NULL);
    hEndOfRace = CreateEvent(NULL,TRUE,FALSE,NULL);

    if ( !hStartOfRace || !hEndOfRace ) {
        fprintf(stderr,"SMPSCALE Race Event Creation Failed\n");
        ExitProcess(1);
        }


    /*
    // Prepare the ready done events. These are auto clearing events
    */

    for(i=0; i<NumberOfThreads; i++ ) {
        ThreadReadyDoneEvents[i] = CreateEvent(NULL,FALSE,FALSE,NULL);
        if ( !ThreadReadyDoneEvents[i] ) {
            fprintf(stderr,"SMPSCALE Ready Done Event Creation Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        }

    NumberOfDwords = (Mb*ONE_MB) / sizeof(unsigned long);
    CNumberOfDwords = NumberOfDwords;
    DwordsPerThread = NumberOfDwords / NumberOfThreads;

    /*
    // Initialize the Cell Vector
    */

    for(i=0, ExpectedRecalcValue=0; i<NumberOfDwords; i++ ){
        ExpectedRecalcValue += i;
        CellVector[i] = i;
        }

    /*
    // Partition the work to the worker threads
    */

    for(i=0; i<NumberOfThreads; i++ ){
        ThreadWork[i].CellVector = &CellVector[i*DwordsPerThread];
        ThreadWork[i].NumberOfCells = DwordsPerThread;
        NumberOfDwords -= DwordsPerThread;

        /*
        // If we have a remainder, give the remaining work to the last thread
        */

        if ( NumberOfDwords < DwordsPerThread ) {
            ThreadWork[i].NumberOfCells += NumberOfDwords;
            }
        }

    /*
    // Create the worker threads
    */

    for(i=0; i<NumberOfThreads; i++ ) {
        ThreadWork[i].RecalcResult = 0;
        ThreadWork[i].GlobalMode = GlobalMode;
        GlobalData[i] = 0;

        ThreadHandles[i] = CreateThread(
                                NULL,
                                0,
                                WorkerThread,
                                (PVOID)i,
                                0,
                                &ThreadId
                                );
        if ( !ThreadHandles[i] ) {
            fprintf(stderr,"SMPSCALE Worker Thread Creation Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        CloseHandle(ThreadHandles[i]);

        }

    /*
    // All of the worker threads will signal thier ready done event
    // when they are idle and ready to proceed. Once all events have been
    // set, then setting the hStartOfRaceEvent will begin the recalc
    */

    i = WaitForMultipleObjects(
            NumberOfThreads,
            ThreadReadyDoneEvents,
            TRUE,
            INFINITE
            );

    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"SMPSCALE Wait for threads to stabalize Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    /*
    // Everthing is set to begin the recalc operation
    */

    StartTicks = GetTickCount();
    if ( !SetEvent(hStartOfRace) ) {
        fprintf(stderr,"SMPSCALE SetEvent(hStartOfRace) Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    /*
    // Now just wait for the recalc to complete
    */

    i = WaitForMultipleObjects(
            NumberOfThreads,
            ThreadReadyDoneEvents,
            TRUE,
            INFINITE
            );

    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"SMPSCALE Wait for threads to complete Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    /*
    // Now pick up the individual recalc values
    */

    for(i=0, ActualRecalcValue = 0; i<NumberOfThreads; i++ ){
        ActualRecalcValue += ThreadWork[i].RecalcResult;
        }

    EndTicks = GetTickCount();

    if ( ActualRecalcValue != ExpectedRecalcValue ) {
        fprintf(stderr,"SMPSCALE Recalc Failuer !\n");
        ExitProcess(1);
        }

    return (EndTicks - StartTicks);
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD Time,GlobalModeTime;
    DWORD BaseLine;
    DWORD i;
    SYSTEM_INFO SystemInfo;

    /*
    // Allocate and initialize the CellVector
    */

    if ( argc > 1 ) {
        fShowScaling = TRUE;
        }
    else {
        fShowScaling = FALSE;
        }

    CellVector = (PDWORD)VirtualAlloc(NULL,Mb*ONE_MB,MEM_COMMIT,PAGE_READWRITE);
    if ( !CellVector ) {
        fprintf(stderr,"SMPSCALE Cell Vector Allocation Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    BaseLine = DoAnInteration(1,FALSE);
    i = 0;
    while(i++<10) {
        Time = DoAnInteration(1,FALSE);
        if ( Time == BaseLine ) {
            break;
            }
        if ( abs(Time-BaseLine) < 2 ) {
            break;
            }
        BaseLine = Time;
        }

    GetSystemInfo(&SystemInfo);

    fprintf(stdout,"%d Processor System. Single Processor BaseLine %dms\n\n",
        SystemInfo.dwNumberOfProcessors,
        BaseLine
        );

    if ( !fShowScaling ) {
            fprintf(stdout,"              Time             Time with Cache Sloshing\n");
            }

    for ( i=0;i<SystemInfo.dwNumberOfProcessors;i++) {
        Time = DoAnInteration(i+1,FALSE);
        GlobalModeTime = DoAnInteration(i+1,TRUE);

        if ( fShowScaling ) {
            if ( i > 0 ) {
                fprintf(stdout,"%1d Processors %4dms (%3d%%)   %4dms (%3d%%) (with cache contention)\n",
                    i+1,Time,((BaseLine*100)/Time-100),GlobalModeTime,((BaseLine*100)/GlobalModeTime-100)
                    );
                }
            else {
                fprintf(stdout,"%1d Processors %4dms          %4dms        (with cache contention)\n",
                    i+1,Time,GlobalModeTime
                    );
                }
            }
        else {
            fprintf(stdout,"%1d Processors %4dms        vs          %4dms\n",
                i+1,Time,GlobalModeTime
                );
            }
        }

    ExitProcess(2);
}


/*
// The worker threads perform the recalc operation on their
// assigned cells. They begin by setting their ready done event
// to indicate that they are ready to begin the recalc. Then they
// wait until the hStartOfRace event is signaled. Once this occurs, they
// do their part of the recalc and when done they signal their ready done
// event and then wait on the hEndOfRaceEvent
*/

DWORD
WorkerThread(
    PVOID ThreadIndex
    )
{

    unsigned long Me;
    unsigned long *MyCellVectorBase;
    unsigned long *CurrentCellVector;
    unsigned long MyRecalcValue;
    unsigned long MyNumberOfCells;
    unsigned long i,j;
    int GlobalMode;
    HANDLE hEvent;
    BOOL b;

    Me = (unsigned long)ThreadIndex;
    MyRecalcValue = 0;
    MyCellVectorBase = ThreadWork[Me].CellVector;
    MyNumberOfCells = ThreadWork[Me].NumberOfCells;
    GlobalMode = ThreadWork[Me].GlobalMode;

    /*
    // Signal that I am ready to go
    */

    if ( !SetEvent(ThreadReadyDoneEvents[Me]) ) {
        fprintf(stderr,"SMPSCALE (1) SetEvent(ThreadReadyDoneEvent[%d]) Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    /*
    // Wait for the master to release us to do the recalc
    */

    i = WaitForSingleObject(hStartOfRace,INFINITE);
    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"SMPSCALE Thread %d Wait for start of recalc Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    /*
    // perform the recalc operation
    */

    for (i=0, CurrentCellVector = MyCellVectorBase,j=0; i<MyNumberOfCells; i++ ) {
        if (GlobalMode){
            GlobalData[Me] += *CurrentCellVector++;
            }
        else {
            MyRecalcValue += *CurrentCellVector++;
            }
        }
    if (GlobalMode){
        MyRecalcValue = GlobalData[Me];
        }
    ThreadWork[Me].RecalcResult = MyRecalcValue;

    /*
    // Signal that I am done and then wait for further instructions
    */

    if ( !SetEvent(ThreadReadyDoneEvents[Me]) ) {
        fprintf(stderr,"SMPSCALE (2) SetEvent(ThreadReadyDoneEvent[%d]) Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    i = WaitForSingleObject(hEndOfRace,INFINITE);
    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"SMPSCALE Thread %d Wait for end of recalc Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    return MyRecalcValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\char\tspin.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

HANDLE ThreadHandles[32];

DWORD
WorkerThread(
    PVOID ThreadIndex
    )
{

    DWORD Processor;
    BOOL DoSleep;

    Processor = (DWORD)ThreadIndex;
    if ( Processor > 100 ) {
        DoSleep = TRUE;
        Processor -= 100;
        }
    else {
        DoSleep = FALSE;
        }
    SetThreadAffinityMask(GetCurrentThread(),1 << Processor);
    for(;;){
        if ( Processor & 1 ) {
            SetThreadPriority(ThreadHandles[Processor-1],THREAD_PRIORITY_ABOVE_NORMAL);
            SetThreadPriority(ThreadHandles[Processor-1],THREAD_PRIORITY_NORMAL);
            }
        else {
            if ( DoSleep ) {
                Sleep(0);
                }
            }
        }
    return 0;
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD i;
    SYSTEM_INFO SystemInfo;
    DWORD ThreadId;
    HANDLE hThread;

    GetSystemInfo(&SystemInfo);
    if ( SystemInfo.dwNumberOfProcessors >= 3 ) {

        for ( i=0;i<SystemInfo.dwNumberOfProcessors;i++) {

            ThreadHandles[i] = CreateThread(
                                NULL,
                                0,
                                WorkerThread,
                                (PVOID)(i),
                                0,
                                &ThreadId
                                );

            if ( !ThreadHandles[i] ) {
                fprintf(stdout,"CreateThread failed %d\n",GetLastError());
                ExitProcess(1);
                }
            }

        for ( i=0;i<SystemInfo.dwNumberOfProcessors;i++) {
            if ( (i & 1) == 0 ) {

                hThread = CreateThread(
                            NULL,
                            0,
                            WorkerThread,
                            (PVOID)(100+i),
                            0,
                            &ThreadId
                            );

                if ( !ThreadHandles[i] ) {
                    fprintf(stdout,"CreateThread failed %d\n",GetLastError());
                    ExitProcess(1);
                    }
                CloseHandle(hThread);
                }
            }
        Sleep(60000);
        }
    ExitProcess(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\char\i386\move.asm ===
title  "Move Test"
;++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   move.asm
;
; Abstract:
;
;   This module implements code to test x86 move instruction timing.
;
; Author:
;
;   Mark Lucovsky (markl) 28-Sep-1990
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        subttl  "Move To register"
;++
;
; VOID
; FASTCALL
; RegToMem (
;     IN ULONG Count,
;     IN PULONG Address
;     )
;
; Routine Description:
;
;   This function performs a move dword to register in a loop such that the
;   loop overhead is negligible.
;
; Arguments:
;
;   Count (ecx) - Supplies the iteration count.
;
;   Address (edx) - Supplies the source address.
;
; Return Value:
;
;   None.
;
;--

cPublicFastCall RegToMem, 2

RTM10:  mov     [edx], eax              ; repeat move 32 times in a loop
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        dec     ecx                     ;
        jnz     RTM10                   ;
        fstRET  RegToMem

        fstENDP RegToMem

        subttl  "Move To register"
;++
;
; VOID
; FASTCALL
; MemToReg (
;     IN ULONG Count,
;     IN PULONG Address
;     )
;
; Routine Description:
;
;   This function performs a move dword to register in a loop such that the
;   loop overhead is negligible.
;
; Arguments:
;
;   Count (ecx) - Supplies the iteration count.
;
;   Address (edx) - Supplies the source address.
;
; Return Value:
;
;   None.
;
;--

cPublicFastCall MemToReg, 2

MTR10:  mov     eax, [edx]              ; repeat move 32 times in a loop
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        dec     ecx                     ;
        jnz     MTR10                   ;
        fstRET  MemToReg

        fstENDP MemToReg

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\intrlk\intrlk.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    intrlk.c

Abstract:

    This module contains code to test the generation of code for interlocked
    intrinsics.

Author:

    David N. Cutler (davec) 15-Feb-2001

Environment:

    User mode.

Revision History:

    None.

--*/

#include <ntos.h>

//
// Main program.
//

void
test (
    void
    )

{

    LONG Var1;
    LONG Cmp1;
    LONG64 Var2;
    LONG64 Cmp2;
    PVOID Ptr1;
    PVOID Ptr2;

    Cmp1 = InterlockedAnd(&Var1, 4);
    InterlockedAnd(&Cmp1, 4);

    Cmp1 = InterlockedOr(&Var1, 8);
    InterlockedOr(&Cmp1, 8);

    Cmp1 = InterlockedXor(&Var1, 16);
    InterlockedXor(&Cmp1, 16);

    Cmp2 = InterlockedAnd64(&Var2, 4);
    InterlockedAnd64(&Cmp2, 4);

    Cmp2 = InterlockedOr64(&Var2, 8);
    InterlockedOr64(&Cmp2, 8);

    Cmp2 = InterlockedXor64(&Var2, 16);
    InterlockedXor64(&Cmp2, 16);

    Cmp1 = InterlockedIncrement(&Var1);
    InterlockedIncrement(&Cmp1);

    Cmp1 = InterlockedDecrement(&Var1);
    InterlockedDecrement(&Cmp1);

    Cmp2 = InterlockedIncrement64(&Var2);
    InterlockedIncrement64(&Cmp2);

    Cmp2 = InterlockedDecrement64(&Var2);
    InterlockedDecrement64(&Var2);

    Cmp1 = InterlockedExchange(&Var1, 4);
    InterlockedExchange(&Cmp1, 8);

    Cmp2 = InterlockedExchange64(&Var2, 4);
    InterlockedExchange64(&Cmp2, 8);

    Cmp1 = InterlockedExchangeAdd(&Var1, 4);
    InterlockedExchangeAdd(&Cmp1, 8);

    Cmp2 = InterlockedExchangeAdd64(&Var2, 4);
    InterlockedExchangeAdd64(&Cmp2, 8);

    Cmp1 = InterlockedCompareExchange(&Var1, 4, Cmp1);
    InterlockedCompareExchange(&Cmp1, 8, Var1);

    Cmp2 = InterlockedCompareExchange64(&Var2, 4, Cmp2);
    InterlockedCompareExchange64(&Cmp2, 8, Var2);

    Ptr1 = InterlockedExchangePointer(&Ptr2, (PVOID)4);
    InterlockedExchangePointer(&Ptr1, Ptr2);

    Ptr1 = InterlockedCompareExchangePointer(&Ptr2, (PVOID)4, Ptr1);
    InterlockedCompareExchangePointer(&Ptr2, (PVOID)8, Ptr1);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\nbqueue\nbtest.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    nbtest.c

Abstract:

    This module contains code to stress test the nonblocking queue functions.

Author:

    David N. Cutler (davec) 19-May-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"
#include "windef.h"
#include "winbase.h"

//
// Define locals constants.
//

#define TABLE_SIZE 2
#define THREAD_NUMBER 2

//
// Define external prototypes.
//

typedef struct _NBQUEUE_BLOCK {
    ULONG64 Next;
    ULONG64 Data;
} NBQUEUE_BLOCK, *PNBQUEUE_BLOCK;

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    );

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    );

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    );

//
// Define local routine prototypes.
//

NTSTATUS
MyCreateThread (
    OUT PHANDLE Handle,
    IN PUSER_THREAD_START_ROUTINE StartRoutine,
    PVOID Context

    );

VOID
StressNBQueueEven (
    VOID
    );

VOID
StressNBQueueOdd (
    VOID
    );

NTSTATUS
ThreadMain (
    IN PVOID Context
    );

//
// Define static storage.
//

HANDLE Thread1Handle;
HANDLE Thread2Handle;
HANDLE Thread3Handle;
HANDLE Thread4Handle;
HANDLE Thread5Handle;
HANDLE Thread6Handle;
HANDLE Thread7Handle;
HANDLE Thread8Handle;

//
// Define nonblocking queues
//

PVOID ClrQueue;
PVOID SetQueue;

SLIST_HEADER SListHead;

LONG Table[TABLE_SIZE];

volatile ULONG StartSignal = 0;
ULONG StopSignal = 0;

//
// Begin test code.
//

int
__cdecl
main(
    int argc,
    char *argv[]
    )

{

    ULONG Index;
    PSINGLE_LIST_ENTRY Entry;
    NTSTATUS Status;

    //
    // Initialize the SLIST headers and insert TABLE_SIZE + 2 entries.
    //

    RtlInitializeSListHead(&SListHead);
    for (Index = 0; Index < (TABLE_SIZE + 2); Index += 1) {
        Entry = (PSINGLE_LIST_ENTRY)malloc(sizeof(NBQUEUE_BLOCK));
        if (Entry == NULL) {
            printf("unable to allocate SLIST entry\n");
            return 0;
        }

        InterlockedPushEntrySList(&SListHead, Entry);
    }

    //
    // Initialize the clear entry nonblocking queue elements.
    //

    ClrQueue = ExInitializeNBQueueHead(&SListHead);
    if (ClrQueue == NULL) {
        printf("unable to initialize clr nonblock queue\n");
        return 0;
    }

    for (Index = 0; Index < (TABLE_SIZE / 2); Index += 1) {
        if (ExInsertTailNBQueue(ClrQueue, Index) == FALSE) {
            printf("unable to insert in clear nonblocking queue\n");
            return 0;
        }

        Table[Index] = 0;
    }

    //
    // Initialize the set entry nonblocking queue elements.
    //

    SetQueue = ExInitializeNBQueueHead(&SListHead);
    if (SetQueue == NULL) {
        printf("unable to initialize set nonblock queue\n");
        return 0;
    }

    for (Index = (TABLE_SIZE / 2); Index < TABLE_SIZE; Index += 1) {
        if (ExInsertTailNBQueue(SetQueue, Index) == FALSE) {
            printf("unable to insert in set nonblocking queue\n");
            return 0;
        }

        Table[Index] = 1;
    }

    //
    // Create and start the background timer thread.
    //

    Status = MyCreateThread(&Thread1Handle,
                            ThreadMain,
                            (PVOID)1);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create thread during initialization\n");
        return 0;

    } else {
        StartSignal = 1;
        StressNBQueueEven();
    }

    return 0;
}

VOID
StressNBQueueEven (
    VOID
    )

{

    ULONG64 Value;

    do {
        do {

            //
            // Attempt to remove an entry from the clear queue.
            //
            // Entries in this list should be clear in the table array.
            //
    
            if (ExRemoveHeadNBQueue(ClrQueue, &Value) != FALSE) {
                if ((ULONG)Value > 63) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }

                if (InterlockedExchange(&Table[(ULONG)Value], 1) != 0) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
                if (ExInsertTailNBQueue(SetQueue, (ULONG)Value) == FALSE) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
            } else {
                break;
            }
    
        } while (TRUE);

        do {
    
            //
            // Attempt to remove an entry from the set queue.
            //
            // Entries in this list should be set in the table array.
            //
    
            if (ExRemoveHeadNBQueue(SetQueue, &Value) != FALSE) {
                if ((ULONG)Value > 63) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }

                if (InterlockedExchange(&Table[(ULONG)Value], 0) != 1) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
                if (ExInsertTailNBQueue(ClrQueue, (ULONG)Value) == FALSE) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
            } else {
                break;
            }
    
        } while (TRUE);

    } while (TRUE);

    return;
}

VOID
StressNBQueueOdd (
    VOID
    )

{

    ULONG64 Value;

    do {
        do {
    
            //
            // Attempt to remove an entry from the set queue.
            //
            // Entries in this list should be set in the table array.
            //
    
            if (ExRemoveHeadNBQueue(SetQueue, &Value) != FALSE) {
                if ((ULONG)Value > 63) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }

                if (InterlockedExchange(&Table[(ULONG)Value], 0) != 1) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
        
                if (ExInsertTailNBQueue(ClrQueue, (ULONG)Value) == FALSE) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
            } else {
                break;
            }
    
        } while (TRUE);

        do {
    
            //
            // Attempt to remove an entry from the clear queue.
            //
            // Entries in this list should be clear in the table array.
            //
    
            if (ExRemoveHeadNBQueue(ClrQueue, &Value) != FALSE) {
                if ((ULONG)Value > 63) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }

                if (InterlockedExchange(&Table[(ULONG)Value], 1) != 0) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
                if (ExInsertTailNBQueue(SetQueue, (ULONG)Value) == FALSE) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
            } else {
                break;
            }
    
        } while (TRUE);

    } while (TRUE);

    return;
}

NTSTATUS
ThreadMain (
    IN PVOID Context
    )

{

    //
    // Wait until start signal is given.
    //

    do {
    } while (StartSignal == 0);

    if (((ULONG_PTR)Context & 1) == 0) {
        StressNBQueueEven();

    } else {
        StressNBQueueOdd();
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MyCreateThread (
    OUT PHANDLE Handle,
    IN PUSER_THREAD_START_ROUTINE StartRoutine,
    PVOID Context
    )

{

    NTSTATUS Status;

    //
    // Create a thread and start its execution.
    //

    Status = RtlCreateUserThread(NtCurrentProcess(),
                                 NULL,
                                 FALSE,
                                 0,
                                 0,
                                 0,
                                 StartRoutine,
                                 Context,
                                 Handle,
                                 NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\nt\hrderr.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    ULONG ErrorParameters[2];
    ULONG ErrorResponse;
    UNICODE_STRING PathName;

    RtlInitUnicodeString(&PathName,L"\\\\??\\O:\\AUTORUN.EXE");
    ErrorResponse = ResponseOk;
    ErrorParameters[0] = (ULONG)&PathName;

    NtRaiseHardError( STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE,
                      1,
                      1,
                      ErrorParameters,
                      OptionOk,
                      &ErrorResponse
                    );

    RtlInitUnicodeString(&PathName,L"\\\\??\\O:\\autorun.exe");
    ErrorResponse = ResponseOk;
    ErrorParameters[0] = (ULONG)&PathName;

    NtRaiseHardError( STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE,
                      1,
                      1,
                      ErrorParameters,
                      OptionOk,
                      &ErrorResponse
                    );
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\nbqueue\nbqueue.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nbqueue.c

Abstract:

   This module implements non-blocking fifo queue.

Author:

    David N. Cutler (davec) 24-Apr-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"
#include "malloc.h"

VOID
DbgBreakPoint (
    VOID
    );
extern ULONG StopSignal;

//
// Define non-blocking interlocked queue functions.
//
// A non-blocking queue is a singly link list of queue entries with a
// head pointer and a tail pointer. The head and tail pointers use
// sequenced pointers as do next links in the entries themselves. The
// queueing discipline is FIFO. New entries are inserted at the tail
// of the list and current entries are removed from the front of the
// list.
//
// Non-blocking queues require a descriptor for each entry in the queue.
// A descriptor consists of a sequenced next pointer and a PVOID data
// value. Descriptors for a queue must be preallocated and inserted in
// an SLIST before calling the function to initialize a non-blocking
// queue header. The SLIST should have as many entries as required for
// the respective queue.
//

typedef struct _NBQUEUE_BLOCK {
    ULONG64 Next;
    ULONG64 Data;
} NBQUEUE_BLOCK, *PNBQUEUE_BLOCK;

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    );

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    );

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    );

#if defined(_X86_)

#define InterlockedCompareExchange64(Destination, Exchange, Comperand) \
    xInterlockedCompareExchange64(Destination, &(Exchange), &(Comperand))

LONG64
__fastcall
xInterlockedCompareExchange64 (
    IN OUT LONG64 volatile * Destination,
    IN PLONG64 Exchange,
    IN PLONG64 Comparand
    );

#elif defined(_IA64_)

#define InterlockedCompareExchange64 _InterlockedCompareExchange64

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange64)

#endif

//
// Define queue pointer structure - this is platform target specific.
//

#if defined(_AMD64_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG64 Node : 48;
        LONG64 Count : 16;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#elif defined(_X86_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG Count;
        LONG Node;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#elif defined(_IA64_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG64 Node : 45;
        LONG64 Region : 3;
        LONG64 Count : 16;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;


#else

#error "no target architecture"

#endif

//
// Define queue node struture.
//

typedef struct _NBQUEUE_NODE {
    NBQUEUE_POINTER Next;
    ULONG64 Value;
} NBQUEUE_NODE, *PNBQUEUE_NODE;

//
// Define inline functions to pack and unpack pointers in the platform
// specific non-blocking queue pointer structure.
//

#if defined(_AMD64_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG64)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)((LONG64)(Entry->Node));
}

#elif defined(_X86_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)(Entry->Node);
}

#elif defined(_IA64_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG64)Node;
    Entry->Region = (LONG64)Node >> 61;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{

    LONG64 Value;

    Value = Entry->Node & 0x1fffffffffffffff;
    Value |= Entry->Region << 61;
    return (PVOID)(Value);
}

#else

#error "no target architecture"

#endif

//
// Define queue descriptor structure.
//

typedef struct _NBQUEUE_HEADER {
    NBQUEUE_POINTER Head;
    NBQUEUE_POINTER Tail;
    PSLIST_HEADER SlistHead;
} NBQUEUE_HEADER, *PNBQUEUE_HEADER;

typedef struct _NBQUEUE_LOG {
    ULONG_PTR Type;
    PNBQUEUE_HEADER Queue;
    NBQUEUE_POINTER Head;
    NBQUEUE_POINTER Tail;
    NBQUEUE_POINTER Next;
    ULONG_PTR Value;
    PNBQUEUE_NODE Node;
    PVOID *Address;
    ULONG_PTR Fill;
} NBQUEUE_LOG, *PNBQUEUE_LOG;

#define NBQUEUE_LOG_SIZE 64

NBQUEUE_LOG NbLog[NBQUEUE_LOG_SIZE + 1];

ULONG xLogIndex = -1;

#define LogInsertData(_queue_, _head_, _tail_, _next_) { \
    if (StopSignal != 0) {                               \
        LogIndex = NBQUEUE_LOG_SIZE;                     \
    } else {                                             \
        LogIndex = InterlockedIncrement(&xLogIndex) & (NBQUEUE_LOG_SIZE - 1); \
    }                                                    \
    NbLog[LogIndex].Type = 0;                            \
    NbLog[LogIndex].Queue = _queue_;                     \
    NbLog[LogIndex].Head.Data = (_head_);                \
    NbLog[LogIndex].Tail.Data = (_tail_);                \
    NbLog[LogIndex].Next.Data = (_next_);                \
}

#define LogRemoveData(_queue_, _head_, _tail_, _next_) { \
    if (StopSignal != 0) {                               \
        LogIndex = NBQUEUE_LOG_SIZE;                     \
    } else {                                             \
        LogIndex = InterlockedIncrement(&xLogIndex) & (NBQUEUE_LOG_SIZE - 1); \
    }                                                    \
    NbLog[LogIndex].Type = 1;                            \
    NbLog[LogIndex].Queue = _queue_;                     \
    NbLog[LogIndex].Head.Data = (_head_);                \
    NbLog[LogIndex].Tail.Data = (_tail_);                \
    NbLog[LogIndex].Next.Data = (_next_);                \
}

#pragma alloc_text(PAGE, ExInitializeNBQueueHead)

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    )

/*++

Routine Description:

    This function initializes a non-blocking queue header.

    N.B. It is assumed that the specified SLIST has been populated with
         non-blocking queue nodes prior to calling this routine.

Arguments:

    SlistHead - Supplies a pointer to an SLIST header.

Return Value:

    If the non-blocking queue is successfully initialized, then the
    address of the queue header is returned as the function value.
    Otherwise, NULL is returned as the function value.

--*/

{

    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;

    //
    // Attempt to allocate the queue header. If the allocation fails, then
    // return NULL.
    //

    QueueHead = (PNBQUEUE_HEADER)malloc(sizeof(NBQUEUE_HEADER));
    if (QueueHead == NULL) {
        return NULL;
    }

    //
    // Attempt to allocate a queue node from the specified SLIST. If a node
    // can be allocated, then initialize the non-blocking queue header and
    // return the address of the queue header. Otherwise, free the queue
    // header and return NULL.
    //

    QueueHead->SlistHead = SlistHead;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);

    if (QueueNode != NULL) {

        //
        // Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = 0;

        //
        // Initialize the head and tail pointers in the queue header.
        //

        PackNBQPointer(&QueueHead->Head, QueueNode);
        QueueHead->Head.Count = 0;
        PackNBQPointer(&QueueHead->Tail, QueueNode);
        QueueHead->Tail.Count = 0;
        return QueueHead;

    } else {
        free(QueueHead);
        return NULL;
    }
}

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    )

/*++

Routine Description:

    This function inserts the specific data value at the tail of the
    specified non-blocking queue.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to an opaque data value.

Return Value:

    If the specified opaque data value is successfully inserted at the tail
    of the specified non-blocking queue, then a value of TRUE is returned as
    the function value. Otherwise, a value of FALSE is returned.

    N.B. FALSE is returned if a queue node cannot be allocated from the
         associated SLIST.

--*/

{

    NBQUEUE_POINTER Head;
    NBQUEUE_POINTER Insert;
    ULONG LogIndex;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // Attempt to allocate a queue node from the SLIST associated with
    // the specified non-blocking queue. If a node can be allocated, then
    // the node is inserted at the tail of the specified non-blocking
    // queue, and TRUE is returned as the function value. Otherwise, FALSE
    // is returned.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);

    if (QueueNode != NULL) {

        //
        //  Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = Value;

        //
        // The following loop is executed until the specified entry can
        // be safely inserted at the tail of the specified non-blocking
        // queue.
        //

        do {

            //
            // Read the tail queue pointer and the next queue pointer of
            // the tail queue pointer making sure the two pointers are
            // coherent.
            //

            Head.Data = *((volatile LONG64 *)(&QueueHead->Head.Data));
            Tail.Data = *((volatile LONG64 *)(&QueueHead->Tail.Data));
            TailNode = UnpackNBQPointer(&Tail);
            Next.Data = *((volatile LONG64 *)(&TailNode->Next.Data));
            LogInsertData(QueueHead, Head.Data, Tail.Data, Next.Data);
            NbLog[LogIndex].Address = &Header;

            QueueNode->Next.Count = Tail.Count + 1;
            if (Tail.Data == *((volatile LONG64 *)(&QueueHead->Tail.Data))) {

                //
                // If the tail is pointing to the last node in the list,
                // then attempt to insert the new node at the end of the
                // list. Otherwise, the tail is not pointing to the last
                // node in the list and an attempt is made to move the
                // tail pointer to the next node.
                //

                NextNode = UnpackNBQPointer(&Next);
                if (NextNode == NULL) {
                    PackNBQPointer(&Insert, QueueNode);
                    Insert.Count = Next.Count + 1;
                    if (InterlockedCompareExchange64(&TailNode->Next.Data,
                                                     Insert.Data,
                                                     Next.Data) == Next.Data) {

                        NbLog[LogIndex].Value = (ULONG)Value;
                        NbLog[LogIndex].Node = QueueNode;
                        break;

                    } else {
                        NbLog[LogIndex].Value = 0xffffffff;
                        NbLog[LogIndex].Node = QueueNode;
                    }

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    if (InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                     Insert.Data,
                                                     Tail.Data) == Tail.Data) {

                        NbLog[LogIndex].Value = 0xffffff00;
                        NbLog[LogIndex].Node = QueueNode;

                    } else {
                        NbLog[LogIndex].Value = 0xffff0000;
                        NbLog[LogIndex].Node = QueueNode;
                    }
                }

            } else {
                NbLog[LogIndex].Value = 0x000000ff;
                NbLog[LogIndex].Node = QueueNode;
            }

        } while (TRUE);

        //
        // Attempt to move the tail to the new tail node.
        //


        LogInsertData(QueueHead, Head.Data, Tail.Data, Next.Data);
        NbLog[LogIndex].Address = &Header;
        PackNBQPointer(&Insert, QueueNode);
        Insert.Count = Tail.Count + 1;
        if (InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                         Insert.Data,
                                         Tail.Data) == Tail.Data) {

            NbLog[LogIndex].Value = 0x0000ffff;
            NbLog[LogIndex].Node = QueueNode;

        } else {
            NbLog[LogIndex].Value = 0x00ffffff;
            NbLog[LogIndex].Node = QueueNode;
        }

        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    )

/*++

Routine Description:

    This function removes a queue entry from the head of the specified
    non-blocking queue and returns the associated data value.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to a variable that receives the queue
        element value.

Return Value:

    If an entry is removed from the specified non-blocking queue, then
    TRUE is returned as the function value. Otherwise, FALSE is returned.

--*/

{

    NBQUEUE_POINTER Head;
    PNBQUEUE_NODE HeadNode;
    NBQUEUE_POINTER Insert;
    ULONG LogIndex;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // The following loop is executed until an entry can be removed from
    // the specified non-blocking queue or until it can be determined that
    // the queue is empty.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;

    do {

        //
        // Read the head queue pointer, the tail queue pointer, and the
        // next queue pointer of the head queue pointer making sure the
        // three pointers are coherent.
        //

        Head.Data = *((volatile LONG64 *)(&QueueHead->Head.Data));
        Tail.Data = *((volatile LONG64 *)(&QueueHead->Tail.Data));
        HeadNode = UnpackNBQPointer(&Head);
        Next.Data = *((volatile LONG64 *)(&HeadNode->Next.Data));
        LogRemoveData(QueueHead, Head.Data, Tail.Data, Next.Data);
        NbLog[LogIndex].Address = &Header;

        if (Head.Data == *((volatile LONG64 *)(&QueueHead->Head.Data))) {

            //
            // If the queue header node is equal to the queue tail node,
            // then either the queue is empty or the tail pointer is falling
            // behind. Otherwise, there is an entry in the queue that can
            // be removed.
            //

            NextNode = UnpackNBQPointer(&Next);
            TailNode = UnpackNBQPointer(&Tail);
            if (HeadNode == TailNode) {

                //
                // If the next node of head pointer is NULL, then the queue
                // is empty. Otherwise, attempt to move the tail forward.
                //

                if (NextNode == NULL) {
                    NbLog[LogIndex].Value = 0xffffffff;
                    NbLog[LogIndex].Node = NULL;
                    *Value = 0xffffffff;
                    return FALSE;

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    if (InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                 Insert.Data,
                                                 Tail.Data) == Tail.Data) {

                        NbLog[LogIndex].Value = 0xffffff00;
                        NbLog[LogIndex].Node = NULL;

                    } else {
                        NbLog[LogIndex].Value = 0xffff0000;
                        NbLog[LogIndex].Node = NULL;
                    }
                }

            } else {

                //
                // Attempt to remove the first entry at the head of the queue.
                //

                *Value = ((ULONG64)LogIndex << 32) | NextNode->Value;
                PackNBQPointer(&Insert, NextNode);
                Insert.Count = Head.Count + 1;
                if (InterlockedCompareExchange64(&QueueHead->Head.Data,
                                                 Insert.Data,
                                                 Head.Data) == Head.Data) {

                    NbLog[LogIndex].Value = (ULONG)*Value;
                    NbLog[LogIndex].Node = NextNode;
                    break;

                } else {
                    NbLog[LogIndex].Value = 0x00ffffff;
                    NbLog[LogIndex].Node = NextNode;
                }
            }

        } else {
            NbLog[LogIndex].Value = 0x0000ffff;
            NbLog[LogIndex].Node = NULL;
        }

    } while (TRUE);

    //
    // Free the node that was removed for the list by inserting the node
    // in the associated SLIST.
    //

    InterlockedPushEntrySList(QueueHead->SlistHead,
                              (PSINGLE_LIST_ENTRY)HeadNode);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\nt\ntbm.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>


#define ONEK    1000
#define FIVEK   5000
#define TENK    10000
#define ONEHUNK 100000
#define ONEMIL  1000000


//
// Define local types.
//

typedef struct _PERFINFO {
    DWORD StartTime;
    DWORD StopTime;
    LPSTR Title;
    DWORD Iterations;
} PERFINFO, *PPERFINFO;

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    DWORD ContextSwitches;
    DWORD Duration;
    DWORD Performance;


    //
    // Print results and announce end of test.
    //

    PerfInfo->StopTime = GetTickCount();

    Duration = PerfInfo->StopTime - PerfInfo->StartTime;
    printf("        Test time in milliseconds %d\n", Duration);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = PerfInfo->Iterations * 1000 / Duration;
    printf("        Iterations per second     %d\n", Performance);


    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN DWORD Iterations,
    IN PPERFINFO PerfInfo
    )

{

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    PerfInfo->StartTime = GetTickCount();
    return;
}

HANDLE
APIENTRY
FastFindOpenDir(
    LPCWSTR lpFileName
    )

{

    HANDLE hFindFile;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    UNICODE_STRING UnicodeInput;
    BOOLEAN EndsInDot;

    RtlInitUnicodeString(&UnicodeInput,lpFileName);

    //
    // Bogus code to workaround ~* problem
    //

    if ( UnicodeInput.Buffer[(UnicodeInput.Length>>1)-1] == (WCHAR)'.' ) {
        EndsInDot = TRUE;
        }
    else {
        EndsInDot = FALSE;
        }


    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &PathName,
                            &FileName.Buffer,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        return NULL;
        }

    FreeBuffer = PathName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the directory for list access
    //

    Status = NtOpenFile(
                &hFindFile,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( !NT_SUCCESS(Status) ) {
        return NULL;
        }
    return hFindFile;
}

BOOL
FastFind(
    HANDLE hFindFile,
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    UNICODE_STRING UnicodeInput;
    BOOLEAN EndsInDot;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    CHAR Buffer[MAX_PATH*2 + sizeof(FILE_BOTH_DIR_INFORMATION)];

    RtlInitUnicodeString(&FileName,lpFileName);
    DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION)Buffer;

    Status = NtQueryDirectoryFile(
                hFindFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                DirectoryInfo,
                sizeof(Buffer),
                FileBothDirectoryInformation,
                TRUE,
                &FileName,
                TRUE
                );

    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
        }

    //
    // Attributes are composed of the attributes returned by NT.
    //

    lpFindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
    lpFindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
    lpFindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
    lpFindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
    lpFindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
    lpFindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

    RtlMoveMemory( lpFindFileData->cFileName,
                   DirectoryInfo->FileName,
                   DirectoryInfo->FileNameLength );

    lpFindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

    RtlMoveMemory( lpFindFileData->cAlternateFileName,
                   DirectoryInfo->ShortName,
                   DirectoryInfo->ShortNameLength );

    lpFindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

    return TRUE;
}


VOID
FastFindTest(
    VOID

    )
{
    PERFINFO PerfInfo;
    int i;
    HANDLE hFind;
    WIN32_FIND_DATAW FindFileData;
    BOOL b;


    hFind = FastFindOpenDir(L"d:\\testdir\\client1\\bench");

    if ( !hFind ) {
        printf("Failed\n");
        return;
        }

    StartBenchMark(
        "FastFind Test",
        ONEK,
        &PerfInfo
        );

    for ( i=0;i<5*ONEK;i++) {

        //
        // do 5 calls 3 work, 2 don't
        //

        b = FastFind(hFind,L"a",&FindFileData);
        if ( !b ) {
            printf("Test Failure a\n");
            ExitProcess(0);
            }
        b = FastFind(hFind,L"ab",&FindFileData);
        if ( b ) {
            printf("Test Failure ab\n");
            ExitProcess(0);
            }
        b = FastFind(hFind,L"abc",&FindFileData);
        if ( !b ) {
            printf("Test Failure abc\n");
            ExitProcess(0);
            }
        b = FastFind(hFind,L"da",&FindFileData);
        if ( b ) {
            printf("Test Failure da\n");
            ExitProcess(0);
            }
        b = FastFind(hFind,L"dxxa",&FindFileData);
        if ( !b ) {
            printf("Test Failure dxxa\n");
            ExitProcess(0);
            }
        }

    FinishBenchMark(&PerfInfo);
}

VOID
FindFirstTest(
    VOID

    )
{
    PERFINFO PerfInfo;
    int i;
    HANDLE hFind;
    WIN32_FIND_DATAW FindFileData;
    BOOL b;


    StartBenchMark(
        "Stock FindFirst Test",
        ONEK,
        &PerfInfo
        );

    for ( i=0;i<5*ONEK;i++) {

        //
        // do 5 calls 3 work, 2 don't
        //

        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\a",&FindFileData);
        if ( hFind == INVALID_HANDLE_VALUE ) {
            printf("Test Failure a\n");
            ExitProcess(0);
            }
        FindClose(hFind);

        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\ab",&FindFileData);
        if ( hFind != INVALID_HANDLE_VALUE ) {
            printf("Test Failure ab\n");
            ExitProcess(0);
            }

        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\abc",&FindFileData);
        if ( hFind == INVALID_HANDLE_VALUE ) {
            printf("Test Failure abc\n");
            ExitProcess(0);
            }
        FindClose(hFind);


        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\da",&FindFileData);
        if ( hFind != INVALID_HANDLE_VALUE ) {
            printf("Test Failure da\n");
            ExitProcess(0);
            }


        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\dxxa",&FindFileData);
        if ( hFind == INVALID_HANDLE_VALUE ) {
            printf("Test Failure dxxa\n");
            ExitProcess(0);
            }
        FindClose(hFind);

        }

    FinishBenchMark(&PerfInfo);
}

VOID
APIENTRY
CreateOpenDirObja(
    LPCWSTR lpFileName,
    POBJECT_ATTRIBUTES Obja,
    PUNICODE_STRING PathName,
    LPCWSTR DirName
    )

{

    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    HANDLE hDir;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(DirName) ) {


        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                DirName,
                                PathName,
                                &FileName.Buffer,
                                &RelativeName
                                );

        if ( TranslationStatus ) {


            //
            // Open the directory for list access
            //

            InitializeObjectAttributes(
                Obja,
                PathName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

            Status = NtOpenFile(
                        &hDir,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                        );

            if ( !NT_SUCCESS(Status) ) {
                printf("Open faild %x\n",Status);
                ExitProcess(1);
                }
            }

        }
    else {
        hDir = NULL;
        }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            PathName,
                            &FileName.Buffer,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        return;
        }

    if ( hDir ) {
        PathName->Buffer = PathName->Buffer + 15;
        PathName->Length -= 30;
        PathName->MaximumLength -= 30;
        }

    FreeBuffer = PathName->Buffer;

    InitializeObjectAttributes(
        Obja,
        PathName,
        OBJ_CASE_INSENSITIVE,
        hDir,
        NULL
        );
}

VOID
APIENTRY
OpenCloseDir(
    POBJECT_ATTRIBUTES Obja
    )

{

    HANDLE hDir;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Open the directory for list access
    //

    Status = NtOpenFile(
                &hDir,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( !NT_SUCCESS(Status) ) {
        printf("Open faild %x\n",Status);
        ExitProcess(1);
        }
    NtClose(hDir);
}

VOID
OpenDirTest(
    VOID

    )
{
    PERFINFO PerfInfo;
    int i;
    HANDLE hDir;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING PathName;
    FILE_BASIC_INFORMATION BasicInfo;

#if 0
    CreateOpenDirObja(
        L"d:\\testdir\\client1\\bench",
        &Obja,
        &PathName,
        NULL
        );

    StartBenchMark(
        "Open Dir NTFS d:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        OpenCloseDir(&Obja);
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "NtQueryAttributes Dir NTFS d:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        NtQueryAttributesFile( &Obja, &BasicInfo );

        }

    FinishBenchMark(&PerfInfo);


    CreateOpenDirObja(
        L"c:\\testdir\\client1\\bench",
        &Obja,
        &PathName,
        NULL
        );

    StartBenchMark(
        "Open Dir FAT c:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        OpenCloseDir(&Obja);
        }

    FinishBenchMark(&PerfInfo);
#endif

    CreateOpenDirObja(
        L"d:\\testdir\\client1\\bench",
        &Obja,
        &PathName,
        L"d:\\"
        );

    StartBenchMark(
        "VOL Rel Open Dir NTFS d:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        OpenCloseDir(&Obja);
        }

    FinishBenchMark(&PerfInfo);


    CreateOpenDirObja(
        L"c:\\testdir\\client1\\bench",
        &Obja,
        &PathName,
        L"c:\\"
        );

    StartBenchMark(
        "Vol Rel Open Dir FAT c:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        OpenCloseDir(&Obja);
        }

    FinishBenchMark(&PerfInfo);
}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    DWORD CryptoKey;
    PDWORD p;

    printf("sixeof teb %x\n",sizeof(TEB));

    CryptoKey = USER_SHARED_DATA->CryptoExponent;

    printf("Key %x\n",CryptoKey);

    p = &(USER_SHARED_DATA->CryptoExponent);
    *p = 1;

    //OpenDirTest();
    //FastFindTest();
    //FindFirstTest();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\single\single.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slisttest.c

Abstract:

    This module implements a program which tests the interlocked SLIST
    functions exported from kernel32.dll. Since these functions are
    implemented in Win2000 and are just being exposed to windows programs
    this program is not an exhaustive test. Rather it just tests whether
    the interfaces exposed correctly.

Author:

    David N. Cutler (davec) 10-Jan-2000

Environment:

    User mode.

Revision History:

    None.

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include "e:\nt32\base\ntos\inc\intrlk.h"

#pragma intrinsic(__readgsdword)

//
// Define structure that will be used in SLIST.
//

typedef struct _PROGRAM_ITEM {

    //
    // Normally a SINGLE_LIST_ENTRY is the first member of the program
    // item structure, but it can be any member as long as the address
    // of the containing structure is computed correctly.
    //

    SINGLE_LIST_ENTRY ItemEntry;

    //
    // Additional members in the structure would be used for data
    // associated with whatever the program item represents. Here
    // the only use is for a signature that will be used for the
    // test.
    //

    ULONG Signature;
} PROGRAM_ITEM, *PPROGRAM_ITEM;

//
// Main program.
//

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )

{

    ULONG Count;
    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY LastEntry;
    SINGLE_LIST_ENTRY ListHead;
    PPROGRAM_ITEM ProgramItem;

    ListHead.Next = NULL;
    LastEntry = NULL;
    for (Count = 1; Count < 100; Count += 1) {
        ProgramItem = (PPROGRAM_ITEM)malloc(sizeof(*ProgramItem));
        ProgramItem->Signature = Count;
        FirstEntry = InterlockedPushEntrySingleList(&ListHead,
                                                    &ProgramItem->ItemEntry);

        if (FirstEntry != LastEntry) {
            printf("wrong old first entry\n");
        }

        LastEntry = &ProgramItem->ItemEntry;
//        Count = _byteswap_ulong(Count);
        Count = __readgsdword(Count);
    }

    for (Count = 99; Count > 0; Count -= 1) {
        FirstEntry = InterlockedPopEntrySingleList(&ListHead);
        ProgramItem = CONTAINING_RECORD(FirstEntry, PROGRAM_ITEM, ItemEntry);
        if (ProgramItem->Signature != Count) {
            printf("wring entry removed\n");
        }
    }

    if (ListHead.Next != NULL) {
        printf("list not empty\n");
    }

    printf("program ran successfully\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\nbqueue\i386\intrlk.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    slist.asm
;
; Abstract:
;
;    This module implements functions to support interlocked S-List
;    operations.
;
; Author:
;
;    David N. Cutler (davec) 13-Mar-1996
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list


_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; LONG64
; FASTCALL
; xInterlockedCompareExchange64 (
;    IN OUT PLONG64 Destination,
;    IN PLONG64 Exchange,
;    IN PLONG64 Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall xInterlockedCompareExchange64, 3

cPublicFpo 0,2

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  xInterlockedCompareExchange64

fstENDP xInterlockedCompareExchange64

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\slist\sl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slisttest.c

Abstract:

    This module implements a program which tests the interlocked SLIST
    functions exported from kernel32.dll. Since these functions are
    implemented in Win2000 and are just being exposed to windows programs
    this program is not an exhaustive test. Rather it just tests whether
    the interfaces exposed correctly.

Author:

    David N. Cutler (davec) 10-Jan-2000

Environment:

    User mode.

Revision History:

    None.

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>

//
// Define structure that will be used in SLIST.
//

typedef struct _PROGRAM_ITEM {

    //
    // Normally a SINGLE_LIST_ENTRY is the first member of the program
    // item structure, but it can be any member as long as the address
    // of the containing structure is computed correctly.
    //

    SINGLE_LIST_ENTRY ItemEntry;

    //
    // Additional members in the structure would be used for data
    // associated with whatever the program item represents. Here
    // the only use is for a signature that will be used for the
    // test.
    //

    ULONG Signature;
} PROGRAM_ITEM, *PPROGRAM_ITEM;

VOID
FrameNoCode (
    VOID
    );

VOID
FrameWithCode (
    VOID
    );

int
Bar (
    PULONG Switch
    )

{
    *Switch /= 3;
    return (*Switch & 1);
}

int
Foo (
    PULONG Switch
    )
{

    *Switch += 1;
    return (*Switch & 1);
}

//
// Main program.
//

int __cdecl
main(
    ULONG *Buffer1,
    ULONG *Buffer2,
    ULONG Length
    )

{

    ULONG Count = 1;
    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY ListEntry;
    SLIST_HEADER ListHead;
    PPROGRAM_ITEM ProgramItem;

    memmove(Buffer1, Buffer2, Length);
    memcpy(Buffer1, Buffer2, Length);
    memset(Buffer1, 0, Length);
    InitializeSListHead(&ListHead);
    Foo(&Count);
    try {
        ProgramItem = (PPROGRAM_ITEM)malloc(sizeof(*ProgramItem));
        ProgramItem->Signature = Count;
        FirstEntry = InterlockedPushEntrySList(&ListHead,
                                               &ProgramItem->ItemEntry);

        if (FirstEntry != NULL) {
            leave;
        }

        try {
            ListEntry = InterlockedPopEntrySList(&ListHead);
            ProgramItem = CONTAINING_RECORD(ListEntry, PROGRAM_ITEM, ItemEntry);
            if (ProgramItem->Signature != Count) {
                leave;
            }

            free((PCHAR)ProgramItem);

        } finally {
            if (AbnormalTermination()) {
                Foo(&Count);
            }
        }

        Bar(&Count);

    } except (Bar(&Count)) {
        Foo(&Count);
    }

    FrameNoCode();
    FrameWithCode();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\slist\slist1.c ===
#include <stdio.h>
#include <stdlib.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"

HANDLE rpipe, wpipe;
ULONG buf[1];
IO_STATUS_BLOCK iosb;


VOID
Save (
    ULONG Count)
{
    DWORD i;
    NTSTATUS status;
    DWORD retlen;

    for (i = 0; i < Count; i++) {
        status = NtFsControlFile (wpipe,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &iosb,
                                  FSCTL_PIPE_INTERNAL_WRITE,
                                  buf, sizeof (buf),
                                  NULL, 0);
        if (!NT_SUCCESS (status)) {
            printf ("NtFsControlFile failed %X\n", status);
            ExitProcess (1);
        }
    }

}
VOID
Restore (
    ULONG Count)
{
    IO_STATUS_BLOCK iosb;
    DWORD i;
    NTSTATUS status;
    DWORD retlen;

    for (i = 0; i < Count; i++) {
        if (!ReadFile (rpipe, buf, sizeof (buf), &retlen, NULL)) {
            printf ("ReadFileEx failed %d\n", GetLastError ());
            ExitProcess (1);
        }
    }

}
VOID
Invert (
    ULONG Count)
{
    Save (Count);
    Restore (Count);
}

DWORD
WINAPI
Thrash (LPVOID arg)
{
    IO_STATUS_BLOCK iosb;
    ULONG i;
    HANDLE Handle1, Handle2, Handle3;

    if (!arg) {
        SetThreadAffinityMask (GetCurrentThread (), 1);
        while (1) {

            NtQueryEaFile (NULL,
                           &iosb,
                           NULL,
                           0,
                           FALSE,
                           &buf,
                           sizeof (buf),
                           NULL,
                           FALSE);
        }
    } else {
        while (1) {

            SetThreadAffinityMask (GetCurrentThread (), 1);
            Save (1);
            Sleep (0);
            SetThreadAffinityMask (GetCurrentThread (), 2);

            NtSuspendThread ((HANDLE) arg, NULL);

            SetThreadAffinityMask (GetCurrentThread (), 1);

            Invert (2);


            for (i = 0; i < 256-2; i++) {
                NtQueryEaFile (NULL,
                               &iosb,
                               NULL,
                               0,
                               FALSE,
                               &buf,
                               sizeof (buf),
                               NULL,
                               FALSE);
            }

            NtResumeThread ((HANDLE) arg, NULL);
            Sleep (0);
            Restore (1);
            SetThreadAffinityMask (GetCurrentThread (), 2);
        }
    }
    return 0;
}


int __cdecl main ()
{
    ULONG i;
    HANDLE thread1;
    DWORD id;
    DWORD mode;
    OVERLAPPED ovl={0};

    wpipe = CreateNamedPipe ("\\\\.\\pipe\\testpipe",
                             PIPE_ACCESS_DUPLEX|FILE_FLAG_OVERLAPPED,
                             PIPE_TYPE_MESSAGE|PIPE_READMODE_MESSAGE|PIPE_WAIT,
                             1,
                             100,
                             100,
                             100000,
                             NULL);
    if (wpipe == INVALID_HANDLE_VALUE) {
        printf ("CreateNamedPipe failed %d\n", GetLastError ());
        ExitProcess (1);
    }
    if (!ConnectNamedPipe (wpipe, &ovl)) {
        if (GetLastError () != ERROR_IO_PENDING) {
            printf ("ConnectNamedPipe failed %d\n", GetLastError ());
            ExitProcess (1);
        }
    }

    rpipe = CreateFile ("\\\\.\\pipe\\testpipe",
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED,
                        NULL);
    if (rpipe == INVALID_HANDLE_VALUE) {
        printf ("CreateFile failed %d\n", GetLastError ());
        ExitProcess (1);
    }
    mode = PIPE_READMODE_MESSAGE|PIPE_WAIT;
    if (!SetNamedPipeHandleState (rpipe, &mode, NULL, NULL)) {
        printf ("SetNamedPipeHandleState failed %d\n", GetLastError ());
        ExitProcess (1);
    }

    thread1 = CreateThread (NULL, 0, Thrash, NULL, 0, &id);
    if (!thread1) {
       printf ("CreateThread failed %d\n", GetLastError ());
       exit (EXIT_FAILURE);
    }

    Thrash (thread1);
    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\daytona\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\throw\throw.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    throw.cpp

Abstract:

    This module implements a program which tests C++ EH.

Author:

    David N. Cutler (davec) 25-Jun-2001

Environment:

    User mode.

Revision History:

    None.

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>

VOID
func (
    ULONG N
    )

{
    if (N != 0) {
        throw N;
    }

    return;
}

//
// Main program.
//

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )

{
    try {
        func(5);
        printf("resuming, should never happen\n");

    } catch(ULONG) {
        printf("caught ULONG exception\n");

    } catch(CHAR *) {
        printf("caught CHAR * exception\n");

    } catch(...) {
        printf("caught typeless exception\n");
    }

    printf("terminating after try block\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bt\slist\amd64\tf.asm ===
TITLE  "Trap Frame Test Program"
;++
;
; Copyright (c) 2001 Microsoft Corporation
;
; Module Name:
;
;    tf.asm
;
; Abstract:
;
;    This is a test program that generates a trap frame with and without an
;    error code.
;
; Author:
;
;    David N. Cutler (davec) 11-Feb-2001
;
; Environment:
;
;    Kernel mode only.
;
;--

include ksamd64.inc

        LEAF_ENTRY KiInitiateUserApc, _TEXT$00

        retq                            ;

        LEAF_END KiInitiateUserApc, _TEXT$00

        subttl  "Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; ExceptionHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PDISPATCHER_CONTEXT DispatcherContext
;    )
;
; Routine Description:
;
;   This routine is an exception handler for the trap frame below with a
;   handler.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to  the dispatcher context
;       record.
;
; Return Value:
;
;   The exception disposition.
;
;--

        LEAF_ENTRY ExceptionHandler, _TEXT$00

        mov     eax, EXCEPTION_CONTINUE_SEARCH ; assume continue search
        test    dword ptr ErExceptionFlags[rcx], EXCEPTION_UNWIND ; test for unwind
        jnz     short Eh10              ; if nz, unwind in progress
        mov     eax, EXCEPTION_CONTINUE_EXECUTION ; set to continue execution
Eh10:   ret                             ; return

        LEAF_END ExceptionHandler, _TEXT$00

        subttl  "Frame Without Error Code - With Handler"
;++
;
; VOID
; FrameNoCode (
;     VOID
;     );
;
; Routine Description:
;
;   This routine generates a trap frame without an error, but with a handler.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY FrameNoCode, _TEXT$00, ExceptionHandler

        GENERATE_TRAP_FRAME             ; generate trap frame

        RESTORE_TRAP_STATE <Volatile>   ; restore trap state

        NESTED_END FrameNoCode, _TEXT$00

        subttl  "Frame With Code - Without Handler"
;++
;
; VOID
; FrameWithCode (
;     VOID
;     );
;
; Routine Description:
;
;   This routine generates a trap frame with an error code.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY FrameWithCode, _TEXT$00

        GENERATE_TRAP_FRAME code        ; generate trap frame

        RESTORE_TRAP_STATE <Service>    ; restore trap state

        NESTED_END FrameWithCode, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\i386\context.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains the context management routines for
    Win32

Author:

    Mark Lucovsky (markl) 28-Sep-1990

Revision History:

--*/

#include "basedll.h"

extern PVOID BasepLockPrefixTable;

//
// Specify address of kernel32 lock prefixes
//
IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    0,                              // Reserved
    0,                              // Reserved
    0,                              // Reserved
    0,                              // Reserved
    0,                              // GlobalFlagsClear
    0,                              // GlobalFlagsSet
    0,                              // CriticalSectionTimeout (milliseconds)
    0,                              // DeCommitFreeBlockThreshold
    0,                              // DeCommitTotalFreeThreshold
    (ULONG) &BasepLockPrefixTable,  // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0             // Reserved
};

VOID
BaseInitializeContext(
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL,
    IN BASE_CONTEXT_TYPE ContextType
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    Parameter - Supplies the thread's parameter.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

    NewThread - Supplies a flag that specifies that this is a new
        thread, or a new process.

Return Value:

    Raises STATUS_BAD_INITIAL_STACK if the value of InitialSp is not properly
           aligned.

    Raises STATUS_BAD_INITIAL_PC if the value of InitialPc is not properly
           aligned.

--*/

{

    Context->Eax = (ULONG)InitialPc;
    Context->Ebx = (ULONG)Parameter;

    Context->SegGs = 0;
    Context->SegFs = KGDT_R3_TEB;
    Context->SegEs = KGDT_R3_DATA;
    Context->SegDs = KGDT_R3_DATA;
    Context->SegSs = KGDT_R3_DATA;
    Context->SegCs = KGDT_R3_CODE;

    //
    // Start the thread at IOPL=3.
    //

    Context->EFlags = 0x3000;

    //
    // Always start the thread at the thread start thunk.
    //

    Context->Esp = (ULONG) InitialSp;

    if ( ContextType == BaseContextTypeThread ) {
        Context->Eip = (ULONG) BaseThreadStartThunk;
        }
    else if ( ContextType == BaseContextTypeFiber ) {
        Context->Eip = (ULONG) BaseFiberStart;
        }
    else {
        Context->Eip = (ULONG) BaseProcessStartThunk;
        }
    //
    // add code to check alignment and raise exception...
    //

    Context->ContextFlags = CONTEXT_FULL;
    Context->Esp -= sizeof(Parameter); // Reserve room for ret address
}

VOID
BaseFiberStart(
    VOID
    )

/*++

Routine Description:

    This function is called to start a Win32 fiber. Its purpose
    is to call BaseThreadStart, getting the necessary arguments
    from the fiber context record.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PFIBER Fiber;

    Fiber = GetCurrentFiber();
    BaseThreadStart( (LPTHREAD_START_ROUTINE)Fiber->FiberContext.Eax,
                     (LPVOID)Fiber->FiberContext.Ebx );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\i386\thunk.asm ===
title  "Thunks"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    thunk.asm
;
; Abstract:
;
;   This module implements all Win32 thunks. This includes the
;   first level thread starter...
;
; Author:
;
;   Mark Lucovsky (markl) 28-Sep-1990
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc
        .list
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

_BasepTickCountMultiplier    dd  0d1b71759H

_DATA ENDS


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;;      align  512

        page ,132
        subttl  "BaseThreadStartThunk"
;++
;
; VOID
; BaseThreadStartThunk(
;    IN PTHREAD_START_ROUTINE StartRoutine,
;    IN PVOID ThreadParameter
;    )
;
; Routine Description:
;
;    This function calls to the portable thread starter after moving
;    its arguments from registers to the stack.
;
; Arguments:
;
;    EAX - StartRoutine
;    EBX - ThreadParameter
;
; Return Value:
;
;    Never Returns
;
;--

        EXTRNP  _BaseThreadStart,2
cPublicProc _BaseThreadStartThunk,2

        xor     ebp,ebp
        push    ebx
        push    eax
        push    0
        jmp     _BaseThreadStart@8

stdENDP _BaseThreadStartThunk

;++
;
; VOID
; BaseProcessStartThunk(
;     IN LPVOID lpProcessStartAddress,
;     IN LPVOID lpParameter
;     );
;
; Routine Description:
;
;    This function calls the process starter after moving
;    its arguments from registers to the stack.
;
; Arguments:
;
;    EAX - StartRoutine
;    EBX - ProcessParameter
;
; Return Value:
;
;    Never Returns
;
;--

        EXTRNP  _BaseProcessStart,1
cPublicProc _BaseProcessStartThunk,2

        xor     ebp,ebp
        push    eax
        push    0
        jmp     _BaseProcessStart@4

stdENDP _BaseProcessStartThunk


;++
;
; VOID
; SwitchToFiber(
;    PFIBER NewFiber
;    )
;
; Routine Description:
;
;    This function saves the state of the current fiber and switches
;    to the new fiber.
;
; Arguments:
;
;    NewFiber (TOS+4) - Supplies the address of the new fiber.
;
; Return Value:
;
;    None
;
;--

cPublicProc _SwitchToFiber,1

        mov     edx,fs:[PcTeb]              ; edx is flat TEB
        mov     eax,[edx]+TbFiberData       ; eax points to current fiber


        ;
        ; Setup and save nonvolitile state
        ;


        mov     ecx,esp

        mov     [eax]+FbFiberContext+CsEbx,ebx
        mov     [eax]+FbFiberContext+CsEdi,edi
        mov     [eax]+FbFiberContext+CsEsi,esi
        mov     [eax]+FbFiberContext+CsEbp,ebp

        mov     ebx,[esp]                   ; get return address

        add     ecx,8                       ; adjust esp to account for args + ra
        mov     [eax]+FbFiberContext+CsEsp,ecx

        mov     [eax]+FbFiberContext+CsEip,ebx

        ;
        ; Save exception list, stack base, stack limit
        ;

        mov     ecx,[edx]+PcExceptionList
        mov     ebx,[edx]+PcStackLimit

        mov     [eax]+FbExceptionList,ecx
        mov     [eax]+FbStackLimit,ebx


        ;
        ; Now restore the new fiber
        ;

        mov     eax,[esp]+4                 ; eax is new fiber


        ;
        ; now restore new fiber TEB state
        ;

        mov     ecx,[eax]+FbExceptionList
        mov     ebx,[eax]+FbStackBase
        mov     esi,[eax]+FbStackLimit
        mov     edi,[eax]+FbDeallocationStack

        mov     [edx]+PcExceptionList,ecx
        mov     [edx]+PcInitialStack,ebx
        mov     [edx]+PcStackLimit,esi
        mov     [edx]+TbDeallocationStack,edi

        ;
        ; Restore FiberData
        ;

        mov     [edx]+TbFiberData,eax

        ;
        ; Restore new fiber nonvolitile state
        ;

        mov     edi,[eax]+FbFiberContext+CsEdi
        mov     esi,[eax]+FbFiberContext+CsEsi
        mov     ebp,[eax]+FbFiberContext+CsEbp
        mov     ebx,[eax]+FbFiberContext+CsEbx
        mov     ecx,[eax]+FbFiberContext+CsEip
        mov     esp,[eax]+FbFiberContext+CsEsp

        jmp     ecx

stdENDP _SwitchToFiber

;++
;
; VOID
; LdrpCallInitRoutine(
;    IN PDLL_INIT_ROUTINE InitRoutine,
;    IN PVOID DllHandle,
;    IN ULONG Reason,
;    IN PCONTEXT Context OPTIONAL
;    )
;
; Routine Description:
;
;    This function calls an x86 DLL init routine.  It is robust
;    against DLLs that don't preserve EBX or fail to clean up
;    enough stack.
;
;    The only register that the DLL init routine cannot trash is ESI.
;
; Arguments:
;
;    InitRoutine - Address of init routine to call
;
;    DllHandle - Handle of DLL to call
;
;    Reason - one of the DLL_PROCESS_... or DLL_THREAD... values
;
;    Context - context pointer or NULL
;
; Return Value:
;
;    FALSE if the init routine fails, TRUE for success.
;
;--

cPublicProc __ResourceCallEnumLangRoutine , 6

EnumRoutine     equ [ebp + 8]
ModuleHandle    equ [ebp + 12]
LpType          equ [ebp + 16]
LpName          equ [ebp + 20]
WLanguage       equ [ebp + 24]
LParam          equ [ebp + 28]

stdENDP __ResourceCallEnumLangRoutine
        push    ebp
        mov     ebp, esp
        push    esi         ; save esi across the call
        push    edi         ; save edi across the call
        push    ebx         ; save ebx on the stack across the call
        mov     esi,esp     ; save the stack pointer in esi across the call
        push    LParam
        push    WLanguage
	push    LpName
	push    LpType
	push    ModuleHandle
        call    EnumRoutine
        mov     esp,esi     ; restore the stack pointer in case callee forgot to clean up
        pop     ebx         ; restore ebx
        pop     edi         ; restore edi
        pop     esi         ; restore esi
        pop     ebp
        stdRET  __ResourceCallEnumLangRoutine

cPublicProc __ResourceCallEnumNameRoutine , 5

EnumRoutine     equ [ebp + 8]
ModuleHandle    equ [ebp + 12]
LpType          equ [ebp + 16]
LpName          equ [ebp + 20]
LParam          equ [ebp + 24]

stdENDP __ResourceCallEnumNameRoutine
        push    ebp
        mov     ebp, esp
        push    esi         ; save esi across the call
        push    edi         ; save edi across the call
        push    ebx         ; save ebx on the stack across the call
        mov     esi,esp     ; save the stack pointer in esi across the call
        push    LParam
	push    LpName
	push    LpType
	push    ModuleHandle
        call    EnumRoutine
        mov     esp,esi     ; restore the stack pointer in case callee forgot to clean up
        pop     ebx         ; restore ebx
        pop     edi         ; restore edi
        pop     esi         ; restore esi
        pop     ebp
        stdRET  __ResourceCallEnumNameRoutine
	
cPublicProc __ResourceCallEnumTypeRoutine , 4

EnumRoutine     equ [ebp + 8]
ModuleHandle    equ [ebp + 12]
LpType          equ [ebp + 16]
LParam          equ [ebp + 20]

stdENDP __ResourceCallEnumTypeRoutine
        push    ebp
        mov     ebp, esp
        push    esi         ; save esi across the call
        push    edi         ; save edi across the call
        push    ebx         ; save ebx on the stack across the call
        mov     esi,esp     ; save the stack pointer in esi across the call
        push    LParam
	push    LpType
	push    ModuleHandle
        call    EnumRoutine
        mov     esp,esi     ; restore the stack pointer in case callee forgot to clean up
        pop     ebx         ; restore ebx
        pop     edi         ; restore edi
        pop     esi         ; restore esi
        pop     ebp
        stdRET  __ResourceCallEnumTypeRoutine

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\i386\critsect.asm ===
title   "Critical Section Support"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     critsect.asm
;
;  Abstract:
;
;     This module implements functions to support user mode interlocked operations.
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;  Revision History:
;
;
;   WARNING!!!!!!!!!! Some of this code is duplicated in
;   ntos\dll\i386\critsect.asm
;
;   Some day we should put it in a .inc file that both include.
;
;--

.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_DATA   SEGMENT DWORD PUBLIC 'DATA'
    public _BasepLockPrefixTable
_BasepLockPrefixTable    label dword
        dd offset FLAT:Lock1
        dd offset FLAT:Lock2
        dd offset FLAT:Lock3
        dd offset FLAT:Lock4
        dd offset FLAT:Lock5
        dd 0
_DATA   ENDS


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


Addend      equ     [esp + 4]
FlagMask    equ     0c0000000H
FlagShift   equ     24
FlagSelect  equ     30

        page , 132
        subttl  "InterlockedIncrement"

;++
;
; LONG
; InterlockedIncrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of one to the addend variable.
;
;    No checking is done for overflow.
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       incremented by one.
;
; Return Value:
;
;   (eax) - the incremented value.
;
;--

cPublicProc _InterlockedIncrement,1
cPublicFpo 1,0
        mov     ecx,Addend              ; get pointer to addend variable
        mov     eax,1                   ; set increment value
Lock1:
   lock xadd    [ecx],eax               ; interlocked increment
        inc     eax                     ; adjust return value
        stdRET _InterlockedIncrement    ;

stdENDP _InterlockedIncrement

        page , 132
        subttl  "InterlockedDecrment"
;++
;
; LONG
; InterlockedDecrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of -1 to the addend variable.
;
;    No checking is done for overflow
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       decremented by one.
;
; Return Value:
;
;   (eax) - The decremented value.
;
;--

cPublicProc _InterlockedDecrement,1
cPublicFpo 1,0

        mov     ecx,Addend              ; get pointer to addend variable
        mov     eax,-1                  ; set decrement value
Lock2:
   lock xadd    [ecx],eax               ; interlocked decrement
        dec     eax                     ; adjust return value
        stdRET _InterlockedDecrement    ;

stdENDP _InterlockedDecrement

        page , 132
        subttl  "Interlocked Exchange"
;++
;
; LONG
; InterlockedExchange(
;    IN OUT LPLONG Target,
;    IN LONG Value
;    )
;
; Routine Description:
;
;    This function atomically exchanges the Target and Value, returning
;    the prior contents of Target
;
; Arguments:
;
;    Target - Address of LONG to exchange
;    Value  - New value of LONG
;
; Return Value:
;
;    (eax) - The prior value of target.
;--

cPublicProc _InterlockedExchange, 2
cPublicFpo 2,0

        mov     ecx, [esp+4]                ; (ecx) = Target
        mov     edx, [esp+8]                ; (edx) = Value
        mov     eax, [ecx]                  ; get comperand value
Ixchg:
Lock5:
   lock cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
        stdRET  _InterlockedExchange

stdENDP _InterlockedExchange

        page , 132
        subttl  "Interlocked Compare Exchange"
;++
;
;   PVOID
;   InterlockedCompareExchange (
;       IN OUT PVOID *Destination,
;       IN PVOID Exchange,
;       IN PVOID Comperand
;       )
;
;   Routine Description:
;
;    This function performs an interlocked compare of the destination
;    value with the comperand value. If the destination value is equal
;    to the comperand value, then the exchange value is stored in the
;    destination. Otherwise, no operation is performed.
;
; Arguments:
;
;    Destination - Supplies a pointer to destination value.
;
;    Exchange - Supplies the exchange value.
;
;    Comperand - Supplies the comperand value.
;
; Return Value:
;
;    (eax) - The initial destination value.
;
;--

cPublicProc _InterlockedCompareExchange, 3
cPublicFpo 3,0

        mov     ecx, [esp + 4]          ; get destination address
        mov     edx, [esp + 8]          ; get exchange value
        mov     eax, [esp + 12]         ; get comperand value
Lock3:
   lock cmpxchg [ecx], edx              ; compare and exchange

        stdRET  _InterlockedCompareExchange

stdENDP _InterlockedCompareExchange

        page , 132
        subttl  "Interlocked Exchange Add"
;++
;
;   LONG
;   InterlockedExchangeAdd (
;       IN OUT PLONG Addend,
;       IN LONG Increment
;       )
;
;   Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsinged long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;    Increment - Supplies the increment value to be added to the
;       addend variable.
;
; Return Value:
;
;    (eax) - The initial value of the addend.
;
;--

cPublicProc _InterlockedExchangeAdd, 2
cPublicFpo 2,0

        mov     ecx, [esp + 4]          ; get addend address
        mov     eax, [esp + 8]          ; get increment value
Lock4:
   lock xadd    [ecx], eax              ; exchange add

        stdRET  _InterlockedExchangeAdd

stdENDP _InterlockedExchangeAdd

        page , 132
        subttl  "Multiply and Divide"
;++
;
; LONG
; MulDiv(
;    IN LONG nNumber,
;    IN LONG nNumerator,
;    IN LONG nDenominator
;    )
;
; Routine Description:
;
;    This function multiples two 32-bit numbers forming a 64-bit product.
;    The 64-bit product is rounded and then divided by a 32-bit divisor
;    yielding a 32-bit result.
;
; Arguments:
;
;    nNumber - Supllies the multiplier.
;
;    nNumerator - Supplies the multiplicand.
;
;    nDenominator - Supplies the divisor.
;
; Return Value:
;
;    If the divisor is zero or an overflow occurs, then a value of -1 is
;    returned as the function value. Otherwise, the rounded quotient is
;    returned as the funtion value.
;
;--

nNumber      equ [esp + 4]
nNumerator   equ [esp + 8]
nDenominator equ DWORD PTR [esp + 12]

cPublicProc _MulDiv, 3
cPublicFpo 3,0
        mov     eax, nNumber            ; get multiplier absolute value
        or      eax, eax                ;
        js      short MD32_First        ; if s, multiplier is negative

;
; The multiplier is positive.
;

        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      MD32_Second             ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      MD32_Third              ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error        ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error        ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error:
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is negative.
;

MD32_First:                             ;
        neg     eax                     ; negate multiplier
        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      short MD32_First10      ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First20      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative and the multiplicand is negative.
;

MD32_First10:                           ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First30      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error10:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv


;
; The multiplier is negative, the multiplicand is positive, and the
; divisor is negative.
;

MD32_First20:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative, the multiplier is negative, and the divisor
; is negative.
;

MD32_First30:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive and the multiplicand is negative.
;

MD32_Second:                            ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_Second10     ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; check for overflow
        jg      short MD32_error20      ; if g, overlfow has occured

        stdRET  _MulDiv

MD32_error20:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is negative, and the divisor
; is negative.
;

MD32_Second10:                          ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is positive, the divisor
; is negative.
;

MD32_Third:                             ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error20      ; if g, overflow has occured

        stdRET  _MulDiv

stdENDP _MulDiv

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\fusionwarnings.h ===
// C4100: 'identifier' : unreferenced formal parameter
#pragma warning(disable: 4100)

// C4201: nonstandard extension used: nameless struct/union
#pragma warning(disable: 4201)

// C4706: assignment within conditional expression
#pragma warning(disable: 4706)

// C4211: nonstandard extension used: redefined extern to static
#pragma warning(disable: 4211)

// C4702: unreachable code
// This one is useful/interesting but having it enabled breaks do { foo(); bar(); goto Exit; } while (0) macros.
#pragma warning(disable: 4702)

// C4505: unreferenced local function has been removed
#pragma warning(disable: 4505)

// C4663: C++ language change: to explicitly specialize class template 'foo' use the following syntax:
#pragma warning(disable: 4663)

// C4127: conditional expression is constant
// makes ASSERT() macros useless.
#pragma warning(disable: 4127)

// C4189: local variable is initialized but not referenced
// makes macros that define things like __pteb = NtCurrentTeb() generate warnings/errors
#pragma warning(disable: 4189)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\wow6432\makefile.inc ===
!INCLUDE ..\makefile.inc

$(O)\services.tab: services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\usrstubs.$(ASM_SUFFIX): $(O)\services.tab $(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) $(TARGET_BRACES) -s $(TARGET_DIRECTORY) $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\ia64\thunk.s ===
//++
//
// Module Name:
//
//    thunk.s
//
// Abstract:
//
//   This module implements all Win32 thunks. This includes the
///   first level thread starter...
//
// Author:
//
//   12-Oct-1995
//
// Revision History:
//
//--

#include "ksia64.h"
        .file    "thunk.s"


//++
//
// VOID
// BaseThreadStartThunk(
//    IN PTHREAD_START_ROUTINE StartRoutine,
//    IN PVOID ThreadParameter
//    )
//
// Routine Description:
//
//    This function calls to the portable thread starter after moving
//    its arguments from registers to the argument registers.
//
// Arguments:
//
//    s1 - StartRoutine
//    s2 - ThreadParameter
//
// Return Value:
//
//    Never Returns
//
//--

        PublicFunction(BaseThreadStart)

        LEAF_ENTRY(BaseThreadStartThunk)
        LEAF_SETUP(0,0,2,0)

        mov        out0=s1
        mov        out1=s2
        br.many    BaseThreadStart
        ;;

        //
        // never come back here
        //

        LEAF_EXIT(BaseThreadStartThunk)


//++
//
// VOID
// BaseProcessStartThunk(
//    IN PTHREAD_START_ROUTINE StartRoutine,
//    IN PVOID ThreadParameter
//    )
//
// Routine Description:
//
//    This function calls to the portable thread starter after moving
//    its arguments from registers to the argument registers.
//
// Arguments:
//
//    s1 - StartRoutine
//    s2 - ThreadParameter
//
// Return Value:
//
//    Never Returns
//
//--

        PublicFunction(BaseProcessStart)

        LEAF_ENTRY(BaseProcessStartThunk)

        alloc   t22 = ar.pfs, 0, 0, 1, 0

        mov     out0=s1
        br      BaseProcessStart                          // jump process wrapper.
        ;;

        LEAF_EXIT(BaseProcessStartThunk)



//++
//
// VOID
// SwitchToFiber(
//    PFIBER NewFiber
//    )
//
// Routine Description:
//
//    This function saves the state of the current fiber and switches
//    to the new fiber.
//
// Arguments:
//
//    NewFiber (a0) - Supplies the address of the new fiber.
//
// Return Value:
//
//    None
//
//--

        LEAF_ENTRY(SwitchToFiber)


        // local register aliases

        rOldFb = t21
        rOldCx = t20
        rNewFb = t19
        rNewCx = t18
        rA0    = t17

        dest1  = t10
        dest2  = t11
        dest4  = t12
        dest5  = t13

        //
        // set up pointers to old and new fiber and context records
        //

        add          rNewFb = zero, a0
        add          rNewCx = FbFiberContext, a0
        add          t0 = TeFiberData, teb
        ;;

        LDPTR        (t1, t0)
        mov          rA0 = a0
        ;;

        add          rOldFb = 0, t1
        add          rOldCx = FbFiberContext, t1
        ;;

        //
        // step 1
        // save current state in to old fiber's fiber and context rec
        //

        //
        // save fiber exception list and stack info
        //
        add          dest1 = TeExceptionList, teb      // TEB
        add          dest2 = FbExceptionList, rOldFb    // Old fiber
        ;;

        LDPTRINC     (t0, dest1, TeStackLimit - TeExceptionList)
        ;;
        STPTRINC     (dest2, t0, FbStackLimit - FbExceptionList)
        ;;

        LDPTR        (t0, dest1)
        ;;
        STPTR        (dest2, t0)

        //
        // also save RSE stack info
        //
        add          dest4 = TeBStoreLimit, teb
        add          dest5 = FbBStoreLimit, rOldFb
        ;;

        LDPTR        (t1, dest4)
        ;;
        STPTR        (dest5, t1)
        ;;

        //
        // spill low non-volatile fp registers 0-3, 5-19
        //
        add          dest1 = CxFltS0, rOldCx
        add          dest2 = CxFltS1, rOldCx
        ;;

        mov          t2 = ar.fpsr                         //FPSR
        mov          t3 = ar28                            //FSR
        mov          t4 = ar29                            //FIR
        mov          t5 = ar30                            //FDR

        stf.spill    [dest1] = fs0, CxFltS2 - CxFltS0
        stf.spill    [dest2] = fs1, CxFltS3 - CxFltS1
        ;;

        stf.spill    [dest1] = fs2, CxFltS5 - CxFltS2
        stf.spill    [dest2] = fs3, CxFltS6 - CxFltS3
        ;;

        stf.spill    [dest1] = fs5, CxFltS7 - CxFltS5
        stf.spill    [dest2] = fs6, CxFltS8 - CxFltS6
        ;;

        stf.spill    [dest1] = fs7, CxFltS9 - CxFltS7
        stf.spill    [dest2] = fs8, CxFltS10 - CxFltS8
        ;;

        stf.spill    [dest1] = fs9, CxFltS11 - CxFltS9
        stf.spill    [dest2] = fs10, CxFltS12 - CxFltS10
        ;;

        stf.spill    [dest1] = fs11, CxFltS13 - CxFltS11
        stf.spill    [dest2] = fs12, CxFltS14 - CxFltS12
        ;;

        stf.spill    [dest1] = fs13, CxFltS15 - CxFltS13
        stf.spill    [dest2] = fs14, CxFltS16 - CxFltS14
        ;;

        stf.spill    [dest1] = fs15, CxFltS17 - CxFltS15
        stf.spill    [dest2] = fs16, CxFltS18 - CxFltS16
        ;;

        stf.spill    [dest1] = fs17, CxFltS19 - CxFltS17
        stf.spill    [dest2] = fs18
        ;;

        stf.spill    [dest1] = fs19

        //
        // fp status registers
        //

        add          dest1 = CxStFPSR,  rOldCx
        add          dest2 = CxStFSR,  rOldCx
        ;;

        st8          [dest1] = t2
        ;;

        st8          [dest2] = t3, CxStFDR - CxStFSR
        add          dest1 = CxStFIR, rOldCx
        ;;

        st8          [dest1] = t4
        ;;

        st8          [dest2] = t5

        //
        // save old unat before starting the spills
        //

        mov          t6 = ar.unat
        add          dest4 = CxApUNAT, rOldCx
        ;;

        st8          [dest4] = t6
        mov          ar.unat = zero
        ;;

        // ordering ? should not start spilling before unat is saved

        // save sp and preserved int registers

        add          dest4 = CxIntS0, rOldCx
        add          dest5 = CxIntSp, rOldCx
        ;;

        .mem.offset 0,0
        st8.spill    [dest5] = sp, CxIntS1 - CxIntSp
        .mem.offset 8,0
        st8.spill    [dest4] = s0, CxIntS2 - CxIntS0
        ;;

        .mem.offset 0,0
        st8.spill    [dest5] = s1, CxIntS3 - CxIntS1
        .mem.offset 8,0
        st8.spill    [dest4] = s2
        ;;

        st8.spill    [dest5] = s3

        // save predicates

        add          dest4 = CxPreds, rOldCx
        add          dest5 = CxBrRp, rOldCx

        mov          t7 = pr
        ;;
        st8          [dest4] = t7, CxBrS0 - CxPreds

        // save preserved branch registers

        mov          t8 = brp
        ;;

        st8          [dest5] = t8, CxBrS1 - CxBrRp
        mov          t9 = bs0

        ;;
        st8          [dest4] = t9, CxBrS2 - CxBrS0

        mov          t1 = bs1
        ;;
        st8          [dest5] = t1, CxBrS3 - CxBrS1

        mov          t2 = bs2
        ;;
        st8          [dest4] = t2, CxBrS4 - CxBrS2

        mov          t3 = bs3
        ;;
        st8          [dest5] = t3

        mov          t4 = bs4
        ;;
        st8          [dest4] = t4

        // save other applicatin registers
        //

        mov          t6 = ar.lc
        add          dest4 = CxApLC, rOldCx
        add          dest5 = CxApEC, rOldCx
        ;;

        st8          [dest4] = t6, CxRsPFS - CxApLC
        mov          t7 = ar.ec
        ;;

        st8          [dest5] = t7, CxRsRSC - CxApEC

        //
        // save RSE stuff
        //
        mov        t8 = ar.pfs
        ;;

        st8        [dest4] = t8
        mov        t9 = ar.rsc
        ;;

        st8        [dest5] = t9
        dep        t9 = 0, t9, RSC_MODE, 2                  // put in lazy mode
        ;;
        mov        ar.rsc = t9

        //
        // since we do not use locals, we don't need cover..
        // cover
        // ;;

        ;;
        flushrs
        dep        t9 = 0, t9, RSC_LOADRS, RSC_LOADRS_LEN  // invalidate all
        ;;
        mov        ar.rsc = t9
        ;;
        loadrs

        add        dest1 = CxRsRNAT, rOldCx
        add        dest2 = CxRsBSP, rOldCx
        ;;

        mov        t1 = ar.bsp
        ;;
        st8        [dest2] = t1

        mov        t2 = ar.rnat
        ;;
        st8        [dest1] = t2


        // save all spilled NaT bits in in IntNats

        add        dest1 = CxIntNats, rOldCx
        mov        t3 = ar.unat
        ;;
        st8        [dest1] = t3


        //
        // step 2
        // setup the state for new fiber from new context/fiber record
        //

        // restore exception list and stack info fist
        //
        add          dest1 = TeExceptionList, teb
        add          dest2 = FbExceptionList, rNewFb
        ;;

        LDPTRINC     (t0, dest2, FbStackBase - FbExceptionList)
        ;;
        STPTRINC     (dest1, t0, TeStackBase - TeExceptionList)
        ;;

        LDPTRINC     (t0, dest2, FbStackLimit - FbStackBase)
        ;;
        STPTRINC     (dest1, t0, TeStackLimit - TeStackBase)
        ;;

        LDPTR        (t0, dest2)
        ;;
        STPTR        (dest1, t0)

        add          dest4 = TeDeallocationStack, teb
        add          dest5 = FbDeallocationStack, rNewFb
        ;;

        LDPTR        (t1, dest5)
        ;;
        STPTR        (dest4, t1)

        // also restore RSE stack info
        //
        add          dest4 = TeBStoreLimit, teb
        add          dest5 = FbBStoreLimit, rNewFb
        ;;

        LDPTRINC     (t2, dest5, FbDeallocationBStore - FbBStoreLimit)
        ;;
        STPTRINC     (dest4, t2, TeDeallocationBStore - TeBStoreLimit)
        ;;

        LDPTR        (t3, dest5)
        ;;
        STPTR        (dest4, t3)

        // set the fiber pointer in teb to point to new fiber
        //
        add          dest1 = TeFiberData, teb
        ;;
        STPTR        (dest1, rA0)


        // set up new RSE first

        add          dest1 = CxRsRSC, rNewCx
        add          dest2 = CxRsBSP, rNewCx
        ;;

        ld8          t2 = [dest2], CxRsRNAT - CxRsBSP
        ;;
        mov          ar.bspstore = t2
        invala

        ld8          t3 = [dest2]
        ;;
        mov          ar.rnat = t3

        ld8          t4 = [dest1]
        ;;
        mov          ar.rsc = t4

        add          dest4 = CxRsPFS, rNewCx
        ;;
        ld8          t5 = [dest4]
        ;;
        mov          ar.pfs = t5


        // restore floating point registers

        add          dest1 = CxFltS0, rNewCx
        add          dest2 = CxFltS1, rNewCx
        ;;

        ldf.fill     fs0 = [dest1], CxFltS2 - CxFltS0
        ldf.fill     fs1 = [dest2] , CxFltS3 - CxFltS1
        ;;

        ldf.fill     fs2 = [dest1], CxFltS5 - CxFltS2
        ldf.fill     fs3 = [dest2], CxFltS6 - CxFltS3
        ;;

        ldf.fill     fs5 = [dest1], CxFltS7 - CxFltS5
        ldf.fill     fs6 = [dest2], CxFltS8 - CxFltS6
        ;;

        ldf.fill     fs7 = [dest1], CxFltS9 - CxFltS7
        ldf.fill     fs8 = [dest2], CxFltS10 - CxFltS8
        ;;

        ldf.fill     fs9 = [dest1], CxFltS11 - CxFltS9
        ldf.fill     fs10 = [dest2], CxFltS12 - CxFltS10
        ;;

        ldf.fill     fs11 = [dest1], CxFltS13 - CxFltS11
        ldf.fill     fs12 = [dest2], CxFltS14 - CxFltS12
        ;;

        ldf.fill     fs13 = [dest1], CxFltS15 - CxFltS13
        ldf.fill     fs14 = [dest2], CxFltS16 - CxFltS14
        ;;

        ldf.fill     fs15 = [dest1], CxFltS17 - CxFltS15
        ldf.fill     fs16 = [dest2], CxFltS18 - CxFltS16
        ;;

        ldf.fill     fs17 = [dest1], CxFltS19 - CxFltS17
        ldf.fill     fs18 = [dest2]
        ;;

        ldf.fill     fs19 = [dest1]

        add          dest1 = CxStFPSR, rNewCx
        add          dest2 = CxStFSR, rNewCx
        ;;

        ld8          t2 = [dest1]                         //FPSR
        ;;
        mov          ar.fpsr = t2

        ld8          t3 = [dest2], CxStFDR - CxStFSR
        add          dest1 = CxStFIR, rNewCx
        ;;
        mov          ar28 = t3                            //FSR

        ld8          t4 = [dest1]
        ;;
        mov          ar29 = t4                            //FIR

        ld8          t5 = [dest2]
        ;;
        mov          ar30 = t5                            //FDR

        //
        // restore ar.unat first, so that fills will restore the
        // nat bits correctly
        //
        add          dest4 = CxIntNats, rNewCx
        ;;
        ld8          t6 = [dest4]
        ;;
        mov          ar.unat = t6

        // now start filling the preserved integer registers
        //
        add          dest4 = CxIntS0, rNewCx
        add          dest5 = CxIntSp, rNewCx
        ;;


        ld8.fill     sp = [dest5], CxIntS1 - CxIntSp

        // save preserved integer registers

        ld8.fill     s0 = [dest4], CxIntS2 - CxIntS0
        ;;
        ld8.fill     s1 = [dest5], CxIntS3 - CxIntS1

        ld8.fill     s2 = [dest4]
        ;;
        ld8.fill     s3 = [dest5]

        // restore predicates and branch registers

        add          dest4 = CxPreds, rNewCx
        add          dest5 = CxBrRp, rNewCx
        ;;

        ld8          t7 = [dest4], CxBrS0 - CxPreds
        ;;
        mov          pr = t7

        ld8          t8 = [dest5], CxBrS1 - CxBrRp
        ;;
        mov          brp = t8

        ld8          t9 = [dest4], CxBrS2 - CxBrS0
        ;;
        mov          bs0 = t9

        ld8          t1 = [dest5], CxBrS3 - CxBrS1
        ;;
        mov          bs1 = t1

        ld8          t2 = [dest4], CxBrS4 - CxBrS2
        ;;
        mov          bs2 = t2

        ld8          t3 = [dest5]
        ;;
        mov          bs3 = t3

        ld8          t4 = [dest4]
        ;;
        mov          bs4 = t4


        // restore other applicatin registers
        //
        add          dest4 = CxApLC, rNewCx
        add          dest5 = CxApEC, rNewCx
        ;;

        ld8          t6 = [dest4]
        ;;
        mov          ar.lc = t6

        ld8          t7 = [dest5]
        ;;
        mov          ar.ec = t7


        // finally restore the unat register
        //
        add          dest4 = CxApUNAT, rNewCx
        ;;
        ld8          t5 = [dest4]
        ;;
        mov          ar.unat = t5

        br.ret.sptk brp

        //
        // this will execute BaseFiberStart if we are switching to
        // the new fiber for the first time. otherwise, it will
        // return back to new fiber.
        //

        LEAF_EXIT(SwitchToFiber)


#if 0
        LEAF_ENTRY(GenericIACall)
        LEAF_SETUP(1,95,0,0)

//
// Load iA state for iVE. Since working with flat 32 in NT,
// much of the state is a constant (per Freds document)
//
        mov rBase   = teb               // Get TEB pointer

// load up selector register constants, we dont care about GS
        mov rES = _DataSelector
        mov rSS = _DataSelector
        mov rDS = _DataSelector
        mov rGS = _DataSelector
        mov rCS = _CodeSelector
        mov rFS = _FsSelector
        mov rLDT    = _LdtSelector
//
//  Setup pointer to iA32 Resources relative to TEB
//
        mov r23 = rIA32Rsrc
        add rIA32Ptr = rBase, r23

        ld8    rGDTD   = [rIA32Ptr], 8      //  load LDT Descriptor registers
        ld8    rLDTD   = [rIA32Ptr], 8      //  GDT Descriptor is 8 bytes after
        ld8    rFSD    = [rIA32Ptr]         //  FSDescriptor is 8 bytes after
//
//  Eflag should not be touched by stub routines...
//

//
// Since CSD and SSD are in AR registers and since they are saved
// on context switches, dont need to reload them...
//
//
//  DSD and ESD are the same as SSD, and we dont care about GSD
//
        mov rESD    =   rSSD
        mov rDSD    =   rSSD
        mov rGSD    =   rSSD

//
// push the return address on the memory stack
//
//
// As we never return, just push NULL...
//
//
// Stack always points to a valid value, so decrement before putting on
// return address
//
        adds    sp = -4, sp
        st4     [sp] = r0

        ARGPTR (in0)
        sxt4   r23 = in0
        mov b7 = r23

        br.ia.sptk   b7

//
// Return addresses and stuff would go here, but we never return
//

        LEAF_EXIT(GenericIACall)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\fusion_all.inc ===
FUSION_LIB_DEST = $(FUSION_ALL_LIB_DEST)
C_DEFINES = $(C_DEFINES) -DFUSION_ALL -DFUSION_ENABLE_UNWRAPPED_NEW=1 -DFUSION_ENABLE_UNWRAPPED_DELETE=1
FUSION_INC_PATH=$(FUSION_ALL_INC_PATH)
FUSION_BUILD_TYPE_PREFIX=
FUSION_DIRECTDB_INC_DEST=$(FUSION_ALL_DIRECTDB_INC_DEST)
USE_RTTI=1
FUSION_LIB_PATH = $(FUSION_ALL_LIB_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\fusion_urt.inc ===
FUSION_LIB_DEST = $(FUSION_URT_LIB_DEST)
C_DEFINES = $(C_DEFINES) -DFUSION_URT=1 -DFUSION_ENABLE_UNWRAPPED_NEW=1 -DFUSION_ENABLE_UNWRAPPED_DELETE=1
FUSION_BUILD_TYPE_PREFIX=urt
FUSION_INC_PATH=$(FUSION_ALL_INC_PATH);$(FUSION_URT_INC_PATH)
FUSION_DIRECTDB_INC_DEST=$(FUSION_PATH)\directdb\inc\urt
USE_RTTI=1
FUSION_LIB_PATH = $(FUSION_URT_LIB_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\fusion.inc ===
MSC_WARNING_LEVEL = /W4 /WX
!undef USE_MSVCRT
!undef USE_NTDLL
!undef USE_LIBCMT
!undef NO_NTDLL
#NO_NTDLL=1
#USE_MSVCRT=1
#USE_NTDLL=1
#USE_LIBCMT=1
USE_NOLIBS=1
USE_NATIVE_EH=1

!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) -DFUSION_RETAIL_LOGGING
!else
C_DEFINES = $(C_DEFINES) -DFUSION_RETAIL_LOGGING -DDEBUG
!endif

C_DEFINES = $(C_DEFINES) -DFUSION_REDEFINE_ASSERT=1

# Put this in independent of USE_MSVCRT, etc. to make it
# easier to switch among them.
C_DEFINES = $(C_DEFINES) -D_MT=1

# Downlevel is all of NT4, Win2k, Win9x.
C_DEFINES = $(C_DEFINES) -DSXSP_DOWNLEVEL=0

# locally defined symbol imported
# LINKER_FLAGS=$(LINKER_FLAGS) -ignore:4049,4217

#
# Set private include paths
#

INCLUDES        = \
    $(WINDOWS_INC_PATH);\
    $(BASE_INC_PATH);\
    $(SDK_INC_PATH);\
    $(NET_INC_PATH);\
    $(INCLUDES)

FUSION_PATH = $(BASEDIR)\base\win32\fusion

PROJECT_COMPILER_WARNINGS = -FI$(FUSION_PATH)\fusionwarnings.h

FUSION_ALL_INC_PATH = $(FUSION_PATH)\inc
FUSION_URT_INC_PATH = $(FUSION_PATH)\inc\urt
FUSION_WIN_INC_PATH = $(FUSION_PATH)\inc\win
FUSION_WIN2000_INC_PATH = $(FUSION_PATH)\inc\win2000

!if "$(FUSION_BUILD_TYPE)" == ""
!error FUSION_BUILD_TYPE not defined
!endif

FUSION_WIN_LIB_DEST = $(FUSION_PATH)\winobj\$(_OBJ_DIR)
FUSION_WIN_LIB_PATH = $(FUSION_WIN_LIB_DEST)\*
FUSION_WIN2000_LIB_DEST = $(FUSION_PATH)\w2kobj\$(_OBJ_DIR)
FUSION_WIN2000_LIB_PATH = $(FUSION_WIN2000_LIB_DEST)\*
FUSION_URT_LIB_DEST = $(FUSION_PATH)\urtobj\$(_OBJ_DIR)
FUSION_URT_LIB_PATH = $(FUSION_URT_LIB_DEST)\*
FUSION_ALL_LIB_DEST = $(FUSION_PATH)\$(_OBJ_DIR)
FUSION_ALL_LIB_PATH = $(FUSION_ALL_LIB_DEST)\*

!include fusion_$(FUSION_BUILD_TYPE).inc

!if 0
!ifndef FUSION_MBCS
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif
!else
C_DEFINES = $(C_DEFINES) -D_MBCS
!endif

!ifdef USE_PERFTAGS
C_DEFINES = $(C_DEFINES) -DPERFTAGS
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\ia64\context.c ===
/*++

Module Name:

    context.c

Abstract:

    This module contains the context management routines for
    Win32

Author:


Revision History:

--*/

#include "basedll.h"

#include "kxia64.h"

VOID
BaseInitializeContext(
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL,
    IN BASE_CONTEXT_TYPE ContextType
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    Parameter - Supplies the thread's parameter.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

    NewThread - Supplies a flag that specifies that this is a new
        thread, or a new process.

Return Value:

    Raises STATUS_BAD_INITIAL_STACK if the value of InitialSp is not properly
           aligned.

    Raises STATUS_BAD_INITIAL_PC if the value of InitialPc is not properly
           aligned.

--*/

{
    ULONG ArgumentsCount;
    //
    // Initialize the Context 
    //
    RtlZeroMemory((PVOID)Context, sizeof(CONTEXT));

    Context->StFPSR = USER_FPSR_INITIAL;
    Context->StIPSR = USER_PSR_INITIAL;
    Context->RsBSP = Context->IntSp = (ULONG_PTR)InitialSp;
    Context->IntSp -= STACK_SCRATCH_AREA; // scratch area as per convention
    Context->IntS1 = (ULONG_PTR)InitialPc;
    Context->IntS2 = (ULONG_PTR)Parameter;

    //
    // Enable RSE engine
    //

    Context->RsRSC = (RSC_MODE_EA<<RSC_MODE)
                   | (RSC_BE_LITTLE<<RSC_BE)
                   | (0x3<<RSC_PL);

    if ( ContextType == BaseContextTypeThread ) {
        Context->IntS0 = Context->StIIP = (ULONG_PTR)BaseThreadStartThunk;
        }
    else if ( ContextType == BaseContextTypeFiber ) {
        Context->IntS0 = Context->StIIP = (ULONG_PTR)BaseFiberStart;
        //
        // set up the return pointer here..
        // when SwitchToFiber restores context and calls return, 
        // the contorl goes to this routine
        //
        Context->BrRp = *((ULONGLONG *)((PUCHAR)BaseFiberStart));

        //
        // set up sof = 96 in pfs. This will be used to set up CFM for above
        // routine
        //  
        Context->RsPFS = 0x60;

        }
    else {
        Context->IntS0 = Context->StIIP = (ULONG_PTR)(LONG_PTR)BaseProcessStartThunk;
        }

    Context->RsPFS |= MASK_IA64(PFS_PPL, 3i64);
    Context->ContextFlags = CONTEXT_CONTROL| CONTEXT_INTEGER;

    Context->Eflag = 0x3000i64;
}

VOID
BaseFiberStart(
    VOID
    )

/*++

Routine Description:

    This function is called to start a Win32 fiber. Its purpose
    is to call BaseThreadStart, getting the necessary arguments
    from the fiber context record.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PFIBER Fiber;

    Fiber = GetCurrentFiber();
    BaseThreadStart( (LPTHREAD_START_ROUTINE)Fiber->FiberContext.IntS1,
                     (LPVOID)Fiber->FiberContext.IntS2 );
}


VOID
BaseProcessStartupIA64(
   IN PTHREAD_START_ROUTINE StartRoutine,
   IN PVOID ThreadParameter
   )

/*++

Routine Description:

   This function calls to the portable thread starter after moving
   its arguments from registers to the argument registers.

Arguments:

   StartRoutine - User Target start program counter
   ThreadParameter 

Return Value:

   Never Returns

--*/
{
   (StartRoutine)(ThreadParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\fusion_win2000.inc ===
FUSION_LIB_DEST = $(FUSION_WIN2000_LIB_DEST)
C_DEFINES = $(C_DEFINES) -DFUSION_WIN2000=1
C_DEFINES = $(C_DEFINES) -DFUSION_NO_WRAPPERS=1 -DFUSION_ENABLE_UNWRAPPED_NEW=1 -DFUSION_ENABLE_UNWRAPPED_DELETE=1
FUSION_BUILD_TYPE_PREFIX=w2k
FUSION_INC_PATH=$(FUSION_ALL_INC_PATH);$(FUSION_WIN2000_INC_PATH)
!undef USE_RTTI
FUSION_LIB_PATH = $(FUSION_WIN2000_LIB_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\fusion_win.inc ===
FUSION_LIB_DEST = $(FUSION_WIN_LIB_DEST)
C_DEFINES = $(C_DEFINES) -DFUSION_WIN=1
C_DEFINES = $(C_DEFINES) -DFUSION_NO_WRAPPERS=1 -DFUSION_ENABLE_UNWRAPPED_NEW=1 -DFUSION_ENABLE_UNWRAPPED_DELETE=1
FUSION_BUILD_TYPE_PREFIX=win
FUSION_INC_PATH=$(FUSION_ALL_INC_PATH);$(FUSION_WIN_INC_PATH)
!undef USE_RTTI
FUSION_LIB_PATH = $(FUSION_WIN_LIB_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\appprotocol.cxx ===
/**
 * Asynchronous pluggable protocol for Applications
 *
 * Copyright (C) Microsoft Corporation, 2000
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "app.h"

#include <stdio.h> // for _snprintf

char * stristr(char *pszMain, char *pszSub)
{
    char * pszCur = pszMain;
    char ch = (char) tolower(*pszSub);
    int cb = strlen(pszSub) - 1; // -1 to ignore leading character

    for (;;) {
        while (tolower(*pszCur) != ch && *pszCur)
            pszCur++;

        if (!*pszCur)
            return NULL;

        if (_strnicmp(pszCur + 1, pszSub + 1, cb) == 0)
            return pszCur;

        pszCur++;
    }
}

/**
 * Return last Win32 error as an HRESULT.
 */
HRESULT
GetLastWin32Error()
{
    // Win 95 can return 0, even when there's an error.
    DWORD dw = GetLastError();
    return dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
}

HRESULT
RunCommand(WCHAR *cmdLine)
{
    HRESULT hr = S_OK;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    si.cb = sizeof(si);
    
    if(!CreateProcess(NULL, cmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    if(WaitForSingleObject(pi.hProcess, 180000L) == WAIT_TIMEOUT)
    {
        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
        goto exit;
    }

exit:
    if(pi.hProcess) CloseHandle(pi.hProcess);
    if(pi.hThread) CloseHandle(pi.hThread);

    return hr;
}

#define ToHex(val) val <= 9 ? val + '0': val - 10 + 'A'
DWORD ConvertToHex(WCHAR* strForm, BYTE* byteForm, DWORD dwSize)
{
    DWORD i = 0;
    DWORD j = 0;
    for(i = 0; i < dwSize; i++) {
        strForm[j++] =  ToHex((0xf & byteForm[i]));
        strForm[j++] =  ToHex((0xf & (byteForm[i] >> 4)));
    }
    strForm[j] = L'\0';
    return j;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// {B8BF3C7E-4DB6-4fdb-9CD3-13D2CE728CA8}, by guidgen VS7
CLSID   CLSID_AppProtocol = { 0xb8bf3c7e,
                              0x4db6, 0x4fdb,
                              { 0x9c, 0xd3, 0x13, 0xd2, 0xce, 0x72, 0x8c, 0xa8 } };


BOOL                        g_fStarted              = FALSE;
AppProtocolFactory          g_AppProtocolFactory;
IInternetSecurityManager*   g_pSecurityMgr          = NULL;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class AppProtocol ctor

AppProtocol::AppProtocol(IUnknown *  pUnkOuter)
    : m_refs                   (1),
      m_pProtocolSink          (NULL),
//      m_cookie                 (NULL),   
      m_fullUri             (NULL),
      m_uriPath                (NULL),
      m_queryString            (NULL),
      m_appOrigin              (NULL),
      m_appRoot                (NULL),
      m_appRootTranslated      (NULL),
      m_extraHeaders           (NULL),
      m_inputDataSize          (0),
      m_inputData              (NULL),
      m_pInputRead             (NULL),
      m_pOutputRead            (NULL),
      m_pOutputWrite           (NULL),
      m_started                (FALSE),
      m_aborted                (FALSE),
      m_done                   (FALSE),
      m_responseMimeType       (NULL),
      m_cbOutput               (0),
      m_extraHeadersUpr        (NULL),
      m_strResponseHeader      (NULL),
      m_postedMimeType         (NULL),
      m_verb                   (NULL),
      m_localStoreFilePath     (NULL),
      m_appType                (APPTYPE_IE),
      m_status                 (STATUS_CLEAR)
{
    m_pUnkOuter = (pUnkOuter ? pUnkOuter : (IUnknown *)(IPrivateUnknown *)this);
    InitializeCriticalSection(&m_csOutputWriter);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
AppProtocol::Cleanup()
{
    ClearInterface(&m_pOutputRead);
    ClearInterface(&m_pOutputWrite);
    ClearInterface(&m_pProtocolSink);
    ClearInterface(&m_pInputRead);

    m_appType = APPTYPE_IE;
    m_status = STATUS_CLEAR;
    m_done = TRUE;
    m_aborted = FALSE; //???

    if (m_bindinfo.cbSize)
    {
        ReleaseBindInfo(&m_bindinfo);
        ZeroMemory(&m_bindinfo, sizeof(m_bindinfo));
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
AppProtocol::FreeStrings()
{
    MemClearFn((void **)&m_fullUri);
    m_uriPath = NULL;
    m_queryString = NULL;

    MemClearFn((void **)&m_appOrigin) ;
    m_appRoot = NULL;

    MemClearFn((void **)&m_appRootTranslated);

    if(m_extraHeaders)
    {
        CoTaskMemFree(m_extraHeaders);
        m_extraHeaders = NULL;
    }

//    MemClearFn((void **)&m_cookie);
    MemClearFn((void **)&m_extraHeadersUpr);
    MemClearFn((void **)&m_strResponseHeader);
    MemClearFn((void **)&m_verb);
    MemClearFn((void **)&m_postedMimeType);
    MemClearFn((void **)&m_responseMimeType);
    MemClearFn((void **)&m_localStoreFilePath);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

AppProtocol::~AppProtocol()
{
    FreeStrings();

    Cleanup();

    DeleteCriticalSection(&m_csOutputWriter);

    if (g_pSecurityMgr != NULL)
    {
        g_pSecurityMgr->Release();
        g_pSecurityMgr = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Private QI

ULONG
AppProtocol::PrivateAddRef()
{
    return ++m_refs;
}

ULONG
AppProtocol::PrivateRelease()
{
    if (--m_refs > 0)
        return m_refs;

    delete this;
    return 0;
}

HRESULT
AppProtocol::PrivateQueryInterface(
        REFIID      iid, 
        void**      ppv)
{
    *ppv = NULL;

    if (iid == IID_IInternetProtocol ||
        iid == IID_IInternetProtocolRoot)
    {
        *ppv = (IInternetProtocol *)this;
    }
    else if (iid == IID_IUnknown)
    {
        *ppv = (IUnknown *)(IPrivateUnknown *)this;
    }
    else if (iid == IID_IWinInetHttpInfo)
    {
        *ppv = (IWinInetHttpInfo *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Public (delegated) QI

ULONG
AppProtocol::AddRef()
{
    m_pUnkOuter->AddRef();
    return PrivateAddRef();
}

ULONG
AppProtocol::Release()
{
    m_pUnkOuter->Release();
    return PrivateRelease();
}

HRESULT
AppProtocol::QueryInterface(
        REFIID    iid, 
        void **   ppv)
{
    return m_pUnkOuter->QueryInterface(iid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::Start(
        LPCWSTR                   url,
        IInternetProtocolSink *   pProtocolSink,
        IInternetBindInfo *       pBindInfo,
        DWORD                     grfSTI,
        DWORD                           )
{
    HRESULT             hr                = S_OK;
    WCHAR *             Strings[]         = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    DWORD               cStrings          = sizeof(Strings) / sizeof(Strings[0]);
//    DWORD               cookieSize        = 0;
    IServiceProvider *  pServiceProvider  = NULL;
    IHttpNegotiate *    pHttpNegotiate    = NULL;

    FreeStrings();

    ReplaceInterface(&m_pProtocolSink, pProtocolSink);

    // ?????
    if (grfSTI & PI_PARSE_URL)
        goto exit;

    if (pProtocolSink == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // get bindinfo
    m_bindinfo.cbSize = sizeof(BINDINFO);
    if (pBindInfo != NULL)
    {
        if (FAILED(hr = pBindInfo->GetBindInfo(&m_bindf, &m_bindinfo)))
           goto exit;
    }

    if (m_bindinfo.dwCodePage == 0)
        m_bindinfo.dwCodePage = CP_ACP;

    // extract root, uri path and query string from url
    if (FAILED(hr = ParseUrl(url)))
       goto exit;

    // get to headers in MSHtml
    if (FAILED(hr = pBindInfo->QueryInterface(IID_IServiceProvider, (void **) &pServiceProvider)))
       goto exit;
    if(pServiceProvider != NULL)
    {
        if (FAILED(hr = pServiceProvider->QueryService(IID_IHttpNegotiate, IID_IHttpNegotiate, (void **) &pHttpNegotiate)))
           goto exit;
        if(pHttpNegotiate != NULL)
        {
            hr = pHttpNegotiate->BeginningTransaction(url, NULL, 0, &m_extraHeaders);
            pHttpNegotiate->Release();
            pHttpNegotiate = NULL;
            if (FAILED(hr))
                goto exit;
        }
        pServiceProvider->Release();
        pServiceProvider = NULL;
    }

    // determine verb
    switch (m_bindinfo.dwBindVerb)
    {
    case BINDVERB_GET:  
        m_verb = DuplicateString(L"GET");
        break;

    case BINDVERB_POST: 
        m_verb = DuplicateString(L"POST");
        break;

    case BINDVERB_PUT: 
        m_verb = DuplicateString(L"PUT");
        break;

    default:
        if (m_bindinfo.szCustomVerb != NULL && m_bindinfo.dwBindVerb == BINDVERB_CUSTOM)
        {
            m_verb = DuplicateString(m_bindinfo.szCustomVerb); 
        }
        else
        {
            m_verb = DuplicateString(L"GET");
        }
        break;
    }

    // get mime type of posted data from binding
    hr = pBindInfo->GetBindString(BINDSTRING_POST_DATA_MIME, Strings, cStrings, &cStrings);
    if(hr == S_OK && cStrings)
    {
        DWORD i;

        m_postedMimeType = DuplicateString(Strings[0]);
        if (m_postedMimeType == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        for(i = 0; i < cStrings; i++)
            CoTaskMemFree(Strings[i]);
    }

    // don't fail if we failed to get bind string, 
    hr = S_OK;

    // retrieve cookie
/*    cookieSize = 0;
    if(g_pInternetGetCookieW(m_fullUri, NULL, NULL, &cookieSize) && cookieSize)
    {
        m_cookie = (WCHAR *)MemAlloc(cookieSize + sizeof(WCHAR));
        if (m_cookie == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        g_pInternetGetCookieW(m_fullUri, NULL, m_cookie, &cookieSize);
    }
*/

    // Input data
    if (m_bindinfo.stgmedData.tymed == TYMED_HGLOBAL)
    {
        m_inputDataSize = m_bindinfo.cbstgmedData;
        m_inputData = (BYTE *)m_bindinfo.stgmedData.hGlobal;
    }
    else if (m_bindinfo.stgmedData.tymed == TYMED_ISTREAM)
    {
        STATSTG statstg;

        ReplaceInterface(&m_pInputRead, m_bindinfo.stgmedData.pstm);

        if(m_pInputRead) 
        {
            hr = m_pInputRead->Stat(&statstg, STATFLAG_NONAME);
            if(hr == S_OK)
                m_inputDataSize = statstg.cbSize.LowPart;
            else
                m_inputDataSize = (DWORD)-1;
        }

    }

    if (FAILED(hr = CreateStreamOnHGlobal(NULL, TRUE, &m_pOutputWrite)))
        goto exit;

    if (FAILED(hr = m_pOutputWrite->Clone(&m_pOutputRead)))
        goto exit;

    PROTOCOLDATA        protData;
    protData.dwState = 1;
    protData.grfFlags = PI_FORCE_ASYNC;
    protData.pData = NULL;
    protData.cbData = 0;

    pProtocolSink->Switch(&protData);
//***    hr = E_PENDING;

exit:
    if (pHttpNegotiate)
    {
        pHttpNegotiate->Release();
        pHttpNegotiate = NULL;
    }

    if (pServiceProvider)
    {
        pServiceProvider->Release();
        pServiceProvider = NULL;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::Continue(
        PROTOCOLDATA *  pProtData)
{
    HRESULT   hr                       = S_OK;
//    CHAR      appDomainPath[MAX_PATH]  = "";
    WCHAR     appRootTranslated[MAX_PATH];

    if(pProtData->dwState != 1)
    {
        hr = E_FAIL;
        goto exit;
    }

    // step 1: "install" the specified file
    appRootTranslated[0] = L'\0';

    hr = SetupAndInstall(m_fullUri, appRootTranslated);
    if (FAILED(hr))
        goto exit;

    if (m_localStoreFilePath == NULL)
    {
        hr = E_FAIL;
        goto exit;
    }

    m_appRootTranslated = DuplicateString(appRootTranslated);
    if (m_appRootTranslated == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // step 2: check error status
    if ((m_status & STATUS_OFFLINE_MODE) && (m_status & STATUS_NOT_IN_CACHE))
    {
        char buffer[100 + MAX_PATH];
        
        SendHeaders(HTTP_RESPONSEOK);

        _snprintf(buffer, 100+MAX_PATH, "Error: In offline mode and file not found in application store.\r\nLocal path expected- %ws", m_localStoreFilePath);
        
        WriteBytes((BYTE*) buffer, lstrlenA(buffer)+1);
        hr = Finish();

        goto exit;
    }

    // step 3: process different file types
    if (m_appType == APPTYPE_BYMANIFEST)
    {
        char buffer[512 + MAX_PATH];

        SendHeaders(HTTP_RESPONSEOK);

        // ???? ignore if excess buffer len
        // do this before as m_localStoreFilePath might be overwritten
        _snprintf(buffer, 512 + MAX_PATH, "Application installed and executed with manifest file - %ws\r\nSource - %ws", m_localStoreFilePath, m_fullUri);

        if (FAILED(hr = ProcessAppManifest()))
            goto exit;

        WriteBytes((BYTE *) buffer, lstrlenA(buffer)+1); //???? includes last '\0'
        hr = Finish();
    }
    else if (m_appType == APPTYPE_ASM)
    {
        char buffer[512 + MAX_PATH];
        
        SendHeaders(HTTP_RESPONSEOK);

        // ???? ignore if excess buffer len
        _snprintf(buffer, 512+MAX_PATH, "Assembly Executed - %ws\r\nSource - %ws", m_localStoreFilePath, m_fullUri);

        WriteBytes((BYTE*) buffer, lstrlenA(buffer)+1); //???? includes last '\0'
        hr = Finish();
    }
    else if (m_appType == APPTYPE_IE)
    {
        DWORD dwLength;
        BYTE buffer[512];
        char header[60];
        HANDLE hFile;
        int len;
        WCHAR* p;

        // set mime type
        // assume lower cases
        len = lstrlen(m_localStoreFilePath);
        p = m_localStoreFilePath + len - 5;
        if ((p[1] == L'.' && p[2] == L'h' && p[3] == L't' && p[4] == L'm')
             || (p[0] == L'.' && p[1] == L'h' && p[2] == L't' && p[3] == L'm' && p[4] == L'l')) //L".htm" ".html"
            sprintf(header, "%s\r\nContent-Type: text/html\r\n", HTTP_RESPONSEOK);
        else if (p[1] == L'.' && p[2] == L'g' && p[3] == L'i' && p[4] == L'f') //L".gif"
            sprintf(header, "%s\r\nContent-Type: image/gif\r\n", HTTP_RESPONSEOK);
        else if ((p[1] == L'.' && p[2] == L'j' && p[3] == L'p' && p[4] == L'g')
                 || (p[0] == L'.' && p[1] == L'j' && p[2] == L'p' && p[3] == L'e' && p[4] == L'g')) //L".jpg" ".jpeg"
            sprintf(header, "%s\r\nContent-Type: image/jpeg\r\n", HTTP_RESPONSEOK);
        else
            sprintf(header, "%s", HTTP_RESPONSEOK);

        SendHeaders(header);

        hFile = CreateFile(m_localStoreFilePath, GENERIC_READ, 0, NULL, 
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if(hFile == INVALID_HANDLE_VALUE)
        {
            hr = GetLastWin32Error();
            goto exit;
        }

        ZeroMemory(buffer, sizeof(buffer));

        while ( ReadFile (hFile, buffer, 512, &dwLength, NULL) && dwLength )
        {
                WriteBytes(buffer, dwLength);
        }
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        hr = Finish();
    }

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
AppProtocol::Finish()
{
    HRESULT hr = S_OK;

    if (m_done == FALSE)
    {
        m_done = TRUE;

        m_pProtocolSink->ReportData(BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE, 0, m_cbOutput);

        if (m_aborted == FALSE)
            m_pProtocolSink->ReportResult(S_OK, 0, NULL);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::Abort(
        HRESULT hrReason,
        DWORD           )
{
    HRESULT hr = S_OK;

    m_aborted = TRUE;
    if (m_pProtocolSink != NULL)
    {
        hr = m_pProtocolSink->ReportResult(hrReason, 0, 0);
    if (FAILED(hr))
        goto exit;
    }

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::Terminate(
        DWORD )
{
    Cleanup();
    return S_OK;
}

HRESULT
AppProtocol::Suspend()
{
    return E_NOTIMPL;
}

HRESULT
AppProtocol::Resume()
{
    return E_NOTIMPL;
}

HRESULT
AppProtocol::Read(
        void *pv, 
        ULONG cb, 
        ULONG *pcbRead)
{
    HRESULT hr;

    hr = m_pOutputRead->Read(pv, cb, pcbRead);

    // We must only return S_FALSE when we have hit the absolute end of the stream
    // If we think there is more data coming down the wire, then we return E_PENDING
    // here. Even if we return S_OK and no data, UrlMON will still think we've hit
    // the end of the stream.

//    if (S_OK == hr && 0 == *pcbRead)
//****
    if (S_OK == hr && (0 == *pcbRead || cb > *pcbRead))
    {
        hr = m_done ? S_FALSE : E_PENDING;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::Seek(
        LARGE_INTEGER offset, 
        DWORD origin, 
        ULARGE_INTEGER *pPos)
{
    return m_pOutputRead->Seek(offset, origin, pPos);
}


HRESULT
AppProtocol::LockRequest(
        DWORD )
{
    return S_OK;
}

HRESULT
AppProtocol::UnlockRequest()
{
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::SendHeaders(
        LPSTR headers)
{
    HRESULT    hr       = S_OK;
//    DWORD      flags    = 0;
    DWORD      dwLength = 0;
    LPSTR      mime     = NULL;
    LPSTR      tail     = NULL;
    int        iHLen    = 0;

    if(headers == NULL)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    if (m_strResponseHeader != NULL)
        MemFree(m_strResponseHeader);
    iHLen = strlen(headers);
    m_strResponseHeader = (WCHAR *) MemAllocClear(iHLen*sizeof(WCHAR) + 512);
    if (m_strResponseHeader != NULL)
    {
        wcscpy(m_strResponseHeader, L"Server: Microsoft.Net-App/1.0\r\nDate:"); // Microsoft-IIS/App 1.0
        WCHAR szTemp[100];
        szTemp[0] = NULL;
        GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, NULL, NULL, szTemp, 100); 
        wcscat(m_strResponseHeader, szTemp);
        wcscat(m_strResponseHeader, L" ");

        GetTimeFormat(LOCALE_USER_DEFAULT, 0, NULL, NULL, szTemp, 100); 
        wcscat(m_strResponseHeader, szTemp);
        wcscat(m_strResponseHeader, L"\r\n");
        int iLen = wcslen(m_strResponseHeader);
        MultiByteToWideChar(CP_ACP, 0, headers, -1, &m_strResponseHeader[iLen], iHLen + 256 - iLen - 1);
    }

    mime = stristr(headers, "Content-Type:");
    if(mime)
    {
        mime += 13;
        while(*mime && isspace(*mime))
            mime++;
        tail = mime;

        while(*tail && *tail != '\r')
            tail++;

        dwLength = tail - mime;
        if(dwLength)
        {
            if (m_responseMimeType)
                MemFree(m_responseMimeType);

            m_responseMimeType = (WCHAR *) MemAlloc((dwLength + 1) * sizeof(WCHAR));
            if (m_responseMimeType == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            MultiByteToWideChar(CP_ACP, 0, mime, dwLength, m_responseMimeType, dwLength);
            m_responseMimeType[dwLength] = L'\0';
        }
    }

    if (m_responseMimeType && *m_responseMimeType)
        m_pProtocolSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, m_responseMimeType);
    else
        m_pProtocolSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, L"text/plain"); //proper default not L"text/html");

//****    SaveCookie(headers);

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*HRESULT 
AppProtocol::SaveCookie(
	LPSTR header)
{
    HRESULT hr = S_OK;
    LPSTR cookie, tail;
    WCHAR *cookieBody = NULL;
    int bodyLength;

    for(cookie = stristr(header, "Set-Cookie:");
        cookie != NULL;
        cookie = (*tail ? stristr(tail, "Set-Cookie:") : NULL)) //???? added () around ? :
    {
        cookie += 11;
        while(*cookie && isspace(*cookie))
            cookie++;
        tail = cookie;
        while(*tail && *tail != '\r')
            tail++;
        bodyLength = tail - cookie;

        if(bodyLength)
        {
            cookieBody = (WCHAR *)MemAlloc(sizeof(WCHAR) *(bodyLength + 1));
            if (cookieBody == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
                
            MultiByteToWideChar(CP_ACP, 0, cookie, bodyLength, cookieBody, bodyLength);
            cookieBody[bodyLength] = '\0';

            if(!g_pInternetSetCookieW(m_cookiePath, NULL, cookieBody))
            {
                hr = GetLastWin32Error();
                goto exit;
            }
        }
    }
exit:
    if (cookieBody)
        MemFree(cookieBody);

    return hr;
}*/

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::WriteBytes(
        BYTE *  buffer, 
        DWORD   dwLength)
{
    HRESULT hr = S_OK;
    DWORD flags = 0;

    EnterCriticalSection(&m_csOutputWriter);

    if (!m_pOutputWrite)
    {
        hr = E_UNEXPECTED;
    }

    if (FAILED(hr = m_pOutputWrite->Write(buffer, dwLength, &dwLength)))
        goto exit;

    m_cbOutput += dwLength;

    if (!m_started)
    {
        m_started = TRUE;
        flags |= BSCF_FIRSTDATANOTIFICATION;
    }
    else //****

    if (m_done)
    {
        flags |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    }

    else //****
        flags |= BSCF_INTERMEDIATEDATANOTIFICATION;

    if (FAILED(hr = m_pProtocolSink->ReportData(flags, dwLength, m_cbOutput)))
        goto exit;

exit:
    LeaveCriticalSection(&m_csOutputWriter);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*int
AppProtocol::GetKnownRequestHeader (
        LPCWSTR  szHeader,
        LPWSTR   buf,
        int      size)
{
    if (szHeader == NULL || szHeader[0] == NULL || wcslen(szHeader) > 256)
        return 0;

    LPCWSTR  szReturn        = NULL;
    LPCWSTR  szStart         = NULL;
    int      iLen            = 0;
    HRESULT  hr              = S_OK;
//    int      iter            = 0;
    WCHAR    szHeadUpr[260]  = L"";

    wcscpy(szHeadUpr, szHeader);
    _wcsupr(szHeadUpr);

    if (wcscmp(szHeadUpr, SZ_HTTP_COOKIE) == 0)
    {
        szReturn = m_cookie;
        iLen = (m_cookie ? wcslen(m_cookie) : 0);
        goto exit;
    }

    if (m_extraHeadersUpr == NULL && m_extraHeaders != NULL)
    {
        m_extraHeadersUpr = DuplicateString(m_extraHeaders);
        if (m_extraHeadersUpr == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        _wcsupr(m_extraHeadersUpr);
    }

    if (m_extraHeadersUpr == NULL)
        goto exit;
        
    szStart = wcsstr(m_extraHeadersUpr, szHeadUpr);
    if (szStart == NULL)
        goto exit;

    iLen = wcslen(szHeadUpr);
    szReturn = &(m_extraHeaders[iLen+1]);

    while(iswspace(*szReturn))
        szReturn++;

    for (iLen = 0; szReturn[iLen] != L'\r' && szReturn[iLen] != NULL; iLen++);

exit:
    if (szReturn == NULL || iLen == 0)
        return 0;

    if (iLen >= size)
        return -(iLen + 1);

    buf[iLen] = NULL;
    memcpy(buf, szReturn, iLen*sizeof(WCHAR));
    return iLen;
}
*/
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// TODO: make it real, netclasses, manifest and all that 
//
// ???? construct filename, create directory
HRESULT
AppProtocol::SetupAndInstall(
        LPTSTR  url, /* *not* ok to modify */
        LPTSTR  path /* out */)
{
    HRESULT hr = S_OK;
//    WCHAR *installFromPath = NULL;  // full path - app://www.microsoft.com/app5/app.manifest
    WCHAR *origin = NULL;                  // src - www.microsoft.com/app5
    WCHAR *p, *q;
    int i, j;

    // skip app:// part
    origin = DuplicateString(url + lstrlen(PROTOCOL_SCHEME));
    if (origin == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

//    installFromPath = (WCHAR *) MemAlloc((lstrlen(origin/*url*/) + lstrlen(HTTP_SCHEME)/*MAX_PATH*/) * sizeof(WCHAR));
//    if (installFromPath == NULL)
//    {
//        hr = E_OUTOFMEMORY;
//        goto exit;
//    }
//???????????????????????
    WCHAR installFromPath[MAX_URL_LENGTH];

    lstrcpy(installFromPath, HTTP_SCHEME);
    lstrcat(installFromPath, origin);
    // assume file name is given (it's now passed in) - not myweb.cab
    // better? - check if last contain ".", if so assume has filename, else attach app.manifest as filename
//    lstrcat(installFromPath, L"/MyWeb.cab");  //????????? if no filename it will get index.html, if exists!

    // remove the filename, if specified
    // ?????????? this assume all filename has a '.'
    p = wcsrchr(origin, L'/');
    q = wcsrchr(origin, L'.');
    if (p && q && /*((p - origin) > 6) &&*/ (p < q))
        *p = L'\0';
    // else - no filename -> do something to installFromPath? or no '/' after "app://" in url
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // install to

    if(GetEnvironmentVariable(L"ProgramFiles", path, MAX_PATH-lstrlen(STORE_PATH)-1) == 0)  //????????
    {
        // 
        hr = CO_E_PATHTOOLONG;//E_FAIL;
        goto exit;
    }

    // ????????
    lstrcat(path, STORE_PATH);
    if(!CreateDirectory(path, NULL) && GetLastError() != ERROR_ALREADY_EXISTS)
    {
        hr = GetLastWin32Error();
        goto exit;
    }
    lstrcat(path, L"\\");

    i = lstrlen(path);
    j = 0;
    while(origin[j])
    {
        if(origin[j] == L'/')
        {
            path[i] = L'\0';
            if(!CreateDirectory(path, NULL) && GetLastError() != ERROR_ALREADY_EXISTS)
            {
                hr = GetLastWin32Error();
                goto exit;
            }

            path[i] = L'\\';
        }
        else
            path[i] = origin[j];
        i++;
        j++;
    }
    path[i] = L'\0';
    if(!CreateDirectory(path, NULL) && GetLastError() != ERROR_ALREADY_EXISTS)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    // grab the files
    hr = InstallInternetFile(installFromPath, path);

exit:
//    if(installFromPath) MemFree(installFromPath);
    if(origin) MemFree(origin);

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// given the url like MyWeb://www.site.com/app/something/else?querystring=aa
// sets
//      m_uriPath        to /app/something/else
//      m_queryString    to querystring=aa
//      m_appRoot        to /app or
//                         /app/something or 
//                         /app/something/else,
//          depending on which was successfully mapped to 
//      m_appRootTranslated to, for instance, c:\program files\site app\
//                       not set till SetupAndInstall() is called
//      m_appOrigin      to www.site.com
//      m_fullUri     to myweb://www.site.com/app/something/else
//
// if application was not installed, attempts to install it
//
// ???? setup strings, find out if needs install
HRESULT
AppProtocol::ParseUrl(LPCTSTR url)
{
    HRESULT hr = S_OK;
    WCHAR slash = L'/';
    WCHAR *p, *base;
    int cchFullUri = 0;
//    WCHAR appRootTranslated[MAX_PATH];

    // copy the cookie path into member variable
    m_fullUri = DuplicateString(url);
    if (m_fullUri == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // locate, store and strip query string, if any
    p = wcschr(m_fullUri, L'?');
    if(p != NULL && p[1] != L'\0')
    {
        m_queryString = p + 1;
        *p = L'\0';
    }

    // ????? to be moved
    // assume lower cases
    // need to find from end, skip ?querystring, use m_fullUri instead?
    cchFullUri = lstrlen(m_fullUri);
    m_appType = APPTYPE_IE;

    // ????? BUGBUG assume >= than 9 characters
    if (cchFullUri >= 9)
    {
        p = m_fullUri + cchFullUri - 5;
    /*    if (p[0] != L'.' && p[1] != L'.')
            // error? no extension
            m_appType = APPTYPE_IE;
        else*/
        if (p[1] == L'.' && (p[2] == L'e' && p[3] == L'x' && p[4] == L'e')
                            || (p[2] == L'd' && p[3] == L'l' && p[4] == L'l')) //L".exe" ".dll"
            m_appType = APPTYPE_ASM;    // (check asm or not?)
        else if (p[0] == L'.' && p[1] == L'a' && p[2] == L's' && p[3] == L'p' && p[4] == L'x') //L".aspx"
            m_appType = APPTYPE_MYWEB;
        else if (wcsncmp(p = m_fullUri + cchFullUri - 9, L".manifest", 9) == 0)
            m_appType = APPTYPE_BYMANIFEST;
        //else //default or others
        //    m_appType = APPTYPE_IE;
    }

    // skip through protocol:// 
    p = wcschr(m_fullUri, L':');
    if(p == NULL || p[1] != slash || p[2] != slash || p[3] == L'\0')  
    {
        hr = E_INVALIDARG;
    }

    // copy full origin path
    m_appOrigin = DuplicateString(p + 3);
    if (m_appOrigin == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // point to the end of site
    base = wcschr(m_appOrigin, slash);
    if(base == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

//    appRootTranslated[0] = L'\0';

    // tear off one segment at a time from the end
    while((p = wcsrchr(m_appOrigin, slash)) != base)
    {
        *p = L'\0';
//        if(GetAppBaseDir(m_appOrigin, appRootTranslated) == S_OK)
//        {
//            break;
//        }
    }

// moved to Continue()
//    if(appRootTranslated[0] == L'\0')
//    {
//        WCHAR * appPath = DuplicateString(m_fullUri);
//        WCHAR * p;

        // application not installed, install it

/*        if (appPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
*/
        // ???? why? - this will remove the last - supposingly the filename?
//        p = wcsrchr(appPath, L'/');

//        if(p) *p = NULL;

//        hr = SetupAndInstall(m_fullUri/*appPath*/, appRootTranslated);
//        if (FAILED(hr))
//            goto exit;

//        if(appPath) MemFree(appPath);
//    }
   
/*    m_appRootTranslated = DuplicateString(appRootTranslated);
    if (m_appRootTranslated == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
*/
    m_appRoot = wcschr(m_appOrigin, slash);

    // ???? this should be ok
/*    if(m_appRoot == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
*/
    if (m_appRoot)
        m_uriPath = wcsstr(m_fullUri, m_appRoot);
    else
        // ???? this should be ok
        m_uriPath = NULL;

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Note: appRoot is assumed to have enough space (MAX_PATH)
//
/*HRESULT AppProtocol::GetAppBaseDir(LPCTSTR base, LPTSTR appRoot)
{
    HKEY             hKey     = NULL;
    HRESULT          hr       = E_FAIL;
    HKEY             hSubKey  = NULL;

    appRoot[0] = L'\0';

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, MYWEBS_KEY, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    if(RegOpenKeyEx(hKey, base, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
    {
        DWORD dwType, cb = MAX_PATH * sizeof(WCHAR);
        if(RegQueryValueEx(hSubKey, MYWEBS_APPROOT, NULL, &dwType, (LPBYTE)appRoot, &cb) == ERROR_SUCCESS)
        {
            dwType = GetFileAttributes(appRoot);
            if (dwType == (DWORD) -1 || (dwType & FILE_ATTRIBUTE_DIRECTORY) == 0)
                appRoot[0] = NULL;
            else
                hr = S_OK;
        }
        RegCloseKey(hSubKey);
    }

    RegCloseKey(hKey);
    

//exit:
    return hr;
}*/

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// ???????called only from managed code?

WCHAR *
AppProtocol::MapString(
   int key)
{
/*    switch(key)
    {
    case IEWR_URIPATH:
        return m_uriPath;
    case IEWR_QUERYSTRING:
        return m_queryString;
    case IEWR_VERB:
        return m_verb;
    case IEWR_APPPATH:
        return m_appRoot;
    case IEWR_APPPATHTRANSLATED:
        return m_appRootTranslated;
    default:*/
if (key)
key=key; // ???????
        return NULL;
//    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// ????????called only from managed code?
int
AppProtocol::GetStringLength(
        int key)
{
    WCHAR *targetString = MapString(key);
    return targetString ? lstrlen(targetString) + 1 : 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int 
AppProtocol::GetString(
        int        key, 
        WCHAR *    buf, 
        int        size)
{
    WCHAR *targetString = MapString(key);
    int len; 

    if(targetString == NULL)
        return 0;

    len = lstrlen(targetString);

    if(len >= size)
        return 0;

    lstrcpy(buf, targetString);

    return len + 1;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*int
AppProtocol::MapPath(
        WCHAR *  virtualPath, 
        WCHAR *  physicalPath, 
        int      length)
{
    int requiredLength = lstrlen(m_appRootTranslated) + 2;
    int rootLength = lstrlen(m_appRoot);
    int i = 0;

    if(virtualPath && virtualPath[0] != '\0')
    {
        requiredLength += lstrlen(virtualPath) - rootLength;
    }

    if(requiredLength <= 0)
        return 0;

    if(requiredLength > length)
        return - requiredLength;

    while(m_appRootTranslated[i])
    {
        physicalPath[i] = m_appRootTranslated[i];
        i++;
    }

    if(virtualPath && virtualPath[0] != L'\0')
    {

        if(_memicmp(virtualPath, m_appRoot, sizeof(WCHAR) * rootLength))
            return 0;

        virtualPath += rootLength;
        if(*virtualPath && *virtualPath != L'/')
            physicalPath[i++] = L'\\';

        while(*virtualPath)
        {
            if(*virtualPath == L'/')
                physicalPath[i++] = L'\\';
            else
                physicalPath[i++] = *virtualPath;
            virtualPath++;
        }
    }

    physicalPath[i] = L'\0';

    return 1;
}
*/
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// ????? download file from url into path
HRESULT
AppProtocol::InstallInternetFile(
        LPTSTR   url, 
        LPTSTR   path)
{
    HRESULT          hr                  = S_OK;
    HINTERNET        hInternet           = NULL;
    HINTERNET        hTransfer           = NULL;
    HANDLE           hFile               = INVALID_HANDLE_VALUE;
    WCHAR *          file                = NULL;
    DWORD            bytesRead           = 0;
    DWORD            bytesWritten        = 0;
    WCHAR            szFile[MAX_PATH];
    BYTE             buffer[4096];

    BOOL             bNeedDownload       = TRUE;

//    CabHandlerInfo   cabInfo;

    // ????????? TO BE MOVED!
    // check offline mode
    DWORD            dwState             = 0;
    DWORD            dwSize              = sizeof(DWORD);
    BOOL             bRemoveEmptyFile    = FALSE;

    if(g_pInternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            m_status |= STATUS_OFFLINE_MODE;
    }

    ////////////////////////////////////////////////////////////
    // Step 1: Construct the file name 
    // ???? this assumes there is a filename after the last '/'
    ZeroMemory(szFile, sizeof(szFile));
    wcsncpy(szFile, path, MAX_PATH - 2);
    lstrcat(szFile, L"\\");
    file = wcsrchr(url, L'/');

    if (file != NULL && wcslen(szFile) + wcslen(file) < MAX_PATH)
        wcscat(szFile, file + 1);
    else
    {
        hr = CO_E_PATHTOOLONG;//E_FAIL;
        goto exit;
    }

    MemClearFn((void **)&m_localStoreFilePath);
    m_localStoreFilePath = DuplicateString(szFile);

    ////////////////////////////////////////////////////////////
    // Step 2: Create the file
    // need write access, will open (and replace/overwrite) exiting file
    // ??? FILE_SHARE_READ? but we might write to if outdated...
    hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, 
                       OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    // ????????? TO BE MOVED!
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        FILETIME ftLastModified;
#define FTTICKSPERDAY (60*60*24*(LONGLONG) 10000000) // == 864000000000

        if (GetFileTime(hFile, NULL, NULL, &ftLastModified))
        {
                SYSTEMTIME sSysT;
                FILETIME ft;

                GetSystemTime(&sSysT);
                SystemTimeToFileTime(&sSysT, &ft);

                ULARGE_INTEGER ulInt = * (ULARGE_INTEGER *) &ft;
                ulInt.QuadPart -= FTTICKSPERDAY * 3;  // 3 days
                ft = * (FILETIME *) &ulInt;

                if (CompareFileTime(&ftLastModified, &ft) != -1)
                    // reuse file, just execute it
                    bNeedDownload = FALSE;
        }
    }
    else
         m_status |= STATUS_NOT_IN_CACHE;

    if ((m_status & STATUS_OFFLINE_MODE) && (m_status & STATUS_NOT_IN_CACHE))
    {
        // hr = E_FAIL; // ???? file not found - if uncomment this line, generic IE error page will display instead
        bRemoveEmptyFile = TRUE;
        goto exit;
    }

    if (bNeedDownload && !(m_status & STATUS_OFFLINE_MODE))
    {
    ////////////////////////////////////////////////////////////
    // Step 3: Copy the files over the internet
    hInternet = g_pInternetOpen(L"App", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if(hInternet == NULL)
    {
        hr = GetLastWin32Error();
        bRemoveEmptyFile = TRUE;
        goto exit;
    }

    // use own caching instead
    hTransfer = g_pInternetOpenUrl(hInternet, url, NULL, 0, INTERNET_FLAG_NO_CACHE_WRITE, 0);
    if(hTransfer == NULL)
    {
        hr = GetLastWin32Error();
        bRemoveEmptyFile = TRUE;
        goto exit;
    }

    // need to check if there's any error, eg. not found (404)...
    
    // synchronous download
    while(g_pInternetReadFile(hTransfer, buffer, sizeof(buffer), &bytesRead) && bytesRead != 0)
    {
        if ( !WriteFile(hFile, buffer, bytesRead, &bytesWritten, NULL) || 
             bytesWritten != bytesRead                                  )
        {
            hr = GetLastWin32Error();
            bRemoveEmptyFile = TRUE;
            goto exit;
        }
    }
    }

    // ensure file/internet handles are closed before further processing is done
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);    
    if (hInternet != NULL)
        g_pInternetCloseHandle(hInternet);
    if (hTransfer != NULL)
        g_pInternetCloseHandle(hTransfer);
        
    hInternet   = NULL;
    hTransfer   = NULL;
    hFile       = INVALID_HANDLE_VALUE;

    // ????????? TO BE MOVED!
    // process - run all .exe
    // lower case? end of string?
    if (/*m_appType == APPTYPE_ASM)*/wcsstr(file, L".exe"))
    {
//#define MAX_SIZE_SECURITY_ID 0x200
        DWORD                   dwZone;
        DWORD                   dwSize = MAX_SIZE_SECURITY_ID;
        BYTE                    byUniqueID[MAX_SIZE_SECURITY_ID];
        WCHAR                   wzUniqueID[MAX_SIZE_SECURITY_ID * 2 + 1];
        WCHAR                   wzCmdLine[1025];

    //IInternetSecurityManager::ProcessUrlAction

        // lazy init
        if (g_pSecurityMgr == NULL)
        {
            hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                                IID_IInternetSecurityManager, (void**)&g_pSecurityMgr);

            //???? should this fails at all if security info/manager is undef?
            if (FAILED(hr))
            {
                g_pSecurityMgr = NULL;
                goto exit;
            }
        }
        
        // m_fullUri -> this should translate correctly in IInternetProtocolInfo->ParseUrl()
        if (SUCCEEDED(hr = g_pSecurityMgr->MapUrlToZone(m_fullUri, &dwZone, 0)))
        {
             // check space in site? -  assume checked in GetSecurityId
             // should site be just www.abc.com or www.abc.com/app2/appmain.exe?
             if (FAILED(hr)
             || FAILED(hr = g_pSecurityMgr->GetSecurityId(m_fullUri, byUniqueID, &dwSize, 0)))
                 goto exit;

             ConvertToHex(wzUniqueID, byUniqueID, dwSize);
        }
        else
        {
             goto exit;
        }

        // ???? any space in url? start a new proc for that asm, not hang the browser
        /* C:\\Documents and Settings\\felixybc.NTDEV\\Desktop\\work\\conexec\\Debug\\*/
        if (_snwprintf(wzCmdLine, 1025,
					L"conexec.exe \"%s\" +3 %d %s %s", szFile, dwZone, wzUniqueID, url) < 0)
        {
			hr = CO_E_PATHTOOLONG;
			goto exit;
		}
        RunCommand(wzCmdLine);
    }

exit:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hInternet != NULL)
        g_pInternetCloseHandle(hInternet);
    if (hTransfer != NULL)
        g_pInternetCloseHandle(hTransfer);
    hInternet   = NULL;
    hTransfer   = NULL;
    hFile       = INVALID_HANDLE_VALUE;

    // remove the file so that it will not be mistaken next time this runs
    // ignore if error deleting the file so the hr is not overwritten
    if (bRemoveEmptyFile)
        DeleteFile(szFile);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::QueryOption(DWORD, LPVOID, DWORD*)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::QueryInfo(
        DWORD        dwOption, 
        LPVOID       pBuffer, 
        LPDWORD      pcbBuf, 
        LPDWORD      , 
        LPDWORD      )
{
    if (pcbBuf == NULL)
        return E_FAIL;
    
    HRESULT hr              = S_OK;
    LPCWSTR szHeader        = NULL;
    DWORD   dwOpt           = (dwOption & HTTP_QUERY_HEADER_MASK);
    DWORD   dwLen           = (m_strResponseHeader ? wcslen(m_strResponseHeader) : 0);

    switch(dwOpt)
    {
    case HTTP_QUERY_RAW_HEADERS_CRLF: 
    case HTTP_QUERY_RAW_HEADERS:
        if (m_strResponseHeader == NULL)
            return E_FAIL;

        if (*pcbBuf < dwLen + 1)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if (dwOpt == HTTP_QUERY_RAW_HEADERS_CRLF)
            {
                wcscpy((WCHAR *) pBuffer, m_strResponseHeader);
            }
            else
            {
                DWORD iPos = 0;
                for(DWORD iter=0; iter<dwLen; iter++)
                    if (m_strResponseHeader[iter] == L'\r' && m_strResponseHeader[iter+1] == L'\n')
                    {
                        ((WCHAR *)pBuffer)[iPos++] = L'0';
                        iter++;
                    }
                    else
                    {
                        ((WCHAR *)pBuffer)[iPos++] = m_strResponseHeader[iter];
                    }

                *pcbBuf = iPos;
            }
        }
        goto exit;
    case HTTP_QUERY_ACCEPT:
        szHeader = L"Accept:";
        break;
    case HTTP_QUERY_ACCEPT_CHARSET: 
        szHeader = L"Accept-Charset:";
        break;
    case HTTP_QUERY_ACCEPT_ENCODING: 
        szHeader = L"Accept-Encoding:";
        break;
    case HTTP_QUERY_ACCEPT_LANGUAGE: 
        szHeader = L"Accept-Language:";
        break;
    case HTTP_QUERY_ACCEPT_RANGES: 
        szHeader = L"Accept-Ranges:";
        break;
    case HTTP_QUERY_AGE: 
        szHeader = L"Age:";
        break;
    case HTTP_QUERY_ALLOW: 
        szHeader = L"Allow:";
        break;
    case HTTP_QUERY_AUTHORIZATION: 
        szHeader = L"Authorization:";
        break;
    case HTTP_QUERY_CACHE_CONTROL: 
        szHeader = L"Cache-Control:";
        break;
    case HTTP_QUERY_CONNECTION: 
        szHeader = L"Connection:";
        break;
    case HTTP_QUERY_CONTENT_BASE: 
        szHeader = L"Content-Base:";
        break;
    case HTTP_QUERY_CONTENT_DESCRIPTION: 
        szHeader = L"Content-Description:";
        break;
    case HTTP_QUERY_CONTENT_DISPOSITION: 
        szHeader = L"Content-Disposition:";
        break;
    case HTTP_QUERY_CONTENT_ENCODING: 
        szHeader = L"Content-encoding:";
        break;
    case HTTP_QUERY_CONTENT_ID: 
        szHeader = L"Content-ID:";
        break;
    case HTTP_QUERY_CONTENT_LANGUAGE: 
        szHeader = L"Content-Language:";
        break;
    case HTTP_QUERY_CONTENT_LENGTH: 
        szHeader = L"Content-Langth:";
        break;
    case HTTP_QUERY_CONTENT_LOCATION: 
        szHeader = L"Content-Location:";
        break;
    case HTTP_QUERY_CONTENT_MD5: 
        szHeader = L"Content-MD5:";
        break;
    case HTTP_QUERY_CONTENT_TRANSFER_ENCODING: 
        szHeader = L"Content-Transfer-Encoding:";
        break;
    case HTTP_QUERY_CONTENT_TYPE: 
        szHeader = L"Content-Type:";
        break;
    case HTTP_QUERY_COOKIE: 
        szHeader = L"Cookie:";
        break;
    case HTTP_QUERY_COST: 
        szHeader = L"Cost:";
        break;
    case HTTP_QUERY_CUSTOM: 
        szHeader = L"Custom:";
        break;
    case HTTP_QUERY_DATE: 
        szHeader = L"Date:";
        break;
    case HTTP_QUERY_DERIVED_FROM: 
        szHeader = L"Derived-From:";
        break;
    case HTTP_QUERY_ECHO_HEADERS: 
        szHeader = L"Echo-Headers:";
        break;
    case HTTP_QUERY_ECHO_HEADERS_CRLF: 
        szHeader = L"Echo-Headers-Crlf:";
        break;
    case HTTP_QUERY_ECHO_REPLY: 
        szHeader = L"Echo-Reply:";
        break;
    case HTTP_QUERY_ECHO_REQUEST: 
        szHeader = L"Echo-Request:";
        break;
    case HTTP_QUERY_ETAG: 
        szHeader = L"ETag:";
        break;
    case HTTP_QUERY_EXPECT: 
        szHeader = L"Expect:";
        break;
    case HTTP_QUERY_EXPIRES: 
        szHeader = L"Expires:";
        break;
    case HTTP_QUERY_FORWARDED: 
        szHeader = L"Forwarded:";
        break;
    case HTTP_QUERY_FROM: 
        szHeader = L"From:";
        break;
    case HTTP_QUERY_HOST: 
        szHeader = L"Host:";
        break;
    case HTTP_QUERY_IF_MATCH: 
        szHeader = L"If-Match:";
        break;
    case HTTP_QUERY_IF_MODIFIED_SINCE: 
        szHeader = L"If-Modified-Since:";
        break;
    case HTTP_QUERY_IF_NONE_MATCH: 
        szHeader = L"If-None-Match:";
        break;
    case HTTP_QUERY_IF_RANGE: 
        szHeader = L"If-Range:";
        break;
    case HTTP_QUERY_IF_UNMODIFIED_SINCE:
        szHeader = L"If-Unmodified-since:";
        break;
    case HTTP_QUERY_LINK:
        szHeader = L"Link:";
        break;
    case HTTP_QUERY_LAST_MODIFIED: 
        szHeader = L"Last-Modified:";
        break;
    case HTTP_QUERY_LOCATION: 
        szHeader = L"Location:";
        break;
    case HTTP_QUERY_MAX_FORWARDS: 
        szHeader = L"Max-Forwards:";
        break;
    case HTTP_QUERY_MESSAGE_ID: 
        szHeader = L"Message_Id:";
        break;
    case HTTP_QUERY_MIME_VERSION: 
        szHeader = L"Mime-Version:";
        break;
    case HTTP_QUERY_ORIG_URI: 
        szHeader = L"Orig-Uri:";
        break;
    case HTTP_QUERY_PRAGMA: 
        szHeader = L"Pragma:";
        break;
    case HTTP_QUERY_PROXY_AUTHENTICATE: 
        szHeader = L"Authenticate:";
        break;
    case HTTP_QUERY_PROXY_AUTHORIZATION: 
        szHeader = L"Proxy-Authorization:";
        break;
    case HTTP_QUERY_PROXY_CONNECTION: 
        szHeader = L"Proxy-Connection:";
        break;
    case HTTP_QUERY_PUBLIC: 
        szHeader = L"Public:";
        break;
    case HTTP_QUERY_RANGE: 
        szHeader = L"Range:";
        break;
    case HTTP_QUERY_REFERER: 
        szHeader = L"Referer:";
        break;
    case HTTP_QUERY_REFRESH: 
        szHeader = L"Refresh:";
        break;
    case HTTP_QUERY_REQUEST_METHOD: 
        szHeader = L"Request-Method:";
        break;
    case HTTP_QUERY_RETRY_AFTER: 
        szHeader = L"Retry-After:";
        break;
    case HTTP_QUERY_SERVER: 
        szHeader = L"Server:";
        break;
    case HTTP_QUERY_SET_COOKIE: 
        szHeader = L"Set-Cookie:";
        break;
    case HTTP_QUERY_STATUS_CODE: 
        szHeader = L"HTTP/1.1"; // Special!!!
        break;
    case HTTP_QUERY_STATUS_TEXT: 
        szHeader = L"HTTP/1.1"; // Special!!!
        break;
    case HTTP_QUERY_TITLE: 
        szHeader = L"Title:";
        break;
    case HTTP_QUERY_TRANSFER_ENCODING: 
        szHeader = L"Transfer-Encoding:";
        break;
    case HTTP_QUERY_UNLESS_MODIFIED_SINCE: 
        szHeader = L"Unless-Modified-Since:";
        break;
    case HTTP_QUERY_UPGRADE: 
        szHeader = L"Upgrade:";
        break;
    case HTTP_QUERY_URI: 
        szHeader = L"Uri:";
        break;
    case HTTP_QUERY_USER_AGENT: 
        szHeader = L"User-Agent:";
        break;
    case HTTP_QUERY_VARY: 
        szHeader = L"Vary:";
        break;
    case HTTP_QUERY_VERSION: 
        szHeader = L"Version:";
        break;
    case HTTP_QUERY_VIA: 
        szHeader = L"Via:";
        break;
    case HTTP_QUERY_WARNING: 
        szHeader = L"Warning:";
        break;
    case HTTP_QUERY_WWW_AUTHENTICATE:
        szHeader = L"WWW-Authenticate:";
        break;
    default:
        goto exit;
    }

    if (dwOption & HTTP_QUERY_FLAG_SYSTEMTIME)
    {
        if (*pcbBuf < sizeof(SYSTEMTIME) || pBuffer == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto exit;
        }
        else
        {
            LPSYSTEMTIME pSys = (LPSYSTEMTIME) pBuffer;
            GetSystemTime(pSys);
            *pcbBuf = sizeof(SYSTEMTIME);
            goto exit;
        }
    }


    if ((dwOption & HTTP_QUERY_FLAG_REQUEST_HEADERS) == 0)
        hr = DealWithBuffer(m_strResponseHeader, szHeader, dwOpt, dwOption, pBuffer, pcbBuf);
    if (hr == E_FAIL)
        hr = DealWithBuffer(m_extraHeaders, szHeader, dwOpt, dwOption, pBuffer, pcbBuf);

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::DealWithBuffer(
        LPWSTR   szHeaders, 
        LPCWSTR  szHeader, 
        DWORD    dwOpt, 
        DWORD    dwOption, 
        LPVOID   pBuffer, 
        LPDWORD  pcbBuf)
{
    LPCWSTR szValue = wcsstr(szHeaders, (LPWSTR) szHeader);
    if (szValue == NULL)
        return E_FAIL;

    DWORD dwStart  = wcslen(szHeader);
    while(iswspace(szValue[dwStart]) && szValue[dwStart] != L'\r')
        dwStart++;

    DWORD dwEnd    = dwStart;
   
    switch(dwOpt)
    {
    case HTTP_QUERY_STATUS_CODE:
        dwEnd = dwStart + 3;
        break;
    case HTTP_QUERY_STATUS_TEXT:
        dwStart += 4;// Fall thru to default
        dwEnd = dwStart;
    default:
        while(szValue[dwEnd] != NULL && szValue[dwEnd] != L'\r')
            dwEnd++;
        dwEnd--;
    }

    DWORD dwReq = (dwEnd - dwStart + 1);

    if ((dwOption & HTTP_QUERY_FLAG_NUMBER) && *pcbBuf < 4)
    {
        *pcbBuf = 4;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);            
    }
    if ((dwOption & HTTP_QUERY_FLAG_NUMBER) == 0 && *pcbBuf < dwReq)
    {
        *pcbBuf = dwReq;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER); 
    }
 

    if (dwOption & HTTP_QUERY_FLAG_NUMBER)
    {
        LPDWORD lpD = (LPDWORD) pBuffer;
        *lpD = _wtoi(&szValue[dwStart]);
        *pcbBuf = 4;
    }
    else
    {
        memcpy(pBuffer, &szValue[dwStart], dwReq*sizeof(WCHAR));
        ((WCHAR *) pBuffer)[dwReq] = NULL;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocol::ProcessAppManifest()
{
    HRESULT   hr   = S_OK;

    char    *szManifest;
    HANDLE  hFile;
    BYTE    buffer[1024];
    DWORD   dwLength;

    APPINFO aiApplication;

    aiApplication._wzNewRef[0] = L'\0';
    aiApplication._wzEntryAssemblyFileName[0] = L'\0';
    aiApplication._pFileList = NULL;

    // step 1: read the .manifest
    hFile = CreateFile(m_localStoreFilePath, GENERIC_READ, 0, NULL, 
                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    ZeroMemory(buffer, sizeof(buffer));

    while ( ReadFile (hFile, buffer, sizeof(buffer), &dwLength, NULL) && dwLength )
    {
            break; //BUGBUG: read once - only the 1st 1024 bytes
    }
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    *(buffer + dwLength) = '\0';
    szManifest = (char*) buffer;

    // step 2: parsing
    ParseManifest(szManifest, &aiApplication);

    // step 3: do "the works"

    // should take the base Uri, base appRoot, + file name
//***        if (FAILED(hr = InstallInternetFile2(wzSourceUri, m_appRootTranslated, filename, hash)))
//            goto exit;
    

exit:
    return hr;
}

void
AppProtocol::ParseManifest(char* szManifest, APPINFO* pAppInfo)
{
    char    *token;
    char    seps[] = " </>=\"\t\n\r";
    FILEINFOLIST* pCurrent = NULL;

//    WCHAR   wzDummyPath[MAX_PATH];
    WCHAR   wzSourceUri[MAX_PATH];

    BOOL    fSkipNextToken = FALSE;

    // parsing code - limitation: does not work w/ space in field, even if enclosed w/ quotes
    // szManifest will be modified!
    token = strtok( szManifest, seps );
    while( token != NULL )
    {
//        wzDummyPath[0] = L'\0';

       // While there are tokens
       if (!_stricmp(token, "file"))
       {
            // get around in spaced tag
            token = strtok( NULL, seps );
            if (!_stricmp(token, "name"))
            {
                token = strtok( NULL, seps );

/*                lstrcpy(wzSourceUri, m_fullUri);
                WCHAR* p = wcsrchr(wzSourceUri, L'/');
                WCHAR* q = wcsrchr(wzSourceUri, L'.');
                if (p && q && (p < q))
                    *p = L'\0';
                else
                {
                    hr = E_INVALIDARG;
                    goto exit;
                }
                
                _snwprintf(wzSourceUri, MAX_PATH, L"%s/%S", wzSourceUri, token);*/

                // init
                if (pCurrent == NULL)
                {
                    pAppInfo->_pFileList = new FILEINFOLIST;
                    pCurrent = pAppInfo->_pFileList;
                }
                else
                {
                    pCurrent->_pNext = new FILEINFOLIST;
                    pCurrent = pCurrent->_pNext;
                }

                pCurrent->_pNext = NULL;
                _snwprintf(pCurrent->_wzFilename, MAX_PATH, L"%S", token); // worry about total path len later

//no need       m_pProtocolSink->ReportProgress(BINDSTATUS_BEGINDOWNLOADCOMPONENTS, L"downloading application files");

                token = strtok( NULL, seps );
                if (!_stricmp(token, "hash"))
                {
                    _snwprintf(pCurrent->_wzHash, 33, L"%S", token);

                    // ???? should i reuse the file handle instead?
//*                    if (IsFileCorrupted(m_localStoreFilePath, token))    Integrity
//*                        ...
                }
                else
                    fSkipNextToken = TRUE;            
            }
       }
       else if (!_stricmp(token, "newhref"))
       {
            // note, different handling... because '/' is one of seps
            for (int i = 0; i < MAX_URL_LENGTH; i++)
            {
                if (*(token+8+i) == '<')
                {
                    // BUGBUG: 8 == strlen("newhref>")
                    *(token+8+i) = '\0';
                    _snwprintf(pAppInfo->_wzNewRef, i, L"%S", token+8);

                    // BUGBUG? is this going to work?
                    token = strtok( token+i+9, seps);
                    // now  token == "newhref" && *(token-1) == '/'
                }
            }

            // BUGBUG: ignoring > MAX_URL_LENGTH case here... may mess up later if the URL contain a "keyword"
            // <newhref></newhref> may be ok...
       }

       //else
       // ignore others for now

    // Get next token...
    if(!fSkipNextToken)
        token = strtok( NULL, seps );
    else
        fSkipNextToken = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\appprotocolfactory.cxx ===
/**
 * Asynchronous pluggable protocol for Applications
 *
 * Copyright (C) Microsoft Corporation, 2000
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "app.h"

//LONG g_cAppPObject = 0;
ULONG IncrementDllObjectCount();
ULONG DecrementDllObjectCount();

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocolFactory::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown ||
        iid == IID_IInternetProtocolInfo)
    {
        *ppv = (IInternetProtocolInfo *)this;
    }
    else
        if (iid == IID_IClassFactory)
        {
            *ppv = (IClassFactory *)this;
        }
        else
        {
            return E_NOINTERFACE;
        }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////

ULONG
AppProtocolFactory::AddRef()
{
    //return InterlockedIncrement(&g_cAppPObject);
    return IncrementDllObjectCount();
}

ULONG
AppProtocolFactory::Release()
{
    //return InterlockedDecrement(&g_cAppPObject);
    return DecrementDllObjectCount();
}

HRESULT
AppProtocolFactory::LockServer(BOOL lock)
{
    //return (lock ? 
    //        InterlockedIncrement(&g_cAppPObject) : 
    //        InterlockedDecrement(&g_cAppPObject));
    return (lock ? IncrementDllObjectCount() : DecrementDllObjectCount());
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocolFactory::CreateInstance(
        IUnknown * pUnkOuter,
        REFIID     iid,
        void **    ppv)
{
    HRESULT hr = S_OK;
    AppProtocol *pProtocol = NULL;

    if (pUnkOuter && iid != IID_IUnknown)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if ((pProtocol = new AppProtocol(pUnkOuter)) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (iid == IID_IUnknown)
    {
        *ppv = (IPrivateUnknown *)pProtocol;
        pProtocol->PrivateAddRef();
    }
    else
    {
        hr = pProtocol->QueryInterface(iid, ppv);
        if (FAILED(hr))
           goto exit;
    }

exit:
    if (pProtocol)
        pProtocol->PrivateRelease();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AppProtocolFactory::CombineUrl(
        LPCWSTR, 
        LPCWSTR, 
        DWORD, 
        LPWSTR,  
        DWORD, 
        DWORD *, 
        DWORD)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT
AppProtocolFactory::CompareUrl(LPCWSTR, LPCWSTR, DWORD)
{
    return INET_E_DEFAULT_ACTION;
}


HRESULT
AppProtocolFactory::ParseUrl(
        LPCWSTR       pwzUrl,
        PARSEACTION   ParseAction,
        DWORD         ,
        LPWSTR        pwzResult,
        DWORD         cchResult,
        DWORD *       pcchResult,
        DWORD         )
{
    // Only thing we handle is security zones...
    if (ParseAction != PARSE_SECURITY_URL && ParseAction != PARSE_SECURITY_DOMAIN)
        return INET_E_DEFAULT_ACTION;

    // Check to make sure args are okay
    if ( pwzUrl == NULL || pwzResult == NULL || cchResult < wcslen(HTTP_SCHEME)+1/*4*/ || wcslen(pwzUrl) < PROTOCOL_NAME_LEN)
        return INET_E_DEFAULT_ACTION;

    // Check if the protocol starts with app
    for(int iter=0; iter<PROTOCOL_NAME_LEN; iter++)
        if (towlower(pwzUrl[iter]) != PROTOCOL_NAME[iter])
            return INET_E_DEFAULT_ACTION; // Doesn't start with app
    
    // Copy in the corresponding http protocol
    wcscpy(pwzResult, HTTP_SCHEME);   
    wcsncpy(&pwzResult[4], &pwzUrl[PROTOCOL_NAME_LEN], cchResult - 5);
    pwzResult[cchResult-1] = NULL;
    (*pcchResult) = wcslen(pwzResult);

    return S_OK;
}


HRESULT
AppProtocolFactory::QueryInfo(LPCWSTR, QUERYOPTION, DWORD,
                             LPVOID, DWORD, DWORD *, DWORD)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\precomp.h ===
/**
 * Precompiled header for AppAPP
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

// Standard headers

#define UNICODE

#include <windows.h>
#include <objbase.h>
#include <httpext.h>
#include <shlwapi.h>
#include <malloc.h>

HRESULT GetLastWin32Error();

void *MemAlloc(size_t size);
void *MemAllocClear(size_t size);
void  MemFree(void *pMem);
void  MemClearFn(void **ppMem);
void *MemReAlloc(void *pMem, size_t NewSize);
size_t  MemGetSize(void *pv);
void *MemDup(void *pMem, int cb);

/*#ifdef ASSERT
#undef ASSERT
#endif

#define ASSERT(x) 	  do { if (!((DWORD)(x)|g_dwFALSE) && DbgpAssert(DbgComponent, #x, __FILE__, __LINE__, NULL)) DbgBreak(); } while (g_dwFALSE)
*/
void ClearInterfaceFn(IUnknown ** ppUnk);
void ReplaceInterfaceFn(IUnknown ** ppUnk, IUnknown * pUnk);

template <class PI>
inline void
ClearInterface(PI * ppI)
{
#if DBG
//    IUnknown * pUnk = *ppI;
//    ASSERT((void *) pUnk == (void *) *ppI);
#endif
    ClearInterfaceFn((IUnknown **) ppI);
}

template <class PI>
inline void
ReplaceInterface(PI * ppI, PI pI)
{
#if DBG
//    IUnknown * pUnk = *ppI;
//    ASSERT((void *) pUnk == (void *) *ppI);
#endif
    ReplaceInterfaceFn((IUnknown **) ppI, pI);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\functions.cxx ===
/**
 * Asynchronous pluggable protocol for Applications
 *
 * Copyright (C) Microsoft Corporation, 2000
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "app.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//  Private globals
HINSTANCE g_DllInstance;
long      g_DllObjectCount;

//  Prototypes
extern "C"
{
BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID);
STDAPI      DllCanUnloadNow();
STDAPI      DllGetClassObject(REFCLSID, REFIID, LPVOID*);
STDAPI      DllRegisterServer();
STDAPI      DllUnregisterServer();
}

/*HRESULT
InitDll()
{
    HRESULT hr;

    //LoadLibrary(L"XSPISAPI.DLL");   // to disable unloading

    //hr = InitThreadPool();
    //ON_ERROR_EXIT();

//    hr = InitCodeGenerator();
  //  if (FAILED(hr))
    //   goto exit;

//  hr = DllInitProcessModel();
  //if (FAILED(hr))
    // goto exit;

//exit:
    hr = S_OK;
    return hr;
}*/


/*HRESULT
UninitDll()
{
    HRESULT hr;

//  hr = UninitCodeGenerator();
    hr = S_OK;
    return hr;
}*/


BOOL WINAPI
DllMain(
    HINSTANCE Instance,
    DWORD Reason,
    LPVOID)
{
    HRESULT hr = S_OK;
    BOOL    ret = TRUE;

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        // remember the instance
        g_DllInstance = Instance;
        DisableThreadLibraryCalls(Instance);

//        hr = InitDll();
        if (hr)
        {
            ret = FALSE;
            goto exit;
        }

        break;

    case DLL_PROCESS_DETACH:
//        hr = UninitDll();
        break;

    default:
        break;
    }

exit:
    return ret;
}

ULONG
IncrementDllObjectCount()
{
    return InterlockedIncrement(&g_DllObjectCount);
}

ULONG
DecrementDllObjectCount()
{

    ULONG count = InterlockedDecrement(&g_DllObjectCount);
    if (count == 0)
    {
        TerminateAppProtocol();
    }
    return count;
}

STDAPI
DllCanUnloadNow()
{
    // TODO: Make this code thread safe.

    return g_DllObjectCount > 0 ? S_FALSE : S_OK;
}

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    if (clsid == CLSID_AppProtocol)
    {
        hr = GetAppProtocolClassObject(iid, ppv);
        if (FAILED(hr))
            goto exit;
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto exit;
    }

exit:
    return hr;
}

// for errors define
#include <olectl.h>

STDAPI
DllRegisterServer()
{
    // BUGBUG: for now! copy code from register.cxx XSP later
    return SELFREG_E_CLASS;
}

STDAPI
DllUnregisterServer()
{
    // BUGBUG: for now! copy code from register.cxx XSP later
    return SELFREG_E_CLASS;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL         (WINAPI * g_pInternetSetCookieW  ) (LPCTSTR, LPCTSTR, LPCTSTR)                             = NULL;
BOOL         (WINAPI * g_pInternetGetCookieW  ) (LPCTSTR, LPCTSTR, LPTSTR, LPDWORD)                     = NULL;
HINTERNET    (WINAPI * g_pInternetOpen        ) (LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD)               = NULL;
void         (WINAPI * g_pInternetCloseHandle ) (HINTERNET)                                             = NULL;
HINTERNET    (WINAPI * g_pInternetOpenUrl     ) (HINTERNET, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR)  = NULL;
BOOL         (WINAPI * g_pInternetReadFile    ) (HINTERNET, LPVOID, DWORD, LPDWORD)                     = NULL;
BOOL         (WINAPI * g_pInternetQueryOption ) (HINTERNET, DWORD, LPVOID, LPDWORD)                     = NULL;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT InitializeAppProtocol()
{
    if (g_fStarted)
        return TRUE;

    HRESULT             hr             = S_OK;
    HINSTANCE           hWinInet       = NULL;
   
    ////////////////////////////////////////////////////////////
    // Step 3: Obtain  entry points from WININET.DLL
    hWinInet = GetModuleHandle(L"WININET.DLL");
    if(hWinInet == NULL)
        hWinInet = LoadLibrary(L"WININET.DLL");
    if(hWinInet == NULL)
    {
        hr = GetLastWin32Error();
        goto exit;
    }
    
    g_pInternetSetCookieW = (BOOL (WINAPI *)(LPCTSTR, LPCTSTR, LPCTSTR))
        GetProcAddress(hWinInet, "InternetSetCookieW");
    g_pInternetGetCookieW = (BOOL (WINAPI *)(LPCTSTR, LPCTSTR, LPTSTR, LPDWORD))
        GetProcAddress(hWinInet, "InternetGetCookieW");
    g_pInternetOpen = (HINTERNET (WINAPI *)(LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD))
        GetProcAddress(hWinInet, "InternetOpenW");
    g_pInternetCloseHandle = (void (WINAPI *)(HINTERNET))
        GetProcAddress(hWinInet, "InternetCloseHandle");
    g_pInternetOpenUrl = (HINTERNET (WINAPI *)(HINTERNET, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR))
        GetProcAddress(hWinInet, "InternetOpenUrlW");
    g_pInternetReadFile = (BOOL (WINAPI *)(HINTERNET, LPVOID, DWORD, LPDWORD))
        GetProcAddress(hWinInet, "InternetReadFile");
    g_pInternetQueryOption = (BOOL (WINAPI *)(HINTERNET, DWORD, LPVOID, LPDWORD))
        GetProcAddress(hWinInet, "InternetQueryOptionW");
        
    if ( g_pInternetSetCookieW   == NULL ||
         g_pInternetGetCookieW   == NULL ||
         g_pInternetOpen         == NULL ||
         g_pInternetCloseHandle  == NULL ||
         g_pInternetOpenUrl      == NULL ||
         g_pInternetReadFile     == NULL ||
         g_pInternetQueryOption  == NULL )
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    g_fStarted = TRUE;

exit:
    // ???? freelibrary later?

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
GetAppProtocolClassObject(
        REFIID    iid, 
        void **   ppv)
{
    HRESULT hr;

    hr = InitializeAppProtocol();
    if (FAILED(hr))
        goto exit;

    hr = g_AppProtocolFactory.QueryInterface(iid, ppv);
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LPWSTR
DuplicateString ( LPCWSTR szString)
{
  if (szString == NULL)
    return NULL;

  LPWSTR szReturn = (LPWSTR) MemAlloc((wcslen(szString) + 1) * sizeof(WCHAR));

  if (szReturn != NULL)
    wcscpy(szReturn, szString);

  return szReturn;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Cleanup for process shutdown.

//????????
BOOL WINAPI TerminateExtension(DWORD)
{
    return TRUE;
}

void
TerminateAppProtocol()
{
    // TODO: This is never called. Figure out how to get proper shutdown. Consider possible refcount leaks.

    if (g_fStarted)
    {
        TerminateExtension(0); // this is in xspprobe.cxx, but doesn't do anything!
        g_fStarted = FALSE;
    }
}


/**
 * Allocate memory block.
 */
void *
MemAlloc(
    size_t size)
{
    return (void *)HeapAlloc(GetProcessHeap(), 0, size);
}

/**
 * Allocate memory block and zero it out.
 */
void *
MemAllocClear(
    size_t size)
{
    return (void *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

/**
 * Free allocated memory block.
 */
void
MemFree(
    void *pMem)
{
    if (pMem != NULL)
        HeapFree(GetProcessHeap(), 0, pMem);
}

/**
 * Free allocated memory block, then clear the reference.
 */
void  
MemClearFn(void **ppMem)
{
    if (*ppMem != NULL)
    {
        HeapFree(GetProcessHeap(), 0, *ppMem);
        *ppMem = NULL;
    }
}


/**
 * Reallocate memory block
 */
void *
MemReAlloc(
    void *pMem,
    size_t NewSize)
{
    void *pResult = NULL;

    if (pMem != NULL) 
    {
        pResult = (void *)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pMem, NewSize);
    } else {
        pResult = (void *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, NewSize);
    }

    return pResult;
}


/**
 * Get the size of a memory block.
 */
size_t  
MemGetSize(void *pv)
{
    int result;

    if (pv == NULL)
        return 0;

    result = HeapSize(GetProcessHeap(), 0, pv);
//    ASSERT(result != -1);
    return result;
}



/**
 * Copy memory block
 */
void *
MemDup(void *pMem, int cb)
{
    void *p = MemAlloc(cb);
    if (p == NULL) 
        return NULL;

    CopyMemory(p, pMem, cb);
    return p;
}


void
ClearInterfaceFn(
	IUnknown ** ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}

void
ReplaceInterfaceFn(
	IUnknown ** ppUnk,
	IUnknown * pUnk)
{
    IUnknown * pUnkOld = *ppUnk;

    *ppUnk = pUnk;

    //  Note that we do AddRef before Release; this avoids
    //    accidentally destroying an object if this function
    //    is passed two aliases to it

    if (pUnk)
        pUnk->AddRef();

    if (pUnkOld)
        pUnkOld->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\version.h ===
/**
 * Version strings for APP.DLL.
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

// Standard version includes

#pragma once

#include <winver.h>
#include <ntverp.h>

//
// APP Version
//
// Version numbers can be assigned in newbuild.cmd
//

#ifndef APP_VER_MAJORVERSION
#define APP_VER_MAJORVERSION 1
#endif

#ifndef APP_VER_MINORVERSION
#define APP_VER_MINORVERSION 0
#endif

#ifndef APP_VER_PRODUCTBUILD
#define APP_VER_PRODUCTBUILD 0
#endif

#ifndef APP_VER_PRODUCTBUILD_QFE
#define APP_VER_PRODUCTBUILD_QFE 0
#endif

//
// Allow a component to override values in individual rc files
// by checking if these are already defined
//
#ifndef APP_VER_PRODUCTNAME_STR
#define APP_VER_PRODUCTNAME_STR      "Microsoft (R) Application Protocol"
#endif

#ifndef APP_VER_INTERNALNAME_STR
#define APP_VER_INTERNALNAME_STR     "APP"
#endif

// the following two are defined in individual RC files:
//      APP_VER_ORIGINALFILENAME_STR
//      APP_VER_FILEDESCRIPTION_STR

//
// Don't edit the remainder of this file to change version values.
// Edit above instead.
//

#if APPBLDTYPE_FREE
#define APP_BLDTYPE_STR     "Free"
#elif APPBLDTYPE_ICECAP
#define APP_BLDTYPE_STR     "Icecap"
#elif APPBLDTYPE_RETAIL
#define APP_BLDTYPE_STR     "Retail"
#else //APPBLDTYPE_DEBUG
#define APP_BLDTYPE_STR     "Debug"
#endif

//
// undefine these values as some are defined in sdk\inc\ntverp.h
//

#ifdef VER_MAJORVERSION
#undef VER_MAJORVERSION
#endif

#ifdef VER_MINORVERSION
#undef VER_MINORVERSION
#endif

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifdef VER_INTERNALNAME_STR
#undef VER_INTERNALNAME_STR
#endif

#ifdef VER_ORIGINALFILENAME_STR
#undef VER_ORIGINALFILENAME_STR
#endif

#ifdef VER_FILEDESCRIPTION_STR
#undef VER_FILEDESCRIPTION_STR
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_FILEVERSION_STR
#undef VER_FILEVERSION_STR
#endif

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_FILETYPE
#undef VER_FILETYPE
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#define VER_MAJORVERSION         APP_VER_MAJORVERSION
#define VER_MINORVERSION         APP_VER_MINORVERSION
#define VER_PRODUCTBUILD         APP_VER_PRODUCTBUILD
#define VER_PRODUCTBUILD_QFE     APP_VER_PRODUCTBUILD_QFE

#define VER_PRODUCTNAME_STR      APP_VER_PRODUCTNAME_STR
#define VER_INTERNALNAME_STR     APP_VER_INTERNALNAME_STR
#define VER_ORIGINALFILENAME_STR APP_VER_ORIGINALFILENAME_STR
#define VER_FILEDESCRIPTION_STR  APP_VER_FILEDESCRIPTION_STR

#define CONCAT5HELPER(a, b, c, d, e)      #a "." #b "." #c "." #d " " e
#define CONCAT5(a, b, c, d, e)            CONCAT5HELPER(a, b, c, d, e)

#define CONCAT5HELPER_L(a, b, c, d, e)    L ## #a L"." L ## #b L"." L ## #c L"." L ## #d L" " L ## e
#define CONCAT5_L(a, b, c, d, e)          CONCAT5HELPER_L(a, b, c, d, e)

#define VER_PRODUCTVERSION_STR   CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)
#define VER_PRODUCTVERSION_STR_L CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)

#define VER_PRODUCTVERSION       VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILEVERSION_STR      CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)
#define VER_FILEVERSION_STR_L    CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)

#define VER_FILEVERSION          VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          VFT2_UNKNOWN


// Standard NT build defines

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\asmexec\asmexec.cs ===
/*=============================================================================
**
** Class: ASMExecute
**
** Purpose: Used to setup the correct hosting environment before executing an
**          assembly
**
** Date: 2:24 PM 10/20/2000
**
** Copyright (c) Microsoft, 1999-2000
**
=============================================================================*/
namespace ComHost {
    using System;
    using System.Text;
    using System.Reflection;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;
    //using IIEHost;
    
    public class AsmExecute : MarshalByRefObject
    {
        public static readonly int SECURITY_NONE = 0x00;
        public static readonly int SECURITY_ZONE = 0x01;
        public static readonly int SECURITY_SITE = 0x02;

		public void Execute(string codebase, string flags)
		{
			string[] args = {codebase, flags};
			Process(args);
		}

		public void Execute(string codebase, string flags, string evidence)
		{
			string[] args = {codebase, flags, evidence};
			Process(args);		
		}

		public void Execute(string codebase, string flags, string evidence1, string evidence2, string evidence2url)
		{
			string[] args = {codebase, flags, evidence1, evidence2, evidence2url};
			Process(args);		
		}

		// Arguments: Codebase, flags, zone, uniqueid, siteurl
        // If the flags indicate zone then a zone must be provided. 
        // If the flags indicate a site then a uniqueid must be provided
		//static void Main(string[] args)
		private void Process(string[] args)
        {
            if(args == null || args.Length < 2)
                throw new ArgumentException();
            
            int index = 0;
            string file = args[index++];
            if(file == null) 
                throw new ArgumentException();
            
            // Find the URL of the executable. For now we assume the 
            // form to be http://blah/... with forward slashes. This
            // need to be update.
			// Note: aso works w/ '\' as in file paths
            string URL = null;
            string Configuration = null;
            int k = file.LastIndexOf('/');
            if(k <= 0)
			{
				k = file.LastIndexOf('\\');
				if(k == 0) 
				{
		            URL = file;
	                Configuration = file;
				}
            }

			if(k != 0)
			{
				// if k is still < 0 at this point, URL should be an empty string
				// BUGBUG: should URL be null instead??
                URL = file.Substring(0,k+1);
                if(k+1 < file.Length) 
                    Configuration = file.Substring(k+1);
            }

			// BUGBUG: should URL be the source of the code, not local?
            Console.WriteLine("URL- {0}", URL);

            // Build up the configuration File name
            if(Configuration != null)
	
			{
                k = Configuration.LastIndexOf('.');
                StringBuilder bld = new StringBuilder();
                if(k > 0)
				{
                    bld.Append(Configuration.Substring(0,k));
                    bld.Append(".cfg");
                }
                else
				{
                    bld.Append(Configuration);
                    bld.Append(".cfg");
                }
                Configuration = bld.ToString();
            }

            Console.WriteLine("Config- {0}", Configuration);

			// Get the flags 
            // 0x1 we have Zone
            // 0x2 we have a unique id.
            int dwFlag = Int32.Parse(args[index++], NumberStyles.HexNumber);//CultureInfo.InvariantCulture);

            string friendlyName = GetSiteName(file);
			Console.WriteLine("SiteName- {0}", friendlyName);
            Evidence documentSecurity = null;
            int size = 0;
            if((dwFlag & SECURITY_ZONE) != 0) 
                size++;
            if((dwFlag & SECURITY_SITE) != 0)
                size++;

            if(size != 0) 
                documentSecurity = new Evidence();
        
            if((dwFlag & SECURITY_ZONE) != 0)
			{
                if(index == args.Length) 
                    throw new ArgumentException();
                int zone = Int32.Parse(args[index++], NumberStyles.HexNumber);//, CultureInfo.InvariantCulture);
                documentSecurity.AddHost( new Zone((System.Security.SecurityZone)zone) );
            }
            if((dwFlag & SECURITY_SITE) != 0)
			{
                if(index == args.Length-1)
                    throw new ArgumentException();
                byte[] uniqueId = DecodeDomainId(args[index++]);
                documentSecurity.AddHost( new Site(uniqueId, args[index]) );//file) ); uses the url instead
            }

            AppDomain adProxy = AppDomain.CreateDomain(friendlyName, documentSecurity, null);

//            if(adProxy != null)
//			{
            adProxy.SetData(AppDomainFlags.ApplicationBase, URL);
            adProxy.SetData(AppDomainFlags.PrivateBinPath, "bin");
            if(Configuration != null)
			{
                adProxy.SetData(AppDomainFlags.Configuration, Configuration);
            }

			string asmname = Assembly.GetExecutingAssembly().Location;
			Console.WriteLine("AsmName- {0}", asmname);
			Console.WriteLine("\n========");

			// Use remoting. Otherwise asm will be loaded both in current and the new AppDomain
			// ... as explained by URT ppl
			// asmexec.dll must be found on path (CorPath?) for this to work.
            ObjectHandle handle = adProxy.CreateInstanceFrom(asmname, "ComHost.AsmExecute");
            if (handle != null)
			{
                AsmExecute execproxy = (AsmExecute)handle.Unwrap();
                if (execproxy != null)
                    execproxy.RunExecute(file, documentSecurity);
            }

			Console.WriteLine("\n========");
        }

        private void RunExecute(string file, Evidence evidence)
        {
            new SecurityPermission(SecurityPermissionFlag.ControlEvidence).Assert();
            AppDomain.CurrentDomain.ExecuteAssembly(file, evidence);
        }

		private static int ConvertHexDigit(char val)
		{
            if (val <= '9') return (val - '0');
            return ((val - 'A') + 10);
        }
        
        public static byte[] DecodeDomainId(string hexString)
		{
            byte[] sArray = new byte[(hexString.Length / 2)];
            int digit;
            int rawdigit;
            for (int i = 0, j = 0; i < hexString.Length; i += 2, j++) {
                digit = ConvertHexDigit(hexString[i]);
                rawdigit = ConvertHexDigit(hexString[i+1]);
                sArray[j] = (byte) (digit | (rawdigit << 4));
            }
            return(sArray);
        }

        public static string GetSiteName(string pURL) 
        {
            // BUGBUG: this does not work w/ UNC or file:// (?)
            string siteName = null;
            if(pURL != null) {
                int j = pURL.IndexOf(':');  
                
                // If there is a protocal remove it. In a URL of the form
                // yyyy://xxxx/zzzz   where yyyy is the protocal, xxxx is
                // the site and zzzz is extra we want to get xxxx.
                if(j != -1 && 
                   j+3 < pURL.Length &&
                   pURL[j+1] == '/' &&
                   pURL[j+2] == '/') 
                    {
                        j+=3;
                        
                        // Remove characters after the
                        // next /.  
                        int i = pURL.IndexOf('/',j);
                        if(i > -1) 
                            siteName = pURL.Substring(j,i-j);
                        else 
                            siteName = pURL.Substring(j);
                    }
            
                if(siteName == null)
                    siteName = pURL;
            }
            return siteName;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\app.h ===
/**
 * App.h header file
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

//#if _MSC_VER > 1000
#pragma once
//#endif

#ifndef _AppAPP_H
#define _AppAPP_H

#include "wininet.h"

/////////////////////////////////////////////////////////////////////////////
#define PROTOCOL_NAME           L"appx"          //??????? get around app: in IE5
#define PROTOCOL_NAME_LEN       4
#define PROTOCOL_PREFIX         PROTOCOL_NAME L":"
#define PROTOCOL_SCHEME         PROTOCOL_NAME L"://"
#define HTTP_SCHEME             L"http://"

#define HTTP_RESPONSEOK         "HTTP/1.1 200 OK\r\n"
/////////////////////////////////////////////////////////////////////////////

#define STORE_PATH              L"\\Application Store"

#define APPTYPE_IE              0
#define APPTYPE_BYMANIFEST      1
#define APPTYPE_ASM             2
#define APPTYPE_MYWEB           3

#define STATUS_CLEAR            0x0
#define STATUS_OFFLINE_MODE     0x1
#define STATUS_NOT_IN_CACHE     0x2

#define MAX_URL_LENGTH          512     // some hardcoded #, for now

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Global Objects
extern  CLSID		CLSID_AppProtocol;
extern  BOOL 		g_fStarted;

/////////////////////////////////////////////////////////////////////////////
// Imported WININET functions, setup in functions.cxx

extern  BOOL         (WINAPI * g_pInternetSetCookieW  ) (LPCTSTR, LPCTSTR, LPCTSTR);
extern  BOOL         (WINAPI * g_pInternetGetCookieW  ) (LPCTSTR, LPCTSTR, LPTSTR, LPDWORD);
extern  HINTERNET    (WINAPI * g_pInternetOpen        ) (LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD);
extern  void         (WINAPI * g_pInternetCloseHandle ) (HINTERNET);
extern  HINTERNET    (WINAPI * g_pInternetOpenUrl     ) (HINTERNET, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR);
extern  BOOL         (WINAPI * g_pInternetReadFile    ) (HINTERNET, LPVOID, DWORD, LPDWORD);
extern  BOOL         (WINAPI * g_pInternetQueryOption ) (HINTERNET, DWORD, LPVOID, LPDWORD);    // for offline mode

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Data structures

struct FILEINFOLIST
{
    WCHAR   _wzFilename[MAX_PATH];    // can have \ but not ..\ ; no path, should be much shorter than MAX_PATH
    WCHAR   _wzHash[33];              // 32 + L'\0'

    FILEINFOLIST*   _pNext;
};

struct APPINFO
{
    WCHAR           _wzNewRef[MAX_URL_LENGTH];
    WCHAR           _wzEntryAssemblyFileName[MAX_PATH];
    FILEINFOLIST*   _pFileList;
};
// + m_appRootTranslated

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Clases and interfaces

interface IPrivateUnknown
{
public:
   STDMETHOD  (PrivateQueryInterface) (REFIID riid, void ** ppv) = 0;
   STDMETHOD_ (ULONG, PrivateAddRef)  () = 0;
   STDMETHOD_ (ULONG, PrivateRelease) () = 0;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class AppProtocol : public IPrivateUnknown, public IInternetProtocol, public IWinInetHttpInfo
{
public:
  AppProtocol        (IUnknown *pUnkOuter);
  ~AppProtocol       ();

  // IPrivateUnknown methods
  STDMETHOD_        (ULONG, PrivateAddRef)    ();
  STDMETHOD_        (ULONG, PrivateRelease)   ();
  STDMETHOD         (PrivateQueryInterface)   (REFIID, void **);

  // IUnknown methods
  STDMETHOD_        (ULONG, AddRef)           ();
  STDMETHOD_        (ULONG, Release)          ();
  STDMETHOD         (QueryInterface)          (REFIID, void **);

  // IInternetProtocol, IInternetProtocolRoot methods
  STDMETHOD         (Start)                   (LPCWSTR, IInternetProtocolSink *, IInternetBindInfo *, DWORD, DWORD);
  STDMETHOD         (Continue)                (PROTOCOLDATA *pProtData);
  STDMETHOD         (Abort)                   (HRESULT hrReason,DWORD );
  STDMETHOD         (Terminate)               (DWORD );
  STDMETHOD         (Suspend)                 ();
  STDMETHOD         (Resume)                  ();
  STDMETHOD         (Read)                    (void *pv, ULONG cb, ULONG *pcbRead);
  STDMETHOD         (Seek)                    (LARGE_INTEGER , DWORD , ULARGE_INTEGER *) ;
  STDMETHOD         (LockRequest)             (DWORD );
  STDMETHOD         (UnlockRequest)           ();

  // IWinInetHttpInfo
  STDMETHOD         (QueryInfo)               (DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf, DWORD *pdwFlags, DWORD *pdwReserved);
  STDMETHOD         (QueryOption)             (DWORD , LPVOID, DWORD *);


  // Public functions called by exported functions
  HRESULT           WriteBytes                (BYTE *buf, DWORD dwLength);
  HRESULT           SendHeaders               (LPSTR buffer);
//  HRESULT           SaveCookie                (LPSTR header);
  int               GetString                 (int key, WCHAR *buf, int size);
  int               GetStringLength           (int key);
//  int               MapPath                   (WCHAR *virtualPath, WCHAR *physicalPath, int length);
  HRESULT           Finish                    ();
//  int               GetKnownRequestHeader     (LPCWSTR szHeader, LPWSTR buf, int size);


private:
  // Private functions
  HRESULT           SetupAndInstall        (LPTSTR url, LPTSTR path);
  HRESULT           ParseUrl                  (LPCTSTR url);
//  HRESULT           GetAppBaseDir             (LPCTSTR base, LPTSTR appRoot);
  WCHAR *           MapString                 (int key);
  void              Cleanup                   ();
  void              FreeStrings               ();
  HRESULT           InstallInternetFile      (LPTSTR url, LPTSTR path);
  HRESULT           InstallInternetFile2      (LPTSTR url, LPTSTR path);
  HRESULT           DealWithBuffer            (LPWSTR szHeaders, LPCWSTR szHeader, 
                                               DWORD dwOpt, DWORD dwOption, 
                                               LPVOID pBuffer, LPDWORD pcbBuf);
  HRESULT           ProcessAppManifest        ();
  void              ParseManifest             (char* szManifest, APPINFO* pAppInfo);
  

  long                    m_refs;
  IUnknown *              m_pUnkOuter;
  DWORD                   m_bindf;
  BINDINFO                m_bindinfo;

  IInternetProtocolSink * m_pProtocolSink;  

  CRITICAL_SECTION        m_csOutputWriter;
  DWORD                   m_cbOutput;
  IStream *               m_pOutputRead;
  IStream *               m_pOutputWrite;

  BOOL                    m_started;
  BOOL                    m_aborted;
  BOOL                    m_done;
  BOOL                    m_redirect;

  DWORD                   m_inputDataSize;
  BYTE *                  m_inputData;
  IStream *               m_pInputRead;

  WCHAR *                 m_verb;
  WCHAR *                 m_fullUri;    // "myWeb://www.site.com/app/something/else"
  WCHAR *                 m_uriPath;       // "/app/something/else"
  WCHAR *                 m_queryString;   // "?aaa=bbb"
  WCHAR *                 m_appOrigin;     // "www.site.com"
  WCHAR *                 m_appRoot;       //  "/app"
  WCHAR *                 m_appRootTranslated;  // "c:\program files\site myweb app"
  WCHAR *                 m_extraHeaders;
  WCHAR *                 m_postedMimeType;
  WCHAR *                 m_responseMimeType;
//  WCHAR *                 m_cookie;
  WCHAR *                 m_extraHeadersUpr;
  WCHAR *                 m_strResponseHeader;
  WCHAR *                 m_localStoreFilePath;

  int                     m_appType;
  int                     m_status;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class AppProtocolFactory : public IClassFactory, public IInternetProtocolInfo
{
public:
    // IUnknown Methods
    STDMETHOD_    (ULONG, AddRef)    ();
    STDMETHOD_    (ULONG, Release)   ();
    STDMETHOD     (QueryInterface)   (REFIID, void **);

    // IClassFactory Moethods
    STDMETHOD     (LockServer)       (BOOL);
    STDMETHOD     (CreateInstance)   (IUnknown*,REFIID,void**);

    // IInternetProtocolInfo Methods
    STDMETHOD     (CombineUrl)       (LPCWSTR,LPCWSTR,DWORD,LPWSTR,DWORD,DWORD *,DWORD);
    STDMETHOD     (CompareUrl)       (LPCWSTR, LPCWSTR, DWORD);
    STDMETHOD     (ParseUrl)         (LPCWSTR, PARSEACTION, DWORD, LPWSTR, DWORD, DWORD *, DWORD);
    STDMETHOD     (QueryInfo)        (LPCWSTR, QUERYOPTION, DWORD, LPVOID, DWORD, DWORD *, DWORD);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Gloabal functions
//HRESULT
//InstallInternetFile( LPTSTR   url, LPTSTR   path);


void
TerminateAppProtocol();

HRESULT 
GetAppProtocolClassObject(REFIID iid, void **ppv);

HRESULT 
InitializeAppProtocol();

/*UINT WINAPI
CabFileHandler( LPVOID context, 
                UINT notification,
                UINT_PTR param1,
                UINT_PTR param2 );
*/
LPWSTR
DuplicateString ( LPCWSTR szString);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
extern  AppProtocolFactory  g_AppProtocolFactory; // ! not a pointer !


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// for AppProtocol.cxx



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\conexec\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	conexec.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\conexec\conexec.cpp ===
// conexec.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "process.h" // for CreateProcess? //for _spawnv //windows.h" // for CreateThread()
#include "mscoree.h"

#import <mscorlib.tlb> raw_interfaces_only high_property_prefixes("_get","_put","_putref")
using namespace ComRuntimeLibrary;
#import <asmexec.tlb>

// !! required !!
#include "Debug/asmexec.tlh"
using namespace asmexec ; //ComHost;

/*#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif*/

//#using <mscorlib.dll>

//{5F078073-5DCE-36EF-8A36-C03C30980216}
extern const GUID  __declspec(selectany) CLSID_AsmExecute = { 0x5f078073, 0x5dce, 0x36ef, { 0x8a, 0x36, 0xc0, 0x3c, 0x30, 0x98, 0x02, 0x16 } };

//{229C7FE0-4744-30C8-81F4-BB0541469CA9}
extern const GUID  __declspec(selectany) IID__AsmExecute = { 0x229c7fe0, 0x4744, 0x30c8, { 0x81, 0xf4, 0xbb, 0x05, 0x41, 0x46, 0x9c, 0xa9 } };

//class _AsmExecute;

HRESULT _hr;
_AsmExecute* _pAsmExecute;

bool init()
{
	bool ret = true;

	//
	// Initialize COM
	//
	_hr = ::CoInitialize(NULL);
    if(FAILED(_hr)) 
	{
		printf("COM CoInitialize failed...\n");
		ret = false;
		goto exit;
    }

	printf("COM CoInitialize succeed\n");

exit:
	return ret;
}

bool final()
{
	if(SUCCEEDED(_hr))
	{
		::CoUninitialize();
		printf("COM CoUninitialize called\n");
	}

	return true;
}

int main(int argc, char* argv[])
{
	int ret = -1;
	HRESULT hr;

	_hr = E_FAIL;
	_pAsmExecute = NULL;
	printf("CONsoleEXEC\n");
	if (argc < 3)
	{
		printf("syntax: Codebase [+]Flag [Zone] [uniqueId Site]\n    + - spawn a new process\n    default - execute in this process\n");
		goto exit;
	}
	else
	{
		for (int i = 1; i < argc; i++)
		{
			switch(i)
			{
			case 1:
				printf("  Codebase- %s", argv[i]);
				break;
			case 2:
				printf("  Flag- %s", argv[i]);
				break;
			case 3:
				printf("  Zone- %s", argv[i]);
				break;
			case 4:
				printf("  uniqueId- %s", argv[i]);
				break;
			case 5:
				printf("  Site- %s", argv[i]);
				break;
			default:
				break;
			}
		}
		printf("\n");
	}

	if (!init())
	{
		goto exit;
	}

	if (*argv[2] == '+')
	{
		// spawn a new process
//		printf("Spawnv...\n" );
		printf("CreateProcess...\n");

/*		// a hack to remove the flag in the spawn process... BUGBUG? use sprintf and _spawnl?
		*argv[2] = ' ';
passing the original argv does not work if it originally contains a quoted path, eg. "c:\program files\a.exe"

background: argv[0] is the path to the running program itself
note:  if you type> prog "ar g1" arg2
this becomes argv[0] = "prog", argv[1] = "ar g1", arg2 = "arg2"
if you type> "De ug\prog" "ar g1"
this becomes argv[0] = "De ug\prog", argv[1] = "ar g1"
however, spawn will only take non-quoted path (even if there are spaces in it) for the program path
but the spawned conexec choks on the space inside argv[0] (program path) and instead for it
this becomes argv[0] = "De", argv[1] = " ug\prog", argv[2] = "ar g1" - and thus crashes badly
Therefore, keep the original argv[0] for spawn program path, but add quotes when pass as arguments*/

/*		char buf0[1025];
		char* ptr;
		char buf1[1025];
		char buf2[1025];
		// _spawn limits to 1024+'\0' for total of argv
		_snprintf(buf0, 1025, "\"%s\"", argv[0]);
		_snprintf(buf1, 1025, "\"%s\"", argv[1]);
		_snprintf(buf2, 1025, "%s", argv[2]+1);
		// error checking?

		// BUGBUG? free?
		ptr = argv[0];
		argv[0] = buf0;
		argv[1] = buf1;
		argv[2] = buf2;

		// _P_OVERLAY? _P_WAIT?
		if (_spawnv(_P_NOWAIT, ptr, argv) == -1)
		{
			printf("Spawnv failed. errno = %x\n", errno);
			goto exit;
		}

		// how to start in a new console??

		printf("Spawnv succeed. This process will terminate\n" );
		ret = 0;
		goto exit;*/

		STARTUPINFO si;
		PROCESS_INFORMATION pi;

		ZeroMemory( &si, sizeof(si) );
		si.cb = sizeof(si);
		ZeroMemory( &pi, sizeof(pi) );

//		char szAppName[1025];
		char szCmdLine[1025];
		int len = 0;

/*		if ((len = _snprintf(szAppName, 1025, "\"%s\"", argv[0])) <= 0)
		{
			printf("Application name too long > 1024\n");
			goto exit;
		}

		strcpy(szCmdLine, szAppName);

		printf("\n\n%d\n", len);
		szCmdLine[len] = ' ';
		szCmdLine[len+1] = '0';
		szCmdLine[len+2] = '\0';*/
		for (int i = 0; i < argc; i++)
		{
			// a small hack: "conexec.exe" "asm.exe"  0<-- 2 spaces before "0"
			// for this for-loop to work w/o another condition for i=0
			if ((len += _snprintf(szCmdLine+len,
								1025-len,
								(i <= 1 ? "\"%s\" " : " %s"),
								(i == 2 ? argv[i] + 1 : argv[i]))) >= 1025)
			{
				printf("Command line too long > 1024\n");
				goto exit;
			}
		}


		// Start the child process. 
		if( !CreateProcess( NULL,             // Use command line instead to avoid ambigous naming and allow the use of quotes.//szAppName, //argv[0],          // Myself. This CANNOT have quotes
							szCmdLine,        // Command line. 
							NULL,             // Process handle not inheritable. security??
							NULL,             // Thread handle not inheritable. security??
							FALSE,            // Set handle inheritance to FALSE. 
							CREATE_NEW_CONSOLE, //DETACHED_PROCESS, // No access to current console. 
							NULL,             // Use parent's environment block. 
							NULL,             // Use parent's starting directory. ??
							&si,              // Pointer to STARTUPINFO structure.
							&pi )             // Pointer to PROCESS_INFORMATION structure.
						) 
		{
			printf("CreateProcess failed. Error code = %x\n", GetLastError());
			goto exit;
		}

		// Wait until child process exits.
//		WaitForSingleObject( pi.hProcess, INFINITE );

		// Close process and thread handles. 
		CloseHandle( pi.hProcess );
		CloseHandle( pi.hThread );

		printf("CreateProcess succeed. This process will terminate\n" );
		ret = 0;
		goto exit;
	}

	// return data...?

    hr = CoCreateInstance(CLSID_AsmExecute, NULL,CLSCTX_INPROC_SERVER,IID__AsmExecute,(void**)&_pAsmExecute);
	
	if (FAILED(hr))
	{
		printf("AsmExecute CoCreateInstance failed...\n");
		goto exit;
	}

	printf("AsmExecute CoCreateInstance succeed.\n");

	printf("Calling AsmExecute.Execute()...\n");
	try
	{
		if (argc == 3)
		{
			// use _bstr_t?
			hr = _pAsmExecute->Execute(argv[1], argv[2]);
		}
		else if (argc == 4)
		{
			hr = _pAsmExecute->Execute_2(argv[1], argv[2], argv[3]);
		}
		else if (argc == 6) //BUGBUG > args?
		{
			hr = _pAsmExecute->Execute_3(argv[1], argv[2], argv[3], argv[4], argv[5]);
		}
	}
	catch (_com_error &e)
	{
		// _com_issue_errorex throws _com_error
		printf("... AsmExecute Execute failed; Code = %08lx\n", e.Error());
		printf(" Code meaning = %s\n", (char*) e.ErrorMessage());
		printf(" Source = %s\n", (char*) e.Source());
		printf(" Description = %s\n", (char*) e.Description());

		goto exit;
	}

	if (FAILED(hr))
	{
		// !! should never be here !!
		printf("... AsmExecute Execute failed; hr = %x\n", hr);
		goto exit;
	}

	printf("... AsmExecute Execute succeed.\n");
	ret = 0;
exit:
	if (_pAsmExecute != NULL)
	{
		_pAsmExecute->Release();
		_pAsmExecute = NULL;
	}
	// BUGBUG: relesase domains?

	final();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\conexec\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7F6F233F_D1F8_44BF_BEA3_086D29EEED44__INCLUDED_)
#define AFX_STDAFX_H__7F6F233F_D1F8_44BF_BEA3_086D29EEED44__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7F6F233F_D1F8_44BF_BEA3_086D29EEED44__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\dll\dllmain.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "dll.h"
#include "util.h"
#include <shlwapi.h>
#include <stdio.h> // for _snwprintf

HINSTANCE	g_DllInstance = NULL;
LONG		g_cRef = 0;

HANDLE		g_hHeap = INVALID_HANDLE_VALUE;

//----------------------------------------------------------------------------
BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved )
{
    BOOL    ret = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // remember the instance
        g_DllInstance = hInst;
        DisableThreadLibraryCalls(hInst);

        if (g_hHeap == INVALID_HANDLE_VALUE)
		{
			g_hHeap = GetProcessHeap();
			if (g_hHeap == NULL)
			{
				g_hHeap = INVALID_HANDLE_VALUE;
				ret = FALSE;
				goto exit;
			}
		}

		break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

exit:
    return ret;
}

//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
   return TRUE;
}


STDAPI DllUnregisterServer(void)
{
    return TRUE;
}


// ----------------------------------------------------------------------------
// DllAddRef
// ----------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// ----------------------------------------------------------------------------
// DllRelease
// ----------------------------------------------------------------------------
ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

HRESULT
RunCommand(LPWSTR wzCmdLine, LPCWSTR wzCurrentDir, BOOL fWait)
{
    HRESULT hr = S_OK;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    si.cb = sizeof(si);

    // wzCurrentDir: The string must be a full path and file name that includes a drive letter; or NULL
    if(!CreateProcess(NULL, wzCmdLine, NULL, NULL, TRUE, 0, NULL, wzCurrentDir, &si, &pi))
    {
        hr = GetLastWin32Error();
        goto exit;
    }

	if (fWait)
	{
	    if(WaitForSingleObject(pi.hProcess, 180000L) == WAIT_TIMEOUT)
	    {
	        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
	        goto exit;
	    }
	}

exit:
    if(pi.hProcess) CloseHandle(pi.hProcess);
    if(pi.hThread) CloseHandle(pi.hThread);

    return hr;
}

#define ToHex(val) val <= 9 ? val + '0': val - 10 + 'A'
DWORD ConvertToHex(WCHAR* strForm, BYTE* byteForm, DWORD dwSize)
{
    DWORD i = 0;
    DWORD j = 0;
    for(i = 0; i < dwSize; i++) {
        strForm[j++] =  ToHex((0xf & byteForm[i]));
        strForm[j++] =  ToHex((0xf & (byteForm[i] >> 4)));
    }
    strForm[j] = L'\0';
    return j;
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

// note: this is not really a WCHAR/Unicode/UTF implementation!
void
ParseRef(char* szRef, APPNAME* pAppName, LPWSTR wzCodebase)
{
    char    *token;
    char    seps[] = " </>=\"\t\n\r";
    BOOL	fSkipNextToken = FALSE;

    // parsing code - limitation: does not work w/ space in field, even if enclosed w/ quotes
    // szRef will be modified!
    token = strtok( szRef, seps );
    while( token != NULL )
    {
       // While there are tokens
		if (!_stricmp(token, "displayname"))
		{
	        for (int i = 0; i < DISPLAYNAMESTRINGLENGTH; i++)
            {
                if (*(token+13+i) == '\"')
                {
                    // BUGBUG: 13 == strlen("displayname="")
                    *(token+13+i) = '\0';
                    _snwprintf(pAppName->_wzDisplayName, i+1, L"%S", token+13);

                    // BUGBUG? a hack
                    token = strtok( token+i+14, seps);

					fSkipNextToken = TRUE;
                    break;
                }
	        }
		}
		else if (!_stricmp(token, "name"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAppName->_wzName, NAMESTRINGLENGTH, L"%S", token);
		}
		else if (!_stricmp(token, "version"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAppName->_wzVersion, VERSIONSTRINGLENGTH, L"%S", token);
		}
		else if (!_stricmp(token, "culture"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAppName->_wzCulture, CULTURESTRINGLENGTH, L"%S", token);
		}
		else if (!_stricmp(token, "publickeytoken"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAppName->_wzPKT, PKTSTRINGLENGTH, L"%S", token);
		}
		else if (!_stricmp(token, "codebase"))
		{
	        for (int i = 0; i < MAX_URL_LENGTH; i++)
            {
                if (*(token+10+i) == '\"')
                {
                    // BUGBUG: 10 == strlen("codebase="")
                    *(token+10+i) = '\0';
                    _snwprintf(wzCodebase, i+1, L"%S", token+10);

                    // BUGBUG? a hack
                    token = strtok( token+i+11, seps);
                    // now  token == "newhref" && *(token-1) == '/'

					fSkipNextToken = TRUE;                    
                    break;
                }
            }
            // BUGBUG: ignoring > MAX_URL_LENGTH case here... may mess up later if the URL contain a "keyword"
       }
       //else
       // ignore others for now

    // Get next token...
	if (!fSkipNextToken)
	   token = strtok( NULL, seps );
	else
		fSkipNextToken = FALSE;

    }

}

// ----------------------------------------------------------------------------

// note: this is not really a WCHAR/Unicode/UTF implementation!
void
ParseManifest(char* szManifest, APPINFO* pAppInfo)
{
    char    *token;
    char    seps[] = " </>=\"\t\n\r";
    FILEINFOLIST* pCurrent = NULL;

    BOOL    fSkipNextToken = FALSE;

    // parsing code - limitation: does not work w/ space in field, even if enclosed w/ quotes
    // szManifest will be modified!
    token = strtok( szManifest, seps );
    while( token != NULL )
    {
       // While there are tokens
       if (!_stricmp(token, "file"))
       {
            // get around in spaced tag
            token = strtok( NULL, seps );
            if (!_stricmp(token, "name"))
            {
                // init
                if (pCurrent == NULL)
                {
                    pAppInfo->_pFileList = new FILEINFOLIST;
                    pCurrent = pAppInfo->_pFileList;
                }
                else
                {
                    pCurrent->_pNext = new FILEINFOLIST;
                    pCurrent = pCurrent->_pNext;
                }

                pCurrent->_pNext = NULL;
                pCurrent->_wzFilename[0] = L'\0';
                pCurrent->_wzHash[0] = L'\0';
                pCurrent->_fOnDemand = FALSE;
                pCurrent->_fState = FI_GET_AS_NORMAL;

		        for (int i = 0; i < MAX_PATH; i++)
	            {
	                if (*(token+6+i) == '\"')
	                {
	                    // BUGBUG: 6 == strlen("name="")
	                    *(token+6+i) = '\0';
		                _snwprintf(pCurrent->_wzFilename, i+1, L"%S", token+6); // worry about total path len later

	                    // BUGBUG? a hack
	                    token = strtok( token+i+7, seps);

						fSkipNextToken = TRUE;
	                    break;
	                }
	            }

				if (fSkipNextToken == FALSE)
				{
					// this should not happen... but as a fail safe
					// note: the code *will fail* later on anyway because there is no filename
					token = strtok( NULL, seps );
	                fSkipNextToken = TRUE;
				}

                if (!_stricmp(token, "hash"))
                {
                	token = strtok( NULL, seps );
                    _snwprintf(pCurrent->_wzHash, 33, L"%S", token);

	                fSkipNextToken = FALSE;
                }

                if (fSkipNextToken == FALSE)
               	{
       		     		token = strtok( NULL, seps );
						fSkipNextToken = TRUE;
               	}
                if (!_stricmp(token, "ondemand"))
               	{
            	   		token = strtok( NULL, seps );
            	   		if (!_stricmp(token, "true"))
			                pCurrent->_fOnDemand = TRUE;
						// default is FALSE
            	   			
	                	fSkipNextToken = FALSE;
                }
            }
       }
		else if (!_stricmp(token, "type"))
		{
			token = strtok( NULL, seps );
			if (!_stricmp(token, ".NetAssembly"))
				pAppInfo->_fAppType = APPTYPE_NETASSEMBLY;
			else if (!_stricmp(token, "Win32Executable"))
				pAppInfo->_fAppType = APPTYPE_WIN32EXE;
		}
		else if (!_stricmp(token, "entrypoint"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAppInfo->_wzEntryFileName, MAX_PATH, L"%S", token);
		}
		else if (!_stricmp(token, "codebase"))
		{
	        for (int i = 0; i < MAX_URL_LENGTH; i++)
            {
                if (*(token+10+i) == '\"')//'<')
                {
                    // BUGBUG: 10 == strlen("codebase="")
                    *(token+10+i) = '\0';
                    _snwprintf(pAppInfo->_wzCodebase, i+1, L"%S", token+10);

                    // BUGBUG? a hack
                    token = strtok( token+i+11, seps);
                    // now  token == "newhref" && *(token-1) == '/'

					fSkipNextToken = TRUE;
                    break;
                }
            }
            // BUGBUG: ignoring > MAX_URL_LENGTH case here... may mess up later if the URL contain a "keyword"
       }
       //else
       // ignore others for now

    // Get next token...
    if(!fSkipNextToken)
        token = strtok( NULL, seps );
    else
        fSkipNextToken = FALSE;
    }
}

// ----------------------------------------------------------------------------

// Note: this is not really a WCHAR/Unicode/UTF implementation!
// Note: 1. remember to do HeapFree on the the ptr *szData!
//      2. *szData must be initialized to NULL else this func will attempt to free it 1st
HRESULT
ReadManifest(LPCWSTR wzFilePath, char** ppszData)
{
	HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwLength;
    DWORD dwFileSize;

	// BUGBUG? should it be freed? or do HeapValidate()?
    if (*ppszData)
    {
		if (HeapFree(g_hHeap, 0, *ppszData) == 0)
		{
			hr = GetLastWin32Error();
			goto exit;
    	}
    }

	hFile = CreateFile(wzFilePath, GENERIC_READ, 0, NULL, 
                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    // BUGBUG: this won't work properly if the file is too large
    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

	// allocate memory
	*ppszData = (char*) HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwFileSize);
	if (*ppszData == NULL)
	{
		hr = E_FAIL;
		goto exit;
	}

	// read the file in a whole
	if (ReadFile(hFile, *ppszData, dwFileSize, &dwLength, NULL) == 0)
	{
		hr = GetLastWin32Error();
    	goto exit;
	}

	if (dwLength != dwFileSize)
	{
		hr = E_FAIL;
		goto exit;
	}

    //*((*ppszData) + dwLength) = '\0';  memory was zero-ed out when allocated

exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	
	return hr;
}

// ----------------------------------------------------------------------------

STDAPI 
ProcessRef(LPCWSTR wzRefLocalFilePath, APPNAME* pAppName, LPWSTR wzCodebase)
{
	HRESULT hr = S_OK;
	char* psz = NULL;

	if (FAILED(hr=ReadManifest(wzRefLocalFilePath, &psz)))
		goto exit;

	ParseRef(psz, pAppName, wzCodebase);

exit:
    if (psz)
    {
		if (HeapFree(g_hHeap, 0, psz) == 0)
		{
			hr = GetLastWin32Error();
    	}
    }

	return hr;
}

// ----------------------------------------------------------------------------

void
CompareManifest(APPINFO* aiOld, APPINFO* aiNew)
{
	// shortcut: compare hash instead
	// note: n^2 cmp loop * n hash cmp - however, assuming the lists are in alphabetical order, then this will be more efficient

	FILEINFOLIST* pFIOld=aiOld->_pFileList;
	FILEINFOLIST* pFINew=aiNew->_pFileList;

	while (pFINew != NULL)
	{
		while (pFIOld != NULL)
		{
			if (!wcscmp(pFIOld->_wzHash, pFINew->_wzHash))
			{
				if (!wcscmp(pFIOld->_wzFilename, pFINew->_wzFilename))
				{
					pFIOld->_fState = FI_COPY_TO_NEW;
					pFINew->_fState = FI_COPY_FROM_OLD;
					break;
				}
			}

			pFIOld = pFIOld->_pNext;
		}

		pFIOld=aiOld->_pFileList;
		pFINew = pFINew->_pNext;
	}
}

// ----------------------------------------------------------------------------

// func declaration
HRESULT SearchForNewestVersionExcept(APPNAME* pAppName);

STDAPI
ProcessAppManifest(LPCWSTR wzManifestLocalFilePath, LPAPPLICATIONFILESOURCE pAppFileSrc, APPNAME* pAppName)
{
    HRESULT   hr   = S_OK;
    BOOL fCoInitialized = FALSE;
	IInternetSecurityManager*	pSecurityMgr = NULL;

    char    *szManifest = NULL;

    APPINFO aiApplication;
    FILEINFOLIST* pFI=NULL;
    WCHAR wzLocalFilePath[MAX_PATH];
    WCHAR* pwzFilename = NULL;
    BOOL fAlreadyInstalled = TRUE;

    LPAPPLICATIONFILESOURCE pAppFileSrc2 = NULL;
    APPINFO aiApplication2;

    aiApplication._wzCodebase[0] = L'\0';
    aiApplication._wzEntryFileName[0] = L'\0';
    aiApplication._fAppType = APPTYPE_UNDEF;
    aiApplication._pFileList = NULL;

    aiApplication2._wzCodebase[0] = L'\0';
    aiApplication2._wzEntryFileName[0] = L'\0';
    aiApplication2._fAppType = APPTYPE_UNDEF;
    aiApplication2._pFileList = NULL;

	// copy and avoid buffer overflows
    wcsncpy(wzLocalFilePath, wzManifestLocalFilePath, MAX_PATH-1);
    wzLocalFilePath[MAX_PATH-1] = L'\0';

	pwzFilename = PathFindFileName(wzLocalFilePath);
	if (pwzFilename <= wzLocalFilePath)
	{
		hr = E_FAIL;
		goto exit;
	}

    // step 1: read the .manifest
	if (FAILED(hr=ReadManifest(wzLocalFilePath, &szManifest)))
		goto exit;
    
    // step 2: parsing
    ParseManifest(szManifest, &aiApplication);

    // step 3: do "the works"

	// quick check - optimization
	// assume application is "atomic" and if one file in the app is present the whole app is
	// note this does not guarantee no file is corrupted on local disk, etc.
	*pwzFilename = L'\0';
	PathAppend(wzLocalFilePath, (aiApplication._pFileList)->_wzFilename);	// BUGBUG: file list != NULL
	if (!PathFileExists(wzLocalFilePath))
		fAlreadyInstalled = FALSE;

	// get the max cached version on disk
    hr = SearchForNewestVersionExcept(pAppName);	// this returns newest ref that is != version in arg, if found
    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
    	// case 1 no other cached copy found
		if (!fAlreadyInstalled)    	
		{
			// this is a 1st time installation...
			WCHAR wzMsg[90+DISPLAYNAMESTRINGLENGTH+NAMESTRINGLENGTH];

            _snwprintf(wzMsg, 90+DISPLAYNAMESTRINGLENGTH+NAMESTRINGLENGTH,
            	L"New application- %s (%s).\nDo you want to initialize this application and keep a copy on disk?",
            	pAppName->_wzDisplayName, pAppName->_wzName);

			// 1st time installation UI
			if (MsgAskYN(wzMsg) == IDNO)
			{
				// BUGBUG: this leave the shortcut and the manifest file lying around...

				hr = E_ABORT;
				goto exit;
			}
		}
    }
    else if (FAILED(hr))
    	goto exit;
    else if (hr == S_OK)
    {
    	// case 2 found a newer cached copy
    	// change the ref to run the newer
    	// notify via UI

    	// BUGBUG? ignore for now! assume source (ie. the same PKT) have newer/newest ref only!
    	// is it possible to have same PKT but older ref (ie. different site)?

		// read the ref file from disk then the manifest etc... - ie. ref file must be cached?
    }
    else
	{
    	// else case 3 not found a newer cached copy (but at least one older copy)
		if (!fAlreadyInstalled)
		{
			// this is an update...
			WCHAR wzMsg[60+DISPLAYNAMESTRINGLENGTH];

			_snwprintf(wzMsg, 60+DISPLAYNAMESTRINGLENGTH,
				L"An update for %s is available,\ndo you want to apply that now?",
				pAppName->_wzDisplayName);

			// update UI
			if (MsgAskYN(wzMsg) == IDNO)
			{
				WCHAR wzAppDir[MAX_PATH];
				
				// change the ref to run older
				// BUGBUG: switching codebase, codebase must be in manifest file
				// security issue?
				MsgShow(L"Starting the copy from disk...");

				// read the manifest file from disk etc...
				pwzFilename = PathFindFileName(wzManifestLocalFilePath);
				if (pwzFilename == wzManifestLocalFilePath)
				{
					hr = E_FAIL;
					goto exit;
				}

				if (FAILED(hr=GetDefaultLocalRoot(wzLocalFilePath)))
					goto exit;

				if (FAILED(hr=GetAppDir(pAppName, wzAppDir)))
					goto exit;

				if (!PathAppend(wzLocalFilePath, wzAppDir))
				{
					hr = E_FAIL;
					goto exit;
				}


				if (!PathAppend(wzLocalFilePath, pwzFilename))
				{
					hr = E_FAIL;
					goto exit;
				}

				pwzFilename = PathFindFileName(wzLocalFilePath);

				if (FAILED(hr=ReadManifest(wzLocalFilePath, &szManifest)))
					goto exit;

			    aiApplication._wzCodebase[0] = L'\0';
			    aiApplication._wzEntryFileName[0] = L'\0';
			    aiApplication._fAppType = APPTYPE_UNDEF;

		    	pFI = aiApplication._pFileList;
				while(pFI != NULL)
				{
					FILEINFOLIST* p = pFI->_pNext;
					delete pFI;
					pFI = p;
				}
		    	aiApplication._pFileList = NULL;

				ParseManifest(szManifest, &aiApplication);

				if (FAILED(hr = pAppFileSrc->SetSourcePath(aiApplication._wzCodebase)))
					goto exit;

				// quick check
				*pwzFilename = L'\0';
				PathAppend(wzLocalFilePath, (aiApplication._pFileList)->_wzFilename);	// BUGBUG: file list != NULL
				if (!PathFileExists(wzLocalFilePath))
				{
					hr = E_UNEXPECTED;
					goto exit;
				}
			}
			else
			{
		    	// use files from old cached, copy if possible
			    WCHAR wzLocalFilePath2[MAX_PATH];
		    	WCHAR wzAppDir[MAX_PATH];
			    WCHAR* pwzFilename2=NULL;

				// note: this is needed only to create file source object of the same type
			    if (FAILED(hr = pAppFileSrc->CreateNew(&pAppFileSrc2)))
				    	goto exit;

				pwzFilename2 = PathFindFileName(wzManifestLocalFilePath);
				if (pwzFilename2 == wzManifestLocalFilePath)
				{
					hr = E_FAIL;
					goto exit;
				}

				if (FAILED(hr=GetDefaultLocalRoot(wzLocalFilePath2)))
					goto exit;

				if (FAILED(hr=GetAppDir(pAppName, wzAppDir)))
					goto exit;

				if (!PathAppend(wzLocalFilePath2, wzAppDir))
				{
					hr = E_FAIL;
					goto exit;
				}

				if (!PathAppend(wzLocalFilePath2, pwzFilename2))
				{
					hr = E_FAIL;
					goto exit;
				}

				pwzFilename2 = PathFindFileName(wzLocalFilePath2);

				if (FAILED(hr=ReadManifest(wzLocalFilePath2, &szManifest)))
					goto exit;

				ParseManifest(szManifest, &aiApplication2);

				if (FAILED(hr = pAppFileSrc2->SetSourcePath(aiApplication2._wzCodebase)))
					goto exit;

				// quick check - optimization
				// assume application is "atomic" and if one file in the app is present the whole app is
				// note this does not guarantee no file is corrupted on local disk, etc.
				*pwzFilename2 = L'\0';
				PathAppend(wzLocalFilePath2, (aiApplication2._pFileList)->_wzFilename);	// BUGBUG: file list != NULL
				if (PathFileExists(wzLocalFilePath2))
				{
					// there is an update, (and old version of the app files are present) compare file list
					CompareManifest(&aiApplication2, &aiApplication);

					// copy files from old version
				    pFI = aiApplication2._pFileList;
				    while (pFI != NULL)
				    {
				    	// skip file if marked as on-demand
				    	// BUGBUG: this assumes files marked w/ ondemand do not change to w/o it in subsequent versions!
				    	if (pFI->_fOnDemand)
				    	{
				    		pFI = pFI->_pNext;
				    		continue;
				    	}

						if (pFI->_fState == FI_COPY_TO_NEW)
						{
							*pwzFilename2 = L'\0';
							PathAppend(wzLocalFilePath2, pFI->_wzFilename);	// src
							*pwzFilename = L'\0';
							PathAppend(wzLocalFilePath, pFI->_wzFilename);	// dest

							// note: unknown behaviour if source == destination
							// 1. check if the file exist, if so, check file integrity
							if (PathFileExists(wzLocalFilePath))
							{
								if (FAILED(hr = CheckIntegrity(wzLocalFilePath, pFI->_wzHash)))
									goto exit;
								if (hr == S_FALSE)
								{
									// hash mismatch/no hash, force overwrite
									hr = S_OK;
								}
								else
								{
									// else we are done, file already there and unchanged
									pFI = pFI->_pNext;
									continue;
								}
							}

							// 2. copy it over
							// check the path exist? create (sub)directories?
							*(pwzFilename-1) = L'\0';
							if (wcslen(wzLocalFilePath) > 3)
							{
								/* must be at least c:\a */
								hr =  CreatePathHierarchy(wzLocalFilePath);
							}
							// note: this few lines must follow the previous CreatePathHierarchy() line
							*(pwzFilename-1) = L'\\';
							if (FAILED(hr))
								goto exit;

							if (CopyFile(wzLocalFilePath2, wzLocalFilePath, FALSE) == 0)
							{
								hr = GetLastWin32Error();
								goto exit;
							}

							// should this copy the file by bytes and check hash the same time?

							// 3. check file integrity, assume ok if no hash
							if (pFI->_wzHash[0] != L'\0')
							{
								if (FAILED(hr = CheckIntegrity(wzLocalFilePath, pFI->_wzHash)))
									goto exit;
								if (hr == S_FALSE)
								{
									// hash mismatch - something very wrong
									// BUGBUG: this should force a download in the new set...
									hr = CRYPT_E_HASH_VALUE;
									goto exit;
								}
							}
						}

				        pFI = pFI->_pNext;
				     }
				}
			}
		}
	}

	// download and check all/remaining files, filesource should check if the file exist, if so,
	// check if hash match, get file only if necessary
	pFI = aiApplication._pFileList;
    while (pFI != NULL)
    {
    	// skip file if marked as on-demand
    	// or file should have been copied above
    	if (pFI->_fOnDemand || pFI->_fState == FI_COPY_FROM_OLD)
    	{
    		pFI = pFI->_pNext;
    		continue;
    	}

		*pwzFilename = L'\0';
		PathAppend(wzLocalFilePath, pFI->_wzFilename);
		if (FAILED(hr = pAppFileSrc->GetFile(pFI->_wzFilename, wzLocalFilePath, pFI->_wzHash)))
            goto exit;

        pFI = pFI->_pNext;
     }

    // step 4: execute
    if (aiApplication._wzEntryFileName[0] != L'\0' && aiApplication._fAppType == APPTYPE_NETASSEMBLY)
    {
        DWORD                   	dwZone;
        DWORD                   	dwSize = MAX_SIZE_SECURITY_ID;
        BYTE						byUniqueID[MAX_SIZE_SECURITY_ID];
        WCHAR						wzUniqueID[MAX_SIZE_SECURITY_ID * 2 + 1];
        WCHAR               	    wzCmdLine[1025];
        WCHAR						wzEntryFullPath[MAX_URL_LENGTH];

		if (FAILED(hr = pAppFileSrc->GetFullFilePath(aiApplication._wzEntryFileName, wzEntryFullPath)))
			goto exit;

    	//
		// Initialize COM
		//
	    if(FAILED(hr = ::CoInitialize(NULL))) 
			goto exit;

		fCoInitialized = TRUE;

        hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                            IID_IInternetSecurityManager, (void**)&pSecurityMgr);

        if (FAILED(hr))
        {
            pSecurityMgr = NULL;
            goto exit;
        }

        if (SUCCEEDED(hr = pSecurityMgr->MapUrlToZone(wzEntryFullPath, &dwZone, 0)))
        {
             if (FAILED(hr)
             || FAILED(hr = pSecurityMgr->GetSecurityId(wzEntryFullPath, byUniqueID, &dwSize, 0)))
                 goto exit;

             ConvertToHex(wzUniqueID, byUniqueID, dwSize);
        }
        else
        {
              goto exit;
        }

		*pwzFilename = L'\0';
		PathAppend(wzLocalFilePath, aiApplication._wzEntryFileName);
        if (_snwprintf(wzCmdLine, sizeof(wzCmdLine),
					L"conexec.exe \"%s\" 3 %d %s %s", wzLocalFilePath, dwZone, wzUniqueID, wzEntryFullPath) < 0)
        {
			hr = CO_E_PATHTOOLONG;
			goto exit;
		}

		// CreateProcess dislike having the filename in the path for the start directory
 		*pwzFilename = L'\0';
        if (FAILED(hr=RunCommand(wzCmdLine, wzLocalFilePath, FALSE)))
        	goto exit;

	}
    else if (aiApplication._wzEntryFileName[0] != L'\0' && aiApplication._fAppType == APPTYPE_WIN32EXE)
    {
        WCHAR wzCmdLine[1025];

		// BUGBUG: Win32 app has no sandboxing... use SAFER?

		*pwzFilename = L'\0';
		PathAppend(wzLocalFilePath, aiApplication._wzEntryFileName);
        if (_snwprintf(wzCmdLine, sizeof(wzCmdLine),
					L"%s", wzLocalFilePath) < 0)
        {
			hr = CO_E_PATHTOOLONG;
			goto exit;
		}

		// CreateProcess dislike having the filename in the path for the start directory
 		*pwzFilename = L'\0';
        if (FAILED(hr=RunCommand(wzCmdLine, wzLocalFilePath, FALSE)))
        	goto exit;
    }

exit:
	if (pSecurityMgr != NULL)
	{
		pSecurityMgr->Release();
        pSecurityMgr = NULL;
	}

	if (fCoInitialized)
		::CoUninitialize();

	if (pAppFileSrc2 != NULL)
		delete pAppFileSrc2;

	pFI = aiApplication._pFileList;
	while(pFI != NULL)
	{
		FILEINFOLIST* p = pFI->_pNext;
		delete pFI;
		pFI = p;
	}

	if (aiApplication2._pFileList != NULL)
	{
		pFI = aiApplication2._pFileList;
		while(pFI != NULL)
		{
			FILEINFOLIST* p = pFI->_pNext;
			delete pFI;
			pFI = p;
		}
	}

    if (szManifest)
    {
		if (HeapFree(g_hHeap, 0, szManifest) == 0)
		{
			hr = GetLastWin32Error();
    	}
    }

	return hr;
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

STDAPI
BeginHash(HASHCONTEXT *ctx)
{
    MD5Init(ctx);
    return S_OK;
}
        

STDAPI
ContinueHash(HASHCONTEXT *ctx, unsigned char *buf, unsigned len)
{
    MD5Update(ctx, buf, len);
    return S_OK;
}

STDAPI
EndHash(HASHCONTEXT *ctx, LPWSTR wzHash)
{
    unsigned char signature[HASHLENGTH/2];
    WCHAR* p;

    MD5Final(signature, ctx);

    // convert hash from byte array to hex
    p = wzHash;
	for (int i = 0; i < sizeof(signature); i++)
	{
	    // BUGBUG?: format string 0 does not work w/ X accord to MSDN?
        swprintf(p, L"%02X", signature[i]);
        p += 2;
	}

    return S_OK;
}

// Return: S_OK == hash match; S_FALSE == hash unmatch
STDAPI
CheckIntegrity(LPCWSTR wzFilePath, LPCWSTR wzHash)
{
	//assume not unicode file, use ReadFile()  then cast it as char[]
	HRESULT hr = S_OK;
	HANDLE hFile;
	DWORD dwLength;
	unsigned char ucBuffer[16384];
	HASHCONTEXT hc;
	WCHAR wzComputedHash[HASHSTRINGLENGTH];

	if (wzHash == NULL || wzHash[0] == L'\0')
	{
		hr = S_FALSE;
		goto exit;	//??? ie. to force redownload/copy
	}

	// 1. CreateFile
	hFile = CreateFile(wzFilePath, GENERIC_READ, 0, NULL, 
	               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if(hFile == INVALID_HANDLE_VALUE)
	{
		hr = GetLastWin32Error();
		goto exit;
	}

	// 2. BeginHash
	BeginHash(&hc);

	ZeroMemory(ucBuffer, sizeof(ucBuffer));

	// 3.  ReadFile
	while ( ReadFile (hFile, ucBuffer, sizeof(ucBuffer), &dwLength, NULL) && dwLength )
	{
		// 4. ContinueHash
	    ContinueHash(&hc, ucBuffer, (unsigned) dwLength);
	}
    CloseHandle(hFile);

	// note: the next few lines should follow the previous ReadFile()
	if (dwLength != 0)
    {
    	hr = GetLastWin32Error();
    	goto exit;
    }

	// 5. EndHash
	EndHash(&hc, wzComputedHash);

	if (wcscmp(wzHash, wzComputedHash) != 0)
		hr = S_FALSE;
	else
		hr = S_OK;

exit:
	return hr;
}

// ----------------------------------------------------------------------------

// Copied from Fusion.URT...
// modified - use WCHAR + LastWin32Error + take a path w/o the filename or a ending backslash
// ---------------------------------------------------------------------------
// CreatePathHierarchy
// ---------------------------------------------------------------------------
STDAPI 
CreatePathHierarchy( LPCWSTR pwzName )
{
    HRESULT hr=S_OK;
    LPWSTR pwzFileName;
    WCHAR wzPath[MAX_PATH];

	// note: after this rearrange of code, this lack a check on the path before doing I/O...
    DWORD dw = GetFileAttributes( pwzName );
    if ( dw != (DWORD) -1 )
        return S_OK;
    
    hr = GetLastWin32Error();

    switch (hr)
    {
        case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
            {
				    wcscpy(wzPath, pwzName);

				    pwzFileName = PathFindFileName ( wzPath );

				    if ( pwzFileName <= wzPath )
				        return E_INVALIDARG; // Send some error 

				    *(pwzFileName-1) = 0;

					hr =  CreatePathHierarchy(wzPath);
					if (hr != S_OK)
						return hr;
            }

		 // falls thru...
        case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
            {
					if ( CreateDirectory( pwzName, NULL ) )
						return S_OK;
					else
					{
						hr = GetLastWin32Error();
						return hr;
					}
            }

        default:
            return hr;
    }
}

// ----------------------------------------------------------------------------

STDAPI
GetDefaultLocalRoot(LPWSTR wzPath)
{
	// wzPath should be of length MAX_PATH
	HRESULT hr = S_OK;

	if(GetEnvironmentVariable(L"ProgramFiles", wzPath, MAX_PATH-lstrlen(LOCALROOTNAME)-1) == 0)  //????????
	{
		hr = CO_E_PATHTOOLONG;
		goto exit;
	}

	if (!PathAppend(wzPath, LOCALROOTNAME))
	{
		hr = E_FAIL;
		//goto exit;
	}

exit:
	return hr;
}

// ----------------------------------------------------------------------------

STDAPI
GetAppDir(APPNAME* pAppName, LPWSTR wzPath)
{
	// wzPath should be of length MAX_PATH
	HRESULT hr = S_OK;

    if (_snwprintf(wzPath, MAX_PATH, L"%s\\%s\\%s\\%s",
    	pAppName->_wzPKT, pAppName->_wzName, pAppName->_wzVersion, pAppName->_wzCulture) < 0)
    {
    	hr = CO_E_PATHTOOLONG;
    }

    return hr;
}

// ----------------------------------------------------------------------------

HRESULT
GetAppVersionSearchPath(APPNAME* pAppName, LPWSTR wzPath)
{
	// wzPath should be of length MAX_PATH
	HRESULT hr = S_OK;
	WCHAR wzAppDir[MAX_PATH];

	if (FAILED(hr=GetDefaultLocalRoot(wzPath)))
		goto exit;

	// ???? see how the app root is build and if this has changed...
    if (_snwprintf(wzAppDir, MAX_PATH, L"%s\\%s\\*",
    	pAppName->_wzPKT, pAppName->_wzName) < 0)
    {
    	hr = CO_E_PATHTOOLONG;
    	goto exit;
    }

	if (!PathAppend(wzPath, wzAppDir))
	{
		hr = E_FAIL;
		//goto exit;
	}

exit:
	return hr;
}

// ----------------------------------------------------------------------------

int
CompareVersion(LPCWSTR pwzVersion1, LPCWSTR pwzVersion2)
{
	// BUGBUG: this should compare version by its major minor build revision!
	return wcscmp(pwzVersion1, pwzVersion2);
}

// ----------------------------------------------------------------------------

// S_OK for found newer, S_FALSE for found older, HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) for no other found
// returns newest ref that is != version in arg, if found
// BUGBUG: does not check culture etc if they are the same
HRESULT
SearchForNewestVersionExcept(APPNAME* pAppName) // in, out
{
	HRESULT hr = S_OK;
	WCHAR wzAppSearchPath[MAX_PATH];
	WCHAR wzNewestVersionString[VERSIONSTRINGLENGTH];
	HANDLE hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA fdAppDir;
	DWORD dwLastError = 0;
	BOOL fFoundAtLeastTwo = FALSE;
	BOOL fSkip = FALSE;

	// this has trailing "\*"
	if (FAILED(hr = GetAppVersionSearchPath(pAppName, wzAppSearchPath)))
		goto exit;

	hFind = FindFirstFileEx(wzAppSearchPath, FindExInfoStandard, &fdAppDir, FindExSearchLimitToDirectories, NULL, 0);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = GetLastWin32Error();
		goto exit;
	}

	// since the app dir is build before this check it ensures FindFirstFile be ok - there's at least one
	wcscpy(wzNewestVersionString, L"0.0.0.0");

	while (dwLastError != ERROR_NO_MORE_FILES)
	{
		// ignore "." and ".."
		if (wcscmp(fdAppDir.cFileName, L".") == 0 || wcscmp(fdAppDir.cFileName, L"..") == 0)
			fSkip = TRUE;
		else
		{
			// ???? check file attribute to see if it's a directory? needed only if the file system does not support the filter...
			// ???? check version string format?
			if (CompareVersion(fdAppDir.cFileName, pAppName->_wzVersion) != 0)
				if (CompareVersion(fdAppDir.cFileName, wzNewestVersionString) > 0)
				{
					wcscpy(wzNewestVersionString, fdAppDir.cFileName);
				}
				// else keep the newest
		}

		if (!FindNextFile(hFind, &fdAppDir))
		{
			dwLastError = GetLastError();
			continue;
		}

		if (!fSkip)
			fFoundAtLeastTwo = TRUE;
		else
			fSkip = FALSE;
	}

exit:
	if (hFind != INVALID_HANDLE_VALUE)
	{
		if (!FindClose(hFind))
		{
			hr = GetLastWin32Error();
		}
	}

	if (SUCCEEDED(hr))
	{
		if (fFoundAtLeastTwo)
		{
			if (CompareVersion(wzNewestVersionString, pAppName->_wzVersion) > 0)
				hr = S_OK;
			else
				hr = S_FALSE;

			// modify the ref
			wcscpy(pAppName->_wzVersion, wzNewestVersionString);
		}
		else
			hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;
}

// ----------------------------------------------------------------------------

STDAPI
CopyToStartMenu(LPCWSTR pwzFilePath, LPCWSTR pwzRealFilename, BOOL bOverwrite)
{
	HRESULT hr = S_OK;
	WCHAR wzPath[MAX_PATH];

	if(GetEnvironmentVariable(L"USERPROFILE", wzPath, MAX_PATH-1) == 0)
	{
		hr = CO_E_PATHTOOLONG;
		goto exit;
	}

	if (!PathAppend(wzPath, L"Start Menu\\Programs\\"))
	{
		hr = E_FAIL;
		goto exit;
	}

	if (!PathAppend(wzPath, pwzRealFilename))
	{
		hr = E_FAIL;
		goto exit;
	}

	if (CopyFile(pwzFilePath, wzPath, !bOverwrite) == 0)
	{
		hr = GetLastWin32Error();
		//goto exit;
	}

exit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\inc\afilter.h ===
#pragma once
#ifndef _APPFILTER_DLL_H
#define _APPFILTER_DLL_H

#include <objbase.h>
#include <windows.h>

#include <wininet.h>

#include "dll.h" // for MAX_URL_LENGTH

#define CONTENT_TYPE L"text/html"

// Clases and interfaces
class CAppMimeFilterClassFactory : public IClassFactory
{
public:
	CAppMimeFilterClassFactory		();
	
    // IUnknown Methods
    STDMETHOD_    (ULONG, AddRef)	();
    STDMETHOD_    (ULONG, Release)	();
    STDMETHOD     (QueryInterface)	(REFIID, void **);

    // IClassFactory Moethods
    STDMETHOD     (LockServer)		(BOOL);
    STDMETHOD     (CreateInstance)	(IUnknown*,REFIID,void**);

protected:
	long			_cRef;
};

class CAppMimeFilter : public IInternetProtocol, public IInternetProtocolSink
{
public:
    CAppMimeFilter		();
    ~CAppMimeFilter		();

    // IUnknown methods
    STDMETHOD_        (ULONG, AddRef)			();
    STDMETHOD_        (ULONG, Release)			();
    STDMETHOD         (QueryInterface)			(REFIID, void **);

    // InternetProtocol methods
    STDMETHOD         (Start)					(LPCWSTR, IInternetProtocolSink *, IInternetBindInfo *, DWORD, DWORD);
    STDMETHOD         (Continue)				(PROTOCOLDATA *pProtData);
    STDMETHOD         (Abort)					(HRESULT hrReason,DWORD );
    STDMETHOD         (Terminate)				(DWORD );
    STDMETHOD         (Suspend)					();
    STDMETHOD         (Resume)					();
    STDMETHOD         (Read)					(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD         (Seek)					(LARGE_INTEGER , DWORD , ULARGE_INTEGER *) ;
    STDMETHOD         (LockRequest)				(DWORD );
    STDMETHOD         (UnlockRequest)			();

	// IInternetProtocolSink methods
	STDMETHOD			(ReportData)			(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax);
	STDMETHOD			(ReportProgress)		(ULONG ulStatusCode, LPCWSTR szStatusText);
	STDMETHOD			(ReportResult)			(HRESULT hrResult, DWORD dwError, LPCWSTR szResult);
	STDMETHOD			(Switch)				(PROTOCOLDATA *pProtocolData);

protected:
	HRESULT				OpenTempFile();
	HRESULT				CloseTempFile();

	long				_cRef;
	BOOL				_fFirstRead;
	BOOL				_fReadDone;

	IInternetProtocolSink* _pOutgoingProtSink;
	IInternetProtocol*	_pIncomingProt;

	DWORD				_grfSTI;							// STI flags handed to us 

	WCHAR				_wzUrl[MAX_URL_LENGTH];				// The URL

	WCHAR				_wzTempFile[MAX_PATH];
	HANDLE				_hFile;
};

extern const GUID CLSID_AppMimeFilter;

#endif // _APPFILTER_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\inc\dll.h ===
#pragma once
#ifndef MANIFEST_DLL_H
#define MANIFEST_DLL_H

#include <objbase.h>
#include <windows.h>

#include "md5.h"
#define HASHCONTEXT MD5Context

#define DISPLAYNAMESTRINGLENGTH		26
#define NAMESTRINGLENGTH			26
#define VERSIONSTRINGLENGTH			16	// 10.10.1234.1234
#define CULTURESTRINGLENGTH			3	// en
#define PKTSTRINGLENGTH				17

#define HASHLENGTH					32
#define HASHSTRINGLENGTH			HASHLENGTH+1

#define MANIFESTFILEEXT			L".manifest"
#define SHORTCUTFILEEXT			L".app"

#define LOCALROOTNAME			L"Application Store"

#define MAX_URL_LENGTH			2084 // same as INTERNET_MAX_URL_LENGTH+1 from wininet.h

#define FI_GET_AS_NORMAL		0
#define FI_COPY_TO_NEW			1
#define FI_COPY_FROM_OLD		2

#define APPTYPE_UNDEF			0
#define APPTYPE_NETASSEMBLY		1	// .NetAssembly
#define APPTYPE_WIN32EXE		2	// Win32Executable

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Data structures

struct FILEINFOLIST
{
    WCHAR		_wzFilename[MAX_PATH];    		// can have \ but not ..\ ; no path, should be much shorter
    WCHAR		_wzHash[HASHSTRINGLENGTH];		// 32 + L'\0'

    FILEINFOLIST*   _pNext;

    BOOL		_fOnDemand;		// default is FALSE
    int			_fState;
};

struct APPINFO
{
    WCHAR			_wzEntryFileName[MAX_PATH];
    WCHAR			_wzCodebase[MAX_URL_LENGTH];
    int				_fAppType;

    FILEINFOLIST*	_pFileList;
};

struct APPNAME
{
	WCHAR			_wzDisplayName[DISPLAYNAMESTRINGLENGTH];
	WCHAR			_wzName[NAMESTRINGLENGTH];
	WCHAR			_wzVersion[VERSIONSTRINGLENGTH];
	WCHAR			_wzCulture[CULTURESTRINGLENGTH];
	WCHAR			_wzPKT[PKTSTRINGLENGTH];
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// "LocalPath" == a path to the cached/stored-locally copy of the file
// "LocalFilePath" == a path + filename
// "Filename" == just the filename, no path

typedef interface IApplicationFileSource *LPAPPLICATIONFILESOURCE;

interface IApplicationFileSource
{
public:
	virtual HRESULT CreateNew(
		/* [out] */ LPAPPLICATIONFILESOURCE* ppAppFileSrc) = 0;

	// returns HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if source file not found
	virtual HRESULT GetFile( 
		/* [in] */ LPCWSTR wzSourceFilename,
		/* [in] */ LPCWSTR wzDestinationLocalFilePath,
		/* [in] */ LPCWSTR wzHash) = 0;

	// get file from a different location - via CopyFile
	// unconditional get and overwrite existing, no hash checking
	virtual HRESULT GetFile( 
		/* [in] */ LPCWSTR wzSourceFilePath,
		/* [in] */ LPCWSTR wzDestinationLocalFilePath) = 0;

	virtual HRESULT SetSourcePath(
		/* [in] */ LPCWSTR wzSourceFilePath) = 0;

	// returning the local app root path with all directories created
	virtual HRESULT BuildLocalAppRootHierarchy(
		/* [in]  */ APPNAME* pAppName,
		/* [out] */ LPWSTR wzLocalAppRoot) = 0;

	// returning the source file path from a filename
	virtual HRESULT GetFullFilePath(
		/* [in]  */  LPCWSTR wzFilename,
		/* [out] */ LPWSTR wzFullFilePath) = 0;

};// this should know where the src is...

STDAPI ProcessRef(
		/* [in]  */ LPCWSTR wzRefLocalFilePath,
		/* [out] */ APPNAME* pAppName,
		/* [out] */ LPWSTR wzCodebase);

STDAPI ProcessAppManifest( 
		/* [in]  */ LPCWSTR wzManifestLocalFilePath,
		/* [in]  */ LPAPPLICATIONFILESOURCE pAppFileSrc,
		/* [inout]*/ APPNAME* pAppName);

STDAPI BeginHash(
		HASHCONTEXT *ctx);

STDAPI ContinueHash(
		HASHCONTEXT *ctx,
		unsigned char *buf,
		unsigned len);

STDAPI EndHash(
		HASHCONTEXT *ctx,
		/* [out] */LPWSTR wzHash);

STDAPI CheckIntegrity(LPCWSTR wzFilePath, LPCWSTR wzHash);	// S_OK == hash match; S_FALSE == hash unmatch

STDAPI CreatePathHierarchy(LPCWSTR pwzName);

STDAPI GetDefaultLocalRoot(/* [out] */LPWSTR wzPath);

STDAPI GetAppDir(APPNAME* pAppName, /* [out] */LPWSTR wzPath);

STDAPI CopyToStartMenu(LPCWSTR pwzFilePath, LPCWSTR pwzRealFilename, BOOL bOverwrite);

#endif // MANIFEST_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\filehost\manhost.cpp ===
#include <shlwapi.h>
#include "dll.h"
#include "util.h"

#include <wininet.h>

class CUNCFileSource : public IApplicationFileSource
{
public:
	CUNCFileSource();

	HRESULT CreateNew(
		/* [out] */ LPAPPLICATIONFILESOURCE* ppAppFileSrc);

	HRESULT GetFile( 
		/* [in] */ LPCWSTR wzSourceFilename,
		/* [in] */ LPCWSTR wzDestinationLocalFilePath,
		/* [in] */ LPCWSTR wzHash);

	HRESULT GetFile( 
		/* [in] */ LPCWSTR wzSourceFilePath,
		/* [in] */ LPCWSTR wzDestinationLocalFilePath);

	HRESULT SetSourcePath(
		/* [in] */ LPCWSTR wzSourceFilePath);
	
	HRESULT BuildLocalAppRootHierarchy(
		/* [in]  */ APPNAME* pAppName,
		/* [out] */ LPWSTR wzLocalAppRoot);

	HRESULT GetFullFilePath(
		/* [in] */  LPCWSTR wzFilename,
		/* [out] */ LPWSTR wzFullFilePath);

private:
	// this should contain the last / or \, excluding a filename
	WCHAR wzSourcePath[MAX_PATH]; // UNC/filesystem restirction
};

CUNCFileSource::CUNCFileSource()
{
	wzSourcePath[0] = L'\0';
}

HRESULT 
CUNCFileSource::CreateNew(LPAPPLICATIONFILESOURCE* ppAppFileSrc)
{
	HRESULT hr = S_OK;
	LPAPPLICATIONFILESOURCE pAppFileSrc = NULL;

    if (!ppAppFileSrc)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

	pAppFileSrc = new CUNCFileSource();
    if (!pAppFileSrc)
    {
		hr = E_OUTOFMEMORY;
		*ppAppFileSrc = NULL;
		goto exit;
    }

	*ppAppFileSrc = pAppFileSrc;

exit:
	return hr;
}

HRESULT 
CUNCFileSource::GetFile(LPCWSTR wzSourceFilePath, LPCWSTR wzDestinationLocalFilePath)
{
	HRESULT hr = S_OK;
	WCHAR* pwzFileName = NULL;

	// unconditional get and overwrite

	// check the path exist? create (sub)directories?
	pwzFileName = PathFindFileName ( wzDestinationLocalFilePath );

	if ( pwzFileName > wzDestinationLocalFilePath )
	{
		*(pwzFileName-1) = L'\0';
		int len = wcslen(wzDestinationLocalFilePath);
		if (len > 3)
		{
			/* must be at least c:\a */
			hr =  CreatePathHierarchy(wzDestinationLocalFilePath);
		}

		// note: this few lines must follow the previous CreatePathHierarchy() line
		*(pwzFileName-1) = L'\\';
		if (FAILED(hr))
			goto exit;
	}

	if (CopyFile(wzSourceFilePath, wzDestinationLocalFilePath, FALSE) == 0)
	{
		hr = GetLastWin32Error();
		goto exit;
	}

exit:
	return hr;
}


HRESULT
CUNCFileSource::GetFile(LPCWSTR wzSourceFilename, LPCWSTR wzDestinationLocalFilePath, LPCWSTR wzHash)
{
	// note: unknown behaviour if wzSourcePath\wzSourceFilename == wzDestinationLocalFilePath
	HRESULT hr=S_OK;
	WCHAR wzFullFilePath[MAX_PATH];

	// 1. check if the file exist, if so, check file integrity
	if (PathFileExists(wzDestinationLocalFilePath))
	{
		if (FAILED(hr = CheckIntegrity(wzDestinationLocalFilePath, wzHash)))
			goto exit;
		if (hr == S_FALSE)
		{
			// hash mismatch/no hash, force overwrite
			hr = S_OK;
		}
		else
			goto exit;	// else we are done, file already there and unchanged
	}

	// 2. assemble the full source path
	if (FAILED(hr = GetFullFilePath(wzSourceFilename, wzFullFilePath)))
		goto exit;

	// 3. copy it over
	if (FAILED(hr = GetFile(wzFullFilePath, wzDestinationLocalFilePath)))
		goto exit;

	// should this copy the file by bytes and check hash the same time?

	// 4. check file integrity, assume ok if no hash
	if (wzHash != NULL && wzHash[0] != L'\0')
	{
		if (FAILED(hr = CheckIntegrity(wzDestinationLocalFilePath, wzHash)))
			goto exit;
		if (hr == S_FALSE)
		{
			// hash mismatch - something very wrong
			hr = CRYPT_E_HASH_VALUE;
			goto exit;
		}
	}
	
exit:
	return hr;
}

// this should only be called once
HRESULT 
CUNCFileSource::SetSourcePath(LPCWSTR wzSourceFilePath)
{
	// keep the source path

	HRESULT hr=S_OK;
	WCHAR* p;

	// copy and avoid buffer overflows
	wcsncpy(wzSourcePath, wzSourceFilePath, MAX_PATH-1);
    wzSourcePath[MAX_PATH-1] = L'\0';

	// strip out the filename portion of the filepath
	p = PathFindFileName(wzSourcePath);
	if ((p-wzSourcePath) >= MAX_PATH)
	{
		hr = CO_E_PATHTOOLONG;
		goto exit;
	}
	else if (p <= wzSourcePath)
	{
		// this file path has no filename in it or is invalid (eg. root)
		hr = E_INVALIDARG;
		goto exit;
	}
	
	*(p-1) = L'\0';

exit:
	if (FAILED(hr))
		wzSourcePath[0] = L'\0';

	return hr;
}

// returning the local app root path with all directories created
HRESULT
CUNCFileSource::BuildLocalAppRootHierarchy(APPNAME* pAppName, LPWSTR wzLocalAppRoot)
{
	// build from wzSourcePath
	
	HRESULT hr=S_OK;
	int offset = 0;
	int len = wcslen(wzSourcePath);
	WCHAR wzAppDir[MAX_PATH];
	
	if (len <3)
	{
		/* must be at least \\a or c:\*/
		hr = E_INVALIDARG;
		goto exit;
	}

	if (PathIsUNC(wzSourcePath))
		offset = 2;		// UNC source
	else if (wzSourcePath[1] == L':' && wzSourcePath[2] == L'\\')
		{
			offset = 3;		// local file source

			// check if the string ends at/after the offset!
			if (len <= 3)
			{
				// eg. C:\ - should disallow root
				hr = E_INVALIDARG;
				goto exit;
			}
		}
	else
	{
		// what else is this?!
		hr = E_FAIL;
		goto exit;
	}

	// 1 get default local root
	if (FAILED(hr=GetDefaultLocalRoot(wzLocalAppRoot)))
		goto exit;

	// 2 append part of source path as the app root
	if (FAILED(hr=GetAppDir(pAppName, wzAppDir)))
		goto exit;

	if (!PathAppend(wzLocalAppRoot, wzAppDir))
	{
		hr = E_FAIL;
		goto exit;
	}

	// 3 create the directories
	if (FAILED(hr=CreatePathHierarchy(wzLocalAppRoot)))
	{
		goto exit;
	}
	

exit:
	if (FAILED(hr))
		wzLocalAppRoot[0] = L'\0';

	return hr;
}

// returning the source file path from a filename
HRESULT 
CUNCFileSource::GetFullFilePath(LPCWSTR wzFilename, LPWSTR wzFullFilePath)
{
	// wzFilename cannot = L'\0'
	// wzFullFilePath must be of length MAX_PATH

	HRESULT hr=S_OK;

	if (wzSourcePath[0] == L'\0')
	{
		// source path not set
		hr = E_UNEXPECTED;
		goto exit;
	}

	wcscpy(wzFullFilePath, wzSourcePath);
	if (!PathAppend(wzFullFilePath, wzFilename))
	{
		hr = E_FAIL;
		//goto exit;
	}

exit:
	return hr;

}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

// the following functions acts similar to their shlwapi Path... counterparts

// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
// http://www.microsoft.com/foo/bar	->	bar
// http://www.microsoft.com/foo		->	foo
// http://www.microsoft.com/foo/	->	foo/	(is this busted?)
// http://www.microsoft.com/		->	http://www.microsoft.com/
// http://www.microsoft.com			->	http://www.microsoft.com
// http://							->	http://
// http:							->	http:
// www.microsoft.com				->	www.microsoft.com

STDAPI_(LPWSTR)
UrlFindFileName(LPCWSTR pPath)
{
    LPCWSTR pW;
    BOOL fSkip = FALSE;

    for (pW = pPath; *pPath; pPath = pPath+1)
    {
        if (pPath[0] == L':' && pPath[1] && pPath[1] == L'/')
        	fSkip = TRUE;
    	
        if (pPath[0] == L'/' && pPath[1] && pPath[1] != L'/')
        {
        	if (fSkip)
        		fSkip = FALSE;
        	else
	            pW = pPath + 1;
        }
    }

    return (LPWSTR)pW;   // const -> non const
}

// this returns successfully only if a filename is present
/*STDAPI_(LPWSTR)
UrlFindExtension(LPCWSTR pPath)
{
	LPCWSTR pFN = UrlFindFileName(pPath);
	int len = wcslen(pPath);
	LPCWSTR pW = pPath+len;

	// no filename there
	if (pFN == pPath)
		return (LPWSTR)(pPath+len);

	for (; *pFN; pFN = pFN+1)
	{
		if (pFN[0] == L'.')
			pW = pFN;
	}

	return (LPWSTR)pW;
}*/

// size of pszPath should be set to MAX_URL_LENGTH
STDAPI_(BOOL)
UrlAppend(LPWSTR  pszPath, LPCWSTR pszMore)
{
	int len = wcslen(pszPath);
	int len2 = wcslen(pszMore);

	// check string overlaps!
	if ((pszPath < pszMore && pszMore < pszPath+len) || 
		(pszMore < pszPath && pszPath < pszMore+len2))
		return FALSE;

	if ((len >= MAX_URL_LENGTH-1) || (len+len2 >= MAX_URL_LENGTH-1))
		return FALSE;

	if (pszPath[len-1] != L'/')
	{
		if ((len >= MAX_URL_LENGTH-2) || (len+len2 >= MAX_URL_LENGTH-2))
			return FALSE;
		pszPath[len] = L'/';
		pszPath[len+1] = L'\0';
	}

	wcsncat(pszPath, pszMore, len2);

	return TRUE;
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

class CHTTPFileSource : public IApplicationFileSource
{
public:
	CHTTPFileSource();

	HRESULT CreateNew(
		/* [out] */ LPAPPLICATIONFILESOURCE* ppAppFileSrc);

	HRESULT GetFile( 
		/* [in] */ LPCWSTR wzSourceFilename,
		/* [in] */ LPCWSTR wzDestinationLocalFilePath,
		/* [in] */ LPCWSTR wzHash);

	HRESULT GetFile( 
		/* [in] */ LPCWSTR wzSourceFilePath,
		/* [in] */ LPCWSTR wzDestinationLocalFilePath);

	HRESULT SetSourcePath(
		/* [in] */ LPCWSTR wzSourceFilePath);
	
	HRESULT BuildLocalAppRootHierarchy(
		/* [in]  */ APPNAME* pAppName,
		/* [out] */ LPWSTR wzLocalAppRoot);

	HRESULT GetFullFilePath(
		/* [in] */  LPCWSTR wzFilename,
		/* [out] */ LPWSTR wzFullFilePath);

private:
	// this should contain the last / or \, excluding a filename
	WCHAR wzSourcePath[MAX_URL_LENGTH]; // http URL restirction

	// S_OK == hash match; S_FALSE == hash unmatch
	HRESULT GetFileFromInternet( 
		/* [in] */ LPCWSTR wzSourceFilePath,
		/* [in] */ LPCWSTR wzDestinationLocalFilePath,
		/* [in] */ LPCWSTR wzHash);
};

CHTTPFileSource::CHTTPFileSource()
{
	wzSourcePath[0] = L'\0';
}

HRESULT 
CHTTPFileSource::CreateNew(LPAPPLICATIONFILESOURCE* ppAppFileSrc)
{
	HRESULT hr = S_OK;
	LPAPPLICATIONFILESOURCE pAppFileSrc = NULL;

    if (!ppAppFileSrc)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

	pAppFileSrc = new CHTTPFileSource();
    if (!pAppFileSrc)
    {
		hr = E_OUTOFMEMORY;
		*ppAppFileSrc = NULL;
		goto exit;
    }

	*ppAppFileSrc = pAppFileSrc;

exit:
	return hr;
}

HRESULT
CHTTPFileSource::GetFileFromInternet(LPCWSTR wzSourceFilePath, LPCWSTR wzDestinationLocalFilePath, LPCWSTR wzHash)
{
	HRESULT hr = S_OK;
	WCHAR* pwzFileName = NULL;

    HINTERNET	hInternet	= NULL;
    HINTERNET	hTransfer	= NULL;
    HANDLE		hFile		= INVALID_HANDLE_VALUE;
    DWORD		dwRead		= 0;
    DWORD		dwWritten	= 0;
    BYTE		buffer[4096];

	HASHCONTEXT hc;
	WCHAR wzComputedHash[HASHSTRINGLENGTH];
	BOOL fDoHash = TRUE;

	// unconditional get and overwrite

	if (wzHash == NULL || wzHash[0] == L'\0')
		fDoHash = FALSE;

	// check the path exist? create (sub)directories?
	pwzFileName = PathFindFileName( wzDestinationLocalFilePath );

	if ( pwzFileName > wzDestinationLocalFilePath )
	{
		*(pwzFileName-1) = L'\0';
		int len = wcslen(wzDestinationLocalFilePath);
		if (len > 3)
		{
			/* must be at least c:\a */
			hr =  CreatePathHierarchy(wzDestinationLocalFilePath);
		}

		// note: this few lines must follow the previous CreatePathHierarchy() line
		*(pwzFileName-1) = L'\\';
		if (FAILED(hr))
			goto exit;
	}

    //////////////////////////////////////////////////////////////////////
    // Step 1: Open the http connection
    hInternet = InternetOpen(L"App", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if(hInternet == NULL)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    // note: cache write mean the refresh might not work and old bits could return
    hTransfer = InternetOpenUrl(hInternet, wzSourceFilePath, NULL, 0, 0, 0);
    if(hTransfer == NULL)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

	if (fDoHash)
		BeginHash(&hc);

    // need to check if there's any error, eg. not found (404)...	InternetGetLastResponseInfo()?

    //////////////////////////////////////////////////////////////////////
    // Step 2: Create the file; Copy the files over the internet
    // need write access, will open (and replace/overwrite) exiting file
    // ??? FILE_SHARE_READ? but we might write to if outdated...
    while(InternetReadFile(hTransfer, buffer, sizeof(buffer), &dwRead) && dwRead != 0)
    {
        // Open the disk file
        if (hFile == INVALID_HANDLE_VALUE)
        {
            hFile = CreateFile(wzDestinationLocalFilePath, GENERIC_WRITE, 0, NULL, 
                               OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        }

        // Failed to open the disk file
        if(hFile == INVALID_HANDLE_VALUE)
	    {
    	    hr = GetLastWin32Error();
        	goto exit;
	    }

        // Write bytes to the disk file
	    // synchronous download
        if ( !WriteFile(hFile, buffer, dwRead, &dwWritten, NULL) || dwWritten != dwRead)
        {
            hr = GetLastWin32Error();
            goto exit;
        }

		if (fDoHash)
		    ContinueHash(&hc, buffer, (unsigned) dwRead);

    }

	if (dwRead != 0)
	{
		hr = GetLastWin32Error();
		goto exit;
	}

	if (fDoHash)
	{
		EndHash(&hc, wzComputedHash);

		if (wcscmp(wzHash, wzComputedHash) != 0)
			hr = S_FALSE;
		else
			hr = S_OK;
	}

exit:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hInternet != NULL)
        InternetCloseHandle(hInternet);
    if (hTransfer != NULL)
        InternetCloseHandle(hTransfer);
    hInternet   = NULL;
    hTransfer   = NULL;
    hFile       = INVALID_HANDLE_VALUE;

	return hr;
}

HRESULT 
CHTTPFileSource::GetFile(LPCWSTR wzSourceFilePath, LPCWSTR wzDestinationLocalFilePath)
{
	HRESULT hr = S_OK;
	WCHAR* pwzFileName = NULL;

	// BUGBUG: this pretty much duplicates CUNCFileSource::GetFile(,)

	// get file from a different location - via CopyFile
	// unconditional get and overwrite

	// check the path exist? create (sub)directories?
	pwzFileName = PathFindFileName ( wzDestinationLocalFilePath );

	if ( pwzFileName > wzDestinationLocalFilePath )
	{
		*(pwzFileName-1) = L'\0';
		int len = wcslen(wzDestinationLocalFilePath);
		if (len > 3)
		{
			/* must be at least c:\a */
			hr =  CreatePathHierarchy(wzDestinationLocalFilePath);
		}

		// note: this few lines must follow the previous CreatePathHierarchy() line
		*(pwzFileName-1) = L'\\';
		if (FAILED(hr))
			goto exit;
	}

	if (CopyFile(wzSourceFilePath, wzDestinationLocalFilePath, FALSE) == 0)
	{
		hr = GetLastWin32Error();
		goto exit;
	}

exit:
	return hr;
}

HRESULT
CHTTPFileSource::GetFile(LPCWSTR wzSourceFilename, LPCWSTR wzDestinationLocalFilePath, LPCWSTR wzHash)
{
	// note: unknown behaviour if wzSourcePath\wzSourceFilename == wzDestinationLocalFilePath
	HRESULT hr=S_OK;
	WCHAR wzFullFilePath[MAX_URL_LENGTH];

	// 1. check if the file exist, if so, check file integrity
	if (PathFileExists(wzDestinationLocalFilePath))
	{
		if (FAILED(hr = CheckIntegrity(wzDestinationLocalFilePath, wzHash)))
			goto exit;
		if (hr == S_FALSE)
		{
			// hash mismatch/no hash, force overwrite
			hr = S_OK;
		}
		else
			goto exit;	// else we are done, file already there and unchanged
	}

	// 2. assemble the full source path
	if (FAILED(hr = GetFullFilePath(wzSourceFilename, wzFullFilePath)))
		goto exit;

	// 3. copy it over
	if (FAILED(hr = GetFileFromInternet(wzFullFilePath, wzDestinationLocalFilePath, wzHash)))
		goto exit;

	// should this copy the file by bytes and check hash the same time?

	// 4. check file integrity, assume ok if no hash
	if (hr == S_FALSE)
	{
DbgMsg(L"hash m