 sends to complete.
	BILINK      InboundPendingList;   // On the list of pending inbound connections

	// index of listener list we are listening in.(not the index in the list).
	INT			iEventHandle;

	
	PCHAR		pReceiveBuffer;				// if we get bigger than 4K.
	PCHAR		pDefaultReceiveBuffer;		// 4K Receive Buffer
	DWORD		cbReceiveBuffer;			// total size of receive buffer
	DWORD		cbReceived;					// total bytes received in buffer
	DWORD		cbExpected;					// number of bytes we're trying to receive.

	BOOL		bCombine;					// whether we combined with another connection.
	// this is the socket address corresponding to the sSocket which may
	// be used for both inbound and outbound connections.  Socket hash keys
	// off of this value.  Which will be the "reply" address of any inbound
	// messages not associated with a player.
	union {							
		SOCKADDR	sockaddr;
		SOCKADDR_IN sockaddr_in;
	}	IOSock;

	// clients without the new dpwsockx.dll will connect with a socket they
	// are not listening on.  This is the address we are receiving from,
	// corresponds to sSocketIn.
	union {
		SOCKADDR	sockaddr;
		SOCKADDR_IN sockaddr_in;
	}	IOnlySock;

} PLAYERCONN, *PPLAYERCONN;

// number of handles we distribute listens across so we can use
// wait for multiple objects and WSAEvent Select for listening.
#define NUM_EVENT_HANDLES			48
#define MAX_EVENTS_PER_HANDLE		32
//#define NUM_EVENT_HANDLES			3
//#define MAX_EVENTS_PER_HANDLE		2
#define INVALID_EVENT_SLOT 0xFFFFFFFF

// Note this sets an absolute cap of 48*32 = 1536 listeners
// per session.  Any connect attempts after that must be failed.
// Note also, with old clients this can mean a max of half that
// many actual players. (We could pull out listening from a player
// if he got a different inbound connection rather than re-using
// the outbound connection to solve this) 

typedef struct _EVENTLIST {
VOL	DWORD		nConn;		// number of 
	PPLAYERCONN pConn[MAX_EVENTS_PER_HANDLE];
} EVENTLIST, *PEVENTLIST;

#if USE_RSIP
typedef struct _RSIP_LEASE_RECORD {
	struct _RSIP_LEASE_RECORD * pNext;
	DWORD   dwRefCount;
	BOOL    ftcp_udp;
	DWORD	tExpiry;
	DWORD   bindid;
	DWORD   addrV4; // remote IP address
	SHORT   rport; 	// remote port
	SHORT	port;	// local port
} RSIP_LEASE_RECORD, *PRSIP_LEASE_RECORD;

// Cache of queried address mappings so we don't
// need to requery the mappings over and over
typedef struct _ADDR_ENTRY {
	struct _ADDR_ENTRY *pNext;
	BOOL	ftcp_udp;
	DWORD	tExpiry;
	DWORD	addr;
	DWORD	raddr;
	WORD	port;
	WORD	rport;
} ADDR_ENTRY, *PADDR_ENTRY;
#endif

// flags that describe a socket
#define SP_CONNECTION_FULLDUPLEX	0x00000001
// stream accept socket in the socket list.
#define SP_STREAM_ACCEPT            0x00000002	

#ifdef SENDEX
typedef struct FPOOL *LPFPOOL;
#endif

typedef struct _GLOBALDATA
{
	IDirectPlaySP * pISP;

	SOCKET sSystemDGramSocket;
	SOCKET sSystemStreamSocket;
	HANDLE hStreamReceiveThread;	// does receive and accept.
	HANDLE hDGramReceiveThread;
	HANDLE hReplyThread;
	RECEIVELIST ReceiveList;  // the list of sockets that StreamReceiveThread is listening on
	// reply thread	
	LPREPLYLIST pReplyList; // list of replies for reply thread to send
	LPREPLYLIST pReplyCloseList; // list of replies to close.
	HANDLE hReplyEvent; // signal the replythread that something is up
	// bago sockets stuff
	LPPLAYERSOCK BagOSockets; // socket cache
	UINT nSocketsInBag; // how many sockets in our bag
	ULONG uEnumAddress; // address entered by user for game server
	ULONG AddressFamily;
	SOCKADDR saddrNS; // address for name server
	DWORD dwLatency; // from dwreserved1 in registry
	BOOL bShutdown;
	BOOL bHaveServerAddress;
    CHAR szServerAddress[ADDR_BUFFER_SIZE];
	HANDLE	hIPXSpareThread; // if nameserver migrates to this host, we start a new receive thread 
							// (bound to our well known socket).  this is the handle to our old receive
							// thread - at shutdown, we need to make sure it's gone
	UINT iMaxUdpDg;			// maximum udp datagram size
	// added in DX6
	FDS	readfds;			// dynamic read fdset
	DWORD dwFlags;			// DPSP_OUTBOUNDONLY, etc.
	DWORD dwSessionFlags;	// session flags passed by app
	WORD wApplicationPort;	// port used for creating system player sockets
	
#ifdef BIGMESSAGEDEFENSE
	DWORD 	dwMaxMessageSize;	// the max message size we should receive
#endif

	HANDLE  hTCPEnumAsyncThread; // fix async enum.
	LPVOID  lpEnumMessage;
	DWORD   dwEnumMessageSize;
	SOCKADDR saEnum;
	DWORD    dwEnumAddrSize;
	SOCKET   sEnum;
	BOOL     bOutBoundOnly;

	HANDLE   hSelectEvent;

#ifdef SENDEX
	CRITICAL_SECTION csSendEx;  // locks sendex data.
	LPFPOOL	pSendInfoPool;     // pool for allocating SENDINFO+SPHeaders for scatter gather sends
	DWORD   dwBytesPending;		// count of total bytes in pending messages.
	DWORD   dwMessagesPending;  // count of total bytes pending.
	BILINK  PendingSendQ;
	BILINK  ReadyToSendQ;
	HANDLE  hSendWait;         // alert thread wait here.
	HANDLE  BogusHandle;	   // don't be fooled by waitfor multiple probs in Win9x, put -1 here.
	BOOL    bSendThreadRunning;
	BOOL    bStopSendThread;
#endif

#if USE_RSIP
VOL	SOCKET  	sRsip;
	SOCKADDR_IN	saddrGateway;
	CRITICAL_SECTION csRsip;
	DWORD       msgid;
	DWORD		clientid;

	// cache the public addresses of these sockets so we don't 
	// need to keep querying the name server every time.
	SOCKADDR saddrpubSystemDGramSocket;
	SOCKADDR saddrpubSystemStreamSocket;

	DWORD	dwBindDGEnumListener;
	
	PRSIP_LEASE_RECORD 	pRsipLeaseRecords;	// list of leases.
	PADDR_ENTRY        	pAddrEntry;			// cache of mappings.
	DWORD 		 		tuRetry;		//microseconds starting retry time.
#endif

#if USE_NATHELP
	HMODULE				hNatHelp;		// module handle for dpnhxxx.dll
	IDirectPlayNATHelp	*pINatHelp;		// interface pointer for IDirectPlayNATHelp object
	DPNHCAPS			NatHelpCaps;

	// we only ever map 2 ports, 1 for UDP, 1 for TCP.
	DPNHHANDLE			hNatHelpUDP;
	DPNHHANDLE			hNatHelpTCP;
	SOCKADDR			saddrpubSystemDGramSocket;
	SOCKADDR			saddrpubSystemStreamSocket;
    SOCKADDR            INADDRANY;
#endif

	SHORT				SystemStreamPort;		// will always be in 2300-2400 range when valid.
	//SHORT				SystemStreamPortOut;	// When running on Win9x < Millenium, need to use separate outbound port.
	BOOL				bSeparateIO;			// When set workaround Winsock bug in Win9x < Millenium
	BOOL		 		bFastSock;				// if we are using FastSocket support.
	CRITICAL_SECTION	csFast;					//  guards fast socket structures

	BILINK		 		InboundPendingList;		// connected from remote, but haven't created local player yet.

VOL	PPLAYERCONN  		PlayerHash[PLAYER_HASH_SIZE];
VOL	PPLAYERCONN	 		SocketHash[SOCKET_HASH_SIZE];

	HANDLE				hAccept;
	HANDLE				EventHandles[NUM_EVENT_HANDLES];
	HANDLE				BackStop;				// Invalid handle to avoid Win95 bug in Wait for Multiple Objects
	
	EVENTLIST			EventList[NUM_EVENT_HANDLES];

	UINT			    iEventAlloc;		// runs around through EventList Index to try next allocation
	INT					nEventSlotsAvail;

} GLOBALDATA,*LPGLOBALDATA;

/*
 * SP Flags (from registry)
 */
#define DPSP_OUTBOUNDONLY	0x00000001

/*
 * DPLAYSVR - DPWSOCKX communication related information
 */

// MSG_HDR indicates a dpwsock system message
#define MSG_HDR 0x736F636B

#define SP_MSG_VERSION	1	// DX6

#define IS_VALID_DPWS_MESSAGE(pMsg) (MSG_HDR == (*((DWORD *)(pMsg))) )
#define COMMAND_MASK 0X0000FFFF

#define GET_MESSAGE_VERSION(pMsg) ( ((pMsg)->dwCmdToken & ~COMMAND_MASK) >> 16 )
#define GET_MESSAGE_COMMAND(pMsg) ( (pMsg)->dwCmdToken & COMMAND_MASK)

#define SET_MESSAGE_HDR(pMsg)  (*((DWORD *)(pMsg)) = MSG_HDR )
#define SET_MESSAGE_COMMAND(pMsg,dwCmd) ((pMsg)->dwCmdToken = ((dwCmd & COMMAND_MASK) \
	| (SP_MSG_VERSION<<16)) )

typedef struct {
	DWORD dwHeader;
    DWORD dwCmdToken;	
} MSG_GENERIC, *LPMSG_GENERIC;


// DPLAYSVR


// macros for manipulating the sockaddr in the player data
#ifdef DEBUG
extern int gCSCount;
#endif
extern CRITICAL_SECTION gcsDPSPCritSection;	// defined in dllmain.c
extern CRITICAL_SECTION csMem;
#define INIT_DPSP_CSECT() InitializeCriticalSection(&gcsDPSPCritSection);InitializeCriticalSection(&csMem);
#define FINI_DPSP_CSECT() DeleteCriticalSection(&gcsDPSPCritSection);DeleteCriticalSection(&csMem);
#ifdef DEBUG
#define ENTER_DPSP() EnterCriticalSection(&gcsDPSPCritSection),gCSCount++;
#define LEAVE_DPSP() gCSCount--,LeaveCriticalSection(&gcsDPSPCritSection);
#else
#define ENTER_DPSP() EnterCriticalSection(&gcsDPSPCritSection);
#define LEAVE_DPSP() LeaveCriticalSection(&gcsDPSPCritSection);
#endif // DEBUG

// get a pointer to the players socket address - used by macros below
#define DGRAM_PSOCKADDR(ppd) ((SOCKADDR *)&(((LPSPPLAYERDATA)ppd)->saddrDatagram))
#define STREAM_PSOCKADDR(ppd) ((SOCKADDR *)&(((LPSPPLAYERDATA)ppd)->saddrStream))

// get the udp ip addr from a player
#define IP_DGRAM_ADDR(ppd) 	(((SOCKADDR_IN *)DGRAM_PSOCKADDR(ppd))->sin_addr.s_addr)
#define IP_DGRAM_PORT(ppd) 	(((SOCKADDR_IN *)DGRAM_PSOCKADDR(ppd))->sin_port)

// get the stream ip addr from a player
#define IP_STREAM_ADDR(ppd) 	(((SOCKADDR_IN *)STREAM_PSOCKADDR(ppd))->sin_addr.s_addr)
#define IP_STREAM_PORT(ppd) 	(((SOCKADDR_IN *)STREAM_PSOCKADDR(ppd))->sin_port)

// used to get the name of the computer we're running on in spinit
#define HOST_NAME_LENGTH 50


// if it's not ipx, it's ip
// {685BC400-9D2C-11cf-A9CD-00AA006886E3}
DEFINE_GUID(GUID_IPX, 
0x685bc400, 0x9d2c, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(GUID_TCP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// {3A826E00-31DF-11d0-9CF9-00A0C90A43CB}
DEFINE_GUID(GUID_LOCAL_TCP, 
0x3a826e00, 0x31df, 0x11d0, 0x9c, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);


// globals
// ghinstance is used when putting up the dialog box to prompt for ip addr
extern HANDLE ghInstance; // set in dllmain. instance handle for dpwsock.dll

#ifdef DEBUG

extern void DebugPrintAddr(UINT level,LPSTR pStr,SOCKADDR * psockaddr);
#define DEBUGPRINTADDR(n,pstr,psockaddr) DebugPrintAddr(n,pstr,psockaddr);
extern void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock);
#define DEBUGPRINTSOCK(n,pstr,psock) DebugPrintSocket(n,pstr,psock);

#else // debug

#define DEBUGPRINTADDR(n,pstr,psockaddr)
#define DEBUGPRINTSOCK(n,pstr,psock)

#endif // debug

// global vars
extern BOOL gbVoiceOpen; // set to TRUE if we have nm call open

// from dpsp.c
extern HRESULT WaitForThread(HANDLE hThread);
extern HRESULT SetupControlSocket();
extern HRESULT WINAPI SP_Close(LPDPSP_CLOSEDATA pcd);
extern HRESULT InternalReliableSend(LPGLOBALDATA pgd, DPID idPlayerTo, SOCKADDR *
	lpSockAddr, LPBYTE lpMessage, DWORD dwMessageSize);
extern HRESULT DoTCPEnumSessions(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,
	LPDPSP_ENUMSESSIONSDATA ped, BOOL bHostWillReuseConnection);
extern HRESULT SendControlMessage(LPGLOBALDATA pgd);
extern HRESULT SendReuseConnectionMessage(SOCKET sSocket);
extern HRESULT AddSocketToBag(LPGLOBALDATA pgd, SOCKET socket, DPID dpid, SOCKADDR *psockaddr, DWORD dwFlags);
extern BOOL FindSocketInReceiveList(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket);
extern void RemoveSocketFromReceiveList(LPGLOBALDATA pgd, SOCKET socket);
extern void RemoveSocketFromBag(LPGLOBALDATA pgd, SOCKET socket);
extern BOOL FindSocketInBag(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket, LPDPID lpdpidPlayer);
extern HRESULT GetSocketFromBag(LPGLOBALDATA pgd,SOCKET * psSocket, DWORD dwID, LPSOCKADDR psockaddr);
extern HRESULT CreateAndConnectSocket(LPGLOBALDATA pgd,SOCKET * psSocket,DWORD dwType,LPSOCKADDR psockaddr, BOOL bOutBoundOnly);
extern void RemovePlayerFromSocketBag(LPGLOBALDATA pgd,DWORD dwID);
extern void SetMessageHeader(LPDWORD pdwMsg,DWORD dwSize, DWORD dwToken);
extern void KillTCPEnumAsyncThread(LPGLOBALDATA pgd);

// Support for SendEx in dpsp.c

extern HRESULT UnreliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO lpSendInfo);
extern HRESULT ReliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo);
extern VOID RemovePendingAsyncSends(LPGLOBALDATA pgd, DPID dwPlayerTo);
extern BOOL bAsyncSendsPending(LPGLOBALDATA pgd, DPID dwPlayerTo);
extern HRESULT GetSPPlayerData(LPGLOBALDATA pgd, IDirectPlaySP * lpISP, DPID idPlayer, LPSPPLAYERDATA *ppPlayerData, DWORD *lpdwSize);

// from winsock.c
extern HRESULT FAR PASCAL CreateSocket(LPGLOBALDATA pgd,SOCKET * psock,INT type,
	WORD port,ULONG address,SOCKERR * perr, BOOL bInRange);
extern HRESULT SPConnect(SOCKET* psSocket, LPSOCKADDR psockaddr,UINT addrlen, BOOL bOutBoundOnly);
extern HRESULT CreateAndInitStreamSocket(LPGLOBALDATA pgd);
extern HRESULT SetPlayerAddress(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,SOCKET sSocket,BOOL fStream); 
extern HRESULT CreatePlayerDgramSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags); 
extern HRESULT CreatePlayerStreamSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags); 
extern HRESULT SetDescriptionAddress(LPSPPLAYERDATA ppd,LPDPSESSIONDESC2 lpsdDesc);
extern HRESULT SetReturnAddress(LPVOID pmsg,SOCKET sSocket, LPSOCKADDR psaddr);
extern HRESULT GetReturnAddress(LPVOID pmsg,LPSOCKADDR psockaddr);
extern HRESULT GetServerAddress(LPGLOBALDATA pgd,LPSOCKADDR psockaddr) ;
extern void IPX_SetNodenum(LPVOID pmsg,SOCKADDR_IPX * psockaddr);
extern void IP_GetAddr(SOCKADDR_IN * paddrDest,SOCKADDR_IN * paddrSrc) ;
extern void IP_SetAddr(LPVOID pBuffer,SOCKADDR_IN * psockaddr);
extern void IPX_GetNodenum(SOCKADDR_IPX * paddrDest,SOCKADDR_IPX * paddrSrc) ;
extern HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard);
extern HRESULT KillPlayerSockets();
extern HRESULT GetAddress(ULONG * puAddress,char *pBuffer,int cch);
extern HRESULT KillThread(HANDLE hThread);

// from wsock2.c
extern DWORD WINAPI AsyncSendThreadProc(LPVOID pvCast);
extern HRESULT InitWinsock2();
extern HRESULT GetMaxUdpBufferSize(SOCKET socket, unsigned int * lpiSize);

extern HRESULT InternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, 
				LPSENDINFO pSendInfo, SOCKADDR *lpSockAddr);
extern DWORD WINAPI SPSendThread(LPVOID lpv);
extern void QueueForSend(LPGLOBALDATA pgd,LPSENDINFO pSendInfo);


// from handler.c
extern HRESULT HandleServerMessage(LPGLOBALDATA pgd, SOCKET sSocket, LPBYTE pBuffer, DWORD dwSize);

#ifdef FULLDUPLEX_SUPPORT
// from registry.c
extern HRESULT GetFlagsFromRegistry(LPGUID lpguidSP, LPDWORD lpdwFlags);
#endif // FULLDUPLEX_SUPPORT

#if USE_RSIP
// from registry.c
extern HRESULT GetGatewayFromRegistry(LPGUID lpguidSP, LPBYTE lpszGateway, DWORD cbszGateway);
#elif USE_NATHELP
// from registry.c
extern HRESULT GetNATHelpDLLFromRegistry(LPGUID lpguidSP, LPBYTE lpszNATHelpDLL, DWORD cbszNATHelpDLL);
#endif

extern BOOL FastSockInit(LPGLOBALDATA pgd);
extern VOID FastSockFini(LPGLOBALDATA pgd);
extern PPLAYERCONN CreatePlayerConn(LPGLOBALDATA pgd, DPID dpid, SOCKADDR *psockaddr);
extern PPLAYERCONN FindPlayerById(LPGLOBALDATA pgd, DPID dpid);
extern PPLAYERCONN FindPlayerBySocket(LPGLOBALDATA pgd, SOCKADDR *psockaddr);
extern HRESULT AddConnToPlayerHash(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern HRESULT AddConnToSocketHash(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern PPLAYERCONN RemoveConnFromSocketHash(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern PPLAYERCONN RemoveConnFromPlayerHash(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern VOID QueueSendOnConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, PSENDINFO pSendInfo);
extern PPLAYERCONN GetPlayerConn(LPGLOBALDATA pgd, DPID dpid, SOCKADDR *psockaddr);
extern INT DecRefConn(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern INT DecRefConnExist(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern HRESULT FastInternalReliableSend(LPGLOBALDATA pgd, LPDPSP_SENDDATA psd, SOCKADDR *lpSockAddr);
extern HRESULT FastInternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo, SOCKADDR *lpSockAddr);
extern PPLAYERCONN CleanPlayerConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bHard);
extern HRESULT FastReply(LPGLOBALDATA pgd, LPDPSP_REPLYDATA prd, DPID dwPlayerID);
extern PPLAYERCONN FindConnInPendingList(LPGLOBALDATA pgd, SOCKADDR *psaddr);
extern DWORD WINAPI FastStreamReceiveThreadProc(LPVOID pvCast);
extern VOID FastSockCleanConnList(LPGLOBALDATA pgd);
extern INT DecRefConn(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern VOID QueueNextSend(LPGLOBALDATA pgd,PPLAYERCONN pConn);


// Wrap Malloc
void _inline __cdecl SP_MemFree( LPVOID lptr )
{
	EnterCriticalSection(&csMem);
	MemFree(lptr);
	LeaveCriticalSection(&csMem);
}

LPVOID _inline __cdecl SP_MemAlloc(UINT size)
{
	LPVOID lpv;
	EnterCriticalSection(&csMem);
	lpv = MemAlloc(size);
	LeaveCriticalSection(&csMem);
	return lpv;
}

LPVOID _inline __cdecl SP_MemReAlloc(LPVOID lptr, UINT size)
{
	LPVOID lpv;
	EnterCriticalSection(&csMem);
	lpv = MemReAlloc(lptr, size);
	LeaveCriticalSection(&csMem);
	return lpv;
}

#define AddRefConn(_p) InterlockedIncrement(&((_p)->dwRefCount))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\dpsp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsp.c
 *  Content:	sample direct play service provider, based on winsock
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  1/96		andyco	created it
 *  2/8/96		andyco	steam + dgram model, including name server support
 *	2/15/96		andyco	added reliable receive.  added send (udp + stream). 
 *						added macros for dwReserved to clean up, (and provide
 *						means for reducing # dwords reserved per player)
 *	3/13/96		andyco	relaible send + receive for all players. MW2
 *	3/16/96		andyco	shutdown method - code cleanup - shared stream receive, etc.
 *	3/19/96		andyco	new message macros (IS_VALID, GET_MESSAGE_SIZE). see dpmess.h
 *	4/3/96		andyco	moved start up / shut down winsock code here from dllmain 
 *	4/10/96		andyco	added spplayerdata
 *	4/12/96		andyco	got rid of dpmess.h! use DPlay_ instead of message macros
 *	4/18/96		andyco	added multihomed support, started ipx
 *	4/23/96		andyco	ipx support.  ipx only - no spx.  spx doesn't support
 *						graceful disconnect (winsock bug?) so we don't know
 *						when it's safe to closesocket.
 *	4/25/96		andyco	messages now have blobs (sockaddr's) instead of dwReserveds  
 *	5/31/96		andyco	all non-system players share a socket (gsStream and 
 *						gsDGramSocket).
 *	6/9/96		andyco	ouch.  dplayi_player + group are gone!
 *	6/19/96		andyco	sp sets own header!
 *	6/22/96		andyco	no more stashing goodies in sessiondesc.  tossed cookies.
 *	6/23/96		kipo	updated for latest service provider interfaces.
 *	6/25/96		kipo	added WINAPI prototypes and updated for DPADDRESS;
 *						added version.
 *	7/11/96		andyco	reset gsEnumSocket to INVALID_SOCKET if spInit fails
 *						#2348.  added sp_getaddress.
 *	7/18/96		andyco	added dphelp for server socket
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  8/1/96		andyco	fixed up caps.  dplay allocs sp data, not us.  
 *  8/9/96		andyco	throw DPCAPS_GUARANTEEDOPTIMIZED for AF_INET
 *	8/12/96		andyco	changed failure check on inithelper
 *	8/15/96		andyco	added sp local data + clean up on thread terminate
 *	8/30/96		andyco	clean it up b4 you shut it down! added globaldata.
 *	9/1/96		andyco	right said thread!  if you spin it, they won't block.
 *						bagosockets.
 * 	9/4/96		andyco	kill threads at shutdown only. add all threads to
 *						threadlist. don't add thread to list if it's already
 *						done.
 *	11/11/96	andyco	check for NULL header or data when creating
 *						non-local players (support game server). Memset our 
 *						sockaddr to 0 before calling getserveraddress.
 *	12/18/96	andyco	de-threading - use a fixed # of prealloced threads.
 *						cruised the enum socket / thread - use the system
 *						socket / thread instead
 *	1/15/97		andyco	return actual hr on open failure (bug 5197) instead of
 *						just DP_OK.  also, allow system messages to go in the 
 *						socket cache. 
 *	1/17/97		andyco	workaround for nt bug 68093 - recvfrom returns buffer size
 *						instead of WSAEMSGSIZE
 *	1/23/97		kipo	return an error code from StartDPHelp() so Open() returns
 *						an error if you cannot host a session.
 *	1/24/97		andyco	handle incoming message when receive thread isn't running yet
 *	2/7/97		andyco  store globals w/ IDirectPlaySP, so we can have > 1 SP per DLL.
 *	2/10/97		andyco	remove sockets from receive list if we get an error when receiving 
 *						on them.  this keeps us from going into a spin on select(...).
 *	2/15/97		andyco	wait on accept thread b4 receive thread.  pass port to 
 *						helperdeletedplayserver.
 *	3/04/97		kipo	external definition of gdwDPlaySPRefCount now in dplaysp.h
 *	3/18/97		andyco	create socket at spinit to verify support for requested
 *						address family
 *	3/18/97		kipo	GetServerAddress() now returns an error so that we can
 *						return DPERR_USERCANCEL from the EnumSessions dialog
 *	3/25/97		andyco	tweaked shutdown code to send message to streamreceivethreadproc
 *						to exit, rather than nuking the control socket which
 *						would sometimes hang.
 *	4/11/97		andyco	make sure it's really the control socket @ init
 *	5/12/97		kipo	return DPERR_UNAVAILABLE if SP could not be opened (i.e. if
 *						IPX not installed) to be compatible with the modem SP; added
 *						support for Unicode IP address strings.
 *	5/18/97		andyco	close threads + sockets at close.  this way, we don't hold
 *						sockets across sessions.
 *	6/11/97		andyco	changed reply thread proc to flush q when waking up
 *	6/18/97		andyco	check for bogus reply headers, just to be safe
 *	6/19/97		myronth	Fixed handle leak (#10059)
 *	6/20/97		andyco	check for bogus IPX install by looking for sa_nodenum
 *						of all 0's at SPInit.  raid 9625.
 *	7/11/97		andyco	added async reply thread and ws2 support
 *	7/30/97		andyco	call wsastartup w/ version 1.1 if app has already 
 *						called it.
 *   8/4/97		andyco	added support for DPSEND_ASYNC (no return status) so 
 *						we can make addforward async
 *	8/25/97		sohailm updated stream receive logic to avoid congestion (bug #10952)
 *	9/05/97		kipo	Fixed memphis bug #43655 to deal with getsockopt failing
 *	12/5/97		andyco	voice support
 *	01/5/98		sohailm	fd set now grows dynamically - allows for any number of clients (#15244).
 *	01/14/98	sohailm	don't look for Winsock2.0 on non-nt platforms for IPX (#15253)
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/21/98    a-PeterZ	Fix #15242 SP_GetAddress supports local players
 *	1/27/98		sohailm	added Firewall support.
 *	1/30/98		sohailm	bug fix for 17731
 *	2/09/98    a-PeterZ	Fix #17737 ReceiveList Memory Leak
 *  2/13/98     aarono  added async support
 *  2/13/98     aarono  made IPX return proper header size
 *	2/16/98    a-PeterZ	Fix #15342 Detect no local connection in SP_EnumSessions and SP_Open
 *	2/18/98    a-peterz Comment byte order mess-up with SERVER_xxx_PORT constants
 *  2/24/98     aarono  Bug#18646 fix startup/close race crashing stress.
 *  3/3/98      aarono  Bug#19188 remove accept thread 
 *  3/30/98     aarono  changed KillSocket on StreamAccept socket to closesocket
 *  4/6/98      aarono  mapped WSAECONNRESET to DPERR_CONNECTIONLOST
 *  4/23/98     aarono  workaround Winsock shutdown bug.
 *                       The workaround for DPLAY would be to close all accepted sockets first 
 * 						 and only then listening socket. (VadimE)
 *  6/19/98     aarono  map WSAENETRESET and WSAENOTCONN to DPERR_CONNECTIONLOST too.
 *                      required since we now turn on keepalives on reliable
 *                      connections.
 * 12/15/98     aarono  Fix Async Enum.
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *  1/12/2000   aarono  Added Rsip support
 *  2/21/2000   aarono  Fix socket leaks
 * 10/15/2000   aarono  Force separate ports for Inbound/Outbound there seems to be a race
 *                      condition either in sockets or us in Millennium (win2k too?) too late
 *                      for full fix, may want to investigate furthur for later version.
 *
 ***************************************************************************/

/***************************************************************************
*  summary -                                                                
* 	+ SPInit is the entry point called by dplay. SP fills in callbacks,		
* 		does any other init stuff there.                                    
* 	+ All dplay callbacks start with SP_                                    
*                                                                           
*****************************************************************************/

// todo - need a meaningful mapping from socket errors to hresults

// todo - figure out when to pop a message box to the user for tragic errors

#define INITGUID

#include <dplobby.h>
#include "dpsp.h"
#include "fpm.h"
#include <initguid.h>
#include "helpcli.h"
#include "rsip.h"
#include "nathelp.h"
#include "mmsystem.h"
#include "dpnathlp.h"

/*			*/
/*  globals	*/
/*			*/
WSADATA gwsaData; // from wsastartup
HINSTANCE hWS2; // dynaload the ws2_32.dll, so if it's not installed (e.g. win 95 gold)
				// we still load

// stuff for ddhelp
DWORD dwHelperPid; // for ddhelp
HANDLE hModule;  // for ddhelp

CRITICAL_SECTION gcsDPSPCritSection;
CRITICAL_SECTION csMem;
#ifdef DEBUG
int gCSCount;
#endif

HRESULT StartReplyThread(LPGLOBALDATA pgd);

#undef DPF_MODNAME
#define DPF_MODNAME	"DEBUGPRINTSOCKADDR"

#ifdef DEBUG
void DebugPrintAddr(UINT nLevel,LPSTR pStr,SOCKADDR * psockaddr)
{
	switch (psockaddr->sa_family)
	{
		case AF_INET: 
		{
			SOCKADDR_IN * pin;
			pin = (SOCKADDR_IN *)psockaddr;
			DPF(nLevel,"%s af = AF_INET : address =  %s : port = %d\n",pStr,
				inet_ntoa(pin->sin_addr),ntohs(pin->sin_port));
			break;
			
		}
		case AF_IPX: 
		{
			SOCKADDR_IPX * pipx;
			pipx = (SOCKADDR_IPX *)psockaddr;
			DPF(nLevel,"%s AF = AF_IPX : sa_socket = %d : sa_net.sa_nodenum = \n",pStr,pipx->sa_socket);
			DPF(nLevel,"%02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x\n",
					(UCHAR)pipx->sa_netnum[0],(UCHAR)pipx->sa_netnum[1],
					(UCHAR)pipx->sa_netnum[2],(UCHAR)pipx->sa_netnum[3],
					(UCHAR)pipx->sa_nodenum[0],(UCHAR)pipx->sa_nodenum[1],
					(UCHAR)pipx->sa_nodenum[2],(UCHAR)pipx->sa_nodenum[3],
					(UCHAR)pipx->sa_nodenum[4],(UCHAR)pipx->sa_nodenum[5]);
			break;
			
		}

		default:
			ASSERT(FALSE);
			break;
	}

} // DebugPrintAddr

void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock) 
{
	SOCKADDR sockaddr;
	int addrlen=sizeof(sockaddr);

	getsockname(*pSock,&sockaddr,&addrlen);
	DEBUGPRINTADDR(level,pStr,&sockaddr);
	
}
#endif // debug

#if USE_RSIP
HRESULT GetLocalAliases(LPGLOBALDATA pgd, LPSPPLAYERDATA lpPublicData, LPSPPLAYERDATA lpLocalData)
{
	HRESULT hr=DP_OK;

	
	DPF(8, "GetLocalAliases: Parameters: (0x%x, 0x%x, 0x%x)", pgd, lpPublicData, lpLocalData);

	// local aliases may be the public addresses, so copy first and only overwrite if there
	// are actual local aliases.
	memcpy(lpLocalData, lpPublicData, sizeof(SPPLAYERDATA));
	if(pgd->sRsip != INVALID_SOCKET)
	{
		hr=rsipQueryLocalAddress(pgd,TRUE,&lpPublicData->saddrStream, &lpLocalData->saddrStream);
		if (hr != DP_OK)
		{
			//
			// Stream socket address not found.
			//
		}
		else
		{
			hr=rsipQueryLocalAddress(pgd,FALSE,&lpPublicData->saddrDatagram, &lpLocalData->saddrDatagram);
			if (hr != DP_OK)
			{
				//
				// Datagram socket address not found.
				//
			}
		}
	}	
	
	DPF(8, "GetLocalAliases: Returning [0x%lx]", hr);
	
	return hr;
}
#endif

#if USE_NATHELP
HRESULT GetLocalAliases(LPGLOBALDATA pgd, LPSPPLAYERDATA lpPublicData, LPSPPLAYERDATA lpLocalData)
{
	HRESULT hr=DP_OK;

	
	DPF(8, "GetLocalAliases: Parameters: (0x%x, 0x%x, 0x%x)", pgd, lpPublicData, lpLocalData);

	// local aliases may be the public addresses, so copy first and only overwrite if there
	// are actual local aliases.
	memcpy(lpLocalData, lpPublicData, sizeof(SPPLAYERDATA));
	if(pgd->pINatHelp)
	{
		hr=IDirectPlayNATHelp_QueryAddress(
			pgd->pINatHelp, 
			&pgd->INADDRANY, 
			&lpPublicData->saddrStream, 
			&lpLocalData->saddrStream, 
			sizeof(SOCKADDR_IN), 
			DPNHQUERYADDRESS_TCP|DPNHQUERYADDRESS_CACHENOTFOUND);
		
		if (hr != DPNH_OK)
		{
			//
			// Stream socket address not found.
			//
		}
		else
		{
			hr=IDirectPlayNATHelp_QueryAddress(
				pgd->pINatHelp, 
				&pgd->INADDRANY, 
				&lpPublicData->saddrDatagram, 
				&lpLocalData->saddrDatagram, 
				sizeof(SOCKADDR_IN), 
				DPNHQUERYADDRESS_CACHENOTFOUND);
			if (hr != DPNH_OK)
			{
				//
				// Datagram socket address not found.
				//
			}
		}
	}	
	
	DPF(8, "GetLocalAliases: Returning [0x%lx]", hr);
	
	return hr;
}
#endif


HRESULT GetSPPlayerData(LPGLOBALDATA pgd, IDirectPlaySP * lpISP, DPID idPlayer, LPSPPLAYERDATA *ppPlayerData, DWORD *lpdwSize)
{
	HRESULT hr;
	DWORD dwSize;
	BOOL bAlreadyTried=FALSE; // already tried to get local mapping for remote, so just return local

	
	DPF(8, "GetSPPlayerData: Parameters: (0x%x, 0x%x, %u/%x, 0x%x, 0x%x)", pgd, lpISP, idPlayer, idPlayer, ppPlayerData, lpdwSize);
	
	#if USE_RSIP 

	    if(pgd->sRsip != INVALID_SOCKET){
	
GetLocal:	    
			hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_LOCAL);
			if(FAILED(hr)){
				if(hr!=DPERR_INVALIDPLAYER){
					ASSERT(FALSE);
				}
				goto Exit;
			}
			if (*lpdwSize==0 && !bAlreadyTried )
			{
				SPPLAYERDATA Local_pd;     // Local as in the local addresses
				LPSPPLAYERDATA pRemote_pd; // Remote as in the public addresses 
				// We haven't go the local alias for the public addresses yet.
									
				hr= lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,&pRemote_pd,lpdwSize,DPGET_REMOTE);
				if(FAILED(hr)){
					if(hr!=DPERR_INVALIDPLAYER){
						ASSERT(0);
					}
					goto Exit;
				}
				if(*lpdwSize == sizeof(SPPLAYERDATA)){
					// see if there are local aliases for the remote addresses - if there are no local aliases,
					// this simply returns the same information that is used in the LOCAL data.
					GetLocalAliases(pgd, pRemote_pd, &Local_pd);
					
					hr=lpISP->lpVtbl->SetSPPlayerData(lpISP, idPlayer, &Local_pd, sizeof(SPPLAYERDATA), DPSET_LOCAL);
					if(hr == DP_OK){
						goto GetLocal;
					}	
				} else {
					bAlreadyTried=TRUE;
					goto GetLocal;
				}
			}

			goto Exit;

		} else {
		
			hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_REMOTE);
			if (FAILED(hr))
			{
				DPF(1, "GetSPPlayerData for player %d returned err %d", idPlayer, hr);
				if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
					ASSERT(FALSE);
				goto Exit;
			}

			goto Exit;
		}

	#elif USE_NATHELP

	    if(pgd->pINatHelp){
	
GetLocal:	    
			hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_LOCAL);
			if(FAILED(hr)){
				if(hr!=DPERR_INVALIDPLAYER){
					ASSERT(FALSE);
				}
				goto Exit;
			}
			if (*lpdwSize==0 && !bAlreadyTried )
			{
				SPPLAYERDATA Local_pd;     // Local as in the local addresses
				LPSPPLAYERDATA pRemote_pd; // Remote as in the public addresses 
				// We haven't go the local alias for the public addresses yet.
									
				hr= lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,&pRemote_pd,lpdwSize,DPGET_REMOTE);
				if(FAILED(hr)){
					if(hr!=DPERR_INVALIDPLAYER){
						ASSERT(0);
					}
					goto Exit;
				}
				if(*lpdwSize == sizeof(SPPLAYERDATA)){
					// see if there are local aliases for the remote addresses - if there are no local aliases,
					// this simply returns the same information that is used in the LOCAL data.
					GetLocalAliases(pgd, pRemote_pd, &Local_pd);
					
					hr=lpISP->lpVtbl->SetSPPlayerData(lpISP, idPlayer, &Local_pd, sizeof(SPPLAYERDATA), DPSET_LOCAL);
					if(hr == DP_OK){
						goto GetLocal;
					}	
				} else {
					bAlreadyTried=TRUE;
					goto GetLocal;
				}
			}

			goto Exit;

		} else {
		
			hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_REMOTE);
			if (FAILED(hr))
			{
				DPF(1, "GetSPPlayerData for player %d returned err %d", idPlayer, hr);
				if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
					ASSERT(FALSE);
				goto Exit;
			}

			goto Exit;
		}

	#else
	
		hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			DPF(1, "GetSPPlayerData for player %d returned err %d", idPlayer, hr);
			if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
				ASSERT(FALSE);
			goto Exit;
		}

		goto Exit;

	#endif

Exit:

	DPF(8, "GetSPPlayerData: Returning [0x%lx]", hr);

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"GetHostAddr"

// Helper function to retrieve host IP Address(es).
// System owns structure returned.
PHOSTENT GetHostAddr(void)
{
	char pHostName[HOST_NAME_LENGTH];
	PHOSTENT phostent;
	UINT err;

	if (0 != gethostname(pHostName, HOST_NAME_LENGTH)) 
	{
		err = WSAGetLastError();
		DPF(0,"could not get host name - err = %d\n",err);
		return NULL;
	}
	
	phostent = gethostbyname(pHostName);
	if (NULL == phostent) 
	{
		err = WSAGetLastError();
		DPF(0,"could not get address for '%s' - err = %d\n", pHostName, err);
		return NULL;
	}

	return phostent;
} // GetHostAddr

#undef DPF_MODNAME
#define DPF_MODNAME	"DatagramListenThread"

void SetMessageHeader(LPDWORD pdwMsg,DWORD dwSize, DWORD dwToken)
{

	if (dwSize > SPMAXMESSAGELEN)
	{
		ASSERT(FALSE);
	}

	*pdwMsg = dwSize | dwToken;	

	return ;

}// SetMessageHeader

#undef DPF_MODNAME
#define DPF_MODNAME	"DatagramReceiveThread"

// our initial guess at the size of the dgram receive buffer.
// any messages bigger than this will be truncated BUT when we 
// receive a too big message, we double the buffer size (winsock
// won't tell us exactly how big the message was, so we guess).
// a-josbor: I thought 1024 was really stingy, so I bumped this up to 16K
#define BUF_SIZE 0x4000
DWORD WINAPI DgramListenThreadProc(LPVOID pvCast)
{
    UINT err;
	LPBYTE pBuffer;
    INT addrlen=sizeof(SOCKADDR);
    SOCKADDR sockaddr; // the from address
	DWORD dwBufSize = BUF_SIZE;
	IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;
	LPGLOBALDATA pgd;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	SOCKET sSocket;
	HRESULT hr;

    DPF(2,"starting udp listen thread ");

	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;
	}
	
	// use the dgram socket
	sSocket = pgd->sSystemDGramSocket;

  DPF(0,"Thread listening on socket %d UDP\n",sSocket);
  DEBUGPRINTSOCK(0,"SocketAddr for listen:",&sSocket);

	
	ENTER_DPSP();
	
	pBuffer = SP_MemAlloc(BUF_SIZE);
	
	LEAVE_DPSP();
	
	if (!pBuffer)
	{
		DPF_ERR("could not alloc dgram receive buffer");
		DEBUG_BREAK();
		ExitThread(0);
		return 0;
	}


    while (1)
    {
        err = recvfrom(sSocket,pBuffer,dwBufSize,0,&sockaddr,&addrlen);
        if ( (SOCKET_ERROR == err)  || (dwBufSize == err))
        {
		
			if (dwBufSize == err)
			{
				// this works around NT bug 68093
				err = WSAEMSGSIZE;
			}
			else 
			{
	            err = WSAGetLastError();				
			}
	        
			DPF(2,"\n udp recv error - err = %d socket = %d",err,(DWORD)sSocket);
			
			if (WSAEMSGSIZE == err)
			{
				// buffer too small!
				dwBufSize *= 2;
				
				ENTER_DPSP();
				
				pBuffer = SP_MemReAlloc(pBuffer,dwBufSize);
				
				LEAVE_DPSP();
				
				if (!pBuffer)
				{
					DPF_ERR("could not realloc dgram receive buffer");
					DEBUG_BREAK();
					ExitThread(0);
					return 0;
				}
				// we don't pass dplay this message, since it was truncated...
			}
			else 
			{
		      if(pgd->bShutdown || err == WSAENOTSOCK || err == WSAESHUTDOWN || err == WSAEINTR){
				// bail on shutdown only.
				DPF(0,"Got err %d on datagram socket, bailing, bShutdown = %d\n",err,pgd->bShutdown);
				goto ERROR_EXIT;
			  }else if(err == WSAECONNRESET){
			  		// expected errors we are going to ignore.
			      DPF(0,"Winsock gave a WSAECONNRESET on a DATAGRAM socket\n");
			  } else {
			  		// Getting some kind of consistent error, don't totally crush the cpu
			  		// until we shutdown.  Some of these may be normal.
			  		DPF(0,"DGListen Got err %d on datagram socket, sleeping 1ms\n",err);
				  	Sleep(1);
			  }
			}
        }
        else if ( (err >= sizeof(DWORD)) &&  (VALID_DPWS_MESSAGE(pBuffer)) )
        {
		
			DEBUGPRINTADDR(8,"received udp message from : ",&sockaddr);
			if (VALID_SP_MESSAGE(pBuffer))
			{
				// it came from another dplay (not from our dplay helper)
				// if it came from our helper, we've already poked the ip addr
				// into the message body
				switch (pgd->AddressFamily)
				{
					case AF_IPX:
						IPX_SetNodenum((LPVOID)pBuffer,(SOCKADDR_IPX *)&sockaddr);
						break;
					case AF_INET:
						IP_SetAddr((LPVOID)pBuffer,(SOCKADDR_IN *)&sockaddr);
						break;
					default:
						ASSERT(FALSE);
						break;
				}
				
			}

			// pass message to dplays handler
            pISP->lpVtbl->HandleMessage(pISP,pBuffer + sizeof(MESSAGEHEADER),
            	err -  sizeof(MESSAGEHEADER), pBuffer);
    	}
		else 
		{
			DEBUGPRINTADDR(8,"received udp message from : ",&sockaddr);		
			// it must be just a raw send...
            pISP->lpVtbl->HandleMessage(pISP,pBuffer,err,NULL);
		}
    }

ERROR_EXIT:
	DPF(2,"UDP Listen thread exiting");
  DPF(0,"Exiting from listening on Socket %d\n",sSocket);
	
	ENTER_DPSP();
	
	if (pBuffer) SP_MemFree(pBuffer);
	
	LEAVE_DPSP();

    // all done
    ExitThread(0);
    return 0;

} // UDPListenThreadProc

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamListenThread"

// make sure the buffer is big enough to fit the message size
HRESULT MakeBufferSpace(LPBYTE * ppBuffer,LPDWORD pdwBufferSize,DWORD dwMessageSize)
{
	HRESULT hr = DP_OK;

	ASSERT(ppBuffer);
	ASSERT(pdwBufferSize);
		    
	ENTER_DPSP();
	
	if (!*ppBuffer)
	{
		DPF(8, "Allocating space for message of size %d", dwMessageSize);

		// need to alloc receive buffer?
		*ppBuffer = SP_MemAlloc(dwMessageSize);
        if (!*ppBuffer)
        {
        	DPF_ERR("could not alloc stream receive buffer - out of memory");        
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
		*pdwBufferSize = dwMessageSize;
	}
	// make sure receive buffer can hold data
	else if (dwMessageSize > *pdwBufferSize) 
	{
		LPVOID pvTemp;

		DPF(8, "ReAllocating space for message of size %d", dwMessageSize);

		// realloc buffer to hold data
		pvTemp = SP_MemReAlloc(*ppBuffer,dwMessageSize);
		if (!pvTemp)
		{
        	DPF_ERR("could not realloc stream receive buffer - out of memory");
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
		}
		*ppBuffer = pvTemp;
		*pdwBufferSize = dwMessageSize;
	}

    // fall through
    
CLEANUP_EXIT: 
    
	LEAVE_DPSP();
    return hr;    
    
}  // MakeBufferSpace

// is this sockaddr local to this machine?
BOOL IsLocalIP(SOCKADDR_IN sockaddr)
{
	PHOSTENT phostent;
	IN_ADDR hostaddr;
	HRESULT hr = DP_OK;
	int i;

	phostent = GetHostAddr();
	if (NULL == phostent) 
	{
		return FALSE;
	}

	i=0;
	while (phostent->h_addr_list[i])
	{
		memcpy(&hostaddr,phostent->h_addr_list[i],sizeof(hostaddr));
		if (hostaddr.s_addr == sockaddr.sin_addr.s_addr )
		{
			return TRUE;
		}
		i++;
	}

	return FALSE;
}  // IsLocalIP

// adds socket to our send list
HRESULT AddSocketToBag(LPGLOBALDATA pgd, SOCKET socket, DPID dpid, SOCKADDR *psockaddr, DWORD dwFlags)
{
	UINT i=0;
	BOOL bFound = FALSE;
	BOOL bTrue = TRUE;
	HRESULT hr=DP_OK;
		
	ASSERT(psockaddr);

	ENTER_DPSP();

	// see if we can find an empty slot
	i=0;
	while (( i < pgd->nSocketsInBag) && !bFound)
	{
		if (INVALID_SOCKET == pgd->BagOSockets[i].sSocket) bFound = TRUE;
		else i++;
	}
	if (!bFound)	
	{
		// no space. bummer
		DPF(5,"no space in bag o' sockets. slowness ensues");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	DPF(5,"adding new socket to bag for id = %d, slot = %d",dpid,i);
	DEBUGPRINTSOCK(7, "Adding socket to bag - ",&socket);
	
	pgd->BagOSockets[i].dwPlayerID = dpid;	
	pgd->BagOSockets[i].sSocket = socket;
	pgd->BagOSockets[i].sockaddr = *psockaddr;
	pgd->BagOSockets[i].dwFlags = dwFlags;

	// fall through

CLEANUP_EXIT:
	LEAVE_DPSP();
	return hr;
}

void FreeConnection(LPCONNECTION pConnection)
{
	if (pConnection->pBuffer && (pConnection->pBuffer != pConnection->pDefaultBuffer)) 
	{
		SP_MemFree(pConnection->pBuffer);
		pConnection->pBuffer = NULL;
	}
	if (pConnection->pDefaultBuffer) 
	{
		SP_MemFree(pConnection->pDefaultBuffer);
		pConnection->pDefaultBuffer = NULL;
	}

	// initialize connection 
    pConnection->socket = INVALID_SOCKET; // this tells us if connection is valid
	pConnection->dwCurMessageSize = 0;
	pConnection->dwTotalMessageSize = 0;
	pConnection->dwFlags = 0;
}


HRESULT AddSocketToReceiveList(LPGLOBALDATA pgd,SOCKET sSocket,DWORD dwFlags)
{
    UINT i = 0;
    UINT err, iNewSlot;
	BOOL bFoundSlot = FALSE;
    HRESULT hr = DP_OK;
    INT addrlen=sizeof(SOCKADDR);
	LPCONNECTION pNewConnection=NULL;
	DWORD dwCurrentSize,dwNewSize;
    
    ENTER_DPSP();
	
    // look for an empty slot 
    while ( (i < pgd->ReceiveList.nConnections) && !bFoundSlot)
    {
    	if (INVALID_SOCKET == pgd->ReceiveList.pConnection[i].socket)
    	{
    		bFoundSlot = TRUE;			
			iNewSlot = i;
    	}
        else 
        {
        	i++;
        }
    }
    
    {
      // Turn on keepalive on all inbound sockets so if the remote
      // goes away without exiting cleanly, we will (eventually) dump the socket.
      // (AO 2/17/00)
      
   		// All our sockets have KEEPALIVE...
  		BOOL bTrue = TRUE;

  		// turn ON keepalive
  		if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
  		{
  				err = WSAGetLastError();
  				DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
  		}
    }

    if (!bFoundSlot)
    {		
		// allocate space for list of connections
		dwCurrentSize = pgd->ReceiveList.nConnections * sizeof(CONNECTION);
		dwNewSize = dwCurrentSize +  INITIAL_RECEIVELIST_SIZE * sizeof(CONNECTION);		
		hr =  MakeBufferSpace((LPBYTE *)&(pgd->ReceiveList.pConnection),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // set all the new entries to INVALID
        for (i = pgd->ReceiveList.nConnections + 1; 
        	i < pgd->ReceiveList.nConnections + INITIAL_RECEIVELIST_SIZE; i++ )
        {
        	pgd->ReceiveList.pConnection[i].socket = INVALID_SOCKET;
        }
        
        // store the new socket in the 1st new spot
		iNewSlot = pgd->ReceiveList.nConnections;

        // allocate space for an fd set (fd_count + fd_array)
		if (pgd->ReceiveList.nConnections)
		{
	        dwCurrentSize = sizeof(u_int) + pgd->ReceiveList.nConnections * sizeof(SOCKET);
	        dwNewSize =	dwCurrentSize + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		else
		{
			dwCurrentSize = 0;
			dwNewSize = sizeof(u_int) + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		hr =  MakeBufferSpace((LPBYTE *)&(pgd->readfds.pfdbigset),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // update the # of connections
        pgd->ReceiveList.nConnections += INITIAL_RECEIVELIST_SIZE; 
		// update the fd_array buffer size
		pgd->readfds.dwArraySize = pgd->ReceiveList.nConnections;
        
    } // !bFoundSlot

	// we have a space holder for a connection when we get here
	
	// Initialize new connection 
	pNewConnection = &(pgd->ReceiveList.pConnection[iNewSlot]);
    pNewConnection->socket = sSocket;
    pNewConnection->dwFlags = dwFlags;

	if(dwFlags != SP_STREAM_ACCEPT){

		// allocate a default receive buffer if don't have one already
	    if (!pNewConnection->pDefaultBuffer)
	    {
	    	pNewConnection->pDefaultBuffer = SP_MemAlloc(DEFAULT_RECEIVE_BUFFERSIZE);
	    	if (!pNewConnection->pDefaultBuffer)
			{
				hr = DPERR_OUTOFMEMORY;
			    DPF_ERR("could not alloc default receive buffer - out of memory");        
				goto ERROR_EXIT;
			}
	    }
	    
		// receive buffer initially points to our default buffer
		pNewConnection->pBuffer = pNewConnection->pDefaultBuffer;
		
		// remember the address we are connected to
		err = getpeername(pNewConnection->socket, &(pNewConnection->sockAddr), &addrlen);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			DPF(1,"could not getpeername err = %d\n",err);
		}

		DEBUGPRINTADDR(8, "Socket is connected to address - ",&(pNewConnection->sockAddr));

	}
	
	LEAVE_DPSP();

	DPF(5, "Added new socket at index %d", iNewSlot);


	// success
	return DP_OK;

	// not a fall through
	
ERROR_EXIT:

	if (pNewConnection)
	{
		KillSocket(pNewConnection->socket,TRUE,FALSE);
		FreeConnection(pNewConnection);
	}
	LEAVE_DPSP();
    return hr;
    
}  // AddSocketToReceiveList

// updates the player associated with a socket in the send list
void UpdateSocketPlayerID(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, DPID dpidPlayer)
{
	UINT i=0;
	IN_ADDR *pIPCurrent, *pIPFind;
	BOOL bFound = FALSE;

	ASSERT(pSockAddr);

	DEBUGPRINTADDR(8, "Updating player id for socket connected to - ",pSockAddr);

	ENTER_DPSP();

	while (!bFound && (i < pgd->nSocketsInBag))
    {
		pIPCurrent = &(((SOCKADDR_IN *)&pgd->BagOSockets[i].sockaddr)->sin_addr);
		pIPFind = &(((SOCKADDR_IN *)pSockAddr)->sin_addr);

		// todo - we are only comparing the IP here, need to look at the complete socket address
		if ((INVALID_SOCKET != pgd->BagOSockets[i].sSocket) && 
			!memcmp(pIPCurrent, pIPFind, sizeof(IN_ADDR)))
    	{			
			bFound = TRUE;
			// update the player id
			pgd->BagOSockets[i].dwPlayerID = dpidPlayer;
    	}

    	i++;
    }

    LEAVE_DPSP();

    return;
}

BOOL FindSocketInReceiveList(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket)
{
	UINT i=0;
	IN_ADDR *pIPCurrent, *pIPFind;
	BOOL bFound = FALSE;

	ASSERT(psSocket);

	ENTER_DPSP();

	while (!bFound && (i < pgd->ReceiveList.nConnections))
    {
		pIPCurrent = &(((SOCKADDR_IN *)&pgd->ReceiveList.pConnection[i].sockAddr)->sin_addr);
		pIPFind = &(((SOCKADDR_IN *)pSockAddr)->sin_addr);

		// todo - we are only comparing the IP here, need to look at the complete socket address
		if ((INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket) && 
			!memcmp(pIPCurrent, pIPFind, sizeof(IN_ADDR)))
    	{
			*psSocket = pgd->ReceiveList.pConnection[i].socket;
			bFound = TRUE;
    	}

    	i++;
    }

    LEAVE_DPSP();
    
	return bFound;
}

BOOL FindSocketInBag(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket, LPDPID lpdpidPlayer)
{
	UINT i=0;
	IN_ADDR *pIPCurrent, *pIPFind;
	BOOL bFound = FALSE;

	ASSERT(psSocket);
	ASSERT(lpdpidPlayer);

	ENTER_DPSP();
	

	while (!bFound && (i < pgd->nSocketsInBag))
    {
		pIPCurrent = &(((SOCKADDR_IN *)&pgd->BagOSockets[i].sockaddr)->sin_addr);
		pIPFind = &(((SOCKADDR_IN *)pSockAddr)->sin_addr);

		if ((INVALID_SOCKET != pgd->BagOSockets[i].sSocket) &&
			!memcmp(pIPCurrent, pIPFind, sizeof(IN_ADDR)))
		{
			*psSocket = pgd->BagOSockets[i].sSocket;
			*lpdpidPlayer = pgd->BagOSockets[i].dwPlayerID;

			DPF(8, "Found socket in send list for id %d", *lpdpidPlayer);
			bFound = TRUE;
    	}

    	i++;
    }

    LEAVE_DPSP();
    
	return bFound;
}

void RemoveSocketFromBag(LPGLOBALDATA pgd, SOCKET socket)
{
	BOOL bFound = FALSE;
	UINT i=0;
	
	ENTER_DPSP();

    // look for the socket
    while (!bFound && (i < pgd->nSocketsInBag))
    {
    	if (socket == pgd->BagOSockets[i].sSocket)
    	{
			pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
			bFound = TRUE;
    	}
        else 
        {
        	i++;
        }
    } // while

	LEAVE_DPSP();
}

void RemoveSocketFromReceiveList(LPGLOBALDATA pgd, SOCKET socket)
{
    UINT i = 0;
	BOOL bFound = FALSE;
	SOCKET sSocket=INVALID_SOCKET;
	DWORD dwSocketFlags=0;

    ENTER_DPSP();
    
    // look for the corresponding connection
    while ( !bFound && (i < pgd->ReceiveList.nConnections))
    {
    	if (socket == pgd->ReceiveList.pConnection[i].socket)
    	{
			DEBUGPRINTSOCK(8, "Removing socket from receive list - ", &socket);
			socket = pgd->ReceiveList.pConnection[i].socket;			
			dwSocketFlags = pgd->ReceiveList.pConnection[i].dwFlags;
			FreeConnection(&pgd->ReceiveList.pConnection[i]);
			bFound = TRUE;
    	}
        else 
        {
        	i++;
        }
    } // while
    
    LEAVE_DPSP();
	
	if (bFound)
	{
		KillSocket(socket, TRUE, FALSE);
		if (dwSocketFlags & SP_CONNECTION_FULLDUPLEX)
			RemoveSocketFromBag(pgd,sSocket);
	}

	return ;	
	
} //RemoveSocketFromReceiveList

HRESULT HandleSPMessage(IDirectPlaySP *pISP, LPGLOBALDATA pgd, LPCONNECTION pConnection)
{
	HRESULT hr;
	
	switch (SP_MESSAGE_TOKEN(pConnection->pBuffer)) 
	{		
		// VALID_SP_MESSAGE
		case TOKEN:
		{
			if (SPMESSAGEHEADERLEN == pConnection->dwTotalMessageSize)
			{
	    		// if we get a message w/ 0 size, it means we've accepted a connection
				// and need to add the new socket to our recv list...
				// basically, it's a no-op for the receive loop
				return DP_OK;
			}
			
			// now, we've read all the bits
			// store the address we received from w/ the message
			// todo - don't store address if it's a player - player message
			switch (pgd->AddressFamily)
			{
				case AF_INET:
					if (pgd->dwFlags & DPSP_OUTBOUNDONLY)
					{
						((LPMESSAGEHEADER)pConnection->pBuffer)->sockaddr = pConnection->sockAddr;
					}
					else
					{
						IP_SetAddr((LPVOID)pConnection->pBuffer,(SOCKADDR_IN *)&pConnection->sockAddr);
					}
					break;
				case AF_IPX:
					IPX_SetNodenum((LPVOID)pConnection->pBuffer,(SOCKADDR_IPX *)&pConnection->sockAddr);
					break;
				default:
					ASSERT(FALSE);
					break;
			}
			
			// pass message to dplays handler
			// need to drop the lock here...
			ASSERT( 1 == gCSCount);
			
			DPF(8, "received a complete message - handing it off to dplay");

			LEAVE_DPSP();
			
			// received a complete message - hand it off to dplay
			pISP->lpVtbl->HandleMessage(pISP, pConnection->pBuffer + sizeof(MESSAGEHEADER),
	        		pConnection->dwTotalMessageSize - sizeof(MESSAGEHEADER),pConnection->pBuffer);
			
			ENTER_DPSP();

		} 
		break;
		
 		// VALID_SERVER_MESSAGE
 		case SERVER_TOKEN:
		{
			HandleServerMessage(pgd, pConnection->socket, pConnection->pBuffer + sizeof(MESSAGEHEADER), 
	        		pConnection->dwTotalMessageSize - sizeof(MESSAGEHEADER));
	        		
		}
		break;

		// if we get this token, the sender wants us to reuse the connection
		// so put it in the send list
		case REUSE_TOKEN:
		{
			DEBUGPRINTSOCK(8, "Received reuse message on - ", &pConnection->socket);

			// we only allow reusing connections in client/server mode at this time.
			// peer-peer can't work without making inbound connections
			if (pgd->dwSessionFlags & DPSESSION_CLIENTSERVER)
			{
				DEBUGPRINTSOCK(8, "Reusing connection - ", &pConnection->socket);

				hr = AddSocketToBag(pgd, pConnection->socket, 0, &pConnection->sockAddr, 
									SP_CONNECTION_FULLDUPLEX);
				if (FAILED(hr))
				{
					DEBUGPRINTSOCK(0, "Failed to reuse connection - ",&pConnection->socket);
					return hr;
				}
			}
			else
			{
				DPF(2, "Not accepting reuse request in peer-peer");
				return E_FAIL;

			}
		}
		break;

		default:
		{
			DPF(0, "Received a message with invalid token - 0x%08x",SP_MESSAGE_TOKEN(pConnection->pBuffer));
		}
		break;
	
	} // switch

	return DP_OK;
	
} // HandleSPMessage

/*
 ** StreamReceive
 *
 *  CALLED BY: StreamReceiveThreadProc
 *
 *  PARAMETERS:
 *		sSocket - socket to receive on
 *		ppBuffer - buffer to receive into - alloc'ed / realloc'ed  as necessary
 *		pdwBuffersize - size of pBuffer
 *
 *  DESCRIPTION:
 *		pull the bytes out of sSocket until no more bytes
 *
 *  RETURNS: E_FAIL on sockerr, or DP_OK. 
 *
 */
HRESULT StreamReceive(IDirectPlaySP * pISP,LPGLOBALDATA pgd, LPCONNECTION pConnection)
{
	HRESULT hr = DP_OK;
    UINT err;
    DWORD dwBytesReceived=0;
	DWORD dwMessageSize = 0;
	LPBYTE pReceiveBuffer=NULL;
	DWORD dwReceiveBufferSize;
	
	// is it a new message ?
	if (pConnection->dwCurMessageSize == 0)
	{
		// make sure we have a buffer to recive data in
		if (!pConnection->pDefaultBuffer)
		{
			DEBUGPRINTADDR(0, "No buffer to receive data - removing connection to - ",&pConnection->sockAddr);
			goto CLEANUP_EXIT;
		}
		// receive the header first
		pConnection->dwTotalMessageSize = SPMESSAGEHEADERLEN;
	}

	// continue receiving message
	pReceiveBuffer = pConnection->pBuffer + pConnection->dwCurMessageSize;
	dwReceiveBufferSize = pConnection->dwTotalMessageSize - pConnection->dwCurMessageSize;

	DPF(8,"Attempting to receive %d bytes", dwReceiveBufferSize);

   	DEBUGPRINTSOCK(8,">>> receiving data on socket - ",&pConnection->socket);

	// receive data from socket 
	// note - make exactly one call to recv after select otherwise we'll hang
	dwBytesReceived = recv(pConnection->socket, (LPBYTE)pReceiveBuffer, dwReceiveBufferSize, 0);

	if (0 == dwBytesReceived)
	{
		// remote side has shutdown connection gracefully
	   	DEBUGPRINTSOCK(8,"<<< received data on socket - ",&pConnection->socket);
		hr = DP_OK;
		DEBUGPRINTSOCK(5,"Remote side has shutdown connection gracefully - ",&pConnection->socket);
		goto CLEANUP_EXIT;
	}
	else if (SOCKET_ERROR == dwBytesReceived)
	{
		err = WSAGetLastError();

   		DEBUGPRINTSOCK(8,"<<< received data on socket - ",&pConnection->socket);
		DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
		hr = E_UNEXPECTED;            
		goto CLEANUP_EXIT;
	}

	DPF(5, "received %d bytes", dwBytesReceived);
	
	// we have received this much message so far
	pConnection->dwCurMessageSize += dwBytesReceived;

	// did we receive the header
	if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN)
	{
		// we just completed receiving message header

		// make sure its valid
		if (VALID_DPWS_MESSAGE(pConnection->pDefaultBuffer))
		{
			 dwMessageSize = SP_MESSAGE_SIZE(pConnection->pDefaultBuffer); // total message size			

#ifdef BIGMESSAGEDEFENSE
			// make sure it is not greater that the max message len
			if (dwMessageSize > pgd->dwMaxMessageSize)
			{
				DPF(0, "Got message (%d bytes) that's bigger than max allowed len (%d)! Disconnecting sender.\n",
					dwMessageSize - sizeof(MESSAGEHEADER), pgd->dwMaxMessageSize - sizeof(MESSAGEHEADER));
				ASSERT(dwMessageSize <= pgd->dwMaxMessageSize);
								
				// we want to receive another 12 bytes so that DPLAY can have
				//	something to look at to decide whether or not to continue
				//	receiving this message.  So instead of setting dwMessageSize
				//	to its real size, we fake it out.
				dwMessageSize = SPMESSAGEHEADERLEN + 12;
			}
#endif
		}
		else 
		{
			DPF(2,"got invalid message - token = 0x%08x",SP_MESSAGE_TOKEN(pConnection->pDefaultBuffer));
			ASSERT(FALSE);
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}

		// prepare to receive rest of the message (after the token)
		if (dwMessageSize) 
		{
			pConnection->dwTotalMessageSize = dwMessageSize;

			// which buffer to receive message in ?
			if (dwMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
			{
				ASSERT(pConnection->pBuffer == pConnection->pDefaultBuffer);
				// get a new buffer to fit the message
				pConnection->pBuffer = SP_MemAlloc(dwMessageSize);
				if (!pConnection->pBuffer)
				{
					DPF(0,"Failed to allocate receive buffer for message - out of memory");
					goto CLEANUP_EXIT;
				}
				// copy header into new message buffer
				memcpy(pConnection->pBuffer, pConnection->pDefaultBuffer, SPMESSAGEHEADERLEN);
			}
		}
	}
#ifdef BIGMESSAGEDEFENSE
	// this MIGHT be because the message is really huge, and we're just getting
	// enough to hand to DPLAY
	else if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN + 12)
	{
		dwMessageSize = SP_MESSAGE_SIZE(pConnection->pBuffer);
		if (dwMessageSize > pgd->dwMaxMessageSize)
		{
			DPSP_MSGTOOBIG	msgTooBigErr;
			
			// okay.  This is message is too big, and we now have enough data
			// to hand to DPLAY.  Find out if it wants us to continue receiving,
			//	or bail on this connection

			// call into DPLAY to let it do its thing
			msgTooBigErr.dwType = DPSPWARN_MESSAGETOOBIG;	
			msgTooBigErr.pReceiveBuffer = pConnection->pBuffer + sizeof(MESSAGEHEADER);
			msgTooBigErr.dwBytesReceived = pConnection->dwCurMessageSize;
			msgTooBigErr.dwMessageSize = dwMessageSize - sizeof(MESSAGEHEADER);
			
			LEAVE_DPSP();

			pISP->lpVtbl->HandleSPWarning(pISP, &msgTooBigErr, sizeof(DPSP_MSGTOOBIG), pConnection->pBuffer);
			
			ENTER_DPSP();

//			now, kill the connection
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}
	}
#endif

	// did we receive a complete message ?
	if (pConnection->dwCurMessageSize == pConnection->dwTotalMessageSize)
	{
		// process message
		hr = HandleSPMessage(pISP, pgd, pConnection);
		
		// cleanup up new receive buffer if any
		if (pConnection->dwTotalMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
		{
			DPF(8, "Releasing receive buffer of size %d", pConnection->dwTotalMessageSize);
			if (pConnection->pBuffer) SP_MemFree(pConnection->pBuffer);
		}			
		// initialize message information
		pConnection->dwCurMessageSize = 0;
		pConnection->dwTotalMessageSize = 0;
		pConnection->pBuffer = pConnection->pDefaultBuffer;

		if (FAILED(hr))
		{
			goto CLEANUP_EXIT;
		}
	}

	// all done
	return DP_OK;	
	
CLEANUP_EXIT:

	RemoveSocketFromReceiveList(pgd,pConnection->socket);
	return hr;
	 	
} // StreamReceive


void EmptyConnectionList(LPGLOBALDATA pgd)
{
	UINT i;
	
	ENTER_DPSP();
	
	for (i=0;i<pgd->ReceiveList.nConnections ;i++ )
	{
		if (INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket)
		{
			KillSocket(pgd->ReceiveList.pConnection[i].socket,TRUE,FALSE);
			FreeConnection(&(pgd->ReceiveList.pConnection[i]));
		}
	}
	
	LEAVE_DPSP();
	
	return ;
	
}  // EmptyConnectionList

// when we get a control event, we need to send a message to the control
// socket (to wake up the receive thread proc).
// this finds the ip addr of this machine to send to. 
HRESULT GetDefaultHostAddr(SOCKADDR * psockaddr)
{
    PHOSTENT phostent;
    IN_ADDR hostaddr;
	    	
    ((LPSOCKADDR_IN)psockaddr)->sin_addr.s_addr = 0;
	
    // find an ip address for this machine
    // we use the default, since all our sends are to local 
    // name servers (no homing issues)
    phostent = GetHostAddr();
    if (NULL == phostent) 
    {
        return E_FAIL;
    }
    DPF(5,"found host name %s \n",phostent->h_name);

    memcpy(&hostaddr,phostent->h_addr_list[0],sizeof(hostaddr));

    DPF(5,"GetDefaultHostAddr ::  found host addr = %s \n",inet_ntoa(hostaddr));
    
    // store the default sockaddr for this system
    ((LPSOCKADDR_IN)psockaddr)->sin_addr.s_addr = hostaddr.s_addr;
	
    return DP_OK;
	
} // GetDefaultHostAddr

// watch our list of sockets, waiting for one to have data to be received, or to be closed
DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast)
{
	HRESULT hr;
	int rval;
	UINT i = 0;
    UINT err;
    DWORD dwBufferSize = 0;    
	UINT nSelected;
	IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	TIMEVAL tv={0,250000};	// 250000 us = 1/4 sec.
	DWORD dwPrevSelectLastError=0;
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;
	}

	AddSocketToReceiveList(pgd,pgd->sSystemStreamSocket,SP_STREAM_ACCEPT);

    while (1)
    {
		ENTER_DPSP();

		ASSERT(pgd->readfds.pfdbigset);

    	// add all sockets in our recv list to readfds
		FD_ZERO(pgd->readfds.pfdbigset);
		nSelected = 0;
		for (i=0;i < pgd->ReceiveList.nConnections ; i++)
		{
        	if (INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket)
        	{
		        FD_BIG_SET(pgd->ReceiveList.pConnection[i].socket,&pgd->readfds);
				nSelected++;
        	}
		}

		LEAVE_DPSP();

		if (0 == nSelected)		
		{
			if (pgd->bShutdown)
			{
				DPF(2,"stream receive thread proc detected shutdown - bailing");
				goto CLEANUP_EXIT;
			}
			// we should have at least one?
			DPF_ERR("No sockets in receive list - missing control socket? bailing!");
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}

		// now, we wait for something to happen w/ our socket set
		rval = select(0,(fd_set *)(pgd->readfds.pfdbigset),NULL,NULL,&tv);
        if (SOCKET_ERROR == rval)
        {
        	err = WSAGetLastError();
        	if(dwPrevSelectLastError==err){
        		DPF(0,"Got two bogus last errors of(%x) from select, bailing",err);
        		goto CLEANUP_EXIT;
        	}
			// WSAEINTR is returned when a socket is shutdown behind us - this can happen
			// when a socket is removed from the receivelist
        	if (WSAEINTR != err)
			{
				dwPrevSelectLastError=err;
	            DPF(2,"StreamReceiveThreadProc failing w/ sockerr = %d\n - trying again",err);
				ASSERT(FALSE);				
	        	rval = 0; // try again...
			} else {
				dwPrevSelectLastError=0;
			}
        } else {
			dwPrevSelectLastError=0;
        }

		// shut 'em down?
        if (pgd->bShutdown)
        {
        	DPF(2,"receive thread proc detected bShutdown - bailing");
            goto CLEANUP_EXIT;
        }
        
		// a-josbor: why are we waking up with 0 events?
		// in any case, a workaround is to just go back to sleep if we have
		// no real events
		if ( rval == 0)
		{
			continue;
		}

    	DPF(5,"receive thread proc - events on %d sockets",rval);
		i = 0;
		
		ENTER_DPSP();
		
        while (rval>0)
        {
	        // walk the receive list, dealing w/ all new sockets
			if (i >= pgd->ReceiveList.nConnections)
			{
				DPF(0, "nConnections = %d, selected = %d", pgd->ReceiveList.nConnections, i);
				ASSERT(FALSE); // should never happen
				rval = 0; // just to be safe, reset
			}
            
            if (pgd->ReceiveList.pConnection[i].socket != INVALID_SOCKET)
            {
            	// see if it's in the set
                if (FD_ISSET(pgd->ReceiveList.pConnection[i].socket,pgd->readfds.pfdbigset))
                {
					DPF(8, "Receiving on socket %d from ReceiveList", i);

					if(pgd->ReceiveList.pConnection[i].dwFlags != SP_STREAM_ACCEPT){

	                	// got one! this socket has something going on...
						hr = StreamReceive(pISP, pgd, &(pgd->ReceiveList.pConnection[i]));
	                    if (FAILED(hr))
	                    {
							DPF(1,"Stream Receive failed - hr = 0x%08lx\n",hr);
	                    }
	                    
                    } else {
                    
               		    // accept any incoming connection
               		    SOCKADDR sockaddr; 
					    INT addrlen=sizeof(sockaddr);
					    SOCKET sSocket;
					    
					    sSocket = accept(pgd->sSystemStreamSocket,&sockaddr,&addrlen);
					    if (INVALID_SOCKET == sSocket) 
					    {
					        err = WSAGetLastError();
				            DPF(2,"\n stream accept error - err = %d socket = %d",err,(DWORD)sSocket);
					    } else {
						    DEBUGPRINTADDR(5,"stream - accepted connection from",&sockaddr);
							
							// add the new socket to our receive q
							hr = AddSocketToReceiveList(pgd,sSocket,0);
							if (FAILED(hr))
							{
								ASSERT(FALSE);
							}
						}	
                    }
                    rval--; // one less to hunt for
                } // IS_SET
            } // != INVALID_SOCKET

            i++;
                
   		} // while rval
		
		LEAVE_DPSP();
		
	} // while 1

CLEANUP_EXIT:

	EmptyConnectionList(pgd);
	    
    return 0;
    
} // StreamReceiveThreadProc

// send a message of 0 length telling receiver to reuse connection
HRESULT SendReuseConnectionMessage(SOCKET sSocket)
{
	DWORD dwMessage;
	HRESULT hr=DP_OK;
	UINT err;
	
	// send a 0 sized message (w/ our header) to the stream socket, to tell 
	// receive thread proc to reuse this socket for replies to us
	SetMessageHeader(&dwMessage,0,REUSE_TOKEN);
	
    err = send(sSocket,(LPBYTE)&dwMessage,sizeof(DWORD),0);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();

		// if we're shutdown, don't print a scary
		DPF(0,"SendReuseControlMessage failed with error - err = %d\n",err);
		hr = E_FAIL;
	}	

	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CreateAndConnectSocket"

// called by reliable send and DoTCPEnumSessions
HRESULT CreateAndConnectSocket(LPGLOBALDATA pgd,SOCKET * psSocket,DWORD dwType,LPSOCKADDR psockaddr, BOOL bOutBoundOnly)
{
	UINT err;
	HRESULT hr;
	int iAddrLen = sizeof(SOCKADDR);

	ASSERT(psSocket);
	
	hr = CreateSocket(pgd,psSocket,dwType,0,INADDR_ANY,&err,FALSE);
    if (FAILED(hr)) 
    {
        DPF(0,"createandconnect :: create socket failed - err = %d\n",err);
       	return hr;
    }
	
	// try to connect	
	hr = SPConnect(psSocket,(LPSOCKADDR)psockaddr,iAddrLen, bOutBoundOnly);
    if (FAILED(hr)) 
    {
        DEBUGPRINTADDR(0, "createandconnect - connect socket failed - ", psockaddr);
		goto ERROR_EXIT;
    }

	if (bOutBoundOnly)
	{
		// so we receive the reply (server will reuse the connection)
		hr = AddSocketToReceiveList(pgd, *psSocket,SP_CONNECTION_FULLDUPLEX);
		if (FAILED(hr))
		{
			DPF(0, "failed to add socket to receive list");
			goto ERROR_EXIT;
		}
	}
	
	return DP_OK;
	// not a fall through

ERROR_EXIT:
	if (INVALID_SOCKET != *psSocket)
	{
		err = closesocket(*psSocket);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			DPF(0,"send closesocket error - err = %d\n",err);
			return E_UNEXPECTED;
		}
	    *psSocket = INVALID_SOCKET;
	}

	return hr;	
	
}  // CreateAndConnectSocket


#undef DPF_MODNAME
#define DPF_MODNAME	"EnumSessions"

// starts the streamacceptthread (TCP) or the dgramlistenthreadproc (IPX) so we can 
// get replies from the nameserver for our requests
HRESULT StartupEnumThread(IDirectPlaySP * pISP,LPGLOBALDATA pgd)
{
	HRESULT hr;
	UINT err;
	DWORD dwThreadID;
	
	// set up socket
	if (AF_IPX == pgd->AddressFamily) // ipx gets dgram socket
	{
		if (pgd->hDGramReceiveThread)
		{
			return DP_OK; // already running
		}
		
		ASSERT(INVALID_SOCKET == pgd->sSystemDGramSocket);
		
	    hr = CreateSocket(pgd,&(pgd->sSystemDGramSocket),SOCK_DGRAM,0,INADDR_ANY,&err,TRUE);
		if (FAILED(hr)) 
		{
			DPF(0,"could not create enum socket - err = %d\n",err);
			return hr;
		}
		
		pgd->hDGramReceiveThread = CreateThread(NULL,0,DgramListenThreadProc,
			(LPVOID)pISP,0,&dwThreadID);
		if (!pgd->hDGramReceiveThread)
		{
			ASSERT(FALSE);
		} else SetThreadPriority(pgd->hDGramReceiveThread, THREAD_PRIORITY_ABOVE_NORMAL);
	}
	else  // everything else uses reliable
	{
		if (pgd->hStreamReceiveThread)
		{
			return DP_OK; // already running
		}
		
		// create system stream socket so we can start listening for connections
		ASSERT(INVALID_SOCKET == pgd->sSystemStreamSocket);
		hr = CreateAndInitStreamSocket(pgd); 
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			return hr;
		}

		#if USE_RSIP
			if(pgd->sRsip != INVALID_SOCKET){

				DWORD addrlen;
				SOCKADDR_IN sockaddr_in;
				SOCKADDR_IN sockaddr_inpublic;

				addrlen=sizeof(SOCKADDR_IN);
		    	err = getsockname(pgd->sSystemStreamSocket,(LPSOCKADDR)&sockaddr_in,&addrlen);
				if (SOCKET_ERROR == err)
				{
					err = WSAGetLastError();
					DPF(0,"Startup Enum thread (RSIP) could not get socket name - err = %d\n",err);
				} else {
					hr=rsipAssignPort(pgd,1,sockaddr_in.sin_port,(LPSOCKADDR)&sockaddr_inpublic,NULL);
					if(hr==DP_OK){
						memcpy(&pgd->saddrpubSystemStreamSocket, &sockaddr_inpublic, sizeof(SOCKADDR));
					} else {
						DPF(0,"Couldn't get port assignment for system stream port\n");
						memcpy(&pgd->saddrpubSystemStreamSocket, &sockaddr_in, sizeof(SOCKADDR));
					}	
				}

			}
		#endif

		// start the enum accept thread (listen for new connections)
		if(hWS2){
		    pgd->hStreamReceiveThread = CreateThread(NULL,0,FastStreamReceiveThreadProc,		   
			(LPVOID)pISP,0,&dwThreadID);
		}else{
		    pgd->hStreamReceiveThread = CreateThread(NULL,0,StreamReceiveThreadProc,		   
			(LPVOID)pISP,0,&dwThreadID);
		}
		
		if (!pgd->hStreamReceiveThread)
		{
			DPF(0, "Failed to start stream receive thread");
			ASSERT(FALSE);
		} else SetThreadPriority(pgd->hStreamReceiveThread, THREAD_PRIORITY_ABOVE_NORMAL);
	}
	
	return DP_OK;
	
} // StartupEnumThread

/*
 *		Creates a dgram socket, sends enum sessions request, and closes socket.  
 *
 *		reply is received in streamlistenthreadproc and passed into dplay.
 */
HRESULT DoUDPEnumSessions(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,
	LPDPSP_ENUMSESSIONSDATA ped)
{
	SOCKET sSocket;
	HRESULT hr;
	BOOL bTrue=TRUE;
	UINT err;

	DEBUGPRINTADDR(5,"enum unreliable - sending to ",lpSockAddr); 
	
  	hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
	if (FAILED(hr)) 
	{
		DPF(0,"!!! enum - could not create socket error = %d\n",err);
	    return E_FAIL;
	}
    
    // enable broadcast on our socket
    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_BROADCAST,(char FAR *)&bTrue,
                    sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(0,"enum - could not set broadcast err = %d\n",err);
        goto CLEANUP_EXIT;
    }

	// send out the enum message
    err = sendto(sSocket,ped->lpMessage,ped->dwMessageSize,0,lpSockAddr,dwAddrSize);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
        hr = E_UNEXPECTED;
    }

	// fall through

CLEANUP_EXIT:
	KillSocket(sSocket,FALSE,FALSE);
	return hr;
} // DoUDPEnumSessions

// A very short lived thread -- may hang in connect with invalid id to connect to.
DWORD WINAPI TCPEnumSessionsAsyncThread(LPVOID lpv)
{
	LPGLOBALDATA pgd=(LPGLOBALDATA) lpv;
	HRESULT hr;
	UINT err;


	
	DPF(8,"==> Entering TCPEnumSessionsAsyncThread(0x%08x)\n", lpv);
	
	pgd->sEnum = INVALID_SOCKET;

	DEBUGPRINTADDR(5,"enum reliable - sending to ",&pgd->saEnum); 
	
	// get us a new connection
	hr = CreateAndConnectSocket(pgd,&pgd->sEnum,SOCK_STREAM,&pgd->saEnum,pgd->bOutBoundOnly);
	if (FAILED(hr))
	{
		DPF(0, "Failed to get socket for enum sessions - hr: 0x%08x",hr);
		goto EXIT;
	}


	DPF(5, "Sending %u byte async TCP enum via socket 0x%x.",
		pgd->dwEnumMessageSize, pgd->sEnum);
	
	// send the request
    err = send(pgd->sEnum,pgd->lpEnumMessage,pgd->dwEnumMessageSize,0);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
		DEBUGPRINTADDR(0,"reliable send  - FAILED - sending to ",&pgd->saEnum);
		hr = E_FAIL;
		goto ERROR_EXIT;
		// fall through
    }

    if (!pgd->bOutBoundOnly)
    {
    	DEBUGPRINTSOCK(5,"Closing enum sessions connection - ", &pgd->sEnum);
    	// close the connection
    	KillSocket(pgd->sEnum,TRUE,FALSE);
    	pgd->sEnum=INVALID_SOCKET;
    }

	goto EXIT;
    // not a fall through

ERROR_EXIT:
	if (INVALID_SOCKET != pgd->sEnum) 	{
		KillSocket(pgd->sEnum,TRUE,FALSE);
		pgd->sEnum=INVALID_SOCKET;
	}	
EXIT:

	ENTER_DPSP();
	if(pgd->hTCPEnumAsyncThread){
		CloseHandle(pgd->hTCPEnumAsyncThread);
		pgd->hTCPEnumAsyncThread=0;
	}	
	if(pgd->lpEnumMessage){
		SP_MemFree(pgd->lpEnumMessage);
		pgd->lpEnumMessage=0;
	}
	LEAVE_DPSP();
	DPF(5,"<== Leaving TCPEnumSessionsAsyncThread\n");
	return 0;
	
} // TCPEnumSessionsAsyncThread

/*
 *		Creates a stream socket, sends enum sessions request, and closes socket 
 *		depending on bHostWillReuseConnection. If bHostWillReuseConnection is TRUE, server will
 *		close the connection after sending reply.
 *
 *		reply is received in streamlistenthreadproc and passed into dplay.
 */
HRESULT DoTCPEnumSessionsAsync(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,	
LPDPSP_ENUMSESSIONSDATA ped,BOOL bOutBoundOnly)
{
	DWORD dwJunk;
	HRESULT hr=DP_OK;

	// First see if we have a thread running already, if we do cancel it.

	KillTCPEnumAsyncThread(pgd);

	// package the request up and hand it to the thread.

	ENTER_DPSP();

	pgd->lpEnumMessage=SP_MemAlloc(ped->dwMessageSize);
	
	if(pgd->lpEnumMessage){
		memcpy(pgd->lpEnumMessage, ped->lpMessage, ped->dwMessageSize);
		pgd->dwEnumMessageSize=ped->dwMessageSize;
	} else {
		hr=DPERR_OUTOFMEMORY;
		goto EXIT;
	}

	memcpy(&pgd->saEnum,lpSockAddr,dwAddrSize);
	pgd->dwEnumAddrSize=dwAddrSize;
	pgd->bOutBoundOnly=bOutBoundOnly;
	pgd->sEnum=INVALID_SOCKET;

	if(!(pgd->hTCPEnumAsyncThread=CreateThread(NULL,0,TCPEnumSessionsAsyncThread,pgd,0,&dwJunk))){
		SP_MemFree(pgd->lpEnumMessage);
		pgd->lpEnumMessage=NULL;
		hr=DPERR_OUTOFMEMORY;
	}
	
EXIT:	
	LEAVE_DPSP();
	return hr;
}

/*
 ** EnumSessions
 *
 *  CALLED BY: DPLAY
 *
 *  PARAMETERS: ped - see dplayi.h
 *
 *  DESCRIPTION:
 *	
 *		creates a stream socket. sends a message to the address specified by the user.
 *		fills in return address so server can reply.  
 *
 *		reply is received in streamlistenthreadproc and passed into dplay.
 *
 *  RETURNS:
 *		DP_OK always.
 *
 */
HRESULT WINAPI SP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped) 
{
#ifdef DEBUG
    SOCKET sSocket; // bcast socket
#endif // DEBUG
    SOCKADDR sockaddr;
    INT addrlen=sizeof(SOCKADDR);
    HRESULT hr;
    DWORD dwErr=0;
	BOOL bTrue = TRUE;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	BOOL bOutBoundOnly = FALSE;

	DPF(5,"SP_EnumSessions");

	// get the global data
	hr =ped->lpISP->lpVtbl->GetSPData(ped->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	
	// Do we have an active IP address?  If not and DUN is enabled, a DUN
	// dialog will pop for enum to a specific machine.
	// bReturnStatus means no extra dialogs are wanted so we will abort
	// if there are no local connections.
	if (ped->bReturnStatus && AF_INET == pgd->AddressFamily)
	{
		PHOSTENT phostent = GetHostAddr();
		if (!phostent || phostent->h_addr_list[0] == 0) 
		{
			DPF(0, "No Dial-up network or netcard present");
			return DPERR_NOCONNECTION;	// no local IP address = no network
		}
	}

	memset(&sockaddr,0,sizeof(sockaddr));
	// find out where we should send request to
	hr = GetServerAddress(pgd,&sockaddr);
	if (FAILED(hr))
	{
		DPF_ERR("failed to get enumeration address");
		return hr;
	}

	if (!pgd->hReplyThread)
	{
		hr = StartReplyThread(pgd);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	hr = StartupEnumThread(ped->lpISP,pgd);
	if (FAILED(hr))
	{
		DPF(0," could not start enum handler - hr = 0x%08lx\n",hr);
		return hr;
	}
	
	// set message header
	SetMessageHeader(ped->lpMessage,ped->dwMessageSize,TOKEN);

	SetReturnAddress(ped->lpMessage,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));		
	
#ifdef DEBUG	
	sSocket = SERVICE_SOCKET(pgd); // we'll borrow this var for our debug spew
	DEBUGPRINTSOCK(5,"enum - return address = ",&sSocket); 
#endif // DEBUG

	hr = DoUDPEnumSessions(pgd, &sockaddr, addrlen, ped);
	if (FAILED(hr))
	{
		return hr;
	}

	// send a reliable enum sessions as well, duplicates will be filtered by dplay
	if ((pgd->AddressFamily == AF_INET) && (INADDR_BROADCAST != ((LPSOCKADDR_IN)&sockaddr)->sin_addr.s_addr))
	{				
		// poke the correct server port
		if (pgd->wApplicationPort)
		{
			// if app specified a port, let's use the mode specified
			// because we'll be enuming the app directly
			// ISSUE: FOR RSIP we need to get the full address and ask for the alias again.
			((LPSOCKADDR_IN)&sockaddr)->sin_port = htons(pgd->wApplicationPort);
			bOutBoundOnly = (pgd->dwFlags & DPSP_OUTBOUNDONLY);
		}
		else
		{
			// otherwise send enum to dplaysvr
			// see byte-order comment in dpsp.h for this constant
			((LPSOCKADDR_IN)&sockaddr)->sin_port = SERVER_STREAM_PORT;
			bOutBoundOnly = FALSE;
		}
		
		if(!pgd->hTCPEnumAsyncThread) {
			hr = DoTCPEnumSessionsAsync(pgd, &sockaddr, addrlen, ped, bOutBoundOnly);
		} else {
			DPF(2, "Not issuing reliable enum request, there is one already running.\n");
		}
	}
	
	// fall through

    DPF(5,"enum exiting");
    
    return DP_OK;

}// EnumSessions


#undef DPFSessions


#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetAddress"

// helper to handle local player address(es)
HRESULT WINAPI SP_GetAddressLocal(LPDPSP_GETADDRESSDATA pad)
{
	int i, j, count;
	HRESULT hr = DP_OK;
	PHOSTENT phostent;
	char *pszIPAddr, *pszBuf = NULL;
	WCHAR *pszIPAddrW, *pszBufW = NULL;
	LPDPCOMPOUNDADDRESSELEMENT paDPAddrEl = NULL;

	phostent = GetHostAddr();
	if (!phostent || !phostent->h_addr_list[0]) 
	{
		return DPERR_GENERIC;
	}

	// how many IP addresses do we have?
	for (count=0; phostent->h_addr_list[count]; count++) {}

	// allocate our DPAddress assembly buffers
	// ANSI and UNICODE elements for each IP address plus one SP guid
	// max size of IP address dot notation = 15 + terminator = 16
	ENTER_DPSP();
	// addressElement array
	paDPAddrEl = SP_MemAlloc(sizeof(DPCOMPOUNDADDRESSELEMENT)*(2*count + 1));
	// one big buffer each for ANSI and UNICODE strings
	pszIPAddr = pszBuf = SP_MemAlloc(16*count);
	pszIPAddrW = pszBufW = SP_MemAlloc(sizeof(WCHAR)*(16*count));
	if (!paDPAddrEl || !pszBuf || !pszBufW)
	{
		ASSERT(FALSE);
		SP_MemFree(paDPAddrEl);
		SP_MemFree(pszBuf);
		SP_MemFree(pszBufW);
		LEAVE_DPSP();
		return DPERR_NOMEMORY;
	}
	LEAVE_DPSP();
	
	// service provider chunk
	paDPAddrEl[0].guidDataType = DPAID_ServiceProvider;
	paDPAddrEl[0].dwDataSize = sizeof(GUID);
	paDPAddrEl[0].lpData = (LPVOID) &GUID_TCP;

	// make an ANSI and UNICODE string of each IP address
	for (i=0, j=1; i < count; i++)
	{
		DWORD dwStrLen;		// includes terminator
		IN_ADDR hostaddr;

		memcpy(&hostaddr, phostent->h_addr_list[i], sizeof(hostaddr));
		strcpy(pszIPAddr, inet_ntoa(hostaddr));
		dwStrLen = (DWORD)AnsiToWide(pszIPAddrW, pszIPAddr, 16);
		if (dwStrLen == 0 || dwStrLen > 16)
		{
			ASSERT(FALSE);
			hr = DPERR_GENERIC;
			goto cleanup;
		}

		paDPAddrEl[j].guidDataType = DPAID_INet;
		paDPAddrEl[j].dwDataSize = dwStrLen;
		paDPAddrEl[j++].lpData = pszIPAddr;
		paDPAddrEl[j].guidDataType = DPAID_INetW;
		paDPAddrEl[j].dwDataSize = dwStrLen * sizeof(WCHAR);
		paDPAddrEl[j++].lpData = pszIPAddrW;
		pszIPAddr += 16;	// bump buffer ptrs by max str size
		pszIPAddrW += 16;
	}

	// create the address
	hr = pad->lpISP->lpVtbl->CreateCompoundAddress(pad->lpISP,
				paDPAddrEl, 2*count+1, pad->lpAddress, pad->lpdwAddressSize);

cleanup:
	ENTER_DPSP();
	SP_MemFree(paDPAddrEl);
	SP_MemFree(pszBuf);
	SP_MemFree(pszBufW);
	LEAVE_DPSP();

	return hr;
} // SP_GetAddressLocal

// get the ip address of the player from its playerdata
// ask winsock to convert that to a hostname
HRESULT WINAPI SP_GetAddress(LPDPSP_GETADDRESSDATA pad)
{
	HRESULT hr = DP_OK;
	LPSPPLAYERDATA ppd;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSTR pszNetName;
	UINT nStrLen;
	LPSOCKADDR_IN psockaddr;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	DPCOMPOUNDADDRESSELEMENT addressElements[3];
	WCHAR szNetNameW[HOST_NAME_LENGTH];

	// get the global data
	hr = pad->lpISP->lpVtbl->GetSPData(pad->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	

	if (AF_IPX == pgd->AddressFamily)
	{
		// not gonna happen
		return E_NOTIMPL;
	}
	
	hr = pad->lpISP->lpVtbl->GetSPPlayerData(pad->lpISP,pad->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
	if (FAILED(hr))
	{
		DPF(1, "GetSPPlayerData for player %d returned err %d", pad->idPlayer, hr);
		if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
			ASSERT(FALSE);
		return hr;
	}

	#if USE_RSIP
		if (pad->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL && pgd->sRsip==INVALID_SOCKET)	
		{
			// We use a different approach for local players
			return SP_GetAddressLocal(pad);
		}
	#elif USE_NATHELP
		if (pad->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL && (!pgd->pINatHelp))	
		{
			// We use a different approach for local players
			return SP_GetAddressLocal(pad);
		}
	#else
		if (pad->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)	
		{
			// We use a different approach for local players
			return SP_GetAddressLocal(pad);
		}
	#endif
		else 
		{
			psockaddr = (LPSOCKADDR_IN)DGRAM_PSOCKADDR(ppd);
			if(psockaddr->sin_addr.s_addr == 0){
			    return SP_GetAddressLocal(pad);
			}
			pszNetName = inet_ntoa(psockaddr->sin_addr);
		}
	
	if (!pszNetName)
	{
		// rut ro
		DPF_ERR("got no string back from getaddress");
		return E_FAIL;
	}
	nStrLen = strlen(pszNetName)+1;

	DPF(2,"get address found address for player id %d = %s\n",pad->idPlayer,pszNetName);

	// get UNICODE version of address
	if (!AnsiToWide(szNetNameW, pszNetName, HOST_NAME_LENGTH))
		return (DPERR_GENERIC);

	// service provider chunk
	addressElements[0].guidDataType = DPAID_ServiceProvider;
	addressElements[0].dwDataSize = sizeof(GUID);
	addressElements[0].lpData = (LPVOID) &GUID_TCP;

	// ANSI name
	addressElements[1].guidDataType = DPAID_INet;
	addressElements[1].dwDataSize = nStrLen;
	addressElements[1].lpData = pszNetName;

	// UNICODE name
	addressElements[2].guidDataType = DPAID_INetW;
	addressElements[2].dwDataSize = nStrLen * sizeof(WCHAR);
	addressElements[2].lpData = szNetNameW;

	// create the address
	hr = pad->lpISP->lpVtbl->CreateCompoundAddress(pad->lpISP,
						addressElements, 3,
						pad->lpAddress, pad->lpdwAddressSize);

	return hr;

} // SP_GetAddress

#undef DPF_MODNAME
#define DPF_MODNAME	"Reply"
// called by ReplyThreadProc to send the reply out on the wire
HRESULT SendReply(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
	HRESULT hr;
	SOCKET sSocket;
	UINT addrlen = sizeof(SOCKADDR);
	UINT err;
	BOOL bConnectionExists = FALSE;

	// now, send out prd		
	switch (pgd->AddressFamily)
    {
		case AF_INET:
		{
			DPID dpidPlayer=0;

#ifdef FULLDUPLEX_SUPPORT
			// if client wants us to reuse a connection, it would have indicated so and the connection
			// would have been added to our send list by now. See if it exists.
			
			// todo - we don't want to search the receive list everytime -  find a better way
			bConnectionExists = FindSocketInBag(pgd, &prd->sockaddr, &prd->sSocket,&dpidPlayer);
#endif // FULLDUPLEX_SUPPORT
			
			if (!bConnectionExists)
			{

				// socket didn't exist in our send list, let's send it on a new temporary connection
				
				DEBUGPRINTADDR(8,"Sending reply on a new connection to - ", &(prd->sockaddr));				

				hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,0,INADDR_ANY,&err,FALSE);
				if (FAILED(hr)) 
				{
					DPF(0,"create reply socket failed - err = %d\n",err);
					return hr;
				}

				SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket,SERVICE_SADDR_PUBLIC(pgd));		
				hr = SPConnect(&sSocket,(LPSOCKADDR)&(prd->sockaddr),addrlen,FALSE);
				if (FAILED(hr))
				{
					DEBUGPRINTADDR(0,"reply - connect failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
				}
				else 
				{
					DPF(5, "Sending %u byte reply via socket 0x%x.",
						prd->dwMessageSize, sSocket);
					DEBUGPRINTADDR(5,"Replying over new connection to - ", &(prd->sockaddr));
					
					err = send(sSocket,prd->lpMessage,prd->dwMessageSize,0);					
					if (SOCKET_ERROR == err) 
				    {
				        err = WSAGetLastError();
				        DPF(0,"reply - send error - err = %d\n",err);
						hr = E_FAIL;
				    }
				}
				
				// nuke the socket
				KillSocket(sSocket,TRUE,FALSE);
				
			}
			else
			{
				DPF(5, "Sending %u byte reply via socket 0x%x.",
					prd->dwMessageSize, prd->sSocket);
				DEBUGPRINTADDR(5, "Sending reply over existing connection to - ", &(prd->sockaddr));				

				err = send(prd->sSocket,prd->lpMessage,prd->dwMessageSize,0);					
				if (SOCKET_ERROR == err) 
				{
				       err = WSAGetLastError();
				       DPF(0,"reply - send error - err = %d\n",err);
					hr = E_FAIL;
				}

				// close the connection if it's a temporary one (no player id yet).
				if (0 == dpidPlayer)
				{
					RemoveSocketFromReceiveList(pgd,prd->sSocket);
					RemoveSocketFromBag(pgd,prd->sSocket);
				}
			}
			
			break;
		}

		case AF_IPX:
		{
			hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
			if (FAILED(hr)) 
			{
				DPF(0,"create reply socket failed - err = %d\n",err);
				return hr;
			}

			SetReturnAddress(prd->lpMessage,pgd->sSystemDGramSocket,DGRAM_SADDR_RSIP(pgd));		
    		err = sendto(sSocket,prd->lpMessage,prd->dwMessageSize,0,
				(LPSOCKADDR)&(prd->sockaddr),addrlen);
			if (SOCKET_ERROR == err) 
		    {
		        err = WSAGetLastError();
		        DPF(0,"reply - send error - err = %d\n",err);
				hr = E_FAIL;
		    }

			// nuke the socket
			KillSocket(sSocket,FALSE,FALSE);

			break;
		}
	
		default:
			hr = E_FAIL;		
			ASSERT(FALSE);
			break;
    }  
	
	return hr;
	
} // SendReply


DWORD WINAPI ReplyThreadProc(LPVOID pvCast)
{
	LPREPLYLIST prd,prdNext;
	HRESULT hr=DP_OK;
	DWORD dwRet;
	DWORD tWait;
	LPGLOBALDATA pgd = (LPGLOBALDATA) pvCast;
	
	#if (USE_RSIP || USE_NATHELP)
	DWORD tLast;
	DWORD tNow;
	#define RSIP_RENEW_TEST_INTERVAL 60000
	#endif

	#if (USE_RSIP || USE_NATHELP)
		tNow=timeGetTime();
		tLast=tNow;
	#endif

	
	while (1)
	{
	
		#if (USE_RSIP || USE_NATHELP)
		wait:
			tWait=(tLast+RSIP_RENEW_TEST_INTERVAL)-tNow;
			if((int)tWait < 0){
				tWait=0;
			}
			ASSERT(!(tWait &0x80000000));
		#else
			tWait=INFINITE;
		#endif

		// wait on our event.  when it's set, we either split, or empty the reply list
		dwRet = WaitForSingleObject(pgd->hReplyEvent,tWait);

		#if (USE_RSIP || USE_NATHELP)
			tNow=timeGetTime();
			if(dwRet == WAIT_TIMEOUT){

				#if USE_RSIP
					if(pgd->sRsip != INVALID_SOCKET){
						tLast=tNow;
						rsipPortExtend(pgd, tNow);
						rsipCacheClear(pgd, tNow);
						goto wait; // back to waiting...
					} else {
						tLast=tNow;
						goto wait;
					}
				#endif	

				#if USE_NATHELP
					if(pgd->pINatHelp){
						natExtend(pgd);
						goto wait; // back to waiting...
					} else {
						tLast=tNow;
						goto wait;
					}
				#endif
			}	
		#endif

		if (WAIT_OBJECT_0 != dwRet)
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}

		// shutdown?		
		if (pgd->bShutdown)
		{
			goto CLEANUP_EXIT;
		}

	Top:
		// find our reply node
		ENTER_DPSP();
		
		// take the first one off the list
		prd = pgd->pReplyList;		
		if (pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
		
		LEAVE_DPSP();
		
		while (prd)
		{
			hr = SendReply(pgd,prd);
			if (FAILED(hr))
			{
				DPF_ERR("SendReply failed hr = 0x%08lx\n");
				// we can't reach the guy, clean out other async sends.
				RemovePendingAsyncSends(pgd, prd->dwPlayerTo);
				goto Top;
			}
			
			// free up the reply node
			ENTER_DPSP();
				
			if (prd->lpMessage) SP_MemFree(prd->lpMessage);
			SP_MemFree(prd);

			// take the next one off the list
			prd = pgd->pReplyList;
			if (pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
				
			LEAVE_DPSP();
		}

	} // 1

CLEANUP_EXIT:
	
	ENTER_DPSP();

	// cleanout reply list
	prd = pgd->pReplyList;	
	while (prd)
	{
		prdNext = prd->pNextReply;
		if (prd->lpMessage) SP_MemFree(prd->lpMessage);
		SP_MemFree(prd);
		prd = prdNext;
	}
	pgd->pReplyList = NULL;
	
	CloseHandle(pgd->hReplyEvent);
	pgd->hReplyEvent = 0;
	
	LEAVE_DPSP();
	
	DPF(6,"replythreadproc exit");

	return 0;
	
}  // ReplyThreadProc

HRESULT StartReplyThread(LPGLOBALDATA pgd)
{
	HANDLE hThread;
	DWORD dwThreadID;
	
	// 1st, create the event
	pgd->hReplyEvent = CreateEvent(NULL,FALSE,FALSE,NULL);	
	if (!pgd->hReplyEvent)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// now, spin the thread	
	if (hWS2 && (AF_IPX != pgd->AddressFamily))
	{
	    hThread = CreateThread(NULL,0,AsyncSendThreadProc,pgd,0,&dwThreadID);	
	}
	else 
	{
	    hThread = CreateThread(NULL,0,ReplyThreadProc,pgd,0,&dwThreadID);		
	}

	if (!hThread)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	pgd->hReplyThread = hThread;
	
	return DP_OK;
	
} // StartReplyThread

HRESULT WINAPI InternalSP_Reply(LPDPSP_REPLYDATA prd, DPID dwPlayerID)
{
    LPSOCKADDR psockaddr;
    SOCKADDR saddrlocal;
    HRESULT hr=DP_OK;
	LPMESSAGEHEADER phead;
	LPBYTE pSendBufferCopy;
	LPREPLYLIST prl,prlList;	
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;


	DPF(5, "InternalSP_Reply: Parameters: (0x%x, %u/0x%x)", prd, dwPlayerID, dwPlayerID);

	// get the global data
	hr =prd->lpISP->lpVtbl->GetSPData(prd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	
	if (prd->dwMessageSize > SPMAXMESSAGELEN)
	{
		ASSERT(FALSE); 
		return DPERR_SENDTOOBIG;
	}

	// check the header
	if (!prd->lpSPMessageHeader || !VALID_DPWS_MESSAGE(prd->lpSPMessageHeader))
	{
		DPF_ERR("	YIKES! Got invalid SP header - can't reply ");
		ASSERT(FALSE);
		return E_FAIL;
	}
    
	// get the address to reply to
	phead = (LPMESSAGEHEADER)prd->lpSPMessageHeader;
    psockaddr = &(phead->sockaddr);
    #if USE_RSIP
    	if(pgd->sRsip != INVALID_SOCKET){
    		hr=rsipQueryLocalAddress(pgd, TRUE, psockaddr, &saddrlocal);
    		if(hr==DP_OK){
    			DPF(7, "Found local alias for reply address\n");
    			psockaddr=&saddrlocal;
    			phead->sockaddr=saddrlocal;  // whack the rsip address into the reply address.
    		} else {
    			DPF(7,"No local alias found for reply address\n");
    		}
    	}
    	
    #elif USE_NATHELP
    	if(pgd->pINatHelp){
    		hr=IDirectPlayNATHelp_QueryAddress(
    					pgd->pINatHelp, 
						&pgd->INADDRANY,
						psockaddr, 
						&saddrlocal, 
						sizeof(SOCKADDR_IN), 
						DPNHQUERYADDRESS_TCP|DPNHQUERYADDRESS_CACHENOTFOUND);

    		if(hr==DP_OK){
    			DPF(7, "Found local alias for reply address\n");
    			psockaddr=&saddrlocal;
    			phead->sockaddr=saddrlocal;  // whack the rsip address into the reply address.
    		} else {
    			DPF(7,"No local alias found for reply address\n");
    		}
    	}
    #endif
	DEBUGPRINTADDR(5,"reply - sending to ",psockaddr);

    DPF(7,"reply - q'ing %d bytes hEvent = 0x%08lx\n",prd->dwMessageSize,pgd->hReplyEvent);

	// stick the message size in the message
	SetMessageHeader(prd->lpMessage,prd->dwMessageSize,TOKEN);

	if(hWS2 && (pgd->AddressFamily==AF_INET)){
		hr=FastReply(pgd, prd, dwPlayerID);
		return hr;
	}


	// build a copy of everything for our receive thread
	ENTER_DPSP();
	
	prl = SP_MemAlloc(sizeof(REPLYLIST));
	
	if (!prl)
	{
		LEAVE_DPSP();				
		DPF_ERR("could not send reply - out of memory");
		return E_OUTOFMEMORY;
	}

	
	pSendBufferCopy = SP_MemAlloc(prd->dwMessageSize);
	if (!pSendBufferCopy)
	{
		SP_MemFree(prl);
		LEAVE_DPSP();
		DPF_ERR("could not send reply - out of memory");
		return E_OUTOFMEMORY;
	}
	
	memcpy(pSendBufferCopy,prd->lpMessage,prd->dwMessageSize);
	
	prl->lpMessage = pSendBufferCopy;
	prl->dwMessageSize = prd->dwMessageSize;
	prl->sockaddr = *psockaddr;
	prl->sSocket = INVALID_SOCKET;
	// since are replies could be sent async, we need to keep track
	// of how many bytes have gone out
	prl->pbSend = pSendBufferCopy;
	prl->dwBytesLeft = prd->dwMessageSize;
	prl->dwPlayerTo=dwPlayerID; 	
	// put prl on the end of the reply list
	prlList = pgd->pReplyList;
	if (!prlList)
	{
		pgd->pReplyList = prl;	
	}
	else
	{
		// find the end
		while (prlList->pNextReply) prlList = prlList->pNextReply;
		ASSERT(!prlList->pNextReply);
		prlList->pNextReply = prl;
	}
	 
	// do we need to start the reply event?
	if (!pgd->hReplyThread)
	{
		hr = StartReplyThread(pgd);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	LEAVE_DPSP();
		
	// tell the reply event to do its thing
	SetEvent(pgd->hReplyEvent);
	
	DPF(5, "InternalSP_Reply: Return [DP_OK]");
	
    return DP_OK;
	
}	// reply

/*
 ** Reply
 *
 *  CALLED BY: DPLAY
 *
 *  PARAMETERS: prd - see dplayi.h
 *
 *  DESCRIPTION:
 *		when one of the receive loops calls into dplay, dplay may call reply.
 *		the receive loop extracts the return address out of the message, and passes
 *		it to dplay .  dplay passes this to reply (via prd), which figures out how to send the
 *		return message.
 *		
 *
 *  RETURNS:   E_FAIL on a socket error or DP_OK.
 *
 */
HRESULT WINAPI SP_Reply(LPDPSP_REPLYDATA prd)
{
	return InternalSP_Reply(prd, 0);
}



#undef DPF_MODNAME
#define DPF_MODNAME	"StartDPHelp"

// 
// if we're starting up a nameserver, register it w/ dphelp.exe
// see %MANROOT%\misc\w95help.c and %MANROOT%\ddhelp\dphelp.c
HRESULT StartDPHelp(LPGLOBALDATA pgd, USHORT port)
{
	DWORD hpid = 0, dwFlags=0;
	HRESULT	hr;

	CreateHelperProcess( &hpid );
	
	if (!hpid)
	{
		// could't start one...
		return DPERR_UNAVAILABLE;
	}

	if (!WaitForHelperStartup())
	{
		return DPERR_UNAVAILABLE;
	}
	
	hr = HelperAddDPlayServer(port);

	return hr;

}  // StartDPHelp


//
// we've just created a player of type dwFlags. 
// if it's a system player, see if we need to start up our receive thread procs
//
HRESULT StartPlayerListenThreads(IDirectPlaySP * pISP,LPGLOBALDATA pgd,DWORD dwFlags)
{
	DWORD dwThreadID;
	HANDLE hThread;
		
	if ( !(dwFlags & DPLAYI_PLAYER_SYSPLAYER) ) return DP_OK;
	
	if (!pgd->hDGramReceiveThread)
	{
		ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
	    hThread = CreateThread(NULL,0,DgramListenThreadProc,
			(LPVOID)pISP,0,&dwThreadID);
		ASSERT(hThread);
		if(pgd->hDGramReceiveThread = hThread){ // check for non-zero hThread
			SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
		}
		
	}
	if ( (AF_IPX != pgd->AddressFamily) && !(pgd->hStreamReceiveThread) )
	{		
		ASSERT(INVALID_SOCKET != pgd->sSystemStreamSocket);

		if(hWS2){
		    hThread = CreateThread(NULL,0,FastStreamReceiveThreadProc,		   
			(LPVOID)pISP,0,&dwThreadID);
		}else{
		    hThread = CreateThread(NULL,0,StreamReceiveThreadProc,		   
			(LPVOID)pISP,0,&dwThreadID);
		}
			
		ASSERT(hThread);		
		if(pgd->hStreamReceiveThread = hThread){ // check for non-zero hThread
			SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
		}
	}

	return DP_OK;
	
} // StartPlayerListenThreads
	
// create a player.  get a stream and dgram socket for it, and start their listen threads.
HRESULT WINAPI SP_CreatePlayer(LPDPSP_CREATEPLAYERDATA pcpd) 
{
    HRESULT hr=DP_OK;
	LPSPPLAYERDATA ppd, ppdpublic;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;


	DPF(6, "SP_CreatePlayer: Parameters: (0x%x)", pcpd);

	// get the global data
	hr =pcpd->lpISP->lpVtbl->GetSPData(pcpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (!(pcpd->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		DWORD dwSize = sizeof(SPPLAYERDATA);
		LPMESSAGEHEADER pmsg;

		hr = pcpd->lpISP->lpVtbl->GetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		if (sizeof(SPPLAYERDATA) != dwSize)
		{
			// this can happen if it's a game server supplied player
		 	DPF(6, "SP_CreatePlayer: Returning: [DP_OK] (player data size %u != %u)",
		 		sizeof(SPPLAYERDATA), dwSize);
			return DP_OK;
		}
		
		pmsg = (LPMESSAGEHEADER)pcpd->lpSPMessageHeader;
		if (!pmsg)
		{
			// this can happen if it's a game server supplied player
		 	DPF(6, "SP_CreatePlayer: Returning: [DP_OK] (no message header)");
			return DP_OK;
		}
		// make it multihomed.  we passed the received address w/ the createplayer message.
		// set the receive address on the player here.

		// if the ip addr wasn't set, this player hasn't been "homed" yet.
		// we set it here.
		if (AF_INET == pgd->AddressFamily)
		{
			IP_GetAddr((SOCKADDR_IN *)DGRAM_PSOCKADDR(ppd),(SOCKADDR_IN *)&(pmsg->sockaddr));
			IP_GetAddr((SOCKADDR_IN *)STREAM_PSOCKADDR(ppd),(SOCKADDR_IN *)&(pmsg->sockaddr));
			
#ifdef FULLDUPLEX_SUPPORT
			// if client want's us to reuse a connection, the socket would have been added to the 
			// send bag already, but the id would be 0. Update the player id.
			UpdateSocketPlayerID(pgd,&pmsg->sockaddr,pcpd->idPlayer);
#endif // FULLDUPLEX_SUPPORT		
		}
		else if (AF_IPX == pgd->AddressFamily) 
		{
			IPX_GetNodenum((SOCKADDR_IPX *)DGRAM_PSOCKADDR(ppd),(SOCKADDR_IPX *)&(pmsg->sockaddr));
			IPX_GetNodenum((SOCKADDR_IPX *)STREAM_PSOCKADDR(ppd),(SOCKADDR_IPX *)&(pmsg->sockaddr));
		}

		hr = GetSPPlayerData(pgd, pcpd->lpISP, pcpd->idPlayer, &ppd, &dwSize); // Force LOCAL_DATA to get set.
	 	if (hr != DP_OK)
	 	{
	 		DPF(0, "Failed setting SP player data (err = 0x%lx)!  Ignoring.", hr);
	 	}

 		DPF(6, "SP_CreatePlayer: Returning: [DPN_OK] (not local player)");
		
		return DP_OK;
	} // !Local

	// it's local, so get it some sockets + threads if we need to

	// alloc the sp player data for this player
	ENTER_DPSP();
	
	ppd = SP_MemAlloc(sizeof(SPPLAYERDATA));
	
	LEAVE_DPSP();
	
	if (!ppd) 
	{
		DPF_ERR("could not alloc player data struct");
		return E_OUTOFMEMORY;
	}

	hr =  CreatePlayerDgramSocket(pgd,ppd,pcpd->dwFlags);
	if (FAILED(hr))
	{
		DPF_ERR("could not create dgram socket"); 
		goto CLEANUP_EXIT;
	}

	if (AF_IPX != pgd->AddressFamily)
	{
		hr =  CreatePlayerStreamSocket(pgd,ppd,pcpd->dwFlags);
		if (FAILED(hr))
		{
			DPF_ERR("could not create stream socket"); 
			goto CLEANUP_EXIT;
		}
	}

	#if USE_RSIP
		if(pgd->sRsip != INVALID_SOCKET){

			SPPLAYERDATA pdpublic;
			DWORD dwBindId;

			ppdpublic=&pdpublic;
		
			// Get a public address for the datagram and stream sockets
			hr=rsipAssignPort(pgd, 
							  0, /* UDP */
							  ((SOCKADDR_IN *)&ppd->saddrDatagram)->sin_port, 
							  &ppdpublic->saddrDatagram, 
							  &dwBindId);
			if(hr!=DP_OK){
				ASSERT(FALSE);
				goto CLEANUP_EXIT;
			}

							  
			hr=rsipAssignPort(pgd, 
							  1, /* TCP */
							  ((SOCKADDR_IN *)&ppd->saddrStream)->sin_port, 
							  &ppdpublic->saddrStream, 
							  NULL);


			if(hr!=DP_OK){
				rsipFreePort(pgd, dwBindId);
				ASSERT(FALSE);
				goto CLEANUP_EXIT;
			}

			if( (((PSOCKADDR_IN)(&ppdpublic->saddrDatagram))->sin_addr.s_addr == 0) ||
			   (((PSOCKADDR_IN)(&ppdpublic->saddrStream))->sin_addr.s_addr == 0) )
			{
				// rsip server not really working (not yet dialed), so backoff to old behaviour

				// store the ppd

				DPF(0,"RSIP service present but not dialed, acting as though no RSIP present\n");
				//we actually don't want to close the connection, because there may be a host or other
				//clients on this segment that ARE registered with the RSIP agent (which still operates
				//for lookups even when the Internet connection is down).  So by keeping the RSIP
				//control channel active we can still join and play with local players that started up
				//while the NAT was connected to the internet.
				
				//rsipCloseConnection(pgd);  -- actually lets not close the connection (see above).

				goto non_rsip;
				
			} else {   


				// store the ppdpublic, these are the addresses that will go in the name table as the address of the player
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppdpublic,dwSize,DPSET_REMOTE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}

				// store the ppd locally so we can remember the local addresses if we need it.
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_LOCAL);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}

				// remember these addresses for sends requiring a return address.
				memcpy(&pgd->saddrpubSystemDGramSocket, &ppdpublic->saddrDatagram, sizeof(SOCKADDR));
				memcpy(&pgd->saddrpubSystemStreamSocket, &ppdpublic->saddrStream, sizeof(SOCKADDR));
				}	
			
		} else {

	non_rsip:	
			// store the ppd
			hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_REMOTE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				goto CLEANUP_EXIT;
			}
		}
		
	#elif USE_NATHELP // NOT USING RSIP

		if(pgd->pINatHelp){

			SPPLAYERDATA pdpublic;
			ppdpublic = &pdpublic;

			// in the NATHELP case the public aliases are already filled in (we might want to verify that though).
			ppdpublic->saddrStream   = pgd->saddrpubSystemStreamSocket;
			ppdpublic->saddrDatagram = pgd->saddrpubSystemDGramSocket;

			if( (((PSOCKADDR_IN)(&ppdpublic->saddrDatagram))->sin_addr.s_addr == 0) ||
			   (((PSOCKADDR_IN)(&ppdpublic->saddrStream))->sin_addr.s_addr == 0) )
			{
				// rsip server not really working (not yet dialed), so backoff to old behaviour

				// store the ppd

				DPF(0,"RSIP service present but not dialed, acting as though no RSIP present\n");
				//we actually don't want to close the connection, because there may be a host or other
				//clients on this segment that ARE registered with the RSIP agent (which still operates
				//for lookups even when the Internet connection is down).  So by keeping the RSIP
				//control channel active we can still join and play with local players that started up
				//while the NAT was connected to the internet.
				
				//rsipCloseConnection(pgd);  -- actually lets not close the connection (see above).

				goto non_nathelp;
				
			} else {	

				// store the ppdpublic, these are the addresses that will go in the name table as the address of the player
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppdpublic,dwSize,DPSET_REMOTE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}

				// store the ppd locally so we can remember the local addresses if we need it.
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_LOCAL);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}
				
			}
			
		} else {
		non_nathelp:	
				// store the ppd
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_REMOTE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}
		}
	
	#else
	
		// store the ppd
		hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_REMOTE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}
	#endif // USE_RSIP
	
	// see if we need to start listen thread for this player type.
	hr = StartPlayerListenThreads(pcpd->lpISP,pgd,pcpd->dwFlags);
	
	// if we need ddhelp, start it up
	if ((AF_IPX != pgd->AddressFamily) && (pcpd->dwFlags & DPLAYI_PLAYER_NAMESRVR))
	{
		// it's ok to pass dgram port to dplaysvr always - we use the same number for stream
		// socket as well
	    hr = StartDPHelp(pgd,IP_DGRAM_PORT(ppd));
	    if (FAILED(hr))
	    {
			// ddhelp.exe barfed
	    	DPF_ERR(" CREATE SERVER - COULD NOT START ENUM LISTEN APPLICATION");
			DPF_ERR(" GAME WILL PLAY - BUT WILL NOT RECEIVE ENUMSESSIONS REQUESTS");
			goto CLEANUP_EXIT;
	    }
	    
		#if USE_RSIP
		//if(pgd->sRsip!=INVALID_SOCKET){
		//	rsipListenPort(pgd, FALSE, SERVER_DGRAM_PORT, NULL, &pgd->dwBindDGEnumListener);
		//}
		#endif

	}

	// fall through to clean up
CLEANUP_EXIT:	

	ENTER_DPSP();
	
	if (ppd) SP_MemFree(ppd);
	
	LEAVE_DPSP();
	
 	DPF(6, "SP_CreatePlayer: Returning: [0x%lx] (cleanup exit)", hr);
	
    return hr;

} // CreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME	"RemovePlayerFromSocketBag"
void RemovePlayerFromSocketBag(LPGLOBALDATA pgd,DWORD dwID)
{
	UINT i=0;
	BOOL bFound = FALSE;
	SOCKET sSocket=INVALID_SOCKET;
	DWORD dwSocketFlags;
	
	if (0 == dwID)
	{
		return;
	}

	ENTER_DPSP();

	// see if we've got one
	while (!bFound && (i<pgd->nSocketsInBag))
	{
		if (pgd->BagOSockets[i].dwPlayerID == dwID) 
		{
			bFound = TRUE;
			sSocket = pgd->BagOSockets[i].sSocket;			
			dwSocketFlags = pgd->BagOSockets[i].dwFlags;
			
			DPF(5,"removing socket from bag id = %d, slot = %d",dwID,i);
			pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
			pgd->BagOSockets[i].dwPlayerID = 0;
		}
		else i++;
	}

	LEAVE_DPSP();
	
	if (bFound)	
	{
		if (INVALID_SOCKET == sSocket) return ;

		// if socket is fullduplex, remove it from the receive list as well
		if (dwSocketFlags & DPSP_OUTBOUNDONLY)
		{
			// this function will kill the socket as well
			RemoveSocketFromReceiveList(pgd,sSocket);
		}
		else
		{		
			KillSocket(sSocket,TRUE,FALSE);
		}
	}

	return ;
	
} // RemovePlayerFromSocketBag

HRESULT WINAPI SP_DeletePlayer(LPDPSP_DELETEPLAYERDATA pdpd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	DWORD sleepcount=0;


	DPF(6, "Entering SP_DeletePlayer, player %d, flags 0x%x, lpISP 0x%08x\n",
		pdpd->idPlayer, pdpd->dwFlags, pdpd->lpISP);
	
	// get the global data
	hr =pdpd->lpISP->lpVtbl->GetSPData(pdpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// give the reply list 5 seconds to clear out
	while(bAsyncSendsPending(pgd, pdpd->idPlayer)){
		Sleep(100);
		if(sleepcount++ == 50){
			break;
		}
	}

	RemovePendingAsyncSends(pgd, pdpd->idPlayer);

	// if it's not local, we don't care
	if (!(pdpd->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		if(hWS2 && pgd->AddressFamily == AF_INET){
			#if 0
			PPLAYERCONN pConn;
			LPSPPLAYERDATA ppd;
			DWORD dwSize = sizeof(SPPLAYERDATA);

			if(pdpd->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				hr = GetSPPlayerData(pgd,pdpd->lpISP,pdpd->idPlayer,&ppd,&dwSize);
				
				EnterCriticalSection(&pgd->csFast);
				
				while(pConn = FindPlayerById(pgd, pdpd->idPlayer)){
					CleanPlayerConn(pgd, pConn, FALSE);
					DecRefConnExist(pgd, pConn); // dump existence ref
					DecRefConn(pgd, pConn); // dump find ref
				}
				if(hr==DP_OK){
					while(pConn=FindPlayerBySocket(pgd,&ppd->saddrStream)){
						CleanPlayerConn(pgd, pConn, FALSE);
						DecRefConnExist(pgd, pConn); // dump existence ref
						DecRefConn(pgd, pConn); // dump find ref
					}
					while(pConn=FindConnInPendingList(pgd,&ppd->saddrStream)){
						CleanPlayerConn(pgd, pConn, FALSE);
						DecRefConnExist(pgd, pConn); // dump existence ref
						DecRefConn(pgd, pConn); // dump find ref
					}
				}

				LeaveCriticalSection(&pgd->csFast);
			}
			#endif
		} else {
			RemovePlayerFromSocketBag(pgd,pdpd->idPlayer);
		}	
		return DP_OK;
	}
	
	// if it's not a sysplayer - we're done
	// if its a sysplayer, we kill 'em, cause we may need to rebind to a new port
	if (!(pdpd->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
	{
		return DP_OK;
	}

	if ( (pdpd->dwFlags & DPLAYI_PLAYER_NAMESRVR)  && (AF_IPX != pgd->AddressFamily) )
	{
		USHORT port;
		LPSPPLAYERDATA ppd;
		DWORD dwSize = sizeof(SPPLAYERDATA);
		 
		// we need to get the port to to delete the server 
		//hr = pdpd->lpISP->lpVtbl->GetSPPlayerData(pdpd->lpISP,pdpd->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
		hr = GetSPPlayerData(pgd,pdpd->lpISP,pdpd->idPlayer,&ppd,&dwSize);
		if ( FAILED(hr) || (sizeof(SPPLAYERDATA) != dwSize) )
		{
			ASSERT(FALSE);
		}
		else 
		{
			// tell dplaysvr to delete this server
			port = IP_DGRAM_PORT(ppd);
		    if ( !HelperDeleteDPlayServer(port) )
		    {
				// ddhelp.exe barfed
		    	DPF_ERR(" could not unregister w/ dphelp");
				// keep going...
		    }
		    #if USE_RSIP
		    	if(pgd->sRsip != INVALID_SOCKET){
		    		// NOTE: don't really need to do this since 
		    		// we only ever delete the nameserver if we are shutting
		    		// him down, and hence will close the RSIP connection releasing
		    		// all the bindings anyway
		    		//rsipFreePort(pgd, pgd->dwBindDGEnumListener);
		    	}
		    #endif
		}
	}
	
	DPF(6, "Leaving SP_DestroyPlayer, returning DPN_OK");

	return DP_OK;

} // DeletePlayer

#undef DPF_MODNAME
#define DPF_MODNAME	"UnreliableSend"
HRESULT UnreliableSend(LPDPSP_SENDDATA psd)
{
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr=DP_OK;
    UINT err;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	
	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (pgd->iMaxUdpDg && (psd->dwMessageSize >= pgd->iMaxUdpDg))
	{
		return DPERR_SENDTOOBIG;
	}

	// get to address	
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(DGRAM_PSOCKADDR(ppdTo));
    }

	// put the token + size on front of the mesage
	SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);

	if (psd->bSystemMessage) 
    {
		SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));
    } // reply
	else 
	{
		// see if we can send this message w/ no header
		// if the message is smaller than a dword, or, if it's a valid sp header (fooling us
		// on the other end, don't send any header
		if ( !((psd->dwMessageSize >= sizeof(DWORD)) &&  !(VALID_SP_MESSAGE(psd->lpMessage))) )
		{
			psd->lpMessage = (LPBYTE)psd->lpMessage +sizeof(MESSAGEHEADER);
			psd->dwMessageSize -= sizeof(MESSAGEHEADER);
		}
	}
    
	DEBUGPRINTADDR(5,"unreliable send - sending to ",&sockaddr);	

   	err = sendto(pgd->sSystemDGramSocket,psd->lpMessage,psd->dwMessageSize,0,
   		(LPSOCKADDR)&sockaddr,iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d, ignoring\n",err);
        hr = DP_OK; // ignore errors on datagram socket.
    }

// fall through...
    return hr;
        
} // UnreliableSend

#undef DPF_MODNAME
#define DPF_MODNAME	"ReliableSend"

// see if we can find or create a connected socket in our
// bag o' sockets for player dwID
HRESULT GetSocketFromBag(LPGLOBALDATA pgd,SOCKET * psSocket, DWORD dwID,
LPSOCKADDR psockaddr)
{
	HRESULT hr;
	UINT i=0;
	BOOL bFound = FALSE;
	BOOL bTrue = TRUE;
	UINT err;
	SOCKET sSocket;
	
	DPF(8, "GetSocketFromBag for id %d",dwID);

	if (0 == dwID)
	{
		// need a real id
		return E_FAIL;
	}

	ENTER_DPSP();

	// see if we've got one	already hooked up
	while ((i < pgd->nSocketsInBag) && !bFound)
	{
		// if it's a valid socket and the id's match, use it
		if ( (INVALID_SOCKET != pgd->BagOSockets[i].sSocket) && 
			(pgd->BagOSockets[i].dwPlayerID == dwID) )
		{
			bFound = TRUE;
		}
		else i++;
	}

	LEAVE_DPSP();

	if (bFound)	
	{
		// bingo! got one
		DPF(7, "Found socket in bag for player %d",dwID);
		*psSocket = pgd->BagOSockets[i].sSocket;
		return DP_OK;
	}

	// we don't have a socket for this player, let's get a new one
	DPF(5,"adding new socket to bag for id = %d, slot = %d",dwID,i);

	// create and connect socket
	hr = CreateAndConnectSocket(pgd,&sSocket,SOCK_STREAM,psockaddr, (pgd->dwFlags & DPSP_OUTBOUNDONLY));
	if (FAILED(hr))
	{
		return hr;
	}

	// enable keepalives
    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_KEEPALIVE,
		(char FAR *)&bTrue,sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(2,"create - could not turn on keepalive err = %d\n",err);
		// keep trying
    }

	hr = AddSocketToBag(pgd, sSocket, dwID, psockaddr,0);
	if (FAILED(hr))
	{
		DPF(0,"Failed to add socket to bag: hr = 0x%08x", hr);
		return hr;
	}
	DPF(7,"Created a new socket for player %d",dwID);
	
	*psSocket = sSocket ;

	return hr;
	
} // GetSocketFromBag



HRESULT ReliableSend(LPDPSP_SENDDATA psd)
{
    SOCKET sSocket = INVALID_SOCKET;
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo, ppdToPublic;
	BOOL fKillSocket = FALSE; // don't kill this socket, it's from the bago
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// get player to
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			DPF(1, "GetSPPlayerData for player %d returned err %d", psd->idPlayerTo, hr);
			if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
				ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(STREAM_PSOCKADDR(ppdTo));
    }

	if (psd->bSystemMessage) 
	{
		SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));
	}

	// put the token + size on front of the mesage
	SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);

	DEBUGPRINTADDR(5,"reliable send - sending to ",&sockaddr);

	if(hWS2 && pgd->AddressFamily == AF_INET){

		hr = FastInternalReliableSend(pgd,psd,&sockaddr);
		
	} else {
		hr = InternalReliableSend(pgd,psd->idPlayerTo,&sockaddr, psd->lpMessage, psd->dwMessageSize);
	
	}

    return hr;
    
} // InternalReliableSend

// puts together a replynode, and calls sp_reply to do 
// an async send
HRESULT AsyncSend(LPDPSP_SENDDATA psd)
{
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	MESSAGEHEADER head;
	DPSP_REPLYDATA rd;
	
	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// get player to
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(STREAM_PSOCKADDR(ppdTo));
    }

	// write the return address into the on the wire message
	SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));

	// put the token + size on front of the mesage
	SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);
	
	// set up a header.  this will be passed to reply, and will tell the reply thread
	// whre to send the message
	head.sockaddr = sockaddr;
	// put our token on the front so the reply thread knows its a valid reply
	SetMessageHeader((LPDWORD)(&head),0,TOKEN); 
	
	// use SP_Reply to send this for us...
	memset(&rd,0,sizeof(rd));
	rd.lpSPMessageHeader = &head;
	rd.lpMessage = psd->lpMessage;
	rd.dwMessageSize = psd->dwMessageSize;
   	rd.lpISP = psd->lpISP;
	
	hr = InternalSP_Reply(&rd,psd->idPlayerTo);
	
	return hr;

} // AsyncSend

#ifdef SENDEX

HRESULT WINAPI SP_GetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pgqd)
{

	LPGLOBALDATA pgd;
	DWORD        dwDataSize;
	BILINK       *pBilinkWalker;
	DWORD        dwNumMsgs = 0;
	DWORD        dwNumBytes = 0;

	LPSENDINFO lpSendInfo;
	HRESULT hr;

	hr = pgqd->lpISP->lpVtbl->GetSPData(pgqd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);

	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	EnterCriticalSection(&pgd->csSendEx);

	if(!pgqd->idFrom && !pgqd->idTo){
		// just wants totals, I already know that!
		dwNumMsgs  = pgd->dwMessagesPending;
		dwNumBytes = pgd->dwBytesPending;
	} else {
		// gotta walk the list.
		pBilinkWalker=pgd->PendingSendQ.next;
		while(pBilinkWalker != &pgd->PendingSendQ) 
		{
			lpSendInfo=CONTAINING_RECORD(pBilinkWalker, SENDINFO, PendingSendQ);
			pBilinkWalker=pBilinkWalker->next;

			if(pgqd->idTo && pgqd->idFrom) {
			
				if(lpSendInfo->idTo==pgqd->idTo && lpSendInfo->idFrom==pgqd->idFrom){
					dwNumMsgs++;
					dwNumBytes+=lpSendInfo->dwMessageSize;
				}	
				
			} else if (pgqd->idTo){
				if(lpSendInfo->idTo==pgqd->idTo){
					dwNumMsgs++;
					dwNumBytes+=lpSendInfo->dwMessageSize;
				}	
			} else if (pgqd->idFrom) {
				if(lpSendInfo->idFrom==pgqd->idFrom){
					dwNumMsgs++;
					dwNumBytes+=lpSendInfo->dwMessageSize;
				}	
			} else {
				ASSERT(0);
			}
		}
	}

	LeaveCriticalSection(&pgd->csSendEx);

	if(pgqd->lpdwNumMsgs){
		*pgqd->lpdwNumMsgs = dwNumMsgs;
	}
	if(pgqd->lpdwNumBytes){
		*pgqd->lpdwNumBytes = dwNumBytes;
	}	
	
	
	return DP_OK;

}

HRESULT WINAPI SP_SendEx(LPDPSP_SENDEXDATA psd)
{
    HRESULT hr=DP_OK;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	LPSENDINFO lpSendInfo;

	DPF(9,"==>SP_SendEx dwSize %d dwFlags %x", psd->dwMessageSize,psd->dwFlags);

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (psd->dwMessageSize >= SPMAXMESSAGELEN)
	{
		return DPERR_SENDTOOBIG;
	}

	// overlapped and SPheader buffer are allocated together.
	lpSendInfo     = pgd->pSendInfoPool->Get(pgd->pSendInfoPool);
	if(!lpSendInfo){
		hr=DPERR_OUTOFMEMORY;
		DPF(0,"WSOCK: sendex couldn't allocate overlapped, out of memory!\n");
		goto EXIT;
	}

	lpSendInfo->dwFlags = 0;
	lpSendInfo->SendArray[0].buf = (CHAR *)(lpSendInfo+1);
	lpSendInfo->SendArray[0].len = sizeof(MESSAGEHEADER);

	ASSERT(psd->cBuffers < MAX_SG-1); 
	
	memcpy(&lpSendInfo->SendArray[1], psd->lpSendBuffers, psd->cBuffers*sizeof(SGBUFFER));

	if ((psd->dwFlags & DPSEND_GUARANTEE) && (AF_IPX != pgd->AddressFamily))
    {
        hr = ReliableSendEx(psd,lpSendInfo);	
		if (hr!=DPERR_PENDING && FAILED(hr)) {
			pgd->pSendInfoPool->Release(pgd->pSendInfoPool, lpSendInfo);
			DPF(0,"reliable sendex failed - error - hr = 0x%08lx\n",hr);
		}
    }
    else
    {
    	hr = UnreliableSendEx(psd,lpSendInfo);
		if (hr!=DPERR_PENDING && FAILED(hr)) {
			pgd->pSendInfoPool->Release(pgd->pSendInfoPool, lpSendInfo);
			DPF(0,"unreliable sendex failed - error -  hr = 0x%08lx\n",hr);
		}	
    }
EXIT:
	DPF(9,"<==SP_SendEx %x",hr);
    return hr;

} // send



HRESULT ReliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo)
{
    SOCKET sSocket = INVALID_SOCKET;
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	BOOL fKillSocket = FALSE; // don't kill this socket, it's from the bago
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// get player to
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			DPF(1, "GetSPPlayerData for player %d returned err %d", psd->idPlayerTo, hr);
			if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
				ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(STREAM_PSOCKADDR(ppdTo));
    }

	if (psd->bSystemMessage) 
	{
		SetReturnAddress((pSendInfo->SendArray)[0].buf,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));
	}

	// put the token + size on front of the mesage
	SetMessageHeader((LPVOID)(pSendInfo->SendArray)[0].buf,psd->dwMessageSize+sizeof(MESSAGEHEADER),TOKEN);

	DEBUGPRINTADDR(5,"reliable send ex - sending to ",&sockaddr);

	//hr = InternalReliableSendEx(pgd,psd,pSendInfo,&sockaddr);
	hr = FastInternalReliableSendEx(pgd,psd,pSendInfo,&sockaddr);

    return hr;
    
} // ReliableSendEx

#endif //SENDEX

HRESULT InternalReliableSend(LPGLOBALDATA pgd, DPID idPlayerTo, SOCKADDR *
							lpSockAddr, LPBYTE lpMessage, DWORD dwMessageSize)
{
	HRESULT hr;
	SOCKET sSocket = INVALID_SOCKET;
	UINT err;


	DPF(6, "InternalReliableSend: Parameters: (0x%x, %u/0x%x, 0x%x, 0x%x, %u)",
		pgd, idPlayerTo, idPlayerTo, lpSockAddr, lpMessage, dwMessageSize);

	// see if we have a connection already
	hr = GetSocketFromBag(pgd,&sSocket,idPlayerTo,lpSockAddr);		
	if (SUCCEEDED(hr))
	{
		DPF(5, "Sending %u byte message via socket 0x%x from bag.",
			dwMessageSize, sSocket);
		DEBUGPRINTADDR(5, "Sending message over connection to - ", lpSockAddr);				
		
		// we do, send the message
		err = send(sSocket,lpMessage,dwMessageSize,0);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			// we got a socket from the bag.  send failed,
			// so we're cruising it from the bag
			DPF(0,"send error - err = %d\n",err);
			DPF(4,"send failed - removing socket from bag");
			RemovePlayerFromSocketBag(pgd,idPlayerTo);
			if(err==WSAECONNRESET || err==WSAENETRESET || err==WSAENOTCONN){
				hr=DPERR_CONNECTIONLOST;
			} else {
				hr = E_FAIL;
			}
		}
		
		goto EXIT;
	}

	// if we reach here, we don't have a connection so get a new one

	hr = CreateAndConnectSocket(pgd,&sSocket,SOCK_STREAM,lpSockAddr, (pgd->dwFlags & DPSP_OUTBOUNDONLY));
	if (FAILED(hr))
	{
		goto CLEANUP_EXIT;
	}

	
	DPF(5, "Sending %u byte message via new socket 0x%x.",
		dwMessageSize, sSocket);
	DEBUGPRINTADDR(5, "Sending message over connection to - ", lpSockAddr);				

	// send the message
	err = send(sSocket,lpMessage,dwMessageSize,0);
	if (SOCKET_ERROR == err) 
	{
		err = WSAGetLastError();
		DPF(0,"send error - err = %d\n",err);
		if(err == WSAECONNRESET || err==WSAENETRESET || err==WSAENOTCONN){
			hr = DPERR_CONNECTIONLOST;
		} else {
			hr = E_FAIL;
		}	
		goto CLEANUP_EXIT;
	}

	// success
	hr = DP_OK;

	// fall through

	
CLEANUP_EXIT:

	// if we are in outbound only mode, receiver will close the connection, so don't bother
	if ((INVALID_SOCKET != sSocket) && !(pgd->dwFlags & DPSP_OUTBOUNDONLY))
	{
		KillSocket(sSocket, TRUE, FALSE);
	}

	// fall through


EXIT:
	
 	DPF(6, "InternalReliableSend: Returning: [0x%lx]", hr);
	
	return hr;
}

// called when a to player can't be reached or is deleted.
VOID RemovePendingAsyncSends(LPGLOBALDATA pgd, DPID dwPlayerTo)
{
	LPREPLYLIST prl, prlPrev;
	#ifdef DEBUG
	DWORD dwBlowAwayCount=0;
	#endif
	if(!dwPlayerTo){
		return;
	}
	
	ENTER_DPSP();
	
	prlPrev = (LPREPLYLIST)(&pgd->pReplyList); // HACKHACK, treat struct as dummy node.
	prl     = pgd->pReplyList;
	
	while(prl){
		if(prl->dwPlayerTo == dwPlayerTo){
			prlPrev->pNextReply=prl->pNextReply;
			
			if(prl->sSocket != INVALID_SOCKET){
				KillSocket(prl->sSocket,TRUE,TRUE);
			}
			if(prl->lpMessage) {
				SP_MemFree(prl->lpMessage);
			}	
			SP_MemFree(prl);
			#ifdef DEBUG
			dwBlowAwayCount++;
			#endif
		} else {
			prlPrev=prl;
		}	
		prl=prlPrev->pNextReply;
		
	}
	DPF(4,"RemovePendingAsyncSends for player %x, blew away %d pending sends\n",dwPlayerTo,dwBlowAwayCount);
	LEAVE_DPSP();
}

// In order to ensure send ordering even if we are doing async sends, we 
// check and wait for any pending async sends to complete.  If they don't complete
// in 5 seconds then we make the send async.
BOOL bAsyncSendsPending(LPGLOBALDATA pgd, DPID dwPlayerTo)
{
	LPREPLYLIST prlList;

	if(!dwPlayerTo){
		return FALSE;
	}
	ENTER_DPSP();
	prlList = pgd->pReplyList;
	while(prlList){
		if(prlList->dwPlayerTo == dwPlayerTo){
			LEAVE_DPSP();
			return TRUE;
		}
		prlList=prlList->pNextReply;
	}
	LEAVE_DPSP()
	return FALSE;
}


HRESULT WINAPI SP_Send(LPDPSP_SENDDATA psd)
{
    HRESULT hr=DP_OK;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (psd->dwMessageSize >= SPMAXMESSAGELEN)
	{
		return DPERR_SENDTOOBIG;
	}

	if ((psd->dwFlags & DPSEND_GUARANTEE) && (AF_IPX != pgd->AddressFamily))
    {

		if(hWS2){
			// Fast Path...
			hr = ReliableSend(psd);
		} else 

		if (psd->dwFlags & DPSEND_ASYNC) hr = AsyncSend(psd);
        else {
        	if(bAsyncSendsPending(pgd, psd->idPlayerTo)){
        		hr = AsyncSend(psd);
        	} else {
	        	hr = ReliableSend(psd);	
	        }	
        }
        if (FAILED(hr)) DPF(0,"reliable send failed - error - hr = 0x%08lx\n",hr);
    }
    else
    {
    	hr = UnreliableSend(psd);
		if (FAILED(hr)) DPF(0,"unreliable send failed - error -  hr = 0x%08lx\n",hr);
    }

    return hr;

} // send


#ifdef SENDEX
HRESULT InitGlobalsInPlace(LPGLOBALDATA pgd)
{
	InitBilink(&pgd->PendingSendQ);
	InitBilink(&pgd->ReadyToSendQ);
	pgd->dwBytesPending=0;	
	pgd->dwMessagesPending=0;
	// Initialize the pool for send headers and overlapped stucts
	pgd->pSendInfoPool=FPM_Init(sizeof(SENDINFO)+sizeof(MESSAGEHEADER),NULL,NULL,NULL);
	
	if(!pgd->pSendInfoPool){
		goto ERROR_EXIT;
	}
	
	InitializeCriticalSection(&pgd->csSendEx);

	return DP_OK;
	
ERROR_EXIT:
	return DPERR_NOMEMORY;
}
#endif

void KillTCPEnumAsyncThread(LPGLOBALDATA pgd)
{
	HANDLE hTCPEnumAsyncThread;
	DWORD SleepCount=0;

	ENTER_DPSP();

	if(pgd->hTCPEnumAsyncThread){
	
		DPF(8,"Killing Running Async TCP enum thread\n");
		//hTCPEnumAsyncThread is 0, thread knows we are 
		//waiting for thread to finish, so we own closing 
		// the handle.
		hTCPEnumAsyncThread=pgd->hTCPEnumAsyncThread;
		pgd->hTCPEnumAsyncThread=0;

		// We need to close the socket out from under the
		// TCPEnum thread in order to have it continue and
		// exit.  So make sure the socket has been allocated
		// first, but don't wait if the thread has exited 
		// already (which is why we check lpEnumMessage.)
		while(pgd->sEnum==INVALID_SOCKET && pgd->lpEnumMessage){
			LEAVE_DPSP();
			Sleep(500);	
			ENTER_DPSP();
			if(SleepCount++ > 10 )break; // don't wait more than 5 seconds.
		}

		if(pgd->sEnum!=INVALID_SOCKET){
			if(pgd->bOutBoundOnly){
				RemoveSocketFromReceiveList(pgd,pgd->sEnum);
			} else {
				closesocket(pgd->sEnum);
			}
		}	
		LEAVE_DPSP();
		
		WaitForSingleObject(hTCPEnumAsyncThread,150*1000);
		CloseHandle(hTCPEnumAsyncThread);
		
		DPF(8,"Async enum thread is dead.\n");
	} else {
		LEAVE_DPSP();
	}	
}		

void InitGlobals(LPGLOBALDATA pgd)
{
	DPF(8, "InitGlobals: Parameters: (0x%x)", pgd);
	
	if(pgd->hTCPEnumAsyncThread){
		KillTCPEnumAsyncThread(pgd);
	}

	if(pgd->bFastSock){
		FastSockFini(pgd);
	}	

	ENTER_DPSP();

	if (pgd->BagOSockets)	
	{
		SP_MemFree(pgd->BagOSockets);
	}
	
	if (pgd->ReceiveList.pConnection)
	{
		 SP_MemFree(pgd->ReceiveList.pConnection);
	}

	if (pgd->readfds.pfdbigset)
	{
		 SP_MemFree(pgd->readfds.pfdbigset);
	}
	
#ifdef SENDEX	
	if(pgd->bSendThreadRunning){
		pgd->bStopSendThread=TRUE;
		SetEvent(pgd->hSendWait);
	}
	while(pgd->bSendThreadRunning){
		Sleep(0);
	}
	if(pgd->hSendWait){
		CloseHandle(pgd->hSendWait);
		pgd->hSendWait=NULL;
	}
	if(pgd->pSendInfoPool){
		pgd->pSendInfoPool->Fini(pgd->pSendInfoPool,0);
		DeleteCriticalSection(&pgd->csSendEx);
		//pgd->pSendInfoPool=NULL; //by memset below.
	}
#endif
	// set global data to 0	
	memset(pgd,0,sizeof(GLOBALDATA));

	// uses INVALID_SOCKET, not 0, to indicate bogus socket
	pgd->sSystemDGramSocket= INVALID_SOCKET;
	pgd->sSystemStreamSocket= INVALID_SOCKET;
#if USE_RSIP
	pgd->sRsip = INVALID_SOCKET;
#endif
#if USE_NATHELP
	pgd->pINatHelp = NULL;
#endif
#ifdef BIGMESSAGEDEFENSE
	pgd->dwMaxMessageSize = SPMAXMESSAGELEN;
#endif
	pgd->uEnumAddress = 0;

	LEAVE_DPSP();

	DPF(8, "InitGlobals: Leave");
} // InitGlobals

HRESULT WaitForThread(HANDLE hThread)
{
	DWORD dwRet;
	
	if (!hThread) return DP_OK;
	
	// we assume the thread has been told to go away
	// we wait for it to do so
	dwRet = WaitForSingleObject(hThread,INFINITE);
	if (WAIT_OBJECT_0 != dwRet)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	
	CloseHandle(hThread);
	
	return DP_OK;
} // WaitForThread

HRESULT WINAPI SP_Shutdown(LPDPSP_SHUTDOWNDATA psd) 
{
	UINT err;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	DPSP_CLOSEDATA cd;
	BOOL bFree;
	
	DPF(2," dpwsock - got shutdown!!\n");

	// get the global data
	hr = psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

#if USE_RSIP
	// Shutdown rsip channel, to save time...
	if(pgd->AddressFamily == AF_INET){
		rsipFini(pgd);
	}	
#endif
#if USE_NATHELP
	// Shutdown nat helper
	if(pgd->AddressFamily == AF_INET){
		natFini(pgd);
	}	
#endif
	
	// call close
	cd.lpISP = psd->lpISP;
	hr = SP_Close(&cd);
	if (FAILED(hr))
	{
		DPF(0," shutdown - could not close SP hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
		// rut roh!  - keep trying
	}

	// reset everything...
	InitGlobals(pgd);

	DPF(2,"shutdown, calling WSACleanup");
	// it's ok to call this for each idirectplaysp that goes away, since
	// we called WSAStartup once for each one at SPInit
    if ( SOCKET_ERROR == WSACleanup()) 
    {
		err = WSAGetLastError();
    	DPF(0,"could not stop winsock err = %d\n",err);
		// keep trying...
    }

	// if we have a winsock2, free it 
	if (hWS2)
	{
		bFree = FreeLibrary(hWS2);
		if (!bFree)
		{
			DWORD dwError = GetLastError();
			DPF(0,"SP_Shutdown - could not free ws2 library - error = %d\n",dwError);
			// keep trying
		}
		hWS2 = NULL;
	}
	

	gdwDPlaySPRefCount--;

	DPF(2,"shutdown leaving");
	return DP_OK;
	
} //Shutdown

// sp only sets fields it cares about
HRESULT WINAPI SP_GetCaps(LPDPSP_GETCAPSDATA pcd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;

	DPF(5,"SP_GetCaps");
	
	// get the global data
	hr =pcd->lpISP->lpVtbl->GetSPData(pcd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (AF_IPX == pgd->AddressFamily)
	{
		// IPX
		pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
		pcd->lpCaps->dwMaxBufferSize = IPX_MAX_DGRAM;
	}
	// else, they want AF_INET
	else 
	{
		// AF_INET optimizes guaranteed
		pcd->lpCaps->dwFlags |= DPCAPS_GUARANTEEDOPTIMIZED;
		
		if (pcd->dwFlags & DPGETCAPS_GUARANTEED)
		{
			// TCP
			pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
			pcd->lpCaps->dwMaxBufferSize = SPMAXMESSAGELEN -sizeof(MESSAGEHEADER);
			pcd->lpCaps->dwMaxPlayers = pgd->nSocketsInBag;
		}
		else 
		{
			// UDP
			pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
			pcd->lpCaps->dwMaxBufferSize = pgd->iMaxUdpDg-sizeof(MESSAGEHEADER);
		}
	}

	// set async caps flags
	if(pgd->bSendThreadRunning){
		// we are supporting async.
		pcd->lpCaps->dwFlags |= (DPCAPS_ASYNCSUPPORTED);
	}
	
	// set the timeout
	if(pcd->idPlayer){
		// we don't track player latency, so say we don't know and
		// give higher level stuff a chance to make a guess
		pcd->lpCaps->dwLatency = 0;
	} else {
		pcd->lpCaps->dwLatency = pgd->dwLatency;
	}	
	pcd->lpCaps->dwTimeout = SPTIMEOUT(pcd->lpCaps->dwLatency);

	return DP_OK;

} // SP_GetCaps

HRESULT WINAPI SP_Open(LPDPSP_OPENDATA pod) 
{
	LPMESSAGEHEADER phead;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	
	DPF(5, "SP_Open: Parameters: (0x%x)", pod);

	// get the global data
	hr =pod->lpISP->lpVtbl->GetSPData(pod->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// do we have a TCP connection?
	if (AF_INET == pgd->AddressFamily)
	{
		PHOSTENT phostent = GetHostAddr();
		if (!phostent || phostent->h_addr_list[0] == 0) 
		{
			DPF(0, "No Dial-up network or netcard present");
			return DPERR_NOCONNECTION;	// no local IP address = no network
		}
	}

	// remember session information so we know if we need to turn off nagling
	pgd->dwSessionFlags = pod->dwSessionFlags;

	if (pod->dwOpenFlags & DPOPEN_CREATE)
	{
		// host should never go into this mode
		pgd->dwFlags &= ~(DPSP_OUTBOUNDONLY);
	}
	if (!pgd->hReplyThread)
	{
		hr = StartReplyThread(pgd);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	if (pod->bCreate) 
		return DP_OK; // all done

	phead =  (LPMESSAGEHEADER)pod->lpSPMessageHeader;
	// get name server address out of phead, stores it in pgd->saddrNS
	pgd->saddrNS = phead->sockaddr;

	#if USE_RSIP
		// Get local alias for the name server (if it has one).
		if(pgd->sRsip!=INVALID_SOCKET){
        	SOCKADDR saddr;
        	HRESULT  hr;
        	hr=rsipQueryLocalAddress(pgd, TRUE, &pgd->saddrNS, &saddr);
        	if(hr==DP_OK){
        		DEBUGPRINTADDR(7, "Name Servers Socket is ",&pgd->saddrNS);
        		DEBUGPRINTADDR(7, "Got Local Alias for name server socket ",&saddr);
        		memcpy(&pgd->saddrNS, &saddr, sizeof(SOCKADDR));
        	} else {
        		DEBUGPRINTADDR(7, "Name Servers Socket has no local alias and is ",&pgd->saddrNS);
        	}
        }
    #endif    
    #if USE_NATHELP
		// Get local alias for the name server (if it has one).
		if(pgd->pINatHelp){
        	SOCKADDR saddr;
        	HRESULT  hr;
        	
			hr=IDirectPlayNATHelp_QueryAddress(
				pgd->pINatHelp, 
				&pgd->INADDRANY, 
				&pgd->saddrNS, 
				&saddr, 
				sizeof(SOCKADDR_IN), 
				DPNHQUERYADDRESS_TCP|DPNHQUERYADDRESS_CACHENOTFOUND
				);
			
        	if(hr==DP_OK){
        		DEBUGPRINTADDR(7, "Name Servers Socket is ",&pgd->saddrNS);
        		DEBUGPRINTADDR(7, "Got Local Alias for name server socket ",&saddr);
        		memcpy(&pgd->saddrNS, &saddr, sizeof(SOCKADDR));
        	} else {
        		DEBUGPRINTADDR(7, "Name Servers Socket has no local alias and is ",&pgd->saddrNS);
        	}
        }
    #endif

	// make sure we have a thread running to get the nametable
	hr = StartupEnumThread(pod->lpISP,pgd);
	if (FAILED(hr))
	{
		DPF(0," could not start open threads - hr = 0x%08lx\n",hr);
		return hr;
	}
	
	DPF(5, "SP_Open: Returning [DP_OK]");
	
	return DP_OK;

} // SP_Open


#ifdef DEBUG
// make sure there are no connected sockets left in the bug
void VerifySocketBagIsEmpty(LPGLOBALDATA pgd)
{
	UINT i=0;

	while (i < pgd->nSocketsInBag)
	{
		if (INVALID_SOCKET != pgd->BagOSockets[i].sSocket) 
		{
			DPF_ERR("socket bag not empty at close!");
			ASSERT(FALSE);
		}
		i++;
	}

} // VerifySocketBagIsEmpty
#endif // DEBUG

HRESULT WINAPI SP_Close(LPDPSP_CLOSEDATA pcd)
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	DWORD sleepcount=0;

	
	DPF(2, "SP_Close: Parameters (0x%x)", pcd);
	
	// get the global data
	hr =pcd->lpISP->lpVtbl->GetSPData(pcd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}


	// Stop asynchronous TCP enumeration thread if it's running
	KillTCPEnumAsyncThread(pgd);


	// give the reply list 5 seconds to clear out
	while(pgd->pReplyList){
		Sleep(100);
		if(sleepcount++ == 50){
			break;
		}
	}


	// reset the nameserver address
	memset(&(pgd->saddrNS),0,sizeof(SOCKADDR));

	pgd->bShutdown = TRUE;

	if(pgd->bFastSock){
		FastSockCleanConnList(pgd);
	}	

	
	DPF(2,"close, datagram sockets");
	
	KillSocket(pgd->sSystemDGramSocket,FALSE,TRUE);
	pgd->sSystemDGramSocket = INVALID_SOCKET;



	DPF(2,"Waiting for stream receive thread");

	WaitForThread(pgd->hStreamReceiveThread);
	pgd->hStreamReceiveThread = NULL;



	DPF(2,"close stream socket");

	if(pgd->sSystemStreamSocket != INVALID_SOCKET)
	{
		closesocket(pgd->sSystemStreamSocket);
		pgd->sSystemStreamSocket = INVALID_SOCKET;
		pgd->SystemStreamPort = 0;
	}
	//pgd->SystemStreamPort = 0;



	DPF(2,"close, waiting on threads");

	// signal the reply thread
	if (pgd->hReplyEvent)
	{
		SetEvent(pgd->hReplyEvent);
	}

	WaitForThread(pgd->hDGramReceiveThread);
	pgd->hDGramReceiveThread = NULL;
	
	WaitForThread(pgd->hReplyThread);
	pgd->hReplyThread = NULL;

	// if it was ipx, and the nameserver has migrated to us, we may have a spare thread 
	// we need to make sure is gone
	if (AF_IPX == pgd->AddressFamily) 
	{
		WaitForThread(pgd->hIPXSpareThread);	
		pgd->hIPXSpareThread = NULL;
	}
	
	pgd->bShutdown = FALSE;
	
#ifdef DEBUG	
	// verify that the bag o' sockets is really empty
	VerifySocketBagIsEmpty(pgd);
#endif 

	while(pgd->dwMessagesPending){
		DPF(0,"Waiting for pending messages to complete\n");
		Sleep(55);
	}

	// moved above...
	//if(pgd->bFastSock){
	//	FastSockCleanConnList(pgd);
	//}	
	
	DPF(5, "SP_Close: Returning [DP_OK]");

	return DP_OK;

} // SP_Close

#ifdef FIND_IP
//
// we get the ip addr of our host.  this is for debug purposes only.
// we never use the ip addr of our host, since it may be multihomed.
// the receiving system assigns our players their ip addresses
HRESULT DebugFindIPAddresses(void)
{
	PHOSTENT phostent;
	IN_ADDR hostaddr;
	int i;

	phostent = GetHostAddr();
	if (NULL == phostent) 
	{
		return E_FAIL;
	}
	DPF(0,"dpwsock - running on host name %s\n",phostent->h_name);

	i=0;
	while (phostent->h_addr_list[i])
	{
		memcpy(&hostaddr,phostent->h_addr_list[i],sizeof(hostaddr));
		DPF(0,"sp - found host addr = %s \n",inet_ntoa(hostaddr));
		i++;
	}

	return DP_OK;

} // DebugFindIPAddresses

#endif  // FIND_IP


/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

BOOL FAR PASCAL EnumConnectionData(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	LPGLOBALDATA pgd = (LPGLOBALDATA) lpContext;
	
	// this is an ANSI internet address
	if (IsEqualGUID(lpguidDataType, &DPAID_INet))
	{
		// make sure there is room (for terminating null too)
		if (dwDataSize > ADDR_BUFFER_SIZE)
			dwDataSize = (ADDR_BUFFER_SIZE - 1);

		// copy string for use later
		memcpy(pgd->szServerAddress, lpData, dwDataSize);

		pgd->bHaveServerAddress = TRUE;		// we have a server address
	}
	// this is a UNICODE internet address
	else if (IsEqualGUID(lpguidDataType, &DPAID_INetW))
	{
		if (WideToAnsi(pgd->szServerAddress, (LPWSTR) lpData, ADDR_BUFFER_SIZE))
			pgd->bHaveServerAddress = TRUE;	// we have a server address
	}
	else if (IsEqualGUID(lpguidDataType, &DPAID_INetPort))
	{
		pgd->wApplicationPort = *(LPWORD)lpData;
		DPF(5, "Application port specified in dp address: %d",pgd->wApplicationPort);
	}
	
#ifdef BIGMESSAGEDEFENSE
	else if (IsEqualGUID(lpguidDataType, &DPAID_MaxMessageSize))
	{
		pgd->dwMaxMessageSize = *(LPDWORD)lpData;
		ASSERT(pgd->dwMaxMessageSize > 11);	// set an arbitrary minimum
		if (pgd->dwMaxMessageSize < 12)
			pgd->dwMaxMessageSize = 12;
		DPF(5, "Max message size specified in dp address: %d",pgd->dwMaxMessageSize);
		pgd->dwMaxMessageSize += sizeof(MESSAGEHEADER);	// add a little extra for the shop
	}
#endif

	return TRUE;

} // EnumConnectionData

// nSockets was passed into spinit as dwReserved2
HRESULT InitBagOSockets(LPGLOBALDATA pgd,DWORD nSockets)
{
	UINT i;

	ENTER_DPSP();
		
	if (0 == nSockets)
	{
		pgd->nSocketsInBag = MAX_CONNECTED_SOCKETS;
	}
	else 
	{
		pgd->nSocketsInBag = nSockets;
	}
	
	pgd->BagOSockets = SP_MemAlloc(pgd->nSocketsInBag * sizeof(PLAYERSOCK));
	
	LEAVE_DPSP();
	
	if (!pgd->BagOSockets)
	{
		pgd->nSocketsInBag = 0;
		DPF_ERR("could not alloc space for socket cache - out of memory");
		return E_OUTOFMEMORY; 
	}
	
	for (i=0;i<pgd->nSocketsInBag;i++ )
	{
		pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
	}
	
	return DP_OK ;
} // InitBagOSockets

// CheckIPXInstall
// 		on win 95 gold
// 		go to control panel / network
// 		select your net card / properties
// 		select bindings tab.  unbind ipx.
// 		socket(...) call succeeds, but sendto(...) hangs.
// 		we check here that the sa_nodenum is not 0,0,0,0,0,0
// 		if it is, we will hang later, so we fail.  andyco.
//
HRESULT CheckIPXInstall(SOCKET sSocket)
{
	int cbOpt;
	UINT err;
	IPX_ADDRESS_DATA  IpxData;
  	char pSixZeros[6];
	
	if (INVALID_SOCKET == sSocket)
	{
		return E_FAIL;		
	}

	// go ask the driver for our ipx address
   	memset( &IpxData, 0, sizeof(IpxData));
	cbOpt = sizeof( IpxData );
	err = getsockopt( sSocket, NSPROTO_IPX, IPX_ADDRESS,
               (char*) &IpxData, &cbOpt );
	if (SOCKET_ERROR == err)
	{
		err = WSAGetLastError();
		DPF(0," could not test ipx getopt - err = %d\n",err);
		return E_FAIL;
	}
	
	// see if it's 0
	memset(pSixZeros,0,6*sizeof(char));	
	if (0 == memcmp(pSixZeros,&(IpxData.nodenum),6))
	{
		DPF_ERR("found invalid IPX install!");
		DPF_ERR("IPX has been improperly un-installed by unbinding from net adaptor");
		return E_FAIL;
	}
	
	return DP_OK;

} // CheckIPXInstall

// main entry point for service provider
// sp should fill in callbacks (pSD->lpCB) and do init stuff here
HRESULT WINAPI SPInit(LPSPINITDATA pSD) 
{
    HRESULT hr;
	UINT err;
	GLOBALDATA gd,*pgd;
	UINT dwSize;
	SOCKET sVerifySocket; // used to verify support for the requested address family
						  // so, if they ask for ipx, and it's not installed, we fail here 
	WORD wVersion;
	OSVERSIONINFO osInfo;
	HANDLE hAlertThread;

	// initialize global data
	memset(&gd,0,sizeof(gd));
	InitGlobals(&gd);

	ASSERT(pSD->lpGuid);
	if (IsEqualIID(pSD->lpGuid,&GUID_IPX))
	{
		DPF(0,"---------------- DPWSOCK -- RUNNING IPX -------------");
		gd.AddressFamily = AF_IPX;		
	}
	else 
	{
		if (IsEqualIID(pSD->lpGuid,&GUID_LOCAL_TCP))
		{
			gd.uEnumAddress = INADDR_BROADCAST;
			DPF(0," ** DPWSOCK -- RUNNING LOCAL TCP / IP ** ");			
		}
		else 
		{
			DPF(0," ** DPWSOCK -- RUNNING INTERNET TCP / IP ** ");
		}

		gd.AddressFamily = AF_INET;			
	}
	
	// find out what os we are running on
	memset(&osInfo,0,sizeof(osInfo));
	osInfo.dwOSVersionInfoSize = sizeof(osInfo);
	if (!GetVersionEx(&osInfo)) 
	{
		err = GetLastError();
		DPF(0,"Failed to get OS information - err = %d\n", err);
		return DPERR_GENERIC;
	}	

	DPF(0,"SPInit: Running on OS Version: %d.%d.%d\n",osInfo.dwMajorVersion, osInfo.dwMinorVersion, osInfo.dwBuildNumber&0xFFFF);

	if( (osInfo.dwMajorVersion < 4) || (osInfo.dwMajorVersion==4 && osInfo.dwMinorVersion < 90) ){
		// Win2K        5.0.2195
		// Millennium  	4.90.2xxx
		// Win98 Gold 	4.10.1998
		// Win98 SE		4.10.2222
		// not on Millennium or Win2K, so workaround sockets bug.  Use separate sockets
		// for outbound and inbound connections.
		DPF(0,"DETECTED platform before Millennium or Win2K, using separate inbound/outbound Sockets\n");
		gd.bSeparateIO=TRUE;
	}

	// I/O on just one port was NOT working, too late to fix for DX8 (ao-10/25/00), force to 2 port IO.
	// Failure was during simulataneous connect process, found on Millennium 8 player launch from zone.
	gd.bSeparateIO=TRUE; 

	// start up sockets
	if (gwsaData.wVersion)
	{
		// note - there is a bug in winsock 1.1.  if you've called WSAStartup 1x in a process,
		// then if any subsequent call asks for a version # > then that returned to the first
		// call, we get WSAEVERNOTSUPPORTED.  So, if we've already got a version in the wsadata,
		// we make sure to use that
		wVersion = gwsaData.wVersion;
		
	}
	// otherwise, ask for winsock 2.0
	else 
	{
		// if we are trying to initialize IPX on a non-NT platform, don't look for Winsock 2.0
		// Only look for Winsock 1.1 as Winsock 2.0 functionality is not supported for IPX on
		// Memphis and Win'95.
		if ((AF_IPX == gd.AddressFamily) && (VER_PLATFORM_WIN32_NT != osInfo.dwPlatformId))
			wVersion = MAKEWORD(1,1);
		else
			wVersion = MAKEWORD(2,0);
	}
	
    err = WSAStartup(wVersion, &gwsaData);
	if (WSAVERNOTSUPPORTED == err)
	{
		// they (the app) must have already called WSAStartup.  see note above 
		// about winsock 1.1 bug.
		wVersion = MAKEWORD(1,1);
	    err = WSAStartup(wVersion, &gwsaData);
	}
	if (err) 
	{
        DPF(0,"could not start winsock err = %d\n",err);
        return E_FAIL;
    }

	DPF(1,"spinit - name = %ls,dwReserved1 = %d,dwReserved2 = %d\n",pSD->lpszName,
		pSD->dwReserved1,pSD->dwReserved2);		

	gd.iMaxUdpDg = gwsaData.iMaxUdpDg;

	DPF(0,"detected winsock version %d.%d\n",LOBYTE(gwsaData.wVersion),HIBYTE(gwsaData.wVersion));	
	if (LOBYTE(gwsaData.wVersion) >= 2)
	{
		hr = InitWinsock2();
		if (FAILED(hr))
		{
			DPF_ERR("detected winsock 2, but could not init it! yikes!");
			ASSERT(FALSE);
		}
	}

	DPF(1,"\nspinit - setting latency to %d\n\n", pSD->dwReserved1);
	gd.dwLatency = pSD->dwReserved1;
	
	hr = InitBagOSockets(&gd,pSD->dwReserved2);	
	if (FAILED(hr))
	{
		DPF_ERR("could not init socket cache. bailing");
		goto ERROR_EXIT;
	}
				
	// make sure support exists for address family
    hr = CreateSocket(&gd,&sVerifySocket,SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
	if (FAILED(hr)) 
	{
		DPF(0,"	COULD NOT CREATE SOCKET IN REQUESTED ADDRESS FAMILY af = %d, err = %d\n",gd.AddressFamily,err);
		DPF(0," SERVICE PROVIDER INITIALIZATION FAILED");
		// return the same error as the modem service provider
		hr = DPERR_UNAVAILABLE;
		goto ERROR_EXIT;
	}

	if (LOBYTE(gwsaData.wVersion) >= 2)
	{
		// get max udp buffer size through getsockopt because
		// WSAStartup doesn't return this info from winsock 2.0 onwards.
		hr = GetMaxUdpBufferSize(sVerifySocket, &gd.iMaxUdpDg);
		if (FAILED(hr))
		{
			DPF(0,"Failed to get max udp buffer size");
			// since memphis still returns this value in WSAStartup
			// use it. This is just a workaround for memphis bug #43655
			if (gwsaData.iMaxUdpDg)
			{
				DPF(0, "Using iMaxUdpDg value from WSAStartup: %d", gwsaData.iMaxUdpDg);
				gd.iMaxUdpDg = gwsaData.iMaxUdpDg;
			}
			else
			{
				DPF_ERR("No max UDP buffer size could be found!");

				// all done w/ verify socket
				KillSocket(sVerifySocket,FALSE,TRUE);
				goto ERROR_EXIT;
			}
		}
	}

	// check that the IPX stack won't hose us
	if (AF_IPX == gd.AddressFamily)
	{
		hr = CheckIPXInstall(sVerifySocket);
		if (FAILED(hr))
		{
			DPF_ERR("SPInit Failing - corrupt IPX install");
			hr = DPERR_UNAVAILABLE;
			// all done w/ verify socket
			KillSocket(sVerifySocket,FALSE,TRUE);
			goto ERROR_EXIT;
		}
	}
	
	// all done w/ verify socket
	KillSocket(sVerifySocket,FALSE,TRUE);

#ifdef FIND_IP
	// print out the ip address(es) of this host
	DebugFindIPAddresses();
#endif 

    // set up callbacks
    pSD->lpCB->CreatePlayer = SP_CreatePlayer;
    pSD->lpCB->DeletePlayer = SP_DeletePlayer;
    pSD->lpCB->Send = SP_Send;
    pSD->lpCB->EnumSessions = SP_EnumSessions;
    pSD->lpCB->Reply = SP_Reply;
	pSD->lpCB->ShutdownEx = SP_Shutdown;
	pSD->lpCB->GetCaps = SP_GetCaps;
	pSD->lpCB->Open = SP_Open;
	pSD->lpCB->CloseEx = SP_Close;
	pSD->lpCB->GetAddress = SP_GetAddress;

#ifdef SENDEX
	if(LOBYTE(gwsaData.wVersion) >= 2)
	{
		DPF(1,"SENDEX being provided by SP\n");
		// Only do new functions when Winsock 2 functions avail.
		// NOTE: not supported on IPX with win9x at present, but reports 1.1 in this case.
		
    	//pSD->lpCB->SendToGroupEx = SP_SendToGroupEx;             // optional - not impl
    	//pSD->lpCB->Cancel        = SP_Cancel;                    // optional - not impl
	    pSD->lpCB->SendEx		   = SP_SendEx;                    // required for async
    	pSD->lpCB->GetMessageQueue = SP_GetMessageQueue;    
    } else {
    	DPF(1,"SENDEX not being provided by SP on winsock ver < 2\n");
    }
#endif

	// we put (at most) 1 sockaddr and one dword (size) in each message
	pSD->dwSPHeaderSize = sizeof(MESSAGEHEADER);

	// return version number so DirectPlay will treat us with respect
	pSD->dwSPVersion = VERSIONNUMBER;

	// look at connnection data
	if (pSD->dwAddressSize)
	{
		// ask dplay to enum the chunks for us. if one of them is
		// af_inet, we'll use it as our name servers address
		pSD->lpISP->lpVtbl->EnumAddress(pSD->lpISP, EnumConnectionData, 
								 pSD->lpAddress, pSD->dwAddressSize,
								 &gd);
	}

#ifdef FULLDUPLEX_SUPPORT
	// get the flags from registry
	hr = GetFlagsFromRegistry(pSD->lpGuid, &gd.dwFlags);
	if (FAILED(hr))
	{
		DPF(2, "Failed to get sp flags from the registry");		
	}
#endif // FULLDUPLEX_SUPPORT

#if USE_RSIP
	if(	gd.AddressFamily == AF_INET ){
		rsipInit(&gd, pSD->lpGuid);
	}
#endif
#if USE_NATHELP
	if(	gd.AddressFamily == AF_INET ){
		natInit(&gd, pSD->lpGuid);
	}
#endif	

	// store the globaldata
	hr = pSD->lpISP->lpVtbl->SetSPData(pSD->lpISP,&gd,sizeof(GLOBALDATA),DPSET_LOCAL);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}
	
	hr = pSD->lpISP->lpVtbl->GetSPData(pSD->lpISP,&pgd,&dwSize,DPGET_LOCAL);

	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}
#ifdef SENDEX	
	if(LOBYTE(gwsaData.wVersion) >= 2) {
		// some globals are self referential, can't set until here.
		hr=InitGlobalsInPlace(pgd);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}

		// added alertable thread.
		pgd->hSendWait=CreateEvent(NULL, FALSE, FALSE, NULL); // autoreset.
		if(!pgd->hSendWait){
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}
		pgd->bSendThreadRunning=TRUE;
		hAlertThread=CreateThread(NULL, 4000, SPSendThread, pgd, 0, (ULONG *)&hAlertThread);
		if(!hAlertThread){
			pgd->bSendThreadRunning=FALSE;
			ASSERT(FALSE);
			goto ERROR_EXIT;
		} else {
			SetThreadPriority(hAlertThread, THREAD_PRIORITY_ABOVE_NORMAL);
		}
		CloseHandle(hAlertThread);// don't need a handle.
	}
	
#endif	
	if(hWS2){
		if(!FastSockInit(pgd)){
			goto ERROR_EXIT;
		}
	}	

	
	gdwDPlaySPRefCount++;

	
	// success!
	return DP_OK;    

ERROR_EXIT:

	DPF_ERR("SPInit - abnormal exit");

	// call this again to clean up anything we alloc'ed
	InitGlobals(&gd);
	
	DPF(2,"SPInit - calling WSACleanup");
    if ( SOCKET_ERROR == WSACleanup()) 
    {
		err = WSAGetLastError();
    	DPF(0,"could not stop winsock err = %d\n",err);
    }

	return hr;

} // SPInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	dpwsock.dll initialization
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   2/1	andyco	created it
 ***************************************************************************/
//#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include "dpsp.h"
#include "memalloc.h"

DWORD dwRefCnt=0;// the # of attached processes
BOOL bFirstTime;

#undef DPF_MODNAME
#define DPF_MODNAME "dpwsock sp dllmain"

HANDLE ghInstance; // save this for our dialog box

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{

    switch( dwReason )
    {
	
	case DLL_PROCESS_ATTACH:
	
	    DisableThreadLibraryCalls( hmod );
	    DPFINIT(); // bugbug : dpfinit for every proc?

	    DPF( 0, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
	            GetCurrentProcessId(), GetCurrentThreadId() );
	    	
	    /*
	     * initialize memory
	     */
	    if( dwRefCnt == 0 )
	    {
			INIT_DPSP_CSECT();	
			
	        if( !MemInit() )
	        {
		        DPF( 0, "LEAVING, COULD NOT MemInit" );
		        return FALSE;
	        }

			// save the instance
			ghInstance = hmod;
			
	    }

    	dwRefCnt++;

        break;

    case DLL_PROCESS_DETACH:

	    DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
	        DllMain, GetCurrentProcessId(), GetCurrentThreadId() );
	    
	    dwRefCnt--;        
      	if (0==dwRefCnt) 
       	{
	
			DPF(0,"DPWSOCK - dllmain - going away!");

		    #ifdef DEBUG
	    	    MemState();
		    #endif // debug
	    
	        MemFini(); 
			
			FINI_DPSP_CSECT();
       	} 
	    break;

    default:
        break;
    }

    return TRUE;

} /* DllMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\handler.c ===
#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"HandleMessage"

// this function is called with dpws lock taken
HRESULT HandleServerMessage(LPGLOBALDATA pgd, SOCKET sSocket, LPBYTE pBuffer, DWORD dwSize)
{
	LPMSG_GENERIC pMessage = (LPMSG_GENERIC) pBuffer;
	DWORD dwType;
	DWORD dwVersion;
	HRESULT hr=DP_OK;

	ASSERT(pMessage);
	
	dwType = GET_MESSAGE_COMMAND(pMessage);
	dwVersion = GET_MESSAGE_VERSION(pMessage);
	
	switch (dwType) {
			
	default:
		DPF(0,"dpwsock received unrecognized message of type 0x%08x\n",dwType);
		break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\helpcli.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helpcli.h
 *  Content:	header file for dplay helper interface
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/15/97		andyco	created from w95help.h
 *
 ***************************************************************************/
#ifndef __HELPCLI_INCLUDED__
#define __HELPCLI_INCLUDED__
#include "windows.h"
#include "dplaysvr.h"
#include "dpf.h"

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL CreateHelperProcess( LPDWORD ppid );
extern BOOL WaitForHelperStartup( void );
extern HRESULT HelperAddDPlayServer(USHORT port);
extern BOOL HelperDeleteDPlayServer(USHORT port);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpwsock.rc
//
#define IDD_DIALOG1                     101
#define IDD_SELECTSERVER                101
#define IDC_EDIT1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\fastsock.c ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fastsock.c
 *  Content:	new socket management to speed up massive multiplayer games
 *  History:
 *
 *  Date		By		Reason
 *  ==========	==		======
 *  01/23/2000  aarono  created
 *  05/08/2000  aarono  B#34466 Fix ordering problem in DecRefConnExist
 *  07/07/2000  aarono  added WSAEHOSTUNREACH for disconnected links in GetPlayerConn
 *  08/30/2000  aarono  workaround PAST bug MB#43599
 *                      fix MB#43586 Win2K stopping, not handling WSAEWOULDBLOCK on
 *                      receive properly (was dropping link).
 *  02/02/2001  aarono 	B#300219 STRESS: don't break on WSAENOBUFS from winsock
 ***************************************************************************/

#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#include <winsock2.h>
#include "dpsp.h"
#include "rsip.h"
#include "nathelp.h"
#include "mmsystem.h"

LPFN_WSAWAITFORMULTIPLEEVENTS g_WSAWaitForMultipleEvents;
LPFN_WSASEND g_WSASend;
LPFN_WSASENDTO g_WSASendTo;
LPFN_WSACLOSEEVENT g_WSACloseEvent;
LPFN_WSACREATEEVENT g_WSACreateEvent;
LPFN_WSAENUMNETWORKEVENTS g_WSAEnumNetworkEvents;
LPFN_WSAEVENTSELECT g_WSAEventSelect;
LPFN_GETSOCKOPT g_getsockopt;

HRESULT FastPlayerEventSelect(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bSelect);
VOID FastAccept(LPGLOBALDATA pgd, LPWSANETWORKEVENTS pNetEvents);

HRESULT ProcessConnEvents(
	LPGLOBALDATA pgd, 
	PPLAYERCONN pConn, 
	LPWSANETWORKEVENTS pSockEvents, 	
	LPWSANETWORKEVENTS pSockInEvents
);

extern DWORD wsaoDecRef(LPSENDINFO pSendInfo);

PPLAYERCONN CleanPlayerConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bHard);

PPLAYERCONN FastCombine(LPGLOBALDATA pgd, PPLAYERCONN pConn, SOCKADDR *psockaddr);
VOID RemoveConnFromPendingList(LPGLOBALDATA pgd, PPLAYERCONN pConn);


/*=============================================================================

	PlayerConnnection management:
	-----------------------------

	For datagram sends, there is one port on each machine used as a target,
	and since no connection is required, only 1 socket is used for datagram
	sends and receives.  Since datagrams are allowed to be dropped, there is
	no race between sending from one side to the other until player creation
	since its ok to drop the receives that occure before player creation on 
	this machine occurs.  Actually there is a race, but we don't care.

	For reliable sends there are numerous race conditions that exist.  First
	the actual creation of the link between this client and the remote
	machine is going to become a race.  Since we are connecting to and from
	the same ports to create the link, only one link will get set up, either
	it will get set up due to a connect to us, or it will get set up by us
	connecting to them.

	They connect to us:

	In the case where they connect to us first, there may be reliable data
	arriving at our node that would get thrown out it we indicated it to 
	the dplay layer, because dplay has not yet created the player.  To avoid
	this problem we queue any incoming receives and wait until the player
	has been created locally before indicating that data to the dplay layer.
	We pend any incoming data on a PLAYERCONN structure that we put on the
	PendingConnList on the global data.  The PLAYERCONN structure can be
	fully initialized except we won't know the playerid of the remote player,
	as a result of which we cannot put the PLAYERCONN into the PlayerHash
	hash table.

	Note there is an additional problem of not knowing which player a connect
	is from.  This means we need to put the queueing in the dplay layer,
	not in the dpwsock layer.

	We connect to them:

	When we go to establish the connection with the remote, we must do it
	asynchronously so as not to block in case we are a server.  During the
	connection process, we first look on the PendingConnList and see if
	the remote hasn't already connected to us.  If it has, we pick up the
	socket from the conn list and immediately indicate any pending data.

	If we failed to find the connection in the Pending list, this doesn't
	mean they won't still beat us but we are going to try and connect to 
	them first.  We create our connect structure and put it in the hash
	table and mark it pending.  We also put it on the pending connect list
	so any incoming connection could find it.  We then issue an asynchronous
	connect on the socket.

	When the connect completes any pending sends are then sent by the
	send thread.  If the connect fails because the other side connected
	to us first, then we wait for the thread accepting connections to find
	the connection structure and send out the pending sends.

	Since they may be connecting from an old client, there is no guarantee
	that their inbound connection and our outbound connection will use the
	same socket.  Each player structure must therefore contain both an
	inbound and outbound socket.


=============================================================================*/

#ifdef DEBUG
VOID DUMPCONN(PPLAYERCONN pConn, DWORD dwLevel)
{
	DPF(8,"Conn %x dwRefCount %d sSocket %d sSocketIn %d dwFlags %x iEventHandle %d\n",
		pConn, pConn->dwRefCount, pConn->sSocket, pConn->sSocketIn, pConn->dwFlags, pConn->iEventHandle);

	if(dwLevel >= 1	){
		if(pConn->dwFlags & PLYR_NEW_CLIENT){
			DEBUGPRINTADDR(8,"NEW CLIENT: Socket",&pConn->IOSock.sockaddr);
		}
		if(pConn->dwFlags & PLYR_OLD_CLIENT){
			DEBUGPRINTADDR(8,"OLD CLIENT: Socket Out",&pConn->IOSock.sockaddr);
			DEBUGPRINTADDR(8,"OLD CLIENT: Socket In",&pConn->IOnlySock.sockaddr);
		}
	}

	if(dwLevel >= 2){
		DPF(8,"Receive... pReceiveBuffer %x, cbReceiveBuffer %d, cbReceived %d, cbExpected %d\n",
			pConn->pReceiveBuffer, pConn->cbReceiveBuffer, pConn->cbReceived, pConn->cbExpected);
	}

}

#else
#define DUMPCONN(pConn,Level)
#endif


int myclosesocket(LPGLOBALDATA pgd, SOCKET socket)
{
  DWORD lNonBlock=1;
  int err;
  
  if(socket==INVALID_SOCKET){
     DPF(0,"Closing invalid socket... bad bad bad\n");
     DEBUG_BREAK();
  }
  if(socket==pgd->sSystemStreamSocket){
      DPF(0,"Closing listen socket... bad bad bad\n");
      DEBUG_BREAK();
  }
  
  err = ioctlsocket(socket,FIONBIO,&lNonBlock);
  if (SOCKET_ERROR == err)
  {
  	err = WSAGetLastError();
	DPF(0,"myclosesocket: could not set non-blocking mode on socket err = %d!",err);
  }
  
  return closesocket(socket);
}

// TRUE -> same port and IP addr.
BOOL _inline bSameAddr(SOCKADDR *psaddr, SOCKADDR *psaddr2)
{
	SOCKADDR_IN *psaddr_in  = (SOCKADDR_IN *)psaddr;
	SOCKADDR_IN *psaddr_in2 = (SOCKADDR_IN *)psaddr2;

	if( (psaddr_in->sin_port == psaddr_in2->sin_port) &&
		!memcmp(&psaddr_in->sin_addr,&psaddr_in2->sin_addr, 4 ))
	{ 
		return TRUE;
	} else {
		return FALSE;
	}
}

//
// HashPlayer() - hash a dpid to a 0->PLAYER_HASH_SIZE index.
//
UINT _inline HashPlayer(DPID dpid){
	UINT Hash=0;
	Hash = ((dpid & 0xFF000000)>>24) ^ ((dpid & 0xFF0000)>>16) ^ ((dpid & 0xFF00)>>8) ^ (dpid & 0xFF);
	Hash = Hash % PLAYER_HASH_SIZE;
	DPF(8,"Player Hash %d\n",Hash);
	return Hash;
}

//
// HashSocket() - hash a socket id, including port
//
UINT _inline HashSocket(SOCKADDR *psockaddr){
	unsigned char *pc = (char *)(&(*(SOCKADDR_IN *)(psockaddr)).sin_port);
	UINT Hash=0;

	Hash = *pc ^ *(pc+1) ^ *(pc+2) ^ *(pc+3) ^ *(pc+4) ^ *(pc+5);

	Hash = Hash % SOCKET_HASH_SIZE;
	DPF(8,"Socket Hash %d\n",Hash);
	return Hash;
}

/*=============================================================================

	FastSockInit - Initialize Fask socket processing
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/
BOOL FastSockInit(LPGLOBALDATA pgd)
{
	BOOL bReturn = TRUE;
	INT i;

	try {
	
		InitializeCriticalSection(&pgd->csFast);
		
	} except ( EXCEPTION_EXECUTE_HANDLER) {

		// Catch STATUS_NOMEMORY
		DPF(0,"FastSockInit: Couldn't allocate critical section, bailing\n");
		bReturn=FALSE;
		goto exit;
	}

	// Start at -1 so we get the Accept handle too. 
	for(i=-1; i<NUM_EVENT_HANDLES; i++){
		pgd->EventHandles[i]=CreateEvent(NULL, FALSE, FALSE, NULL);
		if(!pgd->EventHandles[i]){
			DPF(0,"FastSockInit: Failed to allocate handles, bailing\n");
			for(;i>-1;--i){
				CloseHandle(pgd->EventHandles[i]);
			}
			bReturn = FALSE;
			goto err_exit1;
		}
	}

	// could initialize all the listenerlists to 0, but that would be pointless.
	pgd->BackStop=INVALID_HANDLE_VALUE;

	pgd->nEventSlotsAvail = NUM_EVENT_HANDLES * MAX_EVENTS_PER_HANDLE;

	InitBilink(&pgd->InboundPendingList);

	DPF(8,"FastSock Init: nEventSlots %d\n",pgd->nEventSlotsAvail);

	pgd->bFastSock=TRUE;
	
exit:
	return bReturn;

err_exit1:
	DeleteCriticalSection(&pgd->csFast);
	return bReturn;
}

/*=============================================================================

	FastSockCleanConnList - Release connections
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/

VOID FastSockCleanConnList(LPGLOBALDATA pgd)
{
	PPLAYERCONN pConn,pNextConn;
	BILINK *pBilink, *pBilinkWalker;
	INT i;

	DPF(8,"==>FastSockCleanConnList\n");

	DPF(8,"Cleaning up Player ID hash Table\n");

	EnterCriticalSection(&pgd->csFast);

	for(i=0;i<PLAYER_HASH_SIZE; i++){
		pConn=pgd->PlayerHash[i];
		pgd->PlayerHash[i]=NULL;
		while(pConn)
		{
			pNextConn=pConn->pNextP;
			DPF(8,"Destroying Connection for Playerid %x\n",pConn->dwPlayerID);
			DUMPCONN(pConn,3);
			CleanPlayerConn(pgd, pConn, TRUE);
			DecRefConnExist(pgd, pConn); // dump existence ref.
			DecRefConn(pgd,pConn); // dump playerid table ref.
			pConn=pNextConn;
		}
	}

	// Clean up socket hash table entries
	DPF(8,"Cleaning up Socket hash Table\n");

	for(i=0;i<SOCKET_HASH_SIZE; i++)
	{
		pConn=pgd->SocketHash[i];
		pgd->SocketHash[i]=NULL;
		while(pConn)
		{
			pNextConn=pConn->pNextP;
			DPF(8,"Destroying Connection for Playerid %x\n",pConn->dwPlayerID);
			DUMPCONN(pConn,3);
			CleanPlayerConn(pgd, pConn, TRUE);
			DecRefConnExist(pgd, pConn); // dump existence ref.
			DecRefConn(pgd,pConn); // dump socket table ref.
			pConn=pNextConn;
		}
	}

	// Clean up inbound list.
	DPF(8,"Cleaning up Inbound Pending List\n");

	pBilink=pgd->InboundPendingList.next;

	while(pBilink != &pgd->InboundPendingList)
	{
		pBilinkWalker=pBilink->next;
		pConn=CONTAINING_RECORD(pBilink, PLAYERCONN, InboundPendingList);
		DPF(8,"Destroying Connection for Playerid %x\n",pConn->dwPlayerID);
		DUMPCONN(pConn,3);
		CleanPlayerConn(pgd, pConn, TRUE);
		DecRefConnExist(pgd, pConn);
		//DecRefConn(pgd,pConn); // dump inbound list ref --no, gets handled in CleanPlayerConn for this case
		pBilink=pBilinkWalker;
	}
	InitBilink(&pgd->InboundPendingList);

	LeaveCriticalSection(&pgd->csFast);

	ASSERT(pgd->nEventSlotsAvail == NUM_EVENT_HANDLES * MAX_EVENTS_PER_HANDLE);
	DPF(8,"<==FastSockCleanConnList\n");
}

/*=============================================================================

	FastSockFini - Release resources for fast socket processing.
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/
VOID FastSockFini(LPGLOBALDATA pgd)
{
	BOOL bReturn = TRUE;
	INT i;

	DPF(8,"==>FastSockFini\n");

	for(i=-1;i<NUM_EVENT_HANDLES;i++){
		CloseHandle(pgd->EventHandles[i]);
	}

	// Clean up player hash table entries

	FastSockCleanConnList(pgd);

	DeleteCriticalSection(&pgd->csFast);

	pgd->bFastSock=FALSE;

	DPF(8,"<==FastSockFini\n");
}


/*=============================================================================

	GetEventHandle - Allocate an event handle for the connection
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
    	pConn - connection to add processing for on the event.

    Return Values:


-----------------------------------------------------------------------------*/
BOOL GetEventHandle(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	UINT i;
	int index;
	int iEvent=-1;	// index of event
	int iConn;	// index into connections on this event

	int bFoundSlot = FALSE;

	i=(pgd->iEventAlloc+(NUM_EVENT_HANDLES-1))%NUM_EVENT_HANDLES;

	while(pgd->iEventAlloc != i){


		if(pgd->EventList[pgd->iEventAlloc].nConn < MAX_EVENTS_PER_HANDLE){
			// Found a winner.
			iEvent = pgd->iEventAlloc;
			iConn=pgd->EventList[iEvent].nConn++;

			DPF(8,"GetEventHandle: For Conn %x, using Event index %d, Slot %d\n",pConn,iEvent,iConn);
			
			pgd->EventList[iEvent].pConn[iConn]=pConn;
			pConn->iEventHandle=iEvent;
			bFoundSlot=TRUE;
			pgd->nEventSlotsAvail--;
			DPF(8,"GetEventHandle: EventSlots Left %d\n",pgd->nEventSlotsAvail);
			if(!pgd->nEventSlotsAvail){
				DPF(0,"Out of Event slots, no new connections will be accepted\n");
			}
			break;
		}

		pgd->iEventAlloc = (pgd->iEventAlloc+1)%NUM_EVENT_HANDLES;
	}

	// advance the index so we distribute the load across the handles.
	pgd->iEventAlloc = (pgd->iEventAlloc+1)%NUM_EVENT_HANDLES;

	DPF(8,"iEventAlloc %d\n",pgd->iEventAlloc);

	ASSERT(iEvent != -1);

	return bFoundSlot;

}


/*=============================================================================

	FreeEventHandle - Remove the event handle for the connection
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
    	pConn - connection to remove processing for on the event.

    Return Values:


-----------------------------------------------------------------------------*/
VOID FreeEventHandle(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	int iEvent;
	int iLastConn;
	UINT iConn;

	iEvent = pConn->iEventHandle;

	if(iEvent == INVALID_EVENT_SLOT){
		DPF(1,"WARN: tried to free invalid event\n");
		return;
	}

	for(iConn=0;iConn<pgd->EventList[iEvent].nConn;iConn++){

		if(pgd->EventList[iEvent].pConn[iConn]==pConn){

			ASSERT(pgd->EventList[iEvent].nConn);
			
			iLastConn = pgd->EventList[iEvent].nConn-1;

			// copy the last entry over this entry (could be 0 over 0, but who cares?)
			pgd->EventList[iEvent].pConn[iConn]=pgd->EventList[iEvent].pConn[iLastConn];
			pgd->EventList[iEvent].nConn--;

			ASSERT((INT)(pgd->EventList[iEvent].nConn) >= 0);
			
			pgd->nEventSlotsAvail++;
			pConn->iEventHandle = INVALID_EVENT_SLOT;
			DPF(8,"FreeEventHandle index %d Slot %d nConn %d on slot Total Slots Left %d\n",iEvent,iConn,pgd->EventList[iEvent].nConn,pgd->nEventSlotsAvail);
			return;
		}
	}

	DPF(0,"UH OH, couldn't free event handle!\n");
	DEBUG_BREAK();
	
}
/*=============================================================================

	FindPlayerById - Find the connection structure for a player
	
	
    Description:

		Finds a player and returns the connection structure with a reference


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		dpid - player id of the player we are trying to find connection for.

    Return Values:

		PPLAYERCONN - player connection structure
		NULL - Didn't find the player connection.

-----------------------------------------------------------------------------*/

PPLAYERCONN FindPlayerById(LPGLOBALDATA pgd, DPID dpid)
{
	PPLAYERCONN pConn;

	EnterCriticalSection(&pgd->csFast);

	pConn = pgd->PlayerHash[HashPlayer(dpid)];

	while(pConn && pConn->dwPlayerID != dpid){
		pConn = pConn->pNextP;
	}

	if(pConn){
		DPF(8,"FindPlayerById, found %x\n",pConn);
		DUMPCONN(pConn, 1);
		AddRefConn(pConn);
	}

	LeaveCriticalSection(&pgd->csFast);

	return pConn;
}

/*=============================================================================

	FindPlayerBySocket - Find the connection structure for a player
	
	
    Description:

		Finds a player and returns the connection structure with a reference

    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		psockaddr - socketaddr of the player we are trying to find connection for.

    Return Values:

		PPLAYERCONN - player connection structure
		NULL - Didn't find the player connection.

-----------------------------------------------------------------------------*/

PPLAYERCONN FindPlayerBySocket(LPGLOBALDATA pgd, SOCKADDR *psockaddr)
{
	PPLAYERCONN pConn;

	EnterCriticalSection(&pgd->csFast);

	DEBUGPRINTADDR(8,"FindPlyrBySock",psockaddr);
	
	pConn = pgd->SocketHash[HashSocket(psockaddr)];

	while(pConn && !bSameAddr(psockaddr, &pConn->IOSock.sockaddr))
	{
		DEBUGPRINTADDR(8,"FPBS: doesn't match",&pConn->IOSock.sockaddr);
		pConn = pConn->pNextS;
	}

	if(pConn){
		DPF(8,"FindPlayerBySocket, found %x\n",pConn);
		DUMPCONN(pConn,1);
		AddRefConn(pConn);
	}

	LeaveCriticalSection(&pgd->csFast);

	return pConn;
}

/*=============================================================================

	CreatePlayerConn - Create a player connection structure
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		dpid - dpid of the player (if known, else DPID_UNKNOWN)
		psockaddr - socket address (if known)

    Return Values:

		ptr to created player conn, or NULL if we couldn't create (out of mem).

-----------------------------------------------------------------------------*/
PPLAYERCONN CreatePlayerConn(LPGLOBALDATA pgd, DPID dpid, SOCKADDR *psockaddr)
{
	PPLAYERCONN pConn;
	// Allocate and initialize a Player connection structure
	if(dpid != DPID_UNKNOWN && (pConn=FindPlayerById(pgd, dpid)))
	{
		return pConn; //Player already exists for this id.
	}

	if(!(pConn=SP_MemAlloc(sizeof(PLAYERCONN)+DEFAULT_RECEIVE_BUFFERSIZE)))
	{
		return pConn; //NULL
	}

	if(!GetEventHandle(pgd, pConn)){
		SP_MemFree(pConn);
		return NULL;		
	}

	pConn->pDefaultReceiveBuffer 	= (PCHAR)(pConn+1);
	pConn->pReceiveBuffer 			= pConn->pDefaultReceiveBuffer;
	pConn->cbReceiveBuffer 			= DEFAULT_RECEIVE_BUFFERSIZE;
	pConn->cbReceived      			= 0;

	pConn->dwRefCount   = 1;
	pConn->dwPlayerID 	= dpid;
	pConn->sSocket    	= INVALID_SOCKET;
	pConn->sSocketIn	= INVALID_SOCKET;
	pConn->dwFlags      = 0;

	InitBilink(&pConn->PendingConnSendQ);
	InitBilink(&pConn->InboundPendingList);

	if(psockaddr){
		// Don't yet know if this guy can re-use sockets, bang only
		// socket we know about so far into both slots.

		memcpy(&pConn->IOSock.sockaddr, psockaddr, sizeof(SOCKADDR));
		memcpy(&pConn->IOnlySock.sockaddr, psockaddr, sizeof(SOCKADDR));
	}


	DPF(8,"CreatedPlayerConn %x\n",pConn);
	DUMPCONN(pConn,3);

	return pConn;
	
}

/*=============================================================================

	DestroyPlayerConn - Remove the connection from any lists, shut down any
						active sockets.
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		pConn 


    Return Values:

		Pulls the player Conn off of any hash tables and lists it lives on
		and gets rid of its existence count.  No guarantee that this will
		actually free the object though, that happens when the last reference
		is released.

-----------------------------------------------------------------------------*/
PPLAYERCONN CleanPlayerConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bHard)
{
	LINGER Linger;
	int err;
	LPREPLYLIST prd;

#ifdef DEBUG
		DWORD dwTime;

	dwTime=timeGetTime();
#endif		

	EnterCriticalSection(&pgd->csFast);

	DPF(8,"==>CLEANPLAYERCONN %x time %d\n",pConn,dwTime);
	DUMPCONN(pConn,3);
	
	// Remove from listening.

	FastPlayerEventSelect(pgd, pConn, FALSE);

	// Dump event handle.

	FreeEventHandle(pgd, pConn);

	// Remove from lists.
	if(pConn->dwFlags & PLYR_PENDINGLIST)
	{
		RemoveConnFromPendingList(pgd, pConn);
	}

	if(pConn->dwFlags & PLYR_DPIDHASH)
	{
		RemoveConnFromPlayerHash(pgd,pConn);
	}

	if(pConn->dwFlags & PLYR_SOCKHASH)
	{
		RemoveConnFromSocketHash(pgd,pConn);
	}
	
	// Close all sockets.

	// When closing the sockets we want to avoid a bunch of nastiness where data sometimes isn't delivered
	// because we close the socket before the data is sent, but we don't want to linger the socket because
	// then it gets into a TIME_WAIT state where the same connection cannot be re-established for 4 minutes
	// which wrecks havoc with our tests and can cause connection problems since DirectPlay uses a limited
	// range (100 ports) between machines.  So we set the socket to hard close (avoiding TIME_WAIT) but use
	// the "Reply" clean up code path to close the sockets down.

	if(pConn->sSocket != INVALID_SOCKET)
	{

		DPF(8,"Closing Socket %d\n",pConn->sSocket);
	
		Linger.l_onoff=TRUE; Linger.l_linger=0; // avoid TIME_WAIT
		if(SOCKET_ERROR == setsockopt( pConn->sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,sizeof(Linger)))
		{
			DPF(0,"DestroyPlayerConn:Couldn't set linger to short for hard close\n");
		}
		
		ENTER_DPSP();

		prd=SP_MemAlloc(sizeof(REPLYLIST));
		
		if(!prd){
			
			LEAVE_DPSP();

			DPF(8,"Closing Socket %d\n",pConn->sSocket);
			err=myclosesocket(pgd,pConn->sSocket);
			if(err == SOCKET_ERROR){
				err=WSAGetLastError();
				DPF(8,"Error Closing Socket %x, err=%d\n", pConn->sSocket,err);
			}
		} else {

			// very tricky, overloading the reply close list to close this socket with our own linger...
			prd->pNextReply=pgd->pReplyCloseList;
			pgd->pReplyCloseList=prd;
			prd->sSocket=pConn->sSocket;
			prd->tSent=timeGetTime();
			prd->lpMessage=NULL;

			LEAVE_DPSP();
		}
			
		pConn->sSocket=INVALID_SOCKET;
		if(pConn->sSocketIn==INVALID_SOCKET){
			pConn->dwFlags &= ~(PLYR_CONNECTED|PLYR_ACCEPTED);
		} else {
			pConn->dwFlags &= ~(PLYR_CONNECTED);
		}
	}

	if(pConn->sSocketIn != INVALID_SOCKET)
	{
		// may have to close another socket.
		DPF(8,"Closing SocketIn %d\n",pConn->sSocketIn);

		Linger.l_onoff=TRUE; Linger.l_linger=0; // avoid TIME_WAIT
		if(SOCKET_ERROR == setsockopt(pConn->sSocketIn,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,sizeof(Linger)))
		{
			DPF(0,"DestroyPlayerConn:Couldn't set linger to short for hard close\n");
		}

		ENTER_DPSP();

		prd=SP_MemAlloc(sizeof(REPLYLIST));
		
		if(!prd){
			LEAVE_DPSP();
			err=myclosesocket(pgd,pConn->sSocketIn);
			if(err == SOCKET_ERROR){
				err=WSAGetLastError();
				DPF(8,"Error Closing Socket %x, err=%d\n", pConn->sSocketIn,err);
			}
		} else {

			// very tricky, overloading the reply close list to close this socket with our own linger...
			prd->pNextReply=pgd->pReplyCloseList;
			pgd->pReplyCloseList=prd;
			prd->sSocket=pConn->sSocketIn;
			prd->tSent=timeGetTime();
			prd->lpMessage=NULL;

			LEAVE_DPSP();
		}	
			
		pConn->sSocketIn=INVALID_SOCKET;
		pConn->dwFlags &= ~(PLYR_ACCEPTED);
		
	}

	// Free extra buffer.
	if(pConn->pReceiveBuffer != pConn->pDefaultReceiveBuffer){
		SP_MemFree(pConn->pReceiveBuffer);
		pConn->pReceiveBuffer = pConn->pDefaultReceiveBuffer;
	}

	// Dump Send Queue if present.
	while(!EMPTY_BILINK(&pConn->PendingConnSendQ)){
	
		PSENDINFO pSendInfo;

		pSendInfo=CONTAINING_RECORD(pConn->PendingConnSendQ.next, SENDINFO, PendingConnSendQ);
		Delete(&pSendInfo->PendingConnSendQ);
		pSendInfo->Status = DPERR_CONNECTIONLOST;
		EnterCriticalSection(&pgd->csSendEx);
		pSendInfo->RefCount = 1;
		LeaveCriticalSection(&pgd->csSendEx);
		wsaoDecRef(pSendInfo);
		
	}

	DUMPCONN(pConn,3);
#ifdef DEBUG	
	dwTime = timeGetTime()-dwTime;
	if(dwTime > 1000){
		DPF(0,"Took way too long in CleanPlayerConn, elapsed %d ms\n",dwTime);
		//DEBUG_BREAK();	// removed break due to stress hits
	}
#endif	
	DPF(8,"<==CleanPlayerConn total time %d ms\n",dwTime);

	LeaveCriticalSection(&pgd->csFast);

	return pConn;
	
}

/*=============================================================================

	DecRefConn - Decrement reference on PlayerConn, when it hits 0, free it.
	
    Description:


    Parameters:

		pConn - player connection.

    Return Values:

		decrements the reference on a player conn.  If it hits 0, frees it.

-----------------------------------------------------------------------------*/
INT DecRefConn(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	INT count;
	
	count=InterlockedDecrement(&pConn->dwRefCount);

	if(!count){
		CleanPlayerConn(pgd, pConn, FALSE);
		DPF(8,"Freeing Connection pConn %x\n",pConn);
		SP_MemFree(pConn);
	}

	#ifdef DEBUG
	if(count & 0x80000000){
		DPF(0,"DecRefConn: Conn refcount for conn %x has gone negative count %x\n",pConn,count);
		DUMPCONN(pConn,2);
		DEBUG_BREAK();
	}
	#endif
	
	return count;
}

/*=============================================================================

	DecRefConnExist - Dumps Existence ref if not already dumped.
	
    Description:


    Parameters:

		pConn - player connection.

    Return Values:

-----------------------------------------------------------------------------*/
INT DecRefConnExist(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	INT count;

	EnterCriticalSection(&pgd->csFast);

	if(!(pConn->dwFlags & PLYR_DESTROYED)){
		pConn->dwFlags |= PLYR_DESTROYED;
		count=DecRefConn(pgd,pConn);
	} else {
		count=pConn->dwRefCount;
	}
	LeaveCriticalSection(&pgd->csFast);
	return count;
}

/*=============================================================================

	AddConnToPlayerHash - puts a connection in the player hash table.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		None.

-----------------------------------------------------------------------------*/

HRESULT AddConnToPlayerHash(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	PPLAYERCONN pConn2;
	INT i;
	HRESULT hr=DP_OK;

	#ifdef DEBUG
	if(pConn->dwPlayerID == DPID_UNKNOWN){
		DEBUG_BREAK();
	}
	#endif

	ASSERT(!(pConn->dwFlags & PLYR_DPIDHASH));

	EnterCriticalSection(&pgd->csFast);

	if(!(pConn->dwFlags & PLYR_DPIDHASH)){

		if(pConn2 = FindPlayerById(pgd, pConn->dwPlayerID)){
			DPF(0,"AddConnToPlayerHash: Player in %x id %d already exists, pConn=%x\n",pConn,pConn->dwPlayerID,pConn2);
			DecRefConn(pgd, pConn2);
			hr=DPERR_GENERIC;
			goto exit;
		}

		DPF(8,"Adding Conn %x to Player ID Hash\n",pConn);
		DUMPCONN(pConn,1);	

		// add a reference for being in the player hash table.
		AddRefConn(pConn);

		i=HashPlayer(pConn->dwPlayerID);

		ASSERT(i<PLAYER_HASH_SIZE);
		
		pConn->pNextP = pgd->PlayerHash[i];
		pgd->PlayerHash[i] = pConn;

		pConn->dwFlags |= PLYR_DPIDHASH;
	} else {
		DPF(8,"WARNING:tried to add Conn %x to Player Hash again\n",pConn);
		DEBUG_BREAK();
	}

exit:
	LeaveCriticalSection(&pgd->csFast);
	return hr;
}

/*=============================================================================

	RemoveConnFromPlayerHash - pull a connection from the player hash table.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/

PPLAYERCONN RemoveConnFromPlayerHash(LPGLOBALDATA pgd, PPLAYERCONN pConnIn)
{
	PPLAYERCONN pConn=NULL,pConnPrev;
	INT i;

	if(pConnIn->dwFlags & PLYR_DPIDHASH){

		i=HashPlayer(pConnIn->dwPlayerID);

		EnterCriticalSection(&pgd->csFast);
		
		pConn = pgd->PlayerHash[i];
		pConnPrev = CONTAINING_RECORD(&pgd->PlayerHash[i], PLAYERCONN, pNextP); // sneaky

		while(pConn && pConn != pConnIn){
			pConnPrev = pConn;
			pConn = pConn->pNextP;
		}

		if(pConn){
			DPF(8,"Removing Conn %x from Player ID Hash\n",pConn);
			DUMPCONN(pConn,1);	
			pConnPrev->pNextP = pConn->pNextP;
			pConn->dwFlags &= ~(PLYR_DPIDHASH);

			i=DecRefConn(pgd, pConn); // remove reference for player hash table
			ASSERT(i);
		}	

		LeaveCriticalSection(&pgd->csFast);

	}
	
	return pConn;
}

/*=============================================================================

	AddConnToSocketHash - puts a connection in the socket hash table.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		None.

-----------------------------------------------------------------------------*/

HRESULT AddConnToSocketHash(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	PPLAYERCONN pConn2;
	INT i;
	HRESULT hr=DP_OK;


	EnterCriticalSection(&pgd->csFast);

	if(!(pConn->dwFlags & PLYR_SOCKHASH)){

		if(pConn2 = FindPlayerBySocket(pgd, &pConn->IOSock.sockaddr)){
			DecRefConn(pgd, pConn2);
			DPF(0,"AddConnToPlayerHash: Player in %x id %d already exists, pConn=%x\n",pConn,pConn->dwPlayerID,pConn2);
			hr=DPERR_GENERIC;
			goto exit;
		}

		DPF(8,"Adding Conn %x to Socket Hash\n",pConn);
		DUMPCONN(pConn,1);	

		// add a reference for being in the socket hash.
		AddRefConn(pConn);

		i=HashSocket(&pConn->IOSock.sockaddr);

		ASSERT(i<SOCKET_HASH_SIZE);
		
		pConn->pNextS = pgd->SocketHash[i];
		pgd->SocketHash[i] = pConn;

		pConn->dwFlags |= PLYR_SOCKHASH;

	} else {
		DPF(0,"WARNING: tried to add pConn %x to socket hash again\n",pConn);
		DEBUG_BREAK();
	}

exit:
	LeaveCriticalSection(&pgd->csFast);
	return hr;
}

/*=============================================================================

	RemoveConnFromSockHash - pull a connection from the socket hash table.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/

PPLAYERCONN RemoveConnFromSocketHash(LPGLOBALDATA pgd, PPLAYERCONN pConnIn)
{
	PPLAYERCONN pConn=NULL,pConnPrev;
	UINT i;

	if(pConnIn->dwFlags & PLYR_SOCKHASH){
	
		i=HashSocket(&pConnIn->IOSock.sockaddr);

		DPF(8,"Removing Player %x from Socket Hash\n",pConnIn);

		EnterCriticalSection(&pgd->csFast);

		pConn = pgd->SocketHash[i];
		pConnPrev = CONTAINING_RECORD(&pgd->SocketHash[i], PLAYERCONN, pNextS); // sneaky

		while(pConn && pConn!=pConnIn){
			pConnPrev = pConn;
			pConn = pConn->pNextS;
		}

		if(pConn){
			pConnPrev->pNextS = pConn->pNextS;
			pConn->dwFlags &= ~(PLYR_SOCKHASH);

			i=DecRefConn(pgd, pConn); // remove reference for socket hash table
			ASSERT(i);
		}

		LeaveCriticalSection(&pgd->csFast);
	}

	return pConn;

	
}

/*=============================================================================

	FindConnInPendingList - finds a connection from the pending list
	
    Description:

    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		PPLAYERCONN - pointer ot connection if found, and adds a reference.

-----------------------------------------------------------------------------*/
PPLAYERCONN FindConnInPendingList(LPGLOBALDATA pgd, SOCKADDR *psaddr)
{
	PPLAYERCONN pConnWalker=NULL, pConn=NULL;
	BILINK *pBilink;
	
	EnterCriticalSection(&pgd->csFast);

	pBilink=pgd->InboundPendingList.next;

	while(pBilink != &pgd->InboundPendingList){
		pConnWalker=CONTAINING_RECORD(pBilink, PLAYERCONN, InboundPendingList);
		if(bSameAddr(psaddr, &pConnWalker->IOnlySock.sockaddr)){
			AddRefConn(pConnWalker);
			pConn=pConnWalker;
			break;
		}
		pBilink=pBilink->next;
	}

	if(pConn){
		DPF(8,"Found Conn %x in Pending List\n",pConn);
		DUMPCONN(pConn,3);
		AddRefConn(pConn);
	}

	LeaveCriticalSection(&pgd->csFast);

	return pConn;
}


/*=============================================================================

	AddConnToPendingList - puts a connection on the pending list
	
    Description:

		The Pending list keeps the list of connections that we have received
		from, but haven't received any information on yet.  Until we receive
		from one of these connections, we don't have any way to know exactly
		who the connection is from.  When we receive from one of these with
		a return address in the message, we can make an association with
		an outbound connection (if present) and can put this node in the
		socket hash table at that time.


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		None.

-----------------------------------------------------------------------------*/

HRESULT AddConnToPendingList(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	PPLAYERCONN pConn2;
	INT i;
	HRESULT hr=DP_OK;

	EnterCriticalSection(&pgd->csFast);

	if(pConn2 = FindConnInPendingList(pgd, &pConn->IOnlySock.sockaddr)){
		// OPTIMIZATION: should we remove the socket from the list here, it must be old.
		DPF(0,"AddConnToPendingList: Player in %x id %d already exists, pConn=%x\n",pConn,pConn->dwPlayerID,pConn2);
		DecRefConn(pgd, pConn2);
		hr=DPERR_GENERIC;
		goto exit;
	}

	InsertAfter(&pConn->InboundPendingList,&pgd->InboundPendingList);

	AddRefConn(pConn);
	pConn->dwFlags |= PLYR_PENDINGLIST;

	DPF(8,"Added Conn %x to PendingList\n",pConn);

exit:	
	LeaveCriticalSection(&pgd->csFast);
	return hr;
}

/*=============================================================================

	RemoveConnFromPendingList
	
    Description:

    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		None.

-----------------------------------------------------------------------------*/

VOID RemoveConnFromPendingList(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	if(pConn->dwFlags & PLYR_PENDINGLIST)
	{
		ASSERT(!EMPTY_BILINK(&pConn->InboundPendingList));
		Delete(&pConn->InboundPendingList);
		pConn->dwFlags &= ~(PLYR_PENDINGLIST);
		DecRefConn(pgd, pConn);
		DPF(8,"Removed Conn %x From Pending List\n",pConn);
	}
}

/*=============================================================================

	GetPlayerConn - Finds or creates a player conn and starts connecting it.
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		dpid - dpid of the player (if known)
		psockaddr - socket address (if known)

    Return Values:

		if found, creates a reference.

-----------------------------------------------------------------------------*/
PPLAYERCONN GetPlayerConn(LPGLOBALDATA pgd, DPID dpid, SOCKADDR *psockaddr)
{
	PPLAYERCONN pConn=NULL;
	SOCKET sSocket;
	SOCKADDR_IN saddr;
	INT rc,err;
	DWORD dwSize;
	BOOL bTrue=TRUE;
	u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
	u_long lBlock = 0; // passed to ioctlsocket to make socket blocking

	BOOL bCreated=FALSE;

	
	// Do we already know this player by id?
	if(dpid != DPID_UNKNOWN) {
		if (pConn=FindPlayerById(pgd, dpid))
		{
			DPF(8,"GetPlayerConn: Found Con for dpid %x pConn %x\n",dpid,pConn);
			goto exit; //Player already exists for this id.
		}
	} 
	
	if(pConn=FindPlayerBySocket(pgd, psockaddr)){
		if(pConn->dwFlags & (PLYR_CONNECTED|PLYR_CONN_PENDING))
		{
			DPF(8,"GetPlayerConn: Found Conn by socketaddr pConn %x\n",pConn);
			if(dpid != DPID_UNKNOWN){
				pConn->dwPlayerID=dpid;
				AddConnToPlayerHash(pgd, pConn);
			}	
			DUMPCONN(pConn,1);
			goto exit;
		} 
		
		EnterCriticalSection(&pgd->csFast);
		
	} else {
	
		EnterCriticalSection(&pgd->csFast);
		
		// do we already know this player by connection?
		if(psockaddr && (pConn=FindConnInPendingList(pgd, psockaddr)) )
		{
			//NOTE: I think we always catch this case in FastCombine
			//       We may get it before the combine happens?
			if(!(pConn->dwFlags & PLYR_CONNECTED|PLYR_CONN_PENDING)){ //only once...
			
				// hey, this is a bi-directional socket, so make it so.
				ASSERT(pConn->dwPlayerID == DPID_UNKNOWN);

				if((dpid != DPID_UNKNOWN) && (pConn->dwPlayerID == DPID_UNKNOWN))
				{
					ASSERT(!pConn->dwFlags & PLYR_DPIDHASH);
					pConn->dwPlayerID = dpid; 
					AddConnToPlayerHash(pgd, pConn);
				}

				if(!(pConn->dwFlags & PLYR_SOCKHASH)){
					AddConnToSocketHash(pgd, pConn);
				}	

				ASSERT(pConn->sSocketIn != INVALID_SOCKET);
				ASSERT(pConn->sSocket == INVALID_SOCKET);
				pConn->sSocket = pConn->sSocketIn;
				pConn->sSocketIn = INVALID_SOCKET;
				
				if(pConn->dwFlags & PLYR_ACCEPTED){
					pConn->dwFlags |= (PLYR_CONNECTED | PLYR_NEW_CLIENT);
				} else {
					ASSERT(pConn->dwFlags & PLYR_ACCEPT_PENDING);
					pConn->dwFlags |= (PLYR_CONN_PENDING | PLYR_NEW_CLIENT);
				}

				RemoveConnFromPendingList(pgd,pConn); // found a home, don't need on pending list anymore

			}

			DPF(8,"GetPlayerConn FoundConn in Pending List pConn %x\n",pConn);
			DUMPCONN(pConn,3);
			LeaveCriticalSection(&pgd->csFast);
			return pConn;
			
		}

	}

	// Have critical section...
	
	// Doesn't already exist, so create one.

	if(!pConn){
		DPF(8,"GetPlayerConn: No Conn Found, creating\n");
		pConn = CreatePlayerConn(pgd, dpid, psockaddr);
		if(!pConn){
			DPF(8, "CreatePlayerConn Failed\n");
			goto drop_exit;
		}	
		if(dpid != DPID_UNKNOWN)AddConnToPlayerHash(pgd, pConn);
		if(psockaddr)AddConnToSocketHash(pgd,pConn);
		bCreated=TRUE;
		AddRefConn(pConn); // need ref to return to caller.
	} else {
		// already have ref to return to caller as result of find.
	}

	// have critical section and a pConn, maybe created (see bCreated), and a return ref.

	ASSERT(pConn->sSocket == INVALID_SOCKET);
	ASSERT(!(pConn->dwFlags & (PLYR_CONN_PENDING|PLYR_CONNECTED)));

	//if(pgd->bSeparateIO && !(pgd->SystemStreamPortOut))
	ASSERT(pgd->bSeparateIO);
	{
		// Workaround Win9x < Millennium sockets bug.  Can't use same port for
		// inbound/outbound traffic, because Win9x will not accept connections in 
		// some cases.  So we create a socket for outbound traffic (and re-use
		// that port for all outbound traffic).

		
		rc=CreateSocket(pgd, &sSocket, SOCK_STREAM, 0, INADDR_ANY, &err, FALSE);

		if(rc != DP_OK){
			DPF(0,"Couldn't create Outbound socket on Win9x < Millennium platform, rc=%x , wserr=%d\n",rc, err);
			goto err_exit;
		}

		dwSize = sizeof(saddr);
		err=getsockname(sSocket, (SOCKADDR *)&saddr, &dwSize);

		if(err){
			DPF(0,"Couldn't get socket name?\n");
			DEBUG_BREAK();
		}

		//pgd->SystemStreamPortOut = saddr.sin_port;
		//DPF(2,"System stream out port is now %d.",ntohs(pgd->SystemStreamPortOut));
		DPF(2,"Stream out socket %x port is now %d.",sSocket, ntohs(saddr.sin_port));

		if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_REUSEADDR, (CHAR FAR *)&bTrue, sizeof(bTrue)))
		{
			err = WSAGetLastError();
			DPF(0,"Failed to to set shared mode on socket - continue : err = %d\n",err);
		}
		
	}
	/*
	else
	{
		// Normal execution path. 

		sSocket = socket(AF_INET, SOCK_STREAM, 0);


		// Bind it to our system address (so we only use one address for a change)
		memset(&saddr,0,sizeof(SOCKADDR_IN));
		saddr.sin_family	  = AF_INET;
		saddr.sin_addr.s_addr = htonl(INADDR_ANY);
		if(pgd->bSeparateIO && pgd->SystemStreamPortOut){
			saddr.sin_port        = pgd->SystemStreamPortOut;	// part of Win9x Hack. (see above)
		} else {
			saddr.sin_port        = pgd->SystemStreamPort;
		}	

		ASSERT(pgd->SystemStreamPort);
		DPF(7,"Using port %d.",ntohs(saddr.sin_port));

		// Set socket for address re-use
		
		if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_REUSEADDR, (CHAR FAR *)&bTrue, sizeof(bTrue)))
		{
			err = WSAGetLastError();
			DPF(0,"Failed to to set shared mode on socket - continue : err = %d\n",err);
		}

		rc = bind(sSocket, (SOCKADDR *)&saddr, sizeof(saddr));

		if(rc){
			err = WSAGetLastError();
			DPF(0,"Failed to Bind socket error=%d\n",err);
			DEBUG_BREAK();
			goto err_exit;	// sends will fail until player killed.
		}
	}
	*/

				
	// turn ON keepalive
	if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
	{
		err = WSAGetLastError();
		DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
	}

	ASSERT(bTrue);
	
	// turn off nagling - always, avoids race on closing socket w/o linger, otherwise must linger socket.

		DPF(5, "Turning nagling off on outbound socket");
		if (SOCKET_ERROR == setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (CHAR FAR *)&bTrue, sizeof(bTrue)))
		{
			err = WSAGetLastError();
			DPF(0,"Failed to turn off naggling - continue : err = %d\n",err);
		}

	// update connection info.
	
	pConn->dwFlags |= PLYR_CONN_PENDING;
	pConn->sSocket = sSocket;
	
	//
	// Now Connect this puppy
	//

	// set socket to non-blocking
	rc = ioctlsocket(sSocket,FIONBIO,&lNonBlock);
	if (SOCKET_ERROR == rc)
	{
		err = WSAGetLastError();
		DPF(0,"could not set non-blocking mode on socket err = %d!",err);
		DPF(0,"will revert to synchronous behavior.  bummer");
	}

	FastPlayerEventSelect(pgd,pConn, TRUE);


	DEBUGPRINTADDR(4, "Fast connecting socket:", psockaddr);

	rc = connect(sSocket,psockaddr,sizeof(SOCKADDR));
	
	if(SOCKET_ERROR == rc)
	{
		err = WSAGetLastError();
		if(err == WSAEISCONN || err == WSAEADDRINUSE){
			// must be an accept about to happen
			DPF(8,"Hey, we're already connected! got extended error %d on connect\n",err);
			pConn->dwFlags |= PLYR_ACCEPT_PENDING;
		} else if (err == WSAEWOULDBLOCK) {
			// this is what we should normally get.
			DPF(8,"Conn is pending connection %x\n",pConn);	
		} else if (err == WSAEHOSTUNREACH) {
			DEBUGPRINTADDR(8,"Can't reach host, not connecting\n",psockaddr);
			goto err_exit;
		} else if (err == WSAENOBUFS) {
			DEBUGPRINTADDR(8,"Winsock out of memory, not connecting\n",psockaddr);
			goto err_exit;
		} else {
			DPF(0,"Trying to connect UH OH, very bad things, err=%d\n",err);
			DEBUG_BREAK();
			goto err_exit;	// sends will fail until player deleted.
		}
	} else {
		// Very unlikely, but WOO HOO, connected.
		DPF(0,"Very surprising, connect didn't pending on async call?\n");
		pConn->dwFlags &= ~(PLYR_CONN_PENDING);
		pConn->dwFlags |= PLYR_CONNECTED;
	}

drop_exit:
	LeaveCriticalSection(&pgd->csFast);

exit:
	DPF(8,"<===GetPlayerConn %x\n",pConn);
	return pConn;

err_exit:
	pConn->dwFlags &= ~(PLYR_CONN_PENDING);
	if(bCreated){
		// better blow it away.
		DPF(0,"GetPlayerConn: Severe error connection Conn we made, so blowing it away.\n");
		CleanPlayerConn(pgd,pConn,TRUE);  // clean up
		DecRefConnExist(pgd,pConn);  // dump existence
		DecRefConn(pgd,pConn);       // bye bye...(ref we had for caller)
	} else {
		if(pConn) { 
			DecRefConn(pgd,pConn);
		}		
	}
	pConn=NULL; // Connection Lost.

	goto drop_exit;
}

/*=============================================================================

	FastPlayerEventSelect - start listening for events for a player.
	
    Description:

		Starts the appropriate events waiting for a signal for a 
		PlayerConn structure.


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - Player to start waiting for events on

    Return Values:


-----------------------------------------------------------------------------*/

HRESULT FastPlayerEventSelect(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bSelect)
{

	HRESULT hr=DP_OK;
	DWORD lEvents;
	INT rc;
	UINT err;

	DPF(8,"FastPlayerEventSelect pConn %x, bSelect %d\n",pConn, bSelect);
	DUMPCONN(pConn,0);

	if(pConn->sSocket != INVALID_SOCKET){
		if(bSelect){
			lEvents = FD_READ|FD_CLOSE;
			if(pConn->dwFlags & PLYR_CONN_PENDING){
				lEvents |= FD_CONNECT;
			}
			if(!EMPTY_BILINK(&pConn->PendingConnSendQ)){
				lEvents |= FD_WRITE;
			}
		} else {
			lEvents = 0;
		}
		DPF(8,"Selecting %x on IO Socket...\n",lEvents);
		DEBUGPRINTADDR(8,"IO Socket",&pConn->IOSock.sockaddr);
		rc=g_WSAEventSelect(pConn->sSocket, pgd->EventHandles[pConn->iEventHandle],lEvents);
		if(rc == SOCKET_ERROR){
			err = WSAGetLastError();
			DPF(0,"FastPlayerEventSelect: failed to do select on 2-way socket extended error=%d\n",err);
			hr=DPERR_GENERIC;
		}
	}

	if(pConn->sSocketIn != INVALID_SOCKET){
		if(bSelect){
			lEvents = FD_READ|FD_CLOSE;
		} else {
			lEvents = 0;
		}
		DPF(8,"Selecting %x on IOnly Socket...\n",lEvents);
		DEBUGPRINTADDR(8,"IOnly Socket",&pConn->IOnlySock.sockaddr);
		rc=g_WSAEventSelect(pConn->sSocketIn, pgd->EventHandles[pConn->iEventHandle], lEvents);
		if(rc == SOCKET_ERROR){
			err = WSAGetLastError();
			DPF(0,"FastPlayerEventSelect: failed to do select on receive-only socket extended error=%d\n",err);
			hr=DPERR_GENERIC;
		}
 	}
 	DPF(8,"<==FastPlayerEventSelect pConn %x\n",pConn);
 	return hr;
}




/*=============================================================================

	FastStreamReceiveThreadProc - version of stream recevie thread proc
								  that uses Winsock 2.0 functions for 
								  greater speed.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/


DWORD WINAPI FastStreamReceiveThreadProc(LPVOID pvCast)
{
	IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;

	HRESULT 		hr;
	UINT 			i,j;
	UINT			err; 
	INT				rc;
	DWORD 			dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA 	pgd;

	WSANETWORKEVENTS NetEvents1, NetEvents2;
	LPWSANETWORKEVENTS pNetEvents1, pNetEvents2;
							
	DWORD			Event;
	PPLAYERCONN	pConn;
	DWORD		nConn;
	
	// get the global data
	hr = pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("FastStreamReceiveThreadProc: couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;
	}

	pgd->pISP = pISP;	// why not do this somewhere easier? -- because old dplay didn't.

	listen(pgd->sSystemStreamSocket, 200);
	
	err = g_WSAEventSelect(pgd->sSystemStreamSocket, pgd->hAccept, FD_ACCEPT);

	if(err){
		err = WSAGetLastError();
		DPF(0,"FastStreamReceiveThreadProc: Event select for accept socket failed err=%d\n",err);
		ExitThread(0);
		return 0;
	}

    while (1)
    {

		if (pgd->bShutdown)
		{
			DPF(2,"FastStreamReceiveThreadProc: detected shutdown - bailing");
			goto CLEANUP_EXIT;
		}

		Event=WaitForMultipleObjectsEx(NUM_EVENT_HANDLES+1, &pgd->hAccept, FALSE, 2500, TRUE);

		if(Event != WAIT_TIMEOUT)
		{
			i = Event - WAIT_OBJECT_0;
			if( i <= NUM_EVENT_HANDLES)
			{

				DPF(8,"GotSignal on iEvent %d Event %x\n", i, pgd->EventHandles[i]);
				// Go to the signalled object and look for events on its sockets.

				if(i != 0){

					i--;	// go from hAccept based index to table index.

					EnterCriticalSection(&pgd->csFast);

					// loop through the connections tied to this event and 
					// see if there is any work to do for this connection.

					nConn=pgd->EventList[i].nConn;
					
					for (j=0;j<nConn;j++){
					
						pConn = pgd->EventList[i].pConn[j];

						if(pConn){

							AddRefConn(pConn); // lock it down.

							pConn->bCombine=FALSE;

							// Check for events on the connection.
							NetEvents1.lNetworkEvents=0;
							NetEvents2.lNetworkEvents=0;
							pNetEvents1=NULL;
							pNetEvents2=NULL;
							
							if(pConn->sSocket != INVALID_SOCKET){
								rc=g_WSAEnumNetworkEvents(pConn->sSocket, 0, &NetEvents1);
								if(NetEvents1.lNetworkEvents){
									pNetEvents1 = &NetEvents1;
								}
							}
							if(pConn->sSocketIn != INVALID_SOCKET){
								rc=g_WSAEnumNetworkEvents(pConn->sSocketIn, 0, &NetEvents2);
								if(NetEvents2.lNetworkEvents){
									pNetEvents2 = &NetEvents2;
								}
							}
							if(pNetEvents1 || pNetEvents2){
								DPF(8,"Found Events on Connection %x\n",pConn);
								// There are events for this connection, deal with it!
								hr=ProcessConnEvents(pgd, pConn, pNetEvents1, pNetEvents2); // can drop csFast

								if(FAILED(hr)){
									if(hr==DPERR_CONNECTIONLOST){
										CleanPlayerConn(pgd, pConn, TRUE);
										DecRefConnExist(pgd, pConn); // destory existence ref.
									} else {
										DPF(0,"Unexpected error processing connection events err=%x\n",hr);
									}
								}	
							}	

							if(pConn->bCombine || (nConn != pgd->EventList[i].nConn)){
								// list changed, re-scan.
								nConn = pgd->EventList[i].nConn;
								j=0;
							}
							DecRefConn(pgd, pConn); // set it free

						}
					}
					
					LeaveCriticalSection(&pgd->csFast);
	
				} else {
					// it's the accept socket, someone just connected to us. Yeah!
					do{
						rc = g_WSAEnumNetworkEvents(pgd->sSystemStreamSocket,0,&NetEvents1);
	  					if(NetEvents1.lNetworkEvents & FD_ACCEPT)
	  					{
	  						EnterCriticalSection(&pgd->csFast);
	  						FastAccept(pgd, &NetEvents1);
	  						LeaveCriticalSection(&pgd->csFast);
	  					}	
					}while(NetEvents1.lNetworkEvents & FD_ACCEPT);


				}
			}
		} 

        
	}// while TRUE

CLEANUP_EXIT:
	    
    return 0;
    
} // StreamReceiveThreadProc

/*=============================================================================

	FastHandleMessage - Indicate a message to the DirectPlay layer.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:


-----------------------------------------------------------------------------*/

HRESULT FastHandleMessage(LPGLOBALDATA pgd, PPLAYERCONN *ppConn)
{
	PPLAYERCONN pConn = *ppConn;
	
	if(SP_MESSAGE_TOKEN(pConn->pReceiveBuffer)==TOKEN && pConn->cbReceived != SPMESSAGEHEADERLEN)
	{
		ASSERT(pgd->AddressFamily == AF_INET);
		
		if(pConn->dwFlags & PLYR_NEW_CLIENT){
			IP_SetAddr((LPVOID)pConn->pReceiveBuffer, &pConn->IOSock.sockaddr_in);
		} else {
			IP_SetAddr((LPVOID)pConn->pReceiveBuffer, &pConn->IOnlySock.sockaddr_in);
		}

		if( !(pConn->dwFlags & PLYR_OLD_CLIENT)	&& 	// already combined
		     (pConn->sSocket == INVALID_SOCKET)	&&	// just checking
		    !(pConn->lNetEventsSocketIn & FD_CLOSE) // don't bother if we're gonna blow it away
		    ){
			LPMESSAGEHEADER phead = (LPMESSAGEHEADER)pConn->pReceiveBuffer;
			pConn=*ppConn=FastCombine(pgd, pConn, &(phead->sockaddr));
		}

		LeaveCriticalSection(&pgd->csFast);

#if DUMPBYTES
		{
			PCHAR pBuf;
			UINT buflen;
			UINT i=0;

			pBuf = pConn->pReceiveBuffer+sizeof(MESSAGEHEADER);
			buflen = pConn->cbReceived-sizeof(MESSAGEHEADER);

			while (((i + 16) < buflen) && (i < 4*16)){
				DPF(9, "%08x %08x %08x %08x",*(PUINT)(&pBuf[i]),*(PUINT)(&pBuf[i+4]),*(PUINT)(&pBuf[i+8]),*(PUINT)(&pBuf[i+12]));
				i += 16;
			}	
		}
#endif

		pgd->pISP->lpVtbl->HandleMessage(pgd->pISP, 
										 pConn->pReceiveBuffer+sizeof(MESSAGEHEADER),
										 pConn->cbReceived-sizeof(MESSAGEHEADER), 
										 pConn->pReceiveBuffer);

		EnterCriticalSection(&pgd->csFast);

		if(pConn->pReceiveBuffer != pConn->pDefaultReceiveBuffer){
			DPF(8,"Releasing big receive buffer of size %d\n",pConn->cbReceiveBuffer);
			SP_MemFree(pConn->pReceiveBuffer);
		}
		pConn->cbReceived=0;
		pConn->cbExpected=0;
		pConn->cbReceiveBuffer = DEFAULT_RECEIVE_BUFFERSIZE;
		pConn->pReceiveBuffer=pConn->pDefaultReceiveBuffer;

		if(pConn->pReceiveBuffer != (PCHAR)(pConn+1)){
		    DEBUG_BREAK();
		}

	}

	return DP_OK;
}

/*=============================================================================

	FastReceive - Receive data on a connection.
	
    Description:

		First receives a message header, then receives the message.
		When a full message is received, it is indicated.


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:


-----------------------------------------------------------------------------*/
HRESULT FastReceive(LPGLOBALDATA pgd, PPLAYERCONN *ppConn)
{
	PPLAYERCONN pConn;
	PCHAR pBuffer;			// receive buffer pointer.
	DWORD cbBuffer;			// receive buffer size.
	SOCKET sSocket;			// socket to receive on
	INT		err;			// sockets error.
	DWORD	cbReceived;		// actual bytes received on this recv call.

	DWORD	cbMessageSize=0;	// size of the message to receive
	HRESULT hr;

	pConn=*ppConn;

	if(pConn->cbExpected == 0){
		// all messages have a header, let get that first.
		pConn->cbExpected = SPMESSAGEHEADERLEN;
	}

	// point to place in buffer we're going to receive latest data.
	// don't get more than we expect, or we would have to be smart
	// about setting up messages.
	pBuffer  = pConn->pReceiveBuffer+pConn->cbReceived;
	cbBuffer = pConn->cbExpected-pConn->cbReceived;

  if(cbBuffer > pConn->cbReceiveBuffer){
      DPF(0,"Receive would overrun buffer\n");
      DEBUG_BREAK();
  }

	if(pConn->dwFlags & PLYR_NEW_CLIENT){
		// new client does bi-directional on socket.
		sSocket = pConn->sSocket;
	} else {
		// old clients have separate receive socket.
		sSocket = pConn->sSocketIn;
	}

	ASSERT(sSocket != INVALID_SOCKET);

	DPF(8,"Attempting to receive %d bytes", cbBuffer);
   	DEBUGPRINTSOCK(8,">>> receiving data on socket - ",&sSocket);

	cbReceived = recv(sSocket, pBuffer, cbBuffer, 0); // <----- Receive that data!

	if(cbReceived == 0){
		// remote side has shutdown connection gracefully
   		DEBUGPRINTSOCK(8,"<<< received notification on socket - ",&sSocket);
		DEBUGPRINTSOCK(5,"Remote side has shutdown connection gracefully - ",&sSocket);
		hr = DPERR_CONNECTIONLOST;
		goto ERROR_EXIT;

	} else if (cbReceived == SOCKET_ERROR){
		err = WSAGetLastError();
		if(err == WSAEWOULDBLOCK){
			DPF(1,"WARN: Got WSAEWOULDBLOCK on non-blocking receive, round and round we go...\n");
			goto exit;
		}
   		DEBUGPRINTSOCK(8,"<<< received notification on socket - ",&sSocket);
		DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
		hr = DPERR_CONNECTIONLOST;            
		goto ERROR_EXIT;

	}

	DPF(5, "received %d bytes", cbReceived);

	pConn->cbReceived += cbReceived;

	if(pConn->cbReceived == SPMESSAGEHEADERLEN){
		// got the header, set up for the body of the message.
		if(VALID_DPWS_MESSAGE(pConn->pReceiveBuffer))
		{
			cbMessageSize = SP_MESSAGE_SIZE(pConn->pReceiveBuffer);
		} else {
			// Bad data.  Shut this baby down!
			DPF(2,"got invalid message - token = 0x%08x",SP_MESSAGE_TOKEN(pConn->pReceiveBuffer));
			hr = DPERR_CONNECTIONLOST;
			goto ERROR_EXIT;
		}
		
	}

	if(cbMessageSize)
	{
		pConn->cbExpected = cbMessageSize;

		if(cbMessageSize > DEFAULT_RECEIVE_BUFFERSIZE){
			pConn->pReceiveBuffer = SP_MemAlloc(cbMessageSize);
			if(!pConn->pReceiveBuffer){
				DPF(0,"Failed to allocate receive buffer for message - out of memory");
				hr=DPERR_CONNECTIONLOST;
				goto ERROR_EXIT;
			}
			pConn->cbReceiveBuffer = cbMessageSize;
			// copy header into new message buffer
			memcpy(pConn->pReceiveBuffer, pConn->pDefaultReceiveBuffer, SPMESSAGEHEADERLEN);
		}
	}

	if(pConn->cbExpected == pConn->cbReceived)
	{
		// hey, got a whole message, send it up.
		hr = FastHandleMessage(pgd, ppConn);		// <---- INDICATE THE MESSAGE
		#ifdef DEBUG
		if(pConn != *ppConn){
			DPF(8,"Connections pConn %x pNewConn %x combined\n",pConn, *ppConn);
		}
		#endif
		pConn = *ppConn;
	
		if(FAILED(hr)){
			goto ERROR_EXIT;
		}
		
	}

exit:
	return DP_OK;

	ERROR_EXIT:
		return hr;
}


/*=============================================================================

	QueueSendOnConn - queue a send on a connection until we know it is ok to send.
	
    Description:

		Note: can only have 1 send outstanding to winsock per socket because of a winsock bug.

    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.
		pSendInfo - send to queue.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/
VOID QueueSendOnConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, PSENDINFO pSendInfo)
{
	EnterCriticalSection(&pgd->csFast);
		InsertBefore(&pSendInfo->PendingConnSendQ, &pConn->PendingConnSendQ);
	LeaveCriticalSection(&pgd->csFast);
}

/*=============================================================================

	QueueNextSend - Move a pending send into the real sendq.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.
		pSendInfo - send to queue.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/

VOID QueueNextSend(LPGLOBALDATA pgd,PPLAYERCONN pConn)
{
	BILINK *pBilink;
	
	EnterCriticalSection(&pgd->csFast);

	DPF(8,"==>QueueNextSend pConn %x",pConn);

	while(!EMPTY_BILINK(&pConn->PendingConnSendQ) && !pConn->bSendOutstanding)
	{
		PSENDINFO pSendInfo;
		
		pBilink=pConn->PendingConnSendQ.next;
		pSendInfo=CONTAINING_RECORD(pBilink, SENDINFO, PendingConnSendQ);
		Delete(pBilink);
		DPF(8,"QueueNextSend: Queuing pConn %x pSendInfo %x\n",pConn,pSendInfo);
		QueueForSend(pgd,pSendInfo);
	}

	DPF(8,"<==QueueNextSend pConn %x",pConn);

	LeaveCriticalSection(&pgd->csFast);
}

/*=============================================================================

	FastCombine - see if this socket should be made bidirectional
	
    Description:

	There are 3 cases where we want to combine connections.

	1.  We have accepted the connection, we receive data and that
	    data tells us the back connection is an existing outbound
	    connection.  In this case we combine the connections

	    a. The return address is the same as the from address, 
	       in this case it is a NEW client, and we mark it so
	       and will use the same connection for outbound traffic

	    b. The return address is different thant the from address
	       in this case it is an OLD client, and we mark it so
	       and will need to establish the outbound connection 
	       later.

	2.  We receive data on a connection and there is no outbound
	    connection yet, but inbound and outbound connections are
	    different.  We know that it is an "old" client and
	    eventually we will have to connect back.  We mark the
	    connection as OLD and when the connection back is 
	    made it will use this same Connection since it will match
	    up on the target address.
	    
    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.
		psockaddr - outbound socket address.

    Return Values:

    	PPLAYERCONN pConn - if this isn't the same as the pConn on the way
    						in, then the connections have been combined.
    					  - the old connection will disappear when decrefed.
    					  - a reference is added for the returned connection
    					    if it is not the original.

-----------------------------------------------------------------------------*/
PPLAYERCONN FastCombine(LPGLOBALDATA pgd, PPLAYERCONN pConn, SOCKADDR *psockaddr_in)
{
	PPLAYERCONN pConnFind=NULL;
	SOCKADDR sockaddr,*psockaddr;
	// See if there is already a player with this target address...

	DPF(8,"==>FastCombine pConn %x\n",pConn);
	DEBUGPRINTADDR(8,"==>FastCombine saddr",psockaddr_in);

	#if USE_RSIP
	if(pgd->sRsip != INVALID_SOCKET){
		HRESULT hr;
		hr=rsipQueryLocalAddress(pgd, TRUE, psockaddr_in, &sockaddr);
		if(hr==DP_OK){
			psockaddr=&sockaddr;
		} else {
			psockaddr=psockaddr_in;
		}
	} else {
		psockaddr=psockaddr_in;
	}
	#elif USE_NATHELP
	if(pgd->pINatHelp){
		HRESULT hr;

		hr=IDirectPlayNATHelp_QueryAddress(
				pgd->pINatHelp, 
				&pgd->INADDRANY, 
				psockaddr_in, 
				&sockaddr, 
				sizeof(SOCKADDR_IN), 
				DPNHQUERYADDRESS_TCP|DPNHQUERYADDRESS_CACHENOTFOUND
				);

		if(hr==DP_OK){
			psockaddr=&sockaddr;
		} else {
			psockaddr=psockaddr_in;
		}
	} else {
		psockaddr=psockaddr_in;
	}
	#else
		psockaddr=psockaddr_in;
	#endif

	if(!pConn->bCombine) // don't combine more than once, we can't handle it.
	{
	
		pConnFind=FindPlayerBySocket(pgd, psockaddr);

		if(pConnFind){
			// We already have a connection to this guy.  See if the back-connection
			// is dead, if it is merge the two.
			ASSERT(pConnFind != pConn);

			if(!(pConnFind->dwFlags & (PLYR_ACCEPTED|PLYR_ACCEPT_PENDING))){

				// In order to get here, the client must be an old style client.
				// Otherwise, the connect for the outbound would have failed, since
				// we would be re-using the address.

				// Already correctly in the socket hash.
				// Old conn gets pulled from pending list by CleanPlayerConn.
			
				ASSERT(pConnFind->sSocketIn == INVALID_SOCKET);

				DPF(8,"FastCombine: Merging Connections pConn %x, pConnFound %x\n",pConn,pConnFind);
				DUMPCONN(pConn,3);
				DUMPCONN(pConnFind,3);

				//
				// Merge the receive socket into the outbound player connection.
				//

				// copy socket information
				pConnFind->sSocketIn = pConn->sSocketIn;
				memcpy(&pConnFind->IOnlySock.sockaddr, &pConn->IOnlySock.sockaddr, sizeof(SOCKADDR));

				// copy over receive data.
				pConnFind->cbExpected = pConn->cbExpected;
				pConnFind->cbReceived = pConn->cbReceived;
				if(pConn->pReceiveBuffer != pConn->pDefaultReceiveBuffer){
					pConnFind->pReceiveBuffer 	= pConn->pReceiveBuffer;
					pConnFind->cbReceiveBuffer = pConn->cbReceiveBuffer;
					pConn->pReceiveBuffer    	= pConn->pDefaultReceiveBuffer;
				} else {
				  ASSERT(pConn->cbReceiveBuffer == DEFAULT_RECEIVE_BUFFERSIZE);
					memcpy(pConnFind->pReceiveBuffer, pConn->pReceiveBuffer, pConn->cbReceived);
				}
				pConnFind->dwFlags |= (PLYR_ACCEPTED | PLYR_OLD_CLIENT);

				// point events to the correct connection. Overrides old conn's select.
				// Do this first so we don't drop any events.
				pConnFind->lNetEventsSocketIn=pConn->lNetEventsSocketIn;
				pConnFind->lNetEventsSocket=pConn->lNetEventsSocket;

				FastPlayerEventSelect(pgd, pConnFind, TRUE);

				// clean up old connection, but don't close the socket
				pConn->dwFlags &= ~(PLYR_ACCEPTED);
				pConn->sSocketIn = INVALID_SOCKET;
				ASSERT(pConn->sSocket==INVALID_SOCKET);
				CleanPlayerConn(pgd, pConn, FALSE);
				pConn->bCombine=TRUE;		  // tell receive thread, to reload.
				DecRefConnExist(pgd, pConn); // destroy existence ref

				DPF(8,"MergedConn pConnFound%x\n",pConnFind);
				DUMPCONN(pConnFind,3);
				pConnFind->bCombine=TRUE; // to prevent re-combine.
				// leaves 1 reference for the caller.
				return pConnFind;
				
			}
			
			DecRefConn(pgd, pConnFind); // found but can't combine... dump find ref.

		} 

	} else {
		DPF(0,"Called Fast Combine with already combined connection, may be bad\n");
	}
	// if we got here, we didn't combine.

	if(bSameAddr(psockaddr,&pConn->IOnlySock.sockaddr)){
		// If destination and source sockets match
		// Promote this one to do both 
		pConn->sSocket   = pConn->sSocketIn;
		pConn->sSocketIn = INVALID_SOCKET;
		pConn->dwFlags |= (PLYR_NEW_CLIENT | PLYR_CONNECTED);
		if(!(pConn->dwFlags & PLYR_SOCKHASH)){// Hmmm, maybe always already in it.
			AddConnToSocketHash(pgd, pConn);
		}
		RemoveConnFromPendingList(pgd, pConn);
		DPF(8,"FastCombine: Promoted Connection to Bi-Directional %x\n",pConn);
		DUMPCONN(pConn,3);
		
	} else {
		ASSERT(!(pConn->dwFlags & PLYR_NEW_CLIENT));
		pConn->dwFlags |= PLYR_OLD_CLIENT;
		// Remove from inbound hash, change to outbound hash.
		memcpy(&pConn->IOSock.sockaddr, psockaddr, sizeof(SOCKADDR));
		if(pConnFind && (pConnFind->dwFlags & (PLYR_CONNECTED|PLYR_CONN_PENDING))){
			// already connecting...
		}	else {
			// ok this is the back connection.
			RemoveConnFromPendingList(pgd, pConn);
			RemoveConnFromSocketHash(pgd, pConn);
			AddConnToSocketHash(pgd, pConn);
		}
		DPF(8,"FastCombine: Connection is Old Client %x\n",pConn);
		DUMPCONN(pConn,3);
	}
	
	FastPlayerEventSelect(pgd,pConn,TRUE);  // make sure we're listening to all the right things.

	DPF(8,"<==FastCombine\n");

	return pConn;
	
}

/*=============================================================================

	FastDropInbound - drop the inbound port for an old style client.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:


-----------------------------------------------------------------------------*/
VOID FastDropInbound(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	LINGER Linger;
	int err;
	LPREPLYLIST prd;

#ifdef DEBUG
	DWORD dwTime;
	dwTime=timeGetTime();
#endif	

	// See if there is already a player with this target address...
	DPF(8, "==>FastDropInbound pConn %x",pConn);

	pConn->dwFlags &= ~(PLYR_OLD_CLIENT|PLYR_ACCEPTED|PLYR_ACCEPT_PENDING);

	if (pConn->sSocketIn != INVALID_SOCKET)
	{
		// Hard close inbound socket to avoid TIME_WAIT.
		BOOL bNoLinger=TRUE;
		if (SOCKET_ERROR == setsockopt( pConn->sSocketIn,SOL_SOCKET,SO_DONTLINGER,(char FAR *)&bNoLinger,sizeof(bNoLinger)))
		{
			DPF(0, "FastDropInbound:Couldn't set linger to \"don't linger\".");
		}
	}

	RemoveConnFromPendingList(pgd, pConn);

	if(pConn->sSocketIn != INVALID_SOCKET)
	{
	
		err=g_WSAEventSelect(pConn->sSocketIn, 0, 0);
		if (err)
		{
			err=GetLastError();
			DPF(8, "Error trying to deselect sSocketIn %d.",pConn->sSocketIn);
		}
		else
		{
			DPF(8, "Deselected socket %d.",pConn->sSocketIn);
		}

		ENTER_DPSP();

		prd=SP_MemAlloc(sizeof(REPLYLIST));
		if (!prd)
		{
			LEAVE_DPSP();
			
			DPF(1, "Closing Socket %d immediately.", pConn->sSocketIn);
			
			myclosesocket(pgd,pConn->sSocketIn);
		}
		else
		{
			DPF(4, "Beginning delayed socket %d close.", pConn->sSocketIn);
			
			// very tricky, overloading the reply close list to close this socket with our own linger...
			prd->pNextReply=pgd->pReplyCloseList;
			pgd->pReplyCloseList=prd;
			prd->sSocket=pConn->sSocketIn;
			prd->tSent=timeGetTime();
			prd->lpMessage=NULL;

			LEAVE_DPSP();
		}

		pConn->sSocketIn = INVALID_SOCKET;
	}
	//memset(&pConn->IOnlySock,0,sizeof(pConn->IOnlySock));	

	//
	// reset receive information.
	//
	
	// Free extra buffer.
	if (pConn->pReceiveBuffer != pConn->pDefaultReceiveBuffer)
	{
		SP_MemFree(pConn->pReceiveBuffer);
	}

	pConn->	cbReceiveBuffer=DEFAULT_RECEIVE_BUFFERSIZE;
	pConn->cbReceived=0;
	pConn->cbExpected=0;

#ifdef DEBUG
	dwTime = timeGetTime()-dwTime;
	if(dwTime > 1000)
	{
		DPF(0, "Took way too long in FastDropInbound, elapsed %d ms.",dwTime);
		//DEBUG_BREAK();	// removed break due to stress hits.
	}
#endif	

	// Will shut down select for inbound.(done before close now.
	//FastPlayerEventSelect(pgd,pConn,TRUE);

	DPF(8, "<==FastDropInbound");

}
/*=============================================================================

	ProcessConnEvents - handle the events on a connection.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.
		pSockEvents - socket events on the bi-directional socket OR NULL
		pSockInEvents - socket events for the inbound only socket OR NULL

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/

HRESULT ProcessConnEvents(
	LPGLOBALDATA pgd, 
	PPLAYERCONN pConn, 
	LPWSANETWORKEVENTS pSockEvents, 
	LPWSANETWORKEVENTS pSockInEvents
)
{
	WSANETWORKEVENTS SockEvents;
	HRESULT hr=DP_OK;
	INT err;

	PPLAYERCONN pConnIn;	// connection passed by FastStreamReceiveThreadProc;

	pConnIn=pConn;

	DPF(8,"==>ProcessConnEvents pConn %x\n",pConn);

	// store in the conn, so downstream routines know what we're processing.
	if(pSockEvents){
		pConn->lNetEventsSocket=pSockEvents->lNetworkEvents;
	} else {
		pConn->lNetEventsSocket=0;
	}
	if(pSockInEvents){
		pConn->lNetEventsSocketIn=pSockInEvents->lNetworkEvents;
	} else {
		pConn->lNetEventsSocketIn=0;
	}
	
	if(pSockEvents){
		DPF(8,"SockEvents %x pConn %x\n",pSockEvents->lNetworkEvents,pConn);
		if(pSockEvents->lNetworkEvents & FD_READ){
		
			// Keep reading until all the readings done.
			ASSERT(!pSockInEvents);
			ASSERT(!(pConn->dwFlags & PLYR_OLD_CLIENT));
			pConn->dwFlags |= (PLYR_NEW_CLIENT|PLYR_ACCEPTED);
			do {
				// will indicate data if whole message received.
				hr=FastReceive(pgd, &pConn);		// can drop csFast
				if(hr!=DP_OK){
					goto exit;
				}
				err=g_WSAEnumNetworkEvents(pConn->sSocket, 0, &SockEvents);
				if(err==SOCKET_ERROR){
					err = WSAGetLastError();
					DPF(8,"Error on EnumNetworkEvents, LastError = %d\n",err);
					goto exit;
				} else {
					DPF(8,"ProcessConnEvents, Polling Sock NetEvents pConn %d Events %x\n",pConn, SockEvents.lNetworkEvents);
				}
				if(SockEvents.lNetworkEvents & FD_CLOSE && !(pSockEvents->lNetworkEvents & FD_CLOSE)){
				  pSockEvents->lNetworkEvents |= FD_CLOSE;
				  pSockEvents->iErrorCode[FD_CLOSE_BIT] = SockEvents.iErrorCode[FD_CLOSE_BIT];
				}
			} while (SockEvents.lNetworkEvents & FD_READ);	
		} 

		if(pSockEvents->lNetworkEvents & FD_WRITE){
			// connection succeeded, send any pending sends now
			QueueNextSend(pgd,pConn);
			pConn->dwFlags |= PLYR_CONNECTED;
			pConn->dwFlags &= ~(PLYR_CONN_PENDING);
			g_WSAEventSelect(pConn->sSocket, pgd->EventHandles[pConn->iEventHandle], FD_READ|FD_CLOSE);
		}

		if(pSockEvents->lNetworkEvents & FD_CONNECT)
		{
			// Check the connect status.
			if(pSockEvents->iErrorCode[FD_CONNECT_BIT]){
				DPF(0,"Connect Error %d\n",pSockEvents->iErrorCode[FD_CONNECT_BIT]);
				hr=DPERR_CONNECTIONLOST;
				goto exit;
			}
			// don't want to know about connect any more...
			pConn->dwFlags |= PLYR_CONNECTED;
			pConn->dwFlags &= ~(PLYR_CONN_PENDING);
			g_WSAEventSelect(pConn->sSocket, pgd->EventHandles[pConn->iEventHandle], FD_READ|FD_WRITE|FD_CLOSE);
		}

		if(pSockEvents->lNetworkEvents & FD_CLOSE)
		{
			DPF(8,"Outbound (Maybe I/O) Connection Closed\n");
			hr=DPERR_CONNECTIONLOST;
			goto exit;
		}
	}

	if(pSockInEvents)
	{
		ASSERT(!(pConn->dwFlags & PLYR_NEW_CLIENT));
		DPF(8,"SockEvents (IOnly) %x pConn %x\n",pSockInEvents->lNetworkEvents, pConn);

		// Need to read first, don't want to drop the data on close
		if(pSockInEvents->lNetworkEvents & FD_READ)
		{
			do{
				// Careful here, we may combine connections changing pConn.
				hr=FastReceive(pgd, &pConn);	// can drop csFast
				if(hr!=DP_OK)
				{
					FastDropInbound(pgd, pConn);
					hr=DP_OK;
					goto exit;
				}
				if(pConn->sSocketIn == INVALID_SOCKET){
					// new pConn may be bi-directional.
					if(pConn->sSocket == INVALID_SOCKET){
						hr=DPERR_CONNECTIONLOST;
						goto exit;
					} else {
						hr=DP_OK;
						goto exit;
					}
				}
				err=g_WSAEnumNetworkEvents(pConn->sSocketIn, 0, &SockEvents);
				if(err==SOCKET_ERROR){
					err = WSAGetLastError();
					DPF(8,"Error on EnumNetworkEvents, LastError = %d\n",err);
					goto exit;
				} else {
					DPF(8,"ProcessConnEvents, Polling SockIn NetEvents pConn %x Events %x\n",pConn,SockEvents.lNetworkEvents);
				}
				if((SockEvents.lNetworkEvents & FD_CLOSE) && !(pSockInEvents->lNetworkEvents & FD_CLOSE)){
				  pSockInEvents->lNetworkEvents |= FD_CLOSE;
				  pSockInEvents->iErrorCode[FD_CLOSE_BIT] = SockEvents.iErrorCode[FD_CLOSE_BIT];
				}

			} while (SockEvents.lNetworkEvents & FD_READ);
		}

		if(pSockInEvents->lNetworkEvents & FD_CLOSE)
		{
			if(pConn->sSocket == INVALID_SOCKET){
				DPF(8,"ProcessConn Events, Got Close on Inbound Only, returning ConnectionLost\n");
				ASSERT(!(pConn->dwFlags & (PLYR_CONN_PENDING|PLYR_CONNECTED)));
				hr=DPERR_CONNECTIONLOST;
			} else {
				DPF(8,"ProcessConn Events, Got Close on I/O Connection dropping inbound only.\n");
				FastDropInbound(pgd, pConn);
				hr=DP_OK;
			}	
			goto exit;
		}
		

	}
	
exit:

	pConn->lNetEventsSocket=0;
	pConn->lNetEventsSocketIn=0;

	if(pConn != pConnIn){
		// During a call to FastReceive, connections were combined and
		// we were given a reference, now we drop that reference.
		DecRefConn(pgd, pConn);
	}

	DPF(8,"<==ProcessConnEvents hr=0x%x\n",hr);


	return hr;
}

/*=============================================================================

	FastAccept - accept a connection
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pNetEvents - socket events on the accept socket

    Return Values:

	Note: csFast Held across this call.  Nothing here should block.

-----------------------------------------------------------------------------*/

VOID FastAccept(LPGLOBALDATA pgd, LPWSANETWORKEVENTS pNetEvents)
{
	SOCKADDR 	sockaddr;
	INT 		addrlen = sizeof(sockaddr);
	SOCKET 		sSocket;

	PPLAYERCONN pConn;

	UINT 		err;		// last error

	DPF(8,"==>FastAccept\n");

    sSocket = accept(pgd->sSystemStreamSocket,&sockaddr,&addrlen);

    
    if (INVALID_SOCKET == sSocket) 
    {
        err = WSAGetLastError();
        DPF(2,"FastAccept: stream accept error - err = %d socket = %d",err,(DWORD)sSocket);
		DEBUG_BREAK();
        
    } else {

		// All our sockets have KEEPALIVE...
		BOOL bTrue = TRUE;

	    DEBUGPRINTADDR(5,"FastAccept - accepted connection from",&sockaddr);
			
		// turn ON keepalive
		if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
		{
				err = WSAGetLastError();
				DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
		}
		
		// add the new socket to our receive q

		// need to allocate a connection structure, lets see if someone is waiting on this accept
		pConn=FindPlayerBySocket(pgd, &sockaddr);

		if(pConn){
			if(pConn->sSocket == INVALID_SOCKET){
				// we found the connection because a connect is waiting for it.  
				ASSERT(pConn->dwFlags & PLYR_ACCEPT_PENDING);
				ASSERT(pConn->dwFlags & PLYR_NEW_CLIENT);
				ASSERT(bSameAddr(&sockaddr, &pConn->IOSock.sockaddr));

				pConn->sSocket = sSocket;
				pConn->dwFlags &= ~(PLYR_ACCEPT_PENDING);
				pConn->dwFlags |= (PLYR_CONNECTED|PLYR_ACCEPTED);
				FastPlayerEventSelect(pgd,pConn,TRUE);

				DPF(8,"Found Pending Connection, now connected\n");
				DUMPCONN(pConn,3);

			} else {
				if(TRUE /*pgd->bSeparateIO*/){
					// more work for Win9x < Mill 
					// 8/30/00 ao - now we turn this on in all cases because we need to allow
					// for a NATed client to have different inbound and outbound connections to
					// workaround the NAT PAST bug where it picks a random from port for
					// the outbound link when we haven't received before sending on an ASSIGNED port.
					DPF(0,"New client connecting back to me, but I treat as old for compat\n");
					pConn->sSocketIn=sSocket;
					pConn->dwFlags |= PLYR_ACCEPTED|PLYR_OLD_CLIENT;
					pConn->bCombine=TRUE;
					FastPlayerEventSelect(pgd,pConn,TRUE);
				} else {
					DPF(0,"Nice race, already have a connection pConn %x, re-use\n", pConn);
					closesocket(sSocket);
				}	
			}
			
			DecRefConn(pgd, pConn); // remove reference from FindPlayerBySocket().

		} else {


			if(pConn=FindConnInPendingList(pgd, &sockaddr)){
				// This guy's in the pending list, blow old conn away.
				DPF(8,"Found Accept for Player in Pending List, blow away old one\n");
				CleanPlayerConn(pgd, pConn, TRUE);
				DecRefConnExist(pgd, pConn); // dump existence ref.
				DecRefConn(pgd, pConn); // dump our ref.
			}

			//
			// No connection, we need to create one.  
			//


			// make sure we have room.
			if(pgd->nEventSlotsAvail && (pConn = CreatePlayerConn(pgd, DPID_UNKNOWN, &sockaddr))){

				DPF(8,"Creating new Connection for Accept %x\n",pConn);
				// put on pending list...
				pConn->sSocketIn = sSocket;
				AddConnToPendingList(pgd, pConn);
				pConn->dwFlags |= PLYR_ACCEPTED;
				FastPlayerEventSelect(pgd, pConn, TRUE);

			} else {

				// No room for more accept events ... blow this socket out!

				LINGER Linger;
				
				DPF(0,"FastAccept: VERY BAD, Out of Event Slots, can't accept any new connections, killing this one\n");
				
				Linger.l_onoff=FALSE;
				Linger.l_linger=0;
				
				if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger, sizeof(Linger) ) ){
					err = WSAGetLastError();
					DPF(0,"Couldn't set linger on socket, can't kill now, so it will be an orphan...bad.bad.bad\n");
				} else {
					// don't need to shutdown the socket, since we don't have any data on it.
					myclosesocket(pgd,sSocket);
				}
			
			}		
		}
		
	}
	
	DPF(8,"<==FastAccept\n");
	
}



/*=============================================================================

	FastInternalReliableSend - reliable send using fast socket code.
	
    Description:


    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

HRESULT FastInternalReliableSend(LPGLOBALDATA pgd, LPDPSP_SENDDATA psd, SOCKADDR *lpSockAddr)
{
	HRESULT hr=DP_OK;
	SOCKET sSocket = INVALID_SOCKET;
	UINT err;

	PPLAYERCONN pConn=NULL;
	LPSENDINFO pSendInfo=NULL;
	PCHAR pBuffer=NULL;
	DPID idPlayerTo;


	DPF(6, "FastInternalReliableSend: Parameters: (0x%x, 0x%x, 0x%x)",
		pgd, psd, lpSockAddr);


	EnterCriticalSection(&pgd->csFast);

	if(psd->idPlayerTo){
		idPlayerTo=psd->idPlayerTo;
	} else {
		idPlayerTo=DPID_UNKNOWN;
	}

	pConn = GetPlayerConn(pgd, idPlayerTo, lpSockAddr); // adds a ref

	if(!pConn){
		hr=DPERR_CONNECTIONLOST;
		goto exit;
	}

	// Always go async, since we are on a non-blocking mode socket.
	{
		// make this puppy asynchronous.... malloc ICK!
		
		pSendInfo = pgd->pSendInfoPool->Get(pgd->pSendInfoPool);
		pBuffer = SP_MemAlloc(psd->dwMessageSize);
		
		if(!pSendInfo || !pBuffer){
			hr=DPERR_OUTOFMEMORY;
			goto CLEANUP_EXIT;
		}

		SetReturnAddress(psd->lpMessage,pgd->sSystemStreamSocket,SERVICE_SADDR_PUBLIC(pgd));		

		memcpy(pBuffer, psd->lpMessage, psd->dwMessageSize);

		pSendInfo->SendArray[0].buf = pBuffer;
		pSendInfo->SendArray[0].len = psd->dwMessageSize;

		pSendInfo->iFirstBuf = 0;
		pSendInfo->cBuffers  = 1;
		pSendInfo->sSocket = pConn->sSocket;

		//CommonInitForSend

		pSendInfo->pConn        = pConn;
		pSendInfo->dwMessageSize= psd->dwMessageSize;
		pSendInfo->dwUserContext= 0;
		pSendInfo->RefCount     = 3;		// one for completion, 1 for this routine, 1 for async completion of send.
		pSendInfo->pgd          = pgd;
		pSendInfo->lpISP        = pgd->pISP;
		pSendInfo->Status       = DP_OK;
		pSendInfo->idTo         = psd->idPlayerTo;
		pSendInfo->idFrom       = psd->idPlayerFrom;
		pSendInfo->dwSendFlags  = psd->dwFlags|DPSEND_ASYNC;

		pSendInfo->dwFlags = SI_RELIABLE | SI_INTERNALBUFF;

		EnterCriticalSection(&pgd->csSendEx);
	
			InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
			pgd->dwBytesPending += psd->dwMessageSize;
			pgd->dwMessagesPending += 1;
		
		LeaveCriticalSection(&pgd->csSendEx);

		// End CommonInit for Send.

		if((pConn->dwFlags & PLYR_CONNECTED) && EMPTY_BILINK(&pConn->PendingConnSendQ) && !pConn->bSendOutstanding){
			QueueForSend(pgd, pSendInfo);	// send it
		} else {
			QueueSendOnConn(pgd, pConn, pSendInfo);
		}	

		wsaoDecRef(pSendInfo);
		
	}

	// success
	hr = DP_OK;
exit:
	
	if(pConn){
		DecRefConn(pgd,pConn);
	}

	LeaveCriticalSection(&pgd->csFast);
	
 	DPF(6, "FastInternalReliableSend: Returning: [0x%lx] (exit)", hr);

	return hr;

CLEANUP_EXIT:

	if(pConn){
		DecRefConn(pgd, pConn); // balance Get
	}

	LeaveCriticalSection(&pgd->csFast);

	if(pBuffer){
		SP_MemFree(pBuffer);
	}
	if(pSendInfo){
		SP_MemFree(pSendInfo);
	}
	
 	DPF(6, "FastInternalReliableSend: Returning: [0x%lx] (cleanup exit)", hr);

	return hr;
}

/*=============================================================================

	FastInternalReliableSendEx - reliable send using fast socket code.
	
    Description:


    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

HRESULT FastInternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo, SOCKADDR *lpSockAddr)
{
	HRESULT hr=DP_OK;
	SOCKET sSocket = INVALID_SOCKET;
	UINT err;

	PPLAYERCONN pConn=NULL;
	PCHAR pBuffer=NULL;
	DPID idPlayerTo;
	UINT i;
	DWORD dwOffset;


	DPF(6, "FastInternalReliableSendEx: Parameters: (0x%x, 0x%x, 0x%x, 0x%x)",
		pgd, psd, pSendInfo, lpSockAddr);

	EnterCriticalSection(&pgd->csFast);

	if(psd->idPlayerTo){
		idPlayerTo=psd->idPlayerTo;
	} else {
		idPlayerTo=DPID_UNKNOWN;
	}

	pConn = GetPlayerConn(pgd, idPlayerTo, lpSockAddr); // adds a ref

	if(!pConn){
		hr=DPERR_CONNECTIONLOST;
		goto exit;
	}

	// Always go async, since we are on a non-blocking mode socket.
	{
		// make this puppy asynchronous.... malloc ICK!

		if(!(psd->dwFlags & DPSEND_ASYNC))
		{
			pBuffer = SP_MemAlloc(psd->dwMessageSize+sizeof(MESSAGEHEADER));
			if(!pBuffer){
				hr=DPERR_OUTOFMEMORY;
				goto CLEANUP_EXIT;
			}
		}
		
		pSendInfo->sSocket = pConn->sSocket;

		//CommonInitForSend

		pSendInfo->pConn			= pConn;
		pSendInfo->dwMessageSize	= psd->dwMessageSize;
		pSendInfo->dwUserContext	= (DWORD_PTR)psd->lpDPContext;
		pSendInfo->RefCount     	= 3;		// one for completion, 1 for this routine, 1 for async completion of send.
		pSendInfo->pgd          	= pgd;
		pSendInfo->lpISP        	= pgd->pISP;
		pSendInfo->Status       	= DP_OK;
		pSendInfo->idTo        		= psd->idPlayerTo;
		pSendInfo->idFrom       	= psd->idPlayerFrom;
		pSendInfo->dwSendFlags  	= psd->dwFlags|DPSEND_ASYNC;
		pSendInfo->iFirstBuf		= 0;

		if(psd->dwFlags & DPSEND_ASYNC) {
			pSendInfo->dwFlags 	= SI_RELIABLE;
			pSendInfo->cBuffers	= psd->cBuffers+1;
		} else {
			// in sync case we need to copy the buffers since the upper layer
			// is expecting ownership back immediately.  Sync sends can't expect
			// thrilling performance anyway so this should not show up in perf.

			// copy message into one contiguous buffer.
			dwOffset=0;
			for( i = 0 ; i < psd->cBuffers+1 ; i++)
			{
				memcpy(pBuffer+dwOffset, pSendInfo->SendArray[i].buf, pSendInfo->SendArray[i].len);
				dwOffset += pSendInfo->SendArray[i].len;
			}
			
			pSendInfo->dwFlags 			= SI_RELIABLE | SI_INTERNALBUFF;
			pSendInfo->cBuffers			= 1;
			pSendInfo->SendArray[0].buf	= pBuffer;
			pSendInfo->SendArray[0].len	= psd->dwMessageSize+sizeof(MESSAGEHEADER);
		}

		EnterCriticalSection(&pgd->csSendEx);
	
			InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
			pgd->dwBytesPending += psd->dwMessageSize;
			pgd->dwMessagesPending += 1;
		
		LeaveCriticalSection(&pgd->csSendEx);

		// End CommonInit for Send.

		if((pConn->dwFlags & PLYR_CONNECTED) && EMPTY_BILINK(&pConn->PendingConnSendQ) && !pConn->bSendOutstanding){
			QueueForSend(pgd, pSendInfo);	// send it
		} else {
			QueueSendOnConn(pgd, pConn, pSendInfo);
		}	

		wsaoDecRef(pSendInfo);
		
	}

	// success
	if(psd->dwFlags & DPSEND_ASYNC)
	{
		hr = DPERR_PENDING;
	}else {
		hr = DP_OK;
	}	
exit:
	
	if(pConn){
		DecRefConn(pgd,pConn);
	}

	LeaveCriticalSection(&pgd->csFast);
	
 	DPF(6, "FastInternalReliableSendEx: Returning: [0x%lx] (exit)", hr);

	return hr;

CLEANUP_EXIT:

	if(pConn){
		DecRefConn(pgd, pConn); // balance Get
	}

	LeaveCriticalSection(&pgd->csFast);

	if(pBuffer){
		SP_MemFree(pBuffer);
	}
	
 	DPF(6, "FastInternalReliableSendEx: Returning: [0x%lx] (cleanup exit)", hr);

	return hr;
}

/*=============================================================================

	FastReply - reliable reply using fast socket code.
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

HRESULT FastReply(LPGLOBALDATA pgd, LPDPSP_REPLYDATA prd, DPID dwPlayerID)
{
	HRESULT hr=DP_OK;
	SOCKET sSocket = INVALID_SOCKET;
	UINT err;

	PPLAYERCONN pConn=NULL;
	LPSENDINFO pSendInfo=NULL;
	PCHAR pBuffer=NULL;

	SOCKADDR *psaddr;
	LPMESSAGEHEADER phead;

	DPF(8,"==>FastReply\n");

	phead=(LPMESSAGEHEADER)prd->lpSPMessageHeader;
	psaddr=&phead->sockaddr;

	if(dwPlayerID == 0){
		dwPlayerID = DPID_UNKNOWN;
	}

	EnterCriticalSection(&pgd->csFast);

	pConn = GetPlayerConn(pgd, dwPlayerID, psaddr); // adds a ref

	if(!pConn){
		hr = DPERR_CONNECTIONLOST;
		goto exit;
	}

	// make this puppy asynchronous.... malloc ICK!
	
	pSendInfo = pgd->pSendInfoPool->Get(pgd->pSendInfoPool);
	pBuffer = SP_MemAlloc(prd->dwMessageSize);
	
	if(!pSendInfo || !pBuffer){
		hr=DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
	}

	SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket,SERVICE_SADDR_PUBLIC(pgd));		

	memcpy(pBuffer, prd->lpMessage, prd->dwMessageSize);

	pSendInfo->SendArray[0].buf = pBuffer;
	pSendInfo->SendArray[0].len = prd->dwMessageSize;

	pSendInfo->iFirstBuf = 0;
	pSendInfo->cBuffers  = 1;

	pSendInfo->sSocket = pConn->sSocket;

	//CommonInitForSend

	pSendInfo->pConn	   = pConn;
	pSendInfo->dwMessageSize= prd->dwMessageSize;
	pSendInfo->dwUserContext= 0;
	pSendInfo->RefCount     = 3;		// one for send routine, one for completion, 1 for this routine
	pSendInfo->pgd          = pgd;
	pSendInfo->lpISP        = pgd->pISP;
	pSendInfo->Status       = DP_OK;
	pSendInfo->idTo         = dwPlayerID;
	pSendInfo->idFrom       = 0;
	pSendInfo->dwSendFlags  = DPSEND_GUARANTEE|DPSEND_ASYNC;
	pSendInfo->Status       = DP_OK;

	pSendInfo->dwFlags = SI_RELIABLE | SI_INTERNALBUFF;

	EnterCriticalSection(&pgd->csSendEx);

		InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
		pgd->dwBytesPending += prd->dwMessageSize;
		pgd->dwMessagesPending += 1;
	
	LeaveCriticalSection(&pgd->csSendEx);

    DPF(9,"pConn->dwFlags & PLYR_CONNECTED = %x",pConn->dwFlags & PLYR_CONNECTED);
    DPF(9,"EMPTY_BILINK PendingConnSendQ   = %x",EMPTY_BILINK(&pConn->PendingConnSendQ));
    DPF(9,"!pConn->bSendOutstanding        = %x",!pConn->bSendOutstanding);
	// End CommonInit for Send.
	if((pConn->dwFlags & PLYR_CONNECTED) && EMPTY_BILINK(&pConn->PendingConnSendQ) && !pConn->bSendOutstanding){
	    DPF(9,"==>QueueForSend");
		QueueForSend(pgd, pSendInfo);	// send it
	} else {
	    DPF(9,"==>QueueSendOnConn");
		QueueSendOnConn(pgd, pConn, pSendInfo);
	}	
	wsaoDecRef(pSendInfo);
	
	// success
	hr = DP_OK;

exit:

	if(pConn){
		DecRefConn(pgd, pConn);
	}

	LeaveCriticalSection(&pgd->csFast);

	DPF(8,"<==Fast Reply\n");

	return hr;

CLEANUP_EXIT:


	if(pConn){
		DecRefConn(pgd, pConn); // balance Get
	}

	LeaveCriticalSection(&pgd->csFast);

	if(pBuffer){
		SP_MemFree(pBuffer);
	}
	if(pSendInfo){
		SP_MemFree(pSendInfo);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\helpcli.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   helpcli.c
 *  Content:	client code to talk to dplaysvr.exe
 *					allows multiple dplay winscock clients to share
 *					a single port.  see %manroot%\dplay\dplaysvr\dphelp.c
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/15/97		andyco	created from w95help.h
 *
 ***************************************************************************/
#include "helpcli.h"

extern DWORD	dwHelperPid;


//**********************************************************************
// Globals
//**********************************************************************
BOOL					g_fDaclInited = FALSE;
SECURITY_ATTRIBUTES		g_sa;
BYTE					g_abSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
PSECURITY_ATTRIBUTES	g_psa = NULL;





//**********************************************************************
// ------------------------------
// DNGetNullDacl - Get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accessible by all users.
//					Taken from IDirectPlay8 code base.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl(void)
{
	// This was done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*) g_abSD, SECURITY_DESCRIPTOR_REVISION))
		{
			DPF(0, "Failed to initialize security descriptor!");
		}
		else
		{
			// Add a NULL DACL to the security descriptor.
			if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*) g_abSD, TRUE, (PACL) NULL, FALSE))
			{
				DPF(0, "Failed to set NULL DACL on security descriptor!");
			}
			else
			{
				g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
				g_sa.lpSecurityDescriptor = g_abSD;
				g_sa.bInheritHandle = FALSE;

				g_psa = &g_sa;
			}
		}
		g_fDaclInited = TRUE;
	}
	
	return g_psa;
}
//**********************************************************************

/*
 * sendRequest
 *
 * communicate a request to DPHELP
 */
static BOOL sendRequest( LPDPHELPDATA req_phd )
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	LPDPHELPDATA	phd;
	HANDLE			hmem;
	HANDLE			hmutex;
	HANDLE			hackevent;
	HANDLE			hstartevent;
	BOOL			rc;


	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			DPF(2, "Running on NT version %u.%u.%u, using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			DPF(2, "Running on 9x version %u.%u.%u, not using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		DPF(0, "Could not determine OS version, assuming global namespace not needed.");
		fUseGlobalNamespace = FALSE;
	}


	/*
	 * get events start/ack events
	 */
	if (fUseGlobalNamespace)
	{
		hstartevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_EVENT_NAME );
	}
	else
	{
		hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
	}
	if( hstartevent == NULL )
	{
		return FALSE;
	}

	if (fUseGlobalNamespace)
	{
		hackevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_ACK_EVENT_NAME );
	}
	else
	{
		hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
	}
	if( hackevent == NULL )
	{
		CloseHandle( hstartevent );
		return FALSE;
	}

	/*
	 * create shared memory area
	 */
	if (fUseGlobalNamespace)
	{
		hmem = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(),
								PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
								"Global\\" DPHELP_SHARED_NAME );
	}
	else
	{
		hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
								PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
								DPHELP_SHARED_NAME );
	}
	if( hmem == NULL )
	{
		DPF( 1, "Could not create file mapping!" );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}

	phd = (LPDPHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
	if( phd == NULL )
	{
		DPF( 1, "Could not create view of file!" );
		CloseHandle( hmem );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}

	/*
	 * wait for access to the shared memory
	 */
	if (fUseGlobalNamespace)
	{
		hmutex = OpenMutex( SYNCHRONIZE, FALSE, "Global\\" DPHELP_MUTEX_NAME );
	}
	else
	{
		hmutex = OpenMutex( SYNCHRONIZE, FALSE, DPHELP_MUTEX_NAME );
	}
	if( hmutex == NULL )
	{
		DPF( 1, "Could not create mutex!" );
		UnmapViewOfFile( phd );
		CloseHandle( hmem );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}
	WaitForSingleObject( hmutex, INFINITE );

	/*
	 * wake up DPHELP with our request
	 */
	memcpy( phd, req_phd, sizeof( DPHELPDATA ) );
	if( SetEvent( hstartevent ) )
	{
		WaitForSingleObject( hackevent, INFINITE );
		memcpy( req_phd, phd, sizeof( DPHELPDATA ) );
		rc = TRUE;
	}
	else
	{
		DPF( 1, "Could not signal event to notify DPHELP!" );
		rc = FALSE;
	}

	/*
	 * done with things
	 */
	ReleaseMutex( hmutex );
	CloseHandle( hmutex );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	return rc;

} /* sendRequest */


/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	HANDLE			hevent;
	DWORD			rc;

	
	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			DPF(2, "Running on NT version %u.%u.%u, using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			DPF(2, "Running on 9x version %u.%u.%u, not using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		rc = GetLastError();
		DPF(0, "Could not determine OS version (err = %u), assuming global namespace not needed.", rc);
		fUseGlobalNamespace = FALSE;
	}

	if (fUseGlobalNamespace)
	{
		hevent = CreateEvent( DNGetNullDacl(), TRUE, FALSE, "Global\\" DPHELP_STARTUP_EVENT_NAME );
	}
	else
	{
		hevent = CreateEvent( NULL, TRUE, FALSE, DPHELP_STARTUP_EVENT_NAME );
	}
	if( hevent == NULL )
	{
		return FALSE;
	}
	DPF( 3, "Wait DPHELP startup event to be triggered" );
	rc = WaitForSingleObject( hevent, INFINITE );
	CloseHandle( hevent );
	return TRUE;

} /* WaitForHelperStartup */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	DWORD			rc;

	
	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			//DPF(2, "Running on NT version %u.%u.%u, using global namespace.",
			//	VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			//DPF(2, "Running on 9x version %u.%u.%u, not using global namespace.",
			//	VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		rc = GetLastError();
		DPF(0, "Could not determine OS version (err = %u), assuming global namespace not needed.", rc);
		fUseGlobalNamespace = FALSE;
	}
	
	if( dwHelperPid == 0 )
	{
		STARTUPINFO		si;
		PROCESS_INFORMATION	pi;
		HANDLE			h;

		if (fUseGlobalNamespace)
		{
			h = OpenEvent( SYNCHRONIZE, FALSE, "Global\\" DPHELP_STARTUP_EVENT_NAME );
		}
		else
		{
			h = OpenEvent( SYNCHRONIZE, FALSE, DPHELP_STARTUP_EVENT_NAME );
		}
		if( h == NULL )
		{
			si.cb = sizeof(STARTUPINFO);
			si.lpReserved = NULL;
			si.lpDesktop = NULL;
			si.lpTitle = NULL;
			si.dwFlags = 0;
			si.cbReserved2 = 0;
			si.lpReserved2 = NULL;

			DPF( 3, "Creating helper process dplaysvr.exe now" );
			if( !CreateProcess(NULL, "dplaysvr.exe",  NULL, NULL, FALSE,
							   NORMAL_PRIORITY_CLASS,
							   NULL, NULL, &si, &pi) )
			{
				DPF( 2, "Could not create DPHELP.EXE" );
				return FALSE;
			}
			dwHelperPid = pi.dwProcessId;
			DPF( 3, "Helper Process created" );
		}
		else
		{
			DPHELPDATA	hd;
			memset(&hd,0,sizeof(DPHELPDATA)); // make prefix happy.
			DPF( 3, "dplaysvr already exists, waiting for dplaysvr event" );
			WaitForSingleObject( h, INFINITE );
			CloseHandle( h );
			DPF( 3, "Asking for DPHELP pid" );
			hd.req = DPHELPREQ_RETURNHELPERPID;
			sendRequest( &hd );
			dwHelperPid = hd.pid;
			DPF( 3, "DPHELP pid = %08lx", dwHelperPid );
		}
		*ppid = dwHelperPid;
		return TRUE;
	}
	*ppid = dwHelperPid;
	return FALSE;

} /* CreateHelperProcess */

// notify dphelp.c that we have a new server on this system
HRESULT HelperAddDPlayServer(USHORT port)
{
	DPHELPDATA hd;
	DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DPHELPDATA));
	hd.req = DPHELPREQ_DPLAYADDSERVER;
	hd.pid = pid;
	hd.port = port;
	if (sendRequest(&hd)) return hd.hr;
	else return E_FAIL;
				
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(USHORT port)
{
	DPHELPDATA hd;
	DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DPHELPDATA));
	hd.req = DPHELPREQ_DPLAYDELETESERVER;
	hd.pid = pid;
	hd.port = port;
	return sendRequest(&hd);

} // HelperDeleteDPlayServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\leverage.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       leverage.c
 *  Content:	code to allow third parties to hook our wsock sp
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	8/30/96	andyco	moved this code from dpsp.c for more better clean
 *	2/18/98 a-peterz Comment byte order for address and port parameters
 **************************************************************************/

#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"dpwsock helper functions- "


// the functions below are exported from dpwsock so sp's sitting on 
// top of us can hook our enum routine (e.g. for Kali)
// return the port of our enum socket (net byte order)
HRESULT DPWS_GetEnumPort(IDirectPlaySP * pISP,LPWORD pPort)
{
	SOCKADDR_IN sockaddr;
	int iAddrLen = sizeof(SOCKADDR);
	UINT err;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
		
	if (!pISP)
	{
		DPF_ERR("must pass in IDirectPlaySP pointer!");
		return E_FAIL;
	}
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;

	}

	if (AF_IPX == pgd->AddressFamily) 
	{
		DPF(0," could not get the enum port for AF_IPX");
		return E_FAIL;
	}

	ASSERT(pPort);
	ASSERT(INVALID_SOCKET != pgd->sSystemStreamSocket);
	
    err = getsockname(pgd->sSystemStreamSocket,(SOCKADDR *)&sockaddr,&iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"GetEnumPort - getsockname - err = %d\n",err);
		return E_FAIL;
    } 

	*pPort = sockaddr.sin_port;
	
	return DP_OK;
} // GetEnumPort

// takes a port and an ip (both in net byte order) and builds a message header
HRESULT DPWS_BuildIPMessageHeader(IDirectPlaySP * pISP,LPVOID pvMessageHeader,LPDWORD
 	pdwMessageHeaderSize,WORD port,DWORD inaddr)
{
	LPMESSAGEHEADER	phead;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
		
	if (!pISP)
	{
		DPF_ERR("must pass in IDirectPlaySP pointer!");
		return E_FAIL;
	}
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;

	}

	ASSERT(pdwMessageHeaderSize);
	if ( (*pdwMessageHeaderSize < sizeof(MESSAGEHEADER)) || (NULL == pvMessageHeader))
	{
		*pdwMessageHeaderSize = sizeof(MESSAGEHEADER);
		return DPERR_BUFFERTOOSMALL;
	}

	if (AF_IPX == pgd->AddressFamily)
	{
		DPF_ERR("can't set header for ipx");
		return E_NOTIMPL;
	}

	phead = (LPMESSAGEHEADER)pvMessageHeader;
	((SOCKADDR_IN *)&(phead->sockaddr))->sin_family =  AF_INET;
	((SOCKADDR_IN *)&(phead->sockaddr))->sin_addr.s_addr =  inaddr;
	((SOCKADDR_IN *)&(phead->sockaddr))->sin_port =  port;

	DEBUGPRINTADDR(5,"BuildIPMessageHeader - setting header to",&(phead->sockaddr));

	return DP_OK;

} // BuildIPMessageHeader


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\registry.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       registry.c
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  ???
 *  12/28/99    aarono  added query for required key for Win95 rsip support
 *  04/19/01    vanceo  added nathelp DLL retrieval and copied to dplaysvr
 *
 ***************************************************************************/



#include "dpsp.h"

#define REGISTRY_NAMELEN	512
// space (in bytes) for a human readable (unicode) guid + some extra
#define GUID_STRING_SIZE 80

#define SZ_SP_KEY		"Software\\Microsoft\\DirectPlay\\Service Providers"
#define SZ_GUID			"Guid"
#define SZ_FLAGS		"dwFlags"

#define SZ_GATEWAY		"Gateway"
#define SZ_NATHELP		"NATHelp"

#undef DPF_MODNAME
#define DPF_MODNAME "FindApplicationInRegistry"

// convert a hex char to an int - used by str to guid conversion
// we wrote our own, since the ole one is slow, and requires ole32.dll
// we use ansi strings here, since guids won't get internationalized
int GetDigit(LPSTR lpstr)
{
	char ch = *lpstr;
    
    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
// walk the string, writing pairs of bytes into the byte stream (guid)
// we need to write the bytes into the byte stream from right to left
// or left to right as indicated by fRightToLeft
void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft)
{
	int i;

	for (i=0;i<iFieldSize ;i++ )
	{
		// don't barf on the field separators
		if ('-' == **ppStr) (*ppStr)++; 
		if (fRightToLeft == TRUE)
		{
			// work from right to left within the byte stream
			*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		} 
		else 
		{
			// work from  left to right within the byte stream
			*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		*ppStr+=2; // get next two digit pair
	}
} // ConvertField


// convert the passed in string to a real GUID
// walk the guid, setting each byte in the guid to the two digit hex pair in the
// passed string
HRESULT GUIDFromString(LPSTR lpStr, GUID * pGuid)
{
	BYTE * lpByte; // byte index into guid
	int iFieldSize; // size of current field we're converting
	// since its a guid, we can do a "brute force" conversion
	
	// make sure we have a {xxxx-...} type guid
	if ('{' !=  *lpStr) return E_FAIL;
	lpStr++;
	
	lpByte = (BYTE *)pGuid;
	// data 1
	iFieldSize = sizeof(unsigned long);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 2
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 3
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 4
	iFieldSize = 8*sizeof(unsigned char);
	ConvertField(lpByte,&lpStr,iFieldSize,FALSE);
	lpByte += iFieldSize;

	// make sure we ended in the right place
	if ('}' != *lpStr) 
	{
		DPF_ERR("invalid guid!!");
		memset(pGuid,0,sizeof(GUID));
		return E_FAIL;
	}

	return DP_OK;
}// GUIDFromString

BOOL FindSPInRegistry(LPGUID lpguid, LPSTR lpszSPName, DWORD dwNameSize, HKEY * lphkey)
{
	HKEY	hkeyDPSPs, hkeySP;
	DWORD	dwIndex = 0;
	CHAR	szGuidStr[GUID_STRING_SIZE];
	DWORD	dwGuidStrSize = GUID_STRING_SIZE;
	DWORD	dwType = REG_SZ;
	GUID	guidSP;
	LONG	lReturn;
	BOOL	bFound = FALSE;
	DWORD	dwSaveNameSize = dwNameSize;


	DPF(7, "Entering FindSPInRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			lpguid, lpszSPName, dwNameSize, lphkey);

 	// Open the Applications key
	lReturn = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SZ_SP_KEY, 0,
							KEY_READ, &hkeyDPSPs);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Unable to open DPlay service provider registry key!");
		return FALSE;
	}

	// Walk the list of sps in the registry, looking for
	// the sp with the right GUID
	while(!bFound)
	{
		// Open the next SP key
		dwSaveNameSize = dwNameSize;
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = RegEnumKeyExA(hkeyDPSPs, dwIndex++, lpszSPName,
						&dwSaveNameSize, NULL, NULL, NULL, NULL);

		// If the enum returns no more SPs, we want to bail
		if(lReturn != ERROR_SUCCESS)
			break;
		
		// Open the SP key		
		lReturn = RegOpenKeyExA(hkeyDPSPs, lpszSPName, 0,
									KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open sp key!");
			continue;
		}

		// Get the GUID of the SP
		lReturn = RegQueryValueExA(hkeySP, SZ_GUID, NULL, &dwType,
									(LPBYTE)&szGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID & Compare it to the passed in one
		GUIDFromString(szGuidStr, &guidSP);
		if(IsEqualGUID(&guidSP, lpguid))
		{
			bFound = TRUE;
			break;
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the SPs key
	RegCloseKey(hkeyDPSPs);

	if(bFound)
		*lphkey = hkeySP;

	return bFound;


} // FindSPInRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "GetKeyValue"
BOOL GetKeyValue(HKEY hkeyApp, LPSTR lpszKey, DWORD dwType, LPBYTE * lplpValue)
{
	DWORD	dwSize;
	LPBYTE	lpTemp = NULL;
	LONG	lReturn;


	DPF(7, "Entering GetKeyValue");
	DPF(8, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeyApp, lpszKey, lplpValue);

	ASSERT(lplpValue);

	// Get the size of the buffer for the Path
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType, NULL, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Error getting size of key value!");
		return FALSE;
	}

	// If the size is 1, then it is an empty string (only contains a
	// null terminator).  Treat this the same as a NULL string or a
	// missing key and fail it.
	if(dwSize <= 1)
		return FALSE;

	ENTER_DPSP();
	
	// Alloc the buffer for the Path
	lpTemp = SP_MemAlloc(dwSize);

	LEAVE_DPSP();
	
	if(!lpTemp)
	{
		DPF_ERR("Unable to allocate temporary string for Path!");
		return FALSE;
	}

	// Get the value itself
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType,
							(LPBYTE)lpTemp, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		SP_MemFree(lpTemp);
		DPF_ERR("Unable to get key value!");
		return FALSE;
	}

	*lplpValue = lpTemp;
	return TRUE;

} // GetKeyValue


#undef DPF_MODNAME
#define DPF_MODNAME "GetFlagsFromRegistry"
HRESULT GetFlagsFromRegistry(LPGUID lpguidSP, LPDWORD lpdwFlags)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetFlagsFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x", lpguidSP, lpdwFlags);

	ENTER_DPSP();
	
	// Allocate memory for the App Name
	lpszSPName = SP_MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPSP();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the App
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the port value.
	if(!GetKeyValue(hkeySP, SZ_FLAGS, REG_BINARY, &lpValue))
	{
		DPF_ERR("Unable to get flags value from registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	*lpdwFlags = *(LPDWORD)lpValue;

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) SP_MemFree(lpszSPName);
	if (lpValue) SP_MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetFlagsFromRegistry


#if USE_RSIP

#undef DPF_MODNAME
#define DPF_MODNAME "GetGatewayFromRegistry"
HRESULT GetGatewayFromRegistry(LPGUID lpguidSP, LPBYTE lpszGateway, DWORD cbszGateway)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetGatewayFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x %d", lpguidSP, lpszGateway, cbszGateway);

	ENTER_DPSP();
	
	// Allocate memory for the SP Name
	lpszSPName = SP_MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPSP();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the SP
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the gateway value.
	if(!GetKeyValue(hkeySP, SZ_GATEWAY, REG_SZ, &lpValue))
	{
		DPF_ERR("Unable to get key value from registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	dwSize = strlen(lpValue)+1;
	if(dwSize > cbszGateway){
		DPF_ERR("Not enough room for gateway address");
		goto CLEANUP_EXIT;
	}
	memcpy(lpszGateway, lpValue, dwSize);

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) SP_MemFree(lpszSPName);
	if (lpValue) SP_MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetGatewayFromRegistry


#elif USE_NATHELP // !  USE_RSIP

#undef DPF_MODNAME
#define DPF_MODNAME "GetNATHelpDLLFromRegistry"
HRESULT GetNATHelpDLLFromRegistry(LPGUID lpguidSP, LPBYTE lpszNATHelpDLL, DWORD cbszNATHelpDLL)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetNATHelpDLLFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x %d", lpguidSP, lpszNATHelpDLL, cbszNATHelpDLL);

	ENTER_DPSP();
	
	// Allocate memory for the SP Name
	lpszSPName = SP_MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPSP();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the SP
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the gateway value.
	if(!GetKeyValue(hkeySP, SZ_NATHELP, REG_SZ, &lpValue))
	{
		DPF(1, "Unable to get NATHelp key value from registry.");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	dwSize = strlen(lpValue)+1;
	if(dwSize > cbszNATHelpDLL){
		DPF_ERR("Not enough room for NATHelp DLL path");
		goto CLEANUP_EXIT;
	}
	memcpy(lpszNATHelpDLL, lpValue, dwSize);

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) SP_MemFree(lpszSPName);
	if (lpValue) SP_MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetNATHelpDLLFromRegistry

#endif // USE_NATHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\nathelp.h ===
#if USE_NATHELP
// from nathelp.c
VOID natExtend(LPGLOBALDATA pgd);
BOOL natInit(LPGLOBALDATA pgd,LPGUID lpguidSP);
VOID natFini(LPGLOBALDATA pgd);
VOID natDeregisterPorts(LPGLOBALDATA pgd);
HRESULT natRegisterPort(LPGLOBALDATA pgd, BOOL ftcp_udp, WORD port);
VOID natDeregisterPort(LPGLOBALDATA pgd, BOOL ftcp_udp);
BOOL natIsICSMachine(LPGLOBALDATA pgd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\rsip.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rsip.h
 *  Content:	Realm Specific IP Support header
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  12/7/99		rlamb	Original
 *  12/8/99     aarono  added function prototypes for rsip support in SP
 *
 ***************************************************************************/


#ifndef _RSIP_H_
#define _RSIP_H_
/*
 * Whats implemented:
 *  as_req_rsap(localaddr=0,localports=4-a:b:c:d,
 *              remaddr=0,remports=0)
 *  as_res_rsap(localaddr=24.128.34.21,localports=4-A:B:C:D,
 *              remaddr=0,remports=0)
 *  where a,b,c,d are listening ports on the client (192.168.0.2)
 *        and A,B,C,D are the associated ports visible
 *        on the external IP address 24.128.34.21.
 * 
 * Operation: When packet from the outside is destined for
 *            24.128.34.21:A is recieved, the ip->dst and udp->dst
 *            (or tcp->dst) fields are changed to 192.168.0.2:a
 *            and then sent along - unencapsulated.
 *            When a packet is sent out from the client, the 
 *            app (e.g. dplay) uses 192.168.0.2:a as in the
 *            IP+UDP/TCP header but uses 24.128.34.21:A for
 *            any information encoded in the data portion of
 *            the packet.
 */
#define RSIP_VERSION 1
#define RSIP_HOST_PORT 2234

// How often we scan the list for liscence renewals
#define RSIP_RENEW_TEST_INTERVAL 60000

/* start RSIP retry timer at 12.5 ms */
#define RSIP_tuRETRY_START	12500
/* max starting retry is 100 ms */
#define RSIP_tuRETRY_MAX	100000

enum { /* TUNNELS */
  TUNNEL_RESERVED = 0,
  TUNNEL_IP_IP = 1,
  TUNNEL_GRE = 2, /* PPTP */
  TUNNEL_L2TP = 3,
  /*TUNNEL_NONE = 4, /* THIS IS NOT PART OR THE SPEC */
};
enum { /* METHODS */
  METHOD_RESERVED = 0,
  RSA_IP = 1,
  RSAP_IP = 2,
  RSA_IP_IPSEC = 3,
  RSAP_IP_IPSEC = 4,
};
enum { /* FLOWS */
  FLOW_RESERVED = 0,
  FLOW_MACRO = 1,
  FLOW_MICRO = 2,
  FLOW_NONE = 3,
};
enum { /* ERROR CODES */
  UNKNOWNERROR = 1,
  BADBINDID = 2,
  BADCLIENTID = 3,
  MISSINGPARAM = 4,
  DUPLICATEPARAM = 5,
  ILLEGALPARAM = 6,
  ILLEGALMESSAGE = 7,
  REGISTERFIRST = 8,
  BADMESSAGEID = 9,
  ALREADYREGISTERED = 10,
  ALREADYUNREGISTERED = 11,
  BADTUNNELTYPE = 12,
  ADDRUNAVAILABLE = 13,
  PORTUNAVAILABLE = 14,
};
#if 0
char *rsip_error_strs[]={
  "RESERVED",
  "UNKNOWNERROR",
  "BADBINDID",
  "BADCLIENTID",
  "MISSINGPARAM",
  "DUPLICATEPARAM",
  "ILLEGALPARAM",
  "ILLEGALMESSAGE",
  "REGISTERFIRST",
  "BADMESSAGEID",
  "ALREADYREGISTERED",
  "ALREADYUNREGISTERED",
  "BADTUNNELTYPE",
  "ADDRUNAVAILABLE",
  "PORTUNAVAILABLE",
  (char *)0
};
#endif
enum { /* MESSAGES */
  RSIP_ERROR_RESPONSE = 1,
  RSIP_REGISTER_REQUEST = 2,
  RSIP_REGISTER_RESPONSE = 3,
  RSIP_DEREGISTER_REQUEST = 4,
  RSIP_DEREGISTER_RESPONSE = 5,
  RSIP_ASSIGN_REQUEST_RSA_IP = 6,
  RSIP_ASSIGN_RESPONSE_RSA_IP = 7,
  RSIP_ASSIGN_REQUEST_RSAP_IP = 8,
  RSIP_ASSIGN_RESPONSE_RSAP_IP = 9,
  RSIP_EXTEND_REQUEST = 10,
  RSIP_EXTEND_RESPONSE = 11,
  RSIP_FREE_REQUEST = 12,
  RSIP_FREE_RESPONSE = 13,
  RSIP_QUERY_REQUEST = 14,
  RSIP_QUERY_RESPONSE = 15,
  RSIP_DEALLOCATE = 16,
  RSIP_OK = 17,
  RSIP_LISTEN_REQUEST = 18,
  RSIP_LISTEN_RESPONSE = 19,
};
enum { /* PARAMETERS */
  RSIP_ADDRESS_CODE = 1,
  RSIP_PORTS_CODE = 2,
  RSIP_LEASE_CODE = 3,
  RSIP_CLIENTID_CODE = 4,
  RSIP_BINDID_CODE = 5,
  RSIP_MESSAGEID_CODE = 6,
  RSIP_TUNNELTYPE_CODE = 7,
  RSIP_RSIPMETHOD_CODE = 8,
  RSIP_ERROR_CODE = 9,
  RSIP_FLOWPOLICY_CODE = 10,
  RSIP_VENDOR_CODE = 11,
};

/*
 * MS specific Vendor Codes
 */
#define RSIP_MS_VENDOR_ID 734
enum {
  RSIP_NO_TUNNEL = 1,
  RSIP_TCP_PORT = 2,
  RSIP_UDP_PORT = 3,
  RSIP_SHARED_UDP_LISTENER = 4,
  RSIP_QUERY_MAPPING = 5,
};

#pragma pack(push,1)

typedef struct _RSIP_MSG_HDR {
	CHAR	version;
	CHAR	msgtype;
} RSIP_MSG_HDR, *PRSIP_MSG_HDR;

typedef struct _RSIP_PARAM {
	CHAR	code;
	WORD	len;
} RSIP_PARAM, *PRSIP_PARAM;

typedef struct _RSIP_MESSAGEID{
	CHAR	code;
	WORD	len;
	DWORD   msgid;	
} RSIP_MESSAGEID, *PRSIP_MESSAGEID;

typedef struct _RSIP_CLIENTID {
	CHAR 	code;
	WORD	len;
	DWORD	clientid;
} RSIP_CLIENTID, *PRSIP_CLIENTID;

typedef struct _RSIP_ADDRESS {
	CHAR 	code;
	WORD	len;
	CHAR    version;	// 1==v4
	DWORD	addr;
} RSIP_ADDRESS, *PRSIP_ADDRESS;

typedef struct _RSIP_PORT {
	CHAR	code;
	WORD 	len;
	CHAR	nports;		// we only do 1 port at a time
	WORD	port;
} RSIP_PORT, *PRSIP_PORT;

typedef struct _RSIP_LEASE {
	CHAR	code;
	WORD	len;
	DWORD	leasetime;
} RSIP_LEASE, *PRSIP_LEASE;

typedef struct _RSIP_BINDID {
	CHAR	code;
	WORD	len;
	DWORD	bindid;
} RSIP_BINDID, *PRSIP_BINDID;

typedef struct _RSIP_TUNNEL {
	CHAR	code;
	WORD	len;
	CHAR	tunneltype;
} RSIP_TUNNEL, *PRSIP_TUNNEL;

// Vendor Specific structures

typedef struct _RSIP_MSVENDOR_CODE {
	CHAR	code;
	WORD	len;
	WORD	vendorid;
	WORD	option;
}RSIP_MSVENDOR_CODE, *PRSIP_MSVENDOR_CODE;

//
// RSIP Message templates
//

typedef struct _MSG_RSIP_REGISTER {
	CHAR			version;
	CHAR			command;
	RSIP_MESSAGEID  msgid;
} MSG_RSIP_REGISTER, *PMSG_RSIP_REGISTER;

typedef struct _MSG_RSIP_DEREGISTER {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID   clientid;
	RSIP_MESSAGEID  msgid;
} MSG_RSIP_DEREGISTER, *PMSG_RSIP_DEREGISTER;

typedef struct _MSG_RSIP_ASSIGN_PORT {
	CHAR 			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	laddress;	// local
	RSIP_PORT		lport;
	RSIP_ADDRESS	raddress;	// remote
	RSIP_PORT		rport;
	RSIP_LEASE		lease;
	RSIP_TUNNEL		tunnel;
	RSIP_MESSAGEID  msgid;
	
	RSIP_MSVENDOR_CODE  porttype;
	RSIP_MSVENDOR_CODE  tunneloptions;
} MSG_RSIP_ASSIGN_PORT, *PMSG_RSIP_ASSIGN_PORT;

typedef struct _MSG_RSIP_LISTEN_PORT {
	CHAR 			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	laddress;	// local
	RSIP_PORT		lport;
	RSIP_ADDRESS	raddress;	// remote
	RSIP_PORT		rport;
	RSIP_LEASE		lease;
	RSIP_TUNNEL		tunnel;
	RSIP_MESSAGEID  msgid;
	
	RSIP_MSVENDOR_CODE porttype;
	RSIP_MSVENDOR_CODE tunneloptions;
	RSIP_MSVENDOR_CODE listentype;
} MSG_RSIP_LISTEN_PORT, *PMSG_RSIP_LISTEN_PORT;


typedef struct _MSG_RSIP_EXTEND_PORT {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_BINDID		bindid;
	RSIP_LEASE		lease;
	RSIP_MESSAGEID	msgid;
} MSG_RSIP_EXTEND_PORT, *PMSG_RSIP_EXTEND_PORT;

typedef struct _MSG_RSIP_FREE_PORT {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_BINDID     bindid;
	RSIP_MESSAGEID	msgid;	
} MSG_RSIP_FREE_PORT, *PMSG_RSIP_FREE_PORT;

typedef struct _MSG_RSIP_QUERY {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	address;
	RSIP_PORT		port;
	
	RSIP_MSVENDOR_CODE porttype;
	RSIP_MSVENDOR_CODE querytype;

	RSIP_MESSAGEID	msgid;
} MSG_RSIP_QUERY, *PMSG_RSIP_QUERY;

typedef struct _RSIP_RESPONSE_INFO {
	DWORD	clientid;
	DWORD	messageid;
	DWORD	bindid;
	DWORD	leasetime;
	CHAR    version;
	CHAR    msgtype;
	CHAR	tunneltype;
	CHAR	rsipmethod;
	DWORD	lAddressV4;	
	WORD	lPort;
	DWORD   rAddressV4;
	WORD    rPort;
	WORD	error;
} RSIP_RESPONSE_INFO, *PRSIP_RESPONSE_INFO;

#pragma pack(pop)

extern BOOL rsipInit(LPGLOBALDATA pgd,LPGUID lpguidSP);
extern VOID rsipFini(LPGLOBALDATA pgd);
extern VOID rsipCloseConnection(LPGLOBALDATA pgd);
extern HRESULT rsipAssignPort(LPGLOBALDATA lpgd, BOOL ftcp_udp, WORD port, SOCKADDR *psaddr, DWORD *pBindid);
extern HRESULT rsipFreePort(LPGLOBALDATA lpgd, DWORD Bindid);
extern HRESULT rsipQueryLocalAddress(LPGLOBALDATA lpgd, BOOL ftcp_udp, SOCKADDR *saddrquery, SOCKADDR *saddrlocal);
extern HRESULT rsipListenPort(LPGLOBALDATA lpgd, BOOL ftcp_udp, WORD port, SOCKADDR *psaddr, DWORD *pBindid);
extern VOID rsipPortExtend(LPGLOBALDATA lpgd, DWORD time);
extern VOID rsipCacheClear(LPGLOBALDATA pgd, DWORD time);

#endif /* _RSIP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\nathelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       nathelp.c
 *  Content:   usage for nat helper DLL
 *
 *  History:
 *  Date			By		Reason
 *  ====			==		======
 *  02/22/2001		aarono	Original
 *  04/16/2001		vanceo	Use one of the split DirectPlayNATHelp interfaces only.
 *
 *  Notes:
 *   
 ***************************************************************************/


#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#define FD_SETSIZE 1
#include <winsock2.h>
#include "dpsp.h"
#include "mmsystem.h"
#if USE_NATHELP

#include "dpnathlp.h"

BOOL natGetCapsUpdate(LPGLOBALDATA pgd)
{
	HRESULT hr;
	//
	// Get Nat Capabilities - may block for a second.
	//
	
	memset(&pgd->NatHelpCaps,0,sizeof(DPNHCAPS));
	pgd->NatHelpCaps.dwSize=sizeof(DPNHCAPS);
	hr=IDirectPlayNATHelp_GetCaps(pgd->pINatHelp, &pgd->NatHelpCaps, DPNHGETCAPS_UPDATESERVERSTATUS);
	
	if(FAILED(hr))
	{
		DPF(0,"NatHelp failed to GetCaps, hr=%x\n",hr);
		return FALSE;
	}

	if (hr == DPNHSUCCESS_ADDRESSESCHANGED)
	{
		DPF(1,"NAT Help reports addresses changed, possible connection problems may occur.");
	}

	return TRUE;

}

/*=============================================================================

	natInit	- Initialize nat helper i/f
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/
BOOL natInit(LPGLOBALDATA pgd,LPGUID lpguidSP)
{
	BOOL bReturn = TRUE;
	HRESULT hr;
	char szNATHelpPath[256];
	PFN_DIRECTPLAYNATHELPCREATE pfnNatHelpCreate;
	BOOL fInitialized = FALSE;

	pgd->hNatHelp = NULL;
	pgd->pINatHelp = NULL;

	pgd->hNatHelpTCP = 0;
	pgd->hNatHelpUDP = 0;

    // build an internet INADDRANY
    memset(&pgd->INADDRANY,0,sizeof(SOCKADDR));
    pgd->INADDRANY.sa_family=AF_INET;


	//
	// See if there's a registry override.
	//
	hr = GetNATHelpDLLFromRegistry(lpguidSP, szNATHelpPath, 256);
	if (hr != S_OK)
	{
		strcpy(szNATHelpPath, "dpnhpast.dll");
		DPF(4, "Couldn't get NatHelp DLL from registry, hr=%x, using default \"%s\".\n", hr, szNATHelpPath);
	}
	else
	{
		DPF(1, "Got NatHelp DLL \"%s\" from registry.\n", szNATHelpPath);
	}



	pgd->hNatHelp = LoadLibrary(szNATHelpPath);
	if (pgd->hNatHelp == NULL)
	{
		goto err_exit;
	}
		
	pfnNatHelpCreate = (PFN_DIRECTPLAYNATHELPCREATE) GetProcAddress(pgd->hNatHelp, "DirectPlayNATHelpCreate");
	if (pfnNatHelpCreate == NULL)
	{
		goto err_exit;
	}
	
	hr = pfnNatHelpCreate(&IID_IDirectPlayNATHelp, (void **) (&pgd->pINatHelp));
	if (hr != DP_OK)
	{
		goto err_exit;
	}

	//
	// Initialize the Nat helper interface.
	//
	hr=IDirectPlayNATHelp_Initialize(pgd->pINatHelp, 0);
	if (hr != DP_OK)
	{
		DPF(0, "NatHelp failed to Initialize, hr=%x\n", hr);
		goto err_exit;
	}
	
	fInitialized = TRUE;

	if (! natGetCapsUpdate(pgd))
	{
		goto err_exit;
	}


	//
	// If there isn't currently a NAT/firewall, or it isn't giving a public address
	// (a.k.a. isn't dialed out), then don't use NAT Help.  We can't handle
	// dynamic address changes, so this will never be useful.
	//
	if ((! (pgd->NatHelpCaps.dwFlags & (DPNHCAPSFLAG_LOCALFIREWALLPRESENT | DPNHCAPSFLAG_GATEWAYPRESENT))) ||
		(! (pgd->NatHelpCaps.dwFlags & DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE)))
	{
		DPF(1, "No Internet gateway or it has no public address (flags = 0x%lx).",
			pgd->NatHelpCaps.dwFlags);
	}

	return TRUE;

err_exit:
		
	if (pgd->pINatHelp)
	{
		if (fInitialized)
		{
			IDirectPlayNATHelp_Close(pgd->pINatHelp, 0);
		}
		
		IDirectPlayNATHelp_Release(pgd->pINatHelp);
		pgd->pINatHelp = NULL;
	}	

	if (pgd->hNatHelp)
	{
		FreeLibrary(pgd->hNatHelp);
		pgd->hNatHelp = NULL;
	}
	

	return FALSE;
}

/*=============================================================================

	natExtend - checks if port leases needs extension and extends 
					 them if necessary
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

VOID natExtend(LPGLOBALDATA pgd)
{
	natGetCapsUpdate(pgd);
}

/*=============================================================================

	natFini - Shut down NATHELP support
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
VOID natFini(LPGLOBALDATA pgd)
{

	// natDeregisterPorts(pgd); - vance says we don't need to do this.
	if(pgd->pINatHelp)
	{
        IDirectPlayNATHelp_Close(pgd->pINatHelp, 0);
    	pgd->hNatHelpTCP = 0;
	    pgd->hNatHelpUDP = 0;
		IDirectPlayNATHelp_Release(pgd->pINatHelp);
		pgd->pINatHelp=NULL;
	}	

	if(pgd->hNatHelp)
	{
		FreeLibrary(pgd->hNatHelp);
		pgd->hNatHelp=NULL;
	}
		
}

/*=============================================================================

	natRegisterPort - Get a port mapping.
	
	
    Description:

		Note only one mapping each for TCP and UDP are supported (for simplicity).

    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
HRESULT natRegisterPort(LPGLOBALDATA pgd, BOOL ftcp_udp, WORD port)
{
	SOCKADDR_IN 	sockaddr_in, sockaddr_inpublic;
	DWORD			dwFlags, dwSize;
	DPNHHANDLE		hPortMapping;
	HRESULT 		hr=DP_OK;
	
	memset(&sockaddr_in , 0 ,sizeof(sockaddr_in));
	sockaddr_in.sin_family          = AF_INET;
	sockaddr_in.sin_addr.S_un.S_addr= INADDR_ANY;
	sockaddr_in.sin_port            = htons(port);

	if (ftcp_udp)
	{
		dwFlags = DPNHREGISTERPORTS_TCP;
	}
	else
	{
		dwFlags = 0;
	}

	hr=IDirectPlayNATHelp_RegisterPorts(pgd->pINatHelp, (SOCKADDR *)&sockaddr_in, sizeof(sockaddr_in), 1, 15*60000, &hPortMapping, dwFlags);
	if (hr != DPNH_OK)
	{
		DPF(0,"NATHelp_RegisterPorts registration failed, hr=%x",hr);
		hr = DPERR_GENERIC;
	}
	else
	{
		dwSize=sizeof(sockaddr_inpublic);
		hr = IDirectPlayNATHelp_GetRegisteredAddresses(pgd->pINatHelp, hPortMapping, (SOCKADDR *)&sockaddr_inpublic, &dwSize, NULL, NULL, 0);
		switch (hr)
		{
			case DPNH_OK:
			{
	      		DPF(2, "NATHelp successfully mapped port to %s:%u.",
	      			inet_ntoa(sockaddr_inpublic.sin_addr), ntohs(sockaddr_inpublic.sin_port) );
	      		
				if (ftcp_udp)
				{
					ASSERT(!pgd->hNatHelpTCP);
					if(pgd->hNatHelpTCP)
					{
						DPF(0,"WARNING: trying to map a TCP connection when one is already mapped?\n");
					}
					pgd->hNatHelpTCP=hPortMapping;
					
					memcpy(&pgd->saddrpubSystemStreamSocket, &sockaddr_inpublic, sizeof(SOCKADDR_IN));
				}
				else
				{
					ASSERT(!pgd->hNatHelpUDP);
					if (pgd->hNatHelpUDP)
					{
						DPF(0,"WARNING: trying to map a UDP connection when one is already mapped?\n");
					}
					pgd->hNatHelpUDP=hPortMapping;
					
					memcpy(&pgd->saddrpubSystemDGramSocket, &sockaddr_inpublic, sizeof(SOCKADDR_IN));
				}
				break;
			}
			
			case DPNHERR_PORTUNAVAILABLE:
			{
	      		DPF(0, "NATHelp reported port %u is unavailable!", port);
		    		
				hr=IDirectPlayNATHelp_DeregisterPorts(pgd->pINatHelp, hPortMapping, 0);
				if (hr != DP_OK)
				{
					DPF(0,"NATHelp_DeregisterPorts returned %x\n",hr);
				}
				
				hr = DPNHERR_PORTUNAVAILABLE;
				break;
			}
			
			default:
			{
		    	DPF(1, "NATHelp couldn't map port %u, (err = 0x%lx).", port, hr);
		    	
				if (ftcp_udp)
				{
					ASSERT(!pgd->hNatHelpTCP);
					if(pgd->hNatHelpTCP)
					{
						DPF(0,"WARNING: trying to map a TCP connection when one is already mapped?\n");
					}
					pgd->hNatHelpTCP=hPortMapping;
				}
				else
				{
					ASSERT(!pgd->hNatHelpUDP);
					if (pgd->hNatHelpUDP)
					{
						DPF(0,"WARNING: trying to map a UDP connection when one is already mapped?\n");
					}
					pgd->hNatHelpUDP=hPortMapping;
				}

				hr = DPERR_GENERIC;
				break;
			}
		}
	}
	
	return hr;
}


/*=============================================================================

	natDeregisterPort - Get rid of either UDP or TCP port mappings
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
VOID natDeregisterPort(LPGLOBALDATA pgd, BOOL ftcp_udp)
{
	HRESULT hr;

	if(ftcp_udp && pgd->hNatHelpTCP){
	    DPF(8,"Deregister TCP port\n");
		hr=IDirectPlayNATHelp_DeregisterPorts(pgd->pINatHelp, pgd->hNatHelpTCP, 0);
		if(hr!=DP_OK){
			DPF(0,"NATHelp_DeRegisterPorts returned %x\n",hr);
		}
		pgd->hNatHelpTCP=0;

		memset(&pgd->saddrpubSystemStreamSocket, 0, sizeof(SOCKADDR_IN));
	}
	if(!ftcp_udp && pgd->hNatHelpUDP){
	    DPF(8,"Deregistering UDP port\n");
		hr=IDirectPlayNATHelp_DeregisterPorts(pgd->pINatHelp, pgd->hNatHelpUDP, 0);
		if(hr!=DP_OK){
			DPF(0,"NATHelp_DeRegisterPorts returned %x\n",hr);
		}
		pgd->hNatHelpUDP=0;

		memset(&pgd->saddrpubSystemDGramSocket, 0, sizeof(SOCKADDR_IN));
	}	
}




/*=============================================================================

	natIsICSMachine - Return TRUE if this machine is a Windows ICS machine, FALSE otherwise
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
BOOL natIsICSMachine(LPGLOBALDATA pgd)
{
	if (pgd->pINatHelp != NULL)
	{
		if ((pgd->NatHelpCaps.dwFlags & DPNHCAPSFLAG_GATEWAYPRESENT) &&
			(pgd->NatHelpCaps.dwFlags & DPNHCAPSFLAG_GATEWAYISLOCAL))
		{
			DPF(1, "Local internet gateway present, flags = 0x%x.", pgd->NatHelpCaps.dwFlags);
			return TRUE;
		}
		else
		{
			DPF(1, "No local internet gateway present, flags = 0x%x.", pgd->NatHelpCaps.dwFlags);
		}
	}
	else
	{
		DPF(1, "NAT Help not loaded.");
	}

	return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\rsip.c ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rsip.c
 *  Content:	Realm Specific IP Support
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  12/7/99		aarono	Original
 *
 *  Notes:
 *   
 *  Could optimize the building of messages with pre-initialized
 *  structures for each command, since most of the command is the same
 *  on every request anyway.
 *
 ***************************************************************************/


#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#define FD_SETSIZE 1
#include <winsock2.h>
#include "dpsp.h"

#if USE_RSIP
#include "rsip.h"
#include "mmsystem.h"

typedef unsigned __int64 ULONGLONG;
#include <iphlpapi.h>
typedef DWORD (WINAPI *LpFnGetAdaptersInfo)(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);
typedef DWORD (WINAPI *LpFnGetBestInterface)(UINT ipaddr, PULONG pIndex);
typedef DWORD (WINAPI *LpFnIpRenewAddress)(PIP_ADAPTER_INDEX_MAP  AdapterInfo);
//NOTE AN_IP_ADDRESS's value is unimportant.
#define AN_IP_ADDRESS "204.107.191.254"
#define LOOPBACK_ADDR "127.0.0.1"
#define RESP_BUF_SIZE 100

// Local Functions
HRESULT rsipFindGateway(UINT myip,char *gwipaddr);
HRESULT rsipRegister(LPGLOBALDATA pgd);
HRESULT rsipDeregister(LPGLOBALDATA lpgd);
HRESULT rsipParse(CHAR *pBuf, DWORD cbBuf, PRSIP_RESPONSE_INFO pRespInfo);
VOID rsipRemoveLease(LPGLOBALDATA pgd, DWORD bindid);
VOID rsipAddLease(LPGLOBALDATA pgd, DWORD bindid, BOOL ftcp_udp, DWORD addrV4, WORD lport, WORD port, DWORD tLease);
PRSIP_LEASE_RECORD rsipFindLease(LPGLOBALDATA pgd, BOOL ftcp_udp, WORD port);
VOID rsipAddCacheEntry(LPGLOBALDATA pgd, BOOL ftcp_udp, DWORD addr, WORD port, DWORD raddr, WORD rport);
PADDR_ENTRY rsipFindCacheEntry(LPGLOBALDATA pgd, BOOL ftcp_udp, DWORD addr, WORD port);


/*=============================================================================

	rsipInit - Initialize RSIP support.  If this function succeeds then there
			   is an RSIP gateway on the network and the SP should call the
			   RSIP services when creating and destroying sockets that need
			   to be accessed from machines outside the local realm.
	
    Description:

		Looks for the Gateway, then check to see if it is RSIP enabled.

    Parameters:

    	pgd  - Service Provider's global data blob for this instance
    	lpguidSP - Service Provider guid so we can lookup gateway 
    				in the registry on Win95 original.

    Return Values:

		TRUE  - found and RSIP gateway and initialized.
		FALSE - no RSIP gateway found.

-----------------------------------------------------------------------------*/
BOOL rsipInit(LPGLOBALDATA pgd, LPGUID lpguidSP)
{
	HRESULT hr;
	char gwipaddr[32];
	BOOL bReturn = TRUE;
	SOCKADDR_IN saddr;

	try {
	
		InitializeCriticalSection(&pgd->csRsip);
		
	} except ( EXCEPTION_EXECUTE_HANDLER) {

		// Catch STATUS_NOMEMORY
		bReturn=FALSE;
		goto exit;
	}

	// find the default gateway
	hr = rsipFindGateway(inet_addr(AN_IP_ADDRESS),gwipaddr);

	if(hr!=DP_OK){

		hr = GetGatewayFromRegistry(lpguidSP, gwipaddr, sizeof(gwipaddr));

		if(hr == DP_OK){
			DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
		} else {
			// this is the default address of Millennium NAT gateway.
			memcpy(gwipaddr, "192.168.0.1", sizeof("192.168.0.1"));
			DPF(0,"Couldn't find regkey for gateway so trying %s, running on Win95?\n",gwipaddr);
		}

	}

	// create a SOCKADDR to address the RSIP service on the gateway
	memset(&pgd->saddrGateway, 0, sizeof(SOCKADDR_IN));
	pgd->saddrGateway.sin_family      = AF_INET;
	pgd->saddrGateway.sin_addr.s_addr = inet_addr(gwipaddr);
	pgd->saddrGateway.sin_port 	      = htons(RSIP_HOST_PORT);

	// create a datagram socket for talking to the RSIP facility on the gateway
	if((pgd->sRsip = socket(AF_INET,SOCK_DGRAM,0))==INVALID_SOCKET){
		DPF(0,"ERROR: rsipInit() socket call for RSIP listener failed\n");
		bReturn = FALSE;
		goto exit;
	}

	// create an address to specify the port to bind our datagram socket to.
	memset(&saddr,0,sizeof(SOCKADDR_IN));
	saddr.sin_family	  = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
	saddr.sin_port        = htons(0);

	// bind the datagram socket to any local address and port.
	if(bind(pgd->sRsip, (PSOCKADDR)&saddr, sizeof(saddr)) != 0){
		DPF(0,"ERROR: rsipInit() bind for RSIP listener failed\n");
		bReturn=FALSE;
		goto exit;
	}

	pgd->tuRetry=12500; // start retry timer at 12.5 ms

	// find out if there is an rsip service and register with it.
	if((hr=rsipRegister(pgd))!=DP_OK){
		bReturn=FALSE;
	}

exit:

	if(bReturn==FALSE){
		 if(pgd->sRsip != INVALID_SOCKET){
		     closesocket(pgd->sRsip);
		     pgd->sRsip=INVALID_SOCKET;
		 }    
	}

	return bReturn;
}

/*=============================================================================

	rsipCloseConnection - Close connection to RSIP agent
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/

VOID rsipCloseConnection(LPGLOBALDATA pgd)
{
	if(pgd->sRsip!=INVALID_SOCKET){
		rsipDeregister(pgd);	
		closesocket(pgd->sRsip);
		pgd->sRsip=INVALID_SOCKET;
	}	
}


/*=============================================================================

	rsipFini - Shut down RSIP support
	
	   All threads that might access RSIP MUST be stopped before this
	   is called.
	
    Description:

		Deregisters with the Rsip Agent on the gateway, and cleans up
		the list of lease records.

    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
VOID rsipFini(LPGLOBALDATA pgd)
{
	PRSIP_LEASE_RECORD pLeaseWalker, pNextLease;
	PADDR_ENTRY pAddrWalker, pNextAddr;
	
	rsipCloseConnection(pgd);
		
	DeleteCriticalSection(&pgd->csRsip);

	ENTER_DPSP(); // need lock for memory ops

	// free the leases
	pLeaseWalker=pgd->pRsipLeaseRecords;
	while(pLeaseWalker){
		pNextLease = pLeaseWalker->pNext;
		SP_MemFree(pLeaseWalker);
		pLeaseWalker=pNextLease;
	}
	pgd->pRsipLeaseRecords=NULL;

	// free the cached address mappings
	pAddrWalker=pgd->pAddrEntry;
	while(pAddrWalker){
		pNextAddr=pAddrWalker->pNext;
		SP_MemFree(pAddrWalker);
		pAddrWalker=pNextAddr;
	}
	pgd->pAddrEntry=NULL;
	
	LEAVE_DPSP();
}


/*=============================================================================

	rsipFindGateway - find the address of the internet gateway (possibly RSIP
				  host) for this machine.

	
    Description:

		Uses the ip helper api to find the default IP gateway.

    Parameters:

		uint32 myip      - ip adapter to find default gateway for
		char   *gwipaddr - gateway address if found

    Return Values:

		DP_OK - found gateway
		DPERR_GENERIC - failed.

	Note: code stolen from Rick Lamb (rlamb)
	
-----------------------------------------------------------------------------*/

HRESULT rsipFindGateway(UINT myip,char *gwipaddr)
{
  PIP_ADAPTER_INFO pAdapterInfo = NULL,p0AdapterInfo = NULL;
  DWORD            error = 0, len = 0;
  UINT             i;
  HANDLE           hIpHlpApi;
  UINT 		   	   bindex;
  
  IP_ADAPTER_INDEX_MAP ipaim;
  LpFnGetAdaptersInfo  lpFnGetAdaptersInfo;
  LpFnGetBestInterface lpFnGetBestInterface;
  LpFnIpRenewAddress   lpFnIpRenewAddress;

 /*
   * See if there is an RSIP server running.
   * If so, we must be running on the server itself
   * so use the loopback interface.
   */
  if(gwipaddr) {
    SOCKET s;
    SOCKADDR_IN addr;

    if((s=socket(AF_INET,SOCK_DGRAM,0)) != INVALID_SOCKET) {
      	memset(&addr,0,sizeof(SOCKADDR_IN));
      	addr.sin_family = AF_INET;
      	addr.sin_addr.s_addr = inet_addr(LOOPBACK_ADDR);
      	addr.sin_port = htons(RSIP_HOST_PORT);
      	if(bind(s,(struct sockaddr *)&addr,sizeof(addr)) != 0) {
			/*
		 	* Something is there already
			*/
			memcpy(gwipaddr,LOOPBACK_ADDR,sizeof(LOOPBACK_ADDR));
			DPF(0,"USING LOOPBACK: default gateway %s\n",gwipaddr);
			closesocket(s);
			goto done;
      	}
      	closesocket(s);
    }
    
  }

  hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
  if(hIpHlpApi == NULL) {
    error = DPERR_GENERIC;
    DPF_ERR("[NET] failed to load IPHLPAIP.DLL\n");
    goto done;
  }
    
  lpFnGetAdaptersInfo = (LpFnGetAdaptersInfo) GetProcAddress(hIpHlpApi, "GetAdaptersInfo");
  if(lpFnGetAdaptersInfo == NULL) {
    DPF_ERR("[NET] failed to find GetAdaptersInfo\n");
    error = DPERR_GENERIC;
    goto done;
  }

  error = (*lpFnGetAdaptersInfo) (pAdapterInfo, &len);
  if(error != ERROR_BUFFER_OVERFLOW) {
    DPF(0,"[NET] GetAdaptersInfo failed error 0x%lx\n", error);  
    error=DPERR_GENERIC;
    goto done;
  }

  p0AdapterInfo = pAdapterInfo = (PIP_ADAPTER_INFO) SP_MemAlloc(len);
  if(pAdapterInfo == NULL) {
    DPF_ERR("[NET] memory allocation failed\n");  
    error=DPERR_GENERIC;
    goto done;
  }

  error = (*lpFnGetAdaptersInfo) (pAdapterInfo, &len);
  if(error != 0) {
    DPF(0, "[NET] GetAdaptersInfo failed error 0x%lx\n", error);  
    error=DPERR_GENERIC;
    goto done;
  }

  lpFnIpRenewAddress = (LpFnIpRenewAddress) GetProcAddress(hIpHlpApi,"IpRenewAddress");
  if(lpFnIpRenewAddress == NULL) {
    DPF_ERR(" failed to find IpRenewAddress\n");
    error=DPERR_GENERIC;
    goto done;
  }


  lpFnGetBestInterface = (LpFnGetBestInterface) GetProcAddress(hIpHlpApi, "GetBestInterface");
  if(lpFnGetBestInterface == NULL) {
    DPF_ERR(" failed to find GetBestInterface\n");
    error=DPERR_GENERIC;
    goto done;
  }

  error = (*lpFnGetBestInterface) (myip, &bindex);
  if(error != 0) {
    DPF(0,"[NET] GetBestInterface failed error 0x%lx\n", error);  
    error=DPERR_GENERIC;
    goto done;
  }
  /*printf("Renew Interface Index = %d\n",bindex);/**/

  for(i = 0; pAdapterInfo != NULL; i++, pAdapterInfo = pAdapterInfo->Next) {
    DPF(8,"[NET] Adapter Info\n");  
    DPF(8,"[NET] \t name %s\n",pAdapterInfo->AdapterName);  
    DPF(8,"[NET] \t description %s\n",pAdapterInfo->Description);  
    DPF(8,"[NET] \t index %d\n",pAdapterInfo->Index);  
    DPF(8,"[NET] \t combo index %d\n",pAdapterInfo->ComboIndex);  
    if(pAdapterInfo->Index == bindex) break;
  }

  if(pAdapterInfo == NULL) {
    DPF(8,"No match\n");
    error=DPERR_GENERIC;
    goto done;
  }

  {
    PIP_ADDR_STRING ips;
    ips = &pAdapterInfo->GatewayList;
    if(gwipaddr) {
      strcpy(gwipaddr,ips->IpAddress.String);
      DPF(0,"default gateway %s\n",gwipaddr);
      goto done;
    }
  }

done:
  if(p0AdapterInfo) SP_MemFree(p0AdapterInfo);
  if(hIpHlpApi) FreeLibrary(hIpHlpApi);
  DPF(8,"[NET] < FindGateway\n");

  return error;
}


/*=============================================================================

	rsipExchangeAndParse - send a request to the rsip server and 
						   wait for and parse the reply

	
    Description:

	Since there is almost no scenario where we don't immediately need to know
	the response to an rsipExchange, there is no point in doing this 
	asynchronously.  The assumption is that an RSIP server is sufficiently
	local that long retries are not necessary.  We use the approach suggested
	in the IETF draft protocol specification, that is 12.5ms retry timer
	with 7fold exponential backoff.  This can lead to up to a total 1.5 
	second wait in the worst case.  (Note this section may no longer be 
	available since the rsip working group decided to drop UDP support)

    Parameters:

		pgd		  - global data
		pRequest  - a fully formatted RSIP request buffer
		cbReq     - size of request buffer
		pRespInfo - structure that returns response parameters
		messageid - the message id of this request
		bConnect  - whether this is the register request, we use a different
					timer strategy on initial connect because we really
					don't want to miss it if there is a gateway.

    Return Values:

		DP_OK - exchange succeeded, reply is in the reply buffer.
		otw, failed, RespInfo is bubkas.

-----------------------------------------------------------------------------*/

#define MAX_RSIP_RETRY	6

struct timeval tv0={0,0};

HRESULT rsipExchangeAndParse(
	LPGLOBALDATA pgd, 
	PCHAR pRequest, 
	UINT cbReq, 
	PRSIP_RESPONSE_INFO pRespInfo,
	DWORD messageid,
	BOOL bConnect)
{
	CHAR  RespBuffer[RESP_BUF_SIZE];
	DWORD dwRespLen=RESP_BUF_SIZE;
	
	struct timeval tv;
	FD_SET readfds;
	INT    nRetryCount=0;
	int    rc;
	int    cbReceived;
	HRESULT hr=DP_OK;

	DPF(8,"==>RsipExchangeAndParse msgid %d\n",messageid);

	memset(RespBuffer,0,RESP_BUF_SIZE);
	memset(pRespInfo,0,sizeof(RSIP_RESPONSE_INFO));

	if(!bConnect){
		tv.tv_usec = pgd->tuRetry;
		tv.tv_sec  = 0;
		nRetryCount = 0;
	} else {
		// on a connect request we try twice with a 1 second total timeout
		tv.tv_usec = 500000;	// 0.5 seconds
		tv.tv_sec  = 0;
		nRetryCount = MAX_RSIP_RETRY-2;
	}


	FD_ZERO(&readfds);
	FD_SET(pgd->sRsip, &readfds);
	
	rc=0;

	// First clear out any extraneous responses.
	while(select(0,&readfds,NULL,NULL,&tv0)){
		cbReceived=recvfrom(pgd->sRsip, RespBuffer, dwRespLen, 0, NULL, NULL);
		if(cbReceived && cbReceived != SOCKET_ERROR){
			DPF(7,"Found extra response from previous RSIP request\n");
			if(pgd->tuRetry < RSIP_tuRETRY_MAX){
				// don't re-try so quickly
				pgd->tuRetry *= 2;
				DPF(7,"rsip Set tuRetry to %d usec\n",pgd->tuRetry);
			}	
		} else {
			#ifdef DEBUG
			if(cbReceived == SOCKET_ERROR){
				rc=WSAGetLastError();
				DPF(0,"Got sockets error %d trying to receive (clear incoming queue) on RSIP socket\n",rc);
				hr=DPERR_GENERIC;
			}
			#endif
			break;
		}
		FD_ZERO(&readfds);
		FD_SET(pgd->sRsip, &readfds);
	}


	// Now do the exchange, get a response to the request, does retries too.
	do{
	
		if(++nRetryCount > MAX_RSIP_RETRY) {
			break;
		}
		
		// First send off the request

		rc=sendto(pgd->sRsip, pRequest, cbReq, 0, (SOCKADDR *)&pgd->saddrGateway,sizeof(SOCKADDR) );
		
		if(rc == SOCKET_ERROR){
			rc=WSAGetLastError();
			DPF(0,"Got sockets error %d on sending to RSIP gateway\n",rc);
			hr=DPERR_GENERIC;
			goto exit;
		}
		if(rc != (int)cbReq){
			DPF(0,"Didn't send entire datagram?  shouldn't happen\n");
			hr=DPERR_GENERIC;
			goto exit;
		}

		// Now see if we get a response.
select_again:		
		FD_ZERO(&readfds);
		FD_SET(pgd->sRsip, &readfds);
		
		rc=select(0,&readfds,NULL,NULL,&tv);
		
		if(rc==SOCKET_ERROR){
			rc=WSAGetLastError();
			DPF(0,"Got sockets error %d trying to select on RSIP socket\n",rc);
			hr=DPERR_GENERIC;
			goto exit;
		}

		if(FD_ISSET(pgd->sRsip, &readfds)){
			break;
		}

		if(!bConnect){  
			// don't use exponential backoff on initial connect
			tv.tv_usec *= 2;	// exponential backoff.
		}	

		ASSERT(tv.tv_usec < 4000000);
		
	} while (rc==0); // keep retrying...


	if(rc == SOCKET_ERROR){
		DPF(0,"GotSocketError on select, extended error %d\n",WSAGetLastError());
		hr=DPERR_GENERIC;
		goto exit;
	}

	if(rc){
		// We Got Mail, err data....
		dwRespLen=RESP_BUF_SIZE;
		cbReceived=recvfrom(pgd->sRsip, RespBuffer, dwRespLen, 0, NULL, NULL);

		// OPTIMIZATION:Could get and check addrfrom to avoid spoofing, not that paranoid
		
		if(!cbReceived || cbReceived == SOCKET_ERROR){
			rc=WSAGetLastError();
			DPF(0,"Got sockets error %d trying to receive on RSIP socket\n",rc);
			hr=DPERR_GENERIC;
		} else {
			rsipParse(RespBuffer,cbReceived,pRespInfo);
			if(pRespInfo->messageid != messageid){
				// Got a dup from a previous retry, go try again.
				DPF(0,"Got messageid %d, expecting messageid %d\n",pRespInfo->messageid, messageid);
				goto select_again;
			}
		}
	}

	DPF(8,"<==RsipExchangeAndParse hr=%x, Resp msgid %d\n",hr,pRespInfo->messageid);

exit:
	return hr;
}

/*=============================================================================

	rsipParse - parses an RSIP request and puts fields into a struct.
	
    Description:

		This parser parses and RSIP request or response and extracts
		out the codes into a standard structure.  This is not completely
		general, as we know that we will only operate with v4 addresses
		and our commands will never deal with more than 1 address at a
		time.  If you need to handle multiple address requests
		and responses, then you will need to change this function.

	Limitations:

		This function only deals with single address/port responses.
		Rsip allows for multiple ports to be allocated in a single
		request, but we do not take advantage of this feature.

    Parameters:

		pBuf  		- buffer containing an RSIP request or response
		cbBuf 		- size of buffer in bytes
		pRespInfo   - a structure that is filled with the parameters
					  from the RSIP buffer.

    Return Values:

		DP_OK - connected to the RSIP server.

-----------------------------------------------------------------------------*/

HRESULT rsipParse(
	CHAR *pBuf, 
	DWORD cbBuf, 
	PRSIP_RESPONSE_INFO pRespInfo
	)
{
	// character pointer version of parameter pointer.

	BOOL bGotlAddress=FALSE;
	BOOL bGotlPort   =FALSE;

	DWORD code;
	DWORD codelen;

	PRSIP_MSG_HDR pHeader;
	PRSIP_PARAM   pParam,pNextParam;
	CHAR          *pc;
	
	CHAR *pBufEnd = pBuf+cbBuf;

	if(cbBuf < 2){
		return DPERR_INVALIDPARAM;
	}	

	pHeader=(PRSIP_MSG_HDR)pBuf;

	pRespInfo->version = pHeader->version;
	pRespInfo->msgtype = pHeader->msgtype;

	DPF(0,"rsipParse: version %d msgtype %d\n",pRespInfo->version, pRespInfo->msgtype);

	pParam = (PRSIP_PARAM)(pHeader+1);

	while((CHAR*)(pParam+1) < pBufEnd)
	{
		pc=(CHAR *)(pParam+1);
		pNextParam = (PRSIP_PARAM)(pc + pParam->len);
		
		if((CHAR *)pNextParam > pBufEnd){
			break;
		}	

		switch(pParam->code){
		
			case RSIP_ADDRESS_CODE:

				// Addresses are type[1]|addr[?]
			
				switch(*pc){
					case 1:
						if(!bGotlAddress){
							DPF(0,"rsipParse: lAddress %s\n",inet_ntoa(*((PIN_ADDR)(pc+1))));
							memcpy((char *)&pRespInfo->lAddressV4, pc+1, 4);
							bGotlAddress=TRUE;
						} else {	
							bGotlPort=TRUE; // just in case there wasn't a local port
							DPF(0,"rsipParse: rAddress %s,",inet_ntoa(*((PIN_ADDR)(pc+1))));
							memcpy((char *)&pRespInfo->rAddressV4, pc+1, 4);
						}	
						break;
					case 0:
					case 2:
					case 3:
					case 4:
					case 5:
						DPF(0,"Unexpected RSIP address code type %d\n",*pc);
					break;
				}
				break;
				
			case RSIP_PORTS_CODE:
			
				// Ports are Number[1]|Port[2]....Port[2]
				// NOTE: I think ports are backwards.
				if(!bGotlPort){
					DPF(0,"rsipParse lPort: %d\n", *((WORD *)(pc+1)));
					memcpy((char *)&pRespInfo->lPort, pc+1,2);
				} else {
					DPF(0,"rsipParse rPort: %d\n", *((WORD *)(pc+1)));
					memcpy((char *)&pRespInfo->rPort, pc+1,2);
					bGotlPort=TRUE;					
				}
				break;
				
  			case RSIP_LEASE_CODE:
				if(pParam->len == 4){
					memcpy((char *)&pRespInfo->leasetime,pc,4);
					DPF(0,"rsipParse Lease: %d\n",pRespInfo->leasetime);
				}	
  				break;
  				
  			case RSIP_CLIENTID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->clientid,pc,4);
					DPF(0,"rsipParse clientid: %d\n",pRespInfo->clientid);
  				}
  				break;
  				
  			case RSIP_BINDID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->bindid,pc,4);
					DPF(0,"rsipParse bindid: %x\n",pRespInfo->bindid);
  				}
  				break;
  				
  			case RSIP_MESSAGEID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->messageid,pc,4);
					DPF(0,"rsipParse messageid: %d\n",pRespInfo->messageid);
  				}
  				break;
  				
  			case RSIP_TUNNELTYPE_CODE:
  				DPF(0,"rsipParse Got Tunnel Type %d, ignoring\n",*pc);
  				break;
  				
  			case RSIP_RSIPMETHOD_CODE:
  				DPF(0,"rsipParse Got RSIP Method %d, ignoring\n",*pc);
  				break;
  				
  			case RSIP_ERROR_CODE:
  				if(pParam->len==2){
  					memcpy((char *)&pRespInfo->error,pc,2);
  				}
  				DPF(0,"rsipParse Got RSIP error %d\n",pRespInfo->error);
  				break;
  				
  			case RSIP_FLOWPOLICY_CODE:
  				DPF(0,"rsipParse Got RSIP Flow Policy local %d remote %d, ignoring\n",*pc,*(pc+1));
  				break;
  				
  			case RSIP_VENDOR_CODE:
  				break;

  			default:
  				DPF(0,"Got unknown parameter code %d, ignoring\n",pParam->code);
  				break;
		}

		pParam=pNextParam;

	}

	return DP_OK;
}

/*=============================================================================

	rsipRegister - register with the RSIP server on the gateway (if present)
	
    Description:

		Trys to contact the RSIP service on the gateway. 
		
		Doesn't require lock since this is establishing the link during
		startup.  So no-one is racing with us.

    Parameters:

    	LPGLOBALDATA lpgd = global data for the service provider instance.

    Return Values:

		DP_OK 		  - connected to the RSIP server.
		DPERR_GENERIC - can't find the RSIP service on the gateway.

-----------------------------------------------------------------------------*/
HRESULT rsipRegister(LPGLOBALDATA pgd)
{
	HRESULT hr;

	MSG_RSIP_REGISTER  RegisterReq;
	RSIP_RESPONSE_INFO RespInfo;

	DPF(8,"==>RSIP Register\n");

	// Initialize the message sequencing.  Each message response pair
	// is numbered sequentially to allow differentiation over UDP link.

	pgd->msgid=0;

	// Build the request

	RegisterReq.version    	= RSIP_VERSION;
	RegisterReq.command    	= RSIP_REGISTER_REQUEST;
	RegisterReq.msgid.code 	= RSIP_MESSAGEID_CODE;
	RegisterReq.msgid.len  	= sizeof(DWORD);
	RegisterReq.msgid.msgid = pgd->msgid++;

	hr=rsipExchangeAndParse(pgd, 
					(PCHAR)&RegisterReq, 
					sizeof(RegisterReq), 
					&RespInfo, 
					RegisterReq.msgid.msgid,
					TRUE);

	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_REGISTER_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	pgd->clientid=RespInfo.clientid;

	DPF(8,"<==RSIP Register, ClientId %d\n",pgd->clientid);

exit:
	return hr;

error_exit:
	DPF(8,"<==RSIP Register FAILED\n");
	return DPERR_GENERIC;

}

/*=============================================================================

	rsipDeregister - close connection to RSIP gateway.
	
    Description:

    	Shuts down the registration of this application with the RSIP
    	gateway.  All port assignments are implicitly freed as a result
    	of this operation.

		- must be called with lock held.

    Parameters:

    	LPGLOBALDATA pgd = global data for the service provider instance.

    Return Values:

		DP_OK - successfully deregistered with the RSIP service.

-----------------------------------------------------------------------------*/
HRESULT rsipDeregister(LPGLOBALDATA pgd)
{
	HRESULT hr;

	MSG_RSIP_DEREGISTER  DeregisterReq;
	RSIP_RESPONSE_INFO RespInfo;

	RespInfo.msgtype=-1; //shut up Prefix

	DPF(8,"==>RSIP Deregister\n");

	// Build the request

	DeregisterReq.version    	    = RSIP_VERSION;
	DeregisterReq.command    	    = RSIP_DEREGISTER_REQUEST;
	
	DeregisterReq.clientid.code     = RSIP_CLIENTID_CODE;
	DeregisterReq.clientid.len      = sizeof(DWORD);
	DeregisterReq.clientid.clientid = pgd->clientid;
	
	DeregisterReq.msgid.code 	    = RSIP_MESSAGEID_CODE;
	DeregisterReq.msgid.len  	    = sizeof(DWORD);
	DeregisterReq.msgid.msgid       = pgd->msgid++;

	hr=rsipExchangeAndParse(pgd, 
					(PCHAR)&DeregisterReq, 
					sizeof(DeregisterReq), 
					&RespInfo, 
					DeregisterReq.msgid.msgid,
					FALSE);

	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_DEREGISTER_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	DPF(8,"<==RSIP Deregister Succeeded\n");

exit:
	return hr;

error_exit:
	DPF(8,"<==RSIP Deregister Failed\n");
	return DPERR_GENERIC;

}

/*=============================================================================

	rsipAssignPort - assign a port mapping with the rsip server
	
    Description:

		Asks for a public realm port that is an alias for the local port on 
		this local realm node.  After this request succeeds, all traffic
		directed to the gateway on the public side at the allocated public
		port, which the gateway provides and specifies in the response, will
		be directed to the specified local port.

		This function also adds the lease for the port binding to a list of
		leases and will renew the lease before it expires if the binding
		hasn't been released by a call to rsipFree first.

    Parameters:

    	LPGLOBALDATA pgd      - global data for the service provider instance.
    	WORD	     port     - local port to get a remote port for (big endian)
    	BOOL		 ftcp_udp - whether we are assigning a UDP or TCP port
    	SOCKADDR     psaddr   - place to return assigned global realm address
    	PDWORD       pBindid  - identifier for this binding, used to extend 
    							lease and/or release the binding (OPTIONAL).

    Return Values:

		DP_OK - assigned succeeded, psaddr contains public realm address,
				*pBindid is the binding identifier.
				
		DPERR_GENERIC - assignment of a public port could not be made.

-----------------------------------------------------------------------------*/
HRESULT rsipAssignPort(LPGLOBALDATA pgd, BOOL ftcp_udp, WORD port, SOCKADDR *psaddr, DWORD *pBindid)
{
	#define psaddr_in ((SOCKADDR_IN *)psaddr)
	
	HRESULT hr;

	MSG_RSIP_ASSIGN_PORT AssignReq;
	RSIP_RESPONSE_INFO RespInfo;
	PRSIP_LEASE_RECORD pLeaseRecord;


	EnterCriticalSection(&pgd->csRsip);

	DPF(8,"==>RSIP Assign Port %d\n",htons(port));

	if(pgd->sRsip == INVALID_SOCKET){
		DPF(0,"rsipAssignPort: pgd->sRsip is invalid, bailing...\n");
		LeaveCriticalSection(&pgd->csRsip);
		return DPERR_GENERIC;
	}

	if(pLeaseRecord=rsipFindLease(pgd, ftcp_udp, port)){

		// hey, we've already got a lease for this port, so use it.
		pLeaseRecord->dwRefCount++;

		if(psaddr_in){
			psaddr_in->sin_family = AF_INET;
			psaddr_in->sin_addr.s_addr = pLeaseRecord->addrV4;
			psaddr_in->sin_port		   = pLeaseRecord->rport;
		}	

		if(pBindid){
			*pBindid = pLeaseRecord->bindid;
		}

		DPF(7,"<==Rsip Assign, already have lease Bindid %d\n",pLeaseRecord->bindid);
		
		LeaveCriticalSection(&pgd->csRsip);
		
		hr=DP_OK;


		goto exit;
	}

	// Build the request.
	
	AssignReq.version    		= RSIP_VERSION;
	AssignReq.command    		= RSIP_ASSIGN_REQUEST_RSAP_IP;

	AssignReq.clientid.code 	= RSIP_CLIENTID_CODE;
	AssignReq.clientid.len 		= sizeof(DWORD);
	AssignReq.clientid.clientid = pgd->clientid;

	// Local Address (will be returned by RSIP server, us don't care value)

	AssignReq.laddress.code		= RSIP_ADDRESS_CODE;
	AssignReq.laddress.len		= sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	AssignReq.laddress.version	= 1; // IPv4
	AssignReq.laddress.addr		= 0; // Don't care

	// Local Port, this is a port we have opened that we are assigning a
	// global alias for.

	AssignReq.lport.code		= RSIP_PORTS_CODE;
	AssignReq.lport.len			= sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	AssignReq.lport.nports      = 1;
	AssignReq.lport.port		= htons(port);

	// Remote Address (not used with our flow control policy, use don't care value)

	AssignReq.raddress.code		= RSIP_ADDRESS_CODE;
	AssignReq.raddress.len		= sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	AssignReq.raddress.version  = 1; // IPv4
	AssignReq.raddress.addr     = 0; // Don't care

	AssignReq.rport.code		= RSIP_PORTS_CODE;
	AssignReq.rport.len			= sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	AssignReq.rport.nports      = 1;
	AssignReq.rport.port		= 0; // Don't care

	// Following parameters are optional according to RSIP spec...
	
	// Lease code, ask for an hour, but don't count on it.
	
	AssignReq.lease.code		 = RSIP_LEASE_CODE;
	AssignReq.lease.len			 = sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	AssignReq.lease.leasetime    = 3600;
	
	// Tunnell Type is IP-IP

	AssignReq.tunnel.code		 = RSIP_TUNNELTYPE_CODE;
	AssignReq.tunnel.len		 = sizeof(RSIP_TUNNEL)-sizeof(RSIP_PARAM);
	AssignReq.tunnel.tunneltype  = TUNNEL_IP_IP;

	// Message ID is optional, but we use it since we use UDP xport it is required.
	
	AssignReq.msgid.code 		 = RSIP_MESSAGEID_CODE;
	AssignReq.msgid.len  		 = sizeof(DWORD);
	AssignReq.msgid.msgid   	 = pgd->msgid++;

	// Vendor specific - need to specify port type and no-tunneling

	AssignReq.porttype.code     	 = RSIP_VENDOR_CODE;
	AssignReq.porttype.len      	 = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	AssignReq.porttype.vendorid 	 = RSIP_MS_VENDOR_ID;
	AssignReq.porttype.option   	 = (ftcp_udp)?RSIP_TCP_PORT:RSIP_UDP_PORT;

	AssignReq.tunneloptions.code     = RSIP_VENDOR_CODE;
	AssignReq.tunneloptions.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	AssignReq.tunneloptions.vendorid = RSIP_MS_VENDOR_ID;
	AssignReq.tunneloptions.option   = RSIP_NO_TUNNEL;
	

	hr=rsipExchangeAndParse(pgd, 
					(PCHAR)&AssignReq, 
					sizeof(AssignReq), 
					&RespInfo,
					AssignReq.msgid.msgid,
					FALSE);

	LeaveCriticalSection(&pgd->csRsip);

	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_ASSIGN_RESPONSE_RSAP_IP){
		DPF(0,"Assignment failed? Response was %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	if(psaddr_in){
		psaddr_in->sin_family = AF_INET;
		psaddr_in->sin_addr.s_addr = RespInfo.lAddressV4;
		psaddr_in->sin_port		   = htons(RespInfo.lPort);
	}

	if(pBindid){
		*pBindid = RespInfo.bindid;
	}

	rsipAddLease(pgd,RespInfo.bindid,ftcp_udp,RespInfo.lAddressV4,htons(RespInfo.lPort),port,RespInfo.leasetime);

	DEBUGPRINTADDR(8,"RSIP Port Assigned\n",(SOCKADDR *)psaddr_in);
	DPF(8,"<== BindId %d\n",RespInfo.bindid);
	
exit:
	return hr;

error_exit:
	DPF(8,"<==Assign Port Failed\n");
	return DPERR_GENERIC;

	#undef psaddr_in
}

/*=============================================================================

	rsipExtendPort - extend a port mapping
	
    Description:

		Extends the lease on a port mapping.  

    Parameters:

    	LPGLOBALDATA pgd    - global data for the service provider instance.
    	DWORD        Bindid - binding identifier specified by the rsip service.
    	DWORD        ptExtend - amount of extra lease time granted.

    Return Values:

		DP_OK - lease extended.
		DPERR_GENERIC - couldn't extend the lease.

-----------------------------------------------------------------------------*/
HRESULT rsipExtendPort(LPGLOBALDATA pgd, DWORD Bindid, DWORD *ptExtend)
{
	HRESULT hr;

	MSG_RSIP_EXTEND_PORT  ExtendReq;
	RSIP_RESPONSE_INFO RespInfo;

	EnterCriticalSection(&pgd->csRsip);

	DPF(8,"==>Extend Port, Bindid %d\n",Bindid);

	if(pgd->sRsip == INVALID_SOCKET){
		DPF(0,"rsipExtendPort: pgd->sRsip is invalid, bailing...\n");
		LeaveCriticalSection(&pgd->csRsip);
		return DPERR_GENERIC;
	}

	// Build the request

	ExtendReq.version    		= RSIP_VERSION;
	ExtendReq.command    		= RSIP_EXTEND_REQUEST;

	ExtendReq.clientid.code 	= RSIP_CLIENTID_CODE;
	ExtendReq.clientid.len 		= sizeof(DWORD);
	ExtendReq.clientid.clientid = pgd->clientid;

	ExtendReq.bindid.code 		= RSIP_BINDID_CODE;
	ExtendReq.bindid.len 		= sizeof(DWORD);
	ExtendReq.bindid.bindid 	= Bindid;

	// Lease code, ask for an hour, but don't count on it.
	
	ExtendReq.lease.code		= RSIP_LEASE_CODE;
	ExtendReq.lease.len			= sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	ExtendReq.lease.leasetime   = 3600;

	ExtendReq.msgid.code 		= RSIP_MESSAGEID_CODE;
	ExtendReq.msgid.len  		= sizeof(DWORD);
	ExtendReq.msgid.msgid   	= pgd->msgid++;

	hr=rsipExchangeAndParse(pgd, 
					(PCHAR)&ExtendReq, 
					sizeof(ExtendReq), 
					&RespInfo,
					ExtendReq.msgid.msgid,
					FALSE);

	LeaveCriticalSection(&pgd->csRsip);
	
	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_EXTEND_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	*ptExtend=RespInfo.leasetime;

	DPF(8,"<==Extend Port, Bindid %d Succeeded, extra lease time %d\n",Bindid,*ptExtend);

exit:
	return hr;

error_exit:
	DPF(8,"<==Extend Port, Failed");
	return DPERR_GENERIC;

}

/*=============================================================================

	rsipFreePort - release a port binding
	
    Description:

		Removes the lease record for our port binding (so we don't renew it
		after we actually release the binding from the gateway).  Then informs
		the gateway that we are done with the binding.

    Parameters:

    	LPGLOBALDATA pgd    - global data for the service provider instance.
    	DWORD        Bindid - gateway supplied identifier for the binding

    Return Values:

		DP_OK - port binding released.
		DPERR_GENERIC - failed.

-----------------------------------------------------------------------------*/
HRESULT rsipFreePort(LPGLOBALDATA pgd, DWORD Bindid)
{
	HRESULT hr;

	MSG_RSIP_FREE_PORT  FreeReq;
	RSIP_RESPONSE_INFO RespInfo;

	EnterCriticalSection(&pgd->csRsip);

	DPF(8,"==>Release Port, Bindid %d\n",Bindid);

	if(pgd->sRsip == INVALID_SOCKET){
		DPF(0,"rsipFreePort: pgd->sRsip is invalid, bailing...\n");
		LeaveCriticalSection(&pgd->csRsip);
		return DPERR_GENERIC;
	}

	rsipRemoveLease(pgd, Bindid);
	
	FreeReq.version    			= RSIP_VERSION;
	FreeReq.command    			= RSIP_FREE_REQUEST;

	FreeReq.clientid.code 		= RSIP_CLIENTID_CODE;
	FreeReq.clientid.len 		= sizeof(DWORD);
	FreeReq.clientid.clientid 	= pgd->clientid;

	FreeReq.bindid.code 		= RSIP_BINDID_CODE;
	FreeReq.bindid.len 			= sizeof(DWORD);
	FreeReq.bindid.bindid 		= Bindid;

	FreeReq.msgid.code 			= RSIP_MESSAGEID_CODE;
	FreeReq.msgid.len  			= sizeof(DWORD);
	FreeReq.msgid.msgid   		= pgd->msgid++;

	hr=rsipExchangeAndParse(pgd, 
					(PCHAR)&FreeReq, 
					sizeof(FreeReq), 
					&RespInfo, 
					FreeReq.msgid.msgid,
					FALSE);

	LeaveCriticalSection(&pgd->csRsip);

	
	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_FREE_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

exit:
	DPF(8,"<==Release Port, Succeeded");
	return hr;

error_exit:
	DPF(8,"<==Release Port, Failed");
	return DPERR_GENERIC;

}

/*=============================================================================

	rsipQueryLocalAddress - get the local address of a public address
	
    Description:

    	Before connecting to anyone we need to see if there is a local
    	alias for its global address.  This is because the gateway will
    	not loopback if we try and connect to the global address, so 
    	we need to know the local alias.

    Parameters:

    	LPGLOBALDATA pgd - global data for the service provider instance.
    	BOOL		 ftcp_udp - whether we are querying a UDP or TCP port
    	SOCKADDR     saddrquery - the address to look up
    	SOCKADDR     saddrlocal - local alias if one exists

    Return Values:

		DP_OK - got a local address.
		other - no mapping exists.
	
-----------------------------------------------------------------------------*/

HRESULT rsipQueryLocalAddress(LPGLOBALDATA pgd, BOOL ftcp_udp, SOCKADDR *saddrquery, SOCKADDR *saddrlocal) 
{
	#define saddrquery_in ((SOCKADDR_IN *)saddrquery)
	#define saddrlocal_in ((SOCKADDR_IN *)saddrlocal)
	HRESULT hr;

	MSG_RSIP_QUERY  QueryReq;
	RSIP_RESPONSE_INFO RespInfo;

	PADDR_ENTRY pAddrEntry;

	EnterCriticalSection(&pgd->csRsip);

	DEBUGPRINTADDR(8,"==>RSIP QueryLocalAddress\n",saddrquery);

	if(pgd->sRsip == INVALID_SOCKET){
		DPF(0,"rsipQueryLocalAddress: pgd->sRsip is invalid, bailing...\n");
		LeaveCriticalSection(&pgd->csRsip);
		return DPERR_GENERIC;
	}

	// see if we have a cached entry.
	
	if(pAddrEntry=rsipFindCacheEntry(pgd,ftcp_udp,saddrquery_in->sin_addr.s_addr,saddrquery_in->sin_port)){
		if(pAddrEntry->raddr){
			saddrlocal_in->sin_family      = AF_INET;
			saddrlocal_in->sin_addr.s_addr = pAddrEntry->raddr;
			saddrlocal_in->sin_port        = pAddrEntry->rport;
			LeaveCriticalSection(&pgd->csRsip);
			DPF(8,"<==Found Local address in cache.\n");
			return DP_OK;
		} else {
			DPF(8,"<==Found lack of local address in cache\n");
			LeaveCriticalSection(&pgd->csRsip);
			return DPERR_GENERIC;
		}
	}		

	// Build the request
	
	QueryReq.version    		= RSIP_VERSION;
	QueryReq.command    		= RSIP_QUERY_REQUEST;

	QueryReq.clientid.code 		= RSIP_CLIENTID_CODE;
	QueryReq.clientid.len 		= sizeof(DWORD);
	QueryReq.clientid.clientid 	= pgd->clientid;

	QueryReq.address.code		= RSIP_ADDRESS_CODE;
	QueryReq.address.len		= sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	QueryReq.address.version	= 1; // IPv4
	QueryReq.address.addr		= saddrquery_in->sin_addr.s_addr; 

	QueryReq.port.code			= RSIP_PORTS_CODE;
	QueryReq.port.len			= sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	QueryReq.port.nports      	= 1;
	QueryReq.port.port			= htons(saddrquery_in->sin_port); 

	QueryReq.porttype.code      = RSIP_VENDOR_CODE;
	QueryReq.porttype.len       = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	QueryReq.porttype.vendorid  = RSIP_MS_VENDOR_ID;
	QueryReq.porttype.option    = (ftcp_udp)?RSIP_TCP_PORT:RSIP_UDP_PORT;

	QueryReq.querytype.code	    = RSIP_VENDOR_CODE;
	QueryReq.querytype.len	    = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	QueryReq.querytype.vendorid = RSIP_MS_VENDOR_ID;
	QueryReq.querytype.option   = RSIP_QUERY_MAPPING;

	QueryReq.msgid.code 	    = RSIP_MESSAGEID_CODE;
	QueryReq.msgid.len  	    = sizeof(DWORD);
	QueryReq.msgid.msgid   		= pgd->msgid++;

	hr=rsipExchangeAndParse(pgd, 
					(PCHAR)&QueryReq, 
					sizeof(QueryReq), 
					&RespInfo, 
					QueryReq.msgid.msgid,
					FALSE);

	LeaveCriticalSection(&pgd->csRsip);
	
	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_QUERY_RESPONSE){
		DPF(0,"Failing query, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	saddrlocal_in->sin_family      = AF_INET;
	saddrlocal_in->sin_addr.s_addr = RespInfo.lAddressV4;
	saddrlocal_in->sin_port        = htons(RespInfo.lPort);

	//rsipAddCacheEntry(pgd,ftcp_udp,saddrquery_in->sin_addr.s_addr,saddrquery_in->sin_port,RespInfo.lAddressV4,htons(RespInfo.lPort));

	DEBUGPRINTADDR(8,"<==RSIP QueryLocalAddress, local alias is\n",(SOCKADDR *)saddrlocal_in);

exit:
	return hr;

error_exit:
	rsipAddCacheEntry(pgd,ftcp_udp,saddrquery_in->sin_addr.s_addr,saddrquery_in->sin_port,0,0);
	DPF(8,"<==RSIP QueryLocalAddress, NO Local alias\n");
	return DPERR_GENERIC;

	#undef saddrlocal_in 
	#undef saddrquery_in
}

/*=============================================================================

	rsipListenPort - assign a port mapping with the rsip server with a fixed
					 port.
	
    Description:

		Only used for the host server port (the one that is used for enums).
		Other than the fixed port this works the same as an rsipAssignPort.

		Since the port is fixed, the local and public port address are
		obviously the same.

    Parameters:

    	LPGLOBALDATA pgd      - global data for the service provider instance.
    	WORD	     port     - local port to get a remote port for (big endian)
    	BOOL		 ftcp_udp - whether we are assigning a UDP or TCP port
    	SOCKADDR     psaddr   - place to return assigned global realm address
    	PDWORD       pBindid  - identifier for this binding, used to extend 
    							lease and/or release the binding (OPTIONAL).
    Return Values:

		DP_OK - assigned succeeded, psaddr contains public realm address,
				*pBindid is the binding identifier.
				
		DPERR_GENERIC - assignment of a public port could not be made.


-----------------------------------------------------------------------------*/
HRESULT rsipListenPort(LPGLOBALDATA pgd, BOOL ftcp_udp, WORD port, SOCKADDR *psaddr, DWORD *pBindid)
{
	#define psaddr_in ((SOCKADDR_IN *)psaddr)
	
	HRESULT hr;

	MSG_RSIP_LISTEN_PORT ListenReq;
	RSIP_RESPONSE_INFO RespInfo;

	EnterCriticalSection(&pgd->csRsip);

	DPF(8,"RSIP Listen Port %d\n",htons(port));

	if(pgd->sRsip == INVALID_SOCKET){
		DPF(0,"rsipListenPort: pgd->sRsip is invalid, bailing...\n");
		LeaveCriticalSection(&pgd->csRsip);
		return DPERR_GENERIC;
	}

	// Build the request
	
	ListenReq.version    		  = RSIP_VERSION;
	ListenReq.command    		  = RSIP_LISTEN_REQUEST;

	ListenReq.clientid.code 	  = RSIP_CLIENTID_CODE;
	ListenReq.clientid.len 		  = sizeof(DWORD);
	ListenReq.clientid.clientid   = pgd->clientid;

	// Local Address (will be returned by RSIP server, us don't care value)

	ListenReq.laddress.code		  = RSIP_ADDRESS_CODE;
	ListenReq.laddress.len		  = sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	ListenReq.laddress.version	  = 1; // IPv4
	ListenReq.laddress.addr		  = 0; // Don't care

	// Local Port, this is a port we have opened that we are assigning a
	// global alias for.

	ListenReq.lport.code		 = RSIP_PORTS_CODE;
	ListenReq.lport.len			 = sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	ListenReq.lport.nports       = 1;
	ListenReq.lport.port		 = htons(port);//->little endian for wire

	// Remote Address (not used with our flow control policy, use don't care value)

	ListenReq.raddress.code		 = RSIP_ADDRESS_CODE;
	ListenReq.raddress.len		 = sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	ListenReq.raddress.version   = 1; // IPv4
	ListenReq.raddress.addr      = 0; // Don't care

	ListenReq.rport.code		 = RSIP_PORTS_CODE;
	ListenReq.rport.len			 = sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	ListenReq.rport.nports       = 1;
	ListenReq.rport.port		 = 0; // Don't care

	// Following parameters are optional according to RSIP spec...
	
	// Lease code, ask for an hour, but don't count on it.
	
	ListenReq.lease.code		 = RSIP_LEASE_CODE;
	ListenReq.lease.len			 = sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	ListenReq.lease.leasetime    = 3600;
	
	// Tunnell Type is IP-IP

	ListenReq.tunnel.code		 = RSIP_TUNNELTYPE_CODE;
	ListenReq.tunnel.len		 = sizeof(RSIP_TUNNEL)-sizeof(RSIP_PARAM);
	ListenReq.tunnel.tunneltype  = TUNNEL_IP_IP;

	// Message ID is optional, but we use it since we use UDP xport it is required.
	
	ListenReq.msgid.code 		 = RSIP_MESSAGEID_CODE;
	ListenReq.msgid.len  		 = sizeof(DWORD);
	ListenReq.msgid.msgid   	 = pgd->msgid++;

	// Vendor specific - need to specify port type and no-tunneling

	ListenReq.porttype.code      = RSIP_VENDOR_CODE;
	ListenReq.porttype.len       = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.porttype.vendorid  = RSIP_MS_VENDOR_ID;
	ListenReq.porttype.option    = (ftcp_udp)?(RSIP_TCP_PORT):(RSIP_UDP_PORT);

	ListenReq.tunneloptions.code     = RSIP_VENDOR_CODE;
	ListenReq.tunneloptions.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.tunneloptions.vendorid = RSIP_MS_VENDOR_ID;
	ListenReq.tunneloptions.option   = RSIP_NO_TUNNEL;

	ListenReq.listentype.code     = RSIP_VENDOR_CODE;
	ListenReq.listentype.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.listentype.vendorid = RSIP_MS_VENDOR_ID;
	ListenReq.listentype.option   = RSIP_SHARED_UDP_LISTENER;
	

	hr=rsipExchangeAndParse(pgd, 
					(PCHAR)&ListenReq, 
					sizeof(ListenReq), 
					&RespInfo, 
					ListenReq.msgid.msgid,
					FALSE);

	LeaveCriticalSection(&pgd->csRsip);
	
	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_LISTEN_RESPONSE){
		DPF(0,"Assignment failed? Response was %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	if(psaddr_in){
		psaddr_in->sin_family      = AF_INET;
		psaddr_in->sin_addr.s_addr = RespInfo.lAddressV4;
		psaddr_in->sin_port        = htons(RespInfo.lPort);// currently little endian on wire

		DEBUGPRINTADDR(8,"RSIP Listen, public address is\n",(SOCKADDR *)psaddr_in);
	}

	if(pBindid){
		*pBindid = RespInfo.bindid;
	}	

	// remember the lease so we will renew it when necessary.
	rsipAddLease(pgd,RespInfo.bindid,ftcp_udp,RespInfo.lAddressV4,htons(RespInfo.lPort),port,RespInfo.leasetime);

	
exit:
	DPF(8,"<==RSIP Listen succeeded\n");
	return hr;

error_exit:
	DPF(8,"<==RSIP Listen failed\n");
	return DPERR_GENERIC;

	#undef psaddr_in
}

/*=============================================================================

	rsipFindLease - see if we already have a lease for a local port.
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/


PRSIP_LEASE_RECORD rsipFindLease(LPGLOBALDATA pgd, BOOL ftcp_udp, WORD port)
{
	PRSIP_LEASE_RECORD pLeaseWalker;

	pLeaseWalker=pgd->pRsipLeaseRecords;
	
	while(pLeaseWalker){
		if(pLeaseWalker->ftcp_udp == ftcp_udp && 
		   pLeaseWalker->port     == port    
		)
		{
			break;
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	return pLeaseWalker;
}

/*=============================================================================

	rsipAddLease - adds a lease record to our list of leases
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

VOID rsipAddLease(LPGLOBALDATA pgd, DWORD bindid, BOOL ftcp_udp, DWORD addrV4, WORD rport, WORD port, DWORD tLease)
{
	PRSIP_LEASE_RECORD pLeaseWalker, pNewLease;
	DWORD tNow;

	tNow=timeGetTime();
	
	// First see if we already have a lease for this port;
	EnterCriticalSection(&pgd->csRsip);

	// first make sure there isn't already a lease for this port
	pLeaseWalker=pgd->pRsipLeaseRecords;
	while(pLeaseWalker){
		if(pLeaseWalker->ftcp_udp == ftcp_udp && 
		   pLeaseWalker->port     == port     && 
		   pLeaseWalker->bindid   == bindid      
		)
		{
			break;
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	if(pLeaseWalker){
		pLeaseWalker->dwRefCount++;
		pLeaseWalker->tExpiry = tNow+(tLease*1000);
	} else {
		ENTER_DPSP();
		pNewLease = SP_MemAlloc(sizeof(RSIP_LEASE_RECORD));
		LEAVE_DPSP();
		if(pNewLease){
			pNewLease->dwRefCount = 1;
			pNewLease->ftcp_udp   = ftcp_udp;
			pNewLease->tExpiry    = tNow+(tLease*1000);
			pNewLease->bindid     = bindid;
			pNewLease->port		  = port;
			pNewLease->rport      = rport;
			pNewLease->addrV4     = addrV4;
			pNewLease->pNext	  = pgd->pRsipLeaseRecords;
			pgd->pRsipLeaseRecords= pNewLease;
		} else {
			DPF(0,"rsip: Couldn't allocate new lease block for port %x\n",port);
		}
	}
	
	LeaveCriticalSection(&pgd->csRsip);
}

/*=============================================================================

	rsipRemoveLease - removes a lease record from our list of leases
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
VOID rsipRemoveLease(LPGLOBALDATA pgd, DWORD bindid)
{
	PRSIP_LEASE_RECORD pLeaseWalker, pLeasePrev;

	DPF(7,"==>rsipRemoveLease bindid %d\n",bindid);

	EnterCriticalSection(&pgd->csRsip);

	pLeaseWalker=pgd->pRsipLeaseRecords;
	pLeasePrev=(PRSIP_LEASE_RECORD)&pgd->pRsipLeaseRecords; //sneaky.

	while(pLeaseWalker){
		if(pLeaseWalker->bindid==bindid){
			--pLeaseWalker->dwRefCount;
			if(!pLeaseWalker->dwRefCount){
				// link over it
				pLeasePrev->pNext=pLeaseWalker->pNext;
				ENTER_DPSP();
				DPF(7,"rsipRemove: removing bindid %d\n",bindid);
				SP_MemFree(pLeaseWalker);
				LEAVE_DPSP();
			} else {
				DPF(7,"rsipRemove: refcount on bindid %d is %d\n",bindid, pLeaseWalker->dwRefCount);
			}
			break;
		}
		pLeasePrev=pLeaseWalker;
		pLeaseWalker=pLeaseWalker->pNext;
	}

	LeaveCriticalSection(&pgd->csRsip);

	DPF(7,"<==rsipRemoveLease bindid %d\n",bindid);
}

/*=============================================================================

	rsipPortExtend - checks if port leases needs extension and extends 
					 them if necessary
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

VOID rsipPortExtend(LPGLOBALDATA pgd, DWORD time)
{
	PRSIP_LEASE_RECORD pLeaseWalker;
	DWORD tExtend;
	HRESULT hr;
	EnterCriticalSection(&pgd->csRsip);

	pLeaseWalker=pgd->pRsipLeaseRecords;
	while(pLeaseWalker){
		
		if((int)(pLeaseWalker->tExpiry - time) < 180000){
			// less than 2 minutes left on lease.
			hr=rsipExtendPort(pgd, pLeaseWalker->bindid, &tExtend);			
			if(hr != DP_OK){
				// this binding is now gone!
				DPF(0,"Couldn't renew lease on bindid %d, port %x\n",pLeaseWalker->bindid, pLeaseWalker->port);
			} else {
				pLeaseWalker->tExpiry=time+(tExtend*1000);
				DPF(8,"rsip: Extended Lease of Port %x by %d seconds\n",pLeaseWalker->bindid,tExtend);
				ASSERT(tExtend > 180);
			}
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}
	
	LeaveCriticalSection(&pgd->csRsip);
}


/*=============================================================================

	rsipFindCacheEntry
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

PADDR_ENTRY rsipFindCacheEntry(LPGLOBALDATA pgd, BOOL ftcp_udp, DWORD addr, WORD port)
{
	PADDR_ENTRY pAddrWalker;

	pAddrWalker=pgd->pAddrEntry;
	
	while(pAddrWalker){
		if(pAddrWalker->ftcp_udp == ftcp_udp && 
		   pAddrWalker->port     == port     &&
		   pAddrWalker->addr     == addr
		)
		{
			// if he looked it up, give it another minute to time out.
			pAddrWalker->tExpiry=timeGetTime()+60*1000;
			DPF(8,"Returning Cache Entry Addr:Port (%x:%d)  Alias Addr:(Port %x:%d)\n",
				pAddrWalker->addr,
				htons(pAddrWalker->port),
				pAddrWalker->raddr,
				htons(pAddrWalker->rport));
			break;
		}
		pAddrWalker=pAddrWalker->pNext;
	}

	return pAddrWalker;

	
}

/*=============================================================================

	rsipAddCacheEntry - adds a cache entry or updates timeout on existing one.
	
    Description:

    	Adds an address mapping from public realm to local realm (or the 
    	lack of such a mapping) to the cache of mappings.

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

VOID rsipAddCacheEntry(LPGLOBALDATA pgd, BOOL ftcp_udp, DWORD addr, WORD port, DWORD raddr, WORD rport)
{
	PADDR_ENTRY pAddrWalker, pNewAddr;
	DWORD tNow;

	tNow=timeGetTime();
	
	// First see if we already have a lease for this port;
	EnterCriticalSection(&pgd->csRsip);

	// first make sure there isn't already a lease for this port
	pAddrWalker=pgd->pAddrEntry;
	while(pAddrWalker){
		if(pAddrWalker->ftcp_udp == ftcp_udp && 
		   pAddrWalker->port     == port     && 
		   pAddrWalker->addr     == addr      
		)
		{
			break;
		}
		pAddrWalker=pAddrWalker->pNext;
	}

	if(pAddrWalker){
		pAddrWalker->tExpiry = tNow+(60*1000); // keep for 60 seconds or 60 seconds from last reference
	} else {
		ENTER_DPSP();
		pNewAddr = SP_MemAlloc(sizeof(ADDR_ENTRY));
		LEAVE_DPSP();
		if(pNewAddr){
			DPF(8,"Added Cache Entry Addr:Port (%x:%d)  Alias Addr:(Port %x:%d)\n",addr,htons(port),raddr,htons(rport));
			pNewAddr->ftcp_udp   = ftcp_udp;
			pNewAddr->tExpiry    = tNow+(60*1000);
			pNewAddr->port		 = port;
			pNewAddr->addr		 = addr;
			pNewAddr->rport      = rport;
			pNewAddr->raddr      = raddr;
			pNewAddr->pNext	     = pgd->pAddrEntry;
			pgd->pAddrEntry      = pNewAddr;
		} else {
			DPF(0,"rsip: Couldn't allocate new lease block for port %x\n",port);
		}
	}
	
	LeaveCriticalSection(&pgd->csRsip);
}


/*=============================================================================

	rsipCacheClear - checks if cached mappings are old and deletes them.

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

VOID rsipCacheClear(LPGLOBALDATA pgd, DWORD time)
{
	PADDR_ENTRY pAddrWalker, pAddrPrev;

	EnterCriticalSection(&pgd->csRsip);

	pAddrWalker=pgd->pAddrEntry;
	pAddrPrev=(PADDR_ENTRY)&pgd->pAddrEntry; //sneaky.
	
	while(pAddrWalker){
		
		if((int)(pAddrWalker->tExpiry - time) < 0){ 
			// cache entry expired.
			pAddrPrev->pNext=pAddrWalker->pNext;
			ENTER_DPSP();
			DPF(7,"rsipRemove: removing cached address entry %x\n",pAddrWalker);
			SP_MemFree(pAddrWalker);
			LEAVE_DPSP();
		} else {
			pAddrPrev=pAddrWalker;
		}	
		pAddrWalker=pAddrPrev->pNext;
	}
	
	LeaveCriticalSection(&pgd->csRsip);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\memalloc.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\spvoice.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsp.c
 *  Content:	sample direct play service provider, based on winsock
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  10/31/96	andyco	created it. happy holloween!
 ***************************************************************************/

#include "dpsp.h"

// get the player data for pod.  extract ip addr.  use netmeeting to place call.
HRESULT WINAPI SP_OpenVoice(LPDPSP_OPENVOICEDATA pod) 
{
    SOCKADDR_IN * pin;
    INT iAddrLen = sizeof(SOCKADDR_IN);
    HRESULT hr=DP_OK;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	
	// get the global data
	hr =pod->lpISP->lpVtbl->GetSPData(pod->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	// tcp only!
	if (pgd->AddressFamily != AF_INET)
	{
		DPF_ERR("voice only supported for TCP / IP");
		ASSERT(FALSE);
		return E_FAIL;
	}

	// get to address	
	hr = pod->lpISP->lpVtbl->GetSPPlayerData(pod->lpISP,pod->idTo,&ppdTo,&dwSize,DPGET_REMOTE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}

	pin = (SOCKADDR_IN *) DGRAM_PSOCKADDR(ppdTo);

	DPF(0,"calling hostname = %s\n",inet_ntoa(pin->sin_addr));
	hr = OpenVoice(inet_ntoa(pin->sin_addr));
	if (FAILED(hr))
	{
		DPF(0,"open voice failed - hr = 0x%08lx\n",hr);
		
	} 
	else 
	{
		gbVoiceOpen = TRUE;
	}
	
	return hr;
	
} // SP_OpenVoice

HRESULT WINAPI SP_CloseVoice(LPDPSP_CLOSEVOICEDATA pod) 
{
	HRESULT hr;
	
	hr = CloseVoice();
	if (FAILED(hr))
	{
		DPF(0,"close voice failed - hr = 0x%08lx\n",hr);
	} 

	// even if it failed, give up on this call...
	gbVoiceOpen = FALSE;		
	return hr;
	
} // SP_CloseVoice
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\daytona\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>
#include <memlog.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
    typedef struct {
    	UINT stat_ThrottleRate;
		UINT stat_BytesSent;
		UINT stat_BackLog;
	 	UINT stat_BytesLost;
	 	UINT stat_RemBytesReceived;
		UINT stat_Latency; 
		UINT stat_MinLatency;
		UINT stat_AvgLatency;
		UINT stat_AvgDevLatency;
		UINT stat_USER1;
		UINT stat_USER2;
		UINT stat_USER3;
		UINT stat_USER4;
		UINT stat_USER5;	// remote tDelta
		UINT stat_USER6;	// Remote tDelta sign (0=+ve, 1=-ve)
	} IN_WRITESTATS, *PIN_WRITESTATS;

	typedef struct {
		UINT	hr;
	} OUT_WRITESTATS, *POUT_WRITESTATS;

   extern void DbgWriteStats(PIN_WRITESTATS pIn);
  
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(volatile DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define DbgWriteStats()
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD myclockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD myclock()	 {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= myclock(), t ## N ++
    #define TIMESTOP(t)   t ## T += myclock()
    #define TIMEFMT(t)	  ((DWORD)(t) / myclockrate()), (((DWORD)(t) * 1000 / myclockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\sources.inc ===
!INCLUDE $(DXROOT)\dplay\bldcfg\dpvbld.inc

MAJORCOMP=windows
MINORCOMP=GDI
UMTYPE=windows

TARGETNAME=$(DPLAY_BUILD_FILENAME_DPWSOCKX)
TARGETTYPE=DYNLINK

USE_MAPSYM=1

INCLUDES= \
     $(DXROOT)\inc;\
	 ..\..\..\misc; \
	 ..\; \
	 ..\..\dplay; \
	 ..\..\dplaysvr; \
	 ..\..\common; \
	 ..\..\nmvoice; \
	 ..\..\..\dpnathlp\inc; \
	 ..\..\..\dplobby\dplobby;

TARGETPATH=OBJ

# Make VC5 compatible libs (Manbugs 44478)
!ifdef DIRECTX_REDIST
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) /link50compat
!endif

PASS1_PUBLISH={ $(O)\dpwsockx.lib = $(SDK_LIB_PATH)\dpwsockx.lib}

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(BASEDIR)\public\sdk\lib\*\libc.lib    \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib    \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib \
	   $(BASEDIR)\public\sdk\lib\*\oleaut32.lib \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   ..\..\dplay\$(PLAT_DIR)\obj$(BUILD_ALT_DIR)\*\$(DPLAY_BUILD_FILENAME_DPLAYX).lib


!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES) -DUSE_CRITSECTS -DWIN16_SEPARATE \
!if "$(VOICE_TARGET)" == "gamevoice" 
	/DVOICE_BUILD_GAMEVOICE \
!endif
!if "$(VOICE_TARGET)" == "allegiance"
	/DVOICE_BUILD_ALLEGIANCE \
!endif
-DNEW_DPF

LINKER_FLAGS=-SECTION:share,RWS

#LINKLIBS= \

SOURCES= \
	..\fastsock.c \
	..\nathelp.c \
	..\rsip.c \
	..\bilink.c \
	..\registry.c \
	..\fpm.c \
	..\wsock2.c \
	..\leverage.c \
	..\dpsp.c \
	..\winsock.c \
	..\dllmain.c \
	..\helpcli.c \
	..\handler.c \
	..\dpwsock.rc \
	memalloc.c \
	newdpf.c \
	dputils.c

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\$(DPLAY_BUILD_FILENAME_DPWSOCKX).def
NTTARGETFILE0=MISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\w95help.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:	Win95 hack-o-rama code
 *		This is a HACK to handle the fact that Win95 doesn't notify
 *		a DLL when a process is destroyed.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   28-mar-95	craige	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	reworked for new ddhelp
 *   09-may-95	craige	loading any DLL
 *   16-sep-95	craige	bug 1117: must UnmapViewOfFile before closing handle
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "w95help.h"
#include "dpf.h"

//extern DWORD	* pdwHelperPid;
//extern HANDLE	* phModule;	// must be defined
extern DWORD	dwHelperPid;
extern HANDLE	hModule;	// must be defined


/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
	return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
	CloseHandle( hstartevent );
	return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    if( hmem == NULL )
    {
	DPF( 1, "Could not create file mapping!" );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
	DPF( 1, "Could not create view of file!" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
	DPF( 1, "Could not create mutex!" );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = hModule;
    if( SetEvent( hstartevent ) )
    {
	WaitForSingleObject( hackevent, INFINITE );
	memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
	rc = TRUE;
    }
    else
    {
	DPF( 1, "Could not signal event to notify DDHELP" );
	rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * DoneWithHelperProcess
 */
void DoneWithHelperProcess( void )
{
    DDHELPDATA	hd;

    if( dwHelperPid == 0 )
    {
	return;
    }

    hd.req = DDHELPREQ_FREEDCLIST;
    sendRequest( &hd );

} /* DoneWithHelperProcess */

/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE	hevent;
    DWORD	rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
	return FALSE;
    }
    DPF( 3, "Wait DDHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, INFINITE );
    CloseHandle( hevent );
    return TRUE;

} /* WaitForHelperStartup */

/*
 * HelperLoadDLL
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context )
{
    DDHELPDATA  hd;
    DWORD       rc = 0;

    if( dllname != NULL )
    {
	hd.req = DDHELPREQ_LOADDLL;
	lstrcpy( hd.fname, dllname );
	if( fnname != NULL )
	{
	    strcpy( hd.func, fnname );
	    hd.context = context;
	    DPF( 3, "Context=%08lx", context );
	}
	else
	{
	    hd.func[0] = 0;
	}
	DPF( 3, "Asking DDHELP to load DLL %s", dllname );
        sendRequest( &hd );
        rc = hd.dwReturn;
    }

    return rc;

} /* HelperLoadDLL */

/*
 * HelperCreateThread
 */
void HelperCreateThread( void )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEHELPERTHREAD;
    sendRequest( &hd );

} /* HelperCreateThread */

/*
 * SignalNewProcess
 *
 * Signal DDHELP that a new process has arrived.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP that a new process has connected" );
    hd.req = DDHELPREQ_NEWPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */

/*
 * SignalNewDriver
 *
 * Signal DDHELP that a new driver has been loaded.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewDriver( LPSTR fname, BOOL isdisp )
{
    DDHELPDATA	hd;

    DPF( 3, "Signalling DDHELP to create a new DC" );
    hd.req = DDHELPREQ_NEWDC;
    hd.isdisp = isdisp;
    lstrcpy( hd.fname, fname );
    sendRequest( &hd );

} /* SignalNewDriver */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
	STARTUPINFO		si;
	PROCESS_INFORMATION	pi;
	HANDLE			h;

	h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
	if( h == NULL )
	{
	    si.cb = sizeof(STARTUPINFO);
	    si.lpReserved = NULL;
	    si.lpDesktop = NULL;
	    si.lpTitle = NULL;
	    si.dwFlags = 0;
	    si.cbReserved2 = 0;
	    si.lpReserved2 = NULL;

	    DPF( 3, "Creating helper process now" );
	    if( !CreateProcess(NULL, "ddhelp.exe",  NULL, NULL, FALSE,
			       NORMAL_PRIORITY_CLASS,
			       NULL, NULL, &si, &pi) )
	    {
		DPF( 2, "Could not create DDHELP.EXE" );
		return FALSE;
	    }
	    dwHelperPid = pi.dwProcessId;
	    DPF( 3, "Helper rocess created" );
	}
	else
	{
	    DDHELPDATA	hd;
	    DPF( 3, "DDHELP already exists, waiting for DDHELP event" );
	    WaitForSingleObject( h, INFINITE );
	    CloseHandle( h );
	    DPF( 3, "Asking for DDHELP pid" );
	    hd.req = DDHELPREQ_RETURNHELPERPID;
	    sendRequest( &hd );
	    dwHelperPid = hd.pid;
	    DPF( 3, "DDHELP pid = %08lx", dwHelperPid );
	}
	*ppid = dwHelperPid;
	return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

#ifndef WINNT   //this is Just For Now... dsound will get the help it needs..jeffno 951206
/*
 * HelperWaveOpen
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx )
{
    DDHELPDATA	hd;

    if( (lphwo != NULL) && (pwfx != NULL) )
    {
	hd.req = DDHELPREQ_WAVEOPEN;
	hd.pData1 = lphwo;
	hd.dwData1 = dwDeviceID;
	hd.dwData2 = (DWORD)pwfx;
	DPF( 3, "Asking DDHELP to Open Wave Device %d", dwDeviceID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Open param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveOpen */

/*
 * HelperWaveClose
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveClose( DWORD hwo )
{
    DDHELPDATA	hd;

    if( (hwo != 0) )
    {
	hd.req = DDHELPREQ_WAVECLOSE;
	hd.dwData1 = hwo;
	DPF( 3, "Asking DDHELP to Close Wave Device ");
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveClose */

/*
 * HelperCreateTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperCreateTimer( DWORD dwResolution,
			 LPVOID	pTimerProc,
			 DWORD dwInstanceData )
{
    DDHELPDATA	hd;

    if( (dwResolution != 0) && (pTimerProc != NULL)  )
    {
	hd.req = DDHELPREQ_CREATETIMER;
	hd.pData1 = pTimerProc;
	hd.dwData1 = dwResolution;
	hd.dwData2 = dwInstanceData;
	DPF( 3, "Asking DDHELP to Create Timer" );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperCreateTimer */

/*
 * HelperKillTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperKillTimer( DWORD dwTimerID )
{
    DDHELPDATA	hd;

    if( (dwTimerID != 0) )
    {
	hd.req = DDHELPREQ_KILLTIMER;
	hd.dwData1 = dwTimerID;
	DPF( 3, "Asking DDHELP to KILL Timer %X", dwTimerID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperKillTimer */

/*
 * HelperCreateDSMixerThread
 *
 * get the helper to create a mixer thread.
 */
HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSMIXERTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSMixerThread

/*
 * HelperCreateDSFocusThread
 *
 * get the helper to create a sound focus thread.
 */
HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSFOCUSTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSFocusThread

/*
 * HelperCallDSEmulatorCleanup
 *
 * Call the DirectSound function which cleans up MMSYSTEM handles
 */
void HelperCallDSEmulatorCleanup( LPVOID callback,
                                  LPVOID pDirectSound )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CALLDSCLEANUP;
    hd.pData1 = callback;
    hd.pData2 = pDirectSound;

    sendRequest( &hd );
}

#endif //not winnt -just for now-jeffno

/*
 * HelperCreateModeSetThread
 *
 * get the helper to load a DLL for us.
 */
BOOL HelperCreateModeSetThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEMODESETTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_MODESET_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open modeset event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateModeSetThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateModeSetThread */

/*
 * HelperKillModeSetThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillModeSetThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLMODESETTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillModeSetThread */


// notify dphelp.c that we have a new server on this system
BOOL HelperAddDPlayServer(DWORD port)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd. dwData1 = port;
    return sendRequest(&hd);

} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(void)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer

#ifdef USE_ALIAS
    /*
     * Get DDHELP to load the DirectSound VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDSVxd( void )
    {
	DDHELPDATA hd;
	hd.req = DDHELPREQ_GETDSVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDSVxd */
#endif /* USE_ALIAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\winsock.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winsock.c
 *  Content:	windows socket support for dpsp
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *	3/15/96		andyco	created it
 *	4/12/96		andyco	got rid of dpmess.h! use DPlay_ instead of message macros
 *	4/18/96		andyco	added multihomed support, started ipx
 *	4/25/96		andyco	messages now have blobs (sockaddr's) instead of dwReserveds  
 *	5/31/96		andyco	all non-system players share a socket (gsStream and 
 *						gsDGramSocket).
 *	7/18/96		andyco	added dphelp for server socket
 *	8/1/96		andyco	no retry on connect failure
 *	8/15/96		andyco	local + remote data	- killthread
 *	8/30/96		andyco	clean it up b4 you shut it down! added globaldata.
 *	9/4/96		andyco	took out bye_bye message
 *	12/18/96	andyco	de-threading - use a fixed # of prealloced threads.
 *						cruised the enum socket / thread - use the system
 *						socket / thread instead
 *	3/17/97		kipo	rewrote server dialog code to not use global variable
 *						to return the address and to return any errors getting
 *						the address, especially DPERR_USERCANCEL
 *	5/12/97		kipo	the server address string is now stored in the globals
 *						at SPInit and resolved when you do EnumSessions so we
 *						will return any errors at that time instead of popping
 *						the dialog again. Fixes bug #5866
 *	11/19/97	myronth	Changed LB_SETCURSEL to CB_SETCURSEL (#12711)
 *	01/27/98	sohaim	added firewall support.
 *  02/13/98    aarono  added async support.
 *   2/18/98   a-peterz Comment byte order for address and port params (CreateSocket)
 *   6/19/98    aarono  turned on keepalive on reliable sockets.  If we
 *                      don't do this we can hang if the send target crashes
 *                      while in a low buffer (i.e. no buffer) state.
 *    7/9/99    aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *    1/12/99   aarono  added rsip support
 *    2/21/00   aarono  fix socket leaks
 ***************************************************************************/

#include "dpsp.h"
#include "rsip.h"
#include "nathelp.h"

// backlog for listen() api.  no constant in winsock, so we ask for the moon
#define LISTEN_BACKLOG 60

// how long to wait, in ms, til we abort a blocking WinSock connect() call
#define CONNECT_WATCHER_TIMEOUT		15000

/*
 ** CreateSocket
 *
 *  CALLED BY: all over
 *
 *  PARAMETERS:
 *		pgd - pointer to a global data
 *		psock - new socket. return value.
 *		type - stream or datagram
 *		port - what port we bind to (host byte order)
 *		address - what address to use (net byte order)
 *		*perr - set to the last socket error if fn fails
 *		bInRange - use reserved range of ports; we also use this to determine whether we need to try mapping it on the NAT or not
 *
 *  DESCRIPTION:
 *		creates a new socket.  binds to port specified, at the address specified
 *
 *  RETURNS: DP_OK or E_FAIL. if E_FAIL, *perr is set with socket error code (see winsock.h)
 *
 */

HRESULT FAR PASCAL CreateSocket(LPGLOBALDATA pgd,SOCKET * psock,INT type,WORD wApplicationPort,ULONG address, 
	SOCKERR * perr,BOOL bInRange)
{
    SOCKET  sNew;
    SOCKADDR sockAddr;
    int bTrue = TRUE;
	int protocol = 0;
	BOOL bBroadcast = FALSE;
	WORD wPort;
	BOOL bBound = FALSE;

    *psock = INVALID_SOCKET; // in case we bail

    //  Create the socket.
	if (AF_IPX == pgd->AddressFamily) 
	{
		// set up protocol for ipx
		if (SOCK_STREAM == type)
		{
			protocol = NSPROTO_SPXII;
		} 
		else protocol = NSPROTO_IPX;
	}

   	sNew = socket( pgd->AddressFamily, type, protocol);
   	
    if (INVALID_SOCKET == sNew) 
    {
        // no cleanup needed, just bail
    	*perr = WSAGetLastError();
        return E_FAIL;
    }

	DPF(8,"Creating New Socket %d\n",sNew);

    //  try to bind an address to the socket.
	// set up the sockaddr
	memset(&sockAddr,0,sizeof(sockAddr));
	switch (pgd->AddressFamily)
	{
		case AF_INET:
			{
				if ((SOCK_STREAM == type))
				{
					BOOL bTrue = TRUE;
					UINT err;
					
					// turn ON keepalive
					if (SOCKET_ERROR == setsockopt(sNew, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
					{
						err = WSAGetLastError();
						DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
					}

					ASSERT(bTrue);
					
					// turn off nagling
					if(pgd->dwSessionFlags & DPSESSION_OPTIMIZELATENCY) 
					{

						DPF(5, "Turning nagling off on socket");
						if (SOCKET_ERROR == setsockopt(sNew, IPPROTO_TCP, TCP_NODELAY, (CHAR FAR *)&bTrue, sizeof(bTrue)))
						{
							err = WSAGetLastError();
							DPF(0,"Failed to turn off naggling - continue : err = %d\n",err);
						}
					}
				}

				((SOCKADDR_IN *)&sockAddr)->sin_family      = PF_INET;
				((SOCKADDR_IN *)&sockAddr)->sin_addr.s_addr = address;
				((SOCKADDR_IN *)&sockAddr)->sin_port        = htons(wApplicationPort);
				if (bInRange && !wApplicationPort)
				{
#ifdef RANDOM_PORTS
					USHORT rndoffset;
#else // ! RANDOM_PORTS
					USHORT	wInitialPort;
#endif // ! RANDOM_PORTS

			    	
					DPF(5, "Application didn't specify a port - using dplay range");

#ifdef RANDOM_PORTS
					rndoffset=(USHORT)(GetTickCount()%DPSP_NUM_PORTS); //(USHORT)(0);// make predictable!
					if (type != SOCK_STREAM)
					{
						// workaround bug in winsock using the same socket.
						rndoffset = ((rndoffset + DPSP_NUM_PORTS/2) % DPSP_NUM_PORTS);
					}
					wPort = DPSP_MIN_PORT+rndoffset;
#else // ! RANDOM_PORTS
					wInitialPort = DPSP_MIN_PORT;
					if (type != SOCK_STREAM)
					{
						// workaround bug in winsock using the same socket.
						wInitialPort = wInitialPort + (DPSP_NUM_PORTS / 2);
					}

					// minimize problem with ICS machine stealing client's NAT connection entries by
					// picking a different starting point on the ICS machine
					if (natIsICSMachine(pgd))
					{
						wInitialPort += (DPSP_NUM_PORTS / 4);
					}

					wPort = wInitialPort;
#endif // ! RANDOM_PORTS
					do 
					{
#if USE_NATHELP
						BOOL bPortMapped=FALSE;
						BOOL ftcp_udp;
						HRESULT hr;

						if (pgd->pINatHelp)
						{
					        if (type == SOCK_STREAM)
					        {
					            if (pgd->hNatHelpTCP)
					            {
					            	DPF(1, "Already have registered TCP port 0x%x.", pgd->hNatHelpTCP);
					                goto pass_nat;
					            }

    					        ftcp_udp=TRUE;
					        }
					        else
					        {
					            if (pgd->hNatHelpUDP)
					            {
					            	DPF(1, "Already have registered UDP port 0x%x.", pgd->hNatHelpUDP);
					                goto pass_nat;
					            }

    					        ftcp_udp=FALSE;
					        }
					        
					        hr = natRegisterPort(pgd, ftcp_udp, wPort);
					        if (hr == DPNHERR_PORTUNAVAILABLE)
					        {
					            bPortMapped=FALSE;
					            DPF(1,"CreateSocket: NatHelp said port %u was already in use, trying another.",
					            	wPort);
					            goto try_next_port;
					        }

					        if (hr != DP_OK)
					        {
					            bPortMapped=FALSE;
					            DPF(1,"CreateSocket: NatHelp returned error 0x%x, port %u will not have mapping.",
					            	hr, wPort);
					        }
					        else
					        {
					            bPortMapped=TRUE;
					            DPF(1,"CreateSocket: NatHelp successfully mapped port %u.", wPort);
					        }
						}  

pass_nat:
	
#endif
					        
						DPF(5, "Trying to bind to port %d",wPort);
						((SOCKADDR_IN *)&sockAddr)->sin_port = htons(wPort);
						// do the bind
						if( SOCKET_ERROR != bind( sNew, (LPSOCKADDR)&sockAddr, sizeof(sockAddr) ) )
						{
							bBound = TRUE;
							DPF(5, "Successfully bound to port %d", wPort);				    
						}
						else
						{
					    
try_next_port:
	
#if USE_NATHELP
				            if (bPortMapped)
				            {
				                natDeregisterPort(pgd,ftcp_udp);
				                bPortMapped=FALSE;
				            }
#endif    
					    	if(++wPort > DPSP_MAX_PORT){
					    		wPort=DPSP_MIN_PORT;
					    	}
						}	
					}
#ifdef RANDOM_PORTS
					while (!bBound && (wPort != DPSP_MIN_PORT+rndoffset));				    
#else // ! RANDOM_PORTS
					while (!bBound && (wPort != wInitialPort));				    
#endif // ! RANDOM_PORTS
			    }	
			    else
		    	{
			    	DPF(5, "Application specifed a port (%u) or it doesn't need to be in dplay range (%i)",
			    		wApplicationPort, bInRange);
		    	}
		    }
			break;
			
		case AF_IPX:
			{
			    ((SOCKADDR_IPX *)&sockAddr)->sa_family      = (SHORT)pgd->AddressFamily;
			    ((SOCKADDR_IPX *)&sockAddr)->sa_socket		= wApplicationPort;
				// nodenum?
				memset(&(((SOCKADDR_IPX *)&sockAddr)->sa_nodenum),0,6);
				
			}
			break;
			
		default:
			ASSERT(FALSE);
			break;

	} // switch

	// do the bind
    if( !bBound && (SOCKET_ERROR == bind( sNew, (LPSOCKADDR)&sockAddr, sizeof(sockAddr))) )
    {
        goto ERROR_EXIT;
    }
    
    // success!
    *psock = sNew;

	if(type==SOCK_STREAM){
		DEBUGPRINTSOCK(8,"created a new stream socket (bound) - ",psock);
	} else {
		DEBUGPRINTSOCK(8,"created a new datagram socket (bound) - ",psock);
	}

    return DP_OK;

ERROR_EXIT:
    // clean up and bail
    *perr = WSAGetLastError();
	DPF(0,"create socket failed- err = %d\n",*perr);
    closesocket(sNew);
    return E_FAIL;

}   // CreateSocket

#undef DPF_MODNAME
#define DPF_MODNAME	"KillSocket"

HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard)
{
	UINT err;

    if (INVALID_SOCKET == sSocket) 
    {
		return E_FAIL;
    }

	if (!fStream)
    {
		DPF(8,"killsocket - closing datagram socket %d\n",
			sSocket);
		
        if (SOCKET_ERROR == closesocket(sSocket)) 
        {
	        err = WSAGetLastError();
			DPF(0,"killsocket - dgram close err = %d\n",err);
			return E_FAIL;
        }
    }
	else 
	{
		LINGER Linger;

	   	if (fHard)
		{
			// LINGER T/O=0 => Shutdown hard.
			Linger.l_onoff=TRUE; // turn linger on
			Linger.l_linger=0; // nice small time out
		}
	   	else
		{
			// NOLINGER => shutdown clean, but not hard.
			Linger.l_onoff=FALSE; // turn linger off -- SO_NOLINGER
			Linger.l_linger=0; // nice small time out
		}

	    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,
	                    sizeof(Linger) ) )
	    {
	        err = WSAGetLastError();
			DPF(0,"killsocket - stream setopt err = %d\n",err);
	    }

#if 0
		DWORD lNonBlock=0;
		err = ioctlsocket(sSocket,FIONBIO,&lNonBlock);
		if (SOCKET_ERROR == err)
		{
			err = WSAGetLastError();
			DPF(0,"could not set blocking mode on socket err = %d!",err);
		}
#endif		

#if 0
		if (SOCKET_ERROR == shutdown(sSocket,2)) 
		{
			// this may well fail, if e.g. no one is using this socket right now...
			// the error would be wsaenotconn 
	        err = WSAGetLastError();
			DPF(5,"killsocket - stream shutdown err = %d\n",err);
		}
#endif

		DPF(8,"killsocket - %s closing stream socket %d:",
			((fHard) ? "hard" : "soft"), sSocket);
		DEBUGPRINTSOCK(8,"Addr :",&sSocket);
        if (SOCKET_ERROR == closesocket(sSocket)) 
        {
	        err = WSAGetLastError();
			DPF(0,"killsocket - stream close err = %d\n",err);
			return E_FAIL;
        }
        else
        {
        	DPF(8,"killsocket - closed socket %d\n",sSocket);
        }
    }

	return DP_OK;
	
}// KillSocket

#undef DPF_MODNAME
#define DPF_MODNAME	"CreateAndInitStreamSocket"

// set up a stream socket to receive connections
// used w/ the gGlobalData.sStreamAcceptSocket
HRESULT CreateAndInitStreamSocket(LPGLOBALDATA pgd)
{
	HRESULT hr;
	UINT err;
	LINGER Linger;
	BOOL bTrue=TRUE;
	SOCKADDR_IN saddr;
	INT dwSize;

    hr = CreateSocket(pgd,&(pgd->sSystemStreamSocket),SOCK_STREAM,pgd->wApplicationPort,INADDR_ANY,&err,TRUE);
    if (FAILED(hr)) 
    {
        DPF(0,"init listen socket failed - err = %d\n",err);
        return hr ;
    }

	if (SOCKET_ERROR == setsockopt(pgd->sSystemStreamSocket, SOL_SOCKET, SO_REUSEADDR, (CHAR FAR *)&bTrue, sizeof(bTrue)))
	{
		err = WSAGetLastError();
		DPF(0,"Failed to to set shared mode on socket - continue : err = %d\n",err);
	}

	// get the socket address, and keep it around for future reference.
	dwSize = sizeof(saddr);
	err=getsockname(pgd->sSystemStreamSocket, (SOCKADDR *)&saddr, &dwSize);

	if(err){
		DPF(0,"Couldn't get socket name?\n");
		DEBUG_BREAK();
	}

	pgd->SystemStreamPort = saddr.sin_port;

    // set up socket w/ max listening connections
    err = listen(pgd->sSystemStreamSocket,LISTEN_BACKLOG);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"init listen socket / listen error - err = %d\n",err);
        return E_FAIL ;
    }

	// set for hard disconnect
	Linger.l_onoff=1;
	Linger.l_linger=0;
    
    if( SOCKET_ERROR == setsockopt( pgd->sSystemStreamSocket,SOL_SOCKET,SO_LINGER,
		(char FAR *)&Linger,sizeof(Linger) ) )
    {
        err = WSAGetLastError();
		DPF(0,"Delete service socket - stream setopt err = %d\n",err);
    }

    if( SOCKET_ERROR == setsockopt( pgd->sSystemStreamSocket,SOL_SOCKET,SO_REUSEADDR,
		(char FAR *)&bTrue,sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(0,"Couldn't share socket address = %d\n",err);
    }
	
	DEBUGPRINTSOCK(1,"enum - listening on",&(pgd->sSystemStreamSocket));
	return DP_OK;
	
} // CreateAndInitStreamSocket



#undef DPF_MODNAME
#define DPF_MODNAME	"SPConnect"
// connect socket to sockaddr
HRESULT SPConnect(SOCKET* psSocket, LPSOCKADDR psockaddr,UINT addrlen, BOOL bOutBoundOnly)
{
	UINT err;
	HRESULT hr = DP_OK;
	DWORD dwLastError;
	u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
	u_long lBlock = 0; // passed to ioctlsocket to make socket blocking again
	fd_set fd_setConnect;
	fd_set fd_setExcept;
	TIMEVAL timevalConnect;


	DPF(6, "SPConnect: Parameters (0x%x, 0x%x, %u, %i)", psSocket, psockaddr, addrlen, bOutBoundOnly);
	

	err=ioctlsocket(*psSocket, FIONBIO, &lNonBlock);	// make socket non-blocking
	if(SOCKET_ERROR == err){
		dwLastError=WSAGetLastError();
		DPF(0,"sp - failed to set socket %d to non-blocking mode err= %d\n", *psSocket, dwLastError);
		return DPERR_CONNECTIONLOST;
	}


	DEBUGPRINTADDR(4, "Connecting socket:", psockaddr);

	// Start the socket connecting.
    err = connect(*psSocket,psockaddr,addrlen);
    
	if(SOCKET_ERROR == err) {
		dwLastError=WSAGetLastError();
		if(dwLastError != WSAEWOULDBLOCK){
			DPF(0,"sp - connect failed err= %d\n", dwLastError);
			hr = DPERR_CONNECTIONLOST;
			goto err_exit;
		}
		// we are going to wait for either the connect to succeed (socket to be writeable)
		// or the connect to fail (except fdset bit to be set).  So we init an FDSET with
		// the socket that is connecting and wait.
		FD_ZERO(&fd_setConnect);
		FD_SET(*psSocket, &fd_setConnect);

		FD_ZERO(&fd_setExcept);
		FD_SET(*psSocket, &fd_setExcept);

		timevalConnect.tv_sec=0;
		timevalConnect.tv_usec=CONNECT_WATCHER_TIMEOUT*1000; //msec -> usec
		
		err = select(0, NULL, &fd_setConnect, &fd_setExcept, &timevalConnect);

		// err is the number of sockets with activity or 0 for timeout 
		// or SOCKET_ERROR for error
		
		if(SOCKET_ERROR == err) {
			dwLastError=WSAGetLastError();
			DPF(0,"sp - connect failed err= %d\n", dwLastError);
			hr = DPERR_CONNECTIONLOST;
			goto err_exit;
		} else if (0==err){
			// timed out
			DPF(0,"Connect timed out on socket %d\n",*psSocket);
			hr = DPERR_CONNECTIONLOST;
			goto err_exit;
		}

		// Now see if the connect succeeded or the connect got an exception
		if(!(FD_ISSET(*psSocket, &fd_setConnect))){
			#ifdef DEBUG
				DWORD optval=0;
				DWORD optlen=sizeof(optval);
				DPF(0,"Connect did not succeed on socket %d\n",*psSocket);
				if(FD_ISSET(*psSocket,&fd_setExcept)){
					DPF(0,"FD Except Set IS Set (expected)\n");
				} else {
					DPF(0,"FD Except Set IS NOT SET (unexpected)\n");
				}
				err=getsockopt(*psSocket, SOL_SOCKET, SO_ERROR, (char *)&optval, &optlen);
				DPF(0,"Socket error %x\n",optval);
			#endif
			return DPERR_CONNECTIONLOST;
		}

		if(FD_ISSET(*psSocket,&fd_setExcept)){
			DPF(0,"Got exception on socket %d during connect\n",*psSocket);
			hr = DPERR_CONNECTIONLOST;
			goto err_exit;
		}
	}

	err=ioctlsocket(*psSocket, FIONBIO, &lBlock);	// make socket blocking again

	DEBUGPRINTSOCK(8,"successfully connected socket - ", psSocket);

	if (bOutBoundOnly)
	{
		DEBUGPRINTADDR(5, "Sending reuse connection message to - ",psockaddr);
		// tell receiver to reuse connection
		hr = SendReuseConnectionMessage(*psSocket);
	}
	
	DPF(6, "SPConnect: Return: [0x%lx]", hr);

	return hr;

err_exit:
	err=ioctlsocket(*psSocket, FIONBIO, &lBlock);	// make socket blocking again
	
	DPF(6, "SPConnect: Return (err exit): [0x%lx]", hr);
	
	return hr;

} //SPConnect
    

#undef DPF_MODNAME
#define DPF_MODNAME	"SetPlayerAddress"
// we've created a socket for a player. store its address in the players
// spplayerdata struct.  
HRESULT SetPlayerAddress(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,SOCKET sSocket,BOOL fStream) 
{
	SOCKADDR sockaddr;
	UINT err;
	int iAddrLen = sizeof(SOCKADDR);

    err = getsockname(sSocket,&sockaddr,&iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"setplayeraddress - getsockname - err = %d\n",err);
        DPF(0,"closing socket %d\n",sSocket);
        closesocket(sSocket);
		return E_FAIL;
    } 

	if (fStream) 
	{
		switch (pgd->AddressFamily)
		{
			case AF_INET:
				DEBUGPRINTADDR(7, "Setting player AF_INET stream socket address:", &sockaddr);
				
				STREAM_PSOCKADDR(ppd)->sa_family = AF_INET;
				IP_STREAM_PORT(ppd) = ((SOCKADDR_IN * )&sockaddr)->sin_port;
				// we don't know the address of the local player (multihomed!)
				IP_STREAM_ADDR(ppd) = 0; 
				break;

			case AF_IPX:
			{
				SOCKADDR_IPX * pipx = (SOCKADDR_IPX * )STREAM_PSOCKADDR(ppd);
				
				pipx->sa_family = AF_IPX;
				pipx->sa_socket = ((SOCKADDR_IPX*)&sockaddr)->sa_socket;
				memset(pipx->sa_nodenum,0,6);
				break;

			}

			default:
				ASSERT(FALSE);
		}
	} // stream
	else 
	{
		switch (pgd->AddressFamily)
		{
			case AF_INET:
				DEBUGPRINTADDR(7, "Setting player AF_INET datagram socket address:", &sockaddr);
				
				DGRAM_PSOCKADDR(ppd)->sa_family = AF_INET;
				IP_DGRAM_PORT(ppd) = ((SOCKADDR_IN *)&sockaddr)->sin_port;
				// we don't know the address of the local player (multihomed!)
				IP_DGRAM_ADDR(ppd) = 0; 
				break;

			case AF_IPX:
			{
				SOCKADDR_IPX * pipx = (SOCKADDR_IPX * )DGRAM_PSOCKADDR(ppd);
				
				pipx->sa_family = AF_IPX;
				pipx->sa_socket = ((SOCKADDR_IPX*)&sockaddr)->sa_socket;
				memset(pipx->sa_nodenum,0,6);
				break;

			}

			default:
				ASSERT(FALSE);
		}

	} // dgram

	return DP_OK;	
} // SetPlayerAddress

#undef DPF_MODNAME
#define DPF_MODNAME	"GetIPXNameServerSocket"

// called by CreatePlayerDgramSocket
// bind to our well known port for ipx
HRESULT GetIPXNameServerSocket(LPGLOBALDATA pgd)
{
	BOOL bTrue = TRUE;
	SOCKET sSocket;
	HRESULT hr;
	UINT err;
	
	// if there already was a receive thread, we need to kill
	// the socket, and remember the thread, so at shutdown we
	// can make sure it's gone.  note - we can't wait for it to 
	// leave now, since dplay hasn't dropped its locks, and
	// the thread may be blocked on dplay
	if (pgd->hDGramReceiveThread)
	{
		// it's ipx, and we're deleting the system player
		// we need to get rid of the system sockets, so that if we recreate as 
		// nameserver we can bind to a specific port...
		// ipx only uses datagram, so we only stop those...kill the socket
		ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
		KillSocket(pgd->sSystemDGramSocket,FALSE,TRUE);
		pgd->sSystemDGramSocket = INVALID_SOCKET;
		
		// remember the old thread - we'll need to make sure it's gone when we 
		// shut down
		pgd->hIPXSpareThread = pgd->hDGramReceiveThread;
		pgd->hDGramReceiveThread = NULL;
	}
	
    DPF(2,"ipx - creating name server dgram socket\n");
	
	// use name server port
    hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,SERVER_DGRAM_PORT,INADDR_ANY,&err,FALSE);
	if (FAILED(hr))
	{
		DPF(0,"IPX - DPLAY SERVER SOCKET IS ALREADY IN USE.  PLEASE SHUTDOWN ANY");
		DPF(0,"OTHER NETWORK APPLICATIONS AND TRY AGAIN");
		// boned!
		return DPERR_CANNOTCREATESERVER;
	}

    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_BROADCAST,(char FAR *)&bTrue,
                sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(0,"create - could not set broadcast err = %d\n",err);
		// keep trying
    }

	DEBUGPRINTSOCK(2,"name server dgram socket (bound) - ",&sSocket);
	
	pgd->sSystemDGramSocket = sSocket;
	
	return DP_OK;

} // GetIPXNameServerSocket

HRESULT CreatePlayerDgramSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags)
{
	HRESULT hr=DP_OK;
	UINT err;
	SOCKET sSocket;
	
    if ( (AF_IPX == pgd->AddressFamily) && (dwFlags & DPLAYI_PLAYER_NAMESRVR))
    {
		//
		// AF_INET uses ddhelp to bind the nameserver to a specific port 
		// (SERVER_DGRAM_PORT).  AF_IPX binds to that port here.
		hr = GetIPXNameServerSocket(pgd);
		if (FAILED(hr))
		{
			return hr;
		}
		// store this for setting player address below
		sSocket = pgd->sSystemDGramSocket;
    } 
	else if (dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
    {
		if (INVALID_SOCKET == pgd->sSystemDGramSocket)
		{

			hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,pgd->wApplicationPort,INADDR_ANY,&err,TRUE);
		    if (FAILED(hr)) 
		    {
		    	DPF(0,"create sysplayer dgram socket failed - err = %d\n",err);
				return hr;
		    }
				
			#ifdef DEBUG
		    if (dwFlags & DPLAYI_PLAYER_NAMESRVR) 
		    {
		    	DEBUGPRINTSOCK(2,"name server dgram socket - ",&sSocket);
		    }
			#endif // DEBUG
			
			pgd->sSystemDGramSocket = sSocket;
		}
		else 
		{
			// store this for setting player address below
			sSocket = pgd->sSystemDGramSocket;	
		}
    }
	else 
	{
	
		ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
		sSocket = pgd->sSystemDGramSocket;	
	}

	// store the ip + port w/ the player...    
	hr = SetPlayerAddress(pgd,ppd,sSocket,FALSE);

	
	return hr; 
}  // CreatePlayerDgramSocket

HRESULT CreatePlayerStreamSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags) 
{
	SOCKET sSocket;
	HRESULT hr=DP_OK;
	UINT err;
	BOOL bListen = TRUE; // set if we created socket, + need to set it's listen
	BOOL bTrue = TRUE;
	DWORD dwSize;
	SOCKADDR_IN saddr;
	
	if (dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
    {
		if (INVALID_SOCKET == pgd->sSystemStreamSocket)
		{
	    	hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,pgd->wApplicationPort,INADDR_ANY,&err,TRUE);
		    if (FAILED(hr)) 
		    {
		    	DPF(0,"create player stream socket failed - err = %d\n",err);
				return hr;
		    }
			
			#ifdef DEBUG
		    if (dwFlags & DPLAYI_PLAYER_NAMESRVR) 
		    {
		    	DEBUGPRINTSOCK(2,"name server stream socket - ",&sSocket);
		    }
			#endif // DEBUG

			
			pgd->sSystemStreamSocket = sSocket;

			if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_REUSEADDR, (CHAR FAR *)&bTrue, sizeof(bTrue)))
			{
				err = WSAGetLastError();
				DPF(0,"Failed to to set shared mode on socket - continue : err = %d\n",err);
			}

			// get the socket address, and keep it around for future reference.
			dwSize = sizeof(saddr);
			err=getsockname(pgd->sSystemStreamSocket, (SOCKADDR *)&saddr, &dwSize);

			if(err){
				DPF(0,"Couldn't get socket name?\n");
				DEBUG_BREAK();
			}
			pgd->SystemStreamPort = saddr.sin_port;
		}
		else
		{
			sSocket = pgd->sSystemStreamSocket;	
			bListen = FALSE;
		}
    		
    }
	else 
	{
		ASSERT (INVALID_SOCKET != pgd->sSystemStreamSocket);
		sSocket = pgd->sSystemStreamSocket;	
		bListen = FALSE;			
	}
	
	if (bListen)
	{
		// set up socket to receive connections
	    err = listen(sSocket,LISTEN_BACKLOG);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			ASSERT(FALSE);
		    DPF(0,"ACK! stream socket listen failed - err = %d\n",err);
			// keep trying
		}
	}
	
	hr = SetPlayerAddress(pgd,ppd,sSocket,TRUE);
	return hr;

} // CreatePlayerStreamSocket


#undef DPF_MODNAME
#define DPF_MODNAME	"PokeAddr"


// poke an ip addr into a message blob
void IP_SetAddr(LPVOID pmsg,SOCKADDR_IN * paddrSrc)
{
	LPSOCKADDR_IN  paddrDest; // tempo variable, makes casting less ugly
	LPMESSAGEHEADER phead;

	phead = (LPMESSAGEHEADER)pmsg;
	// todo - validate header

	// leave the port intact, copy over the ip addr
	paddrDest = (SOCKADDR_IN *)&(phead->sockaddr);
	// poke the new ip addr into the message header
	// only rehome addresses that aren't already homed.
	if(paddrDest->sin_addr.s_addr == 0){
		paddrDest->sin_addr.s_addr = paddrSrc->sin_addr.s_addr;
	}	

	return;
	
} // IP_SetAddr

// get an ip addr from a message blob
void IP_GetAddr(SOCKADDR_IN * paddrDest,SOCKADDR_IN * paddrSrc) 
{
	// leave the port intact, copy over the nodenum
	if (0 == paddrDest->sin_addr.s_addr)
	{
		DPF(2,"remote player - setting address!! =  %s\n",inet_ntoa(paddrSrc->sin_addr));
		paddrDest->sin_addr.s_addr = paddrSrc->sin_addr.s_addr;
	}

	return;
		
} // IP_GetAddr

// poke the ipx nodenumber / a message
void IPX_SetNodenum(LPVOID pmsg,SOCKADDR_IPX * paddrSrc)
{
	LPSOCKADDR_IPX  paddrDest;	 // tempo variable, makes casting less ugly
	LPMESSAGEHEADER phead; 

	phead = (LPMESSAGEHEADER)pmsg;
	// todo - validate header
	
	// leave the port intact, copy over the nodenum
	paddrDest = (SOCKADDR_IPX *)&(phead->sockaddr);
	memcpy(paddrDest->sa_nodenum,paddrSrc->sa_nodenum,6);
	memcpy(paddrDest->sa_netnum,paddrSrc->sa_netnum,4);

	return;

}  // IPX_SetNodenum
							   
// reconstruct the nodenum from the msg
void IPX_GetNodenum(SOCKADDR_IPX * paddrDest,SOCKADDR_IPX * paddrSrc) 
{
	char sa_nodenum_zero[6];

	memset(sa_nodenum_zero,0,6);

	// if the nodenum is zero, set it
	if (0 == memcmp(paddrDest->sa_nodenum,sa_nodenum_zero,6))
	{
			DEBUGPRINTADDR(4,"IPX - setting remote player address",(SOCKADDR *)paddrSrc);
			// leave the port intact, copy over the nodenum
			memcpy(paddrDest->sa_nodenum,paddrSrc->sa_nodenum,6);
			memcpy(paddrDest->sa_netnum,paddrSrc->sa_netnum,4);
	}
	return;
} // IPX_GetNodenum

// store the port of the socket w/ the message, so the receiving end
// can reconstruct the address to reply to
//  psaddr will override the address if present
HRESULT SetReturnAddress(LPVOID pmsg,SOCKET sSocket, LPSOCKADDR psaddrPublic) 
{
	#define psaddr_inPublic ((LPSOCKADDR_IN)psaddrPublic)

    SOCKADDR sockaddr;
    INT addrlen=sizeof(SOCKADDR);
	LPMESSAGEHEADER phead;
	UINT err;

	// Note: extra test for 0 IP address may be extraneous (but certainly won't hurt).
	if(psaddrPublic && psaddr_inPublic->sin_addr.s_addr ){

		// We are behind an RSIP gateway, so put the public address in the header
	
		phead = (LPMESSAGEHEADER)pmsg;
		phead->sockaddr = *psaddrPublic;

		DEBUGPRINTADDR(8,"setting return address (using rsip public address) = ",&phead->sockaddr);
		
	} else {
		// find out what port gGlobalData.sEnumSocket is on
		DPF(8,"==>GetSockName\n");
	    err = getsockname(sSocket,(LPSOCKADDR)&sockaddr,&addrlen);
		DPF(8,"<==GetSockName\n");
		if (SOCKET_ERROR == err)
		{
			err = WSAGetLastError();
			DPF(0,"could not get socket name - err = %d\n",err);
			return DP_OK;
		}

		DEBUGPRINTADDR(8,"setting return address = ",&sockaddr);

		phead = (LPMESSAGEHEADER)pmsg;
		// todo - validate header

		phead->sockaddr = sockaddr;
	}
	
	return DP_OK;

	#undef psaddr_inPublic

} // SetReturnAddress

// code below all called by GetServerAddress. For IP, prompts user for ip address 
// for name server.
#undef DPF_MODNAME
#define DPF_MODNAME	"GetAddress"
// get the ip address from the pBuffer passed in by a user
// can either be a real ip, or a hostname
// called after the user fills out our dialog box
HRESULT GetAddress(ULONG * puAddress,char *pBuffer,int cch)
{
	UINT uiAddr;
	UINT err;
	PHOSTENT phostent;
	IN_ADDR hostaddr;

	if ( (0 == cch)  || (!pBuffer) || (0 == strlen(pBuffer)) )
	{
		*puAddress = INADDR_BROADCAST;
		return (DP_OK);
	} 
	
	// try inet_addr first
	uiAddr = inet_addr(pBuffer);

	if(0 == uiAddr)	// fix bug where "" buffer passed in.
	{
		*puAddress = INADDR_BROADCAST;
		return (DP_OK);
	}
	
	if (INADDR_NONE != uiAddr) 
	{
		// found it
		*puAddress = uiAddr;
		return (DP_OK);
	}
	
	// try hostbyname
	phostent = gethostbyname(pBuffer);
	if (NULL == phostent ) 
	{
		err = WSAGetLastError();
		DPF(0,"could not get host address - err = %d\n",err);
		return (DPERR_INVALIDPARAM);
	}
	memcpy(&hostaddr,phostent->h_addr,sizeof(hostaddr));
	DPF(1,"name server address = %s \n",inet_ntoa(hostaddr));
	*puAddress = hostaddr.s_addr;

	return (DP_OK);
} // GetAddress

// put up a dialog asking for a network address
// call get address to convert user specified address to network usable address
// called by GetServerAddress
INT_PTR CALLBACK DlgServer(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	HWND hWndCtl;
    char pBuffer[ADDR_BUFFER_SIZE];
	UINT cch;
	ULONG *lpuEnumAddress;
	HRESULT hr;

    switch (msg)
    {
    case WM_INITDIALOG:
		// set focus on edit box
        hWndCtl = GetDlgItem(hDlg, IDC_EDIT1);
        if (hWndCtl == NULL)
        {
            EndDialog(hDlg, FALSE);
            return(TRUE);
        }
        SetFocus(hWndCtl);
        SendMessage(hWndCtl, CB_SETCURSEL, 0, 0);

		// save pointer to enum address with the window
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG) lParam);
        return(FALSE);


    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
		case IDOK:
			// get text entered in control
			cch = GetDlgItemText(hDlg, IDC_EDIT1, pBuffer, ADDR_BUFFER_SIZE);

			// get pointer to return address in
			lpuEnumAddress = (ULONG *) GetWindowLongPtr(hDlg, DWLP_USER);

			// convert string to enum address
            hr = GetAddress(lpuEnumAddress,pBuffer,cch);
			if (FAILED(hr))
				EndDialog(hDlg, hr);
			else
				EndDialog(hDlg, TRUE);
            return(TRUE);

		case IDCANCEL:
	        EndDialog(hDlg, FALSE);
	        return(TRUE);
		}
		break;
    }
    return (FALSE);
} // DlgServer

/*
 ** GetServerAddress
 *
 *  CALLED BY: EnumSessions
 *
 *  DESCRIPTION: launches the select network address dialog
 *
 *  RETURNS:  ip address (sockaddr.sin_addr.s_addr)
 *
 */
HRESULT ServerDialog(ULONG *lpuEnumAddress)
{
	HWND hwnd;
	INT_PTR	iResult;
	HRESULT hr;
	
	// we have a valid enum address
	if (*lpuEnumAddress)
		return (DP_OK);

	// use the fg window as our parent, since a ddraw app may be full screen
	// exclusive
	hwnd = GetForegroundWindow();

	iResult = DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_SELECTSERVER), hwnd,
							 DlgServer, (LPARAM) lpuEnumAddress);
	if (iResult == -1)
	{
		DPF_ERR("GetServerAddress - dialog failed");
		hr = DPERR_GENERIC;
	}
	else if (iResult < 0)
	{
		DPF(0, "GetServerAddress - dialog failed: %08X", iResult);
		hr = (HRESULT) iResult;
	}
	else if (iResult == 0)
    {
		hr = DPERR_USERCANCEL;
    }
	else
	{
		hr = DP_OK;
	}
		
	return (hr);
	
} //ServerDialog 

// called by enumsessions - find out where server is...
HRESULT GetServerAddress(LPGLOBALDATA pgd,LPSOCKADDR psockaddr) 
{
	HRESULT hr;

	if (AF_IPX == pgd->AddressFamily)
	{
		((LPSOCKADDR_IPX)psockaddr)->sa_family      = AF_IPX;
	    ((LPSOCKADDR_IPX)psockaddr)->sa_socket 		= SERVER_DGRAM_PORT;
		memset(&(((LPSOCKADDR_IPX)psockaddr)->sa_nodenum),0xff,sizeof(((LPSOCKADDR_IPX)psockaddr)->sa_nodenum));
	
		hr = DP_OK;	
	}
	else
	{
		if (pgd->bHaveServerAddress)
		{
			// use enum address passed to SPInit
            hr = GetAddress(&pgd->uEnumAddress,pgd->szServerAddress,strlen(pgd->szServerAddress));
		}
		else
		{
			// ask user for enum address
			hr = ServerDialog(&pgd->uEnumAddress);
		}

		if (SUCCEEDED(hr))
		{
			// setup winsock to enum this address
			((LPSOCKADDR_IN)psockaddr)->sin_family      = AF_INET;
			((LPSOCKADDR_IN)psockaddr)->sin_addr.s_addr = pgd->uEnumAddress;		
			// see byte-order comment in dpsp.h for this constant
			((LPSOCKADDR_IN)psockaddr)->sin_port 		= SERVER_DGRAM_PORT;

			#if USE_RSIP
				#define IP_SOCKADDR(a) (((SOCKADDR_IN *)(&a))->sin_addr.s_addr)
				// Make sure the address we are enumming doesn't have a local alias.
				// If it does, use the local alias instead of the public address.
	            if(pgd->sRsip!=INVALID_SOCKET && 
	            	pgd->uEnumAddress != INADDR_BROADCAST && 
	            	pgd->uEnumAddress != INADDR_LOOPBACK){
	            	
	            	SOCKADDR saddr;
	            	HRESULT  hr;
	            	hr=rsipQueryLocalAddress(pgd, FALSE, psockaddr, &saddr);
	            	if(hr==DP_OK){
	            		// If there is an alias, go broadcast.  This works just as well
	            		// and avoids problems where more than 1 mapped shared
	            		// UDP port is allocated.

		        		DEBUGPRINTADDR(7, "Enum Socket is ",psockaddr);
		        		DEBUGPRINTADDR(7, "Got Local Alias for Enum socket ",&saddr);

       					IP_SOCKADDR(*psockaddr)=0xFFFFFFFF;
#if 0
		        		if(IP_SOCKADDR(saddr)==IP_SOCKADDR(*psockaddr))
		        		{
		        			DPF(7, "Alias had same IP as queried, assuming local ICS, so using broadcast enum\n");
        					IP_SOCKADDR(*psockaddr)=0xFFFFFFFF;
        				} else {
		            		memcpy(psockaddr, &saddr, sizeof(SOCKADDR));
		            	}	
 #endif       				
	            	}else{
	            		DEBUGPRINTADDR(7,"No local alias for Enum socket ",psockaddr);
	            	}
	            	
	            }
	            #undef IP_SOCKADDR
	        #elif USE_NATHELP
				#define IP_SOCKADDR(a) (((SOCKADDR_IN *)(&a))->sin_addr.s_addr)
				// Make sure the address we are enumming doesn't have a local alias.
				// If it does, use the local alias instead of the public address.
	            if(pgd->pINatHelp && 
	            	pgd->uEnumAddress != INADDR_BROADCAST && 
	            	pgd->uEnumAddress != INADDR_LOOPBACK){
	            	
	            	SOCKADDR saddr;
	            	HRESULT  hr;
	            	
	            	hr=IDirectPlayNATHelp_QueryAddress(
	            		pgd->pINatHelp, 
						&pgd->INADDRANY, 
						psockaddr, 
						&saddr, 
						sizeof(SOCKADDR_IN), 
						DPNHQUERYADDRESS_CACHENOTFOUND
						);

	            	if(hr==DP_OK){
	            		// If there is an alias, go broadcast.  This works just as well
	            		// and avoids problems where more than 1 mapped shared
	            		// UDP port is allocated.
	            		
		        		DEBUGPRINTADDR(7, "Enum Socket is ",psockaddr);
		        		DEBUGPRINTADDR(7, "Got Local Alias for Enum socket ",&saddr);
		        		
       					IP_SOCKADDR(*psockaddr)=0xFFFFFFFF;
	            	}else{
	            		DEBUGPRINTADDR(7,"No local alias for Enum socket ",psockaddr);
	            	}
	            	
	            }
	            #undef IP_SOCKADDR
	        #endif
		}
		else
		{
			DPF(0, "Invalid server address: 0x%08lx", hr); 
		}
	}	

	return (hr);
} // GetServerAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\wsock2.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wsock2.c
 *  Content:	DirectPlay Winsock 2 SP support.  Called from dpsp.c.
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	7/11//97	andyco	created it
 *  2/13/98     aarono  added async support.
 *  4/6/98      aarono  mapped WSAECONNRESET to DPERR_CONNECTIONLOST
 *  6/6/98      aarono  B#27187 fix ref counting on send blocks in sync error case
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *  1/12/2000   aarono  added rsip support
 *  2/21/2000   aarono  fix socket leaks
 **************************************************************************/

// this module is for async connections and sends
// only used w/ TCP:IP - IPX is dgram only, so we don't bother...
// currently only used as the reply thread proc for async replies. see dpsp.c::sp_reply

#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#include <winsock2.h>
#include "dpsp.h"
#include "rsip.h"
#include "nathelp.h"
#include "mmsystem.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"AsyncSendThreadProc"

extern HINSTANCE hWS2; 	// dynaload the ws2_32.dll, so if it's not installed
						// (e.g. win 95 gold) we still load

// prototypes for our dynaload fn's						

LPFN_WSAWAITFORMULTIPLEEVENTS g_WSAWaitForMultipleEvents;
LPFN_WSASEND g_WSASend;
LPFN_WSASENDTO g_WSASendTo;
LPFN_WSACLOSEEVENT g_WSACloseEvent;
LPFN_WSACREATEEVENT g_WSACreateEvent;
LPFN_WSAENUMNETWORKEVENTS g_WSAEnumNetworkEvents;
LPFN_WSAEVENTSELECT g_WSAEventSelect;
LPFN_GETSOCKOPT g_getsockopt;

// attempt to load the winsock 2 dll, and get our proc addresses from it
HRESULT InitWinsock2()
{
	// load winsock library
    hWS2 = LoadLibrary("ws2_32.dll");
	if (!hWS2)
	{
		DPF(0,"Could not load ws2_32.dll\n");
		// reset our winsock 2 global
		goto LOADLIBRARYFAILED;
	}

	// get pointers to the entry points we need
	g_WSAWaitForMultipleEvents = (LPFN_WSAWAITFORMULTIPLEEVENTS)GetProcAddress(hWS2, "WSAWaitForMultipleEvents");
	if(!g_WSAWaitForMultipleEvents) goto GETPROCADDRESSFAILED;

	g_WSASend = (LPFN_WSASEND)GetProcAddress(hWS2, "WSASend");
	if (!g_WSASend) goto GETPROCADDRESSFAILED;

	g_WSASendTo = (LPFN_WSASENDTO)GetProcAddress(hWS2, "WSASendTo");
	if (!g_WSASendTo) goto GETPROCADDRESSFAILED;

    g_WSAEventSelect = ( LPFN_WSAEVENTSELECT )GetProcAddress(hWS2, "WSAEventSelect");
	if (!g_WSAEventSelect) goto GETPROCADDRESSFAILED;

	g_WSAEnumNetworkEvents = (LPFN_WSAENUMNETWORKEVENTS)GetProcAddress(hWS2, "WSAEnumNetworkEvents");
	if (!g_WSAEnumNetworkEvents) goto GETPROCADDRESSFAILED;

	g_WSACreateEvent = (LPFN_WSACREATEEVENT)GetProcAddress(hWS2, "WSACreateEvent");
	if (!g_WSACreateEvent) goto GETPROCADDRESSFAILED;

	g_WSACloseEvent = (LPFN_WSACLOSEEVENT)GetProcAddress(hWS2, "WSACloseEvent");
	if (!g_WSACloseEvent) goto GETPROCADDRESSFAILED;

	g_getsockopt = (LPFN_GETSOCKOPT)GetProcAddress(hWS2, "getsockopt");
	if (!g_getsockopt) goto GETPROCADDRESSFAILED;

	return DP_OK;	

GETPROCADDRESSFAILED:

	DPF(0,"Could not find required Winsock entry point");
	FreeLibrary(hWS2);
	hWS2 = NULL;
	// fall through
	
LOADLIBRARYFAILED:

	g_WSAEventSelect = NULL;
	g_WSAEnumNetworkEvents = NULL;
	g_WSACreateEvent = NULL;
	g_WSACloseEvent = NULL;

	return DPERR_UNAVAILABLE;
	
} // InitWinsock2

// remove the reply node from the list
void DeleteReplyNode(LPGLOBALDATA pgd,LPREPLYLIST prd, BOOL bKillSocket)
{	
	LPREPLYLIST prdPrev;
	
	ENTER_DPSP();

	// 1st, remove prd from the list
	
	// is it the root?
	if (prd == pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
	else
	{
		BOOL bFound = FALSE;
		
		// it's not the root - take it out of the middle
		prdPrev = pgd->pReplyList;
		while (prdPrev && !bFound)
		{
			if (prdPrev->pNextReply == prd)
			{
				prdPrev->pNextReply = prd->pNextReply;
				bFound = TRUE;
			}
			else
			{
				prdPrev = prdPrev->pNextReply;
			}
		} // while
		
		ASSERT(bFound);
		
	} // not the root

	// now clean up prd
	
	// nuke the socket
	if (bKillSocket)
		KillSocket(prd->sSocket,TRUE,FALSE);
	
	// free up the node
	if (prd->lpMessage) SP_MemFree(prd->lpMessage);
	SP_MemFree(prd);
	
	LEAVE_DPSP();
	
	return ;

} // DeleteReplyNode

VOID MoveReplyNodeToCloseList(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
	LPREPLYLIST pPrev, pNode;

	DPF(8,"==>MoveReplyToCloseList prd %x\n",prd);

	pNode=pgd->pReplyList;
	pPrev=CONTAINING_RECORD(&pgd->pReplyList, REPLYLIST, pNextReply);

	while(pNode){
		if(prd==pNode){
			pPrev->pNextReply = pNode->pNextReply;
			pNode->pNextReply = pgd->pReplyCloseList;
			pgd->pReplyCloseList = pNode;
			pNode->tSent=timeGetTime();
			break;
		}

		pPrev=pNode;
		pNode=pNode->pNextReply;
	}
	DPF(8,"<==MoveReplyToCloseList prd %x\n",prd);
}

/*
 **  AsyncConnectAndSend
 *
 *  CALLED BY: AsyncSendThreadProc
 *
 *  DESCRIPTION:
 *			
 *			if necessary, creates a non-blocking socket, and initiates a connection
 *				to address specified in prd
 *			once connection has been completed, does a synchronous (blocking) send and
 *				removes prd from the global list
 */
HRESULT AsyncConnectAndSend(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
	UINT err;
	HRESULT hr;
	UINT addrlen = sizeof(SOCKADDR);	
	BOOL bConnectionExists = FALSE;
	BOOL bKillConnection = TRUE;

	if (INVALID_SOCKET == prd->sSocket)
	{
		u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
		DPID dpidPlayer=0;
		
#ifdef FULLDUPLEX_SUPPORT	
		// if client wants us to reuse a connection, it would have indicated so and the connection
		// would have been added to our send list by now. See if it exists.
		
		// TODO - we don't want to search the list everytime -  find a better way
		bConnectionExists = FindSocketInBag(pgd, &prd->sockaddr, &prd->sSocket, &dpidPlayer);
#endif // FULLDUPLEX_SUPPORT

		if (!bConnectionExists)
		{
			SOCKET sSocket;	

			// socket didn't exist in our send list, let's send it on a new temporary connection
			DEBUGPRINTADDR(4, "Sending async reply on a new connection to - ", &(prd->sockaddr));				
			
			// need to get the new socket
			hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,0,INADDR_ANY,&err,FALSE);
			if (FAILED(hr))
			{
				DPF(0,"create async socket failed - err = %d\n",err);
				return hr;
			}
			
			prd->sSocket = sSocket;
			
			// set socket to non-blocking
			err = ioctlsocket(prd->sSocket,FIONBIO,&lNonBlock);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not set non-blocking mode on socket err = %d!",err);
				DPF(0,"will revert to synchronous behavior.  bummer");
			}

			err=g_WSAEventSelect(prd->sSocket, pgd->hSelectEvent, FD_WRITE|FD_CONNECT|FD_CLOSE);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not do event select on socket err = %d!",err);
				DPF(0,"giving up on send..\n");
				goto CLEANUP_EXIT;
			}
			// now, start the connect
			SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket,SERVICE_SADDR_PUBLIC(pgd));		


			err = connect(prd->sSocket,&prd->sockaddr,addrlen);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				if (WSAEWOULDBLOCK == err)
				{
					// this is expected. the operation needs time to complete.
					// select will tell us when the socket is good to go.
					return DP_OK;
				}
				// else it's a real error!
				DPF(0,"async reply - connect failed - error = %d\n",err);			
				DEBUGPRINTADDR(0,"async reply - connect failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
				goto CLEANUP_EXIT;
			}
		}
		else
		{
			// we found our connection, let's reuse it
			// set it to non-blocking
			
			DEBUGPRINTADDR(6, "Sending async reply on an existing connection to - ", &(prd->sockaddr));				

			err = ioctlsocket(prd->sSocket,FIONBIO,&lNonBlock);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not set non-blocking mode on socket err = %d!",err);
				DPF(0,"will revert to synchronous behavior.  bummer");
			}

			// once we have a player id, the session has started. let's hold on to the connection
			// we have and reuse it for the rest of the session
			if (dpidPlayer) bKillConnection = FALSE;
			
		} // FindSocketInBag
	
	} // INVALID_SOCKET

	// once we get here, we should have a connected socket ready to send!
	err = 0;
	// keep spitting bits at the socket until we finish or get an error
	while ((prd->dwBytesLeft != 0) && (SOCKET_ERROR != err))
	{
		DPF(5, "AsyncConnectAndSend: Sending %u bytes via socket 0x%x.",
			prd->dwBytesLeft, prd->sSocket);
		DEBUGPRINTADDR(5, "AsyncConnectAndSend: Sending message over connection to - ", &prd->sockaddr);	
		
	    err = send(prd->sSocket,prd->pbSend,prd->dwBytesLeft,0);
		if (SOCKET_ERROR != err)
		{
			// some bytes went out on the wire
			prd->dwBytesLeft -= err; // we just sent err bytes
			prd->pbSend	+= err; // advance our send buffer by err bytes		
		}
	}
	// now, we've either finished the send, or we have an error
	if (SOCKET_ERROR == err)
	{
		err = WSAGetLastError();
		if (WSAEWOULDBLOCK == err)
		{
			DPF(8,"async send - total sent %d left to send %d\n",prd->pbSend,prd->dwBytesLeft);
			// this means we couldn't send any bytes w/o blocking
			// that's ok.  we'll let select tell us when it's ready to not block			
			return DP_OK; 	
		}
		// else it's a real eror!
		// any other error, we give up and clean up this reply
		DPF(0,"async send - send failed - error = %d\n",err);			
		DEBUGPRINTADDR(0,"async send - send failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
	}
	else ASSERT(0 == prd->dwBytesLeft); // if it's not an error, we better have sent it all

	DPF(8,"async send - total left to send %d (done)\n",prd->dwBytesLeft);
	
	// fall through

CLEANUP_EXIT:

	
	err = g_WSAEventSelect(prd->sSocket,pgd->hSelectEvent,0);
	if(SOCKET_ERROR == err){
		err = WSAGetLastError();
		DPF(8,"async send - error %d deselecting socket %s\n",err,prd->sSocket);
	}

	if (bConnectionExists && bKillConnection)
	{
		// close the connection after we're done
		RemoveSocketFromReceiveList(pgd,prd->sSocket);
		RemoveSocketFromBag(pgd,prd->sSocket);
		// so DeleteReplyNode won't try to kill socket again
		prd->sSocket = INVALID_SOCKET;
	}
	// remove the node from the list
	MoveReplyNodeToCloseList(pgd,prd);
	
	return DP_OK;

} // AsyncConnectAndSend

#if 0
// walk the reply list, tell winsock to watch any of the nodes which has a valid socket
// (i.e. has a connection or send pending)
HRESULT DoEventSelect(LPGLOBALDATA pgd,WSAEVENT hSelectEvent)
{
	UINT err;
	LPREPLYLIST prd;

	ENTER_DPSP();
	
	prd = pgd->pReplyList;
	while (prd)
	{
		if (INVALID_SOCKET != prd->sSocket)
		{
			// have winscok tell us when anything good (connection complete, ready to write more data)
			// happens on this socket
			err = g_WSAEventSelect(prd->sSocket,hSelectEvent,FD_WRITE | FD_CONNECT | FD_CLOSE);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not do event select ! err = %d!",err);
				// keep trying...
			}
		} // invalid_socket
		
		prd = prd->pNextReply;
	}

	LEAVE_DPSP();
	
	return DP_OK;
	
} // DoEventSelect
#endif

// wsaeventselect woke us up.  one or more of our sockets had something happen
// (e.g. connect completed, send ready for more data, etc.)
// walk the reply list, find nodes who need to be serviced
void ServiceReplyList(LPGLOBALDATA pgd,WSAEVENT hEvent)
{
	UINT err;
	LPREPLYLIST prd,prdNext;
	WSANETWORKEVENTS WSANetEvents;

	ENTER_DPSP();
	
Top:	
	prd = pgd->pReplyList;
	while (prd)
	{
		// save this now - asyncconnectandsend could destroy prd
		prdNext = prd->pNextReply;
		if (INVALID_SOCKET != prd->sSocket)
		{
			// go ask winsock if this socket had anything intersting happen
			err = g_WSAEnumNetworkEvents(prd->sSocket,NULL,&WSANetEvents);

			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not enum events!! err = %d!",err);
				// keep trying...
			}
			else
			{
				BOOL bError=FALSE;
				// no error - go see what we got
				DPF(8,"Got NetEvents %x for socket %d\n",WSANetEvents.lNetworkEvents, prd->sSocket);
				DEBUGPRINTSOCK(8," socket addr -\n", &prd->sSocket);
				if ((WSANetEvents.lNetworkEvents & FD_CONNECT) || (WSANetEvents.lNetworkEvents & FD_WRITE))
				{
					DWORD dwPlayerTo;
					
					// was there an error?
					if (WSANetEvents.iErrorCode[FD_CONNECT_BIT])
					{
						// we got a connect error!
						DPF(0,"async reply - WSANetEvents - connect failed - error = %d\n",
							WSANetEvents.iErrorCode[FD_CONNECT_BIT]);
						DEBUGPRINTADDR(0,"async reply - connect failed - addr = ",
							(LPSOCKADDR)&(prd->sockaddr));
						dwPlayerTo = prd->dwPlayerTo;
						DeleteReplyNode(pgd,prd,TRUE);
						RemovePendingAsyncSends(pgd, dwPlayerTo);
						goto Top;
							
					}

					if (WSANetEvents.iErrorCode[FD_WRITE_BIT])
					{
						// we got a send error!
						DPF(0,"async reply - WSANetEvents - send failed - error = %d\n",
							WSANetEvents.iErrorCode[FD_WRITE_BIT]);
						DEBUGPRINTADDR(0,"async reply - send failed - addr = ",
							(LPSOCKADDR)&(prd->sockaddr));
						dwPlayerTo = prd->dwPlayerTo;
						DeleteReplyNode(pgd,prd,TRUE);
						RemovePendingAsyncSends(pgd, dwPlayerTo);
						goto Top;
					}
					
					if(WSANetEvents.lNetworkEvents & FD_CLOSE){
						dwPlayerTo = prd->dwPlayerTo;
						DeleteReplyNode(pgd,prd,TRUE);
						RemovePendingAsyncSends(pgd, dwPlayerTo);
						goto Top;
					}
					// note - we try + send even if there was an error.	seems like it's worth a shot...
					// go try + send

					AsyncConnectAndSend(pgd,prd);
				}
			}
		} // invalid_socket
		else
		{
			// it it's an invalid socket, we need to init our connect and send
			AsyncConnectAndSend(pgd,prd);	
		}
		
		prd = prdNext;		
		
	}

	LEAVE_DPSP();
	
	return ;
	
} // ServiceReplyList

VOID ServiceReplyCloseList(LPGLOBALDATA pgd, DWORD tNow, BOOL fWait)
{
	UINT err;
	LPREPLYLIST prdPrev,prd,prdNext;

	DPF(8,"==>ServiceReplyCloseList\n");

	prdPrev = CONTAINING_RECORD(&pgd->pReplyCloseList, REPLYLIST, pNextReply);
	prd = pgd->pReplyCloseList;
	
	while (prd)
	{
		prdNext = prd->pNextReply;

		if((tNow-prd->tSent) > LINGER_TIME || fWait){

			while((tNow-prd->tSent) < LINGER_TIME){
				Sleep(500);
				tNow=timeGetTime();
			}
		
			// close that puppy
			KillSocket(prd->sSocket,TRUE,TRUE);
		
			// free up the node
			if (prd->lpMessage) SP_MemFree(prd->lpMessage);
			SP_MemFree(prd);
			prdPrev->pNextReply = prdNext;
			prd = prdNext;
		} else {
			prdPrev=prd;
			prd=prdNext;
		}
	}	
	DPF(8,"<==ServiceReplyCloseList\n");
}

// this thread works on doing async sends
DWORD WINAPI AsyncSendThreadProc(LPVOID pvCast)
{
	HRESULT hr=DP_OK;
	LPGLOBALDATA pgd = (LPGLOBALDATA) pvCast;
	HANDLE hHandleList[3];
	DWORD rc;
	DWORD tWait;
	WSAEVENT hSelectEvent; // event used by WSASelectEvent

	DWORD tLast;
	DWORD tNow;
	#if (USE_RSIP || USE_NATHELP)
	DWORD tLastRsip;
	#endif

	DPF(8,"Entered AsyncSendThreadProc\n");


	// get the event 4 selectevent
	hSelectEvent = g_WSACreateEvent();

	pgd->hSelectEvent = hSelectEvent;

	if (WSA_INVALID_EVENT == hSelectEvent)
	{
		rc = WSAGetLastError();
		DPF(0,"could not create winsock event - rc = %d\n",rc);
		ExitThread(0);
		return 0;
	}
	
	hHandleList[0] = hSelectEvent;
	hHandleList[1] = pgd->hReplyEvent;
	// This extra handle is here because of a Windows 95 bug.  Windows
	// will occasionally miss when it walks the handle table, causing
	// my thread to wait on the wrong handles.  By putting a guaranteed
	// invalid handle at the end of our array, the kernel will do a
	// forced re-walk of the handle table and find the correct handles.
	hHandleList[2] = INVALID_HANDLE_VALUE;

		tNow=timeGetTime();
		tLast=tNow;
	#if (USE_RSIP || USE_NATHELP)
		tLastRsip=tNow;
	#endif

	ASSERT(2*LINGER_TIME < RSIP_RENEW_TEST_INTERVAL);

	while (1)
	{
		// tell winsock to watch all of our reply nodes.  it will set our event
		// when something cool happens...
		//DoEventSelect(pgd,hSelectEvent); -- do on creation only, its sticky.

		wait:
			// we only poll every 2 linger times because it really isn't a resource
			// contraint expect at close, which will not linger as much.
			
			tWait=(tLast+2*LINGER_TIME)-tNow;
			if((int)tWait < 0){
				tWait=0;
			}
			ASSERT(!(tWait &0x80000000));

		// wait on our event.  when it's set, we either split, or empty the reply list
		rc = WaitForMultipleObjectsEx(2,hHandleList,FALSE,tWait,TRUE);

		tNow=timeGetTime();
		if(rc == WAIT_TIMEOUT){
		
		#if (USE_RSIP || USE_NATHELP)
			#if USE_RSIP
				if(pgd->sRsip != INVALID_SOCKET){
					if((tNow - tLastRsip) >= RSIP_RENEW_TEST_INTERVAL)
					{
						tLastRsip=tNow;
						rsipPortExtend(pgd, tNow);
						rsipCacheClear(pgd, tNow);
					}	
				} else {
					tLastRsip=tNow;
				}
			#endif	
			#if USE_NATHELP
				if(pgd->pINatHelp){
					if((tNow - tLastRsip) >= RSIP_RENEW_TEST_INTERVAL)
					{
						tLastRsip=tNow;
						natExtend(pgd);
					}	
				} else {
					tLastRsip=tNow;
				}
			#endif	
		#endif

			tLast=tNow;
			
			ENTER_DPSP();
				if(pgd->pReplyCloseList)
				{
					ServiceReplyCloseList(pgd,tNow,FALSE);
				}
			LEAVE_DPSP();

			goto wait;
		}	
		
		if ((DWORD)-1 == rc)
		{
			DWORD dwError = GetLastError();
			// rut roh!  errror on the wait
			DPF(0,"!!!!!	error on WaitForMultipleObjects -- async reply bailing -- dwError = %d",dwError);
			goto CLEANUP_EXIT;			
			
		}
		
		if (rc == WAIT_OBJECT_0)	// a-josbor: need to reset this manual event
		{
			ResetEvent(hSelectEvent);
		}
		
		// ok.  someone woke us up.  it could be 1. shutdown,  or 2. one
		// of our sockets needs attention (i.e. a connect completed), or 3. someone
		// put a new reply node on the list
		
		// shutdown?		
		if (pgd->bShutdown)
		{
			goto CLEANUP_EXIT;
		}
		
		DPF(8,"In AsyncSendThreadProc, servicing event %d\n", rc - WAIT_OBJECT_0);

		// otherwise, it must be a socket in need or a new replynode
		ServiceReplyList(pgd,hSelectEvent);
	} // 1

CLEANUP_EXIT:
	
	ENTER_DPSP();

	// cleanout reply list
	while (pgd->pReplyList) DeleteReplyNode(pgd,pgd->pReplyList,TRUE);
	
	ServiceReplyCloseList(pgd,tNow,TRUE);
	ASSERT(pgd->pReplyCloseList==NULL);
	
	CloseHandle(pgd->hReplyEvent);
	pgd->hReplyEvent = 0;

	LEAVE_DPSP();

	g_WSACloseEvent(hSelectEvent);
	
	DPF(6,"replythreadproc exit");
	
	return 0;

} // AsyncSendThreadProc


HRESULT GetMaxUdpBufferSize(SOCKET socket, UINT * piMaxUdpDg)
{
	INT iBufferSize;
	INT err;

	ASSERT(piMaxUdpDg);

	iBufferSize = sizeof(UINT);
	err = g_getsockopt(socket, SOL_SOCKET, SO_MAX_MSG_SIZE, (LPBYTE)piMaxUdpDg, &iBufferSize);
	if (SOCKET_ERROR == err)
	{
		DPF(0,"getsockopt for SO_MAX_MSG_SIZE returned err = %d", WSAGetLastError());
		return DPERR_UNAVAILABLE;
	}

	return DP_OK;
}

#ifdef SENDEX

DWORD wsaoDecRef(LPSENDINFO pSendInfo)
{
	#define pgd (pSendInfo->pgd)
	
	DWORD count;
	
	EnterCriticalSection(&pgd->csSendEx);
	count=(--pSendInfo->RefCount);

	if(!count){
	
		Delete(&pSendInfo->PendingSendQ);
		pgd->dwBytesPending -= pSendInfo->dwMessageSize;
		pgd->dwMessagesPending -= 1;
		
		LeaveCriticalSection(&pgd->csSendEx);

		DPF(8,"wsaoDecRef pSendInfo %x, Refcount=0 , SC context %x, status=%x \n",pSendInfo, pSendInfo->dwUserContext,pSendInfo->Status);


		if(pSendInfo->dwFlags & SI_INTERNALBUFF){
			SP_MemFree(pSendInfo->SendArray[0].buf);
		} else {
			if(pSendInfo->dwSendFlags & DPSEND_ASYNC){
				pSendInfo->lpISP->lpVtbl->SendComplete(pSendInfo->lpISP,(LPVOID)pSendInfo->dwUserContext,pSendInfo->Status);
			}	
		}
		
		pgd->pSendInfoPool->Release(pgd->pSendInfoPool, pSendInfo);
		
	} else {
	
		DPF(8,"wsaoDecRef pSendInfo %x, Refcount= %d\n",pSendInfo,pSendInfo->RefCount);
		LeaveCriticalSection(&pgd->csSendEx);
		
	}

	if(count& 0x80000000){
		DEBUG_BREAK();
	}
	
	return count;
	
	#undef pgd
}


VOID CompleteSend(LPSENDINFO pSendInfo)
{
	if(pSendInfo->pConn){
		EnterCriticalSection(&pSendInfo->pgd->csFast);
		pSendInfo->pConn->bSendOutstanding = FALSE;
		LeaveCriticalSection(&pSendInfo->pgd->csFast);
		QueueNextSend(pSendInfo->pgd, pSendInfo->pConn);
		DecRefConn(pSendInfo->pgd, pSendInfo->pConn);
	} 

	wsaoDecRef(pSendInfo);
}

void CALLBACK SendComplete(
  DWORD dwError,
  DWORD cbTransferred,
  LPWSAOVERLAPPED lpOverlapped,
  DWORD dwFlags
)
{
	LPSENDINFO lpSendInfo=(LPSENDINFO)CONTAINING_RECORD(lpOverlapped,SENDINFO,wsao);

	DPF(8,"DPWSOCK:SendComplete, lpSendInfo %x\n",lpSendInfo);

	if(dwError){
		DPF(0,"DPWSOCK: send completion error, dwError=x%x\n",dwError);
		lpSendInfo->Status=DPERR_GENERIC;
	}

	CompleteSend(lpSendInfo);
}

HRESULT DoSend(LPGLOBALDATA pgd, LPSENDINFO pSendInfo)
{
	#define fAsync (pSendInfo->dwSendFlags & DPSEND_ASYNC)
	
	DWORD dwBytesSent;
	UINT err;
	HRESULT hr=DP_OK;


	if (pSendInfo->dwFlags & SI_RELIABLE)
	{
	
		// Reliable Send
		DPF(8,"WSASend, pSendInfo %x\n",pSendInfo);

#if DUMPBYTES
		{
			PCHAR pBuf;
			UINT buflen;
			UINT i=0;

			pBuf = 	 ((LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf+pSendInfo->cBuffers-1])->buf;
			buflen =  ((LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf+pSendInfo->cBuffers-1])->len;

			while (((i + 16) < buflen) && (i < 4*16)){
				DPF(9, "%08x %08x %08x %08x",*(PUINT)(&pBuf[i]),*(PUINT)(&pBuf[i+4]),*(PUINT)(&pBuf[i+8]),*(PUINT)(&pBuf[i+12]));
				i += 16;
			}	
		}
#endif


		// send the message
		err = g_WSASend(pSendInfo->sSocket,
					  (LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf],
					  pSendInfo->cBuffers,
					  &dwBytesSent,
				  	  0,				/*flags*/
				  	  (fAsync)?(&pSendInfo->wsao):NULL,
				  	  (fAsync)?(SendComplete):NULL);

		if(!err){
				DPF(8,"WSASend, sent synchronously, pSendInfo %x\n",pSendInfo);
				wsaoDecRef(pSendInfo);
				hr=DP_OK;
		} else {

			if (SOCKET_ERROR == err)
			{
			
				err = WSAGetLastError();

				if(err==WSA_IO_PENDING){
					hr=DPERR_PENDING;
					wsaoDecRef(pSendInfo);
					DPF(8,"ASYNC SEND Pending pSendInfo %x\n",pSendInfo);
				} else {
					DPF(8,"WSASend Error %d\n",err);
					ASSERT(err != WSAEWOULDBLOCK); // vadime assures this never happens. (aarono 9-12-00)
					if(err==WSAECONNRESET){
						hr=DPERR_CONNECTIONLOST;
					} else {
						hr=DPERR_GENERIC;
					}	
					if(fAsync){
						// Got an error, need to dump 2 refs.
						pSendInfo->Status=hr;
						wsaoDecRef(pSendInfo);
					}	
					CompleteSend(pSendInfo);
					// we got a socket from the bag.  send failed,
					// so we're cruising it from the bag
					if(!pSendInfo->dwFlags & SI_INTERNALBUFF){
						DPF(0,"send error - err = %d\n",err);
							DPF(4,"send failed - removing socket from bag");
							RemovePlayerFromSocketBag(pgd,pSendInfo->idTo);
					}		
				}	
			
			}
		}	
	
	} else {
	
		// Datagram Send
		DEBUGPRINTADDR(5,"unreliable send - sending to ",&pSendInfo->sockaddr);	
		// send the message
		err = g_WSASendTo(pSendInfo->sSocket,
						  (LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf],
						  pSendInfo->cBuffers,
						  &dwBytesSent,
						  0,				/*flags*/
						  (LPSOCKADDR)&pSendInfo->sockaddr,
					      sizeof(SOCKADDR),
					  	  (fAsync)?(&pSendInfo->wsao):NULL,
					  	  (fAsync)?(SendComplete):NULL);


		if(!err){
			hr=DP_OK;
			wsaoDecRef(pSendInfo);
		} else {
		    if (SOCKET_ERROR == err)
		    {
		        err = WSAGetLastError();
		
		        if(err==WSA_IO_PENDING){
		        	hr=DPERR_PENDING;
					wsaoDecRef(pSendInfo);
				} else {
					hr=DPERR_GENERIC;
					if(fAsync){
						// some error, force completion.
						pSendInfo->Status=DPERR_GENERIC;
						wsaoDecRef(pSendInfo);
					}	
					wsaoDecRef(pSendInfo);
			        DPF(0,"send error - err = %d\n",err);
		        }
		    } else {
		    	DEBUG_BREAK();// SHOULD NEVER HAPPEN
		    }

		}
		
	}
	return hr;
	
	#undef fAsync
}

// Alert thread provides a thread for send completions to run on.

DWORD WINAPI SPSendThread(LPVOID lpv)
{
	LPGLOBALDATA pgd=(LPGLOBALDATA) lpv;
	LPSENDINFO  pSendInfo;

	DWORD rcWait=WAIT_IO_COMPLETION;
	BILINK *pBilink;
	BOOL bSent;

	pgd->BogusHandle=INVALID_HANDLE_VALUE;	// workaround win95 wait for multiple bug.
	
	while(!pgd->bStopSendThread){
		rcWait=g_WSAWaitForMultipleEvents(1,&pgd->hSendWait,FALSE,INFINITE,TRUE);
		#ifdef DEBUG
		if(rcWait==WAIT_IO_COMPLETION){
			DPF(8,"ooooh, IO completion\n");
		}
		#endif

		do {
			bSent = FALSE;
		
			EnterCriticalSection(&pgd->csSendEx);

			pBilink=pgd->ReadyToSendQ.next;

			if(pBilink != &pgd->ReadyToSendQ){
				Delete(pBilink);
				LeaveCriticalSection(&pgd->csSendEx);
				pSendInfo=CONTAINING_RECORD(pBilink, SENDINFO, ReadyToSendQ);
				DoSend(pgd, pSendInfo);
				bSent=TRUE;
			} else {
				LeaveCriticalSection(&pgd->csSendEx);
			}	
		} while (bSent);
	}	

	pgd->bSendThreadRunning=FALSE;
	
	return FALSE;
	
	#undef hWait
}



void QueueForSend(LPGLOBALDATA pgd,LPSENDINFO pSendInfo)
{
	EnterCriticalSection(&pgd->csSendEx);
	
		if(pSendInfo->pConn){
			// Note csFast is taken for pConn to be non-NULL
			AddRefConn(pSendInfo->pConn);
			pSendInfo->pConn->bSendOutstanding = TRUE;
		}	
		
		InsertBefore(&pSendInfo->ReadyToSendQ,&pgd->ReadyToSendQ);
		
	LeaveCriticalSection(&pgd->csSendEx);
	
	SetEvent(pgd->hSendWait);
}

// some common code for InternalReliableSendEx and UnreliableSendEx
VOID CommonInitForSend(LPGLOBALDATA pgd,LPDPSP_SENDEXDATA psd,LPSENDINFO pSendInfo)
{

	pSendInfo->pConn		= NULL;
	pSendInfo->dwMessageSize= psd->dwMessageSize;
	pSendInfo->dwUserContext= (DWORD_PTR)psd->lpDPContext;
	pSendInfo->RefCount     = 2;		// one for completion, 1 for this routine
	pSendInfo->pgd          = pgd;
	pSendInfo->lpISP        = psd->lpISP;
	pSendInfo->Status       = DP_OK;
	pSendInfo->idTo         = psd->idPlayerTo;
	pSendInfo->idFrom       = psd->idPlayerFrom;
	pSendInfo->dwSendFlags  = psd->dwFlags;
	
	if(psd->lpdwSPMsgID){
		*psd->lpdwSPMsgID=0;
	}	

	EnterCriticalSection(&pgd->csSendEx);
	
		InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
		pgd->dwBytesPending += psd->dwMessageSize;
		pgd->dwMessagesPending += 1;
		
	LeaveCriticalSection(&pgd->csSendEx);
}

VOID UnpendSendInfo(LPGLOBALDATA pgd, LPSENDINFO pSendInfo)
{
	EnterCriticalSection(&pgd->csSendEx);
	Delete(&pSendInfo->PendingSendQ);
	pgd->dwBytesPending -= pSendInfo->dwMessageSize;
	pgd->dwMessagesPending -= 1;
	LeaveCriticalSection(&pgd->csSendEx);
}


HRESULT UnreliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo)
{
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr=DP_OK;
    UINT err;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	BOOL bSendHeader;
	
	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (pgd->iMaxUdpDg && (psd->dwMessageSize >= pgd->iMaxUdpDg))
	{
		return DPERR_SENDTOOBIG;
	}

	// get to address	
    if (0 == psd->idPlayerTo)
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(DGRAM_PSOCKADDR(ppdTo));
    }

	// put the token + size on front of the mesage
	SetMessageHeader((LPVOID)(pSendInfo->SendArray[0].buf),psd->dwMessageSize+sizeof(MESSAGEHEADER),TOKEN);
   	bSendHeader=TRUE;
   	
	if (psd->bSystemMessage)
    {
		SetReturnAddress(pSendInfo->SendArray[0].buf,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));
    } // reply
	else
	{
		// see if we can send this message w/ no header
		// if the message is smaller than a dword, or, if it's a valid sp header (fooling us
		// on the other end, don't send any header
		if ( !((psd->dwMessageSize >= sizeof(DWORD)) &&  !(VALID_SP_MESSAGE(pSendInfo->SendArray[0].buf))) )
		{
			bSendHeader=FALSE;
		}
	}

    CommonInitForSend(pgd,psd,pSendInfo);
	pSendInfo->dwFlags      |= SI_DATAGRAM;
	pSendInfo->sSocket      = pgd->sSystemDGramSocket;
	pSendInfo->sockaddr     = sockaddr;

	if(bSendHeader){
		pSendInfo->iFirstBuf=0;
		pSendInfo->cBuffers =psd->cBuffers+1;
	} else {
		pSendInfo->iFirstBuf=1;
		pSendInfo->cBuffers=psd->cBuffers;
	}

	if(psd->dwFlags & DPSEND_ASYNC){
		QueueForSend(pgd,pSendInfo);
		hr=DPERR_PENDING;
	} else {
		hr=DoSend(pgd,pSendInfo);
		if(hr==DP_OK || hr==DPERR_PENDING){
			wsaoDecRef(pSendInfo);
		} else {
			UnpendSendInfo(pgd, pSendInfo);
		}
	}
	
	return hr;

} // UnreliableSendEx
#endif //SendEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPLobby"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\context.c ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       context.c
 *  Content:	Internal methods for context (handle) management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	1/18/97		myronth	Created it
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
						this includes removing this file from the build
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetNewContextID"
HRESULT PRV_GetNewContextID(LPDPLOBBYI_DPLOBJECT this, LPDWORD lpdwContext)
{

	DPF(7, "Entering PRV_GetNewContextID");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpdwContext);

	ASSERT(this);
	ASSERT(lpdwContext);

	// Get the current context ID and increment the counter
	if(this->bContextWrap)
	{
		// REVIEW!!!! -- We need to deal with the wrap case, but for
		// now just ASSERT if we hit it (it's pretty unlikely)
		ASSERT(FALSE);
		return DPERR_GENERIC;
	}
	else
	{
		*lpdwContext = this->dwContextCurrent++;
		return DP_OK;
	}
	
} // PRV_GetNewContextID



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindContextNode"
LPDPLOBBYI_CONTEXTNODE PRV_FindContextNode(LPDPLOBBYI_DPLOBJECT this,
											DWORD dwContext)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN;


	DPF(7, "Entering PRV_FindContextNode");
	DPF(9, "Parameters: 0x%08x, %d", this, dwContext);

	ASSERT(this);

	// Walk the list of context nodes, looking for the right ID
	lpCN = this->ContextHead.lpNext;
	while(lpCN != &(this->ContextHead))
	{
		if(lpCN->dwContext == dwContext)
			return lpCN;
		else
			lpCN = lpCN->lpNext;
	}

	// We didn't find it
	return NULL;

} // PRV_FindContextNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetAsyncDataFromContext"
LPDPASYNCDATA PRV_GetAsyncDataFromContext(LPDPLOBBYI_DPLOBJECT this,
											DWORD dwContext)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN;


	DPF(7, "Entering PRV_GetAsyncDataFromContext");
	DPF(9, "Parameters: 0x%08x, %d", this, dwContext);

	ASSERT(this);

	// Find the node and pull out the AsyncData object
	lpCN = PRV_FindContextNode(this, dwContext);
	if(lpCN)
		return lpCN->lpAD;
	else
		return NULL;

} // PRV_GetAsyncDataFromContext



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddContextNode"
HRESULT PRV_AddContextNode(LPDPLOBBYI_DPLOBJECT this, LPDPASYNCDATA lpAD,
							LPDPLOBBYI_CONTEXTNODE * lplpCN)
{
	HRESULT					hr = DP_OK;
	DWORD					dwContext;
	LPDPLOBBYI_CONTEXTNODE	lpCN = NULL;


	DPF(7, "Entering PRV_AddContextNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x", this, lpAD, lplpCN);

	ASSERT(this);
	ASSERT(lpAD);
	ASSERT(lplpCN);

	// Allocate memory for the new node
	lpCN = DPMEM_ALLOC(sizeof(DPLOBBYI_CONTEXTNODE));
	if(!lpCN)
	{
		DPF_ERR("Unable to allocate memory for context node");
		return DPERR_OUTOFMEMORY;
	}

	// Get a new context ID
	hr = PRV_GetNewContextID(this, &dwContext);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to get new context ID");
		return DPERR_GENERIC;
	}

	// Fill in the structure
	lpCN->dwContext = dwContext;
	lpCN->lpAD = lpAD;

	// Fill in the output parameter
	*lplpCN = lpCN;

	// Add the node to the end of the list
	this->ContextHead.lpPrev->lpNext = lpCN;
	lpCN->lpPrev = this->ContextHead.lpPrev;
	this->ContextHead.lpPrev = lpCN;
	lpCN->lpNext = &(this->ContextHead);

	return DP_OK;

} // PRV_AddContextNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteContextNode"
HRESULT PRV_DeleteContextNode(LPDPLOBBYI_DPLOBJECT this,
				LPDPLOBBYI_CONTEXTNODE lpCN)
{
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DeleteContextNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpCN);

	ASSERT(this);

	// Remove the node from the list
	lpCN->lpPrev->lpNext = lpCN->lpNext;
	lpCN->lpNext->lpPrev = lpCN->lpPrev;

	// And delete the node
	DPMEM_FREE(lpCN);
	return DP_OK;

} // PRV_DeleteContextNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CleanUpContextList"
void PRV_CleanUpContextList(LPDPLOBBYI_DPLOBJECT this)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN, lpCNNext;


	DPF(7, "Entering PRV_CleanUpContextList");
	DPF(9, "Parameters: 0x%08x", this);

	ASSERT(this);

	// Walk the list, cleaning up the nodes
	lpCN = this->ContextHead.lpNext;
	while(lpCN != &(this->ContextHead))
	{
		lpCNNext = lpCN->lpNext;
		PRV_DeleteContextNode(this, lpCN);
		lpCN = lpCNNext;
	}

} // PRV_CleanUpContextList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateAndLinkAsyncDataContext"
HRESULT PRV_CreateAndLinkAsyncDataContext(LPDPLOBBYI_DPLOBJECT this,
									LPDPLOBBYI_CONTEXTNODE * lplpCN)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN = NULL;
	LPDPASYNCDATA			lpAD = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_CreateAndLinkAsyncDataContext");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lplpCN);

	ASSERT(this);
	ASSERT(lplpCN);

	// Create the AsyncData object
	hr = CreateAsyncData(&lpAD);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to create DPAsyncData object");
		return hr;
	}

	// Add a new context node and link it in
	hr = PRV_AddContextNode(this, lpAD, &lpCN);
	if(FAILED(hr))
	{
		lpAD->lpVtbl->Release(lpAD);
		return hr;
	}

	// Fill in the output vars
	*lplpCN = lpCN;

	return DP_OK;

} // PRV_CreateAndLinkAsyncDataContext



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_UnlinkAndReleaseAsyncDataContext"
void PRV_UnlinkAndReleaseAsyncDataContext(LPDPLOBBYI_DPLOBJECT this,
									LPDPLOBBYI_CONTEXTNODE lpCN)
{
	LPDPASYNCDATA			lpAD = NULL;


	DPF(7, "Entering PRV_CreateAndLinkAsyncDataContext");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpCN);

	ASSERT(this);
	ASSERT(lpCN);

	// Release the AsyncData pointer
	lpCN->lpAD->lpVtbl->Release(lpCN->lpAD);

	// Remove the context node
	PRV_DeleteContextNode(this, lpCN);

} // PRV_UnlinkAndReleaseAsyncDataContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplgame.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplgame.c
 *  Content:	Methods for game management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *	10/23/96	myronth	added client/server methods
 *	12/12/96	myronth	Fixed DPLCONNECTION validation
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	4/3/97		myronth	#ifdef'd out DPLC_StartGame (Nov. spec related)
 *	5/8/97		myronth	Purged dead code
 *	5/22/97		myronth Changed error code processing of RunApplication which
 *						was calling the wrong cleanup function (#8871)
 *	6/4/97		myronth	Fixed handle leak (#9458)
 *	6/19/97		myronth	Fixed handle leak (#10063)
 *	7/30/97		myronth	Added support for standard lobby messaging and fixed
 *						additional backslash on current directory bug (#10592)
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	1/26/98		myronth	Added OS_CompareString function for Win95
 *	7/07/98		kipo	Define and use PROCESSENTRY32A to avoid passing
 *						Unicode data structures to Win95 functions expecting ANSI
 *  7/09/99     aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *  7/12/00     aarono  fix GUIDs for IPC to be fully significant, otherwise won't IPC.
 *
 ***************************************************************************/
#include "dplobpr.h"
#include <tchar.h>
#include <tlhelp32.h>
#include <winperf.h>

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindGameInRegistry"
BOOL PRV_FindGameInRegistry(LPGUID lpguid, LPWSTR lpwszAppName,
							DWORD dwNameSize, HKEY * lphkey)
{
	HKEY	hkeyDPApps, hkeyApp;
	DWORD	dwIndex = 0;
	WCHAR	wszGuidStr[GUID_STRING_SIZE];
	DWORD	dwGuidStrSize = GUID_STRING_SIZE;
	DWORD	dwType = REG_SZ;
	GUID	guidApp;
	LONG	lReturn;
	BOOL	bFound = FALSE;
	DWORD	dwSaveNameSize = dwNameSize;


	DPF(7, "Entering PRV_FindGameInRegistry");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			lpguid, lpwszAppName, dwNameSize, lphkey);

 	// Open the Applications key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0,
								KEY_READ, &hkeyDPApps);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Unable to open DPlay Applications registry key!");
		return FALSE;
	}

	// Walk the list of DPlay games in the registry, looking for
	// the app with the right GUID
	while(!bFound)
	{
		// Open the next application key
		dwSaveNameSize = dwNameSize;
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegEnumKeyEx(hkeyDPApps, dwIndex++, lpwszAppName,
						&dwSaveNameSize, NULL, NULL, NULL, NULL);

		// If the enum returns no more apps, we want to bail
		if(lReturn != ERROR_SUCCESS)
			break;
		
		// Open the application key		
		lReturn = OS_RegOpenKeyEx(hkeyDPApps, lpwszAppName, 0,
									KEY_READ, &hkeyApp);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open app key!");
			continue;
		}

		// Get the GUID of the Game
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_GUID, NULL, &dwType,
									(LPBYTE)&wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeyApp);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID & Compare it to the passed in one
		GUIDFromString(wszGuidStr, &guidApp);
		if(IsEqualGUID(&guidApp, lpguid))
		{
			bFound = TRUE;
			break;
		}

		// Close the App key
		RegCloseKey(hkeyApp);
	}

	// Close the DPApps key
	RegCloseKey(hkeyDPApps);

	if(bFound)
		*lphkey = hkeyApp;

	return bFound;


} // PRV_FindGameInRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetKeyStringValue"
BOOL PRV_GetKeyStringValue(HKEY hkeyApp, LPWSTR lpwszKey, LPWSTR * lplpwszValue)
{
	DWORD	dwType = REG_SZ;
	DWORD	dwSize=0;
	LPWSTR	lpwszTemp = NULL;
	LONG	lReturn;


	DPF(7, "Entering PRV_GetKeyStringValue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeyApp, lpwszKey, lplpwszValue);

	ASSERT(lplpwszValue);

	// Get the size of the buffer for the Path
	lReturn = OS_RegQueryValueEx(hkeyApp, lpwszKey, NULL, &dwType,
								NULL, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Error getting size of key value!");
		return FALSE;
	}

	// If the size is 2, then it is an empty string (only contains a
	// null terminator).  Treat this the same as a NULL string or a
	// missing key and fail it.
	if(dwSize <= 2)
		return FALSE;

	// Alloc the buffer for the Path
	lpwszTemp = DPMEM_ALLOC(dwSize);
	if(!lpwszTemp)
	{
		DPF_ERR("Unable to allocate temporary string for Path!");
		return FALSE;
	}

	// Get the value itself
	lReturn = OS_RegQueryValueEx(hkeyApp, lpwszKey, NULL, &dwType,
							(LPBYTE)lpwszTemp, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPMEM_FREE(lpwszTemp);
		DPF_ERR("Unable to get key value!");
		return FALSE;
	}

	*lplpwszValue = lpwszTemp;
	return TRUE;

} // PRV_GetKeyStringValue



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeConnectInfo"
BOOL PRV_FreeConnectInfo(LPCONNECTINFO lpci)
{
	DPF(7, "Entering PRV_FreeConnectInfo");
	DPF(9, "Parameters: 0x%08x", lpci);

	if(!lpci)
		return TRUE;

	if(lpci->lpszName)
		DPMEM_FREE(lpci->lpszName);
	if(lpci->lpszPath)
		DPMEM_FREE(lpci->lpszPath);
	if(lpci->lpszFile)
		DPMEM_FREE(lpci->lpszFile);
	if(lpci->lpszCommandLine)
		DPMEM_FREE(lpci->lpszCommandLine);
	if(lpci->lpszCurrentDir)
		DPMEM_FREE(lpci->lpszCurrentDir);
	if(lpci->lpszAppLauncherName)
		DPMEM_FREE(lpci->lpszAppLauncherName);


	return TRUE;

} // PRV_FreeConnectInfo



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetConnectInfoFromRegistry"
BOOL PRV_GetConnectInfoFromRegistry(LPCONNECTINFO lpci)
{
	LPWSTR	lpwszAppName;
	HKEY	hkeyApp = NULL;
	LPWSTR	lpwszTemp;
	DWORD	dwSize = 0;
	DWORD	dwError;
	GUID	guidApp;
	BOOL	bReturn;


	DPF(7, "Entering PRV_GetConnectInfoFromRegistry");
	DPF(9, "Parameters: 0x%08x", lpci);

	// Clear our ConnectInfo structure since we will be overwriting
	// whatever is in it, and we are making assumptions that the
	// string pointers are NULL to start with.  However, we need
	// the Application guid, so save it off
	guidApp = lpci->guidApplication;
	memset(lpci, 0, sizeof(CONNECTINFO));
	lpci->guidApplication = guidApp;

	// Allocate memory for the App Name
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN);
	if(!lpwszAppName)
	{
		DPF_ERR("Unable to allocate memory for App Name!");
		return FALSE;
	}
	
	
	// Open the registry key for the App
	if(!PRV_FindGameInRegistry(&(lpci->guidApplication), lpwszAppName,
								DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		DPMEM_FREE(lpwszAppName);
		DPF_ERR("Unable to find game in registry!");
		return FALSE;
	}

	lpci->lpszName = lpwszAppName;

	// Get the string value for the Path.  If this fails, we
	// can use a NULL path, which represents the default path
	// on the CreateProcess call
	if(PRV_GetKeyStringValue(hkeyApp, SZ_PATH, &lpwszTemp))
	{
		lpci->lpszPath = lpwszTemp;
	}
		
	// Get the string value for the File
	if(!PRV_GetKeyStringValue(hkeyApp, SZ_FILE, &lpwszTemp))
	{
		DPF_ERR("Error getting value for File key!");
		bReturn = FALSE;
		goto EXIT_GETCONNECTINFO;
	}
	
	lpci->lpszFile = lpwszTemp;

	// Get the string value for the CommandLine.  If this fails,
	// we can pass a NULL command line to the CreateProcess call
	if(PRV_GetKeyStringValue(hkeyApp, SZ_COMMANDLINE, &lpwszTemp))
	{
		lpci->lpszCommandLine = lpwszTemp;
	}
	
	// Get the string value for the AppLauncherName.  If this fails,
	// then we assume there is no launcher application.
	if(PRV_GetKeyStringValue(hkeyApp, SZ_LAUNCHER, &lpwszTemp))
	{
		lpci->lpszAppLauncherName = lpwszTemp;
	}

	// Get the string value for the CurrentDir.  If this fails, just
	// use the value returned by GetCurrentDirectory.
	if(!PRV_GetKeyStringValue(hkeyApp, SZ_CURRENTDIR, &lpwszTemp))
	{
		// Get the size of the string
		dwSize = OS_GetCurrentDirectory(0, NULL);
		if(!dwSize)
		{
			dwError = GetLastError();
			// WARNING: this last error value may not be correct in debug
			// since OS_GetCurrentDirectory may have called another function.
			DPF(0, "GetCurrentDirectory returned an error! dwError = %d", dwError);
			bReturn = FALSE;
			goto EXIT_GETCONNECTINFO;
		}

		lpwszTemp = DPMEM_ALLOC(dwSize * sizeof(WCHAR));
		if(!lpwszTemp)
		{
			DPF_ERR("Unable to allocate temporary string for CurrentDirectory!");
			bReturn = FALSE;
			goto EXIT_GETCONNECTINFO;
		}

		if(!OS_GetCurrentDirectory(dwSize, lpwszTemp))
		{
			DPF_ERR("Unable to get CurrentDirectory!");
			bReturn = FALSE;
			goto EXIT_GETCONNECTINFO;
		}
	}
	
	lpci->lpszCurrentDir = lpwszTemp;

	bReturn = TRUE;

EXIT_GETCONNECTINFO:

	// Free any string we allocated if we failed
	if(!bReturn)
		PRV_FreeConnectInfo(lpci);

	// Close the Apps key
	if(hkeyApp)
		RegCloseKey(hkeyApp);

	return bReturn;

} // PRV_GetConnectInfoFromRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateGameProcess"
HRESULT PRV_CreateGameProcess(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	STARTUPINFO			si;
	HRESULT				hr;
	LPWSTR				lpwszPathAndFile = NULL;
	LPWSTR				lpwszTemp = NULL;
	LPWSTR				lpwszCommandLine = NULL;
	LPWSTR              lpwszFileToRun;
	DWORD				dwPathSize,
						dwFileSize,
						dwCurrentDirSize,
						dwPathAndFileSize,
						dwCommandLineSize,
						dwIPCSwitchSize,
						dwError;
	

	DPF(7, "Entering PRV_CreateGameProcess");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpci, lppi);
	

	// Allocate enough memory for the Path, File, an additional backslash,
	// and the null termination
	// Note: the following two OS_StrLen calls with count the null terms
	// on the end of each string.  Since this comes to two characters
	// (4 bytes), this will account for our null terminator and the
	// possible additional backslash after concatenation.  Thus, the
	// size here is big enough for the concatenated string.
	dwPathSize = OS_StrLen(lpci->lpszPath);

	if(lpci->lpszAppLauncherName){
		// when launching with an applauncher, we need a GUID.
		OS_CreateGuid(&lpci->guidIPC);
		lpci->guidIPC.Data1 |= 0x10000000; // make life easy by having fully byte significant first dword.
		lpwszFileToRun = lpci->lpszAppLauncherName;
	} else {
		lpwszFileToRun = lpci->lpszFile;
	}	
		
	dwFileSize = OS_StrLen(lpwszFileToRun);
		
	dwPathAndFileSize = dwPathSize + dwFileSize;
	lpwszPathAndFile = DPMEM_ALLOC(dwPathAndFileSize * sizeof(WCHAR));
	if(!lpwszPathAndFile)
	{
		DPF_ERR("Couldn't allocate memory for temporary string!");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CREATE_GAME_PROCESS;
	}
	

	// Concatenate the path & file together
	if(dwPathSize)
	{
		memcpy(lpwszPathAndFile, lpci->lpszPath, (dwPathSize  * sizeof(WCHAR)));
		lpwszTemp = lpwszPathAndFile + dwPathSize - 1;

		// Only add a backslash if one doesn't already exists
		if(memcmp((lpwszTemp - 1), SZ_BACKSLASH, sizeof(WCHAR)))
			memcpy(lpwszTemp++, SZ_BACKSLASH, sizeof(WCHAR));
		else 
			// since we didn't add a backslash, the actual used
			// size is one WCHAR less than the full allocated size so
			// we need to reduce it so when we calculate the spot for
			// the command line we aren't after a NULL.
			dwPathAndFileSize--;
	}
	else
		lpwszTemp = lpwszPathAndFile;

	memcpy(lpwszTemp, lpwszFileToRun, (dwFileSize * sizeof(WCHAR)));


	// Allocate memory for temporary command line string
	// Note: Since the OS_StrLen function counts the null terminator,
	// we will be large enough to include the extra space when we
	// concatenate the two strings together.
	dwCommandLineSize = OS_StrLen(lpci->lpszCommandLine);

	if(lpci->lpszAppLauncherName){
		// leave space for GUID on the command line
		dwIPCSwitchSize = sizeof(SZ_DP_IPC_GUID SZ_GUID_PROTOTYPE)/sizeof(WCHAR);
	} else {
		dwIPCSwitchSize = 0;
	}
	
	lpwszCommandLine = DPMEM_ALLOC(((dwCommandLineSize + dwPathAndFileSize+dwIPCSwitchSize) *
								sizeof(WCHAR)));
	if(!lpwszCommandLine)
	{
		// REVIEW!!!! -- We should fix these error paths post-DX3
		DPF_ERR("Couldn't allocate memory for temporary command line string!");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CREATE_GAME_PROCESS;
	}

	// Concatenate the path & file string with the rest of the command line
	memcpy(lpwszCommandLine, lpwszPathAndFile, (dwPathAndFileSize *
			sizeof(WCHAR)));

	// Add the rest of the command line if it exists
	lpwszTemp = lpwszCommandLine + dwPathAndFileSize;
	if(dwCommandLineSize)
	{
		// First change the null terminator to a space
		lpwszTemp -= 1; 
		memcpy(lpwszTemp++, SZ_SPACE, sizeof(WCHAR));

		// Now copy in the command line
		memcpy(lpwszTemp, lpci->lpszCommandLine, (dwCommandLineSize *
				sizeof(WCHAR)));

	}
	
	if(dwIPCSwitchSize){
		// add switch with a GUID on the command line for IPC when
		// application is started by a launcher
		lpwszTemp += dwCommandLineSize-1;
		// change NULL terminator to a space
		memcpy(lpwszTemp++, SZ_SPACE, sizeof(WCHAR));
		// copy /dplay_ipc_guid: but skip the NULL
		memcpy(lpwszTemp, SZ_DP_IPC_GUID, sizeof(SZ_DP_IPC_GUID)-sizeof(WCHAR));
		lpwszTemp+=(sizeof(SZ_DP_IPC_GUID)-sizeof(WCHAR))/sizeof(WCHAR);
		// Copy the GUID directly into the target
		StringFromGUID(&lpci->guidIPC,lpwszTemp,GUID_STRING_SIZE);
	}

	// Make sure the CurrentDirectory string doesn't have a trailing backslash
	// (This will cause CreateProcess to not use the right directory)
	dwCurrentDirSize = OS_StrLen(lpci->lpszCurrentDir);
	if(dwCurrentDirSize > 2)
	{
		lpwszTemp = lpci->lpszCurrentDir + dwCurrentDirSize - 2;

		if(!(memcmp((lpwszTemp), SZ_BACKSLASH, sizeof(WCHAR))))
			memset(lpwszTemp, 0, sizeof(WCHAR));
	}

	// Create the game's process in a suspended state
	memset(&si, 0, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);

	if(!OS_CreateProcess(lpwszPathAndFile, lpwszCommandLine, NULL,
			NULL, FALSE, (CREATE_SUSPENDED | CREATE_DEFAULT_ERROR_MODE |
			CREATE_NEW_CONSOLE), NULL, lpci->lpszCurrentDir, &si, lppi))
	{
		dwError = GetLastError();
		// WARNING Last error produced here may not be correct since OS_CreateProcess 
		// may call out to other functions (like DPF) before returning.
		DPF_ERR("Couldn't create game process");
		DPF(0, "CreateProcess error = 0x%08x, (WARNING Error may not be correct)", dwError);
		hr = DPERR_CANTCREATEPROCESS;
		goto ERROR_CREATE_GAME_PROCESS;
	} 

	hr = DP_OK;

	// Fall through

ERROR_CREATE_GAME_PROCESS:

	if(lpwszPathAndFile)
		DPMEM_FREE(lpwszPathAndFile);
	if(lpwszCommandLine)
		DPMEM_FREE(lpwszCommandLine);
	return hr;

} // PRV_CreateGameProcess



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_IsAppInWaitMode"
BOOL PRV_IsAppInWaitMode(DWORD dwProcessID)
{
	DPLOBBYI_GAMENODE		gn;
	LPDPLOBBYI_CONNCONTROL	lpConnControl = NULL;
	SECURITY_ATTRIBUTES		sa;
	WCHAR					szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];
	HRESULT					hr;
	HANDLE					hFile = NULL;
	HANDLE					hMutex = NULL;
	BOOL					bReturn = FALSE;
	DWORD					dwError;


	DPF(7, "Entering PRV_IsAppInWaitMode");
	DPF(9, "Parameters: %lu", dwProcessID);

	// Setup a temporary gamenode structure
	memset(&gn, 0, sizeof(DPLOBBYI_GAMENODE));
	gn.dwFlags = GN_LOBBY_CLIENT;
	gn.dwGameProcessID = dwProcessID;
	
	// Get the name of the shared connection settings buffer
	hr = PRV_GetInternalName(&gn, TYPE_CONNECT_DATA_FILE, (LPWSTR)szName);
	if(FAILED(hr))
	{
		DPF(5, "Unable to get name for shared conn settings buffer");
		goto EXIT_ISAPPINWAITMODE;
	}

	// Map the file into our process
	hFile = OS_OpenFileMapping(FILE_MAP_ALL_ACCESS, TRUE, (LPWSTR)szName);
	if(!hFile)
	{
		dwError = GetLastError();
		// WARNING: Error may not be correct since OpenFileMapping calls out to other functions before returning.
		DPF(5, "Couldn't get a handle to the shared local memory, dwError = %lu (ERROR MAY NOT BE CORRECT)", dwError);
		goto EXIT_ISAPPINWAITMODE;
	}

	// Map a View of the file
	lpConnControl = MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if(!lpConnControl)
	{
		dwError = GetLastError();
		DPF(5, "Unable to get pointer to shared local memory, dwError = %lu", dwError);
		goto EXIT_ISAPPINWAITMODE;
	}

	// Get the name of the connection settings buffer mutex	
	hr = PRV_GetInternalName(&gn, TYPE_CONNECT_DATA_MUTEX, (LPWSTR)szName);
	if(FAILED(hr))
	{
		DPF(5, "Unable to get name for shared conn settings buffer mutex");
		goto EXIT_ISAPPINWAITMODE;
	}

	// Set up the security attributes (so that our objects can
	// be inheritable)
	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.bInheritHandle = TRUE;

	// Open the Mutex
	hMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)&szName);
	if(!hMutex)
	{
		DPF(5, "Unable to create shared conn settings buffer mutex");
		goto EXIT_ISAPPINWAITMODE;
	}

	// Now grab the mutex and see if the app is in wait mode (and
	// it is not in pending mode)
	WaitForSingleObject(hMutex, INFINITE);
	if((lpConnControl->dwFlags & BC_WAIT_MODE) &&
		!(lpConnControl->dwFlags & BC_PENDING_CONNECT))
	{
		// Put the app in pending mode
		lpConnControl->dwFlags |= BC_PENDING_CONNECT;

		// Set the return code to true
		bReturn = TRUE;
	}

	// Release the mutex
	ReleaseMutex(hMutex);

	// Fall through

EXIT_ISAPPINWAITMODE:

	if(lpConnControl)
		UnmapViewOfFile(lpConnControl);
	if(hFile)
		CloseHandle(hFile);
	if(hMutex)
		CloseHandle(hMutex);

	return bReturn;

} // PRV_IsAppInWaitMode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindRunningAppNT"

#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         _T("software\\microsoft\\windows nt\\currentversion\\perflib")
#define REGSUBKEY_COUNTERS  _T("Counters")
#define PROCESS_COUNTER     _T("process")
#define PROCESSID_COUNTER   _T("id process")


HRESULT PRV_FindRunningAppNT(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	HANDLE		hProcess = NULL;
	DWORD		dwProcessID = 0;
	DWORD		dwError;
	HRESULT		hr = -1;

    DWORD                        rc;
    HKEY                         hKeyNames;
    DWORD                        dwType;
    DWORD                        dwSize;
    LPBYTE                       buf = NULL;
    TCHAR                         szSubKey[1024];
    LANGID                       lid;
    LPTSTR                        p;
    LPTSTR                        p2;
	LPWSTR						nameStr;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle;
    DWORD                        dwProcessIdCounter;
    DWORD						dwNumTasks;

	INT							ccStrFind;
	INT							ccStrMatch;

	// on Whistler, the string to match in the process table has changed from
	// being the name of the process without the ".exe" at the end to being
	// the name of the process followed by an '_' and the processid, so we
	// build that string too to compare and accept either when finding the app.
    WCHAR						procString[64];//name concated with proc id for Whistler
    WCHAR						*procStringBaseNameEnd;
    INT							ccStrFindProcBased;

    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
    wsprintf( szSubKey, _T("%s\\%03x"), REGKEY_PERF, lid );
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );
    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (LPBYTE) DPMEM_ALLOC( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //

	// convert the string to ansi because we can't use _wtoi

    p = (LPTSTR) buf;
    while (*p) {
        if (p > (LPTSTR) buf) {
            for( p2=p-2; _istdigit(*p2); p2--) ;
        }
        if (_tcsicmp(p, PROCESS_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; _istdigit(*p2); p2--) ;
            _tcscpy( szSubKey, p2+1 );
        }
        else
        if (_tcsicmp(p, PROCESSID_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; _istdigit(*p2); p2--) ;
            dwProcessIdTitle = _ttoi( p2+1 );
        }
        //
        // next string
        //
        p += (_tcslen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    DPMEM_FREE( buf );


    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = DPMEM_ALLOC( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );


    while (TRUE) {

        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              buf,
                              &dwSize
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize > 0) &&
            (pPerf)->Signature[0] == (WCHAR)'P' &&
            (pPerf)->Signature[1] == (WCHAR)'E' &&
            (pPerf)->Signature[2] == (WCHAR)'R' &&
            (pPerf)->Signature[3] == (WCHAR)'F' ) {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) {
            dwSize += EXTEND_SIZE;
            buf = DPMEM_REALLOC( buf, dwSize );
            memset( buf, 0, dwSize );
        }
        else {
            goto exit;
        }
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((DWORD_PTR)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //
    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD_PTR)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

    dwNumTasks = (DWORD)pObj->NumInstances;

    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pObj + pObj->DefinitionLength);

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //

	ccStrFind=(WSTRLEN(lpci->lpszFile)-1)-4; // don't include .exe in compare

	if(ccStrFind > 15){
		ccStrFind=15;
	}

	wcsncpy(procString, lpci->lpszFile, ccStrFind);
	procString[ccStrFind]=L'_';
	procStringBaseNameEnd=&procString[ccStrFind+1];
    
    for (i=0; i<dwNumTasks; i++) {
        //
        // pointer to the process name
        //

		nameStr = (LPWSTR) ((DWORD_PTR)pInst + pInst->NameOffset);

 		pCounter = (PPERF_COUNTER_BLOCK) ((DWORD_PTR)pInst + pInst->ByteLength);

		// Compare the process name with the executable name we are
		// looking for
		dwProcessID = *((LPDWORD) ((DWORD_PTR)pCounter + dwProcessIdCounter));

		// tack processid onto end of base name to test on Whistler
		_itow(dwProcessID, procStringBaseNameEnd, 10);
		ccStrFindProcBased=WSTRLEN(procString)-1;
	
		ccStrMatch=WSTRLEN(nameStr)-1; // 1 for NULL
		if(ccStrMatch == 16){ // when it is 16, it included a trailing . so strip it.
			ccStrMatch--;
		}
		
		if((CSTR_EQUAL == OS_CompareString(LOCALE_SYSTEM_DEFAULT,
			NORM_IGNORECASE, nameStr, ccStrMatch, lpci->lpszFile, ccStrFind)) ||
		  (CSTR_EQUAL == OS_CompareString(LOCALE_SYSTEM_DEFAULT,
			NORM_IGNORECASE, nameStr, ccStrMatch, procString, ccStrFindProcBased)) 
		)
		{
			// See if the process is in wait mode
			if(PRV_IsAppInWaitMode(dwProcessID))
			{
				hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);
				if(!hProcess)
				{
					dwError = GetLastError();
					DPF_ERRVAL("Unable to open running process, dwError = %lu", dwError);
					goto exit;
				}
				else
				{
					// Save off the stuff we need
					lppi->dwProcessId = dwProcessID;
					lppi->hProcess = hProcess;
					hr = DP_OK;
					goto exit;
				}
			} // IsAppInWaitMode
		} // Are Filenames Equal
		
		//
        // next process
        //
        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pCounter + pCounter->ByteLength);
    }

exit:
    if (buf) {
        DPMEM_FREE( buf );
    }

    RegCloseKey( hKeyNames );
    RegCloseKey( HKEY_PERFORMANCE_DATA );


	return hr;
} // PRV_FindAppRunningNT

// If you build with the UNICODE flag set, the headers will redefine PROCESSENTRY32
// to be PROCESSENTRY32W. Unfortunately, passing PROCESSENTRY32W to Win9x functions
// will cause them to fail (because of the embedded Unicode string).
//
// Fix is to define our own PROCESSENTRY32A which is guaranteed to have an ANSI
// embedded string which Win9x will always accept.

typedef struct tagPROCESSENTRY32 PROCESSENTRY32A;
typedef PROCESSENTRY32A	*LPPROCESSENTRY32A;

#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindRunningAppWin9x"
HRESULT PRV_FindRunningAppWin9x(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	HANDLE			hSnapShot = NULL;
	PROCESSENTRY32A	procentry;
	BOOL			bFlag;
	HRESULT			hr = DPERR_UNAVAILABLE;
	LPBYTE			lpbTemp = NULL;
	DWORD			dwStrSize;
	LPWSTR			lpszFile = NULL;
	HANDLE			hProcess = NULL;
	DWORD			dwError;
	HANDLE			hInstLib = NULL;
	HRESULT			hrTemp;

	// ToolHelp Function Pointers.
	HANDLE (WINAPI *lpfCreateToolhelp32Snapshot)(DWORD,DWORD);
	BOOL (WINAPI *lpfProcess32First)(HANDLE,LPPROCESSENTRY32A);
	BOOL (WINAPI *lpfProcess32Next)(HANDLE,LPPROCESSENTRY32A);
	  

	DPF(7, "Entering PRV_FindRunningAppWin9x");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpci, lppi);

	// Load library and get the procedures explicitly. We do
	// this so that we can load the entry points dynamically,
	// which allows us to build correctly under WinNT even
	// though the NT kernel32 doesn't have these entry points
	hInstLib = LoadLibraryA( "Kernel32.DLL" );
	if(hInstLib == NULL)
	{
		DPF_ERR("Unable to load Kernel32.DLL");
		goto EXIT_FIND_RUNNING_APP_WIN9X;
	}

	// Get procedure addresses.
	// We are linking to these functions of Kernel32
	// explicitly, because otherwise a module using
	// this code would fail to load under Windows NT,
	// which does not have the Toolhelp32
	// functions in the Kernel 32.
	lpfCreateToolhelp32Snapshot=(HANDLE(WINAPI *)(DWORD,DWORD)) GetProcAddress( hInstLib, "CreateToolhelp32Snapshot" );
	lpfProcess32First=(BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32A))	GetProcAddress( hInstLib, "Process32First" );
	lpfProcess32Next=(BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32A)) GetProcAddress( hInstLib, "Process32Next" );
	if( lpfProcess32Next == NULL || lpfProcess32First == NULL || lpfCreateToolhelp32Snapshot == NULL )
	{
		DPF_ERR("Unable to get needed entry points in PSAPI.DLL");
		goto EXIT_FIND_RUNNING_APP_WIN9X;
	}

	// Get a handle to a Toolhelp snapshot of the systems processes. 
	hSnapShot = lpfCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if(hSnapShot == INVALID_HANDLE_VALUE)
	{
		DPF_ERR("Unable to get snapshot of system processes");
		goto EXIT_FIND_RUNNING_APP_WIN9X;
	}
	
	// Get the first process' information.
	procentry.dwSize = sizeof(PROCESSENTRY32A);
	bFlag = lpfProcess32First(hSnapShot, &procentry);

	// While there are processes, keep looping.
	while(bFlag)
	{
		// Walk the path and filename string (guaranteed to be ANSI)
		// looking for the final backslash (\).  Once we find it,
		// convert the filename to Unicode so we can compare it.
		dwStrSize = lstrlenA((LPBYTE)procentry.szExeFile);
		lpbTemp = (LPBYTE)procentry.szExeFile + dwStrSize - 1;
		while(--dwStrSize)
		{
			if(lpbTemp[0] == '\\')
			{
				lpbTemp++;
				break;
			}
			else
				lpbTemp--;
		}
		
		hrTemp = GetWideStringFromAnsi(&lpszFile, (LPSTR)lpbTemp);
		if(FAILED(hrTemp))
		{
			DPF_ERR("Failed making temporary copy of filename string");
			goto EXIT_FIND_RUNNING_APP_WIN9X;
		}
		
		// Compare the process name with the executable name we are
		// looking for
		if(CSTR_EQUAL == OS_CompareString(LOCALE_SYSTEM_DEFAULT,
			NORM_IGNORECASE, lpszFile, -1, lpci->lpszFile, -1))
		{
			// See if the process is in wait mode
			if(PRV_IsAppInWaitMode(procentry.th32ProcessID))
			{
				// Open the process since Windows9x doesn't do
				// it for us.
				hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procentry.th32ProcessID);
				if(!hProcess)
				{
					dwError = GetLastError();
					DPF_ERRVAL("Unable to open running process, dwError = %lu", dwError);
					bFlag = FALSE;
				}
				else
				{
					// Save off the stuff we need
					lppi->dwProcessId = procentry.th32ProcessID;
					lppi->hProcess = hProcess;
					hr = DP_OK;
					bFlag = FALSE;
				}

			} // IsAppInWaitMode
		} // Are Filenames Equal

		// Free our temporary string
		DPMEM_FREE(lpszFile);

		// If we haven't found it, and we didn't error, then move to
		// the next process
		if(bFlag)
		{
			// Move to the next process
			procentry.dwSize = sizeof(PROCESSENTRY32A);
			bFlag = lpfProcess32Next(hSnapShot, &procentry);
		}
	}
		

EXIT_FIND_RUNNING_APP_WIN9X:

	if(hSnapShot)
		CloseHandle(hSnapShot);
	if(hInstLib)
		FreeLibrary(hInstLib) ;

	return hr;

} // PRV_FindRunningAppWin9x



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindRunningApp"
HRESULT PRV_FindRunningApp(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	OSVERSIONINFOA	ver;
	HRESULT			hr = DPERR_UNAVAILABLE;


	DPF(7, "Entering PRV_FindRunningApp");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpci, lppi);

	ASSERT(lpci);
	ASSERT(lppi);


	// Clear our structure since it's on the stack
	memset(&ver, 0, sizeof(OSVERSIONINFOA));
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	// Figure out which platform we are running on and
	// call the appropriate process enumerating function
	if(!GetVersionExA(&ver))
	{
		DPF_ERR("Unable to determinte platform -- not looking for running app");
		return DPERR_UNAVAILABLE;
	}

	switch(ver.dwPlatformId)
	{
		case VER_PLATFORM_WIN32_NT:
		case VER_PLATFORM_WIN32_WINDOWS:
			// Call the Win9x version of FindRunningApp
			hr = PRV_FindRunningAppWin9x(lpci, lppi);
			break;
#if 0
		case VER_PLATFORM_WIN32_NT:
			hr = PRV_FindRunningAppNT(lpci, lppi);
			break;
#endif
		default:
			DPF_ERR("Unable to determinte platform -- not looking for running app");
			hr = DPERR_UNAVAILABLE;
			break;
	}

	return hr;

} // PRV_FindRunningApp



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RunApplication"
HRESULT DPLAPI DPL_RunApplication(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
							LPDWORD lpdwGameID, LPDPLCONNECTION lpConn,
							HANDLE hReceiveEvent)
{
    LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;
	PROCESS_INFORMATION		pi;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
	CONNECTINFO				ci;
	HANDLE					hDupReceiveEvent = NULL;
	HANDLE					hReceiveThread = NULL;
	HANDLE					hTerminateThread = NULL;
	HANDLE					hKillReceiveThreadEvent = NULL;
	HANDLE					hKillTermThreadEvent = NULL;
	DWORD					dwThreadID;
	BOOL					bCreatedProcess = FALSE;
	GUID					*lpguidIPC = NULL;

	DPF(7, "Entering DPL_RunApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpdwGameID, lpConn, hReceiveEvent);

    ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
        
		// Validate the DPLCONNECTION structure and it's members
		hr = PRV_ValidateDPLCONNECTION(lpConn, FALSE);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			return hr;
		}

		if( !VALID_DWORD_PTR( lpdwGameID ) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}
	
		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDFLAGS;
		}

		// Validate the handle
		if(hReceiveEvent)
		{
			if(!OS_IsValidHandle(hReceiveEvent))
			{
				LEAVE_DPLOBBY();
				DPF_ERR("Invalid hReceiveEvent handle");
				return DPERR_INVALIDPARAMS;
			}
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Clear the CONNECTINFO structure since it's on the stack
	memset(&ci, 0, sizeof(CONNECTINFO)); 

	// Get the guid of the game we want to launch
	if(lpConn && lpConn->lpSessionDesc)
		ci.guidApplication = lpConn->lpSessionDesc->guidApplication;
	else
	{
		LEAVE_DPLOBBY();
		return DPERR_UNKNOWNAPPLICATION;
	}

	// Get the information out the registry based on the GUID
	if(!PRV_GetConnectInfoFromRegistry(&ci))
	{
		LEAVE_DPLOBBY();
		return DPERR_UNKNOWNAPPLICATION;
	}

	// Clear the PROCESS_INFORMATION structure since it's on the stack
	memset(&pi, 0, sizeof(PROCESS_INFORMATION)); 

	// Look to see if this game is already running AND is in wait mode
	// waiting for new connection settings.  If it is, we want to 
	// send the connection settings to it.
	hr = PRV_FindRunningApp(&ci, &pi);
	if(FAILED(hr))
	{
		// It isn't waiting, so create the game's process & suspend it
		hr = PRV_CreateGameProcess(&ci, &pi);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			return hr;
		}
		if(!(IsEqualGUID(&ci.guidIPC,&GUID_NULL))){
			lpguidIPC=&ci.guidIPC;
		}
		// Set our created flag
		bCreatedProcess = TRUE;
	}

	// Create a game node
	hr = PRV_AddNewGameNode(this, &lpgn, pi.dwProcessId,
							pi.hProcess, TRUE, lpguidIPC);
	if(FAILED(hr))
	{
		DPF_ERR("Couldn't create new game node");
		goto RUN_APP_ERROR_EXIT;
	}

	// If the ConnectionSettings are from a StartSession message (lobby launched),
	// we need to set the flag
	if(lpConn->lpSessionDesc->dwReserved1)
	{
		// Set the flag that says we were lobby client launched
		lpgn->dwFlags |= GN_CLIENT_LAUNCHED;
	}

	// Write the connection settings in the shared memory buffer
	hr = PRV_WriteConnectionSettings(lpgn, lpConn, TRUE);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to write the connection settings!");
		goto RUN_APP_ERROR_EXIT;
	}

	// Send the app a message that the new connection settings are available
	// but only if we've sent the settings to a running app
	if(!bCreatedProcess)
		PRV_SendStandardSystemMessage(lpDPL, DPLSYS_NEWCONNECTIONSETTINGS, pi.dwProcessId);

	// Duplicate the Receive Event handle to use a signal to the
	// lobby client that the game has sent game settings to it.
	if(hReceiveEvent)
	{
		hDupReceiveEvent = PRV_DuplicateHandle(hReceiveEvent);
		if(!hDupReceiveEvent)
		{
			DPF_ERR("Unable to duplicate ReceiveEvent handle");
			hr = DPERR_OUTOFMEMORY;
			goto RUN_APP_ERROR_EXIT;
		}
	}

	lpgn->hDupReceiveEvent = hDupReceiveEvent;

	// Create the kill thread event for the monitor thread
	hKillTermThreadEvent = OS_CreateEvent(NULL, FALSE, FALSE, NULL);

	if(!hKillTermThreadEvent)
	{
		DPF_ERR("Unable to create kill thread event");
		hr = DPERR_OUTOFMEMORY;
		goto RUN_APP_ERROR_EXIT;
	}

	lpgn->hKillTermThreadEvent = hKillTermThreadEvent;

	// Spawn off a terminate monitor thread
	hTerminateThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)
						PRV_ClientTerminateNotification, lpgn, 0, &dwThreadID);

	if(!hTerminateThread)
	{
		DPF_ERR("Unable to create Terminate Monitor Thread!");
		hr = DPERR_OUTOFMEMORY;
		goto RUN_APP_ERROR_EXIT;
	}

	lpgn->hTerminateThread = hTerminateThread;

	// Resume the game's process & let it run, then
	// free the thread handle since we won't use it anymore
	if(bCreatedProcess)
	{
		ResumeThread(pi.hThread);
		CloseHandle(pi.hThread);
	}

	// Set the output pointer
	*lpdwGameID = pi.dwProcessId;

	// Free the strings in the connect info struct
	PRV_FreeConnectInfo(&ci);

	LEAVE_DPLOBBY();
	return DP_OK;

RUN_APP_ERROR_EXIT:

		if(pi.hThread && bCreatedProcess)
			CloseHandle(pi.hThread);
		if(bCreatedProcess && pi.hProcess)
			TerminateProcess(pi.hProcess, 0L);
		if(lpgn)
			PRV_RemoveGameNodeFromList(lpgn);
		PRV_FreeConnectInfo(&ci);

		LEAVE_DPLOBBY();
		return hr;

} // DPL_RunApplication
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplobby.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobby.c
 *  Content:	Methods for lobby management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	10/23/96	myronth	Added client/server methods
 *	1/2/97		myronth	Added wrappers for CreateAddress and EnumAddress
 *	2/12/97		myronth	Mass DX5 changes
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	4/3/97		myronth	Fixed interface pointer casts for CreateAddress and
 *						EnumAddress
 *	4/10/97		myronth	Added support for GetCaps
 *	5/8/97		myronth	Drop lobby lock when calling LP
 *	11/13/97	myronth	Added functions for asynchronous Connect (#12541)
 *	12/2/97		myronth	Added Register/UnregisterApplication
 *	12/4/97		myronth	Added ConnectEx
 *  10/22/99	aarono  added support for application flags
 *  12/13/99	pnewson bugs #123583, 123601, 123604 - support to launch dpvhelp.exe on 
 *						apps that are not registered or badly registered
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Connect"
HRESULT DPLAPI DPL_Connect(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					LPDIRECTPLAY2 * lplpDP2, IUnknown FAR * lpUnk)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_Connect");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lplpDP2, lpUnk);

	ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if( !VALID_WRITE_PTR( lplpDP2, sizeof(LPDIRECTPLAY2 *)) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}

		if( lpUnk != NULL )
		{
			LEAVE_DPLOBBY();
			return CLASS_E_NOAGGREGATION;
		}

		if(!VALID_CONNECT_FLAGS(dwFlags))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_DPLOBBY();
		return DPERR_INVALIDPARAMS;
	}


	// Call the ConnectMe function which resides in the DPlay project
	hr = ConnectMe(lpDPL, lplpDP2, lpUnk, dwFlags);


	LEAVE_DPLOBBY();
	return hr;

} // DPL_Connect



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ConnectEx"
HRESULT DPLAPI DPL_ConnectEx(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
				REFIID riid, LPVOID * ppvObj, IUnknown FAR * lpUnk)
{
	LPDIRECTPLAY2		lpDP2 = NULL;
	HRESULT				hr;


	DPF(7, "Entering DPL_ConnectEx");
	DPF(9, "Parameters: 0x%08x, 0x%08x, iid, 0x%08x, 0x%08x",
			lpDPL, dwFlags, ppvObj, lpUnk);


	// Call the ConnectMe function which resides in the DPlay project
	hr = DPL_Connect(lpDPL, dwFlags, &lpDP2, lpUnk);
	if(SUCCEEDED(hr))
	{
		hr = DP_QueryInterface((LPDIRECTPLAY)lpDP2, riid, ppvObj);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling QueryInterface, hr = 0x%08x", hr);
		}

		// Release the DP2 object
		DP_Release((LPDIRECTPLAY)lpDP2);
	}

	return hr;

} // DPL_ConnectEx



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SaveConnectPointers"
void PRV_SaveConnectPointers(LPDIRECTPLAYLOBBY lpDPL,
		LPDIRECTPLAY2 lpDP2, LPDPLCONNECTION lpConn)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_SaveConnectPointers");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lpDP2, lpConn);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
		return;
#endif

	// Save the pointers
	this->lpDP2 = lpDP2;
	this->lpConn = lpConn;

} // PRV_SaveConnectPointers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetConnectPointers"
BOOL PRV_GetConnectPointers(LPDIRECTPLAYLOBBY lpDPL,
		LPDIRECTPLAY2 * lplpDP2, LPDPLCONNECTION * lplpConn)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_GetConnectPointers");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lplpDP2, lplpConn);


	ASSERT(lplpDP2);
	ASSERT(lplpConn);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
		return FALSE;
#endif

	// See if we have the pointers
	if((!this->lpDP2) || (!this->lpConn))
		return FALSE;

	// Set the output pointers
	*lplpDP2 = this->lpDP2;
	*lplpConn = this->lpConn;
	return TRUE;

} // PRV_GetConnectPointers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_IsAsyncConnectOn"
BOOL PRV_IsAsyncConnectOn(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_IsAsyncConnectOn");
	DPF(9, "Parameters: 0x%08x", lpDPL);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
		return FALSE;
#endif

	// Check the flag
	if(this->dwFlags & DPLOBBYPR_ASYNCCONNECT)
		return TRUE;
	else
		return FALSE;

} // PRV_IsAsyncConnectOn



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_TurnAsyncConnectOn"
void PRV_TurnAsyncConnectOn(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_TurnAsyncConnectOn");
	DPF(9, "Parameters: 0x%08x", lpDPL);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
	{
		ASSERT(FALSE);
		return;
	}
#endif

	// Set the flag
	this->dwFlags |= DPLOBBYPR_ASYNCCONNECT;

} // PRV_TurnAsyncConnectOn



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_TurnAsyncConnectOff"
void PRV_TurnAsyncConnectOff(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_TurnAsyncConnectOff");
	DPF(9, "Parameters: 0x%08x", lpDPL);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
	{
		ASSERT(FALSE);
		return;
	}
#endif

	// Clear the flag
	this->dwFlags &= (~DPLOBBYPR_ASYNCCONNECT);

} // PRV_TurnAsyncConnectOff



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_CreateAddress"
HRESULT DPLAPI DPL_CreateAddress(LPDIRECTPLAYLOBBY lpDPL,
					REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
					LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_CreateAddress");
	DPF(9, "Parameters: 0x%08x, guid, guid, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpDPL, lpData, dwDataSize, lpAddress, lpdwAddressSize);

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			return DPERR_INVALIDOBJECT;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// Call the CreateAddress function which resides in the DPlay project
	hr = InternalCreateAddress((LPDIRECTPLAYSP)lpDPL, lpguidSP, lpguidDataType, lpData,
							dwDataSize, lpAddress, lpdwAddressSize);

	return hr;

} // DPL_CreateCompoundAddress

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_CreateCompoundAddress"

HRESULT DPLAPI DPL_CreateCompoundAddress(LPDIRECTPLAYLOBBY lpDPL,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_CreateCompoundAddress");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpDPL, lpAddressElements, dwAddressElementCount, lpAddress, lpdwAddressSize);

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			return DPERR_INVALIDOBJECT;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// Call the CreateCompoundAddress function which resides in the DPlay project
	hr = InternalCreateCompoundAddress(lpAddressElements, dwAddressElementCount,
									   lpAddress, lpdwAddressSize);
	return hr;

} // DPL_CreateCompoundAddress


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumAddress"
HRESULT DPLAPI DPL_EnumAddress(LPDIRECTPLAYLOBBY lpDPL,
					LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress,
					DWORD dwAddressSize, LPVOID lpContext)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_EnumAddress");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x",
			lpDPL, lpEnumCallback, lpAddress, dwAddressSize, lpContext);

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			return DPERR_INVALIDOBJECT;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// Call the CreateAddress function which resides in the DPlay project
	hr = InternalEnumAddress((LPDIRECTPLAYSP)lpDPL, lpEnumCallback, lpAddress,
							dwAddressSize, lpContext);

	return hr;

} // DPL_EnumAddress



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetCaps"
HRESULT DPLAPI PRV_GetCaps(LPDPLOBBYI_DPLOBJECT this, DWORD dwFlags,
				LPDPCAPS lpcaps)
{
	SPDATA_GETCAPS		gcd;
	HRESULT				hr = DP_OK;


	DPF(7, "Entering PRV_GetCaps");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x", this, dwFlags, lpcaps);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// Setup our SPDATA struct
	memset(&gcd, 0, sizeof(SPDATA_GETCAPS));
	gcd.dwSize = sizeof(SPDATA_GETCAPS);
	gcd.dwFlags = dwFlags;
	gcd.lpcaps = lpcaps;

	// Call the GetCaps method in the LP
	if(CALLBACK_EXISTS(GetCaps))
	{
		gcd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetCaps, &gcd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetCaps is required
		DPF_ERR("The Lobby Provider callback for GetCaps doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF(2, "Failed calling GetCaps in the Lobby Provider, hr = 0x%08x", hr);
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetCaps



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteAppKeyFromRegistry"
HRESULT PRV_DeleteAppKeyFromRegistry(LPGUID lpguid)
{
	LPWSTR		lpwszAppName = NULL;
	HKEY		hkeyApp, hkeyDPApps = NULL;
	HRESULT		hr;
	LONG		lReturn;


	DPF(7, "Entering PRV_DeleteAppKeyFromRegistry");
	DPF(9, "Parameters: 0x%08x", lpguid);


	// Allocate memory for the App Name
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN);
	if(!lpwszAppName)
	{
		DPF_ERR("Unable to allocate memory for App Name!");
		return DPERR_OUTOFMEMORY;
	}
	
	// Open the registry key for the App
	if(!PRV_FindGameInRegistry(lpguid, lpwszAppName,
				DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		DPF_ERR("Unable to find game in registry!");
		hr = DPERR_UNKNOWNAPPLICATION;
		goto EXIT_DELETEAPPKEY;
	}

	// Close the app key
	RegCloseKey(hkeyApp);

 	// Open the Applications key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0,
								KEY_READ, &hkeyDPApps);
	if(lReturn != ERROR_SUCCESS)
	{
		// If we can't open it, we assume it doesn't exist, so
		// we'll call it a success.
		hr = DP_OK;
		goto EXIT_DELETEAPPKEY;
	}

	// Now delete the key
	hr = OS_RegDeleteKey(hkeyDPApps, lpwszAppName);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to delete app key, hr = 0x%08x", hr);
		goto EXIT_DELETEAPPKEY;
	}

EXIT_DELETEAPPKEY:

	// Free our string memory
	if(lpwszAppName)
		DPMEM_FREE(lpwszAppName);
	
	// Close the DP Applications key
	if(hkeyDPApps)
		RegCloseKey(hkeyDPApps);

	return hr;

} // PRV_DeleteAppKeyFromRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteAppDescInRegistryAnsi"
HRESULT PRV_WriteAppDescInRegistryAnsi(LPDPAPPLICATIONDESC lpDesc)
{
	HKEY	hkeyDPApps = NULL, hkeyApp = NULL;
	LONG	lReturn;
	DWORD	dwDisposition;
	WCHAR	wszGuid[GUID_STRING_SIZE];
	CHAR	szGuid[GUID_STRING_SIZE];
	LPWSTR   lpwszAppName = NULL;
	HRESULT	hr;
	LPDPAPPLICATIONDESC2 lpDesc2=(LPDPAPPLICATIONDESC2)lpDesc;
	DWORD   dwRegFlags;
	DWORD   dwRegFlagsSize;
	DWORD   dwType;

	DPF(7, "Entering PRV_WriteAppDescInRegistryAnsi");
	DPF(9, "Parameters: 0x%08x", lpDesc);

	// Open the registry key for the App, if it exists, so we can
	// check for the autovoice flag
	DPF(5, "Checking to see if game already present in registry");
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN*sizeof(WCHAR));
	if (lpwszAppName == NULL)
	{
		DPF_ERR("Unable to allocate memory");
		hr = DPERR_NOMEMORY;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}
	if(PRV_FindGameInRegistry(&(lpDesc->guidApplication), lpwszAppName,
				DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		// Get the application flags
		DPF(5, "Game already registered");
		dwRegFlags = 0;
		dwRegFlagsSize = sizeof(dwRegFlags);
		dwType = 0;		
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_DWFLAGS, NULL, &dwType, (CHAR *)&dwRegFlags, &dwRegFlagsSize);
		if(lReturn == ERROR_SUCCESS)
		{
			// This application is already registered. We want to maintain the state
			// of the autovoice flag despite this re-registration, so set the appropriate
			// bit of lpDesc->dwFlags to the correct value.
			DPF(5, "Current Game flags: 0x%08x", dwRegFlags);
			if (dwRegFlags & DPLAPP_AUTOVOICE)
			{
				DPF(5, "Forcing DPLAPP_AUTOVOICE flag ON", dwRegFlags);
				lpDesc->dwFlags |= DPLAPP_AUTOVOICE;
			}
			else
			{
				DPF(5, "Forcing DPLAPP_AUTOVOICE flag OFF", dwRegFlags);
				lpDesc->dwFlags &= (~DPLAPP_AUTOVOICE);
			}
		}

		// Close the app key
		RegCloseKey(hkeyApp);
	}
	DPMEM_FREE(lpwszAppName);
	lpwszAppName = NULL;

	// Delete the application key if it exists
	hr = PRV_DeleteAppKeyFromRegistry(&lpDesc->guidApplication);

 	// Open the Applications key (or create it if it doesn't exist
	lReturn = OS_RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0, NULL,
				REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDPApps,
				&dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to open DPlay Applications registry key!, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Create the app's key
	lReturn = RegCreateKeyExA(hkeyDPApps, lpDesc->lpszApplicationNameA,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
				&hkeyApp, &dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to create application registry key, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the guid value
	hr = StringFromGUID(&lpDesc->guidApplication, wszGuid, sizeof(wszGuid));
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert application guid to string, hr = 0x%08x", hr);
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}
	
	WideToAnsi(szGuid, wszGuid, WSTRLEN_BYTES(wszGuid));
	
	lReturn = OS_RegSetValueEx(hkeyApp, SZ_GUID, 0, REG_SZ,
				(LPBYTE)szGuid, lstrlenA(szGuid));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Application guid, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the Filename value
	ASSERT(lpDesc->lpszFilenameA);
	lReturn = OS_RegSetValueEx(hkeyApp, SZ_FILE, 0, REG_SZ,
				lpDesc->lpszFilenameA, lstrlenA(lpDesc->lpszFilenameA));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Filename string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the CommandLine value (optional)
	if(lpDesc->lpszCommandLineA)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_COMMANDLINE, 0, REG_SZ,
			lpDesc->lpszCommandLineA, lstrlenA(lpDesc->lpszCommandLineA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CommandLine string, lReturn = %lu", lReturn);
		}
	}

	// Set the Path value
	ASSERT(lpDesc->lpszPathA);
	lReturn = OS_RegSetValueEx(hkeyApp, SZ_PATH, 0, REG_SZ,
				lpDesc->lpszPathA, lstrlenA(lpDesc->lpszPathA));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Path string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the CurrentDirectory value (optional)
	if(lpDesc->lpszCurrentDirectoryA)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_CURRENTDIR, 0, REG_SZ,
			lpDesc->lpszCurrentDirectoryA, lstrlenA(lpDesc->lpszCurrentDirectoryA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CurrentDirectory string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionA value (optional)
	if(lpDesc->lpszDescriptionA)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_DESCRIPTIONA, 0, REG_SZ,
			lpDesc->lpszDescriptionA, lstrlenA(lpDesc->lpszDescriptionA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionA string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionW value (optional)
	if(lpDesc->lpszDescriptionW)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_DESCRIPTIONW, 0, REG_BINARY,
				(BYTE *)lpDesc->lpszDescriptionW,
				WSTRLEN_BYTES(lpDesc->lpszDescriptionW));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionW string, lReturn = %lu", lReturn);
		}
	}

	if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc) && lpDesc2->lpszAppLauncherNameA){
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_LAUNCHER, 0, REG_SZ,
			lpDesc2->lpszAppLauncherNameA, lstrlenA(lpDesc2->lpszAppLauncherNameA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register LauncherA string, lReturn = %lu", lReturn);
		}
	}

	// set the dwFlags field
	lReturn=OS_RegSetValueEx(hkeyApp, SZ_DWFLAGS, 0, REG_DWORD, (CHAR *)&lpDesc->dwFlags,sizeof(DWORD));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to write dwFlags field to registry, lReturn= %lu", lReturn);
	}

	// Close the two keys
	RegCloseKey(hkeyDPApps);
	RegCloseKey(hkeyApp);

	return DP_OK;

ERROR_WRITEAPPINREGISTRYANSI:

	if(hkeyApp)
	{
		// Delete the key
		// REVIEW!!!! -- TODO

		// Now close the key
		RegCloseKey(hkeyApp);
	}

	if(hkeyDPApps)
		RegCloseKey(hkeyDPApps);

	return hr;

} // PRV_WriteAppDescInRegistryAnsi



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteAppDescInRegistryUnicode"
HRESULT PRV_WriteAppDescInRegistryUnicode(LPDPAPPLICATIONDESC lpDesc)
{
	HKEY	hkeyDPApps = NULL, hkeyApp = NULL;
	LONG	lReturn;
	DWORD	dwDisposition;
	WCHAR	wszGuid[GUID_STRING_SIZE];
	HRESULT	hr;
	LPWSTR  lpwszAppName = NULL;
	LPDPAPPLICATIONDESC2 lpDesc2=(LPDPAPPLICATIONDESC2)lpDesc;
	DWORD   dwRegFlags;
	DWORD   dwRegFlagsSize;
	DWORD   dwType;

	DPF(7, "Entering PRV_WriteAppDescInRegistryUnicode");
	DPF(9, "Parameters: 0x%08x", lpDesc);

	// Open the registry key for the App, if it exists, so we can
	// check for the autovoice flag
	DPF(5, "Checking to see if game already present in registry");
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN*sizeof(WCHAR));
	if (lpwszAppName == NULL)
	{
		DPF_ERR("Unable to allocate memory");
		hr = DPERR_NOMEMORY;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}
	if(PRV_FindGameInRegistry(&(lpDesc->guidApplication), lpwszAppName,
				DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		// Get the application flags
		DPF(5, "Game already registered");
		dwRegFlags = 0;
		dwRegFlagsSize = sizeof(dwRegFlags);
		dwType = 0;		
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_DWFLAGS, NULL, &dwType, (CHAR *)&dwRegFlags, &dwRegFlagsSize);
		if(lReturn == ERROR_SUCCESS)
		{
			// This application is already registered. We want to maintain the state
			// of the autovoice flag despite this re-registration, so set the appropriate
			// bit of lpDesc->dwFlags to the correct value.
			DPF(5, "Current Game flags: 0x%08x", dwRegFlags);
			if (dwRegFlags & DPLAPP_AUTOVOICE)
			{
				DPF(5, "Forcing DPLAPP_AUTOVOICE flag ON", dwRegFlags);
				lpDesc->dwFlags |= DPLAPP_AUTOVOICE;
			}
			else
			{
				DPF(5, "Forcing DPLAPP_AUTOVOICE flag OFF", dwRegFlags);
				lpDesc->dwFlags &= (~DPLAPP_AUTOVOICE);
			}
		}

		// Close the app key
		RegCloseKey(hkeyApp);
	}
	DPMEM_FREE(lpwszAppName);
	lpwszAppName = NULL;

	// Delete the application key if it exists
	hr = PRV_DeleteAppKeyFromRegistry(&lpDesc->guidApplication);

 	// Open the Applications key (or create it if it doesn't exist
	lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0, NULL,
				REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDPApps,
				&dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to open DPlay Applications registry key!, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Create the app's key
	lReturn = RegCreateKeyEx(hkeyDPApps, lpDesc->lpszApplicationName,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
				&hkeyApp, &dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to create application registry key, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the guid value
	hr = StringFromGUID(&lpDesc->guidApplication, wszGuid, sizeof(wszGuid));
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert application guid to string, hr = 0x%08x", hr);
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}
	
	lReturn = RegSetValueEx(hkeyApp, SZ_GUID, 0, REG_SZ, (BYTE *)wszGuid,
				WSTRLEN_BYTES(wszGuid));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Application guid, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the Filename value
	ASSERT(lpDesc->lpszFilename);
	lReturn = RegSetValueEx(hkeyApp, SZ_FILE, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszFilename, WSTRLEN_BYTES(lpDesc->lpszFilename));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Filename string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the CommandLine value (optional)
	if(lpDesc->lpszCommandLine)
	{
		lReturn = RegSetValueEx(hkeyApp, SZ_COMMANDLINE, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszCommandLine,
				WSTRLEN_BYTES(lpDesc->lpszCommandLine));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CommandLine string, lReturn = %lu", lReturn);
		}
	}

	// Set the Path value
	ASSERT(lpDesc->lpszPath);
	lReturn = RegSetValueEx(hkeyApp, SZ_PATH, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszPath, WSTRLEN_BYTES(lpDesc->lpszPath));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Path string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the CurrentDirectory value (optional)
	if(lpDesc->lpszCurrentDirectory)
	{
		lReturn = RegSetValueEx(hkeyApp, SZ_CURRENTDIR, 0, REG_SZ,
					(LPBYTE)lpDesc->lpszCurrentDirectory,
					WSTRLEN_BYTES(lpDesc->lpszCurrentDirectory));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CurrentDirectory string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionA value (optional)
	if(lpDesc->lpszDescriptionA)
	{
		lReturn = RegSetValueExA(hkeyApp, "DescriptionA", 0, REG_SZ,
				lpDesc->lpszDescriptionA, lstrlenA(lpDesc->lpszDescriptionA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionA string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionW value (optional)
	if(lpDesc->lpszDescriptionW)
	{
		lReturn = RegSetValueEx(hkeyApp, SZ_DESCRIPTIONW, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszDescriptionW,
				WSTRLEN_BYTES(lpDesc->lpszDescriptionW));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionW string, lReturn = %lu", lReturn);
		}
	}

	// Set the LauncherName value (optional, DESC2 only)
	if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc) && lpDesc2->lpszAppLauncherName){
		lReturn = RegSetValueEx(hkeyApp, SZ_LAUNCHER, 0, REG_SZ,
				(LPBYTE)lpDesc2->lpszAppLauncherName,
				WSTRLEN_BYTES(lpDesc2->lpszAppLauncherName));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register LauncherName string, lReturn = %lu", lReturn);
		}
	}

	// set the dwFlags field
	lReturn=RegSetValueEx(hkeyApp, SZ_DWFLAGS, 0, REG_DWORD, (CHAR *)&lpDesc->dwFlags,sizeof(DWORD));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to write dwFlags field to registry, lReturn= %lu", lReturn);
	}

	// Close the two keys
	RegCloseKey(hkeyDPApps);
	RegCloseKey(hkeyApp);

	return DP_OK;

ERROR_WRITEAPPINREGISTRYUNICODE:

	if(hkeyApp)
	{
		// Delete the key
		// REVIEW!!!! -- TODO

		// Now close the key
		RegCloseKey(hkeyApp);
	}

	if(hkeyDPApps)
		RegCloseKey(hkeyDPApps);

	return hr;

} // PRV_WriteAppDescInRegistryUnicode



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RegisterApplication"
HRESULT DPLAPI DPL_RegisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, LPVOID lpvDesc)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPAPPLICATIONDESC		lpDescA = NULL;
	HRESULT					hr = DP_OK;
	LPDPAPPLICATIONDESC lpDesc=(LPDPAPPLICATIONDESC)lpvDesc;

	DPF(7, "Entering DPL_RegisterApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpDesc);

	ENTER_DPLOBBY();

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if(dwFlags)
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}

		// Validate the ApplicationDesc struct
		hr = PRV_ValidateDPAPPLICATIONDESC(lpDesc, FALSE);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			DPF_ERR("Invalid DPAPPLICATIONDESC structure");
			return hr;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// If we're on a Unicode platform, just write the stuff in the registry.
	// If it's not, we need to convert the DPAPPLICATIONDESC struct to ANSI
	if(OS_IsPlatformUnicode())
	{
		// Just write to the registry
		hr = PRV_WriteAppDescInRegistryUnicode(lpDesc);
	}
	else
	{
		// Convert the APPDESC struct to ANSI
		hr = PRV_ConvertDPAPPLICATIONDESCToAnsi(lpDesc, &lpDescA);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to convert DPAPPLICATIONDESC to Ansi, hr = 0x%08x", hr);
			goto ERROR_REGISTERAPPLICATION;
		}

		// Write to the registry
		hr = PRV_WriteAppDescInRegistryAnsi(lpDescA);

		// Free our APPDESC structure
		PRV_FreeLocalDPAPPLICATIONDESC(lpDescA);
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed writing ApplicationDesc to registry, hr = 0x%08x", hr);
	}

ERROR_REGISTERAPPLICATION:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_RegisterApplication



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_UnregisterApplication"
HRESULT DPLAPI DPL_UnregisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, REFGUID lpguid)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_UnregisterApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpguid);

	ENTER_DPLOBBY();

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if(dwFlags)
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}

		if(!VALID_READ_UUID_PTR(lpguid))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	hr = PRV_DeleteAppKeyFromRegistry((LPGUID)lpguid);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to delete app key from registry, hr = 0x%08x", hr);
	}

	LEAVE_DPLOBBY();

	return hr;

} // DPL_UnregisterApplication
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\create.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       create.c
 *  Content:	DirectPlayLobby creation code
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	6/24/96		myronth	Added Time Bomb
 *	8/23/96		kipo	removed time bomb
 *	10/23/96	myronth	Added client/server methods
 *	10/25/96	myronth	Added DX5 methods
 *	11/20/96	myronth	Added DPLC_A_LogonServer
 *	1/2/97		myronth	Changed vtbl entries for CreateAddress & EnumAddress
 *	1/2/97		myronth	Cleaned up creation code by adding PRV_LobbyCreate
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Added AllocateLobbyObject, removed response methods
 *						for Open and Close since they are synchronous
 *	3/17/97		myronth	Removed unnecessary Enum functions from IDPLobbySP
 *	3/21/97		myronth	Removed unnecessary Get/Set response functions
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	3/31/97		myronth	Removed dead code, changed IDPLobbySP interface methods
 *	5/8/97		myronth	Added subgroup methods & StartSession to IDPLobbySP
 *	5/17/97		myronth	Added SendChatMessage to IDPLobbySP
 *	6/25/97		kipo	remove time bomb for DX5
 *	10/3/97		myronth	Added CreateCompoundAddress and EnumAddress to
 *						IDPLobbySP (12648)
 *	10/29/97	myronth	Added SetGroupOwner to IDPLobbySP
 *	11/24/97	kipo	Added time bomb for DX6
 *	12/2/97		myronth	Added Register/UnregisterApplication methods
 *	12/4/97		myronth	Added ConnectEx
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	6/25/98		a-peterz Added DPL_A_ConnectEx
 *  2/2/99		aarono  Added lobbies to refcount on DPLAY dll to avoid
 *                      accidental unload.
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set 
 ***************************************************************************/
#include "dplobpr.h"
#include "verinfo.h"

//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------
UINT		gnSPCount;		// Running sp count


//
// The one copy of the direct play callbacks (this is the vtbl!)
//
DIRECTPLAYLOBBYCALLBACKS dplCallbacks =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_EnumLocalApplications,
	(LPVOID)DPL_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
};  				

DIRECTPLAYLOBBYCALLBACKSA dplCallbacksA =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_A_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_A_EnumLocalApplications,
	(LPVOID)DPL_A_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_A_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_A_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
};  				

// IDirectPlayLobby2 interface
DIRECTPLAYLOBBYCALLBACKS2 dplCallbacks2 =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_EnumLocalApplications,
	(LPVOID)DPL_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2 methods ***/
	(LPVOID)DPL_CreateCompoundAddress
};  				

DIRECTPLAYLOBBYCALLBACKS2A dplCallbacks2A =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_A_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_A_EnumLocalApplications,
	(LPVOID)DPL_A_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_A_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_A_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2A methods ***/
	(LPVOID)DPL_CreateCompoundAddress
};  				
  
// IDirectPlayLobby3 interface
DIRECTPLAYLOBBYCALLBACKS3 dplCallbacks3 =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_EnumLocalApplications,
	(LPVOID)DPL_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2 methods ***/
	(LPVOID)DPL_CreateCompoundAddress,
    /*** IDirectPlayLobby3 methods ***/
	(LPVOID)DPL_ConnectEx,
	(LPVOID)DPL_RegisterApplication,
	(LPVOID)DPL_UnregisterApplication,
	(LPVOID)DPL_WaitForConnectionSettings
};  				

DIRECTPLAYLOBBYCALLBACKS3A dplCallbacks3A =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_A_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_A_EnumLocalApplications,
	(LPVOID)DPL_A_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_A_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_A_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2A methods ***/
	(LPVOID)DPL_CreateCompoundAddress,
    /*** IDirectPlayLobby3 methods ***/
	(LPVOID)DPL_A_ConnectEx,
	(LPVOID)DPL_A_RegisterApplication,
	(LPVOID)DPL_UnregisterApplication,
	(LPVOID)DPL_WaitForConnectionSettings
};  				
  
DIRECTPLAYLOBBYSPCALLBACKS dplCallbacksSP =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPLP_AddGroupToGroup,
	(LPVOID)DPLP_AddPlayerToGroup,
	(LPVOID)DPLP_CreateGroup,
	(LPVOID)DPLP_CreateGroupInGroup,
	(LPVOID)DPLP_DeleteGroupFromGroup,
	(LPVOID)DPLP_DeletePlayerFromGroup,
	(LPVOID)DPLP_DestroyGroup,
	(LPVOID)DPLP_EnumSessionsResponse,
	(LPVOID)DPLP_GetSPDataPointer,
	(LPVOID)DPLP_HandleMessage,
	(LPVOID)DPLP_SendChatMessage,
	(LPVOID)DPLP_SetGroupName,
	(LPVOID)DPLP_SetPlayerName,
	(LPVOID)DPLP_SetSessionDesc,
	(LPVOID)DPLP_SetSPDataPointer,
	(LPVOID)DPLP_StartSession,
    /*** Methods added for DX6 ***/
	(LPVOID)DPL_CreateCompoundAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPLP_SetGroupOwner,
};  				

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AllocateLobbyObject"
HRESULT PRV_AllocateLobbyObject(LPDPLAYI_DPLAY lpDPObject,
							LPDPLOBBYI_DPLOBJECT * lpthis)
{
	LPDPLOBBYI_DPLOBJECT	this = NULL;


	DPF(7, "Entering PRV_AllocateLobbyObject");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDPObject, lpthis);

	// Allocate memory for our lobby object
    this = DPMEM_ALLOC(sizeof(DPLOBBYI_DPLOBJECT));
    if(!this) 
    {
    	DPF_ERR("Unable to allocate memory for lobby object");
        return DPERR_OUTOFMEMORY;
    }

	// Initialize the ref count
	this->dwRefCnt = 0;
	this->dwSize = sizeof(DPLOBBYI_DPLOBJECT);

	// Store the back pointer
	this->lpDPlayObject = lpDPObject;

	// Set the output pointer
	*lpthis = this;

	gnObjects++;

	return DP_OK;

} // PRV_AllocateLobbyObject



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LobbyCreate"
HRESULT WINAPI PRV_LobbyCreate(LPGUID lpGUID, LPDIRECTPLAYLOBBY *lplpDPL,
				IUnknown *pUnkOuter, LPVOID lpSPData, DWORD dwSize, BOOL bAnsi)
{
    LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLOBBYI_INTERFACE	lpInterface = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_LobbyCreate");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, %lu",
			lpGUID, lplpDPL, pUnkOuter, lpSPData, dwSize, bAnsi);
	
	// Must be NULL for this release
	if( lpGUID )
	{
		if( !VALID_READ_PTR(lpGUID, sizeof(GUID)) )
			return DPERR_INVALIDPARAMS;

		if(!IsEqualGUID(lpGUID, &GUID_NULL))
			return DPERR_INVALIDPARAMS;
	}

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }
   
	if( lpSPData )
	{
		// Must be NULL for this release
		return DPERR_INVALIDPARAMS;
	}

	if( dwSize )
	{
		// Must be zero for this release
		return DPERR_INVALIDPARAMS;
	}


    TRY
    {
        *lplpDPL = NULL;
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

#ifndef DX_FINAL_RELEASE

#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return DPERR_GENERIC;
	}

#endif

	// Allocate the lobby object
	hr = PRV_AllocateLobbyObject(NULL, &this);
	if(FAILED(hr))
		return hr;

	// Get the Unicode interface
	hr = PRV_GetInterface(this, &lpInterface, (bAnsi ? &dplCallbacksA : &dplCallbacks));
	if(FAILED(hr))
	{
		DPMEM_FREE(this);
    	DPF_ERR("Unable to allocate memory for lobby interface structure");
        return hr;
	}

	*lplpDPL = (LPDIRECTPLAYLOBBY)lpInterface;

    return DP_OK;

} // PRV_LobbyCreate

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayLobbyCreateW"
HRESULT WINAPI DirectPlayLobbyCreateW(LPGUID lpGUID, LPDIRECTPLAYLOBBY *lplpDPL,
							IUnknown *pUnkOuter, LPVOID lpSPData, DWORD dwSize)
{
	HRESULT		hr = DP_OK;

#ifdef DPLAY_LOADANDCHECKTRUE
    if( g_hRedirect != NULL )
    {
        return (*pfnDirectPlayLobbyCreateW)(lpGUID,lplpDPL,pUnkOuter,lpSPData,dwSize);
    }
#endif		

    ENTER_DPLOBBY();
    
	// Call the private create function
	hr = PRV_LobbyCreate(lpGUID, lplpDPL, pUnkOuter, lpSPData, dwSize, FALSE);

    LEAVE_DPLOBBY();

    return hr;

} // DirectPlayLobbyCreateW


#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayLobbyCreateA"
HRESULT WINAPI DirectPlayLobbyCreateA(LPGUID lpGUID, LPDIRECTPLAYLOBBY *lplpDPL,
							IUnknown *pUnkOuter, LPVOID lpSPData, DWORD dwSize)
{
	HRESULT		hr = DP_OK;

#ifdef DPLAY_LOADANDCHECKTRUE
    if( g_hRedirect != NULL )
    {
        return (*pfnDirectPlayLobbyCreateA)(lpGUID,lplpDPL,pUnkOuter,lpSPData,dwSize);
    }
#endif		

    ENTER_DPLOBBY();
    
	// Call the private create function
	hr = PRV_LobbyCreate(lpGUID, lplpDPL, pUnkOuter, lpSPData, dwSize, TRUE);

    LEAVE_DPLOBBY();

    return hr;

} // DirectPlayLobbyCreateA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplenum.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplenum.c
 *  Content:	Methods for enumeration
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	10/23/96	myronth	Added client/server methods
 *	12/10/96	myronth	Fixed bugs #4622 and #5043
 *	2/12/97		myronth	Mass DX5 changes
 *	3/4/97		myronth	Fixed enum size bug #6149
 *	3/12/97		myronth	Added EnumConnections
 *	3/25/97		kipo	EnumConnections takes a const *GUID now
 *	4/7/97		myronth	Fixed PRV_EnumConnections to use CreateCompoundAddress
 *	5/10/97		kipo	added GUID to EnumConnections callback
 *	5/14/97		myronth	Check for valid guid in EnumLocalApps, bug #7695
 *	5/17/97		myronth	Fixed bug #8506 (return bogus error if last app
 *						is invalid), fixed more GUIDFromString bugs
 *	8/22/97		myronth	Added registry support for Description and Private
 *						values, also cleaned up LP enumeration code
 *	11/20/97	myronth	Made EnumConnections & DirectPlayEnumerate 
 *						drop the lock before calling the callback (#15208)
 *	12/2/97		myronth	Changed EnumLocalApp to use Desc fields (#15448)
 *	01/20/98	sohailm	Don't free sp list after EnumConnections (#17006)
 *  10/22/99	aarono  Add support to hide apps from enum calls
 ***************************************************************************/
#include "dplobpr.h"

//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------
LPLSPNODE	glpLSPHead = NULL;


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CallEnumAddressTypesCallback"
HRESULT PRV_CallEnumAddressTypesCallback(HKEY hkeySP,
				LPDPLENUMADDRESSTYPESCALLBACK lpfnEnumCallback,
				LPVOID lpContext)
{
	HRESULT		hr;
	WCHAR		wszGuidStr[GUID_STRING_SIZE];
	DWORD		dwGuidStrSize = sizeof(wszGuidStr)/sizeof(TCHAR);
	GUID		guidAddressType;
	HKEY		hkeyAddressTypes;
	DWORD		dwIndex = 0;
	LONG		lReturn;
	BOOL		bReturn = TRUE;


	DPF(7, "Entering PRV_CallEnumAddressTypesCallback");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeySP, lpfnEnumCallback, lpContext);
	
	ASSERT(hkeySP);	
	
	// Get the Address Type registry key
	lReturn = OS_RegOpenKeyEx(hkeySP, SZ_ADDRESS_TYPES, 0,
								KEY_READ, &hkeyAddressTypes);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("No Address Types found for the Service Provider!");
		return DP_OK;
	}

	// Walk the list of Address Types in the registry, looking for the GUID passed in
	while((ERROR_NO_MORE_ITEMS != OS_RegEnumKeyEx(hkeyAddressTypes, dwIndex++,
			(LPWSTR)&wszGuidStr, &dwGuidStrSize, NULL, NULL, NULL, NULL)) && bReturn)
	{
		// Convert the string to a real GUID
		hr = GUIDFromString(wszGuidStr, &guidAddressType);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't convert Address Type string to GUID");
			dwGuidStrSize = sizeof(wszGuidStr);
			continue;
		}

		// Call the callback
		bReturn = ((LPDPLENUMADDRESSTYPESCALLBACK)lpfnEnumCallback)
					(&guidAddressType, lpContext, 0L);


		// Reset the size variable in the success case
		dwGuidStrSize = sizeof(wszGuidStr);
	}

	// Close the Address Types key
	RegCloseKey(hkeyAddressTypes);

	return DP_OK;


} // PRV_CallEnumAddressTypesCallback


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumAddressTypes"
HRESULT PRV_EnumAddressTypes(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMADDRESSTYPESCALLBACK lpfnEnumCallback,
				REFGUID guidSPIn, LPVOID lpContext, DWORD dwFlags)
{
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr = DP_OK;
	HKEY					hkeySPHead, hkeySP;
	DWORD					dwIndex = 0;
	DWORD					dwNameSize;
	WCHAR					wszSPName[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR					wszGuidStr[GUID_STRING_SIZE];
	DWORD					dwGuidStrSize = sizeof(wszGuidStr);
	DWORD					dwType = REG_SZ;
	GUID					guidSP;
	LONG					lReturn;
	BOOL					bFound = FALSE;


	DPF(7, "Entering PRV_EnumAddressTypes");
	DPF(9, "Parameters: 0x%08x, 0x%08x, guid, 0x%08x, 0x%08x",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags);
    
	TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }
        
        if( !VALIDEX_CODE_PTR( lpfnEnumCallback ) )
        {
            return DPERR_INVALIDPARAMS;
        }

		if (!VALID_READ_PTR(guidSPIn, sizeof(GUID)))
		{
			DPF_ERR("Invalid SP GUID pointer");
			return DPERR_INVALIDPARAMS;	
		}

		// There are no flags defined for DX3
		if( dwFlags )
		{
			return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Open the Service Providers key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_SP_KEY, 0,
								KEY_READ, &hkeySPHead);
	if(lReturn != ERROR_SUCCESS)
	{
		// This just means that the Service Providers key doesn't exist (most
		// likely), so in that case, there are no SP's to enumerate.
		DPF_ERR("There are no Service Providers registered");
		return DP_OK;
	}


	// Walk the list of SP's in the registry, looking for the GUID passed in
	while(!bFound)
	{
		// Get the next SP in the list
		dwNameSize = DPLOBBY_REGISTRY_NAMELEN;
		lReturn = OS_RegEnumKeyEx(hkeySPHead, dwIndex++, (LPWSTR)&wszSPName,
					&dwNameSize, NULL, NULL, NULL, NULL);

		// If lReturn is ERROR_NO_MORE_ITEMS, we want to end on this iteration
		if(lReturn == ERROR_NO_MORE_ITEMS)
			break;;

		// Open the SP key
		lReturn = OS_RegOpenKeyEx(hkeySPHead, (LPWSTR)wszSPName, 0,
									KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open key for Service Provider!");
			continue;
		}

		// Get the GUID of the SP
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_GUID, NULL, &dwType,
									(LPBYTE)&wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID
		hr = GUIDFromString(wszGuidStr, &guidSP);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Invalid SP guid -- skipping SP, hr = 0x%08x", hr);
			RegCloseKey(hkeySP);
			// Set the hresult back to DP_OK in case this is the last
			// SP in the registry -- we want the method call
			// to succeed if we got this far, we just don't want to
			// call the callback for this particular SP
			hr = DP_OK;
			continue;
		}

		// If we match the GUID passed in, then enumerate them
		if(IsEqualGUID(guidSPIn, &guidSP))
		{
			// Enumerate the Address Types for this SP
			hr = PRV_CallEnumAddressTypesCallback(hkeySP,
							lpfnEnumCallback, lpContext);
			bFound = TRUE;
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the DPlay Apps key
	RegCloseKey(hkeySPHead);

	// If we didn't find the SP, return an error
	// REVIEW!!!! -- Is this really the error we want here????
	if(!bFound)
		return DPERR_UNAVAILABLE;

	return hr;

} // PRV_EnumAddressTypes


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumAddressTypes"
HRESULT DPLAPI DPL_EnumAddressTypes(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMADDRESSTYPESCALLBACK lpfnEnumCallback,
				REFGUID guidSP, LPVOID lpContext, DWORD dwFlags)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_EnumAddressTypes");
	DPF(9, "Parameters: 0x%08x, 0x%08x, guid, 0x%08x, 0x%08x",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags);

	ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_EnumAddressTypes(lpDPL, lpfnEnumCallback, guidSP, lpContext, dwFlags);

	LEAVE_DPLOBBY();

	return hr;

} // DPL_EnumAddressTypes



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeLSPNode"
void PRV_FreeLSPNode(LPLSPNODE lpNode)
{
	DPF(7, "Entering PRV_FreeLSPNode");

	if(!lpNode)
		return;

	if(lpNode->lpwszName)
		DPMEM_FREE(lpNode->lpwszName);
	if(lpNode->lpwszPath)
		DPMEM_FREE(lpNode->lpwszPath);
	if(lpNode->lpszDescA)
		DPMEM_FREE(lpNode->lpszDescA);
	if(lpNode->lpwszDesc)
		DPMEM_FREE(lpNode->lpwszDesc);
	DPMEM_FREE(lpNode);

} // PRV_FreeLSPNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeLSPList"
void PRV_FreeLSPList(LPLSPNODE lpLSPHead)
{
	LPLSPNODE	lpTemp;


	DPF(7, "Entering PRV_FreeLSPList");
	DPF(9, "Parameters: 0x%08x", lpLSPHead);
	
	// Walk the list and free each node
	while(lpLSPHead)
	{
		// Save the next one
		lpTemp = lpLSPHead->lpNext;
		
		// Free all of the members
		PRV_FreeLSPNode(lpLSPHead);

		// Move to the next one
		lpLSPHead = lpTemp;
	}

} // PRV_FreeLSPList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddLSPNode"
HRESULT PRV_AddLSPNode(LPWSTR lpwszName, LPWSTR lpwszPath, LPWSTR lpwszDesc,
			LPSTR lpszDescA, LPWSTR lpwszGuid, DWORD dwReserved1,
			DWORD dwReserved2, DWORD dwNodeFlags)
{
	LPLSPNODE	lpLSPNode = NULL;
	DWORD		dwDescASize;
	HRESULT		hr;


	DPF(7, "Entering PRV_AddLSPNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, %lu, 0x%08x",
			lpwszName, lpwszPath, lpwszDesc, lpszDescA, lpwszGuid, dwReserved1,
			dwReserved2, dwNodeFlags);


	// Allocate memory for the node
	lpLSPNode = DPMEM_ALLOC(sizeof(LSPNODE));
	if(!lpLSPNode)
	{
		DPF_ERR("Failed to allocate memory for Lobby Provider node, skipping LP");
		return DPERR_OUTOFMEMORY;
	}

	// Allocate memory for the Name string and copy it
	hr = GetString(&lpLSPNode->lpwszName, lpwszName);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to allocate memory for Lobby Provider Name string, skipping provider");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_ADDLSPNODE;
	}

	// Allocate memory for the Path string and copy it
	hr = GetString(&lpLSPNode->lpwszPath, lpwszPath);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to allocate memory for Lobby Provider Path string, skipping provider");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_ADDLSPNODE;
	}

	if(dwNodeFlags & LSPNODE_DESCRIPTION)
	{
		// Allocate memory for the DescriptionA string and copy it
		dwDescASize = lstrlenA(lpszDescA)+1;
		lpLSPNode->lpszDescA = DPMEM_ALLOC(dwDescASize);
		if(!lpLSPNode->lpszDescA)
		{
			DPF_ERR("Unable to allocate memory for Lobby Provider Path string, skipping provider");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_ADDLSPNODE;
		}
		memcpy(lpLSPNode->lpszDescA, lpszDescA, dwDescASize);

		// Allocate memory for the DescriptionW string and copy it
		hr = GetString(&lpLSPNode->lpwszDesc, lpwszDesc);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to allocate memory for Lobby Provider DescriptionW string, skipping provider");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_ADDLSPNODE;
		}
	}

	// Convert the string to a real GUID
	hr = GUIDFromString(lpwszGuid, &lpLSPNode->guid);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Invalid LP guid -- skipping LP, hr = 0x%08x", hr);
		goto ERROR_ADDLSPNODE;
	}

	// Finish setting up the node
	lpLSPNode->dwReserved1 = dwReserved1;
	lpLSPNode->dwReserved2 = dwReserved2;
	lpLSPNode->dwNodeFlags = dwNodeFlags;

	// Add the node to the list
	lpLSPNode->lpNext = glpLSPHead;
	glpLSPHead = lpLSPNode;

	return DP_OK;

ERROR_ADDLSPNODE:

	if(lpLSPNode->lpwszName)
		DPMEM_FREE(lpLSPNode->lpwszName);
	if(lpLSPNode->lpwszPath)
		DPMEM_FREE(lpLSPNode->lpwszPath);
	if(lpLSPNode->lpwszDesc)
		DPMEM_FREE(lpLSPNode->lpwszDesc);
	if(lpLSPNode->lpszDescA)
		DPMEM_FREE(lpLSPNode->lpszDescA);
	DPMEM_FREE(lpLSPNode);

	return hr;

} // PRV_AddLSPNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_BuildLSPList"
HRESULT PRV_BuildLSPList()
{
	HKEY		hkeyLobbySP, hkeySP;
	WCHAR		szSPName[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR		szSPPath[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR		szSPDescW[DPLOBBY_REGISTRY_NAMELEN];
	CHAR		szSPDescA[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR		wszGuidStr[GUID_STRING_SIZE];
	DWORD		dwSize;
	DWORD		dwGuidStrSize = GUID_STRING_SIZE;
	DWORD		dwType = REG_SZ;
	DWORD		dwIndex = 0;
	DWORD		dwReserved1, dwReserved2, dwReservedSize;
	LONG		lReturn;
	DWORD		dwError;
	HRESULT		hr;
	DWORD		dwNodeFlags = 0;

												
	DPF(7, "Entering PRV_BuildLSPList");
	
	if(glpLSPHead)
	{
		return DP_OK;
	}

	// Open the DPLobby SP key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLOBBY_SP_KEY, 0,
								KEY_READ, &hkeyLobbySP);
	if(lReturn != ERROR_SUCCESS)
	{
		// This just means that the DPLobby SP key doesn't exist (most
		// likely), so in that case, there are no Lobby SP's to enumerate.
		return DP_OK;
	}

	// Walk the list of Lobby SP's in the registry, enumerating them
	while(1)
	{
		// Get the next LSP Name
		dwSize = sizeof(szSPName)/sizeof(TCHAR);
		lReturn = OS_RegEnumKeyEx(hkeyLobbySP, dwIndex++, szSPName,
					&dwSize, NULL, NULL, NULL, NULL);
		if(lReturn == ERROR_NO_MORE_ITEMS)
			break;
		else if(lReturn != ERROR_SUCCESS)
		{
			dwError = GetLastError();
			DPF_ERRVAL("Unable to get Lobby Provider name from the registry -- dwError = %u -- skipping provider", dwError);
			continue;
		}

		// Open the subkey
		lReturn = OS_RegOpenKeyEx(hkeyLobbySP, szSPName, 0, KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			dwError = GetLastError();
			DPF_ERRVAL("Unable to open Lobby Provider key in the registry -- dwError = %u -- skipping provider", dwError);
			continue;
		}


		// First see if the "Private" key exists.  If it does, then set the flag
		// so that it will get skipped during enumeration
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_PRIVATE, NULL, &dwType, NULL, &dwSize);
		if (ERROR_SUCCESS == lReturn) 
		{
			// The key exists, so set the flag so we don't enumerate it
			dwNodeFlags |= LSPNODE_PRIVATE;
		}


		// Get the LSP Path
		dwSize = sizeof(szSPPath);
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_PATH, NULL, &dwType,
					(LPBYTE)&szSPPath, &dwSize);
		if(lReturn != ERROR_SUCCESS)
		{
			dwError = GetLastError();
			DPF_ERRVAL("Unable to get Lobby Provider path from the registry -- dwError = %u -- skipping provider", dwError);
			RegCloseKey(hkeySP);
			continue;
		}

		// Get the LSP Descriptions
		// If the DescriptionA value doesn't exist, then don't worry about
		// getting the DescriptionW value.  If the DescriptionA value exits,
		// but the DescriptionW value does not, convert the DescriptionA
		// value to Unicode and store it in DescriptionW.
		// NOTE: We always assume the DescriptionA value is an ANSI string,
		// even if it's stored in a Unicode format on NT & Memphis.  So we
		// always retrieve this as an ANSI string
		dwSize = sizeof(szSPDescA);
		lReturn = RegQueryValueExA(hkeySP, "DescriptionA", NULL, &dwType,
					(LPBYTE)&szSPDescA, &dwSize);
		if(lReturn == ERROR_SUCCESS)
		{
			// Save the description flag
			dwNodeFlags |= LSPNODE_DESCRIPTION;

			// Get the DescriptionW value
			dwSize = sizeof(szSPDescW);
			lReturn = OS_RegQueryValueEx(hkeySP, SZ_DESCRIPTIONW, NULL, &dwType,
						(LPBYTE)&szSPDescW, &dwSize);
			if(lReturn != ERROR_SUCCESS)
			{
				// Convert the ANSI Description string to Unicode and store it
				AnsiToWide(szSPDescW, szSPDescA, (lstrlenA(szSPDescA)+1));
			}
		}
		
		// Get the GUID of the LSP
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_GUID, NULL, &dwType,
					(LPBYTE)&wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value for Lobby Provider!");
			continue;
		}

		// Get the Reserved1 dword (we don't care if it fails)
		dwType = REG_DWORD;
		dwReservedSize = sizeof(DWORD);
		dwReserved1 = 0;
		OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED1, NULL, &dwType,
			(LPBYTE)&dwReserved1, &dwReservedSize);
		
		// Get the Reserved1 dword (we don't care if it fails)
		dwReservedSize = sizeof(DWORD);
		dwReserved2 = 0;
		OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED1, NULL, &dwType,
			(LPBYTE)&dwReserved2, &dwReservedSize);
		
		
		// Add the node to the list
		hr = PRV_AddLSPNode(szSPName, szSPPath, szSPDescW, szSPDescA,
				wszGuidStr, dwReserved1, dwReserved2, dwNodeFlags);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed adding Lobby Provider to internal list, hr = 0x%08x", hr);
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the Lobby SP key
	RegCloseKey(hkeyLobbySP);

	return DP_OK;

} // PRV_BuildLSPList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumConnections"
HRESULT PRV_EnumConnections(LPCGUID lpGuid, LPDPENUMCONNECTIONSCALLBACK lpCallback,
			LPVOID lpContext, DWORD dwFlags, BOOL bAnsi)
{
	LPLSPNODE					lpLSPNode, lpLSPHead;
	BOOL						bContinue = TRUE;
	DPNAME						name;
	HRESULT						hr = DP_OK;
	DPCOMPOUNDADDRESSELEMENT	AddrOnly;
	LPDPADDRESS					lpAddress = NULL;
	DWORD						dwAddressSize;
	DWORD						dwAddressSizeSave;
	LPWSTR						lpwszName = NULL;


	DPF(7, "Entering PRV_EnumConnections");
	DPF(9, "Parameters: ");

	// Rebuild the LSP List
	PRV_BuildLSPList();

	// If we don't have any entries, just bail here
	if(!glpLSPHead)
		return DP_OK;

	// Get a pointer to the first lobby provider, and store our head pointer
	lpLSPHead = glpLSPHead;
	lpLSPNode = glpLSPHead;

	// Setup the unfinished address
	memset(&AddrOnly, 0, sizeof(DPCOMPOUNDADDRESSELEMENT));
	AddrOnly.guidDataType = DPAID_LobbyProvider;
	AddrOnly.dwDataSize = sizeof(GUID);
	AddrOnly.lpData = &lpLSPNode->guid;

	// Calculate the size of the finished address
	hr = InternalCreateCompoundAddress(&AddrOnly, 1, NULL, &dwAddressSize);
	if(hr != DPERR_BUFFERTOOSMALL)
	{
		DPF_ERRVAL("Failed to retrieve the size of the output address buffer, hr = 0x%08x", hr);
		return hr;
	}

	// Allocate the buffer for the finished address
	lpAddress = DPMEM_ALLOC(dwAddressSize);
	if(!lpAddress)
	{
		DPF_ERR("Unable to allocate memory for temporary address structure");
		return DPERR_OUTOFMEMORY;
	}

	// Clear the DPNAME struct
	memset(&name,0,sizeof(name));
	name.dwSize = sizeof(name);
	
	// now, we have a list of SP's.  walk the list, and call the app back
	// run through what we found...
	dwAddressSizeSave = dwAddressSize;

	// Drop the locks
	LEAVE_ALL();

	while ((lpLSPNode) && (bContinue))
	{
		// If the private flag is set, don't enumerate it
		if(!(lpLSPNode->dwNodeFlags & LSPNODE_PRIVATE))
		{
			// Create the real DPADDRESS
			dwAddressSize = dwAddressSizeSave;
			AddrOnly.lpData = &lpLSPNode->guid;
			hr = InternalCreateCompoundAddress(&AddrOnly, 1, lpAddress,
					&dwAddressSize);
			if(SUCCEEDED(hr))
			{
				// Call the callback
				// If the caller is ANSI, convert the string
				if (bAnsi)
				{
					// If we have a description string, use it, and we already
					// have an ANSI version to use
					if(lpLSPNode->dwNodeFlags & LSPNODE_DESCRIPTION)
					{
						name.lpszShortNameA = lpLSPNode->lpszDescA;

						// Call the app's callback
						bContinue= lpCallback(&lpLSPNode->guid, lpAddress, dwAddressSize, &name,
									DPCONNECTION_DIRECTPLAYLOBBY, lpContext);
					}
					else
					{
						hr = GetAnsiString(&(name.lpszShortNameA), lpLSPNode->lpwszName);
						if(SUCCEEDED(hr))
						{
							// Call the app's callback
							bContinue= lpCallback(&lpLSPNode->guid, lpAddress, dwAddressSize, &name,
										DPCONNECTION_DIRECTPLAYLOBBY, lpContext);

							// Free our short name buffer
							DPMEM_FREE(name.lpszShortNameA);
						}
						else
						{
							DPF_ERR("Unable to allocate memory for temporary name string, skipping Connection");
						}
					}
				}
				else 
				{
					// If we have a description, use it
					if(lpLSPNode->dwNodeFlags & LSPNODE_DESCRIPTION)
						lpwszName = lpLSPNode->lpwszDesc;
					else
						lpwszName = lpLSPNode->lpwszName;

					name.lpszShortName = lpwszName;

					// Call the app's callback
					bContinue= lpCallback(&lpLSPNode->guid, lpAddress, dwAddressSize, &name,
								DPCONNECTION_DIRECTPLAYLOBBY, lpContext);
				}
			}
			else
			{
				DPF(2, "Failed to create DPADDRESS structure, skipping this Connection, hr = 0x%08x", hr);
			}
		}
				
		lpLSPNode = lpLSPNode->lpNext;

	} // while

	// Take the locks back
	ENTER_ALL();

	// Free our temporary address struct
	DPMEM_FREE(lpAddress);
	
	return DP_OK;	

} // PRV_EnumConnections





#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CallEnumLocalAppCallback"
HRESULT PRV_CallEnumLocalAppCallback(LPWSTR lpwszAppName, LPGUID lpguidApp,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK lpfnEnumCallback,
				LPVOID lpContext, BOOL bAnsi, LPSTR lpszDescA,
				LPWSTR lpwszDescW)
{
	LPDPLAPPINFO	lpai = NULL;
	LPSTR			lpszAppName = NULL;
	BOOL			bReturn;


	DPF(7, "Entering PRV_CallEnumLocalAppCallback");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpwszAppName, lpguidApp, lpfnEnumCallback, lpContext, bAnsi,
			lpszDescA, lpwszDescW);

	// Allocate memory for the AppInfo struct
	lpai = DPMEM_ALLOC(sizeof(DPLAPPINFO));
	if(!lpai)
	{
		DPF_ERR("Unable to allocate memory for AppInfo structure!");
		return DPERR_OUTOFMEMORY;
	}

	// Set the size
	lpai->dwSize = sizeof(DPLAPPINFO);

	// If the description strings exist, use them
	// NOTE: We can assume that if the DescriptionA string exists,
	// they both do.
	if(lpszDescA)
	{
		if(bAnsi)
			lpai->lpszAppNameA = lpszDescA;
		else
			lpai->lpszAppName = lpwszDescW;
	}
	else
	{
		// If we're ANSI, convert the string
		if(bAnsi)
		{
			if(FAILED(GetAnsiString(&lpszAppName, lpwszAppName)))
			{
				DPMEM_FREE(lpai);
				DPF_ERR("Unable to allocate memory for temporary string!");
				return DPERR_OUTOFMEMORY;
			}

			lpai->lpszAppNameA = lpszAppName;
		}
		else
		{
			lpai->lpszAppName = lpwszAppName;
		}
	}

	// Set the GUID
	lpai->guidApplication = *lpguidApp;

	// Call the callback
	bReturn = ((LPDPLENUMLOCALAPPLICATIONSCALLBACK)lpfnEnumCallback)
				(lpai, lpContext, 0L);

	// Free all of our memory
	if(lpszAppName)
		DPMEM_FREE(lpszAppName);
	DPMEM_FREE(lpai);

	// Set our HRESULT return value
	if(bReturn)
		return DP_OK;
	else
		return DPLOBBYPR_CALLBACKSTOP;

} // PRV_CallEnumLocalAppCallback


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumLocalApplications"
HRESULT PRV_EnumLocalApplications(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK lpfnEnumCallback,
				LPVOID lpContext, DWORD dwFlags, BOOL bAnsi)
{
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr = DP_OK;
	HKEY					hkeyDPApps, hkeyApp;
	WCHAR					wszAppName[DPLOBBY_REGISTRY_NAMELEN];
	DWORD					dwIndex = 0;
	DWORD					dwNameSize;
	WCHAR					wszGuidStr[GUID_STRING_SIZE];
	DWORD					dwGuidStrSize = sizeof(wszGuidStr);
	DWORD					dwType = REG_SZ;
	GUID					guidApp;
	LONG					lReturn;
	CHAR					szDescA[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR					wszDescW[DPLOBBY_REGISTRY_NAMELEN];
	DWORD					dwDescSize;
	BOOL					bDesc = FALSE;
	LPSTR					lpszDescA = NULL;
	LPWSTR					lpwszDescW = NULL;
	BOOL					bHide;
	DWORD					dwRegFlags;
	DWORD					dwRegFlagsSize;


	DPF(7, "Entering PRV_EnumLocalApplications");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags, bAnsi);

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }
        
        if( !VALIDEX_CODE_PTR( lpfnEnumCallback ) )
        {
            return DPERR_INVALIDPARAMS;
        }

		if( dwFlags )
		{
			return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Open the Applications key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0,
								KEY_READ, &hkeyDPApps);
	if(lReturn != ERROR_SUCCESS)
	{
		// This just means that the application key doesn't exist (most
		// likely), so in that case, there are no apps to enumerate.
		return DP_OK;
	}


	// Walk the list of DPlay games in the registry, enumerating them
	while(1)
	{
		// Reset the pointers and the flag
		lpszDescA = NULL;
		lpwszDescW = NULL;
		bDesc = FALSE;
		bHide = FALSE;

		// Get the next app in the list
		dwNameSize = DPLOBBY_REGISTRY_NAMELEN;
		lReturn = OS_RegEnumKeyEx(hkeyDPApps, dwIndex++, (LPWSTR)&wszAppName,
						&dwNameSize, NULL, NULL, NULL, NULL);

		// If lReturn is ERROR_NO_MORE_ITEMS, we want this to be the last iteration
		if(lReturn == ERROR_NO_MORE_ITEMS)
			break;

		// Open the app key
		lReturn = OS_RegOpenKeyEx(hkeyDPApps, (LPWSTR)wszAppName, 0,
									KEY_READ, &hkeyApp);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open app key!");
			continue;
		}

		// see if we should even report this game (its hidden)
		dwRegFlags = 0;
		dwRegFlagsSize = sizeof(dwRegFlags);
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_DWFLAGS, NULL, &dwType, (CHAR *)&dwRegFlags, &dwRegFlagsSize);
		
		if(lReturn == ERROR_SUCCESS && dwRegFlags & DPLAPP_NOENUM){
		
			// application is hidden, don't report it back to the application.
			bHide = TRUE;
			
		} else {

			// Get the GUID of the Game
			dwGuidStrSize = GUID_STRING_SIZE;
			lReturn = OS_RegQueryValueEx(hkeyApp, SZ_GUID, NULL, &dwType,
										(LPBYTE)&wszGuidStr, &dwGuidStrSize);
			if(lReturn != ERROR_SUCCESS)
			{
				RegCloseKey(hkeyApp);
				DPF_ERR("Unable to query GUID key value!");
				continue;
			}

			// Convert the string to a real GUID
			hr = GUIDFromString(wszGuidStr, &guidApp);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Invalid game guid -- skipping game, hr = 0x%08x", hr);
				RegCloseKey(hkeyApp);
				// Set the hresult back to DP_OK in case this is the last
				// application in the registry -- we want the method call
				// to succeed if we got this far, we just don't want to
				// call the callback for this particular application
				hr = DP_OK;
				continue;
			}

			// Get the Description strings
			dwDescSize = sizeof(szDescA);
			lReturn = RegQueryValueExA(hkeyApp, "DescriptionA", NULL, &dwType,
						(LPBYTE)szDescA, &dwDescSize);
			if(lReturn != ERROR_SUCCESS) 
			{
				DPF(5,"Could not read Description lReturn = %d\n",lReturn);
				// it's ok if the app doesn't have one of these...
			}
			else
			{
				DPF(5,"Got DescriptionA = %s\n",szDescA);
				
				// Set our description flag
				bDesc = TRUE;

				// Now try to get the DescriptionW string if one exists.  If for some
				// reason a DescriptionW string exists, but the DescriptionA does not,
				// we pretend the DescriptionW string doesn't exist either.
				// NOTE: We always assume the DescriptionW string is a Unicode string,
				// even on Win95.  On Win95, this will be of the type REG_BINARY, but
				// it is really just a Unicode string.
				dwDescSize = sizeof(wszDescW);
				lReturn = OS_RegQueryValueEx(hkeyApp, SZ_DESCRIPTIONW, NULL,
							&dwType, (LPBYTE)wszDescW, &dwDescSize);
				if(lReturn != ERROR_SUCCESS) 
				{
					DPF(5,"Could not get DescriptionW, converting DescriptionA");

					// We couldn't get DescriptionW, so convert DescriptionA...
					AnsiToWide(wszDescW,szDescA,(lstrlenA(szDescA)+1));
				}
				else
				{
					DPF(5,"Got DescriptionW = %ls\n",wszDescW);
				}

			}
		}		
		
		// Close the App key
		RegCloseKey(hkeyApp);

		// Setup the description pointers if they are valid
		if(bDesc)
		{
			lpszDescA = (LPSTR)&szDescA;
			lpwszDescW = (LPWSTR)&wszDescW;
		}

		if(bHide){
			// not calling back for this hidden application
			hr=DP_OK;
		} else {
			// Call the callback
			hr = PRV_CallEnumLocalAppCallback(wszAppName, &guidApp,
							lpfnEnumCallback, lpContext, bAnsi,
							lpszDescA, lpwszDescW);
		}

		if(hr == DPLOBBYPR_CALLBACKSTOP)
		{
			hr = DP_OK;
			break;
		}
		else
		{
			if(FAILED(hr))
				break;
			else
				continue;
		}
	}

	// Close the DPlay Apps key
	RegCloseKey(hkeyDPApps);
	dwNameSize = DPLOBBY_REGISTRY_NAMELEN;

	return hr;

} // PRV_EnumLocalApplications


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumLocalApplications"
HRESULT DPLAPI DPL_EnumLocalApplications(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK lpfnEnumCallback,
				LPVOID lpContext, DWORD dwFlags)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_EnumLocalApplications");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags);

	ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_EnumLocalApplications(lpDPL, lpfnEnumCallback, lpContext,
								dwFlags, FALSE);

	LEAVE_DPLOBBY();

	return hr;

} // DPL_EnumLocalApplications
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplobby.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobby.h
 *  Content:    DirectPlayLobby include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	===========	=======	==========
 *	4/13/96		myronth	Created it
 *	6/20/96		myronth	Cleaned it up
 *	6/24/96		myronth	More cleanup
 *	7/1/96		myronth	Changed DPLERR_ to DPERR_
 *  7/9/96      ajayj   Cleaned up formatting to match dplay.h
 *  7/15/96     ajayj   Added DPADDRESS chunk tags for dplaunch
 *                      sample app.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  8/1/96      sohailm Added IDirectPlayLobby interface macros
 *  8/10/96     sohailm Bug#2227: declared pointers in callbacks as const.
 *  8/15/96     sohailm Added type definition for LPCDPLCONNECTION
 *                      Changed LPGUIDs to REFGUIDs in IDirectPlayLobby interface 
 *                      Made function parameters constant where appropriate
 *	8/16/96		andyco	took out some const and ref stuff for ship
 *	8/16/96		myronth	Added SetConnectionSettings & Connect methods
 *  8/21/96     ajayj   replace tabs with spaces
 *	8/21/96		kipo	Added DPCOMPORTADDRESS structure
 *	9/5/96		myronth	Wrapped DPLCAPS with MSINTERNAL
 *	10/23/96	myronth	Added first cut of client/server methods
 *	10/25/96	myronth	Added DX5 methods
 *	12/13/96	myronth	Changed DPLAD_SYSTEM to DPLMSG_SYSTEM
 *	1/30/97		myronth	Added MSINTERNAL's to DX5 stuff for meltdown
 *	2/12/97		myronth	Removed meltdown changes
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	3/5/97		andyco	added DPAID_TotalSize
 *	3/12/97		myronth	Added DPAID_LobbyProvider chunk
 *	3/17/97		kipo	Added data structures for CreateCompoundAddress() and
 *						added guids for Unicode phone numbers and IP addresses
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	4/11/97		myronth	Added CLSID_DirectPlayLobby clsid
 *	5/8/97		myronth	Moved DPLCONNECTION structure definition to dplay.h
 *  5/21/97		ajayj	Added structures and definitions for standard lobby 
 *						messages
 *  5/23/97		ajayj	Added DPLDATA_PLAYERGUID structure
 *  5/30/97		ajayj	Added DPLPROPERTY_MessagesSupported GUID
 *	6/7/97		myronth	Fixed CreateCompoundAddress macros
 *	6/6/97		kipo	Added "FAR" to all structures
 *	8/19/97		myronth	Added DPLMSG_NEWSESSIONHOST structure
 *	11/13/97	myronth	Added guidInstance to lobby system messages (#10944)
 *	12/2/97		myronth	Added Register/UnregisterApplication
 *	12/4/97		myronth	Added ConnectEx
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	1/29/98		sohailm	Added DPAID_INetPort.
 *	2/11/98		a-peterz Clarify that DPAID_INetPort value is a word (#18210)
 *	4/15/98		a-peterz Fix IDirectPlayLobby_CreateCompoundAddress C++ version
 *  10/22/99	aarono  added support for application flags
 *@@END_MSINTERNAL
 ***************************************************************************/
#ifndef __DPLOBBY_INCLUDED__
#define __DPLOBBY_INCLUDED__

#include "dplay.h"

/* avoid warnings at Level 4 */
#pragma warning(disable:4201)

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*
 * GUIDS used by DirectPlay objects
 */

/* {AF465C71-9588-11cf-A020-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobby, 0xaf465c71, 0x9588, 0x11cf, 0xa0, 0x20, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {26C66A70-B367-11cf-A024-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobbyA, 0x26c66a70, 0xb367, 0x11cf, 0xa0, 0x24, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {0194C220-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2, 0x194c220, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {1BB4AF80-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2A, 0x1bb4af80, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {2DB72490-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3, 0x2db72490, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2DB72491-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3A, 0x2db72491, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2FE8F810-B2A5-11d0-A787-0000F803ABFC} */
DEFINE_GUID(CLSID_DirectPlayLobby, 0x2fe8f810, 0xb2a5, 0x11d0, 0xa7, 0x87, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);


/****************************************************************************
 *
 * IDirectPlayLobby Structures
 *
 * Various structures used to invoke DirectPlayLobby.
 *
 ****************************************************************************/

typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBY;
typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBYA;
typedef struct IDirectPlayLobby     IDirectPlayLobbyA;

typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2;
typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2A;
typedef struct IDirectPlayLobby2    IDirectPlayLobby2A;

typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3;
typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3A;
typedef struct IDirectPlayLobby3    IDirectPlayLobby3A;


/*
 * DPLAPPINFO
 * Used to hold information about a registered DirectPlay
 * application
 */
typedef struct DPLAPPINFO
{
    DWORD       dwSize;             // Size of this structure
    GUID        guidApplication;    // GUID of the Application
    union
    {
        LPSTR   lpszAppNameA;       // Pointer to the Application Name
        LPWSTR  lpszAppName;
    };

} DPLAPPINFO, FAR *LPDPLAPPINFO;

/*
 * LPCDPLAPPINFO
 * A constant pointer to DPLAPPINFO
 */
typedef const DPLAPPINFO FAR *LPCDPLAPPINFO;

/*
 * DPCOMPOUNDADDRESSELEMENT
 *
 * An array of these is passed to CreateCompoundAddresses()
 */
typedef struct DPCOMPOUNDADDRESSELEMENT
{
    GUID                guidDataType;
    DWORD               dwDataSize;
	LPVOID				lpData;
} DPCOMPOUNDADDRESSELEMENT, FAR *LPDPCOMPOUNDADDRESSELEMENT;

/*
 * LPCDPCOMPOUNDADDRESSELEMENT
 * A constant pointer to DPCOMPOUNDADDRESSELEMENT
 */
typedef const DPCOMPOUNDADDRESSELEMENT FAR *LPCDPCOMPOUNDADDRESSELEMENT;

/*
 * LPDPAPPLICATIONDESC
 * Used to register a DirectPlay application
 */
typedef struct DPAPPLICATIONDESC
{
    DWORD       dwSize;
    DWORD       dwFlags;
    union
    {
        LPSTR       lpszApplicationNameA;
        LPWSTR      lpszApplicationName;
    };
    GUID        guidApplication;
    union
    {
        LPSTR       lpszFilenameA;
        LPWSTR      lpszFilename;
    };
    union
    {
        LPSTR       lpszCommandLineA;
        LPWSTR      lpszCommandLine;
    };
    union
    {
        LPSTR       lpszPathA;
        LPWSTR      lpszPath;
    };
    union
    {
        LPSTR       lpszCurrentDirectoryA;
        LPWSTR      lpszCurrentDirectory;
    };
    LPSTR       lpszDescriptionA;
    LPWSTR      lpszDescriptionW;
} DPAPPLICATIONDESC, *LPDPAPPLICATIONDESC;

/*
 * LPDPAPPLICATIONDESC2
 * Used to register a DirectPlay application
 */
typedef struct DPAPPLICATIONDESC2
{
    DWORD       dwSize;
    DWORD       dwFlags;
    union
    {
        LPSTR       lpszApplicationNameA;
        LPWSTR      lpszApplicationName;
    };
    GUID        guidApplication;
    union
    {
        LPSTR       lpszFilenameA;
        LPWSTR      lpszFilename;
    };
    union
    {
        LPSTR       lpszCommandLineA;
        LPWSTR      lpszCommandLine;
    };
    union
    {
        LPSTR       lpszPathA;
        LPWSTR      lpszPath;
    };
    union
    {
        LPSTR       lpszCurrentDirectoryA;
        LPWSTR      lpszCurrentDirectory;
    };
    LPSTR       lpszDescriptionA;
    LPWSTR      lpszDescriptionW;
    union
    {
    	LPSTR		lpszAppLauncherNameA;
    	LPWSTR      lpszAppLauncherName;
    };
} DPAPPLICATIONDESC2, *LPDPAPPLICATIONDESC2;


/****************************************************************************
 *
 * Enumeration Method Callback Prototypes
 *
 ****************************************************************************/

/*
 * Callback for EnumAddress()
 */
typedef BOOL (FAR PASCAL *LPDPENUMADDRESSCALLBACK)(
    REFGUID         guidDataType,
    DWORD           dwDataSize,
    LPCVOID         lpData,
    LPVOID          lpContext);

/*
 * Callback for EnumAddressTypes()
 */
typedef BOOL (FAR PASCAL *LPDPLENUMADDRESSTYPESCALLBACK)(
    REFGUID         guidDataType,
    LPVOID          lpContext,
    DWORD           dwFlags);

/*
 * Callback for EnumLocalApplications()
 */
typedef BOOL (FAR PASCAL * LPDPLENUMLOCALAPPLICATIONSCALLBACK)(
    LPCDPLAPPINFO   lpAppInfo,
    LPVOID          lpContext,
    DWORD           dwFlags);


/****************************************************************************
 *
 * DirectPlayLobby API Prototypes
 *
 ****************************************************************************/
#ifdef UNICODE
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateW
#else
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateA
#endif /* UNICODE */

extern HRESULT WINAPI DirectPlayLobbyCreateW(LPGUID, LPDIRECTPLAYLOBBY *, IUnknown *, LPVOID, DWORD );
extern HRESULT WINAPI DirectPlayLobbyCreateA(LPGUID, LPDIRECTPLAYLOBBYA *, IUnknown *, LPVOID, DWORD );


/****************************************************************************
 *
 * IDirectPlayLobby (and IDirectPlayLobbyA) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby
DECLARE_INTERFACE_( IDirectPlayLobby, IUnknown )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

};

/****************************************************************************
 *
 * IDirectPlayLobby2 (and IDirectPlayLobby2A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby2
DECLARE_INTERFACE_( IDirectPlayLobby2, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby3 (and IDirectPlayLobby3A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby3
DECLARE_INTERFACE_( IDirectPlayLobby3, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;

    /*  IDirectPlayLobby3 Methods	*/
    STDMETHOD(ConnectEx)            (THIS_ DWORD, REFIID, LPVOID *, IUnknown FAR *) PURE;
    STDMETHOD(RegisterApplication)  (THIS_ DWORD, LPVOID) PURE;
    STDMETHOD(UnregisterApplication)(THIS_ DWORD, REFGUID) PURE;
    STDMETHOD(WaitForConnectionSettings)(THIS_ DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IDirectPlayLobby_Release(p)                         (p)->lpVtbl->Release(p)
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->lpVtbl->Connect(p,a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->lpVtbl->ConnectEx(p,a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->lpVtbl->CreateAddress(p,a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->lpVtbl->CreateCompoundAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->lpVtbl->EnumAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->lpVtbl->EnumAddressTypes(p,a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->lpVtbl->EnumLocalApplications(p,a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->lpVtbl->GetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->lpVtbl->ReceiveLobbyMessage(p,a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->lpVtbl->RegisterApplication(p,a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->lpVtbl->RunApplication(p,a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->lpVtbl->SendLobbyMessage(p,a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->lpVtbl->SetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->lpVtbl->SetLobbyMessageEvent(p,a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->lpVtbl->UnregisterApplication(p,a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->lpVtbl->WaitForConnectionSettings(p,a)

#else /* C++ */

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->QueryInterface(a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->AddRef()
#define IDirectPlayLobby_Release(p)                         (p)->Release()
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->Connect(a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->ConnectEx(a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->CreateAddress(a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->CreateCompoundAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->EnumAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->EnumAddressTypes(a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->EnumLocalApplications(a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->GetConnectionSettings(a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->ReceiveLobbyMessage(a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->RegisterApplication(a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->RunApplication(a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->SendLobbyMessage(a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->SetConnectionSettings(a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->SetLobbyMessageEvent(a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->UnregisterApplication(a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->WaitForConnectionSettings(a)

#endif

/****************************************************************************
 *
 * DirectPlayLobby Flags
 *
 ****************************************************************************/

/*
 *	This flag is used by IDirectPlayLobby->WaitForConnectionSettings to
 *	cancel a current wait that is in progress.
 */
#define DPLWAIT_CANCEL                  0x00000001


/*
 *	This is a message flag used by ReceiveLobbyMessage.  It can be
 *	returned in the dwMessageFlags parameter to indicate a message from
 *	the system.
 */
#define DPLMSG_SYSTEM					0x00000001

/*
 *	This is a message flag used by ReceiveLobbyMessage and SendLobbyMessage.
 *  It is used to indicate that the message is a standard lobby message.
 *  DPLMSG_SETPROPERTY, DPLMSG_SETPROPERTYRESPONSE, DPLMSG_GETPROPERTY,
 *	DPLMSG_GETPROPERTYRESPONSE
 */
#define DPLMSG_STANDARD					0x00000002

/*
 *  Lobbyable Application registration flags
 */

/*
 *  Applications registered with this flag will not show up when
 *  applications are enumerated in the lobby.  This application
 *  will only be able to be launched by a lobby client that already
 *  knows about the application.
 */
#define DPLAPP_NOENUM					0x80000000

/*
 *  Applications registered with this flag want voice to automatically
 *  be enabled for their application.  All players will be launched into
 *  an 'n'-way voice conference when the application is started.  The 
 *  user will be able to enable this flag for existing non-voice 
 *  directplay applications.
 */
#define DPLAPP_AUTOVOICE				0x00000001 

/*
 * Applications that do their own voice conferencing should register with
 * this flag to avoid allowing the user to enable other voice chat 
 * capabilites during the same session.  This is to avoid users forcing
 * the DPLAPP_AUTOVOICE flag for the application.
 */
#define DPLAPP_SELFVOICE				0x00000002 

/****************************************************************************
 *
 * DirectPlayLobby messages and message data structures
 *
 * All system messages have a dwMessageFlags value of DPLMSG_SYSTEM returned
 * from a call to ReceiveLobbyMessage.
 *
 * All standard messages have a dwMessageFlags value of DPLMSG_STANDARD returned
 * from a call to ReceiveLobbyMessage.
 *
 ****************************************************************************/

/*
 * DPLMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct _DPLMSG_GENERIC
{
    DWORD       dwType;         // Message type
} DPLMSG_GENERIC, FAR *LPDPLMSG_GENERIC;

/*
 * DPLMSG_SYSTEMMESSAGE
 * Generic message format for all system messages --
 * DPLSYS_CONNECTIONSETTINGSREAD, DPLSYS_DPLYCONNECTSUCCEEDED,
 * DPLSYS_DPLAYCONNECTFAILED, DPLSYS_APPTERMINATED, DPLSYS_NEWCONNECTIONSETTINGS
 */
typedef struct _DPLMSG_SYSTEMMESSAGE
{
    DWORD       dwType;         // Message type
    GUID        guidInstance;   // Instance GUID of the dplay session the message corresponds to
} DPLMSG_SYSTEMMESSAGE, FAR *LPDPLMSG_SYSTEMMESSAGE;

/*
 *  DPLMSG_SETPROPERTY
 *  Standard message sent by an application to a lobby to set a
 *  property
 */
typedef struct _DPLMSG_SETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID (DPL_NOCONFIRMATION if no confirmation desired)
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_SETPROPERTY, FAR *LPDPLMSG_SETPROPERTY;

#define	DPL_NOCONFIRMATION			0

/*
 *  DPLMSG_SETPROPERTYRESPONSE
 *  Standard message returned by a lobby to confirm a 
 *  DPLMSG_SETPROPERTY message.
 */
typedef struct _DPLMSG_SETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
} DPLMSG_SETPROPERTYRESPONSE, FAR *LPDPLMSG_SETPROPERTYRESPONSE;

/*
 *  DPLMSG_GETPROPERTY
 *  Standard message sent by an application to a lobby to request
 *	the current value of a property
 */
typedef struct _DPLMSG_GETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
} DPLMSG_GETPROPERTY, FAR *LPDPLMSG_GETPROPERTY;

/*
 *  DPLMSG_GETPROPERTYRESPONSE
 *  Standard message returned by a lobby in response to a
 *	DPLMSG_GETPROPERTY message.
 */
typedef struct _DPLMSG_GETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_GETPROPERTYRESPONSE, FAR *LPDPLMSG_GETPROPERTYRESPONSE;

/*
 *  DPLMSG_NEWSESSIONHOST
 *  Standard message returned by a lobby in response to a
 *	the session host migrating to a new client
 */
typedef struct _DPLMSG_NEWSESSIONHOST
{
    DWORD   dwType;             // Message type
    GUID    guidInstance;       // GUID Instance of the session
} DPLMSG_NEWSESSIONHOST, FAR *LPDPLMSG_NEWSESSIONHOST;


/******************************************
 *
 *	DirectPlay Lobby message dwType values
 *
 *****************************************/

/*
 *  The application has read the connection settings.
 *  It is now O.K. for the lobby client to release
 *  its IDirectPlayLobby interface.
 */
#define DPLSYS_CONNECTIONSETTINGSREAD   0x00000001

/*
 *  The application's call to DirectPlayConnect failed
 */
#define DPLSYS_DPLAYCONNECTFAILED       0x00000002

/*
 *  The application has created a DirectPlay session.
 */
#define DPLSYS_DPLAYCONNECTSUCCEEDED    0x00000003

/*
 *  The application has terminated.
 */
#define DPLSYS_APPTERMINATED            0x00000004

/*
 *  The message is a DPLMSG_SETPROPERTY message.
 */
#define DPLSYS_SETPROPERTY				0x00000005

/*
 *  The message is a DPLMSG_SETPROPERTYRESPONSE message.
 */
#define DPLSYS_SETPROPERTYRESPONSE		0x00000006

/*
 *  The message is a DPLMSG_GETPROPERTY message.
 */
#define DPLSYS_GETPROPERTY				0x00000007

/*
 *  The message is a DPLMSG_GETPROPERTYRESPONSE message.
 */
#define DPLSYS_GETPROPERTYRESPONSE		0x00000008

/*
 *  The message is a DPLMSG_NEWSESSIONHOST message.
 */
#define DPLSYS_NEWSESSIONHOST           0x00000009

/*
 *  New connection settings are available.
 */
#define DPLSYS_NEWCONNECTIONSETTINGS    0x0000000A

/*
 *  The Lobby Client has released the DirectPlayLobby Interface
 */
#define DPLSYS_LOBBYCLIENTRELEASE		0x0000000B

/****************************************************************************
 *
 * DirectPlay defined property GUIDs and associated data structures
 *
 ****************************************************************************/

/*
 * DPLPROPERTY_MessagesSupported
 *
 * Request whether the lobby supports standard.  Lobby with respond with either
 * TRUE or FALSE or may not respond at all.
 * 
 * Property data is a single BOOL with TRUE or FALSE
 */
// {762CCDA1-D916-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_MessagesSupported, 
0x762ccda1, 0xd916, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_LobbyGuid
 *
 * Request the GUID that identifies the lobby software that the application
 * is communicating with.
 *
 * Property data is a single GUID.
 */
// {F56920A0-D218-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_LobbyGuid, 
0xf56920a0, 0xd218, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_PlayerGuid
 *
 * Request the GUID that identifies the player on this machine for sending
 * property data back to the lobby.
 *
 * Property data is the DPLDATA_PLAYERDATA structure
 */
// {B4319322-D20D-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerGuid, 
0xb4319322, 0xd20d, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERGUID
 *
 * Data structure to hold the GUID of the player and player creation flags
 * from the lobby.
 */
typedef struct _DPLDATA_PLAYERGUID
{
	GUID	guidPlayer;
	DWORD	dwPlayerFlags;
} DPLDATA_PLAYERGUID, FAR *LPDPLDATA_PLAYERGUID;

/*
 * DPLPROPERTY_PlayerScore
 *
 * Used to send an array of long integers to the lobby indicating the 
 * score of a player.
 *
 * Property data is the DPLDATA_PLAYERSCORE structure.
 */
// {48784000-D219-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerScore, 
0x48784000, 0xd219, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERSCORE
 *
 * Data structure to hold an array of long integers representing a player score.
 * Application must allocate enough memory to hold all the scores.
 */
typedef struct _DPLDATA_PLAYERSCORE
{
	DWORD	dwScoreCount;
	LONG	Score[1];
} DPLDATA_PLAYERSCORE, FAR *LPDPLDATA_PLAYERSCORE;

/****************************************************************************
 *
 * DirectPlay Address ID's
 *
 ****************************************************************************/

/* DirectPlay Address
 *
 * A DirectPlay address consists of multiple chunks of data, each tagged
 * with a GUID signifying the type of data in the chunk. The chunk also
 * has a length so that unknown chunk types can be skipped.
 *
 * The EnumAddress() function is used to parse these address data chunks.
 */

/*
 * DPADDRESS
 *
 * Header for block of address data elements
 */
typedef struct _DPADDRESS
{
    GUID                guidDataType;
    DWORD               dwDataSize;
} DPADDRESS;

typedef DPADDRESS FAR *LPDPADDRESS;

/*
 * DPAID_TotalSize
 *
 * Chunk is a DWORD containing size of entire DPADDRESS structure
 */

// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * DPAID_ServiceProvider
 *
 * Chunk is a GUID describing the service provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_LobbyProvider
 *
 * Chunk is a GUID describing the lobby provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

/*
 * DPAID_Phone and DPAID_PhoneW
 *
 * Chunk is a string containing a phone number (i.e. "1-800-555-1212")
 * in ANSI or UNICODE format
 */

// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Modem and DPAID_ModemW
 *
 * Chunk is a string containing a modem name registered with TAPI
 * in ANSI or UNICODE format
 */

// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {01FD92E0-A2FF-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_ModemW, 
0x1fd92e0, 0xa2ff, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Inet and DPAID_InetW
 *
 * Chunk is a string containing a TCP/IP host name or an IP address
 * (i.e. "dplay.microsoft.com" or "137.55.100.173") in ANSI or UNICODE format
 */

// {C4A54DA0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_INet, 
0xc4a54da0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {E63232A0-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_INetW, 
0xe63232a0, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_InetPort
 *
 * Chunk is the port number used for creating the apps TCP and UDP sockets.
 * WORD value (i.e. 47624).
 */
 
// {E4524541-8EA5-11d1-8A96-006097B01411}
DEFINE_GUID(DPAID_INetPort, 
0xe4524541, 0x8ea5, 0x11d1, 0x8a, 0x96, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

#ifdef BIGMESSAGEDEFENSE
//@@BEGIN_MSINTERNAL
/*
 * DPAID_MaxMessageSize
 *
 * Tells DPLAY what the maximum allowed message size is.  Enables SPs to
 *	combat Denial of Service attacks
 */
 
 // this terrible hack is needed so the SP can work with the Elmer build.
 // it can be removed when the MSINTERNAL stuff is removed
 #define MAXMSGSIZEGUIDDEFINED

// {F5D09980-F0C4-11d1-8326-006097B01411}
DEFINE_GUID(DPAID_MaxMessageSize, 
0xf5d09980, 0xf0c4, 0x11d1, 0x83, 0x26, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
//@@END_MSINTERNAL
#endif

/*
 * DPCOMPORTADDRESS
 *
 * Used to specify com port settings. The constants that define baud rate,
 * stop bits and parity are defined in WINBASE.H. The constants for flow
 * control are given below.
 */

#define DPCPA_NOFLOW        0           // no flow control
#define DPCPA_XONXOFFFLOW   1           // software flow control
#define DPCPA_RTSFLOW       2           // hardware flow control with RTS
#define DPCPA_DTRFLOW       3           // hardware flow control with DTR
#define DPCPA_RTSDTRFLOW    4           // hardware flow control with RTS and DTR

typedef struct _DPCOMPORTADDRESS
{
    DWORD   dwComPort;                  // COM port to use (1-4)
    DWORD   dwBaudRate;                 // baud rate (100-256k)
    DWORD   dwStopBits;                 // no. stop bits (1-2)
    DWORD   dwParity;                   // parity (none, odd, even, mark)
    DWORD   dwFlowControl;              // flow control (none, xon/xoff, rts, dtr)
} DPCOMPORTADDRESS;

typedef DPCOMPORTADDRESS FAR *LPDPCOMPORTADDRESS;

/*
 * DPAID_ComPort
 *
 * Chunk contains a DPCOMPORTADDRESS structure defining the serial port.
 */

// {F2F0CE00-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ComPort, 
0xf2f0ce00, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * 	dplobby 1.0 obsolete definitions
 *	Included for compatibility only.
 *
 ****************************************************************************/
#define DPLAD_SYSTEM          DPLMSG_SYSTEM


#ifdef __cplusplus
};
#endif /* __cplusplus */

#pragma warning(default:4201)

#endif /* __DPLOBBY_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplobbyi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobbyi.h
 *  Content:    DirectPlayLobby internal include file
 *
 *  History:
 *	Date		By		Reason
 *	===========	=======	==========
 *	2/25/97		myronth	Created it
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Added Connection & Session Management stuff plus
 *						a few forward declarations for internal objects
 *	3/17/97		myronth	Create/DestroyGroup/Player
 *	3/20/97		myronth	AddPlayerToGroup, DeletePlayerFromGroup
 *	3/21/97		myronth	SetGroup/PlayerName, Get/SetGroup/PlayerData
 *	3/25/97		kipo	EnumConnections takes a const *GUID now
 *	3/31/97		myronth	Send
 *	4/10/97		myronth	GetCaps, GetPlayerCaps
 *	5/8/97		myronth	Subgroup functions, GroupConnSettings, StartSession,
 *						Purged dead code
 *	5/13/97		myronth	Pass credentials to PRV_Open, pass them on to the LP
 *	5/17/97		myronth	SendChatMessage
 *	8/19/97		myronth	More prototypes for sending standard lobby messages
 *	8/19/97		myronth	Removed prototypes for dead functions
 *	9/29/97		myronth	Added PRV_ConvertDPLCONNECTIONToAnsiInPlace prototype
 *	10/29/97	myronth	Added group owner ID to create group methods, exposed
 *						map table functions, exposed group owner methods
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97	myronth	Added functions for asynchronous Connect (#12541)
 *	11/20/97	myronth	Made EnumConnections & DirectPlayEnumerate 
 *						drop the lock before calling the callback (#15208)
 *	1/20/98		myronth	Moved PRV_SendStandardSystemMessage into this file
 ***************************************************************************/
#ifndef __DPLOBBYI_INCLUDED__
#define __DPLOBBYI_INCLUDED__


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------
#ifndef DPLAPI
#define DPLAPI WINAPI
#endif

typedef struct DPLOBBYI_DPLOBJECT * LPDPLOBBYI_DPLOBJECT;
typedef struct LSPNODE * LPLSPNODE;

#define DPLOBBYPR_GAMEID				0

// Forward declarations needed because of the include file order in DPlay
typedef struct _DPLAYI_DPLAY * LPDPLAYI_DPLAY;

//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------
extern LPLSPNODE	glpLSPHead;			// In dplenum.c

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------

// create.c
extern HRESULT PRV_AllocateLobbyObject(LPDPLAYI_DPLAY, LPDPLOBBYI_DPLOBJECT *);

// dplenum.c
extern void PRV_FreeLSPList(LPLSPNODE);
extern HRESULT PRV_EnumConnections(LPCGUID, LPDPENUMCONNECTIONSCALLBACK,
									LPVOID, DWORD, BOOL);

// dplobby.c
extern HRESULT DPLAPI PRV_GetCaps(LPDPLOBBYI_DPLOBJECT, DWORD, LPDPCAPS);
extern BOOL PRV_GetConnectPointers(LPDIRECTPLAYLOBBY, LPDIRECTPLAY2 *, LPDPLCONNECTION *);
extern void PRV_SaveConnectPointers(LPDIRECTPLAYLOBBY, LPDIRECTPLAY2, LPDPLCONNECTION);
extern BOOL PRV_IsAsyncConnectOn(LPDIRECTPLAYLOBBY);
void PRV_TurnAsyncConnectOn(LPDIRECTPLAYLOBBY);
void PRV_TurnAsyncConnectOff(LPDIRECTPLAYLOBBY);

// dplobbya.c
extern HRESULT DPLAPI DPL_A_GetGroupConnectionSettings(LPDIRECTPLAY,
						DWORD, DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI DPL_A_SetGroupConnectionSettings(LPDIRECTPLAY,
						DWORD, DPID, LPDPLCONNECTION);

// dplpack.c
extern void PRV_FixupDPLCONNECTIONPointers(LPDPLCONNECTION);
extern HRESULT PRV_ConvertDPLCONNECTIONToAnsiInPlace(LPDPLCONNECTION, LPDWORD, DWORD);

// dplshare.c
extern HRESULT PRV_SendStandardSystemMessage(LPDIRECTPLAYLOBBY, DWORD, DWORD);

// dplunk.c
extern HRESULT PRV_DestroyDPLobby(LPDPLOBBYI_DPLOBJECT);
extern void PRV_FreeAllLobbyObjects(LPDPLOBBYI_DPLOBJECT);

// group.c
extern HRESULT DPLAPI PRV_AddGroupToGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_AddPlayerToGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_CreateGroup(LPDPLOBBYI_DPLOBJECT,
			LPDPID, LPDPNAME, LPVOID, DWORD, DWORD, DPID);
extern HRESULT DPLAPI PRV_CreateGroupInGroup(LPDPLOBBYI_DPLOBJECT, DPID,
			LPDPID, LPDPNAME, LPVOID, DWORD, DWORD, DPID);
extern HRESULT DPLAPI PRV_DeleteGroupFromGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_DeletePlayerFromGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_DestroyGroup(LPDPLOBBYI_DPLOBJECT, DPID);
extern HRESULT DPLAPI DPL_GetGroupConnectionSettings(LPDIRECTPLAY, DWORD,
			DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI PRV_GetGroupData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI DPL_SetGroupConnectionSettings(LPDIRECTPLAY, DWORD,
			DPID, LPDPLCONNECTION);
extern HRESULT DPLAPI DPL_GetGroupOwner(LPDIRECTPLAY, DPID, LPDPID);
extern HRESULT DPLAPI PRV_SetGroupData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, DWORD, DWORD);
extern HRESULT DPLAPI PRV_SetGroupName(LPDPLOBBYI_DPLOBJECT, DPID, LPDPNAME, DWORD);
extern HRESULT DPLAPI DPL_SetGroupOwner(LPDIRECTPLAY, DPID, DPID);
extern HRESULT DPLAPI DPL_StartSession(LPDIRECTPLAY, DWORD, DPID);

// player.c
extern HRESULT DPLAPI PRV_CreatePlayer(LPDPLOBBYI_DPLOBJECT,
			LPDPID, LPDPNAME, HANDLE, LPVOID, DWORD, DWORD);
extern HRESULT DPLAPI PRV_DestroyPlayer(LPDPLOBBYI_DPLOBJECT, DPID);
extern HRESULT DPLAPI PRV_GetPlayerCaps(LPDPLOBBYI_DPLOBJECT, DWORD, DPID, LPDPCAPS);
extern HRESULT DPLAPI PRV_GetPlayerData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI PRV_Send(LPDPLOBBYI_DPLOBJECT, DPID, DPID, DWORD, LPVOID, DWORD);
extern HRESULT DPLAPI PRV_SendChatMessage(LPDPLOBBYI_DPLOBJECT, DPID, DPID, DWORD, LPDPCHAT);
extern HRESULT DPLAPI PRV_SetPlayerData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, DWORD, DWORD);
extern HRESULT DPLAPI PRV_SetPlayerName(LPDPLOBBYI_DPLOBJECT, DPID, LPDPNAME, DWORD);
extern BOOL PRV_GetDPIDByLobbyID(LPDPLOBBYI_DPLOBJECT, DWORD, DPID *);
extern BOOL PRV_GetLobbyIDByDPID(LPDPLOBBYI_DPLOBJECT, DPID, LPDWORD);
extern HRESULT PRV_AddMapIDNode(LPDPLOBBYI_DPLOBJECT, DWORD, DPID);
extern BOOL PRV_DeleteMapIDNode(LPDPLOBBYI_DPLOBJECT, DWORD);

// server.c
extern HRESULT PRV_LoadSP(LPDPLOBBYI_DPLOBJECT, LPGUID, LPVOID, DWORD);
extern BOOL FAR PASCAL PRV_FindLPGUIDInAddressCallback(REFGUID, DWORD,
							LPCVOID, LPVOID);

// session.c
extern HRESULT DPLAPI PRV_Close(LPDPLOBBYI_DPLOBJECT);
extern HRESULT DPLAPI PRV_EnumSessions(LPDPLOBBYI_DPLOBJECT, LPDPSESSIONDESC2, DWORD, DWORD);
extern HRESULT DPLAPI PRV_GetSessionDesc(LPDPLOBBYI_DPLOBJECT);
extern HRESULT DPLAPI PRV_Open(LPDPLOBBYI_DPLOBJECT, LPDPSESSIONDESC2, DWORD, LPCDPCREDENTIALS);
extern HRESULT DPLAPI PRV_SetSessionDesc(LPDPLOBBYI_DPLOBJECT);

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#endif // __DPLOBBYI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplobpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobpr.h
 *  Content:	DirectPlayLobby private header file
 *  History:
 *	Date		By		Reason
 *	====		==		======
 *	4/13/96		myronth	created it
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *	10/23/96	myronth	added client/server methods
 *	11/20/96	myronth	Added Implemented Logon/LogoffServer
 *	12/12/96	myronth	Added validation macros for DPSESSIONDESC2 and DPNAME
 *	1/2/97		myronth	Added wrappers for CreateAddress and EnumAddress
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	2/20/97		myronth	Changed buffer R/W to be circular
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Added LP node stuff, initial async enumsessions
 *	3/13/97		myronth	Changed reg key, other bug fixes
 *	3/17/97		myronth	Added ID map table to lobby object
 *	3/21/97		myronth	Removed unnecessary response function prototypes
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	3/31/97		myronth	Removed dead code, Added IDPLobbySP methods
 *	4/3/97		myronth	Added dplaypr.h dependency, removed dplayi.h dep,
 *						Removed all duplicated code with dplaypr.h, cleaned
 *						up a bunch of dead code
 *	4/4/97		myronth	Changed IDPLobbySP methods' structure names
 *	5/8/97		myronth	Added packed connection header, subgroup function
 *						prototypes
 *	5/12/97		myronth	Added lobby system player
 *	5/17/97		myronth	SendChatMessage function prototype for IDPLobbySP
 *	5/17/97		myronth	Added parent ID to CreateAndMapNewGroup
 *	5/20/97		myronth	Added PRV_DeleteRemotePlayerFromGroup prototype
 *	5/22/97		myronth	Added DPLP_DestroyGroup prototype
 *	6/3/97		myronth	Added PRV_DestroySubgroups and PRV_RemoveSubgroups-
 *						AndPlayersFromGroup function prototypes
 *	6/6/97		myronth	Added prototypes for PRV_DestroyGroupAndParents and
 *						PRV_DeleteRemoteGroupFromGroup
 *	6/16/97		myronth	Added prototype for PRV_SendDeleteShortcutMessage-
 *						ForExitingGroup
 *	7/30/97		myronth	Added support for standard lobby messaging
 *	8/11/97		myronth	Added guidInstance to GameNode struct, added internal
 *						flad indicating we slammed this guid in a request
 *	8/22/97		myronth	Added Desciptions & flags to LSPNODE structure
 *	9/29/97		myronth	Added prototypes for PRV_SendName/DataChangedMessageLocally
 *	10/7/97		myronth	Added LP version to lobby struct
 *	10/23/97	myronth	Added lpStopParent group parameter to DeleteGroupAndParents
 *						and DeleteRemoteGroupFromGroup (#12885)
 *	10/29/97	myronth	Changed and added internal prototypes for group owners
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97	myronth	Added stuff for asynchronous Connect (#12541)
 *	12/2/97		myronth	Added IDPLobby3 interface, Register/UnregisterApp
 *	12/4/97		myronth	Added ConnectEx
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	1/25/98		sohailm	Added #define for CSTR_EQUAL (we define it if it's not already defined)
 *	6/25/98		a-peterz Added DPL_A_ConnectEx
 *  10/22/99	aarono  added support for application flags
 *  02/08/00    aarono  added pid to ipc struct to allow monitoring by app.
 ***************************************************************************/
#ifndef __DPLOBPR_INCLUDED__
#define __DPLOBPR_INCLUDED__

#include <windows.h>
#include "dpmem.h"
#include "dpf.h"
#include "dplobby.h"
#include "dpneed.h"
#include "dpos.h"
#include "lobbysp.h"
#include "dplaypr.h"
#include "dpmess.h"

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------
typedef struct IDirectPlayLobbyVtbl DIRECTPLAYLOBBYCALLBACKS;
typedef DIRECTPLAYLOBBYCALLBACKS * LPDIRECTPLAYLOBBYCALLBACKS;
// Right now the ASCII Vtbl is the same (by definition), but we may need
// to change it in the future, so let's use this structure
typedef struct IDirectPlayLobbyVtbl DIRECTPLAYLOBBYCALLBACKSA;
typedef DIRECTPLAYLOBBYCALLBACKSA * LPDIRECTPLAYLOBBYCALLBACKSA;

typedef struct IDirectPlayLobby2Vtbl DIRECTPLAYLOBBYCALLBACKS2;
typedef DIRECTPLAYLOBBYCALLBACKS2 * LPDIRECTPLAYLOBBYCALLBACKS2;
// Right now the ASCII Vtbl is the same (by definition), but we may need
// to change it in the future, so let's use this structure
typedef struct IDirectPlayLobby2Vtbl DIRECTPLAYLOBBYCALLBACKS2A;
typedef DIRECTPLAYLOBBYCALLBACKS2A * LPDIRECTPLAYLOBBYCALLBACKS2A;

typedef struct IDirectPlayLobby3Vtbl DIRECTPLAYLOBBYCALLBACKS3;
typedef DIRECTPLAYLOBBYCALLBACKS3 * LPDIRECTPLAYLOBBYCALLBACKS3;
// Right now the ASCII Vtbl is the same (by definition), but we may need
// to change it in the future, so let's use this structure
typedef struct IDirectPlayLobby3Vtbl DIRECTPLAYLOBBYCALLBACKS3A;
typedef DIRECTPLAYLOBBYCALLBACKS3A * LPDIRECTPLAYLOBBYCALLBACKS3A;

typedef struct IDPLobbySPVtbl DIRECTPLAYLOBBYSPCALLBACKS;
typedef DIRECTPLAYLOBBYSPCALLBACKS * LPDIRECTPLAYLOBBYSPCALLBACKS;

//--------------------------------------------------------------------------
//
//	DPLobby SP Node stuff
//
//--------------------------------------------------------------------------

//	DirectPlay Service Provider for DPLobby
//	{4AF206E0-9712-11cf-A021-00AA006157AC}
DEFINE_GUID(GUID_DirectPlaySP, 0x4af206e0, 0x9712, 0x11cf, 0xa0, 0x21, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);

// This is where the service provider info read from
// the registry is kept
typedef struct LSPNODE
{
	LPWSTR		lpwszName;
	LPWSTR		lpwszPath;
	GUID		guid;
	DWORD		dwReserved1;
	DWORD		dwReserved2;
	DWORD		dwNodeFlags;
	LPSTR		lpszDescA;
	LPWSTR		lpwszDesc;
	struct LSPNODE * lpNext;
} LSPNODE, * LPLSPNODE;

#define LSPNODE_DESCRIPTION		(0x00000001)
#define LSPNODE_PRIVATE			(0x00000002)

//--------------------------------------------------------------------------
//
//	DirectPlayLobby Stuff
//
//--------------------------------------------------------------------------

// Forward declarations for pointers to these two structs
typedef struct DPLOBBYI_INTERFACE * LPDPLOBBYI_INTERFACE;
typedef struct DPLOBBYI_DPLOBJECT * LPDPLOBBYI_DPLOBJECT;

// This is a structure represent each interface on our DPLobby object
typedef struct DPLOBBYI_INTERFACE
{
// REVIEW!!!! -- Why isn't this strongly typed????
//	LPDIRECTPLAYLOBBYCALLBACKS	lpVtbl;
	LPVOID						lpVtbl;
	LPDPLOBBYI_DPLOBJECT		lpDPLobby;
	LPDPLOBBYI_INTERFACE		lpNextInterface;	// Next interface on DPLobby object
	DWORD 						dwIntRefCnt;		// Ref count for this interface
} DPLOBBYI_INTERFACE;

// This structure represents a message node for messages sent between the
// lobby client & the game using Send/ReceiveLobbyMessage
typedef struct DPLOBBYI_MESSAGE
{
	DWORD		dwFlags;				// Flags pertinent to the data in the message
	DWORD		dwSize;					// Size of the data
	LPVOID		lpData;					// Pointer to the data
	struct DPLOBBYI_MESSAGE * lpPrev;	// Pointer to the previous message
	struct DPLOBBYI_MESSAGE * lpNext;	// Pointer to the next message
} DPLOBBYI_MESSAGE, * LPDPLOBBYI_MESSAGE;

// This represents an entry in our ID map table
typedef struct DPLOBBYI_MAPIDNODE
{
	DWORD		dwLobbyID;
	DPID		dpid;
} DPLOBBYI_MAPIDNODE, * LPDPLOBBYI_MAPIDNODE;

// This structure represents each game launched by the lobby client
typedef struct DPLOBBYI_GAMENODE
{
	DWORD		dwSize;					// Size of this structure
	DWORD		dwFlags;				// Flags relevant to the GameNode
	DWORD		dwGameProcessID;		// Process ID of Game spun off (in lobbyclient)
	HANDLE		hGameProcess;			// Process Hande for the Game spun off (in lobbyclient)
	DWORD		dwLobbyClientProcessID; // Process ID of lobby client (in a game)
	HANDLE      hLobbyClientProcess;    // Process Handle for the client (in a game)
	GUID        guidIPC;                // IPC guid for handling ripple launch case
	HANDLE		hTerminateThread;		// Handle to the Terminate monitor thread
	HANDLE		hKillTermThreadEvent;	// Handle of an event used to kill the monitor thread
	DPLOBBYI_MESSAGE	MessageHead;	// Message queue head
	DWORD		dwMessageCount;			// Count of messages in the queue

	// Connection settings shared memory buffer related stuff	
	HANDLE		hConnectDataMutex;		// Mutex for write access to connect data buffer
	HANDLE		hConnectDataFile;		// File handle for game data buffer
	LPVOID		lpConnectDataBuffer;	// Pointer to game data buffer	

	// Game settings shared memory buffer related stuff	
	HANDLE		hGameWriteFile;			// File handle for game write buffer
	LPVOID		lpGameWriteBuffer;		// Pointer to game write buffer	
	HANDLE		hGameWriteEvent;		// Handle to GameWriteEvent
	HANDLE		hGameWriteMutex;		// Handle to GameWrite Mutex

	HANDLE		hLobbyWriteFile;		// File handle for lobby write buffer
	LPVOID		lpLobbyWriteBuffer;		// Pointer to lobby write buffer	
	HANDLE		hLobbyWriteEvent;		// Handle to LobbyWrite Event
	HANDLE		hLobbyWriteMutex;		// Handle to LobbyWrite Mutex

	HANDLE		hReceiveThread;			// Handle to the Receive thread
	HANDLE		hDupReceiveEvent;		// Duplicate Handle of Caller's Event
	HANDLE		hKillReceiveThreadEvent;// Handle of an event used to kill receive thread

	LPDPLOBBYI_DPLOBJECT	this;		// Back pointer to the DPLobby object
	struct DPLOBBYI_GAMENODE * lpgnNext;// Pointer to the next GameNode in the list

	// Pointer to the dplay object which has a connection to the lobby server
	// and the ID of the player that received the start session message
	LPDPLAYI_DPLAY	lpDPlayObject;
	DPID			dpidPlayer;
	GUID			guidInstance;		// Instance guid for the game

} DPLOBBYI_GAMENODE, *LPDPLOBBYI_GAMENODE;

// This is used to keep track of Property requests made via SendLobbyMessage
typedef struct DPLOBBYI_REQUESTNODE
{
	DWORD		dwFlags;					// GN_* flags
	DWORD		dwRequestID;				// Internal Request ID
	DWORD		dwAppRequestID;				// Request ID passed in by the app
	LPDPLOBBYI_GAMENODE	lpgn;				// Pointer to a Game Node
	struct DPLOBBYI_REQUESTNODE * lpPrev;	// Pointer to the previous request node
	struct DPLOBBYI_REQUESTNODE * lpNext;	// Pointer to the next request node

} DPLOBBYI_REQUESTNODE, * LPDPLOBBYI_REQUESTNODE;

// This is the DirectPlayLobby object
typedef struct DPLOBBYI_DPLOBJECT
{
	DWORD						dwSize;				// Size of this structure
	LPDPLOBBYI_INTERFACE		lpInterfaces;		// List of interface on this object
    DWORD						dwRefCnt;			// Reference Count for the object
    DWORD						dwFlags;			// DPLOBBYPR_xxx
	HINSTANCE					hInstanceLP;		// Lobby Provider DLL's hInstance
    LPSP_CALLBACKS				pcbSPCallbacks;		// SP entry points
	LPVOID						lpSPData;			// SP-specific blob storage
	LPDPLOBBYI_GAMENODE			lpgnHead;			// Head node for all launched games

	LPDPLAYI_DPLAY				lpDPlayObject;		// Back pointer to aggregate DPlay object
	LPDPLOBBYI_MAPIDNODE		lpMap;				// Pointer to the ID map table
	DWORD						dwTotalMapEntries;	// Number of total entries in the map table
	DWORD						dwMapEntries;		// Number of used entries in the map table
	DPID						dpidSysPlayer;		// ID of the lobby's system player

	LPDPLOBBYI_REQUESTNODE		lprnHead;			// Head node for all property requests
	DWORD						dwCurrentRequest;	// ID of the next request

	DWORD						dwLPVersion;		// Version of the lobby provider

	LPDIRECTPLAY2				lpDP2;				// DPlay2 interface pointer used by async DP_Connect
	LPDPLCONNECTION				lpConn;				// DPLCONNECTION pointer used by async DP_Connect
} DPLOBBYI_DPLOBJECT;

typedef struct DPLOBBYI_BUFFERCONTROL
{
	DWORD		dwToken;		// Set by the lobby client
	DWORD		dwReadOffset;	// Offset of the read cursor (relative to this structure)
	DWORD		dwWriteOffset;	// Offset of the write cursor (relative to this structure)
	DWORD		dwFlags;		// Flags for this buffer
	DWORD		dwMessages;		// Number of messages in the buffer
	DWORD		dwBufferSize;	// Size of the entire buffer
	DWORD		dwBufferLeft;	// Number of free bytes left in the buffer
} DPLOBBYI_BUFFERCONTROL, * LPDPLOBBYI_BUFFERCONTROL;

typedef struct DPLOBBYI_CONNCONTROL
{
	DWORD		dwToken;		// Set by the lobby client
	DWORD		dwFlags;		// Flags for this buffer
	DWORD		CliProcId;		// Lobby client's process Id so we can see if it crashes.
} DPLOBBYI_CONNCONTROL, * LPDPLOBBYI_CONNCONTROL;

typedef struct DPLOBBYI_MESSAGEHEADER
{
	DWORD		dwSize;
	DWORD		dwFlags;
} DPLOBBYI_MESSAGEHEADER, * LPDPLOBBYI_MESSAGEHEADER;

typedef struct DPLOBBYI_PACKEDCONNHEADER
{
	DWORD		dwUnicodeSize;
	DWORD		dwAnsiSize;
} DPLOBBYI_PACKEDCONNHEADER, * LPDPLOBBYI_PACKEDCONNHEADER;

typedef struct CONNECTINFO
{
	GUID		guidApplication;
	GUID        guidIPC;
	LPWSTR		lpszName;
	LPWSTR		lpszFile;
	LPWSTR		lpszPath;
	LPWSTR		lpszCommandLine;
	LPWSTR		lpszCurrentDir;
	LPWSTR      lpszAppLauncherName;
} CONNECTINFO, * LPCONNECTINFO;

// This is used for messaging during the StartGame method
typedef struct DPLOBBYI_STARTGAME
{
	DWORD		dwFlags;
	HRESULT		hr;
} DPLOBBYI_STARTGAME, * LPDPLOBBYI_STARTGAME;

//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------

// These two entries are only used by dplos.c.  They can be removed if we
// generalize these functions between DPlay & DPLobby
#define DPLAY_MAX_FILENAMELEN	512
#define DPLOBBY_DEFAULT_CHAR	"-"

#define DPLOBBYPR_DEFAULTMAPENTRIES		100

#define DPLOBBYPR_SIZE_HANDLEMESSAGE_DX50	20

// Note, the 'L' Macro makes these strings Unicode (the TEXT macro uses L also)
#define SZ_DPLAY_APPS_KEY	L"Software\\Microsoft\\DirectPlay\\Applications"
#define SZ_DPLAY_SP_KEY		L"Software\\Microsoft\\DirectPlay\\Service Providers"
#define SZ_DPLOBBY_SP_KEY	L"Software\\Microsoft\\DirectPlay\\Lobby Providers"
#define SZ_ADDRESS_TYPES	L"Address Types"
#define SZ_GUID				L"Guid"
#define SZ_PATH				L"Path"
#define SZ_DESCRIPTIONA		L"DescriptionA"
#define SZ_DESCRIPTIONW		L"DescriptionW"
#define SZ_PRIVATE			L"Private"
#define SZ_FILE				L"File"
#define SZ_LAUNCHER         L"Launcher"
#define SZ_MAJORVERSION		L"Major Version"
#define SZ_MINORVERSION		L"Minor Version"
#define SZ_DWRESERVED1		L"dwReserved1"
#define SZ_DWRESERVED2		L"dwReserved2"
#define SZ_COMMANDLINE		L"CommandLine"
#define SZ_CURRENTDIR		L"CurrentDirectory"
#define SZ_BACKSLASH		L"\\"
#define SZ_SPACE			L" "
#define SZ_SP_FOR_DPLAY		L"dpldplay.dll"
#define SZ_DP_IPC_GUID      L"/dplay_ipc_guid:"
#define SZ_GUID_PROTOTYPE   L"{01020304-0506-0708-090A-0B0C0D0E0F10}"
#define SZ_DWFLAGS          L"dwFlags"

// The following #defines are all for the shared buffers and control
// elements used by the lobby methods for communication between
// a lobby client and a game
#define MAX_PID_LENGTH				(10)
#define	MAX_MMFILENAME_LENGTH		(_MAX_FNAME + MAX_PID_LENGTH)
#define SZ_FILENAME_BASE			L"DPLobby"
#define SZ_CONNECT_DATA_FILE		L"ConnectDataSharedMemory"
#define SZ_CONNECT_DATA_MUTEX		L"ConnectDataMutex"
#define SZ_GAME_WRITE_FILE			L"GameWriteSharedMemory"
#define SZ_GAME_WRITE_EVENT			L"GameWriteEvent"
#define SZ_GAME_WRITE_MUTEX			L"GameWriteMutex"
#define SZ_LOBBY_WRITE_FILE			L"LobbyWriteSharedMemory"
#define SZ_LOBBY_WRITE_EVENT		L"LobbyWriteEvent"
#define SZ_LOBBY_WRITE_MUTEX		L"LobbyWriteMutex"
#define SZ_NAME_TEMPLATE			L"%s-%s-%u"
#define SZ_GUID_NAME_TEMPLATE       L"%s-%s-"

#define TYPE_CONNECT_DATA_FILE		1
#define TYPE_CONNECT_DATA_MUTEX		2
#define TYPE_GAME_WRITE_FILE		3
#define TYPE_LOBBY_WRITE_FILE		4
#define TYPE_LOBBY_WRITE_EVENT		5
#define TYPE_GAME_WRITE_EVENT		7
#define TYPE_LOBBY_WRITE_MUTEX		9
#define TYPE_GAME_WRITE_MUTEX		10



// If this flag is set, the Lobby object has been registered with a lobby
// server.  Some methods require the client to be registered.
#define DPLOBBYPR_REGISTERED			0x00000010

// If this flag is set, we have allocated an IDPLobbySP interface
#define DPLOBBYPR_SPINTERFACE			0x00000020

// If this flag is set, the app has called Connect with the async flag
#define DPLOBBYPR_ASYNCCONNECT			0x00000040

// Message flags
#define DPLOBBYPR_MESSAGE_SYSTEM		0x00000001
#define DPLOBBYPR_INTERNALMESSAGEFLAGS	(0x00000000) // This will change

// HRESULT used by EnumLocalApplication to denote a callback return of
// FALSE (internally, of course)
#define DPLOBBYPR_CALLBACKSTOP			(0xFFFFFFFF)

// Transport Flags
#define DPLOBBYPR_DPLAYSP				(0x00000001)

// Default Timeout value (15 seconds)
#define DPLOBBYPR_DEFAULTTIMEOUT		(15000)

//
// GameNode Flags
//
// If this flag is set, the calling application is a lobby client and not
// a game.  The user shouldn't even set this, but we should be able to
// figure it out from the connection method.  Use this flag to distinguish
// when to "Create" the memory-mapped files, or when to "Open" them.
#define GN_LOBBY_CLIENT					(0x00000001)

// The memory mapped files are available and ready for use
#define GN_SHARED_MEMORY_AVAILABLE		(0x00000002)

// Used to denote when an application's process has gone away.
#define GN_DEAD_GAME_NODE				(0x00000004)

// These two flags determine whether the game was lobby client launched or
// self-lobbied.  If neither of these are set, the game was lobby client
// launched, and the flag is set on the lobby client side (not on the game side)
#define GN_CLIENT_LAUNCHED				(0x00000008)
#define GN_SELF_LOBBIED					(0x00000010)

// This flag is used to identify whether the guidInstance for the game
// was exchanged for GUID_NULL in the guidPlayer field of a Get/SetProperty
// lobby system message.
#define GN_SLAMMED_GUID					(0x00000020)

// This flag is set when the guidIPC field of the game node has been set
// either because we are a lobby client that ripple launched or it was
// on the application's command line.
#define GN_IPCGUID_SET					(0x00000040)
//
// BufferControl Flags
//
// Flags used by the dwFlags member of the BUFFERCONTROL struct
#define BC_LOBBY_ACTIVE					(0x00000001)
#define BC_GAME_ACTIVE					(0x00000002)
#define BC_WAIT_MODE					(0x00000004)
#define BC_PENDING_CONNECT				(0x00000008)

#define BC_TOKEN						(0xFEEDFACE)

#ifndef CSTR_EQUAL
#define CSTR_EQUAL	2
#endif

//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------

// The vtable!
extern DIRECTPLAYLOBBYCALLBACKS		dplCallbacks;
extern DIRECTPLAYLOBBYCALLBACKSA	dplCallbacksA;
extern DIRECTPLAYLOBBYCALLBACKS2	dplCallbacks2;
extern DIRECTPLAYLOBBYCALLBACKS2A	dplCallbacks2A;
extern DIRECTPLAYLOBBYCALLBACKS3	dplCallbacks3;
extern DIRECTPLAYLOBBYCALLBACKS3A	dplCallbacks3A;
extern DIRECTPLAYLOBBYSPCALLBACKS	dplCallbacksSP;

//--------------------------------------------------------------------------
//
//	Macros, etc.
//
//--------------------------------------------------------------------------

// Our own hard-coded break
#define DEBUGBREAK() _asm { int 3 }

#define DPLOBJECT_FROM_INTERFACE(ptr) (((LPDPLOBBYI_INTERFACE)ptr)->lpDPLobby)

#define DPLOBBY_REGISTRY_NAMELEN	512

// Crit section
extern LPCRITICAL_SECTION gpcsDPLCritSection;		// defined in dllmain.c
extern LPCRITICAL_SECTION gpcsDPLQueueCritSection;	// also in dllmain.c
extern LPCRITICAL_SECTION gpcsDPLGameNodeCritSection;	// also in dllmain.c


// Validation macros
#define VALID_DPLOBBY_INTERFACE( ptr ) \
        (!IsBadWritePtr(ptr, sizeof(DPLOBBYI_INTERFACE)) && \
        ((((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacksA) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks2) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks2A) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks3) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks3A) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacksSP)))

#define VALID_DPLOBBY_PTR(ptr) \
        (!IsBadWritePtr(ptr, sizeof(DPLOBBYI_DPLOBJECT)) && \
        (ptr->dwSize == sizeof(DPLOBBYI_DPLOBJECT)))

#define VALID_UUID_PTR(ptr) \
        (ptr && !IsBadWritePtr( ptr, sizeof(UUID)))

#define VALID_READ_UUID_PTR(ptr) \
        (ptr && !IsBadReadPtr( ptr, sizeof(UUID)))

#define VALID_DPLOBBY_CONNECTION( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPLCONNECTION)) && \
        (ptr->dwSize == sizeof(DPLCONNECTION)))

#define VALID_DPLOBBY_APPLICATIONDESC( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPAPPLICATIONDESC)) && \
        (ptr->dwSize == sizeof(DPAPPLICATIONDESC)))

#define VALID_DPLOBBY_APPLICATIONDESC2( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPAPPLICATIONDESC2)) && \
        (ptr->dwSize == sizeof(DPAPPLICATIONDESC2)))

#define IS_DPLOBBY_APPLICATIONDESC2(ptr) \
		(ptr->dwSize == sizeof(DPAPPLICATIONDESC2))

#define VALID_DPLOGONINFO( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPLOGONINFO)) && \
        (ptr->dwSize == sizeof(DPLOGONINFO)))

#define VALID_DPLOBBY_SP_LOADED( ptr ) \
		(ptr->pcbSPCallbacks)

#define VALID_SENDLOBBYMESSAGE_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPLMSG_STANDARD) \
		) )

#define VALID_WAIT_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPLWAIT_CANCEL) \
		) )

#define VALID_REGISTERAPP_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPLAPP_NOENUM | \
                    DPLAPP_AUTOVOICE  | \
                    DPLAPP_SELFVOICE ) \
		) )


#define IS_GAME_DEAD(lpgn) \
		(lpgn->dwFlags & GN_DEAD_GAME_NODE)

#define CALLBACK_EXISTS(fn)	(((LPSP_CALLBACKS)this->pcbSPCallbacks)->fn)

#define CALL_LP(ptr,fn,pdata) (((LPSP_CALLBACKS)ptr->pcbSPCallbacks)->fn(pdata))

#define DPLAPI WINAPI

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------

// convert.c
HRESULT PRV_ConvertDPLCONNECTIONToUnicode(LPDPLCONNECTION, LPDPLCONNECTION *);

// dplunk.c
extern HRESULT 	DPLAPI DPL_QueryInterface(LPDIRECTPLAYLOBBY,
								REFIID riid, LPVOID * ppvObj);
extern ULONG	DPLAPI DPL_AddRef(LPDIRECTPLAYLOBBY);  
extern ULONG 	DPLAPI DPL_Release(LPDIRECTPLAYLOBBY); 

LPDPLOBBYSP PRV_GetDPLobbySPInterface(LPDPLOBBYI_DPLOBJECT);
HRESULT PRV_GetInterface(LPDPLOBBYI_DPLOBJECT, LPDPLOBBYI_INTERFACE *, LPVOID);

// dplgame.c
extern HRESULT	DPLAPI DPL_RunApplication(LPDIRECTPLAYLOBBY, DWORD,
						LPDWORD, LPDPLCONNECTION, HANDLE);

BOOL PRV_FindGameInRegistry(LPGUID, LPWSTR, DWORD, HKEY *);

// dplenum.c
extern HRESULT	DPLAPI DPL_EnumLocalApplications(LPDIRECTPLAYLOBBY,
					LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD);
extern HRESULT	DPLAPI DPL_EnumAddressTypes(LPDIRECTPLAYLOBBY,
					LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD);
HRESULT PRV_EnumLocalApplications(LPDIRECTPLAYLOBBY,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD, BOOL);

// dplobby.c
extern HRESULT	DPLAPI DPL_Connect(LPDIRECTPLAYLOBBY, DWORD, LPDIRECTPLAY2 *,
						IUnknown FAR *);
extern HRESULT DPLAPI DPL_ConnectEx(LPDIRECTPLAYLOBBY, DWORD, REFIID,
					LPVOID *, IUnknown FAR *);
extern HRESULT DPLAPI DPL_CreateAddress(LPDIRECTPLAYLOBBY pISP,
					REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
					LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPLAPI DPL_CreateCompoundAddress(LPDIRECTPLAYLOBBY pISP,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPLAPI DPL_EnumAddress(LPDIRECTPLAYLOBBY pISP,
					LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize, 
					LPVOID lpContext);
extern HRESULT DPLAPI DPL_RegisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, LPVOID lpvDesc);
extern HRESULT DPLAPI DPL_UnregisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, REFGUID lpguid);

HRESULT PRV_WriteAppDescInRegistryAnsi(LPDPAPPLICATIONDESC);
HRESULT PRV_WriteAppDescInRegistryUnicode(LPDPAPPLICATIONDESC);

// dplobbya.c	(Ansi entry points)
extern HRESULT	DPLAPI DPL_A_Connect(LPDIRECTPLAYLOBBY, DWORD,
				LPDIRECTPLAY2 *, IUnknown FAR *);
extern HRESULT DPLAPI DPL_A_ConnectEx(LPDIRECTPLAYLOBBY, DWORD, REFIID,
					LPVOID *, IUnknown FAR *);
extern HRESULT	DPLAPI DPL_A_EnumLocalApplications(LPDIRECTPLAYLOBBY,
						LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD);
extern HRESULT	DPLAPI DPL_A_GetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD,
						LPVOID, LPDWORD);
extern HRESULT DPLAPI DPL_A_RegisterApplication(LPDIRECTPLAYLOBBY,
				DWORD, LPVOID);
extern HRESULT	DPLAPI DPL_A_RunApplication(LPDIRECTPLAYLOBBY,	DWORD, LPDWORD,
						LPDPLCONNECTION, HANDLE);
extern HRESULT	DPLAPI DPL_A_SetConnectionSettings(LPDIRECTPLAYLOBBY,
						DWORD, DWORD, LPDPLCONNECTION);

// dplpack.c
void PRV_GetDPLCONNECTIONPackageSize(LPDPLCONNECTION, LPDWORD, LPDWORD);
HRESULT PRV_PackageDPLCONNECTION(LPDPLCONNECTION, LPVOID, BOOL);
HRESULT PRV_UnpackageDPLCONNECTIONAnsi(LPVOID, LPVOID);
HRESULT PRV_UnpackageDPLCONNECTIONUnicode(LPVOID, LPVOID);
HRESULT PRV_ValidateDPLCONNECTION(LPDPLCONNECTION, BOOL);
HRESULT PRV_ValidateDPAPPLICATIONDESC(LPDPAPPLICATIONDESC, BOOL);
HRESULT PRV_ConvertDPAPPLICATIONDESCToAnsi(LPDPAPPLICATIONDESC,
		LPDPAPPLICATIONDESC *);
HRESULT PRV_ConvertDPAPPLICATIONDESCToUnicode(LPDPAPPLICATIONDESC,
		LPDPAPPLICATIONDESC *);
void PRV_FreeLocalDPAPPLICATIONDESC(LPDPAPPLICATIONDESC);

// dplshare.c
extern HRESULT	DPLAPI DPL_GetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD,
						LPVOID, LPDWORD);
extern HRESULT	DPLAPI DPL_ReceiveLobbyMessage(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, LPDWORD, LPVOID, LPDWORD);
extern HRESULT	DPLAPI DPL_SendLobbyMessage(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, LPVOID, DWORD);
extern HRESULT	DPLAPI DPL_SetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, LPDPLCONNECTION);
extern HRESULT	DPLAPI DPL_SetLobbyMessageEvent(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, HANDLE);
extern HRESULT DPLAPI DPL_WaitForConnectionSettings(LPDIRECTPLAYLOBBY, DWORD);

HRESULT PRV_GetInternalName(LPDPLOBBYI_GAMENODE, DWORD, LPWSTR);
HRESULT PRV_AddNewGameNode(LPDPLOBBYI_DPLOBJECT, LPDPLOBBYI_GAMENODE *,
						DWORD, HANDLE, BOOL, LPGUID);
HRESULT PRV_WriteConnectionSettings(LPDPLOBBYI_GAMENODE, LPDPLCONNECTION, BOOL);
HRESULT PRV_FreeGameNode(LPDPLOBBYI_GAMENODE);
void PRV_RemoveGameNodeFromList(LPDPLOBBYI_GAMENODE);
HANDLE PRV_DuplicateHandle(HANDLE);
DWORD WINAPI PRV_ReceiveClientNotification(LPVOID);
DWORD WINAPI PRV_ClientTerminateNotification(LPVOID);
HRESULT PRV_GetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD, LPVOID,
						LPDWORD, BOOL);
HRESULT PRV_SetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD, DWORD,
						LPDPLCONNECTION);
void PRV_KillThread(HANDLE, HANDLE);
HRESULT PRV_InjectMessageInQueue(LPDPLOBBYI_GAMENODE, DWORD, LPVOID, DWORD, BOOL);
HRESULT PRV_WriteClientData(LPDPLOBBYI_GAMENODE, DWORD, LPVOID, DWORD); 
void PRV_RemoveRequestNode(LPDPLOBBYI_DPLOBJECT, LPDPLOBBYI_REQUESTNODE);

// dplsp.c
extern HRESULT DPLAPI DPLP_AddGroupToGroup(LPDPLOBBYSP, LPSPDATA_ADDREMOTEGROUPTOGROUP);
extern HRESULT DPLAPI DPLP_AddPlayerToGroup(LPDPLOBBYSP, LPSPDATA_ADDREMOTEPLAYERTOGROUP);
extern HRESULT DPLAPI DPLP_CreateGroup(LPDPLOBBYSP, LPSPDATA_CREATEREMOTEGROUP);
extern HRESULT DPLAPI DPLP_CreateGroupInGroup(LPDPLOBBYSP, LPSPDATA_CREATEREMOTEGROUPINGROUP);
extern HRESULT DPLAPI DPLP_DeleteGroupFromGroup(LPDPLOBBYSP, LPSPDATA_DELETEREMOTEGROUPFROMGROUP);
extern HRESULT DPLAPI DPLP_DeletePlayerFromGroup(LPDPLOBBYSP, LPSPDATA_DELETEREMOTEPLAYERFROMGROUP);
extern HRESULT DPLAPI DPLP_DestroyGroup(LPDPLOBBYSP, LPSPDATA_DESTROYREMOTEGROUP);
extern HRESULT DPLAPI DPLP_GetSPDataPointer(LPDPLOBBYSP, LPVOID *);
extern HRESULT DPLAPI DPLP_HandleMessage(LPDPLOBBYSP, LPSPDATA_HANDLEMESSAGE);
extern HRESULT DPLAPI DPLP_SendChatMessage(LPDPLOBBYSP, LPSPDATA_CHATMESSAGE);
extern HRESULT DPLAPI DPLP_SetGroupName(LPDPLOBBYSP, LPSPDATA_SETREMOTEGROUPNAME);
extern HRESULT DPLAPI DPLP_SetGroupOwner(LPDPLOBBYSP, LPSPDATA_SETREMOTEGROUPOWNER);
extern HRESULT DPLAPI DPLP_SetPlayerName(LPDPLOBBYSP, LPSPDATA_SETREMOTEPLAYERNAME);
extern HRESULT DPLAPI DPLP_SetSessionDesc(LPDPLOBBYSP, LPSPDATA_SETSESSIONDESC);
extern HRESULT DPLAPI DPLP_SetSPDataPointer(LPDPLOBBYSP, LPVOID);
extern HRESULT DPLAPI DPLP_StartSession(LPDPLOBBYSP, LPSPDATA_STARTSESSIONCOMMAND);

HRESULT DPLAPI PRV_BroadcastDestroyGroupMessage(LPDPLOBBYI_DPLOBJECT, DPID);
HRESULT PRV_DeleteRemotePlayerFromGroup(LPDPLOBBYI_DPLOBJECT,
		LPSPDATA_DELETEREMOTEPLAYERFROMGROUP, BOOL);
HRESULT DPLAPI DPLP_DestroyGroup(LPDPLOBBYSP, LPSPDATA_DESTROYREMOTEGROUP);
void PRV_RemoveSubgroupsAndPlayersFromGroup(LPDPLOBBYI_DPLOBJECT,
		LPDPLAYI_GROUP, DWORD, BOOL);
HRESULT PRV_DeleteRemoteGroupFromGroup(LPDPLOBBYI_DPLOBJECT,
		LPSPDATA_DELETEREMOTEGROUPFROMGROUP, BOOL, LPDPLAYI_GROUP);
void PRV_SendDeleteShortcutMessageForExitingGroup(LPDPLOBBYI_DPLOBJECT,	LPDPLAYI_GROUP);
HRESULT PRV_SendDataChangedMessageLocally(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, DWORD);
HRESULT PRV_SendNameChangedMessageLocally(LPDPLOBBYI_DPLOBJECT, DPID, LPDPNAME, BOOL);
HRESULT PRV_SendGroupOwnerMessageLocally(LPDPLOBBYI_DPLOBJECT, DPID, DPID, DPID);

// group.c
extern HRESULT PRV_GetGroupConnectionSettings(LPDIRECTPLAY, DWORD, DPID,
							LPVOID, LPDWORD);
extern HRESULT PRV_SetGroupConnectionSettings(LPDIRECTPLAY, DWORD, DPID,
							LPDPLCONNECTION, BOOL);
extern HRESULT PRV_CreateAndMapNewGroup(LPDPLOBBYI_DPLOBJECT,
			DPID *, LPDPNAME, LPVOID, DWORD, DWORD, DWORD, DPID, DWORD);

void PRV_DestroySubgroups(LPDPLOBBYI_DPLOBJECT, LPDPLAYI_GROUP, BOOL);
void PRV_DestroyGroupAndParents(LPDPLOBBYI_DPLOBJECT, LPDPLAYI_GROUP, LPDPLAYI_GROUP);

// player.c
extern HRESULT PRV_GrowMapTable(LPDPLOBBYI_DPLOBJECT);
extern HRESULT PRV_CreateAndMapNewPlayer(LPDPLOBBYI_DPLOBJECT,
			DPID *, LPDPNAME, HANDLE, LPVOID, DWORD, DWORD, DWORD, BOOL);
extern BOOL IsValidLobbyID(DWORD);
extern BOOL IsLobbyIDInMapTable(LPDPLOBBYI_DPLOBJECT, DWORD);

// session.c
extern HRESULT DPLAPI DPLP_EnumSessionsResponse(LPDPLOBBYSP, LPSPDATA_ENUMSESSIONSRESPONSE);


// api.c (in the dplay project)
HRESULT TimeBomb();
HRESULT ConnectMe(LPDIRECTPLAYLOBBY, LPDIRECTPLAY2 FAR *, IUnknown FAR *, DWORD); 


#endif // __DPLOBPR_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplpack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplpack.c
 *  Content:	Methods for packing/unpacking structures
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	5/31/96		myronth	Created it
 *	6/26/96		kipo	added support for DPADDRESS.
 *  7/13/96		kipo	Bug fix - added (LPBYTE) cast to lpConnPack (address calc)
 *						in PRV_UnpackageDPLCONNECTIONAnsi()
 *	11/20/96	myronth	Removed packing for DPTRANSPORT
 *	12/12/96	myronth	Added DPLCONNECTION structure validation
 *	2/12/97		myronth	Mass DX5 changes
 *	4/3/97		myronth Changed STRLEN's to WSTRLEN's from dplaypr.h
 *	5/8/97		myronth	Changed most packing functions to use the packed
 *						conn header, added pointer fixup function, Moved
 *						PRV_ConvertDPLCONNECTIONToUnicode from convert.c
 *	9/29/97		myronth	Fixed DPLCONNECTION package size bug (#12475)
 *	12/2/97		myronth	Made SessionDesc mandatory in DPLCONNECTION (#15529)
 *	7/08/98	   a-peterz	Allow for MBCS for ANSI string sizes. ManBug 16299
 *  2/10/99     aarono  add support for application launcher
 *  10/22/99	aarono  added support for application flags
 *  01/21/00	aarono  added support for DPSESSION_ALLOWVOICERETRO flag
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDPLCONNECTIONPackageSize"
void PRV_GetDPLCONNECTIONPackageSize(LPDPLCONNECTION lpConn,
						LPDWORD lpdwUnicode, LPDWORD lpdwAnsi)
{
	DWORD				dwSize;
	DWORD				dwStringSize = 0;
	DWORD				dwStringSizeA = 0;
	LPDPSESSIONDESC2	lpsd = NULL;
	LPDPNAME			lpn = NULL;


	DPF(7, "Entering PRV_GetDPLCONNECTIONPackageSize");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpConn, lpdwUnicode, lpdwAnsi);

	ASSERT(lpConn);
	
	// First calculate the size of the structures
	dwSize = sizeof(DPLCONNECTION);

	// Add the size of the SessionDesc and Name structs
	if(lpConn->lpSessionDesc)
	{
		dwSize += sizeof(DPSESSIONDESC2);
		lpsd = lpConn->lpSessionDesc;
		
		if(lpsd->lpszSessionName)
			dwStringSize += WSTRLEN(lpsd->lpszSessionName);
		if(lpsd->lpszPassword)
			dwStringSize += WSTRLEN(lpsd->lpszPassword);
		// only compute ANSI size if needed. Macro handles NULLS; includes terminator
		if(lpdwAnsi)
		{
			dwStringSizeA += WSTR_ANSILENGTH(lpsd->lpszSessionName);
			dwStringSizeA += WSTR_ANSILENGTH(lpsd->lpszPassword);
		}
	}


	if(lpConn->lpPlayerName)
	{
		dwSize += sizeof(DPNAME);
		lpn = lpConn->lpPlayerName;
		
		if(lpn->lpszShortName)
			dwStringSize += WSTRLEN(lpn->lpszShortName);
		if(lpn->lpszLongName)
			dwStringSize += WSTRLEN(lpn->lpszLongName);
		// only compute ANSI size if needed. Macro handles NULLS; includes terminator
		if(lpdwAnsi)
		{
			dwStringSizeA += WSTR_ANSILENGTH(lpn->lpszShortName);
			dwStringSizeA += WSTR_ANSILENGTH(lpn->lpszLongName);
		}
	}

	// Add the size of the SP-specific data
	if(lpConn->lpAddress)
		dwSize += lpConn->dwAddressSize;

	// Now add in the size of the packed structure header
	dwSize += sizeof(DPLOBBYI_PACKEDCONNHEADER);

	// Fill in the output variables
	if(lpdwAnsi)
		*lpdwAnsi = dwSize + dwStringSizeA;
	if(lpdwUnicode)
		*lpdwUnicode = dwSize + (dwStringSize * sizeof(WCHAR));

} // PRV_GetDPLCONNECTIONPackageSize


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_PackageDPLCONNECTION"
HRESULT PRV_PackageDPLCONNECTION(LPDPLCONNECTION lpConn, LPVOID lpBuffer,
			BOOL bHeader)
{
	LPDPLOBBYI_PACKEDCONNHEADER		lpHeader = NULL;
	LPDPLCONNECTION					lpConnPacked = NULL;
	LPDPSESSIONDESC2				lpsd = NULL,
									lpsdPacked = NULL;
	LPDPNAME						lpn = NULL,
									lpnPacked = NULL;
	LPBYTE							lpStart, lpCurrent;
	DWORD							dwSizeAnsi,
									dwSizeUnicode,
									dwTemp;
	

	DPF(7, "Entering PRV_PackageDPLCONNECTION");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", lpConn, lpBuffer, bHeader);

	ASSERT(lpConn);
	
	// If the bHeader flag is set, we want to copy the packed header into the
	// buffer first.  If it is not, we only want the packed DPLCONNECTION struct
	if(bHeader)
	{
		PRV_GetDPLCONNECTIONPackageSize(lpConn, &dwSizeUnicode, &dwSizeAnsi);
		lpHeader = (LPDPLOBBYI_PACKEDCONNHEADER)lpBuffer;
		lpHeader->dwUnicodeSize = dwSizeUnicode;
		lpHeader->dwAnsiSize = dwSizeAnsi;
		lpStart = (LPBYTE)lpBuffer + sizeof(DPLOBBYI_PACKEDCONNHEADER);
	}
	else
	{
		lpStart = lpBuffer;
	}

	// Copy in the structures & store the offsets
	memcpy(lpStart, lpConn, sizeof(DPLCONNECTION));
	lpConnPacked = (LPDPLCONNECTION)lpStart;
	lpCurrent = lpStart + sizeof(DPLCONNECTION);

	if(lpConn->lpSessionDesc)
	{
		lpsd = lpConn->lpSessionDesc;
		lpsdPacked = (LPDPSESSIONDESC2)lpCurrent;
		if(lpsdPacked->dwSize==sizeof(DPSESSIONDESC2)){
			// we are over-riding and existing session descriptor, don't let
			// the session flag for the retrofit get over-riden
			lpsd->dwFlags |= (lpsdPacked->dwFlags & DPSESSION_ALLOWVOICERETRO);
		}
		memcpy(lpCurrent, lpsd, sizeof(DPSESSIONDESC2));
		(DWORD_PTR)lpConnPacked->lpSessionDesc = (DWORD_PTR)(lpCurrent - lpStart);
		lpCurrent += sizeof(DPSESSIONDESC2);
	}

	if(lpConn->lpPlayerName)
	{
		lpn = lpConn->lpPlayerName;
		memcpy(lpCurrent, lpn, sizeof(DPNAME));
		lpnPacked = (LPDPNAME)lpCurrent;
		(DWORD_PTR)lpConnPacked->lpPlayerName = (DWORD_PTR)(lpCurrent - lpStart);
		lpCurrent += sizeof(DPNAME);
	}

	// Copy in the strings in the SessionDesc and store the offset of the
	// string from lpStart (relative offset in our package) in the pointer
	// for the string in the SessionDesc structure.  We will use this
	// value to unpack and fix up the pointers during GetConnectionSettings
	if(lpsd)
	{
		if(lpsd->lpszSessionName)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpsd->lpszSessionName) * sizeof(WCHAR);
			memcpy(lpCurrent, lpsd->lpszSessionName, dwTemp);

			// Store the offset
                        lpsdPacked->lpszSessionName = (LPWSTR)(DWORD_PTR)(lpCurrent - lpStart);

			lpCurrent += dwTemp;
		}

		if(lpsd->lpszPassword)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpsd->lpszPassword) * sizeof(WCHAR);
			memcpy(lpCurrent, lpsd->lpszPassword, dwTemp);

			// Store the offset
                        lpsdPacked->lpszPassword = (LPWSTR)(DWORD_PTR)(lpCurrent - lpStart);

			lpCurrent += dwTemp;
		}

	}

	// Copy in the strings in the DPName struct and store the offset of the
	// string from lpStart (relative offset in our package) in the pointer
	// for the string in the SessionDesc structure.  We will use this
	// value to unpack and fix up the pointers during GetConnectionSettings
	if(lpn)
	{
		if(lpn->lpszShortName)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpn->lpszShortName) * sizeof(WCHAR);
			memcpy(lpCurrent, lpn->lpszShortName, dwTemp);

			// Store the offset
                        lpnPacked->lpszShortName = (LPWSTR)(DWORD_PTR)(lpCurrent - lpStart);

			lpCurrent += dwTemp;
		}

		if(lpn->lpszLongName)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpn->lpszLongName) * sizeof(WCHAR);
			memcpy(lpCurrent, lpn->lpszLongName, dwTemp);

			// Store the offset
                        lpnPacked->lpszLongName = (LPWSTR)(DWORD_PTR)(lpCurrent - lpStart);

			lpCurrent += dwTemp;
		}

	}

    // Copy in the SP-specific data
    if(lpConn->lpAddress)
    {
        // Copy the data
        memcpy(lpCurrent, lpConn->lpAddress, lpConn->dwAddressSize);

        // Store the offset
        ((LPDPLCONNECTION)lpStart)->lpAddress = (LPVOID)(DWORD_PTR)(lpCurrent - lpStart);
    }

    return DP_OK;

} // PRV_PackageDPLCONNECTION



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_UnpackageDPLCONNECTIONUnicode"
// NOTE : really need to define a WIRE LPDPLCONNECTION so that
//        we can crack it that way.  This will allow compile, until
//        we can test on Win64, there is no way to verify cracking
//        the packet, so I've deffered this work until then AO 11/10/98
// not bringing DP4 to Win64 AO 04/03/2001
HRESULT PRV_UnpackageDPLCONNECTIONUnicode(LPVOID lpData, LPVOID lpPackage)
{
	LPDPLOBBYI_PACKEDCONNHEADER		lpHeader = NULL;
	LPDPLCONNECTION					lpConn = NULL;
	LPDPSESSIONDESC2				lpsd = NULL;
	LPDPNAME						lpn = NULL;
	LPBYTE							lpPackCur, lpDataStart;
	DWORD_PTR						dwSize;
	

	DPF(7, "Entering PRV_UnpackageDPLCONNECTIONUnicode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpData, lpPackage);

	// If we're Unicode, all we need to do is copy the entire package
	// and fix up the pointers
	lpHeader = (LPDPLOBBYI_PACKEDCONNHEADER)lpPackage;
	dwSize = lpHeader->dwUnicodeSize;
	lpPackCur = ((LPBYTE)lpPackage) + sizeof(DPLOBBYI_PACKEDCONNHEADER);
	lpDataStart = lpData;
	
	// Copy the data
	memcpy(lpData, lpPackCur, (DWORD)dwSize);

	// Fix up the pointers -- the offset of every element relative to
	// the start of lpConn is stored in the pointer for the element.
	// So all we have to do to fix up the pointers is calculate it from
	// the given offset + the value of lpConn.
	lpConn = (LPDPLCONNECTION)lpData;

	if(lpConn->lpSessionDesc)
	{
		dwSize = (DWORD_PTR)lpConn->lpSessionDesc;
		lpsd = lpConn->lpSessionDesc = (LPDPSESSIONDESC2)(lpDataStart + dwSize);

		// Now do the same for the strings
		if(lpsd->lpszSessionName)
		{
			lpsd->lpszSessionName = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpsd->lpszSessionName));
		}

		if(lpsd->lpszPassword)
		{
			lpsd->lpszPassword = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpsd->lpszPassword));
		}
	}

	if(lpConn->lpPlayerName)
	{
		dwSize = (DWORD_PTR)lpConn->lpPlayerName;
		lpn = lpConn->lpPlayerName = (LPDPNAME)(lpDataStart + dwSize);

		// Now do the same for the strings
		if(lpn->lpszShortName)
		{
			lpn->lpszShortName = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpn->lpszShortName));
		}

		if(lpn->lpszLongName)
		{
			lpn->lpszLongName = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpn->lpszLongName));
		}

	}

	// Fix the SPData pointer
	if(lpConn->lpAddress)
	{
		lpConn->lpAddress = lpDataStart + ((DWORD_PTR)lpConn->lpAddress);
	}

	return DP_OK;

} // PRV_UnpackageDPLCONNECTIONUnicode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_UnpackageDPLCONNECTIONAnsi"
HRESULT PRV_UnpackageDPLCONNECTIONAnsi(LPVOID lpData, LPVOID lpPackage)
{
	LPDPLOBBYI_PACKEDCONNHEADER		lpHeader = NULL;
	LPDPLCONNECTION					lpConnData, lpConnPack;
	LPDPSESSIONDESC2				lpsdData = NULL,
									lpsdPack = NULL;
	LPDPNAME						lpnData = NULL,
									lpnPack = NULL;
	LPBYTE							lpDataCur, lpPackCur;
	DWORD							dwTemp;
	LPWSTR							lpszTemp;
	

	DPF(7, "Entering PRV_UnpackageDPLCONNECTIONAnsi");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpData, lpPackage);

	// If we're Ansi, we need to do is copy the structures, convert
	// and copy the strings, and fix up all the pointers
	lpPackCur = ((LPBYTE)lpPackage) + sizeof(DPLOBBYI_PACKEDCONNHEADER);
	lpDataCur = lpData;
	
	// First copy the main structures
	dwTemp = sizeof(DPLCONNECTION);
	memcpy(lpDataCur, lpPackCur, dwTemp);
	lpConnData = (LPDPLCONNECTION)lpDataCur;
	lpConnPack = (LPDPLCONNECTION)lpPackCur;

	lpDataCur += dwTemp;
	lpPackCur += dwTemp;

	if(lpConnData->lpSessionDesc)
	{
		dwTemp = sizeof(DPSESSIONDESC2);
		memcpy(lpDataCur, lpPackCur, sizeof(DPSESSIONDESC2));
		lpsdData = lpConnData->lpSessionDesc = (LPDPSESSIONDESC2)lpDataCur;
		lpsdPack = (LPDPSESSIONDESC2)lpPackCur;
		lpDataCur += dwTemp;
		lpPackCur += dwTemp;
	}

	if(lpConnData->lpPlayerName)
	{
		dwTemp = sizeof(DPNAME);
		memcpy(lpDataCur, lpPackCur, sizeof(DPNAME));
		lpnData = lpConnData->lpPlayerName = (LPDPNAME)lpDataCur;
		lpnPack = (LPDPNAME)lpPackCur;
		lpDataCur += dwTemp;
		lpPackCur += dwTemp;
	}

	// Copy the strings & fix up the pointers
	if(lpsdData)
	{
		if(lpsdData->lpszSessionName)
		{
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpsdPack->lpszSessionName);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpsdData->lpszSessionNameA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}

		if(lpsdData->lpszPassword)
		{
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpsdPack->lpszPassword);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpsdData->lpszPasswordA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}
	}

	if(lpnData)
	{
		if(lpnData->lpszShortName)
		{
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpnPack->lpszShortName);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpnData->lpszShortNameA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}

		if(lpnData->lpszLongName)
		{
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpnPack->lpszLongName);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpnData->lpszLongNameA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}

	}

	// Copy in the SPData & fix up the pointer
	if(lpConnData->lpAddress)
	{
		lpPackCur = ((LPBYTE)lpConnPack) + (DWORD_PTR)lpConnPack->lpAddress;
		memcpy(lpDataCur, lpPackCur, lpConnPack->dwAddressSize);
		lpConnData->lpAddress = lpDataCur;
	}

	return DP_OK;

} // PRV_UnpackageDPLCONNECTIONAnsi




#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ValidateDPLCONNECTION"
HRESULT PRV_ValidateDPLCONNECTION(LPDPLCONNECTION lpConn, BOOL bAnsi)
{
	LPDPSESSIONDESC2	lpsd = NULL;
	LPDPNAME			lpn = NULL;


	DPF(7, "Entering PRV_ValidateDPLCONNECTION");
	DPF(9, "Parameters: 0x%08x, %lu", lpConn, bAnsi);
	

	TRY
	{
		// Validate the connection structure itself
		if(!VALID_DPLOBBY_CONNECTION(lpConn))
		{
			DPF_ERR("Invalid DPLCONNECTION structure");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the flags
		if(lpConn->dwFlags & ~(DPLCONNECTION_CREATESESSION | DPLCONNECTION_JOINSESSION))
		{
			DPF_ERR("Invalid flags exist in the dwFlags member of the DPLCONNECTION structure");
			return DPERR_INVALIDFLAGS;
		}

		// Validate the SessionDesc structure
		if(lpConn->lpSessionDesc)
		{
			lpsd = lpConn->lpSessionDesc;
			// Validate the structure itself
			if(!VALID_READ_DPSESSIONDESC2(lpsd))
			{
				DPF_ERR("Invalid DPSESSIONDESC2 structure in DPLCONNECTION structure");
				return DPERR_INVALIDPARAMS;
			}

			// Validate the SessionName string
			if(lpsd->lpszSessionName)
			{
				if(!VALID_READ_PTR(lpsd->lpszSessionName, (bAnsi ?
					strlen(lpsd->lpszSessionNameA) : WSTRLEN_BYTES(lpsd->lpszSessionName))))
				{
					DPF_ERR("Invalid SessionName string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}

			// Validate the Password string
			if(lpsd->lpszPassword)
			{
				if(!VALID_READ_PTR(lpsd->lpszPassword, (bAnsi ?
					strlen(lpsd->lpszPasswordA) : WSTRLEN_BYTES(lpsd->lpszPassword))))
				{
					DPF_ERR("Invalid Password string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}
		}
		else
		{
			DPF_ERR("Invalid SessionDesc pointer in DPLCONNECTION structure");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the Name structure
		if(lpConn->lpPlayerName)
		{
			lpn = lpConn->lpPlayerName;
			if(!VALID_READ_DPNAME_PTR(lpn))
			{
				DPF_ERR("Invalid DPNAME structure in DPLCONNECTION structure");
				return DPERR_INVALIDPARAMS;
			}

			// Validate the ShortName string
			if(lpn->lpszShortName)
			{
				if(!VALID_READ_PTR(lpn->lpszShortName, (bAnsi ?
					strlen(lpn->lpszShortNameA) : WSTRLEN_BYTES(lpn->lpszShortName))))
				{
					DPF_ERR("Invalid ShortName string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}

			// Validate the LongName string
			if(lpn->lpszLongName)
			{
				if(!VALID_READ_PTR(lpn->lpszLongName, (bAnsi ?
					strlen(lpn->lpszLongNameA) : WSTRLEN_BYTES(lpn->lpszLongName))))
				{
					DPF_ERR("Invalid LongName string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}
		}

		// Validate the DPADDRESS structure
		if(lpConn->lpAddress)
		{
			if(!VALID_READ_PTR(lpConn->lpAddress, lpConn->dwAddressSize))
			{
				DPF_ERR("Invalid lpAddress in DPLCONNECTION structure");
				return DPERR_INVALIDPARAMS;
			}
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	return DP_OK;

} // PRV_ValidateDPLCONNECTION



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPLCONNECTIONToUnicode"
HRESULT PRV_ConvertDPLCONNECTIONToUnicode(LPDPLCONNECTION lpConnA,
					LPDPLCONNECTION * lplpConnW)
{
	LPDPLCONNECTION		lpConnW = NULL;
	LPDPSESSIONDESC2	lpsdW = NULL, lpsdA;
	LPDPNAME			lpnW = NULL, lpnA;
	LPWSTR				lpwszSessionName = NULL;
	LPWSTR				lpwszPassword = NULL;
	LPWSTR				lpwszLongName = NULL;
	LPWSTR				lpwszShortName = NULL;
	HRESULT				hr = DP_OK;


	DPF(7, "Entering PRV_ConvertDPLCONNECTIONToUnicode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpConnA, lplpConnW);

	ASSERT(lpConnA);
	ASSERT(lplpConnW);


	// Allocate memory for the DPLCONNECTION structure
	lpConnW = DPMEM_ALLOC(sizeof(DPLCONNECTION));
	if(!lpConnW)
	{
		DPF_ERR("Unable to allocate memory for temporary Unicode DPLCONNECTION struct");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CONVERT_DPLCONNECTION;
	}

	// If we need a SessionDesc struct, allocate one
	if(lpConnA->lpSessionDesc)
	{
		lpsdW = DPMEM_ALLOC(sizeof(DPSESSIONDESC2));
		if(!lpsdW)
		{
			DPF_ERR("Unable to allocate memory for temporary Unicode DPSESSIONDESC struct");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_CONVERT_DPLCONNECTION;
		}
	}

	// If we need a DPName struct, allocate one
	if(lpConnA->lpPlayerName)
	{
		lpnW = DPMEM_ALLOC(sizeof(DPNAME));
		if(!lpnW)
		{
			DPF_ERR("Unable to allocate memory for temporary Unicode DPNAME struct");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_CONVERT_DPLCONNECTION;
		}
	}

	// Copy the fixed size members of the structures
	memcpy(lpConnW, lpConnA, sizeof(DPLCONNECTION));
	if(lpsdW)
		memcpy(lpsdW, lpConnA->lpSessionDesc, sizeof(DPSESSIONDESC2));
	if(lpnW)
		memcpy(lpnW, lpConnA->lpPlayerName, sizeof(DPNAME));


	// Get Unicode copies of all the strings
	if(lpConnA->lpSessionDesc)
	{
		lpsdA = lpConnA->lpSessionDesc;
		if(lpsdA->lpszSessionNameA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszSessionName),
										(LPSTR)lpsdA->lpszSessionNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Session Name string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}

		if(lpsdA->lpszPasswordA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszPassword),
										(LPSTR)lpsdA->lpszPasswordA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Password string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}
	}    

	if(lpConnA->lpPlayerName)
	{
		lpnA = lpConnA->lpPlayerName;
		if(lpnA->lpszShortNameA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszShortName),
										(LPSTR)lpnA->lpszShortNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Short Name string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}

		if(lpnA->lpszLongNameA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszLongName),
										(LPSTR)lpnA->lpszLongNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Long Name string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}
	}    

	// Now we've got everything so just fix up the pointers
	lpConnW->lpSessionDesc = lpsdW;
	lpConnW->lpPlayerName = lpnW;

	if(lpsdW)
	{
		lpsdW->lpszSessionName = lpwszSessionName;
		lpsdW->lpszPassword = lpwszPassword;
	}

	if(lpnW)
	{
		lpnW->lpszShortName = lpwszShortName;
		lpnW->lpszLongName = lpwszLongName;
	}

	*lplpConnW = lpConnW;

	return DP_OK;


ERROR_CONVERT_DPLCONNECTION:

	if(lpConnW)
		DPMEM_FREE(lpConnW);
	if(lpsdW)
		DPMEM_FREE(lpsdW);
	if(lpnW)
		DPMEM_FREE(lpnW);
	if(lpwszSessionName)
		DPMEM_FREE(lpwszSessionName);
	if(lpwszPassword)
		DPMEM_FREE(lpwszPassword);
	if(lpwszShortName)
		DPMEM_FREE(lpwszShortName);
	if(lpwszLongName)
		DPMEM_FREE(lpwszLongName);

	return hr;		

} // PRV_ConvertDPLCONNECTIONToUnicode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FixupDPLCONNECTIONPointers"
void PRV_FixupDPLCONNECTIONPointers(LPDPLCONNECTION lpConn)
{
	LPDPSESSIONDESC2	lpsd = NULL;
	LPDPNAME			lpn = NULL;
	

	DPF(7, "Entering PRV_FixupDPLCONNECTIONPointers");
	DPF(9, "Parameters: 0x%08x", lpConn);

	// Make sure we have a valid DPLCONNECTION pointer
	if(!lpConn)
	{
		DPF_ERR("Invalid DPLCONNECTION pointer");
		ASSERT(FALSE);
		return;
	}

	// Fixup the DPSESSIONDESC2 pointer
	if(lpConn->lpSessionDesc)
	{
		lpsd = (LPDPSESSIONDESC2)((LPBYTE)lpConn + (DWORD_PTR)lpConn->lpSessionDesc);
		lpConn->lpSessionDesc = lpsd;
	}

	// Fixup the name strings in the SessionDesc struct
	if(lpsd)
	{
		// Fixup the session name
		if(lpsd->lpszSessionName)
		{
			lpsd->lpszSessionName = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpsd->lpszSessionName);
		}

		// Fixup the password
		if(lpsd->lpszPassword)
		{
			lpsd->lpszPassword = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpsd->lpszPassword);
		}
	}

	// Fixup the DPNAME pointer
	if(lpConn->lpPlayerName)
	{
		lpn = (LPDPNAME)((LPBYTE)lpConn + (DWORD_PTR)lpConn->lpPlayerName);
		lpConn->lpPlayerName = lpn;
	}

	// Fixup the name strings
	if(lpn)
	{
		// Fixup the short name
		if(lpn->lpszShortName)
		{
			lpn->lpszShortName = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpn->lpszShortName);
		}

		// Fixup the long name
		if(lpn->lpszLongName)
		{
			lpn->lpszLongName = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpn->lpszLongName);
		}
	}

	// Fixup the address pointer
	if(lpConn->lpAddress)
	{
		lpConn->lpAddress = (LPBYTE)lpConn + (DWORD_PTR)lpConn->lpAddress;
	}

} // PRV_FixupDPLCONNECTIONPointers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPLCONNECTIONToAnsiInPlace"
HRESULT PRV_ConvertDPLCONNECTIONToAnsiInPlace(LPDPLCONNECTION lpConn,
		LPDWORD lpdwSize, DWORD dwHeaderSize)
{
	DWORD					dwSessionNameSize = 0, dwPasswordSize = 0;
	DWORD					dwShortNameSize = 0, dwLongNameSize = 0;
	DWORD					dwSessionDescSize = 0, dwNameSize = 0;
	DWORD					dwAnsiSize = 0;
	LPSTR					lpszSession = NULL, lpszPassword = 0;
	LPSTR					lpszShort = NULL, lpszLong = 0;
	LPBYTE					lpByte = NULL;

	
	DPF(7, "Entering PRV_ConvertDPLCONNECTIONToAnsiInPlace");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu",
			lpConn, lpdwSize, dwHeaderSize);

	// If we don't have a DPLCONNECTION struct, something's wrong
	ASSERT(lpConn);
	ASSERT(lpdwSize);

	// Start with the DPSESSIONDESC2 strings
	if(lpConn->lpSessionDesc)
	{
		if(lpConn->lpSessionDesc->lpszSessionName)
		{
			GetAnsiString(&lpszSession, lpConn->lpSessionDesc->lpszSessionName);
			dwSessionNameSize = STRLEN(lpszSession);
		}

		if(lpConn->lpSessionDesc->lpszPassword)
		{
			GetAnsiString(&lpszPassword, lpConn->lpSessionDesc->lpszPassword);
			dwPasswordSize = STRLEN(lpszPassword);
		}
		dwSessionDescSize = sizeof(DPSESSIONDESC2) + dwSessionNameSize +
								dwPasswordSize;
	}

	// Next the DPNAME strings
	if(lpConn->lpPlayerName)
	{
		if(lpConn->lpPlayerName->lpszShortName)
		{
			GetAnsiString(&lpszShort, lpConn->lpPlayerName->lpszShortName);
			dwShortNameSize = STRLEN(lpszShort);
		}

		if(lpConn->lpPlayerName->lpszLongName)
		{
			GetAnsiString(&lpszLong, lpConn->lpPlayerName->lpszLongName);
			dwLongNameSize = STRLEN(lpszLong);
		}
		dwNameSize = sizeof(DPNAME) + dwShortNameSize + dwLongNameSize;
	}

	dwAnsiSize = dwHeaderSize + sizeof(DPLCONNECTION) +
				dwSessionDescSize + dwNameSize + lpConn->dwAddressSize;

	if (dwAnsiSize > *lpdwSize)
	{
		if(lpszSession)
			DPMEM_FREE(lpszSession);
		if(lpszPassword)
			DPMEM_FREE(lpszPassword);
		if(lpszShort)
			DPMEM_FREE(lpszShort);
		if(lpszLong)
			DPMEM_FREE(lpszLong);
		*lpdwSize = dwAnsiSize;
		return DPERR_BUFFERTOOSMALL;
	}

	// store return size
	*lpdwSize = dwAnsiSize;

	// figure out where to start repacking strings
	lpByte = (LPBYTE)lpConn + sizeof(DPLCONNECTION);
	if(lpConn->lpSessionDesc)
		lpByte += sizeof(DPSESSIONDESC2);
	if(lpConn->lpPlayerName)
		lpByte += sizeof(DPNAME);

	// repack 'em
	if(lpszSession)
	{
		memcpy(lpByte, lpszSession, dwSessionNameSize);
		lpConn->lpSessionDesc->lpszSessionNameA = (LPSTR)lpByte;
		DPMEM_FREE(lpszSession);
		lpByte += dwSessionNameSize;
	}
	if(lpszPassword)
	{
		memcpy(lpByte, lpszPassword, dwPasswordSize);
		lpConn->lpSessionDesc->lpszPasswordA = (LPSTR)lpByte;
		DPMEM_FREE(lpszPassword);
		lpByte += dwPasswordSize;
	}
	if(lpszShort)
	{
		memcpy(lpByte, lpszShort, dwShortNameSize);
		lpConn->lpPlayerName->lpszShortNameA = (LPSTR)lpByte;
		DPMEM_FREE(lpszShort);
		lpByte += dwShortNameSize;
	}
	if(lpszLong)
	{
		memcpy(lpByte, lpszLong, dwLongNameSize);
		lpConn->lpPlayerName->lpszLongNameA = (LPSTR)lpByte;
		DPMEM_FREE(lpszLong);
		lpByte += dwLongNameSize;
	}

	if(lpConn->lpAddress)
	{
		// recopy the address, and account for the fact that we could
		// be doing an overlapping memory copy (So use MoveMemory instead
		// of CopyMemory or memcpy)
		MoveMemory(lpByte, lpConn->lpAddress, lpConn->dwAddressSize);
		lpConn->lpAddress = lpByte;
	}

	return DP_OK;
} // PRV_ConvertDPLCONNECTIONToAnsiInPlace



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ValidateDPAPPLICATIONDESC"
HRESULT PRV_ValidateDPAPPLICATIONDESC(LPDPAPPLICATIONDESC lpDesc, BOOL bAnsi)
{
	DWORD LobbyDescVer;
	LPDPAPPLICATIONDESC2 lpDesc2=(LPDPAPPLICATIONDESC2) lpDesc;

	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x, %lu", lpDesc, bAnsi);
	

	TRY
	{
		// Validate the connection structure itself
		if(VALID_DPLOBBY_APPLICATIONDESC(lpDesc)){
			LobbyDescVer=1;
		} else if (VALID_DPLOBBY_APPLICATIONDESC2(lpDesc)){
			LobbyDescVer=2;
		} else {
			DPF_ERR("Invalid structure pointer or invalid size");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the flags
		if(!VALID_REGISTERAPP_FLAGS(lpDesc->dwFlags))
		{
			DPF_ERR("Invalid flags exist in the dwFlags member of the DPAPPLICATIONDESC structure");
			return DPERR_INVALIDFLAGS;
		}
		if((lpDesc->dwFlags & (DPLAPP_AUTOVOICE|DPLAPP_SELFVOICE))==(DPLAPP_AUTOVOICE|DPLAPP_SELFVOICE))
		{
			return DPERR_INVALIDFLAGS;
		}

		// Validate the ApplicationName string (required)
		if(lpDesc->lpszApplicationName)
		{
			if(!VALID_READ_PTR(lpDesc->lpszApplicationName, (bAnsi ?
				strlen(lpDesc->lpszApplicationNameA) :
				WSTRLEN_BYTES(lpDesc->lpszApplicationName))))
			{
				DPF_ERR("Invalid lpszApplicationName string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}
		else
		{
			DPF_ERR("The lpszApplicationName member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the GUID (required)
		// We can really only check this against GUID_NULL since it will
		// always be a valid guid structure inside the APPDESC struct
		if(IsEqualGUID(&lpDesc->guidApplication, &GUID_NULL))
		{
			DPF_ERR("The guidApplication member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the Filename string (required)
		if(lpDesc->lpszFilename)
		{
			if(!VALID_READ_PTR(lpDesc->lpszFilename, (bAnsi ?
				strlen(lpDesc->lpszFilenameA) :
				WSTRLEN_BYTES(lpDesc->lpszFilename))))
			{
				DPF_ERR("Invalid lpszFilename string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}
		else
		{
			DPF_ERR("The lpszFilename member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the CommandLine string (optional)
		if(lpDesc->lpszCommandLine)
		{
			if(!VALID_READ_PTR(lpDesc->lpszCommandLine, (bAnsi ?
				strlen(lpDesc->lpszCommandLineA) :
				WSTRLEN_BYTES(lpDesc->lpszCommandLine))))
			{
				DPF_ERR("Invalid lpszCommandLine string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// Validate the Path string (required)
		if(lpDesc->lpszPath)
		{
			if(!VALID_READ_PTR(lpDesc->lpszPath, (bAnsi ?
				strlen(lpDesc->lpszPathA) :
				WSTRLEN_BYTES(lpDesc->lpszPath))))
			{
				DPF_ERR("Invalid lpszPath string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}
		else
		{
			DPF_ERR("The lpszPath member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the CurrentDirectory string (optional)
		if(lpDesc->lpszCurrentDirectory)
		{
			if(!VALID_READ_PTR(lpDesc->lpszCurrentDirectory, (bAnsi ?
				strlen(lpDesc->lpszCurrentDirectoryA) :
				WSTRLEN_BYTES(lpDesc->lpszCurrentDirectory))))
			{
				DPF_ERR("Invalid lpszCurrentDirectory string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// Validate the DescriptionA string (optional)
		if(lpDesc->lpszDescriptionA)
		{
			if(!VALID_READ_PTR(lpDesc->lpszDescriptionA,
				strlen(lpDesc->lpszDescriptionA)))
			{
				DPF_ERR("Invalid lpszDescriptionA string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// Validate the DescriptionW string (optional)
		if(lpDesc->lpszDescriptionW)
		{
			if(!VALID_READ_PTR(lpDesc->lpszDescriptionW,
				WSTRLEN_BYTES(lpDesc->lpszDescriptionW)))
			{
				DPF_ERR("Invalid lpszDescriptionW string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// if the DPAPPLICATIONDESC2 is being used, validate the launcher name if present
		if(LobbyDescVer==2)
		{
			// Validate AppLauncherName Name
			if(lpDesc2->lpszAppLauncherNameA){
				if(!VALID_READ_PTR(lpDesc2->lpszAppLauncherNameA, (bAnsi ?
					strlen(lpDesc2->lpszAppLauncherNameA) :
					WSTRLEN_BYTES(lpDesc2->lpszAppLauncherName))))
				{
					DPF_ERR("Invalid lpszAppLauncherName string in DPAPPLICATIONDESC2 structure");
					return DPERR_INVALIDPARAMS;
				}
			}	
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	return DP_OK;

} // PRV_ValidateDPAPPLICATIONDESC



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPAPPLICATIONDESCToUnicode"
HRESULT PRV_ConvertDPAPPLICATIONDESCToUnicode(LPDPAPPLICATIONDESC lpDescA,
					LPDPAPPLICATIONDESC * lplpDescW)
{
	#define lpDesc2A ((LPDPAPPLICATIONDESC2) lpDescA)
	#define lpDesc2W ((LPDPAPPLICATIONDESC2) lpDescW)

	LPDPAPPLICATIONDESC		lpDescW = NULL;
	LPWSTR					lpwszApplicationName = NULL;
	LPWSTR					lpwszFilename = NULL;
	LPWSTR					lpwszCommandLine = NULL;
	LPWSTR					lpwszPath = NULL;
	LPWSTR					lpwszCurrentDirectory = NULL;
	LPWSTR					lpwszAppLauncherName = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDescA, lplpDescW);

	ASSERT(lpDescA);
	ASSERT(lplpDescW);

	
	// Allocate memory for the DPAPPLICATIONDESC structure
	lpDescW = DPMEM_ALLOC(lpDescA->dwSize);
	if(!lpDescW)
	{
		DPF_ERR("Unable to allocate memory for temporary Unicode DPAPPLICATIONDESC struct");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
	}

	// Copy the structure itself
	memcpy(lpDescW, lpDescA, lpDescA->dwSize);

	// Convert the ApplicationName
	if(lpDescA->lpszApplicationNameA)
	{
		hr = GetWideStringFromAnsi(&lpwszApplicationName,
				lpDescA->lpszApplicationNameA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert ApplicationName string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the Filename
	if(lpDescA->lpszFilenameA)
	{
		hr = GetWideStringFromAnsi(&lpwszFilename,
				lpDescA->lpszFilenameA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Filename string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the CommandLine
	if(lpDescA->lpszCommandLineA)
	{
		hr = GetWideStringFromAnsi(&lpwszCommandLine,
				lpDescA->lpszCommandLineA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CommandLine string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the Path
	if(lpDescA->lpszPathA)
	{
		hr = GetWideStringFromAnsi(&lpwszPath,
				lpDescA->lpszPathA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Path string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the CurrentDirectory
	if(lpDescA->lpszCurrentDirectoryA)
	{
		hr = GetWideStringFromAnsi(&lpwszCurrentDirectory,
				lpDescA->lpszCurrentDirectoryA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CurrentDirectory string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the AppLauncher string if presend on an APPLICATIONDESC2
	if(IS_DPLOBBY_APPLICATIONDESC2(lpDescA)){
		if(lpDesc2A->lpszAppLauncherNameA){
			hr = GetWideStringFromAnsi(&lpwszAppLauncherName,
					lpDesc2A->lpszAppLauncherNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to convert CurrentDirectory string to Unicode");
				goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
			}
		} 
		lpDesc2W->lpszAppLauncherName=lpwszAppLauncherName;
	}

	// We won't convert the description strings because they will
	// get put in the registry as-is.

	// So now that we have all the strings, setup the structure
	lpDescW->lpszApplicationName = lpwszApplicationName;
	lpDescW->lpszFilename = lpwszFilename;
	lpDescW->lpszCommandLine = lpwszCommandLine;
	lpDescW->lpszPath = lpwszPath;
	lpDescW->lpszCurrentDirectory = lpwszCurrentDirectory;
	
	lpDescW->lpszDescriptionA = lpDescA->lpszDescriptionA;
	lpDescW->lpszDescriptionW = lpDescA->lpszDescriptionW;

	// Set the output pointer
	*lplpDescW = lpDescW;

	return DP_OK;

ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE:

	if(lpwszApplicationName)
		DPMEM_FREE(lpwszApplicationName);
	if(lpwszFilename)
		DPMEM_FREE(lpwszFilename);
	if(lpwszCommandLine)
		DPMEM_FREE(lpwszCommandLine);
	if(lpwszPath)
		DPMEM_FREE(lpwszPath);
	if(lpwszCurrentDirectory)
		DPMEM_FREE(lpwszCurrentDirectory);
	if(lpDescW)
		DPMEM_FREE(lpDescW);
	if(lpwszAppLauncherName){
		DPMEM_FREE(lpwszAppLauncherName);
	}

	return hr;

	#undef lpDesc2A
	#undef lpDesc2W 
	
} // PRV_ConvertDPAPPLICATIONDESCToUnicode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPAPPLICATIONDESCToAnsi"
HRESULT PRV_ConvertDPAPPLICATIONDESCToAnsi(LPDPAPPLICATIONDESC lpDescW,
					LPDPAPPLICATIONDESC * lplpDescA)
{
	#define lpDesc2W ((LPDPAPPLICATIONDESC2)(lpDescW))
	#define lpDesc2A ((LPDPAPPLICATIONDESC2)(lpDescA))

	LPDPAPPLICATIONDESC		lpDescA = NULL;
	LPSTR					lpszApplicationName = NULL;
	LPSTR					lpszFilename = NULL;
	LPSTR					lpszCommandLine = NULL;
	LPSTR					lpszPath = NULL;
	LPSTR					lpszCurrentDirectory = NULL;
	LPSTR					lpszAppLauncherName=NULL;
	HRESULT					hr;

	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDescW, lplpDescA);

	ASSERT(lpDescW);
	ASSERT(lplpDescA);

	// Allocate memory for the DPAPPLICATIONDESC structure
	lpDescA = DPMEM_ALLOC(lpDescW->dwSize);
	if(!lpDescA)
	{
		DPF_ERR("Unable to allocate memory for temporary Ansi DPAPPLICATIONDESC struct");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
	}

	// Copy the structure itself
	memcpy(lpDescA, lpDescW, lpDescW->dwSize);

	// Convert the ApplicationName
	if(lpDescW->lpszApplicationName)
	{
		hr = GetAnsiString(&lpszApplicationName, lpDescW->lpszApplicationName);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert ApplicationName string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the Filename
	if(lpDescW->lpszFilename)
	{
		hr = GetAnsiString(&lpszFilename, lpDescW->lpszFilename);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Filename string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the CommandLine
	if(lpDescW->lpszCommandLine)
	{
		hr = GetAnsiString(&lpszCommandLine, lpDescW->lpszCommandLine);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CommandLine string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the Path
	if(lpDescW->lpszPath)
	{
		hr = GetAnsiString(&lpszPath, lpDescW->lpszPath);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Path string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the CurrentDirectory
	if(lpDescW->lpszCurrentDirectory)
	{
		hr = GetAnsiString(&lpszCurrentDirectory, lpDescW->lpszCurrentDirectory);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CurrentDirectory string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convers the app launcher string if present.
	if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc2W)){
		if(lpDesc2W->lpszAppLauncherName){
			hr = GetAnsiString(&lpszAppLauncherName, lpDesc2W->lpszAppLauncherName);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to convert AppLauncherName string to Ansi");
				goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
			}
		} 
		lpDesc2A->lpszAppLauncherNameA = lpszAppLauncherName;
	}	

	// We won't convert the description strings because they will
	// get put in the registry as-is.

	// So now that we have all the strings, setup the structure
	lpDescA->lpszApplicationNameA = lpszApplicationName;
	lpDescA->lpszFilenameA = lpszFilename;
	lpDescA->lpszCommandLineA = lpszCommandLine;
	lpDescA->lpszPathA = lpszPath;
	lpDescA->lpszCurrentDirectoryA = lpszCurrentDirectory;
	
	lpDescA->lpszDescriptionA = lpDescW->lpszDescriptionA;
	lpDescA->lpszDescriptionW = lpDescW->lpszDescriptionW;

	// Set the output pointer
	*lplpDescA = lpDescA;

	return DP_OK;

ERROR_CONVERT_DPAPPLICATIONDESC_ANSI:

	if(lpszApplicationName)
		DPMEM_FREE(lpszApplicationName);
	if(lpszFilename)
		DPMEM_FREE(lpszFilename);
	if(lpszCommandLine)
		DPMEM_FREE(lpszCommandLine);
	if(lpszPath)
		DPMEM_FREE(lpszPath);
	if(lpszCurrentDirectory)
		DPMEM_FREE(lpszCurrentDirectory);
	if(lpDescA)
		DPMEM_FREE(lpDescA);
	if(lpszAppLauncherName)
		DPMEM_FREE(lpszAppLauncherName);

	return hr;

	#undef lpDesc2A
	#undef lpDesc2W
} // PRV_ConvertDPAPPLICATIONDESCToAnsi



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeLocalDPAPPLICATIONDESC"
void PRV_FreeLocalDPAPPLICATIONDESC(LPDPAPPLICATIONDESC lpDesc)
{
	LPDPAPPLICATIONDESC2 lpDesc2 = (LPDPAPPLICATIONDESC2)lpDesc;
	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x", lpDesc);

	if(lpDesc)
	{
		if(lpDesc->lpszApplicationName)
			DPMEM_FREE(lpDesc->lpszApplicationName);
		if(lpDesc->lpszFilename)
			DPMEM_FREE(lpDesc->lpszFilename);
		if(lpDesc->lpszCommandLine)
			DPMEM_FREE(lpDesc->lpszCommandLine);
		if(lpDesc->lpszPath)
			DPMEM_FREE(lpDesc->lpszPath);
		if(lpDesc->lpszCurrentDirectory)
			DPMEM_FREE(lpDesc->lpszCurrentDirectory);
		if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc) && lpDesc2->lpszAppLauncherName)
			DPMEM_FREE(lpDesc2->lpszAppLauncherName);

		// Note: We don't need to free the Description strings because they
		// were never allocated in either of the above routines, the pointers
		// were just copied.

		DPMEM_FREE(lpDesc);
	}

} // PRV_FreeLocalDPAPPLICATIONDESC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplobbya.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobbya.c
 *  Content:	ANSI Methods for IDirectPlayLobby
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	5/24/96		myronth	Created it
 *	9/09/96		kipo	Pass UNICODE IDirectPlayLobby interface to
 *						DPL_Connect() instead of ANSI interface. Bug #3790.
 *	10/23/96	myronth	Added client/server methods
 *	12/12/96	myronth	Fixed DPLCONNECTION validation
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	5/8/97		myronth	Get/SetGroupConnectionSettings, removed dead code
 *	9/29/97		myronth	Fixed DPLCONNECTION package size bug (#12475)
 *	11/5/97		myronth	Fixed locking macro
 *	11/13/97	myronth	Added stop async check for asynchronous Connect (#12541)
 *	12/2/97		myronth	Added DPL_A_RegisterApplication
 *	12/3/97		myronth	Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	6/25/98		a-peterz Added DPL_A_ConnectEx
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_Connect"
HRESULT DPLAPI DPL_A_Connect(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
				LPDIRECTPLAY2 * lplpDP2A, IUnknown FAR * lpUnk)
{
	HRESULT			hr;
	LPDIRECTPLAY2	lpDP2;
	LPDIRECTPLAYLOBBY	lpDPLW;


	DPF(7, "Entering DPL_A_Connect");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lplpDP2A, lpUnk);

    ENTER_DPLOBBY();

	TRY
	{
		if( !VALID_WRITE_PTR( lplpDP2A, sizeof(LPDIRECTPLAY2 *) ) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	LEAVE_DPLOBBY();

	// QueryInterface for the UNICODE DirectPlayLobby interface
	hr = lpDPL->lpVtbl->QueryInterface(lpDPL, &IID_IDirectPlayLobby, &lpDPLW);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to QueryInterface for the UNICODE DirectPlayLobby interface");
		return (hr);
	}

	// Use the UNICODE IDirectPlayLobby interface (fixes bug #3790)
	hr = DPL_Connect(lpDPLW, dwFlags, &lpDP2, lpUnk);

	// release UNICODE IDirectPlayLobby interface
	lpDPLW->lpVtbl->Release(lpDPLW);
	lpDPLW = NULL;

	if(SUCCEEDED(hr))
	{
		ENTER_DPLOBBY();

		// QueryInterface for the ANSI interface
		hr = lpDP2->lpVtbl->QueryInterface(lpDP2, &IID_IDirectPlay2A, lplpDP2A);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to QueryInterface for the ANSI DirectPlay interface");
		}

		// Release the Unicode interface
		lpDP2->lpVtbl->Release(lpDP2);

		LEAVE_DPLOBBY();
	}

	return hr;

} // DPL_A_Connect



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_ConnectEx"
HRESULT DPLAPI DPL_A_ConnectEx(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
				REFIID riid, LPVOID * ppvObj, IUnknown FAR * lpUnk)
{
	LPDIRECTPLAY2		lpDP2A = NULL;
	HRESULT				hr;


	DPF(7, "Entering DPL_A_ConnectEx");
	DPF(9, "Parameters: 0x%08x, 0x%08x, iid, 0x%08x, 0x%08x",
			lpDPL, dwFlags, ppvObj, lpUnk);


	hr = DPL_A_Connect(lpDPL, dwFlags, &lpDP2A, lpUnk);
	if(SUCCEEDED(hr))
	{
		hr = DP_QueryInterface((LPDIRECTPLAY)lpDP2A, riid, ppvObj);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling QueryInterface, hr = 0x%08x", hr);
		}

		// Release the DP2 object
		DP_Release((LPDIRECTPLAY)lpDP2A);
	}

	return hr;

} // DPL_A_ConnectEx



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_EnumLocalApplications"
HRESULT DPLAPI DPL_A_EnumLocalApplications(LPDIRECTPLAYLOBBY lpDPL,
					LPDPLENUMLOCALAPPLICATIONSCALLBACK lpCallback,
					LPVOID lpContext, DWORD dwFlags)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_A_EnumLocalApplications");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lpCallback, lpContext, dwFlags);

    ENTER_DPLOBBY();
    
	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_EnumLocalApplications(lpDPL, lpCallback, lpContext,
								dwFlags, TRUE);
	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_EnumLocalApplications



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_GetConnectionSettings"
HRESULT DPLAPI DPL_A_GetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
					DWORD dwGameID, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_A_GetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwGameID, lpData, lpdwSize);

    ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetConnectionSettings(lpDPL, dwGameID, lpData,
									lpdwSize, TRUE);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_GetConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_GetGroupConnectionSettings"
HRESULT DPLAPI DPL_A_GetGroupConnectionSettings(LPDIRECTPLAY lpDP,
		DWORD dwFlags, DPID idGroup, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_A_GetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpData, lpdwSize);

	ENTER_LOBBY_ALL();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetGroupConnectionSettings(lpDP, dwFlags, idGroup,
							lpData, lpdwSize);
	if(SUCCEEDED(hr))
	{
		// Now convert the DPLCONNECTION to ANSI in place
		hr = PRV_ConvertDPLCONNECTIONToAnsiInPlace((LPDPLCONNECTION)lpData,
				lpdwSize, 0);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed converting DPLCONNECTION struct to ANSI, hr = 0x%08x", hr);
		}
	}

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_A_GetGroupConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_RegisterApplication"
HRESULT DPLAPI DPL_A_RegisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, LPVOID lpvDesc)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPAPPLICATIONDESC		lpDescW = NULL;
	HRESULT					hr = DP_OK;
	LPDPAPPLICATIONDESC 	lpDesc=(LPDPAPPLICATIONDESC)lpvDesc;
	
	DPF(7, "Entering DPL_A_RegisterApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpDesc);

	ENTER_DPLOBBY();

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if(dwFlags)
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}

		// Validate the ApplicationDesc struct
		hr = PRV_ValidateDPAPPLICATIONDESC(lpDesc, TRUE);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			DPF_ERR("Invalid DPAPPLICATIONDESC structure");
			return hr;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// If we're on an ANSI platform, just write the stuff in the registry.
	// If it's not, we need to convert the DPAPPLICATIONDESC struct to Unicode
	if(OS_IsPlatformUnicode())
	{
		// Convert the APPDESC struct to Unicode
		hr = PRV_ConvertDPAPPLICATIONDESCToUnicode(lpDesc, &lpDescW);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to convert DPAPPLICATIONDESC to Unicode, hr = 0x%08x", hr);
			goto ERROR_REGISTERAPPLICATION;
		}

		// Write to the registry
		hr = PRV_WriteAppDescInRegistryUnicode(lpDescW);

		// Free our APPDESC structure
		PRV_FreeLocalDPAPPLICATIONDESC(lpDescW);
	}
	else
	{
		// Just write to the registry
		hr = PRV_WriteAppDescInRegistryAnsi(lpDesc);
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed writing ApplicationDesc to registry, hr = 0x%08x", hr);
	}

ERROR_REGISTERAPPLICATION:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_RegisterApplication



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeInternalDPLCONNECTION"
void PRV_FreeInternalDPLCONNECTION(LPDPLCONNECTION lpConn)
{
	LPDPSESSIONDESC2	lpsd;
	LPDPNAME			lpn;


	DPF(7, "Entering PRV_FreeInternalDPLCONNECTION");
	DPF(9, "Parameters: 0x%08x", lpConn);

	if(!lpConn)
		return;

	if(lpConn->lpSessionDesc)
	{
		lpsd = lpConn->lpSessionDesc;
		if(lpsd->lpszSessionName)
			DPMEM_FREE(lpsd->lpszSessionName);
		if(lpsd->lpszPassword)
			DPMEM_FREE(lpsd->lpszPassword);
		DPMEM_FREE(lpsd);
	}

	if(lpConn->lpPlayerName)
	{
		lpn = lpConn->lpPlayerName;
		if(lpn->lpszShortName)
			DPMEM_FREE(lpn->lpszShortName);
		if(lpn->lpszLongName)
			DPMEM_FREE(lpn->lpszLongName);
		DPMEM_FREE(lpn);
	}

	DPMEM_FREE(lpConn);

} // PRV_FreeInternalDPLCONNECTION


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_RunApplication"
HRESULT DPLAPI DPL_A_RunApplication(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
							LPDWORD lpdwGameID, LPDPLCONNECTION lpConnA,
							HANDLE hReceiveEvent)
{
	LPDPLCONNECTION	lpConnW = NULL;
	HRESULT			hr;


	DPF(7, "Entering DPL_A_RunApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpdwGameID, lpConnA, hReceiveEvent);

    ENTER_DPLOBBY();

	
	// Validate the DPLCONNECTION structure and it's members
	hr = PRV_ValidateDPLCONNECTION(lpConnA, TRUE);
	if(FAILED(hr))
	{
		LEAVE_DPLOBBY();
		return hr;
	}

	// Convert the ANSI DPLCONNECTION structure to Unicode
	hr = PRV_ConvertDPLCONNECTIONToUnicode(lpConnA, &lpConnW);
	if(FAILED(hr))
	{
		DPF_ERR("Failed to convert ANSI DPLCONNECTION structure to Unicode (temp)");
		LEAVE_DPLOBBY();
		return hr;
	}

	LEAVE_DPLOBBY();
	hr = DPL_RunApplication(lpDPL, dwFlags, lpdwGameID, lpConnW,
							hReceiveEvent);
	ENTER_DPLOBBY();

	// Free our temporary Unicode DPLCONNECTION structure
	PRV_FreeInternalDPLCONNECTION(lpConnW);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_RunApplication



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_SetConnectionSettings"
HRESULT DPLAPI DPL_A_SetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
						DWORD dwFlags, DWORD dwGameID,
						LPDPLCONNECTION lpConnA)
{
	HRESULT			hr;
	LPDPLCONNECTION	lpConnW = NULL;


	DPF(7, "Entering DPL_A_SetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, lpConnA);

    ENTER_DPLOBBY();

	// Validate the DPLCONNECTION structure and it's members
	hr = PRV_ValidateDPLCONNECTION(lpConnA, TRUE);
	if(FAILED(hr))
	{
		LEAVE_DPLOBBY();
		return hr;
	}

	// Conver the ANSI DPLCONNECTION struct to Unicode
	hr = PRV_ConvertDPLCONNECTIONToUnicode(lpConnA, &lpConnW);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to convert DPLCONNECTION structure to Unicode");
		LEAVE_DPLOBBY();
		return hr;
	}

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetConnectionSettings(lpDPL, dwFlags, dwGameID, lpConnW);

	// Free our temporary Unicode DPLCONNECTION structure
	PRV_FreeInternalDPLCONNECTION(lpConnW);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_SetConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_SetGroupConnectionSettings"
HRESULT DPLAPI DPL_A_SetGroupConnectionSettings(LPDIRECTPLAY lpDP,
						DWORD dwFlags, DPID idGroup,
						LPDPLCONNECTION lpConnA)
{
	HRESULT			hr;
	LPDPLCONNECTION	lpConnW = NULL;


	DPF(7, "Entering DPL_A_SetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpConnA);

	ENTER_LOBBY_ALL();

	// Validate the DPLCONNECTION structure and it's members
	hr = PRV_ValidateDPLCONNECTION(lpConnA, TRUE);
	if(FAILED(hr))
	{
		LEAVE_LOBBY_ALL();
		return hr;
	}

	// Conver the ANSI DPLCONNECTION struct to Unicode
	hr = PRV_ConvertDPLCONNECTIONToUnicode(lpConnA, &lpConnW);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to convert DPLCONNECTION structure to Unicode");
		LEAVE_LOBBY_ALL();
		return hr;
	}

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetGroupConnectionSettings(lpDP, dwFlags, idGroup,
										lpConnW, TRUE);

	// Free our temporary Unicode DPLCONNECTION structure
	PRV_FreeInternalDPLCONNECTION(lpConnW);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_A_SetGroupConnectionSettings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplshare.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplshare.c
 *  Content:	Methods for shared buffer management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	5/18/96		myronth	Created it
 *	12/12/96	myronth	Fixed DPLCONNECTION validation & bug #4692
 *	12/13/96	myronth	Fixed bugs #4697 and #4607
 *	2/12/97		myronth	Mass DX5 changes
 *	2/20/97		myronth	Changed buffer R/W to be circular
 *	3/12/97		myronth	Kill thread timeout, DPF error levels
 *	4/1/97		myronth	Fixed handle leak -- bug #7054
 *	5/8/97		myronth	Added bHeader parameter to packing function
 *  5/21/97		ajayj	DPL_SendLobbyMessage - allow DPLMSG_STANDARD flag #8929
 *	5/30/97		myronth	Fixed SetConnectionSettings for invalid AppID (#9110)
 *						Fixed SetLobbyMessageEvent for invalid handle (#9111)
 *	6/19/97		myronth	Fixed handle leak (#10063)
 *	7/30/97		myronth	Added support for standard lobby messaging and
 *						fixed receive loop race condition (#10843)
 *	8/11/97		myronth	Added guidInstance handling in standard lobby requests
 *	8/19/97		myronth	Support for DPLMSG_NEWSESSIONHOST
 *	8/19/97		myronth	Removed dead PRV_SendStandardSystemMessageByObject
 *	8/20/97		myronth	Added DPLMSG_STANDARD to all standard messages
 *	11/13/97	myronth	Added guidInstance to lobby system message (#10944)
 *	12/2/97		myronth	Fixed swallowed error code, moved structure
 *						validation for DPLCONNECTION (#15527, 15529)
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *	10/31/99	aarono add node lock when to SetLobbyMessageEvent
 *			       NTB#411892
 *  02/08/00    aarono  added monitoring for lobby client crash/exit, notify
 *                        lobbied application, Mill B#131938
 *  7/12/00     aarono  fix GUIDs for IPC to be fully significant, otherwise won't IPC.
 ***************************************************************************/
#include "dplobpr.h"

//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------

#define MAX_APPDATABUFFERSIZE		(65535)
#define APPDATA_RESERVEDSIZE		(2 * sizeof(DWORD))

//--------------------------------------------------------------------------
//
//	Debug Functions
//
//--------------------------------------------------------------------------
#ifdef DEBUG

DPF_DUMPWSTR(int level, LPWSTR lpwStr)
{
	char lpszStr[200];
	WideToAnsi(lpszStr,lpwStr,200);
	DPF(level, lpszStr);
}
#else 
#define DPF_DUMPWSTR(a,b)
#endif

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------

HRESULT PRV_ReadCommandLineIPCGuid(GUID *lpguidIPC)
{
	LPWSTR  pwszCommandLine;
	LPWSTR  pwszAlloc=NULL;
	LPWSTR  pwszSwitch=NULL;
	HRESULT hr=DP_OK;
	
	if(!OS_IsPlatformUnicode()){
		// if we get a command line in ANSI, convert to UNICODE, this allows
		// us to avoid the DBCS issues in ANSI while scanning for the IPC GUID
		LPSTR pszCommandLine;
		pszCommandLine=(LPSTR)GetCommandLineA();
		pwszAlloc=DPMEM_ALLOC(MAX_PATH*sizeof(WCHAR));
		if(pwszAlloc){
			hr=AnsiToWide(pwszAlloc,pszCommandLine,MAX_PATH);
			if(FAILED(hr)){
				goto exit;
			}
			pwszCommandLine=pwszAlloc;
		}
	} else {
		pwszCommandLine=(LPWSTR)GetCommandLine(); 
	}

	// pwszCommandLine now points to the UNICODE command line.
	if(pwszSwitch=OS_StrStr(pwszCommandLine,SZ_DP_IPC_GUID)){
		// found the GUID on the command line
		if (OS_StrLen(pwszSwitch) >= (sizeof(SZ_DP_IPC_GUID)+sizeof(SZ_GUID_PROTOTYPE)-sizeof(WCHAR))/sizeof(WCHAR)){
			// skip past the switch description to the actual GUID and extract
			hr=GUIDFromString(pwszSwitch+(sizeof(SZ_DP_IPC_GUID)/sizeof(WCHAR))-1, lpguidIPC);
		} else {
			hr=DPERR_GENERIC;
		}
	} else {
		hr=DPERR_GENERIC;
	}


exit:

	if(pwszAlloc){
		DPMEM_FREE(pwszAlloc);
	}
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetInternalName"
HRESULT PRV_GetInternalName(LPDPLOBBYI_GAMENODE lpgn, DWORD dwType, LPWSTR lpName)
{
	DWORD	pid;
	LPWSTR	lpFileName;
	LPSTR	lpstr1, lpstr2, lpstr3;
	char	szName[256];
	BOOL    bUseGuid=FALSE;


	DPF(7, "Entering PRV_GetInternalName");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x", lpgn, dwType, lpName);


	if(lpgn->dwFlags & GN_IPCGUID_SET){
		bUseGuid=TRUE;
	}
	// Get the current process ID if we are a game, otherwise, we need to
	// get the process ID of the game that we spawned
	else if(lpgn->dwFlags & GN_LOBBY_CLIENT)
	{
		if(lpgn->dwGameProcessID)
			pid = lpgn->dwGameProcessID;
		else
			return DPERR_APPNOTSTARTED;
	}
	else
	{
		pid = GetCurrentProcessId();
	}

	switch(dwType)
	{
		case TYPE_CONNECT_DATA_FILE:
			lpFileName = SZ_CONNECT_DATA_FILE;
			break;

		case TYPE_CONNECT_DATA_MUTEX:
			lpFileName = SZ_CONNECT_DATA_MUTEX;
			break;

		case TYPE_GAME_WRITE_FILE:
			lpFileName = SZ_GAME_WRITE_FILE;
			break;

		case TYPE_LOBBY_WRITE_FILE:
			lpFileName = SZ_LOBBY_WRITE_FILE;
			break;

		case TYPE_LOBBY_WRITE_EVENT:
			lpFileName = SZ_LOBBY_WRITE_EVENT;
			break;

		case TYPE_GAME_WRITE_EVENT:
			lpFileName = SZ_GAME_WRITE_EVENT;
			break;

		case TYPE_LOBBY_WRITE_MUTEX:
			lpFileName = SZ_LOBBY_WRITE_MUTEX;
			break;

		case TYPE_GAME_WRITE_MUTEX:
			lpFileName = SZ_GAME_WRITE_MUTEX;
			break;

		default:
			DPF(2, "We got an Internal Name Type that we didn't expect!");
			return DPERR_GENERIC;
	}

	GetAnsiString(&lpstr2, SZ_FILENAME_BASE);
	GetAnsiString(&lpstr3, lpFileName);

	if(!bUseGuid){
		// REVIEW!!!! -- I can't get the Unicode version of wsprintf to work, so
		// for now, use the ANSI version and convert
		//	wsprintf(lpName, SZ_NAME_TEMPLATE, SZ_FILENAME_BASE, lpFileName, pid);
		GetAnsiString(&lpstr1, SZ_NAME_TEMPLATE);
		wsprintfA((LPSTR)szName, lpstr1, lpstr2, lpstr3, pid);
	} else {
		GetAnsiString(&lpstr1, SZ_GUID_NAME_TEMPLATE);
		wsprintfA((LPSTR)szName, lpstr1, lpstr2, lpstr3);
	}

	AnsiToWide(lpName, szName, (strlen(szName) + 1));

	if(bUseGuid){
		// concatenate the guid to the name if we are using the guid.
		WCHAR *pGuid;
		pGuid = lpName + WSTRLEN(lpName) - 1;
		StringFromGUID(&lpgn->guidIPC, pGuid, GUID_STRING_SIZE);
	}

	DPF(9, "Made internal Name...");
	DPF_DUMPWSTR(9,lpName);

	if(lpstr1)
		DPMEM_FREE(lpstr1);
	if(lpstr2)
		DPMEM_FREE(lpstr2);
	if(lpstr3)
		DPMEM_FREE(lpstr3);

	return DP_OK;

} // PRV_GetInternalName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddNewGameNode"
HRESULT PRV_AddNewGameNode(LPDPLOBBYI_DPLOBJECT this,
				LPDPLOBBYI_GAMENODE * lplpgn, DWORD dwGameID,
				HANDLE hGameProcess, BOOL bLobbyClient, GUID *lpguidIPC)
{
	LPDPLOBBYI_GAMENODE	lpgn;


	DPF(7, "Entering PRV_AddNewGameNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			this, lplpgn, dwGameID, hGameProcess, bLobbyClient);

	lpgn = DPMEM_ALLOC(sizeof(DPLOBBYI_GAMENODE));
	if(!lpgn)
	{
		DPF(2, "Unable to allocate memory for GameNode structure!");
		return DPERR_OUTOFMEMORY;
	}

	// Initialize the GameNode
	lpgn->dwSize = sizeof(DPLOBBYI_GAMENODE);
	lpgn->dwGameProcessID = dwGameID;
	lpgn->hGameProcess = hGameProcess;
	lpgn->this = this;
	lpgn->MessageHead.lpPrev = &lpgn->MessageHead;
	lpgn->MessageHead.lpNext = &lpgn->MessageHead;

	if(lpguidIPC){
		// provided during launch by lobby client
		lpgn->guidIPC=*lpguidIPC;
		lpgn->dwFlags |= GN_IPCGUID_SET;
	} else {
		// need to extract the GUID from the command line if present.
		if(DP_OK==PRV_ReadCommandLineIPCGuid(&lpgn->guidIPC)){
			lpgn->dwFlags |= GN_IPCGUID_SET;
		}
	}

	// If we are a lobby client, set the flag
	if(bLobbyClient)
		lpgn->dwFlags |= GN_LOBBY_CLIENT;
	
	// Add the GameNode to the list
	lpgn->lpgnNext = this->lpgnHead;
	this->lpgnHead = lpgn;

	// Set the output pointer
	*lplpgn = lpgn;

	return DP_OK;

} // PRV_AddNewGameNode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetGameNode"
LPDPLOBBYI_GAMENODE PRV_GetGameNode(LPDPLOBBYI_GAMENODE lpgnHead, DWORD dwGameID)
{
	LPDPLOBBYI_GAMENODE	lpgnTemp = lpgnHead;
	GUID guidIPC=GUID_NULL;
	BOOL bFoundGUID;

	DPF(7, "Entering PRV_GetGameNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpgnHead, dwGameID);

	if(DP_OK==PRV_ReadCommandLineIPCGuid(&guidIPC)){
		bFoundGUID=TRUE;
	} else {
		bFoundGUID=FALSE;
	}

	while(lpgnTemp)
	{
		if((lpgnTemp->dwGameProcessID == dwGameID) || 
		   ((bFoundGUID) && (lpgnTemp->dwFlags & GN_IPCGUID_SET) && (IsEqualGUID(&lpgnTemp->guidIPC,&guidIPC))))
			return lpgnTemp;
		else
			lpgnTemp = lpgnTemp->lpgnNext;
	}

	return NULL;

} // PRV_GetGameNode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetupClientDataAccess"
BOOL PRV_SetupClientDataAccess(LPDPLOBBYI_GAMENODE lpgn)
{
	SECURITY_ATTRIBUTES		sa;
	HANDLE					hConnDataMutex = NULL;
	HANDLE					hLobbyWrite = NULL;
	HANDLE					hLobbyWriteMutex = NULL;
	HANDLE					hGameWrite = NULL;
	HANDLE					hGameWriteMutex = NULL;
	WCHAR					szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];


	DPF(7, "Entering PRV_SetupClientDataAccess");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// Set up the security attributes (so that our objects can
	// be inheritable)
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;

	// Create the ConnectionData Mutex
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_CONNECT_DATA_MUTEX,
								(LPWSTR)&szName)))
	{
		hConnDataMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)&szName);
	}

	// Create the GameWrite Event
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_GAME_WRITE_EVENT, (LPWSTR)&szName)))
	{
		hGameWrite = OS_CreateEvent(&sa, FALSE, FALSE, (LPWSTR)&szName);
	}

	// Create the GameWrite Mutex
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_GAME_WRITE_MUTEX,
								(LPWSTR)&szName)))
	{
		hGameWriteMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)&szName);
	}

	// Create the LobbyWrite Event
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_LOBBY_WRITE_EVENT, (LPWSTR)&szName)))
	{
		hLobbyWrite = OS_CreateEvent(&sa, FALSE, FALSE, (LPWSTR)&szName);
	}

	// Create the LobbyWrite Mutex
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_LOBBY_WRITE_MUTEX,
								(LPWSTR)&szName)))
	{
		hLobbyWriteMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)&szName);
	}


	// Check for errors
	if(!hConnDataMutex || !hGameWrite || !hGameWriteMutex
			|| !hLobbyWrite || !hLobbyWriteMutex)
	{
		if(hConnDataMutex)
			CloseHandle(hConnDataMutex);
		if(hGameWrite)
			CloseHandle(hGameWrite);
		if(hGameWriteMutex)
			CloseHandle(hGameWriteMutex);
		if(hLobbyWrite)
			CloseHandle(hLobbyWrite);
		if(hLobbyWriteMutex)
			CloseHandle(hLobbyWriteMutex);

		return FALSE;
	}

	// Save the handles
	lpgn->hConnectDataMutex = hConnDataMutex;
	lpgn->hGameWriteEvent = hGameWrite;
	lpgn->hGameWriteMutex = hGameWriteMutex;
	lpgn->hLobbyWriteEvent = hLobbyWrite;
	lpgn->hLobbyWriteMutex = hLobbyWriteMutex;

	return TRUE;

} // PRV_SetupClientDataAccess



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDataBuffer"
HRESULT PRV_GetDataBuffer(LPDPLOBBYI_GAMENODE lpgn, DWORD dwType,
				DWORD dwSize, LPHANDLE lphFile, LPVOID * lplpMemory)
{
	HRESULT						hr;
	SECURITY_ATTRIBUTES			sa;
	WCHAR						szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];
	LPVOID						lpMemory = NULL;
	HANDLE						hFile = NULL;
	DWORD						dwError = 0;


	DPF(7, "Entering PRV_GetDataBuffer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpgn, dwType, dwSize, lphFile, lplpMemory);

	// Get the data buffer filename
	hr = PRV_GetInternalName(lpgn, dwType, (LPWSTR)szName);
	if(FAILED(hr))
		return hr;

	// If we are a Lobby Client, we need to create the file. If we
	// are a game, we need to open the already created file for
	// connection data, or we can create the file for game data (if
	// it doesn't already exist).
	if(lpgn->dwFlags & GN_LOBBY_CLIENT)
	{
		// Set up the security attributes (so that our mapping can
		// be inheritable
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;
		sa.bInheritHandle = TRUE;
		
		// Create the file mapping
		hFile = OS_CreateFileMapping(INVALID_HANDLE_VALUE, &sa,
							PAGE_READWRITE,	0, dwSize,
							(LPWSTR)szName);
	}
	else
	{
		hFile = OS_OpenFileMapping(FILE_MAP_ALL_ACCESS, TRUE, (LPWSTR)szName);
	}

	if(!hFile)
	{
		dwError = GetLastError();
		// WARNING: error may not be correct since calls we are trying to get last error from may have called out
		// to another function before returning.
		DPF(5, "Couldn't get a handle to the shared local memory, dwError = %lu (error may not be correct)", dwError);
		return DPERR_OUTOFMEMORY;
	}

	// Map a View of the file
	lpMemory = MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);

	if(!lpMemory)
	{
		dwError = GetLastError();
		DPF(5, "Unable to get pointer to shared local memory, dwError = %lu", dwError);
		CloseHandle(hFile);
		return DPERR_OUTOFMEMORY;
	}


	// Setup the control structure based on the buffer type
	switch(dwType)
	{
		case TYPE_CONNECT_DATA_FILE:
		{
			LPDPLOBBYI_CONNCONTROL		lpControl = NULL;
						
			
			lpControl = (LPDPLOBBYI_CONNCONTROL)lpMemory;

			// If the buffer has been initialized, then don't worry
			// about it.  If the token is wrong (uninitialized), then do it
			if(lpControl->dwToken != BC_TOKEN)
			{
				lpControl->dwToken = BC_TOKEN;
				lpControl->dwFlags = 0;
				if(lpgn->dwFlags & GN_LOBBY_CLIENT){
					lpControl->CliProcId = GetCurrentProcessId();
				}
			}
			break;
		}
		case TYPE_GAME_WRITE_FILE:
		case TYPE_LOBBY_WRITE_FILE:
		{
			LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;


			lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpMemory;
			if(lpgn->dwFlags & GN_LOBBY_CLIENT)
			{
				// Since we're the lobby client, we know we create the buffer, so
				// initialize the entire structure
				lpControl->dwToken = BC_TOKEN;
				lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
				lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
				lpControl->dwFlags = BC_LOBBY_ACTIVE;
				lpControl->dwMessages = 0;
				lpControl->dwBufferSize = dwSize;
				lpControl->dwBufferLeft = dwSize - sizeof(DPLOBBYI_BUFFERCONTROL);
			}
			else
			{
				// We're the game, but we don't know for sure if we just created
				// the buffer or if a lobby client did.  So check the token.  If
				// it is incorrect, we will assume we just created it and we need
				// to initialize the buffer control struct.  Otherwise, we will
				// assume a lobby client created it and we just need to add
				// our flag.
				if(lpControl->dwToken != BC_TOKEN)
				{
					// We don't see the token, so initialize the structure
					lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
					lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
					lpControl->dwFlags = BC_GAME_ACTIVE;
					lpControl->dwMessages = 0;
					lpControl->dwBufferSize = dwSize;
					lpControl->dwBufferLeft = dwSize - sizeof(DPLOBBYI_BUFFERCONTROL);
				}
				else
				{
					// We assume the lobby created this buffer, so just set our flag
					lpControl->dwFlags |= BC_GAME_ACTIVE;
				}
			}
			break;
		}
	}

	// Fill in the output parameters
	*lphFile = hFile;
	*lplpMemory = lpMemory;

	return DP_OK;

} // PRV_GetDataBuffer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_StartReceiveThread"
HRESULT PRV_StartReceiveThread(LPDPLOBBYI_GAMENODE lpgn)
{
	HANDLE	hReceiveThread = NULL;
	HANDLE	hKillEvent = NULL;
	DWORD	dwThreadID;


	DPF(7, "Entering PRV_StartReceiveThread");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	// Create the kill event if one doesn't exists
	if(!(lpgn->hKillReceiveThreadEvent))
	{
		hKillEvent = OS_CreateEvent(NULL, FALSE, FALSE, NULL);
		if(!hKillEvent)
		{
			DPF(2, "Unable to create Kill Receive Thread Event");
			return DPERR_OUTOFMEMORY;
		}
	}

	// If the Receive Thread isn't going, start it
	if(!(lpgn->hReceiveThread))
	{
		// Spawn off a receive notification thread for the cross-proc communication
		hReceiveThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)
							PRV_ReceiveClientNotification, lpgn, 0, &dwThreadID);

		if(!hReceiveThread)
		{
			DPF(2, "Unable to create Receive Thread!");
			if(hKillEvent)
				CloseHandle(hKillEvent);
			return DPERR_OUTOFMEMORY;
		}

		lpgn->hReceiveThread = hReceiveThread;
		if(hKillEvent)
			lpgn->hKillReceiveThreadEvent = hKillEvent;

	}

	return DP_OK;

} // PRV_StartReceiveThread



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetupAllSharedMemory"
HRESULT PRV_SetupAllSharedMemory(LPDPLOBBYI_GAMENODE lpgn)
{
	HRESULT	hr;
	LPVOID		lpConnDataMemory = NULL;
	LPVOID		lpGameMemory = NULL;
	LPVOID		lpLobbyMemory = NULL;
	HANDLE		hFileConnData = NULL;
	HANDLE		hFileGameWrite = NULL;
	HANDLE		hFileLobbyWrite = NULL;
	DWORD		dwError = 0;


	DPF(7, "Entering PRV_SetupAllSharedMemory");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// Get access to the Connection Data File
	hr = PRV_GetDataBuffer(lpgn, TYPE_CONNECT_DATA_FILE,
								MAX_APPDATABUFFERSIZE,
								&hFileConnData, &lpConnDataMemory);
	if(FAILED(hr))
	{
		DPF(5, "Couldn't get access to Connection Data buffer");
		goto ERROR_SETUP_SHARED_MEMORY;
	}

	// Do the same for the Game Write File...
	hr = PRV_GetDataBuffer(lpgn, TYPE_GAME_WRITE_FILE,
								MAX_APPDATABUFFERSIZE,
								&hFileGameWrite, &lpGameMemory);
	if(FAILED(hr))
	{
		DPF(5, "Couldn't get access to Game Write buffer");
		goto ERROR_SETUP_SHARED_MEMORY;
	}


	// Do the same for the Lobby Write File...
	hr = PRV_GetDataBuffer(lpgn, TYPE_LOBBY_WRITE_FILE,
								MAX_APPDATABUFFERSIZE,
								&hFileLobbyWrite, &lpLobbyMemory);
	if(FAILED(hr))
	{
		DPF(5, "Couldn't get access to Lobby Write buffer");
		goto ERROR_SETUP_SHARED_MEMORY;
	}


	// Setup the signalling objects
	if(!PRV_SetupClientDataAccess(lpgn))
	{
		DPF(5, "Unable to create synchronization objects for shared memory!");
		return DPERR_OUTOFMEMORY;
	}

	// Save the file handles
	lpgn->hConnectDataFile = hFileConnData;
	lpgn->lpConnectDataBuffer = lpConnDataMemory;
	lpgn->hGameWriteFile = hFileGameWrite;
	lpgn->lpGameWriteBuffer = lpGameMemory;
	lpgn->hLobbyWriteFile = hFileLobbyWrite;
	lpgn->lpLobbyWriteBuffer = lpLobbyMemory;

	// Set the flag that tells us the shared memory files are valid
	lpgn->dwFlags |= GN_SHARED_MEMORY_AVAILABLE;

	// Start the Receive Thread
	hr = PRV_StartReceiveThread(lpgn);
	if(FAILED(hr))
	{
		// In this case, we will keep our shared buffers around.  Don't
		// worry about cleaning them up here -- we'll probably still need
		// them later, and they will get cleaned up later.
		DPF(5, "Unable to start receive thread");
		return hr;
	}

	return DP_OK;


ERROR_SETUP_SHARED_MEMORY:

		if(hFileConnData)
			CloseHandle(hFileConnData);
		if(lpConnDataMemory)
			UnmapViewOfFile(lpConnDataMemory);
		if(hFileGameWrite)
			CloseHandle(hFileGameWrite);
		if(lpGameMemory)
			UnmapViewOfFile(lpGameMemory);
		if(hFileLobbyWrite)
			CloseHandle(hFileLobbyWrite);
		if(lpLobbyMemory)
			UnmapViewOfFile(lpLobbyMemory);

		return hr;

} // PRV_SetupAllSharedMemory



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnterConnSettingsWaitMode"
void PRV_EnterConnSettingsWaitMode(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_CONNCONTROL		lpConnControl = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpBufferControl = NULL;


	DPF(7, "Entering PRV_EnterConnSettingsWaitMode");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	// Set the flag in the ConnSettings buffer
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	lpConnControl->dwFlags |= BC_WAIT_MODE;
	ReleaseMutex(lpgn->hConnectDataMutex);

	// Set the flag in the GameWrite buffer
	WaitForSingleObject(lpgn->hGameWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpGameWriteBuffer;
	lpBufferControl->dwFlags |= BC_WAIT_MODE;
	ReleaseMutex(lpgn->hGameWriteMutex);

	// Set the flag in the LobbyWrite buffer
	WaitForSingleObject(lpgn->hLobbyWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
	lpBufferControl->dwFlags |= BC_WAIT_MODE;
	ReleaseMutex(lpgn->hLobbyWriteMutex);

} // PRV_EnterConnSettingsWaitMode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LeaveConnSettingsWaitMode"
void PRV_LeaveConnSettingsWaitMode(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_CONNCONTROL		lpConnControl = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpBufferControl = NULL;


	DPF(7, "Entering PRV_LeaveConnSettingsWaitMode");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	// Clear the flag in the ConnSettings buffer
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	lpConnControl->dwFlags &= ~(BC_WAIT_MODE | BC_PENDING_CONNECT);
	ReleaseMutex(lpgn->hConnectDataMutex);

	// Clear the flag in the GameWrite buffer
	WaitForSingleObject(lpgn->hGameWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpGameWriteBuffer;
	lpBufferControl->dwFlags &= ~BC_WAIT_MODE;
	ReleaseMutex(lpgn->hGameWriteMutex);

	// Clear the flag in the LobbyWrite buffer
	WaitForSingleObject(lpgn->hLobbyWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
	lpBufferControl->dwFlags &= ~BC_WAIT_MODE;
	ReleaseMutex(lpgn->hLobbyWriteMutex);

} // PRV_LeaveConnSettingsWaitMode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteClientData"
HRESULT PRV_WriteClientData(LPDPLOBBYI_GAMENODE lpgn, DWORD dwFlags,
							LPVOID lpData, DWORD dwSize)
{
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;
	LPDPLOBBYI_MESSAGEHEADER	lpHeader = NULL;
	HANDLE						hMutex = NULL;
	DWORD						dwSizeToEnd = 0;
	LPBYTE						lpTemp = NULL;
    HRESULT						hr = DP_OK;


	DPF(7, "Entering PRV_WriteClientData");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu",
			lpgn, dwFlags, lpData, dwSize);

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access App Data memory");
			return hr;
		}
	}
	LEAVE_DPLGAMENODE();

	
	// Grab the mutex
	hMutex = (lpgn->dwFlags & GN_LOBBY_CLIENT) ?
			(lpgn->hLobbyWriteMutex) : (lpgn->hGameWriteMutex);
	WaitForSingleObject(hMutex, INFINITE);

	// Get a pointer to our control structure
	lpControl = (LPDPLOBBYI_BUFFERCONTROL)((lpgn->dwFlags &
				GN_LOBBY_CLIENT) ? (lpgn->lpLobbyWriteBuffer)
				: (lpgn->lpGameWriteBuffer));

	// If we're in wait mode, bail
	if(lpControl->dwFlags & BC_WAIT_MODE)
	{
		DPF_ERR("Cannot send lobby message while in Wait Mode for new ConnectionSettings");
		hr = DPERR_UNAVAILABLE;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// If we are the game, check to see if the lobby client is even there. In
	// the self-lobbied case, it won't be.  If it is not there, don't even
	// bother sending anything.
	if((!(lpgn->dwFlags & GN_LOBBY_CLIENT)) && (!(lpControl->dwFlags
		& BC_LOBBY_ACTIVE)))
	{
		DPF(5, "There is not active lobby client; Not sending message");
		hr = DPERR_UNAVAILABLE;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// Make sure there is enough space left for the message and two dwords
	if(lpControl->dwBufferLeft < (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER)))
	{
		DPF(5, "Not enough space left in the message buffer");
		hr = DPERR_BUFFERTOOSMALL;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// Copy in the data. First make sure we can write from the cursor
	// forward without having to wrap around to the beginning of the buffer,
	// but make sure we don't write past the read cursor
	if(lpControl->dwWriteOffset >= lpControl->dwReadOffset)
	{
		// Our write pointer is ahead of our read pointer (cool). Figure
		// out if we have enough room between our write pointer and the
		// end of the buffer.  If we do, then just write it.  If we don't
		// we need to wrap it.
		dwSizeToEnd = lpControl->dwBufferSize - lpControl->dwWriteOffset;
		if(dwSizeToEnd >= (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER)))
		{
			// We have enough room
			lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl
							+ lpControl->dwWriteOffset);
			lpHeader->dwSize = dwSize;
			lpHeader->dwFlags = dwFlags;
			lpTemp = (LPBYTE)(++lpHeader);
			memcpy(lpTemp, lpData, dwSize);

			// Move the write cursor, and check to see if we have enough
			// room for the header on the next message.  If the move causes
			// us to wrap, or if we are within one header's size,
			// we need to move the write cursor back to the beginning
			// of the buffer
			lpControl->dwWriteOffset += dwSize + sizeof(DPLOBBYI_MESSAGEHEADER);
			if(lpControl->dwWriteOffset > (lpControl->dwBufferSize -
					sizeof(DPLOBBYI_MESSAGEHEADER)))
			{
				// Increment the amount of free buffer by the amount we
				// are about to skip over to wrap
				lpControl->dwBufferLeft -= (lpControl->dwBufferSize -
					lpControl->dwWriteOffset);
				
				// We're closer than one header's size
				lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
			}
		}
		else
		{
			// We don't have enough room before the end, so we need to
			// wrap the message (ugh).  Here's the rules:
			//		1. If we don't have enough bytes for the header, start
			//			the whole thing at the beginning of the buffer
			//		2. If we have enough bytes, write as much
			//			as we can and wrap the rest.
			if(dwSizeToEnd < sizeof(DPLOBBYI_MESSAGEHEADER))
			{
				// We don't even have room for our two dwords, so wrap
				// the whole thing. So first decrement the amount of
				// free memory left and make sure we will still fit
				lpControl->dwBufferLeft -= dwSizeToEnd;
				if(lpControl->dwBufferLeft < (dwSize +
						sizeof(DPLOBBYI_MESSAGEHEADER)))
				{
					DPF(5, "Not enough space left in the message buffer");
					hr = DPERR_BUFFERTOOSMALL;
					goto EXIT_WRITE_CLIENT_DATA;
				}
				
				// Reset the write pointer and copy
				lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl +
						sizeof(DPLOBBYI_BUFFERCONTROL));
				lpHeader->dwSize = dwSize;
				lpHeader->dwFlags = dwFlags;
				lpTemp = (LPBYTE)(++lpHeader);
				memcpy(lpTemp, lpData, dwSize);

				// Move the write cursor
				lpControl->dwWriteOffset += sizeof(DPLOBBYI_BUFFERCONTROL) +
							(dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
			}
			else
			{
				// We at least have enough room for the two dwords
				lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl
							+ lpControl->dwWriteOffset);
				lpHeader->dwSize = dwSize;
				lpHeader->dwFlags = dwFlags;

				// Now figure out how much we can write
				lpTemp = (LPBYTE)(++lpHeader);
				dwSizeToEnd -= sizeof(DPLOBBYI_MESSAGEHEADER);
				if(!dwSizeToEnd)
				{
					// We need to wrap to write the whole message
					lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
					memcpy(lpTemp, lpData, dwSize);

					// Move the write cursor
					lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL)
							+ dwSize;
				}
				else
				{
					// Copy as many bytes as we can
					memcpy(lpTemp, lpData, dwSizeToEnd);

					// Move both pointers and finish the job
					lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
					memcpy(lpTemp, ((LPBYTE)lpData + dwSizeToEnd), (dwSize -
							dwSizeToEnd));

					// Move the write cursor
					lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL)
							+ (dwSize - dwSizeToEnd);
				}
			}
		}
	}
	else
	{
		// Our read pointer is ahead of our write pointer.  Since we checked
		// and found there is enough room to write, we should just be able
		// to just slam this guy in.
		lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl +
						lpControl->dwWriteOffset);
		lpHeader->dwSize = dwSize;
		lpHeader->dwFlags = dwFlags;
		lpTemp = (LPBYTE)(++lpHeader);
		memcpy(lpTemp, lpData, dwSize);

		// Move the write cursor
		lpControl->dwWriteOffset += dwSize + sizeof(DPLOBBYI_MESSAGEHEADER);
	}

	// Decrement the amount of free space left and increment the message count
	lpControl->dwBufferLeft -= (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
	lpControl->dwMessages++;

	// Signal the other user that we have written something
	SetEvent((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
			(lpgn->hLobbyWriteEvent) : (lpgn->hGameWriteEvent));

	// Fall through

EXIT_WRITE_CLIENT_DATA:

	// Release the mutex
	ReleaseMutex(hMutex);
	return hr;

} // PRV_WriteClientData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendStandardSystemMessage"
HRESULT PRV_SendStandardSystemMessage(LPDIRECTPLAYLOBBY lpDPL,
			DWORD dwMessage, DWORD dwGameID)
{
	LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
	HRESULT					hr;
	DWORD					dwMessageSize;
	LPVOID					lpmsg = NULL;
	DWORD					dwFlags;


	DPF(7, "Entering PRV_SendStandardSystemMessage");
	DPF(9, "Parameters: 0x%08x, %lu, %lu",
			lpDPL, dwMessage, dwGameID);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If dwGameID is zero it means that we are the game, so
	// we need to get the current process ID.  Otherwise, it
	// means we are the lobby client
	if(!dwGameID)
		dwGameID = GetCurrentProcessId();

	// Now find the correct game node
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		if(FAILED(PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, FALSE,NULL)))
		{
			LEAVE_DPLOBBY();
			return DPERR_OUTOFMEMORY;
		}
	}

	// Get the size of the message
	switch(dwMessage)
	{
		case DPLSYS_NEWSESSIONHOST:
			dwMessageSize = sizeof(DPLMSG_NEWSESSIONHOST);
			break;

		default:
			dwMessageSize = sizeof(DPLMSG_SYSTEMMESSAGE);
			break;
	}

	// Allocate a buffer for the message
	lpmsg = DPMEM_ALLOC(dwMessageSize);
	if(!lpmsg)
	{
		LEAVE_DPLOBBY();
		DPF_ERRVAL("Unable to allocate memory for lobby system message, dwMessage = %lu", dwMessage);
		return DPERR_OUTOFMEMORY;
	}

	// Setup the message
	((LPDPLMSG_SYSTEMMESSAGE)lpmsg)->dwType = dwMessage;
	((LPDPLMSG_SYSTEMMESSAGE)lpmsg)->guidInstance = lpgn->guidInstance;

	// Write into the shared buffer
	dwFlags = DPLMSG_SYSTEM | DPLMSG_STANDARD;
	hr = PRV_WriteClientData(lpgn, dwFlags, lpmsg, dwMessageSize);
	if(FAILED(hr))
	{
		DPF(8, "Couldn't send system message");
	}

	// Free our buffer
	DPMEM_FREE(lpmsg);

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SendStandardSystemMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddNewRequestNode"
HRESULT PRV_AddNewRequestNode(LPDPLOBBYI_DPLOBJECT this,
		LPDPLOBBYI_GAMENODE lpgn, LPDPLMSG_GENERIC lpmsg, BOOL bSlamGuid)
{
	LPDPLOBBYI_REQUESTNODE	lprn = NULL;


	// Allocate memory for a Request Node
	lprn = DPMEM_ALLOC(sizeof(DPLOBBYI_REQUESTNODE));
	if(!lprn)
	{
		DPF_ERR("Unable to allocate memory for request node, system message not sent");
		return DPERR_OUTOFMEMORY;
	}
	
	// Setup the request node
	lprn->dwFlags = lpgn->dwFlags;
	lprn->dwRequestID = this->dwCurrentRequest;
	lprn->dwAppRequestID = ((LPDPLMSG_GETPROPERTY)lpmsg)->dwRequestID;
	lprn->lpgn = lpgn;

	// Add the slammed guid flag if needed
	if(bSlamGuid)
		lprn->dwFlags |= GN_SLAMMED_GUID;

	// Change the request ID in the message to our internal one (we'll
	// change it back on Receive
	((LPDPLMSG_GETPROPERTY)lpmsg)->dwRequestID = this->dwCurrentRequest++;

	// Add the node to the list
	if(this->lprnHead)
		this->lprnHead->lpPrev = lprn;
	lprn->lpNext = this->lprnHead;
	this->lprnHead = lprn;

	return DP_OK;

} // PRV_AddNewRequestNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveRequestNode"
void PRV_RemoveRequestNode(LPDPLOBBYI_DPLOBJECT this,
		LPDPLOBBYI_REQUESTNODE lprn)
{
	// If we're the head, move it
	if(lprn == this->lprnHead)
		this->lprnHead = lprn->lpNext;

	// Fixup the previous & next pointers
	if(lprn->lpPrev)
		lprn->lpPrev->lpNext = lprn->lpNext;
	if(lprn->lpNext)
		lprn->lpNext->lpPrev = lprn->lpPrev;

	// Free the node
	DPMEM_FREE(lprn);

} // PRV_RemoveRequestNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ForwardMessageToLobbyServer"
HRESULT PRV_ForwardMessageToLobbyServer(LPDPLOBBYI_GAMENODE lpgn,
		LPVOID lpBuffer, DWORD dwSize, BOOL bStandard)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLMSG_GENERIC		lpmsg = NULL;
	HRESULT					hr;
	BOOL					bSlamGuid = FALSE;


	DPF(7, "Entering PRV_ForwardMessageToLobbyServer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, %lu",
			lpgn, lpBuffer, dwSize, bStandard);


    TRY
    {
		// Validate the dplay object
		hr = VALID_DPLAY_PTR( lpgn->lpDPlayObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}

		// Validate the lobby object
		this = lpgn->lpDPlayObject->lpLobbyObject;
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("Invalid lobby object");
			return DPERR_INVALIDOBJECT;
        }
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If this is a property request, we need to create a request node
	lpmsg = (LPDPLMSG_GENERIC)lpBuffer;
	if(bStandard)
	{
		// If it's a property message, we need a request node
		switch(lpmsg->dwType)
		{
			case DPLSYS_GETPROPERTY:
			{
				LPDPLMSG_GETPROPERTY	lpgp = lpBuffer;

				// If it's a GETPROPERTY message, we need to check to see if
				// the player guid is NULL.  If it is, we need to
				// stuff the game's Instance guid in that field
				if(IsEqualGUID(&lpgp->guidPlayer, &GUID_NULL))
				{
					// Stuff the instance guid of the game
					lpgp->guidPlayer = lpgn->guidInstance;
					bSlamGuid = TRUE;
				}

				// Add a request node to the pending requests list
				hr = PRV_AddNewRequestNode(this, lpgn, lpmsg, bSlamGuid);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Unable to add request node to list, hr = 0x%08x", hr);
					return hr;
				}
				break;
			}
			
			case DPLSYS_SETPROPERTY:
			{
				LPDPLMSG_SETPROPERTY	lpsp = lpBuffer;
				
				// If it's a SETPROPERTY message, we need to check to see if
				// the player guid is NULL.  If it is, we need to
				// stuff the game's Instance guid in that field
				if(IsEqualGUID(&lpsp->guidPlayer, &GUID_NULL))
				{
					// Stuff the instance guid of the game
					lpsp->guidPlayer = lpgn->guidInstance;
					bSlamGuid = TRUE;
				}

				// If the request ID is zero, we don't need to swap
				// the ID's or add a pending request
				if(lpsp->dwRequestID != 0)
				{
					// Add a request node to the pending requests list
					hr = PRV_AddNewRequestNode(this, lpgn, lpmsg, bSlamGuid);
					if(FAILED(hr))
					{
						DPF_ERRVAL("Unable to add request node to list, hr = 0x%08x", hr);
						return hr;
					}
				}
				break;
			}

			case DPLSYS_NEWSESSIONHOST:
				((LPDPLMSG_NEWSESSIONHOST)lpBuffer)->guidInstance = lpgn->guidInstance;
				break;
			
			default:
				break;
		}
	}


	// Call Send on the lobby object
	hr = PRV_Send(this, lpgn->dpidPlayer, DPID_SERVERPLAYER,
			DPSEND_LOBBYSYSTEMMESSAGE, lpBuffer, dwSize);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed sending lobby message, hr = 0x%08x", hr);
	}

	return hr;

} // PRV_ForwardMessageToLobbyServer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_InjectMessageInQueue"
HRESULT PRV_InjectMessageInQueue(LPDPLOBBYI_GAMENODE lpgn, DWORD dwFlags,
							LPVOID lpData, DWORD dwSize, BOOL bForward)
{
	LPDPLOBBYI_MESSAGE	lpm = NULL;
	LPVOID				lpBuffer = NULL;
	HRESULT				hr;


	DPF(7, "Entering PRV_InjectMessageInQueue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu, %lu",
			lpgn, dwFlags, lpData, dwSize, bForward);

	ASSERT(lpData);

	// Allocate memory for the node and the data buffer
	lpm = DPMEM_ALLOC(sizeof(DPLOBBYI_MESSAGE));
	lpBuffer = DPMEM_ALLOC(dwSize);
	if((!lpm) || (!lpBuffer))
	{
		DPF_ERR("Unable to allocate memory for system message");
		if(lpm)
			DPMEM_FREE(lpm);
		if(lpBuffer)
			DPMEM_FREE(lpBuffer);
		return DPERR_OUTOFMEMORY;
	}

	// Copy the data
	memcpy(lpBuffer, lpData, dwSize);

	// Before we put it in our own queue, forward it onto the lobby server
	// if there is one.
	if(bForward && (lpgn->dwFlags & GN_CLIENT_LAUNCHED))
	{
		hr = PRV_ForwardMessageToLobbyServer(lpgn, lpData, dwSize, FALSE);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed forwarding system message to lobby server, hr = 0x%08x", hr);
		}
	}

	// Save the data pointer & the external flags
	// Note: If we're injecting this, it has to be a system message,
	// so set the flag just in case we forgot elsewhere.
	lpm->dwFlags = (dwFlags | DPLAD_SYSTEM);
	lpm->dwSize = dwSize;
	lpm->lpData = lpBuffer;

	// Add the message to the end of the queue & increment the count
	ENTER_DPLQUEUE();
	lpm->lpPrev = lpgn->MessageHead.lpPrev;
	lpgn->MessageHead.lpPrev->lpNext = lpm;
	lpgn->MessageHead.lpPrev = lpm;
	lpm->lpNext = &lpgn->MessageHead;

	lpgn->dwMessageCount++;
	LEAVE_DPLQUEUE();

	// Kick the event handle
	if(lpgn->hDupReceiveEvent)
	{
		SetEvent(lpgn->hDupReceiveEvent);
	}

	return DP_OK;

} // PRV_InjectMessageInQueue


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ReadClientData"
HRESULT PRV_ReadClientData(LPDPLOBBYI_GAMENODE lpgn, LPDWORD lpdwFlags,
							LPVOID lpData, LPDWORD lpdwDataSize)
{
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;
	LPDPLOBBYI_MESSAGEHEADER	lpHeader = NULL;
	DWORD						dwSize = 0;
	DWORD_PTR					dwSizeToEnd = 0;
	HANDLE						hMutex = NULL;
	LPBYTE						lpTemp = NULL;
	LPBYTE						lpEnd = NULL;
	HRESULT						hr = DP_OK;


	DPF(7, "Entering PRV_ReadClientData");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpgn, lpdwFlags, lpData, lpdwDataSize);

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access App Data memory");
			return hr;
		}
	}
	LEAVE_DPLGAMENODE();

	// Grab the mutex
	// REVIEW!!!! -- Is there anything that might cause this wait to hang????
	hMutex = (lpgn->dwFlags & GN_LOBBY_CLIENT) ?
			(lpgn->hGameWriteMutex) : (lpgn->hLobbyWriteMutex);
	WaitForSingleObject(hMutex, INFINITE);

	// Get a pointer to our control structure
	lpControl = (LPDPLOBBYI_BUFFERCONTROL)((lpgn->dwFlags &
				GN_LOBBY_CLIENT) ? (lpgn->lpGameWriteBuffer)
				: (lpgn->lpLobbyWriteBuffer));

	// Make sure there are any messages in the buffer
	if(!lpControl->dwMessages)
	{
		DPF(8, "No messages in shared buffer");
		hr = DPERR_NOMESSAGES;
		goto EXIT_READ_CLIENT_DATA;
	}

	// Make sure there is enough space for the message
	lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl
				+ lpControl->dwReadOffset);
	dwSize = lpHeader->dwSize;

	// Set the output data size (even if we fail, we want to return it)
	if(lpdwDataSize)
		*lpdwDataSize = dwSize;

	if((!lpData) || (dwSize > *lpdwDataSize))
	{
		DPF(8, "Message buffer is too small, must be at least %d bytes", dwSize);
		hr = DPERR_BUFFERTOOSMALL;
		goto EXIT_READ_CLIENT_DATA;
	}

	// Set the output flags
	if(lpdwFlags)
		*lpdwFlags = lpHeader->dwFlags;

	// Now check and see if we are going to wrap. If we are, some of the message
	// will be at the end of the buffer, some will be at the beginning.
	lpTemp = (LPBYTE)(++lpHeader) + dwSize;
	if(lpTemp > ((LPBYTE)lpControl + lpControl->dwBufferSize))
	{
		// Figure out where we need to wrap
		dwSizeToEnd = ((LPBYTE)lpControl + lpControl->dwBufferSize)
						- (LPBYTE)(lpHeader);

		if(!dwSizeToEnd)
		{
			// We are at the end, so the whole message must be at the
			// beginning of the buffer
			lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
			memcpy(lpData, lpTemp, dwSize);

			// Move the read cursor
			lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL) + dwSize;
		}
		else
		{
			// Copy the first part of the data
			lpTemp = (LPBYTE)lpHeader;
			memcpy(lpData, lpTemp, (DWORD)dwSizeToEnd);

			// Move the read cursor and copy the rest
			lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
			memcpy(((LPBYTE)lpData + dwSizeToEnd), lpTemp,
					(DWORD)(dwSize - dwSizeToEnd));

			// Move the read pointer
			lpControl->dwReadOffset = (DWORD)(sizeof(DPLOBBYI_BUFFERCONTROL)
						+ (dwSize - dwSizeToEnd));
		}
	}
	else
	{
		// We don't have to wrap (cool).
		lpTemp = (LPBYTE)lpHeader;
		memcpy(lpData, lpTemp, dwSize);

		// Move the read pointer.  If there are less than 8 bytes left in the
		// buffer, we should move the read pointer to the beginning.  We need
		// to add however many bytes we skip (at the end) back into our free
		// buffer memory counter.
		lpTemp += dwSize;
		lpEnd = (LPBYTE)lpControl + lpControl->dwBufferSize;
		if(lpTemp > (lpEnd	- sizeof(DPLOBBYI_MESSAGEHEADER)))
		{
			// Move the read cursor to the beginning
			lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL);

			// Add the number of bytes to the free buffer total
			lpControl->dwBufferLeft += (DWORD)(lpEnd - lpTemp);
		}
		else
			lpControl->dwReadOffset += (DWORD)(dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
	}


	// Increment the amount of free space left and decrement the message count
	lpControl->dwBufferLeft += (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
	lpControl->dwMessages--;

	// Fall through

EXIT_READ_CLIENT_DATA:

	// Release the mutex
	ReleaseMutex(hMutex);

	return hr;

} // PRV_ReadClientData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ReceiveClientNotification"
DWORD WINAPI PRV_ReceiveClientNotification(LPVOID lpParam)
{
    LPDPLOBBYI_GAMENODE			lpgn = (LPDPLOBBYI_GAMENODE)lpParam;
    LPDPLOBBYI_MESSAGE			lpm = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;
	LPDPLMSG_GENERIC			lpmsg = NULL;
	HRESULT						hr;
	HANDLE						hEvents[4];
	LPVOID						lpBuffer = NULL;
	DWORD						dwFlags;
	DWORD						dwSize;
	DWORD						dwReturn;
	BOOL						bForward;

	DWORD						dwWait=INFINITE;
	DWORD						nWait=2;

	DPF(7, "Entering PRV_ReceiveClientNotification");
	DPF(9, "Parameters: 0x%08x", lpParam);

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		BOOL	bGameCreate=FALSE;


		DPF(2, "NOTE: ReceiveClientNotification thread starting without shared memory set up.  Setting up now.");
		
		// HACK!!!! -- SetLobbyMessageReceiveEvent may get called from
		// the game without having been lobbied yet.  If that is the case,
		// we need to create the shared memory buffer.  If we don't do
		// that, we may miss messages.
		
		if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
		{
			// Fake the setup routine by setting the lobby client flag
			lpgn->dwFlags |= GN_LOBBY_CLIENT;

			// Set our flag
			bGameCreate = TRUE;
		}

		hr = PRV_SetupAllSharedMemory(lpgn);

		// HACK!!!! -- Reset the settings we changed to fake the setup routines
		if(bGameCreate)
		{
			lpgn->dwFlags &= (~GN_LOBBY_CLIENT);
		}

	
		//hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access App Data memory");
			return 0L;
		}
	}
	LEAVE_DPLGAMENODE();

	// Setup the two events -- one receive event, one kill event
	hEvents[0] = ((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
				(lpgn->hGameWriteEvent) : (lpgn->hLobbyWriteEvent));
	hEvents[1] = lpgn->hKillReceiveThreadEvent;

	if(lpgn->hLobbyClientProcess){
		nWait=3;
		hEvents[2] = lpgn->hLobbyClientProcess;
	} else {
		hEvents[2] = INVALID_HANDLE_VALUE;
		if(!(lpgn->dwFlags & GN_LOBBY_CLIENT)){
			dwWait = 5000;
		}
	}
	// This extra handle is here because of a Windows 95 bug.  Windows
	// will occasionally miss when it walks the handle table, causing
	// my thread to wait on the wrong handles.  By putting a guaranteed
	// invalid handle at the end of our array, the kernel will do a
	// forced re-walk of the handle table and find the correct handles.
	hEvents[3] = INVALID_HANDLE_VALUE;

	// Make sure we have a valid event
	if(!hEvents[0] || !hEvents[1])
	{
		DPF(2, "Either the Write Event or the Kill Event is NULL and it shouldn't be!");
		ExitThread(0L);
		return 0;
	}

	// If we are the game, we should check the buffer to see if any messages
	// already exist in the shared buffer.
	if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
	{
		lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
		// If there are any messages, kick our event so that our receive
		// loop will immediately put the messages in the queue
		if(lpControl->dwMessages)
			SetEvent(hEvents[0]);
	}

	// Wait for the event notification
	while(1)
	{
		// Sleep until something shows up
		dwReturn = WaitForMultipleObjects(nWait, (HANDLE *)hEvents,
											FALSE, dwWait);

		if(dwReturn == WAIT_TIMEOUT){
			ASSERT(!(lpgn->dwFlags & GN_LOBBY_CLIENT));
			if(lpgn->hLobbyClientProcess){
				DPF(9,"Got the lobby client process handle, adding to wait list\n");
				hEvents[2] = lpgn->hLobbyClientProcess;
				nWait = 3;
				dwWait=INFINITE;
			} 
			continue;
		}

		if(nWait==3 && dwReturn == WAIT_OBJECT_0 + 2){
			// send the dead lobby client message
			DPLMSG_SYSTEMMESSAGE msg;

			if(lpgn->dwLobbyClientProcessID){
				memset(&msg, 0, sizeof(DPLMSG_SYSTEMMESSAGE));
				msg.dwType = DPLSYS_LOBBYCLIENTRELEASE;
				msg.guidInstance = lpgn->guidInstance;
				lpgn->dwLobbyClientProcessID = 0;
				hr = PRV_InjectMessageInQueue(lpgn, DPLMSG_SYSTEM | DPLMSG_STANDARD, &msg,
										sizeof(DPLMSG_SYSTEMMESSAGE), FALSE);

			}	
			nWait=2;
			hEvents[2]=INVALID_HANDLE_VALUE;
			continue;
		}

		// If the return value was anything bug the receive event,
		// kill the thread
		if(dwReturn != WAIT_OBJECT_0)
		{
			if(dwReturn == WAIT_FAILED)
			{
				// This is a Windows 95 bug -- We may have gotten
				// kicked for no reason.  If that was the case, we
				// still have valid handles (we think), the OS
				// just goofed up.  So, validate the handle and if
				// they are valid, just return to waiting.  See
				// bug #3340 for a better explanation.
				if(ERROR_INVALID_HANDLE == GetLastError())
				{
					if(!OS_IsValidHandle(hEvents[0]))
						break;
					if(!OS_IsValidHandle(hEvents[1]))
						break;
					continue;
				}
				break;
			}
			else
			{
				// It is either our kill event, or something we don't
				// understand or expect.  In this case, let's exit.
				break;
			}
		}

		while(1)
		{
			// First, call PRV_ReadClientData to get the size of the data
			hr = PRV_ReadClientData(lpgn, NULL, NULL, &dwSize);
			
			// If there are no messages, end the while loop
			if(hr == DPERR_NOMESSAGES)
				break;

			// Otherwise, we should get the BUFFERTOOSMALL case
			if(hr != DPERR_BUFFERTOOSMALL)
			{
				// We should never have a problem here
				DPF_ERRVAL("Recieved an unexpected error reading from shared buffer, hr = 0x%08x", hr);
				ASSERT(FALSE);
				// Might as well keep trying
				break;
			}
			
			// Allocate memory for the node and the data buffer
			lpm = DPMEM_ALLOC(sizeof(DPLOBBYI_MESSAGE));
			lpBuffer = DPMEM_ALLOC(dwSize);
			if((!lpm) || (!lpBuffer))
			{
				DPF_ERR("Unable to allocate memory for message");
				ASSERT(FALSE);
				// Might as well keep trying
				break;
			}

			// Copy the data into our buffer
			hr = PRV_ReadClientData(lpgn, &dwFlags, lpBuffer, &dwSize);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Error reading shared buffer, message not read, hr = 0x%08x", hr);
				ASSERT(FALSE);
				DPMEM_FREE(lpm);
				DPMEM_FREE(lpBuffer);
				// Might as well keep trying
				break;
			}

			// Clear our foward flag
			bForward = FALSE;
			
			// If we are a dplay lobby client, we need to forward the message
			// onto the lobby server using the IDP3 interface.  If we're not,
			// then just put the message in the receive queue.
			if(lpgn->dwFlags & GN_CLIENT_LAUNCHED)
			{
				// Foward the message
				hr = PRV_ForwardMessageToLobbyServer(lpgn, lpBuffer, dwSize,
					((dwFlags & DPLMSG_STANDARD) ? TRUE : FALSE));
				if(FAILED(hr))
				{
					DPF_ERRVAL("Unable to send lobby system message, hr = 0x%08x", hr);
				}

				// Set the forwarded flag
				bForward = TRUE;
			}

			// Check for an App Terminated message.  If we get one off the wire,
			// we need to shut down our ClientTerminateMonitor thread, signal
			// this thread (the receive thread to shut down, and mark the game
			// node as dead.  This will keep us from sending or receiving any
			// more messages from the now dead game.  (This message will only
			// ever be received by a lobby client).
			lpmsg = (LPDPLMSG_GENERIC)lpBuffer;
			if(lpmsg->dwType == DPLSYS_APPTERMINATED)
			{
				// Kick the TerminateMonitor thread with it's kill event
				SetEvent(lpgn->hKillTermThreadEvent);

				// Set this thread's kill event (so that when we get done
				// reading messages out of the shared buffer, we go away)
				SetEvent(lpgn->hKillReceiveThreadEvent);

				// Mark the GAMENODE as dead, but don't remove it since we know
				// there will still messages in the queue.
				lpgn->dwFlags |= GN_DEAD_GAME_NODE;
			}

			// If it's one of our DX3 messages, we need to put it in the queue
			// otherwise if we already forwarded it, we can free it. NOTE: All
			// DX3 lobby system messages had a value between 0 and
			// DPLSYS_APPTERMINATED (0x04).
			if( (!bForward) || (lpmsg->dwType <= DPLSYS_APPTERMINATED))
			{

				if (lpmsg->dwType == DPLSYS_LOBBYCLIENTRELEASE) {
					if(lpgn->dwLobbyClientProcessID){
						lpgn->dwLobbyClientProcessID = 0;
					} else {
						goto no_queue;
					}
				} 

				
				// Save the data pointer & the external flags
				lpm->dwFlags = dwFlags & (~DPLOBBYPR_INTERNALMESSAGEFLAGS);
				lpm->dwSize = dwSize;
				lpm->lpData = lpBuffer;

				// Add the message to the end of the queue & increment the count
				ENTER_DPLQUEUE();
				lpm->lpPrev = lpgn->MessageHead.lpPrev;
				lpgn->MessageHead.lpPrev->lpNext = lpm;
				lpgn->MessageHead.lpPrev = lpm;
				lpm->lpNext = &lpgn->MessageHead;

				lpgn->dwMessageCount++;
				LEAVE_DPLQUEUE();

				// NOTE: There is a potential thread problem here, but we are going
				// to ignore it for now.  It is possible for another thread to be
				// going through the SetAppData code which changes this event handle.
				// The problem is if they change it after this IF statement, but
				// before we call SetEvent.  However, the SetEvent call will either
				// succeed on the new handle, or return an error if the handle is
				// changed to NULL.  In either case, no harm, no foul -- we don't care.
				if(!lpgn->hDupReceiveEvent)
				{
					DPF(8, "The Receive Event handle is NULL!");
					continue;
				}

				SetEvent(lpgn->hDupReceiveEvent);
			}
			else
			{
			no_queue:
				// Free the buffers
				DPMEM_FREE(lpm);
				DPMEM_FREE(lpBuffer);
			}
		}
	}

	DPF(8, "Lobby Receive Thread is going away!!!!!");
	ExitThread(0L);

	return 0L; // avoid warning.
} // PRV_ReceiveClientNotification



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveNodeFromQueue"
void PRV_RemoveNodeFromQueue(LPDPLOBBYI_GAMENODE lpgn, LPDPLOBBYI_MESSAGE lpm)
{
	DPF(7, "Entering PRV_RemoveNodeFromQueue");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpgn, lpm);

	ASSERT(lpgn);
	ASSERT(lpm);

	// Delete the message from the queue & decrement the count
	lpm->lpPrev->lpNext = lpm->lpNext;
	lpm->lpNext->lpPrev = lpm->lpPrev;

	lpgn->dwMessageCount--;

	// Free the memory for the message node
	DPMEM_FREE(lpm->lpData);
	DPMEM_FREE(lpm);

} // PRV_RemoveNodeFromQueue



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CleanUpQueue"
void PRV_CleanUpQueue(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_MESSAGE	lpm, lpmNext;


	DPF(7, "Entering PRV_CleanUpQueue");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	lpm = lpgn->MessageHead.lpNext;
	while(lpm != &lpgn->MessageHead)
	{
		// Save the next pointer
		lpmNext = lpm->lpNext;

		// Remove the node
		PRV_RemoveNodeFromQueue(lpgn, lpm);

		// Move to the next node
		lpm = lpmNext;
	}


} // PRV_CleanUpQueue



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_KillThread"
void PRV_KillThread(HANDLE hThread, HANDLE hEvent)
{

	DPF(7, "Entering PRV_KillThread");
	DPF(9, "Parameters: 0x%08x, 0x%08x", hThread, hEvent);
	
	ASSERT(hThread);
	ASSERT(hEvent);
	
	// Signal the thread to die.
	SetEvent(hEvent);

	// Wait until the thread terminates, if it doesn't something is
	// wrong, so we better fix it.
	DPF(8, "Starting to wait for a thread to exit -- hThread = 0x%08x, hEvent = 0x%08x", hThread, hEvent);
	WaitForSingleObject(hThread, INFINITE);

	// Now close both handles
	CloseHandle(hThread);
	CloseHandle(hEvent);

} // PRV_KillThread



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeGameNode"
HRESULT PRV_FreeGameNode(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;


	DPF(7, "Entering PRV_FreeGameNode");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// FIRST: Take care of the connection settings data buffer
	// Unmap & release the shared memory
	if(lpgn->lpConnectDataBuffer)
		UnmapViewOfFile(lpgn->lpConnectDataBuffer);

	if(lpgn->hConnectDataFile)
		CloseHandle(lpgn->hConnectDataFile);

	if(lpgn->hConnectDataMutex)
		CloseHandle(lpgn->hConnectDataMutex);

	// NEXT: Take care of the App Data Events & Buffers
	// Kill the Receive Thread
	if(lpgn->hReceiveThread)
	{
		PRV_KillThread(lpgn->hReceiveThread, lpgn->hKillReceiveThreadEvent);
		CloseHandle(lpgn->hDupReceiveEvent);
	}

	// Close the event handles
	if(lpgn->hLobbyWriteEvent)
		CloseHandle(lpgn->hLobbyWriteEvent);

	if(lpgn->hGameWriteEvent)
		CloseHandle(lpgn->hGameWriteEvent);

	// Kill the Terminate Monitor Thread
	if(lpgn->hTerminateThread)
	{
		PRV_KillThread(lpgn->hTerminateThread, lpgn->hKillTermThreadEvent);
	}

	// Clear the flags since we are no longer going to be active
	if(lpgn->lpGameWriteBuffer)
	{
		lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpGameWriteBuffer;
		lpControl->dwFlags &= ~((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
					BC_LOBBY_ACTIVE : BC_GAME_ACTIVE);
	}

	if(lpgn->lpLobbyWriteBuffer)
	{
		lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
		lpControl->dwFlags &= ~((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
					BC_LOBBY_ACTIVE : BC_GAME_ACTIVE);
	}

	// Unmap & release the Game Write memory
	if(lpgn->lpGameWriteBuffer)
		UnmapViewOfFile(lpgn->lpGameWriteBuffer);

	if(lpgn->hGameWriteFile)
		CloseHandle(lpgn->hGameWriteFile);

	if(lpgn->hGameWriteMutex)
		CloseHandle(lpgn->hGameWriteMutex);

	// Unmap & release the Lobby Write memory
	if(lpgn->lpLobbyWriteBuffer)
		UnmapViewOfFile(lpgn->lpLobbyWriteBuffer);

	if(lpgn->hLobbyWriteFile)
		CloseHandle(lpgn->hLobbyWriteFile);

	if(lpgn->hLobbyWriteMutex)
		CloseHandle(lpgn->hLobbyWriteMutex);

	// Clean up the message queue
	PRV_CleanUpQueue(lpgn);

	// Close the process handle we have for the game
	if(lpgn->hGameProcess)
		CloseHandle(lpgn->hGameProcess);

	if(lpgn->hLobbyClientProcess)
		CloseHandle(lpgn->hLobbyClientProcess);
	
	// Free the game node structure
	DPMEM_FREE(lpgn);

	return DP_OK;

} // PRV_FreeGameNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DuplicateHandle"
HANDLE PRV_DuplicateHandle(HANDLE hSource)
{
	HANDLE					hProcess = NULL;
	HANDLE					hTarget = NULL;
	DWORD					dwProcessID;
	DWORD					dwError;


	DPF(7, "Entering PRV_DuplicateHandle");
	DPF(9, "Parameters: 0x%08x", hSource);

	dwProcessID = GetCurrentProcessId();
	hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessID);
	if(!DuplicateHandle(hProcess, hSource, hProcess, &hTarget,
					0L, FALSE, DUPLICATE_SAME_ACCESS))
	{
		dwError = GetLastError();
		CloseHandle(hProcess);
		return NULL;
	}

	CloseHandle(hProcess);
	return hTarget;

} // PRV_DuplicateHandle



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetLobbyMessageEvent"
HRESULT DPLAPI DPL_SetLobbyMessageEvent(LPDIRECTPLAYLOBBY lpDPL,
									DWORD dwFlags, DWORD dwGameID,
									HANDLE hReceiveEvent)
{
    LPDPLOBBYI_DPLOBJECT		this;
	LPDPLOBBYI_GAMENODE			lpgn = NULL;
	LPVOID						lpBuffer = NULL;
	HANDLE						hReceiveThread = NULL;
	HANDLE						hDupReceiveEvent = NULL;
	HRESULT						hr;
	BOOL						bCreated = FALSE;
	BOOL						bLobbyClient = TRUE;
	BOOL						bNewEvent = FALSE;


	DPF(7, "Entering DPL_SetLobbyMessageEvent");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, hReceiveEvent);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		// Validate the handle
		if(hReceiveEvent)
		{
			if(!OS_IsValidHandle(hReceiveEvent))
			{
				LEAVE_DPLOBBY();
				DPF_ERR("Invalid hReceiveEvent handle");
				return DPERR_INVALIDPARAMS;
			}
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// If the dwGameID is zero, we assume we are a game.  In that case,
	// the GameNode we are looking for should have our own ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	ENTER_DPLGAMENODE();
	
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);


	// If the event handle is null, kill our duplicate handle
	if(!hReceiveEvent)
	{
		if(!lpgn)
		{
			DPF(5, "Unable to find GameNode -- Invalid dwGameID!");
			LEAVE_DPLGAMENODE();
			LEAVE_DPLOBBY();
			return DPERR_GENERIC;
		}

		CloseHandle(lpgn->hDupReceiveEvent);
		lpgn->hDupReceiveEvent = NULL;
		LEAVE_DPLGAMENODE();
		LEAVE_DPLOBBY();
		return DP_OK;
	}

	// If a GameNode structure exists for this process, we must be trying
	// to replace the event handle, so kill the old event handle, OTHERWISE
	// we need to allocate a new GameNode for this process
	if(lpgn)
	{
		if(lpgn->hDupReceiveEvent)
		{
			CloseHandle(lpgn->hDupReceiveEvent);
			lpgn->hDupReceiveEvent = NULL;
		}
	}
	else
	{
		// If we are a game, go ahead and create the node
		if(!bLobbyClient)
		{
			hr = PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, bLobbyClient,NULL);
			if(FAILED(hr))
			{
				LEAVE_DPLGAMENODE();
				LEAVE_DPLOBBY();
				return hr;
			}
		}
		else
		{
			LEAVE_DPLGAMENODE();
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}

	}

	// Duplicate the caller's handle in case they free it without calling
	// us first to remove the Receive thread.
	hDupReceiveEvent = PRV_DuplicateHandle(hReceiveEvent);
	if(!hDupReceiveEvent)
	{
		DPF(2, "Unable to duplicate ReceiveEvent handle");
		LEAVE_DPLGAMENODE();
		LEAVE_DPLOBBY();
		return DPERR_OUTOFMEMORY;
	}

	if(!lpgn->hDupReceiveEvent)
		bNewEvent = TRUE;
	lpgn->hDupReceiveEvent = hDupReceiveEvent;

	// Check to see if the Receive thread already exists. If it
	// doesn't, create it.  Otherwise, leave it alone.
	if(!(lpgn->hReceiveThread))
	{
		hr = PRV_StartReceiveThread(lpgn);
		if(FAILED(hr))
		{
			if(lpgn->hDupReceiveEvent)
			{
				CloseHandle(lpgn->hDupReceiveEvent);
				lpgn->hDupReceiveEvent = NULL;
			}

			LEAVE_DPLGAMENODE();
			LEAVE_DPLOBBY();
			return hr;
		}
	}

	// If this is a new event, check to see if there are any messages in the
	// queue.  If there are, kick the event so the user knows they are there.
	if(bNewEvent && lpgn->dwMessageCount)
		SetEvent(hDupReceiveEvent);

	LEAVE_DPLGAMENODE();
	LEAVE_DPLOBBY();
	return DP_OK;

} // DPL_SetLobbyMessageEvent


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SendLobbyMessage"
HRESULT DPLAPI DPL_SendLobbyMessage(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					DWORD dwGameID, LPVOID lpData, DWORD dwSize)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
	LPDPLMSG_GENERIC		lpmsg = NULL;
    HRESULT					hr = DP_OK;
	BOOL					bLobbyClient = TRUE;
	BOOL					bStandard = FALSE;


	DPF(7, "Entering DPL_SendLobbyMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDPL, dwFlags, dwGameID, lpData, dwSize);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

        if( !VALID_READ_PTR( lpData, dwSize ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
        }

		// Check for valid flags
		if( !VALID_SENDLOBBYMESSAGE_FLAGS(dwFlags))
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDFLAGS;
		}

		// If it's of the system message format, validate the dwType
		if( dwFlags & DPLMSG_STANDARD )
		{
			// Mark this as a standard message
			bStandard = TRUE;
			
			// Make sure the message is big enough to read
			if(! VALID_READ_PTR( lpData, sizeof(DPLMSG_GENERIC)) )
			{
				LEAVE_DPLOBBY();
				DPF_ERR("Invalid message buffer");
				return DPERR_INVALIDPARAMS;
			}
			
			// Make sure it's one we support
			lpmsg = (LPDPLMSG_GENERIC)lpData;			
			switch(lpmsg->dwType)
			{
				case DPLSYS_GETPROPERTY:
				case DPLSYS_SETPROPERTY:
					break;
				default:
					DPF_ERR("The dwType of the message is invalid for a legal standard lobby message");
					LEAVE_DPLOBBY();
					return DPERR_INVALIDPARAMS;
			}
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If a GameID was passed in, use it to find the correct GameNode.  If
	// one wasn't passed in, assume we are the game and use our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	// Now find the correct game node.  If we don't find it, assume we
	// have an invalid ID and error out.
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		LEAVE_DPLOBBY();
		DPF_ERR("Invalid dwGameID");
		return DPERR_INVALIDPARAMS;
	}

	// If we are self-lobbied, we need to send the message onto the lobby
	// using the IDP3 interface that we are communicating with the lobby on
	// If not, we need to put it in the shared buffer and let the lobby
	// client deal with it.
	if(lpgn->dwFlags & GN_SELF_LOBBIED)
	{
		// Drop the lobby lock so we can call PRV_Send
		LEAVE_DPLOBBY();
		
		// Foward the message
		hr = PRV_ForwardMessageToLobbyServer(lpgn, lpData, dwSize, bStandard);
		
		// Take the lock back
		ENTER_DPLOBBY();
		
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to send lobby system message, hr = 0x%08x", hr);
		}
	}
	else
	{
		// Write the data to our shared memory
		hr = PRV_WriteClientData(lpgn, dwFlags, lpData, dwSize);
	}

	LEAVE_DPLOBBY();
	return hr;

} // DPL_SendLobbyMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetMessageFromQueue"
HRESULT PRV_GetMessageFromQueue(LPDPLOBBYI_GAMENODE lpgn, LPDWORD lpdwFlags,
								LPVOID lpData, LPDWORD lpdwSize)
{
	LPDPLOBBYI_MESSAGE	lpm;


	DPF(7, "Entering PRV_GetMessageFromQueue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpgn, lpdwFlags, lpData, lpdwSize);

	ENTER_DPLQUEUE();

	// Get the top message in the queue
	lpm = lpgn->MessageHead.lpNext;

	// Make sure we have a message
	if((!lpgn->dwMessageCount) || (lpm == &lpgn->MessageHead))
	{
		LEAVE_DPLQUEUE();
		return DPERR_NOMESSAGES;
	}

	// If the lpData pointer is NULL, just return the size
	if(!lpData)
	{
		*lpdwSize = lpm->dwSize;
		LEAVE_DPLQUEUE();
		return DPERR_BUFFERTOOSMALL;
	}

	// Otherwise, check the remaining output parameters
	if( !VALIDEX_CODE_PTR( lpData ) )
	{
		LEAVE_DPLQUEUE();
		return DPERR_INVALIDPARAMS;
	}

	if( !VALID_DWORD_PTR( lpdwFlags ) )
	{
		LEAVE_DPLQUEUE();
		return DPERR_INVALIDPARAMS;
	}

	// Copy the message
	if(*lpdwSize < lpm->dwSize)
	{
		*lpdwSize = lpm->dwSize;
		LEAVE_DPLQUEUE();
		return DPERR_BUFFERTOOSMALL;
	}
	else
		memcpy(lpData, lpm->lpData, lpm->dwSize);

	// Set the other output parameters
	*lpdwSize = lpm->dwSize;
	*lpdwFlags = lpm->dwFlags;


	// Delete the message from the queue & decrement the count
	PRV_RemoveNodeFromQueue(lpgn, lpm);

	// Check and see if our GAMENODE is dead.  If it is, and if the message
	// count has gone to zero, then free the GAMENODE structure.
	if((!lpgn->dwMessageCount) && IS_GAME_DEAD(lpgn))
		PRV_RemoveGameNodeFromList(lpgn);

	LEAVE_DPLQUEUE();
	return DP_OK;

} // PRV_GetMessageFromQueue


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ReceiveLobbyMessage"
HRESULT DPLAPI DPL_ReceiveLobbyMessage(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					DWORD dwGameID, LPDWORD lpdwMessageFlags, LPVOID lpData,
					LPDWORD lpdwDataLength)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
    HRESULT					hr = DP_OK;
	BOOL					bLobbyClient = TRUE;


	DPF(7, "Entering DPL_ReceiveLobbyMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
		lpDPL, dwFlags, dwGameID, lpdwMessageFlags, lpData, lpdwDataLength);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		if( !VALID_DWORD_PTR( lpdwDataLength ) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If a GameID was passed in, use it to find the correct GameNode.  If
	// one wasn't passed in, assume we are the game and use our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	// Now find the correct game node.  If we don't find it, assume we
	// have an invalid ID and error out.
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		DPF_ERR("Invalid dwGameID");
		hr = DPERR_INVALIDPARAMS;
		goto EXIT_RECEIVE_LOBBY_MESSAGE;
	}

	// Read the data from shared memory
	hr = PRV_GetMessageFromQueue(lpgn, lpdwMessageFlags, lpData, lpdwDataLength);

	// REVIEW!!!! -- Do we need to send this to the lobby server as part of this API????

EXIT_RECEIVE_LOBBY_MESSAGE:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_ReceiveLobbyMessage


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteConnectionSettings"
HRESULT PRV_WriteConnectionSettings(LPDPLOBBYI_GAMENODE lpgn,
			LPDPLCONNECTION lpConn, BOOL bOverrideWaitMode)
{
    HRESULT					hr;
	DWORD					dwSize;
	BOOL					bGameCreate = FALSE;
	LPBYTE					lpConnBuffer = NULL;
	LPDPLOBBYI_CONNCONTROL	lpConnControl = NULL;


	DPF(7, "Entering PRV_WriteConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu",
			lpgn, lpConn, bOverrideWaitMode);

	ENTER_DPLGAMENODE();

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		// HACK!!!! -- SetConnectionSettings may get called from the game
		// without having been lobbied.  If that is the case, we need to
		// create the shared memory with the game's process ID (this process)
		if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
		{
			// Fake the setup routine by setting the lobby client flag
			lpgn->dwFlags |= GN_LOBBY_CLIENT;

			// Set our flag
			bGameCreate = TRUE;
		}

		hr = PRV_SetupAllSharedMemory(lpgn);

		// HACK!!!! -- Reset the settings we changed to fake the setup routines
		if(bGameCreate)
		{
			lpgn->dwFlags &= (~GN_LOBBY_CLIENT);
		}

		// Now handle the failure
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access Connection Settings memory");
			return hr;
		}
	}

	// If the ConnectionSettings come from a StartSession message, we need to
	// pick the dplay object pointer out of the DPLCONNECTION structure's
	// reserved field.  This pointer to a dplay object represents the object
	// that has a connection to the lobby server.
	if(lpConn->lpSessionDesc->dwReserved1)
	{
		// Save the pointer and player ID in our gamenode structure
		lpgn->lpDPlayObject = (LPDPLAYI_DPLAY)lpConn->lpSessionDesc->dwReserved1;
		lpgn->dpidPlayer = (DWORD)lpConn->lpSessionDesc->dwReserved2;

		// Clear the field
		lpConn->lpSessionDesc->dwReserved1 = 0L;
		lpConn->lpSessionDesc->dwReserved2 = 0L;
	}

	// Save the instance pointer for the system messages
	lpgn->guidInstance = lpConn->lpSessionDesc->guidInstance;

	// Get the packaged size of the DPLCONNECTION structure
	PRV_GetDPLCONNECTIONPackageSize(lpConn, &dwSize, NULL);

	// Check data sizes
	if(dwSize > (MAX_APPDATABUFFERSIZE - APPDATA_RESERVEDSIZE))
	{
		DPF(2, "Packaged Connection Settings exceeded max buffer size of %d",
				(MAX_APPDATABUFFERSIZE - APPDATA_RESERVEDSIZE));
		LEAVE_DPLGAMENODE();
		return DPERR_BUFFERTOOLARGE;
	}

	// Make sure we have the mutex for the shared conn settings buffer
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);

	// Look at the control block to see if we are in wait mode
	// If we are, and this is not a call from RunApplication, then
	// we don't want to write the connection settings
	hr = DPERR_UNAVAILABLE;		// Default set to error
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	if((!(lpConnControl->dwFlags & BC_WAIT_MODE)) || bOverrideWaitMode)
	{
		// Get a pointer to the actual buffer
		lpConnBuffer = (LPBYTE)lpConnControl + sizeof(DPLOBBYI_CONNCONTROL);

		// Package the connection settings into the buffer
		hr = PRV_PackageDPLCONNECTION(lpConn, lpConnBuffer, TRUE);
		
		// If it succeeded, and we were overriding wait mode, we need
		// to take the buffers out of wait mode and send the new connection
		// settings available message
		if(SUCCEEDED(hr) && bOverrideWaitMode)
		{
			// Take the buffers out of wait mode
			PRV_LeaveConnSettingsWaitMode(lpgn);
		}
	}

	ReleaseMutex(lpgn->hConnectDataMutex);

	LEAVE_DPLGAMENODE();
	return hr;

} // PRV_WriteConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetConnectionSettings"
HRESULT PRV_SetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					DWORD dwGameID,	LPDPLCONNECTION lpConn)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
    HRESULT					hr;
	BOOL					bLobbyClient = TRUE;


	DPF(7, "Entering PRV_SetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, lpConn);

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }

		// Validate the DPLCONNECTION structure
		hr = PRV_ValidateDPLCONNECTION(lpConn, FALSE);
		if(FAILED(hr))
		{
			return hr;
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If dwGameID is zero, we assume we are a game.  In that case, the
	// GameNode we are looking for should have our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		// If we are a game, go ahead and create the node
		if(!bLobbyClient)
		{
			hr = PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, bLobbyClient,NULL);
			if(FAILED(hr))
				return hr;
		}
		else
			return DPERR_INVALIDPARAMS;

	}
	
	// If the ConnectionSettings are from a StartSession message (lobby launched),
	// we need to set the flag saying we are self-lobbied
	if(lpConn->lpSessionDesc->dwReserved1)
	{
		// Set the flag that says we were lobby client launched
		lpgn->dwFlags |= GN_SELF_LOBBIED;
	}

	// Write the connection settings to our shared buffer
	hr = PRV_WriteConnectionSettings(lpgn, lpConn, FALSE);

	return hr;

} // PRV_SetConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetConnectionSettings"
HRESULT DPLAPI DPL_SetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, DWORD dwGameID, LPDPLCONNECTION lpConn)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_SetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, lpConn);

    ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetConnectionSettings(lpDPL, dwFlags, dwGameID, lpConn);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_SetConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ReadConnectionSettings"
HRESULT PRV_ReadConnectionSettings(LPDPLOBBYI_GAMENODE lpgn, LPVOID lpData,
											LPDWORD lpdwSize, BOOL bAnsi)
{
    HRESULT					hr = DP_OK;
	LPDWORD					lpdwBuffer;
	LPDPLOBBYI_CONNCONTROL	lpConnControl = NULL;
	LPBYTE					lpConnBuffer = NULL;
	DWORD					dwSize = 0,
							dwSizeAnsi,
							dwSizeUnicode;


	DPF(7, "Entering PRV_ReadConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu",
			lpgn, lpData, lpdwSize, bAnsi);

	// Make sure we have a valid memory pointer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(5, "Unable to access Connect Data memory");
			return DPERR_NOTLOBBIED;
		}
	}

	// Grab the shared buffer mutex
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);

	// Make sure we are not in wait mode without being in pending mode
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	if((lpConnControl->dwFlags & BC_WAIT_MODE) &&
		!(lpConnControl->dwFlags & BC_PENDING_CONNECT))
	{
		hr = DPERR_UNAVAILABLE;
		goto EXIT_READ_CONN_SETTINGS;
	}

	if(!(lpgn->dwFlags & GN_LOBBY_CLIENT)){
		lpgn->dwLobbyClientProcessID = lpConnControl->CliProcId;
		lpgn->hLobbyClientProcess = OpenProcess(STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE ,FALSE, lpgn->dwLobbyClientProcessID);

		if(!lpgn->hLobbyClientProcess){
			#ifdef DEBUG
				DWORD err;
				err = GetLastError();
				DPF(0,"Couldn't get lobby client processId %d, extended error %d\n",lpConnControl->CliProcId,err);
			#endif
			// lobby client is already dead, don't allow settings across.
			hr = DPERR_UNAVAILABLE;
			goto EXIT_READ_CONN_SETTINGS;
		}
	}

	// Take us out of wait mode and pending mode
	PRV_LeaveConnSettingsWaitMode(lpgn);

	// Verify that the buffer is big enough.  If it's not, OR if the lpData
	// buffer pointer is NULL, just set the lpdwSize parameter to the
	// correct size and return an error.  Note: In our packed structure, the
	// first DWORD is the size of the packed structure with Unicode strings
	// and the second DWORD is the size of the packed structure with ANSI.
	lpConnBuffer = (LPBYTE)lpConnControl + sizeof(DPLOBBYI_CONNCONTROL);
	lpdwBuffer = (LPDWORD)lpConnBuffer;
	dwSizeUnicode = *lpdwBuffer++;
	dwSizeAnsi = *lpdwBuffer;
	dwSize = (bAnsi) ? dwSizeAnsi : dwSizeUnicode;

	if(((*lpdwSize) < dwSize) || (!lpData))
	{
		if(bAnsi)
			*lpdwSize = dwSizeAnsi;
		else		
			*lpdwSize = dwSizeUnicode;

		hr = DPERR_BUFFERTOOSMALL;
		goto EXIT_READ_CONN_SETTINGS;
	}

	// Copy the DPLCONNECTION structure, taking the ANSI conversion
	// into account if necessary.
	if(bAnsi)
		hr = PRV_UnpackageDPLCONNECTIONAnsi(lpData, lpConnBuffer);
	else
		hr = PRV_UnpackageDPLCONNECTIONUnicode(lpData, lpConnBuffer);

	// If we haven't yet saved off the Instance guid for the game, save
	// it now so that we have it for the system messages
	if(IsEqualGUID(&lpgn->guidInstance, &GUID_NULL))
		lpgn->guidInstance = ((LPDPLCONNECTION)lpData)->lpSessionDesc->guidInstance;

	// Fall through

EXIT_READ_CONN_SETTINGS:

	ReleaseMutex(lpgn->hConnectDataMutex);
	LEAVE_DPLGAMENODE();
	return hr;	

} // PRV_ReadConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetConnectionSettings"
HRESULT PRV_GetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL, DWORD dwGameID,
							LPVOID lpData, LPDWORD lpdwSize, BOOL bAnsi)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
    HRESULT					hr;
	BOOL					bLobbyClient = TRUE;


	DPF(7, "Entering PRV_GetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDPL, dwGameID, lpData, lpdwSize, bAnsi);

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }

		if( !VALID_DWORD_PTR( lpdwSize ) )
		{
			DPF_ERR("lpdwSize was not a valid dword pointer!");
			return DPERR_INVALIDPARAMS;
		}

		if(lpData)
		{
			if( !VALID_WRITE_PTR(lpData, *lpdwSize) )
			{
				DPF_ERR("lpData is not a valid output buffer of the size specified in *lpdwSize");
				return DPERR_INVALIDPARAMS;
			}
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If dwGameID is zero, we assume we are a game.  In that case, the
	// GameNode we are looking for should have our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		// If we are a game, go ahead and create the node
		if(!bLobbyClient)
		{
			hr = PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, bLobbyClient,NULL);
			if(FAILED(hr))
				return hr;
		}
		else
			return DPERR_INVALIDPARAMS;
	}
	
	// Read the data from our shared memory
	hr = PRV_ReadConnectionSettings(lpgn, lpData, lpdwSize, bAnsi);

	return hr;

} // PRV_GetConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetConnectionSettings"
HRESULT DPLAPI DPL_GetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwGameID, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_GetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwGameID, lpData, lpdwSize);

    ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetConnectionSettings(lpDPL, dwGameID, lpData,
									lpdwSize, FALSE);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_GetConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveGameNodeFromList"
void PRV_RemoveGameNodeFromList(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_GAMENODE	lpgnTemp;
	BOOL				bFound = FALSE;


	DPF(7, "Entering PRV_RemoveGameNodeFromList");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// Get the head pointer
	lpgnTemp = lpgn->this->lpgnHead;

	// Make sure it's not the first node.  If it is, move the head pointer
	if(lpgnTemp == lpgn)
	{
		lpgn->this->lpgnHead = lpgn->lpgnNext;
		PRV_FreeGameNode(lpgn);
		return;
	}

	// Walk the list looking for the previous node
	while(lpgnTemp)
	{
		if(lpgnTemp->lpgnNext == lpgn)
		{
			bFound = TRUE;
			break;
		}

		lpgnTemp = lpgnTemp->lpgnNext;
	}

	if(!bFound)
	{
		DPF_ERR("Unable to remove GameNode from list!");
		return;
	}

	// We've now got it's previous one, so remove it from the linked list
	// and delete it.
	lpgnTemp->lpgnNext = lpgn->lpgnNext;
	PRV_FreeGameNode(lpgn);

	return;

}  // PRV_RemoveGameNodeFromList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ClientTerminateNotification"
DWORD WINAPI PRV_ClientTerminateNotification(LPVOID lpParam)
{
    LPDPLOBBYI_GAMENODE		lpgn = (LPDPLOBBYI_GAMENODE)lpParam;
	DPLMSG_SYSTEMMESSAGE	msg;
	HANDLE					hObjects[3];
	HRESULT					hr;
	DWORD					dwResult;
	DWORD					dwError;


	DPF(7, "Entering PRV_ClientTerminateNotification");
	DPF(9, "Parameters: 0x%08x", lpParam);

	// Setup the objects to wait on -- one process handle, one kill event
	hObjects[0] = lpgn->hGameProcess;
	hObjects[1] = lpgn->hKillTermThreadEvent;
	// This extra handle is here because of a Windows 95 bug.  Windows
	// will occasionally miss when it walks the handle table, causing
	// my thread to wait on the wrong handles.  By putting a guaranteed
	// invalid handle at the end of our array, the kernel will do a
	// forced re-walk of the handle table and find the correct handles.
	hObjects[2] = INVALID_HANDLE_VALUE;

	// Wait for the event notification
	while(1)
	{
		// Wait for the process to go away
		dwResult = WaitForMultipleObjects(2, (HANDLE *)hObjects,
											FALSE, INFINITE);

		// If we are signalled by anything but the process going away,
		// just kill the thread.
		if(dwResult != WAIT_OBJECT_0)
		{
			if(dwResult == WAIT_FAILED)
			{
				// This is a Windows 95 bug -- We may have gotten
				// kicked for no reason.  If that was the case, we
				// still have valid handles (we think), the OS
				// just goofed up.  So, validate the handle and if
				// they are valid, just return to waiting.  See
				// bug #3340 for a better explanation.
				dwError = GetLastError();
				if(ERROR_INVALID_HANDLE == dwError)
				{
					if(!OS_IsValidHandle(hObjects[0]))
						break;
					if(!OS_IsValidHandle(hObjects[1]))
						break;
					continue;
				}
				break;
			}
			else
			{
				// This is something we don't understand, so just go away.
				ExitThread(0L);
				return 0L;
			}
		}
		else
		{
			// This is our process handle going away, so bail out of
			// the wait loop and send the system message.
			break;
		}
	}

	// Send the system message which says the app terminated
	memset(&msg, 0, sizeof(DPLMSG_SYSTEMMESSAGE));
	msg.dwType = DPLSYS_APPTERMINATED;
	msg.guidInstance = lpgn->guidInstance;
	hr = PRV_InjectMessageInQueue(lpgn, DPLAD_SYSTEM, &msg,
							sizeof(DPLMSG_SYSTEMMESSAGE), TRUE);
	if(FAILED(hr))
	{
		DPF(0, "Failed to send App Termination message, hr = 0x%08x", hr);
	}

	// Mark the GAMENODE as dead, but don't remove it since we know
	// there are still messages in the queue.
	lpgn->dwFlags |= GN_DEAD_GAME_NODE;

	ExitThread(0L);

	return 0L; // avoid warning.
} // PRV_ClientTerminateNotification



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_WaitForConnectionSettings"
HRESULT DPLAPI DPL_WaitForConnectionSettings(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags)
{
    LPDPLOBBYI_DPLOBJECT		this;
	LPDPLOBBYI_GAMENODE			lpgn = NULL;
	LPDPLOBBYI_CONNCONTROL		lpConnControl = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpBuffControl = NULL;
	HRESULT						hr = DP_OK;
	BOOL						bCreated = FALSE;
	DWORD						dwProcessID;
	BOOL						bGameCreate = FALSE;
	BOOL						bMessages = TRUE;


	DPF(7, "Entering DPL_WaitForConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDPL, dwFlags);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
        }

		if(!VALID_WAIT_FLAGS(dwFlags))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Get the game node
	dwProcessID = GetCurrentProcessId();
	lpgn = PRV_GetGameNode(this->lpgnHead, dwProcessID);
	if(!lpgn)
	{
		// Create the game node
		hr = PRV_AddNewGameNode(this, &lpgn, dwProcessID, NULL, FALSE, NULL);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed creating game node, hr = 0x%08x", hr);
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}

		// Set our flag saying we just created the game node
		bCreated = TRUE;
	}

	// when doing a wait for connection settings, we do NOT use the
	// IPC_GUID, this is because the lobby launching us may not have
	// provided the GUID.
	lpgn->dwFlags &= ~(GN_IPCGUID_SET);

	// Make sure we have a valid memory pointer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		// First we need to try to setup access to the buffers assuming
		// they already exist (we were lobby launched).  If this doesn't
		// work, then we need to create them.
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			// We don't have any memory, so set it up
			// HACK!!!! -- WaitForConnectionSettings may get called from the game
			// without having been lobbied.  If that is the case, we need to
			// create the shared memory with the game's process ID (this process)
			// so we'll set the lobby client flag to fake out the creation
			if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
			{
				// Fake the setup routine by setting the lobby client flag
				lpgn->dwFlags |= GN_LOBBY_CLIENT;

				// Set our flag
				bGameCreate = TRUE;
			}

			// Setup the shared buffers
			hr = PRV_SetupAllSharedMemory(lpgn);

			// HACK!!!! -- Reset the settings we changed to fake the setup routines
			if(bGameCreate)
			{
				lpgn->dwFlags &= (~GN_LOBBY_CLIENT);
			}
		}

		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF_ERRVAL("Unable to access Connect Data memory, hr = 0x%08x", hr);
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
	}

	// Drop the lock
	LEAVE_DPLGAMENODE();

	// If we are in wait mode, and the caller wants to end it, do so,
	// otherwise, just return success
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	if(lpConnControl->dwFlags & BC_WAIT_MODE)
	{
		if(dwFlags & DPLWAIT_CANCEL)
		{
			// Release Mutex
			ReleaseMutex(lpgn->hConnectDataMutex);

			// Take us out of wait mode
			PRV_LeaveConnSettingsWaitMode(lpgn);
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
		else
		{
			// Release Mutex
			ReleaseMutex(lpgn->hConnectDataMutex);

			// Might as well just return OK since we're already doing it
			DPF_ERR("We're already in wait mode");
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
	}
	else
	{
		// We're not it wait mode, and the caller asked us to turn it off
		if(dwFlags & DPLWAIT_CANCEL)
		{
			// Release Mutex
			ReleaseMutex(lpgn->hConnectDataMutex);

			DPF_ERR("Cannot turn off wait mode - we're not in wait mode");
			hr = DPERR_UNAVAILABLE;
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
	}

	// Release Mutex
	ReleaseMutex(lpgn->hConnectDataMutex);

	// See if a lobby client exists on the other side, if it does, we
	// need to tell him we are going into wait mode by sending him an
	// AppTerminated message.
	PRV_SendStandardSystemMessage(lpDPL, DPLSYS_APPTERMINATED, 0);

	// Go into wait mode
	PRV_EnterConnSettingsWaitMode(lpgn);

	// Kick the receive thread to empty the buffer (just in case there
	// are any messages in it)
	SetEvent(lpgn->hLobbyWriteEvent);

	// Spin waiting for the buffer to get emptied
	while(bMessages)
	{
		// Grab the mutex for the lobby write buffer
		WaitForSingleObject(lpgn->hLobbyWriteMutex, INFINITE);
		lpBuffControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;

		if(!lpBuffControl->dwMessages)
			bMessages = FALSE;

		// Drop the mutex
		ReleaseMutex(lpgn->hLobbyWriteMutex);

		if(bMessages)
		{
			// Now sleep to give the receive thread a chance to work
			Sleep(50);
		}
	}

	// Now clean out the message queue
	PRV_CleanUpQueue(lpgn);

	// Fall through

EXIT_WAIT_FOR_CONN_SETTINGS:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_WaitForConnectionSettings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplsp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplsp.c
 *  Content:	DirectPlayLobby Service Provider interface code
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	10/23/96	myronth	Created it
 *	11/20/96	myronth Added DPLAPI to function declarations
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/31/97		myronth	Implemented all IDPLobbySP methods without putting
 *						player management message in the message queue.
 *						Removed dead code
 *	4/4/97		myronth	Changed IDPLobbySP methods' structure names and
 *						implemented system messages for all of them
 *  4/27/97     sohailm Updated calls to HandlePlayerMessage to reflect new params
 *	5/8/97		myronth	All remote subgroup functions for IDPLobbySP
 *						including StartSession, Purged dead code
 *	5/12/97		myronth	Extra semi-colon bug fixes, Fixed group player count
 *						decrement that was in the wrong place
 *	5/14/97		myronth	Allow CreateGroup message to pass even if the
 *						Group ID is in the map table (bug #8354).
 *	5/17/97		myronth	Fixed HandleMessage, Added SendChatMessage
 *	5/17/97		myronth	Filtered some message to certain groups, Fixed calls
 *						to CreateAndMapNewGroup which needed a parent ID
 *	5/20/97		myronth	Changed DPLP_DeleteRemotePlayerFromGroup to use
 *						InternalDeletePlayerFromGroup instead of
 *						RemovedPlayerFromGroup (now includes system player)
 *						(Bug #8586)
 *	5/21/97		myronth	Fixed the player name for players joining a session
 *						(#8798), Changed to new DPMSG_CHAT format (#8642)
 *	5/22/97		myronth	Fixed flag propagation in DPLP_CreateGroup (#8813)
 *	5/23/97		myronth	Send messages locally for CreateGroup and
 *						CreateGroupInGroup (#8870)
 *	6/3/97		myronth	Added support for player flags in AddPlayerToGroup
 *						(#9091) and added PRV_RemoveSubgroupsAndPlayers-
 *						FromGroup function (#9134)
 *	6/5/97		myronth	Fixed AddGroupToGroup & DeleteGroupFromGroup by
 *						adding heirarchy creating & deletion. (#8731)
 *	6/6/97		myronth	Moved code from PRV_DeleteRemoteGroupFromGroup to
 *						PRV_DestroyGroupAndParents in group.c, Changed all
 *						DistributeGroupMessage calls to go to all players
 *	6/16/97		myronth	Fixed call to InternalAddGroupToGroup (#9745) and
 *						fixed Delete messages for shortcuts on DestroyGroup
 *						(#9739)
 *	6/20/97		myronth	Changed AddGroupToGroup to check if a group exists
 *						and not send a duplicate message (#10139)
 *	6/24/97		myronth	Changed AddPlayerToGroup to check if a player exists
 *						and not send a duplicate message (#10287)
 *	7/30/97		myronth	Added support for standard lobby messaging
 *	8/11/97		myronth	Added guidInstance handling in standard lobby requests
 *	8/19/97		myronth	Removed bogus assert
 *	9/29/97		myronth	Ignore SetPlayerName/Data msgs for local players (#12554)
 *	10/3/97		myronth	Fixed player & group data for remote players/groups (#10961)
 *	10/7/97		myronth	Fixed LP version checking for player & group data (regresssion)
 *	10/8/97		myronth	Rolled back fix for #10961 (group & player data)
 *	10/23/97	myronth	Added hidden group support (#12688), fixed crashing
 *						bug on DeletePlayerFromGroup (#12885)
 *	10/29/97	myronth	Added support for group owners, including DPLP_SetGroupOwner
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/6/97		myronth	Made SendChatMessage handle a dwFromID of
 *						DPID_SERVERPLAYER (#12843)
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	 2/13/98	aarono	changed InternalDeletePlayer, added flag.
 *   8/30/00    aarono  B#43812 improper construction of DATA CHANGED.
 *                         in SendDataChangedLocally.
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendBuildParentalHeirarchyMessage"
void PRV_SendBuildParentalHeirarchyMessage(LPDPLOBBYI_DPLOBJECT this,
				DWORD dwGroupID, DWORD dwParentID)
{
	SPDATA_BUILDPARENTALHEIRARCHY	bph;
	HRESULT							hr;


	DPF(7, "Entering PRV_SendBuildParentalHeirarchyMessage");
	DPF(9, "Parameters: 0x%08x, %lu, %lu", this, dwGroupID, dwParentID);

	// Setup the SPDATA structure
	memset(&bph, 0, sizeof(SPDATA_BUILDPARENTALHEIRARCHY));
	bph.dwSize = sizeof(SPDATA_BUILDPARENTALHEIRARCHY);
	bph.lpISP = PRV_GetDPLobbySPInterface(this);
	bph.dwGroupID = dwGroupID;
	bph.dwMessage = DPSYS_ADDGROUPTOGROUP;
	bph.dwParentID = dwParentID;

	// Call the BuildParentalHeirarchy method in the SP
	if(CALLBACK_EXISTS(BuildParentalHeirarchy))
	{
		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, BuildParentalHeirarchy, &bph);
		ENTER_DPLOBBY();
	}
	else 
	{
		// BuildParentalHeirarchy is required
		DPF_ERR("The Lobby Provider callback for BuildParentalHeirarchy doesn't exist -- it's required");
		ASSERT(FALSE);
	}

} // PRV_SendBuildParentalHeirarchyMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_AddGroupToGroup"
HRESULT DPLAPI DPLP_AddGroupToGroup(LPDPLOBBYSP lpILP,
				LPSPDATA_ADDREMOTEGROUPTOGROUP lpd)
{
	SPDATA_CREATEREMOTEGROUPINGROUP		cgig;
	SPDATA_DESTROYREMOTEGROUP			dg;
	SPDATA_CREATEREMOTEGROUP			cg;
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpAnchor = NULL;
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;
	MSG_PLAYERMGMTMESSAGE	msg;
	BOOL					bCreated = FALSE;


	DPF(7, "Entering DPLP_AddGroupToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_ADDREMOTEGROUPTOGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwAnchorID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved AddGroupToGroup message for unknown anchor group, dwGroupID = %lu, discarding message", lpd->dwAnchorID);
		return DPERR_INVALIDGROUP;
	}

	// Now see if the group is in our map table.  If it is, we
	// probably want to update the name.  If it's not, we need to
	// add them to the nametable and the map table
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		// See if the group is a root group (remember hidden groups won't
		// get pushed down to us).  If it is, then just create it.
		if(!(lpd->dwParentID))
		{
			// Setup the SPDATA struct for CreateRemoteGroup
			memset(&cg, 0, sizeof(SPDATA_CREATEREMOTEGROUP));
			cg.dwSize = sizeof(SPDATA_CREATEREMOTEGROUP);
			cg.dwGroupID = lpd->dwGroupID;
			cg.lpName = lpd->lpName;
			cg.dwFlags = lpd->dwGroupFlags;

			if(this->dwLPVersion > DPLSP_DX5VERSION)
				cg.dwGroupOwnerID = lpd->dwGroupOwnerID;
			else
				cg.dwGroupOwnerID = DPID_SERVERPLAYER;

			// Call our internal remote create
			hr = DPLP_CreateGroup((LPDPLOBBYSP)this->lpInterfaces, &cg);
			if(FAILED(hr))
			{
				LEAVE_DPLOBBY();
				DPF_ERRVAL("Failed creating remote parent group, hr = 0x%08x", hr);
				return hr;
			}

			bCreated = TRUE;
		}
		else
		{
			// See if it's parent shows up in the map table, if it doesn't,
			// we need to send a message to the server to tell it to build
			// the entire tree for us
			if(!IsLobbyIDInMapTable(this, lpd->dwParentID))
			{
				DPF(8, "Sending message to server to build parental heirarchy, ignoring AddGroupToGroup message");
				PRV_SendBuildParentalHeirarchyMessage(this, lpd->dwGroupID,
						lpd->dwAnchorID);
				LEAVE_DPLOBBY();
				return DPERR_INVALIDGROUP;
			}

			// Setup the SPDATA struct for CreateRemoteGroupInGroup
			memset(&cgig, 0, sizeof(SPDATA_CREATEREMOTEGROUPINGROUP));
			cgig.dwSize = sizeof(SPDATA_CREATEREMOTEGROUPINGROUP);
			cgig.dwParentID = lpd->dwParentID;
			cgig.dwGroupID = lpd->dwGroupID;
			cgig.lpName = lpd->lpName;
			cgig.dwFlags = lpd->dwGroupFlags;

			if(this->dwLPVersion > DPLSP_DX5VERSION)
				cgig.dwGroupOwnerID = lpd->dwGroupOwnerID;
			else
				cgig.dwGroupOwnerID = DPID_SERVERPLAYER;

			// Call our internal remote create
			hr = DPLP_CreateGroupInGroup((LPDPLOBBYSP)this->lpInterfaces, &cgig);
			if(FAILED(hr))
			{
				LEAVE_DPLOBBY();
				DPF_ERRVAL("Failed creating remote group in group, hr = 0x%08x", hr);
				return hr;
			}

			bCreated = TRUE;
		}
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// Make sure the group isn't already in the parent group.  If it is,
	// we just want to return DP_OK and exit so that we don't send any
	// duplicate messages.
	lpAnchor = GroupFromID(this->lpDPlayObject, lpd->dwAnchorID);
	if(!lpAnchor)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}
	
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}
	
	lpSubgroup = lpAnchor->pSubgroups;
    while(lpSubgroup) 
    {
        if (lpSubgroup->pGroup == lpGroup) 
        {
			DPF(2,"Group already in group!");
			hr = DP_OK;
			goto ERROR_DPLP_ADDGROUPTOGROUP;
        }
		// check next node
        lpSubgroup = lpSubgroup->pNextSubgroup;
    }

	// So now we should have a valid group and valid player in both
	// the map table and the nametable, so call dplay's AGtoG function
	hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
				lpd->dwAnchorID, lpd->dwGroupID, DPGROUP_SHORTCUT, FALSE);
	if(FAILED(hr))
	{
		// If we created the player and mapped it, then destroy the
		// player and unmap it.
		if(bCreated)
		{
			// Setup the SPDATA struct for DestroyRemoteGroup
			memset(&dg, 0, sizeof(SPDATA_DESTROYREMOTEGROUP));
			dg.dwSize = sizeof(SPDATA_DESTROYREMOTEGROUP);
			dg.dwGroupID = lpd->dwGroupID;

			// Call our internal remote create
			hr = DPLP_DestroyGroup((LPDPLOBBYSP)this->lpInterfaces, &dg);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed destroying remote group, hr = 0x%08x", hr);
				goto ERROR_DPLP_ADDGROUPTOGROUP;
			}
		}

		// If we failed, don't send the system message
		DPF_ERRVAL("Failed adding remote group to group from the lobby, hr = 0x%08x", hr);
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}


	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDSHORTCUTTOGROUP);
	msg.dwPlayerID = lpd->dwGroupID;
	msg.dwGroupID = lpd->dwAnchorID;

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding AddGroupToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


ERROR_DPLP_ADDGROUPTOGROUP:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_AddGroupToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_AddPlayerToGroup"
HRESULT DPLAPI DPLP_AddPlayerToGroup(LPDPLOBBYSP lpILP,
				LPSPDATA_ADDREMOTEPLAYERTOGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	DPID					dpidPlayer;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	LPDPLAYI_GROUPNODE		lpGroupnode = NULL;
	MSG_PLAYERMGMTMESSAGE	msg, cpmsg;
	BOOL					bCreated = FALSE;
	DWORD					dwPlayerFlags = 0;


	DPF(7, "Entering DPLP_AddPlayerToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_ADDREMOTEPLAYERTOGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved AddPlayerToGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Fix up the player flags
	if(lpd->dwPlayerFlags & DPPLAYER_SPECTATOR)
		dwPlayerFlags |= DPLAYI_PLAYER_SPECTATOR;
	if(lpd->dwPlayerFlags & DPPLAYER_SERVERPLAYER)
		dwPlayerFlags |= DPLAYI_PLAYER_APPSERVER;

	// Take the dplay lock
	ENTER_DPLAY();

	// Now see if the player is in our map table.  If it is, we
	// probably want to update the name.  If it's not, we need to
	// add them to the nametable and the map table
	if(!IsLobbyIDInMapTable(this, lpd->dwPlayerID))
	{
		// It doesn't show up in our map table, so create a new
		// nametable entry for them and put them in our map table.
		hr = PRV_CreateAndMapNewPlayer(this, &dpidPlayer, lpd->lpName,
				NULL, NULL, 0, dwPlayerFlags,
				lpd->dwPlayerID, FALSE);
		if(FAILED(hr))
		{
			DPF(8, "Unable to add player to nametable or map table, hr = 0x%08x", hr);
			goto ERROR_DPLP_ADDPLAYER;
		}

		bCreated = TRUE;
	}

	// Make sure the player isn't already in the group.  If it is,
	// we just want to return DP_OK and exit so that we don't send any
	// duplicate messages.
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDPLAYER;
	}
	
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwPlayerID);
	if(!lpPlayer)
	{
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto ERROR_DPLP_ADDPLAYER;
	}
	
	lpGroupnode = lpGroup->pGroupnodes;
    while(lpGroupnode) 
    {
        if(lpGroupnode->pPlayer == lpPlayer) 
        {
			DPF(2, "Player already in group!");
			hr = DP_OK;
			goto ERROR_DPLP_ADDPLAYER;
        }

		// check next node
        lpGroupnode = lpGroupnode->pNextGroupnode;
    }

	// So now we should have a valid group and valid player in both
	// the map table and the nametable, so call dplay with the add message
	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
				lpd->dwGroupID, lpd->dwPlayerID, FALSE);
	if(FAILED(hr))
	{
		// If we created the player and mapped it, then destroy the
		// player and unmap it.
		if(bCreated)
		{
			// Remove the player from the nametable
			InternalDestroyPlayer(this->lpDPlayObject, lpPlayer, FALSE, FALSE);
		}

		// If we failed, don't send the system message
		DPF_ERRVAL("Failed adding remote player to group from the lobby, hr = 0x%08x", hr);
		goto ERROR_DPLP_ADDPLAYER;
	}

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDPLAYER;
	}

	// If we created this player, we need to send a CreatePlayer message ahead
	// of the AddPlayerToGroup message
	if(bCreated)
	{
		// Now build the system message (at least the parts we need)
		memset(&cpmsg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&cpmsg);
		SET_MESSAGE_COMMAND(&cpmsg, DPSP_MSG_CREATEPLAYER);
		cpmsg.dwPlayerID = lpd->dwPlayerID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&cpmsg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding CreatePlayer message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	// Now build the system message for AddPlayerToGroup
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDPLAYERTOGROUP);
	msg.dwPlayerID = lpd->dwPlayerID;
	msg.dwGroupID = lpd->dwGroupID;

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding AddPlayerToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	// We need to see if this player is the group owner.  If it is,
	// we need to send a SetGroupOwner message as well.
	if(lpd->dwPlayerID == lpGroup->dwOwnerID)
	{
		// Now send the message
		PRV_SendGroupOwnerMessageLocally(this, lpd->dwGroupID,
				lpd->dwPlayerID, 0);
	}

ERROR_DPLP_ADDPLAYER:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_AddPlayerToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_CreateGroup"
HRESULT DPLAPI DPLP_CreateGroup(LPDPLOBBYSP lpILP,
						LPSPDATA_CREATEREMOTEGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	DPID					dpidGroup;
	DWORD					dwInternalFlags = 0;
	DWORD					dwOwnerID;


	DPF(7, "Entering DPLP_CreateGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_CREATEREMOTEGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Fix the flags from external to internal
	if(lpd->dwFlags & DPGROUP_STAGINGAREA)
		dwInternalFlags = DPLAYI_GROUP_STAGINGAREA;
	if(lpd->dwFlags & DPGROUP_HIDDEN)
		dwInternalFlags |= DPLAYI_GROUP_HIDDEN;

	// Take the lock
	ENTER_DPLAY();

	// First see if the group is in our map table.  If it is,
	// we just want to return.  If it's not, we want to add
	// them and send the appropriate message
	if(IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(2, "Received a CreateGroup message for a group we already know about");
		hr = DP_OK;
		goto ERROR_DPLP_CREATEGROUP;
	}
	else
	{
		// Make the owner default to the server player if we have a problem
		dwOwnerID = DPID_SERVERPLAYER;

		// If we are talking to at least a DX6 lobby provider, we should
		// be able to use the GroupOwnerID element
		if(this->dwLPVersion > DPLSP_DX5VERSION)
			dwOwnerID = lpd->dwGroupOwnerID;
		
		// Create a new entry in the nametable and map the ID's
		hr = PRV_CreateAndMapNewGroup(this, &dpidGroup, lpd->lpName,
				lpd->lpData, lpd->dwDataSize, dwInternalFlags,
				lpd->dwGroupID, 0, dwOwnerID);
		if(FAILED(hr))
		{
			// If we fail, we don't want to send the system message
			DPF_ERRVAL("Unable to add group to nametable or map table, hr = 0x%08x", hr);
			goto ERROR_DPLP_CREATEGROUP;
		}
	}

	// Now build the system message (at least the parts we need
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = lpd->dwGroupID;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_CREATEGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message in
	// the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo, (LPBYTE)&msg,
			sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding CreateGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

ERROR_DPLP_CREATEGROUP:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_CreateGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_CreateGroupInGroup"
HRESULT DPLAPI DPLP_CreateGroupInGroup(LPDPLOBBYSP lpILP,
					LPSPDATA_CREATEREMOTEGROUPINGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	DPID					dpidGroup;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	MSG_PLAYERMGMTMESSAGE	msg;
	BOOL					bCreated = FALSE;
	DWORD					dwInternalFlags = 0;
	DWORD					dwOwnerID;


	DPF(7, "Entering DPLP_CreateGroupInGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_CREATEREMOTEGROUPINGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwParentID))
	{
		LEAVE_DPLOBBY();
		DPF_ERRVAL("Recieved CreateGroupInGroup message for unknown parent group, dwGroupID = %lu, discarding message", lpd->dwParentID);
		return DPERR_INVALIDGROUP;
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// First see if the group is in our map table.  If it is,
	// we just want to return.  If it's not, we want to add
	// them and send the appropriate message
	if(IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(2, "Received a CreateGroupInGroup message for a group we already know about");
		hr = DP_OK;
		goto ERROR_DPLP_CREATEGROUPINGROUP;
	}
	else
	{
		// Setup the internal flags
		if(lpd->dwFlags & DPGROUP_STAGINGAREA)
			dwInternalFlags = DPLAYI_GROUP_STAGINGAREA;
		if(lpd->dwFlags & DPGROUP_HIDDEN)
			dwInternalFlags |= DPLAYI_GROUP_HIDDEN;
		
		// Make the owner default to the server player if we have a problem
		dwOwnerID = DPID_SERVERPLAYER;

		// If we are talking to at least a DX6 lobby provider, we should
		// be able to use the GroupOwnerID element
		if(this->dwLPVersion > DPLSP_DX5VERSION)
			dwOwnerID = lpd->dwGroupOwnerID;
		
		// It doesn't show up in our map table, so create a new
		// nametable entry for them and put them in our map table.
		hr = PRV_CreateAndMapNewGroup(this, &dpidGroup, lpd->lpName,
				NULL, 0, dwInternalFlags,
				lpd->dwGroupID, lpd->dwParentID, dwOwnerID);
		if(FAILED(hr))
		{
			DPF(8, "Unable to add group to nametable or map table, hr = 0x%08x", hr);
			goto ERROR_DPLP_CREATEGROUPINGROUP;
		}

		bCreated = TRUE;
	}

	// So now we should have a valid group and valid player in both
	// the map table and the nametable, so call dplay with the add message
	hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
				lpd->dwParentID, lpd->dwGroupID, lpd->dwFlags, FALSE);
	if(FAILED(hr))
	{
		// If we created the player and mapped it, then destroy the
		// player and unmap it.
		if(bCreated)
		{
			// Get a pointer to dplay's group struct
			lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);

			// Remove the group from the nametable
			if(lpGroup){
				InternalDestroyGroup(this->lpDPlayObject, lpGroup, FALSE);
			}	
		}

		// If we failed, don't send the system message
		DPF_ERRVAL("Failed creating remote group in group from the lobby, hr = 0x%08x", hr);
		goto ERROR_DPLP_CREATEGROUPINGROUP;
	}


	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = lpd->dwGroupID;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_CREATEGROUPINGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding CreateGroupInGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


ERROR_DPLP_CREATEGROUPINGROUP:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_CreateGroupInGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteRemoteGroupFromGroup"
HRESULT PRV_DeleteRemoteGroupFromGroup(LPDPLOBBYI_DPLOBJECT this,
			LPSPDATA_DELETEREMOTEGROUPFROMGROUP lpd, BOOL fPropagate,
			LPDPLAYI_GROUP lpStopParent)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL, lpParentGroup = NULL;
	MSG_PLAYERMGMTMESSAGE	msg;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DeleteRemoteGroupFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			this, lpd, fPropagate, lpStopParent);


	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwParentID))
	{
		DPF(8, "Recieved DeleteGroupFromGroup message for unknown parent group, dwGroupID = %lu, discarding message", lpd->dwParentID);
		return DPERR_INVALIDGROUP;
	}

	// Now make sure the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(8, "Recieved DeleteGroupFromGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Take the lock
	ENTER_DPLAY();

	// Get dplay's internal group structures
	lpParentGroup = GroupFromID(this->lpDPlayObject, lpd->dwParentID);
	if(!lpParentGroup)
	{
		LEAVE_DPLAY();
		DPF(8, "Unable to find parent group in nametable");
		return DPERR_INVALIDGROUP;
	}

	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		LEAVE_DPLAY();
		DPF(8, "Unable to find group in nametable");
		return DPERR_INVALIDGROUP;
	}

	// Call dplay's internal removegroupfromgroup to remove the attachment
	// in the nametable
	hr = RemoveGroupFromGroup(lpParentGroup, lpGroup);
	if(FAILED(hr))
	{
		DPF(8, "Failed removing group from group, hr = 0x%08x", hr);
		goto EXIT_DPLP_DELETEREMOTEGROUPFROMGROUP;
	}

	// If the fPropagate flag is not set, we don't want to send this message
	if(fPropagate)
	{
		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUPFROMGROUP);
		msg.dwPlayerID = lpd->dwGroupID;
		msg.dwGroupID = lpd->dwParentID;

		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			DPF(8, "Unable to find system group in nametable");
			goto EXIT_DPLP_DELETEREMOTEGROUPFROMGROUP;
		}

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DeleteGroupFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	// Even if we couldn't send the message above, destroy the group anyway

EXIT_DPLP_DELETEREMOTEGROUPFROMGROUP:

	// Destroy the group and any of it's parents if there are no more local
	// references to it or any of it's heirarchy
	PRV_DestroyGroupAndParents(this, lpGroup, lpStopParent);

	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_DeleteRemoteGroupFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_DeleteGroupFromGroup"
HRESULT DPLAPI DPLP_DeleteGroupFromGroup(LPDPLOBBYSP lpILP,
					LPSPDATA_DELETEREMOTEGROUPFROMGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_DeleteGroupFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_DELETEREMOTEGROUPFROMGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Call our internal routine, setting the propagate flag to TRUE so that
	// we post the appropriate message in the player's receive queue
	hr = PRV_DeleteRemoteGroupFromGroup(this, lpd, TRUE, NULL);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_DeleteGroupFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteRemotePlayerFromGroup"
HRESULT PRV_DeleteRemotePlayerFromGroup(LPDPLOBBYI_DPLOBJECT this,
			LPSPDATA_DELETEREMOTEPLAYERFROMGROUP lpd, BOOL fPropagate)
{
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	MSG_PLAYERMGMTMESSAGE	msg, dpmsg;
	HRESULT					hr;


	DPF(7, "Entering PRV_DeleteRemotePlayerFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", this, lpd, fPropagate);


	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(8, "Recieved DeletePlayerFromGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Now make sure the player is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// player we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwPlayerID))
	{
		DPF(8, "Recieved DeletePlayerFromGroup message for unknown player, dwPlayerID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDPLAYER;
	}

	// Take the lock
	ENTER_DPLAY();

	// Call dplay's internal removeplayerfromgroup to remove the attachment
	// in the nametable
	hr = InternalDeletePlayerFromGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
			lpd->dwGroupID, lpd->dwPlayerID, FALSE);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed removing player from group, hr = 0x%08x", hr);
		goto ERROR_DPLP_DELETEPLAYERFROMGROUP;
	}

	// If the fPropagate flag is not set, we don't want to send this message
	if(fPropagate)
	{
		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEPLAYERFROMGROUP);
		msg.dwPlayerID = lpd->dwPlayerID;
		msg.dwGroupID = lpd->dwGroupID;

		// Find dplay's internal group struct for the To group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
			hr = DPERR_INVALIDGROUP;
			goto ERROR_DPLP_DELETEPLAYERFROMGROUP;
		}

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DeletePlayerFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	// Get dplay's internal group & player structures
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwPlayerID);
	if(!lpPlayer)
	{
		// So if this fails, the above call to InternalDeletePlayerFromGroup
		// shouldn't have succeeded either
		DPF_ERR("Unable to find player in nametable");
		ASSERT(FALSE);
		goto ERROR_DPLP_DELETEPLAYERFROMGROUP;
	}

	// Now we need to decide if this is the last group this player was in.  If
	// it is, then we need to destroy the player as well, and remove them from
	// our map table.  Of course, only destroy the player if it is a remote player.
	if((!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) &&
		(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP)))
	{
		// However, before we do this, we need to send a DestroyPlayer
		// message to all the people who got the DeletePlayerFromGroup
		if(lpGroupTo && fPropagate)
		{
			// Now build the system message (at least the parts we need)
			memset(&dpmsg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
			SET_MESSAGE_HDR(&dpmsg);
			SET_MESSAGE_COMMAND(&dpmsg, DPSP_MSG_DELETEPLAYER);
			dpmsg.dwPlayerID = lpd->dwPlayerID;

			// Call dplay's DistributeGroupMessage function to put the message
			// in the queues of all the appropriate players
			DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
					(LPBYTE)&dpmsg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
			if(FAILED(hr))
			{
				DPF(8, "Failed adding DestroyPlayer message to player's receive queue from lobby, hr = 0x%08x", hr);
			}
		}

		// Destroy the player and remove it from the nametable
		InternalDestroyPlayer(this->lpDPlayObject, lpPlayer, FALSE, FALSE);
	}


ERROR_DPLP_DELETEPLAYERFROMGROUP:

	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_DeleteRemotePlayerFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_DeletePlayerFromGroup"
HRESULT DPLAPI DPLP_DeletePlayerFromGroup(LPDPLOBBYSP lpILP,
						LPSPDATA_DELETEREMOTEPLAYERFROMGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_DeletePlayerFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_DELETEREMOTEPLAYERFROMGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Call our internal routine, setting the propagate flag to TRUE so that
	// we post the appropriate message in the player's receive queue
	hr = PRV_DeleteRemotePlayerFromGroup(this, lpd, TRUE);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_DeletePlayerFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_BroadcastDestroyGroupMessage"
HRESULT DPLAPI PRV_BroadcastDestroyGroupMessage(LPDPLOBBYI_DPLOBJECT this,
					DWORD dwGroupID)
{
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr;


	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUP);
	msg.dwGroupID = dwGroupID;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERR("Unable to find system group in nametable");
		hr = DPERR_INVALIDGROUP;
	}
	else
	{
		// Call dplay's DistributeGroupMessage function to put the message in the queue
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DestroyGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	return hr;

} // PRV_BroadcastDestroyGroupMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveSubgroupsAndPlayersFromGroup"
void PRV_RemoveSubgroupsAndPlayersFromGroup(LPDPLOBBYI_DPLOBJECT this,
		LPDPLAYI_GROUP lpGroup, DWORD dwGroupID, BOOL bRemoteOnly)
{
	SPDATA_DELETEREMOTEPLAYERFROMGROUP	dpd;
	LPDPLAYI_GROUPNODE					lpGroupnode = NULL;
	LPDPLAYI_GROUPNODE					lpNextGroupnode = NULL;
	HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_RemoveSubgroupsAndPlayersFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpGroup);

	ASSERT(lpGroup);

	// Destroy any subgroups hanging off of this group
	PRV_DestroySubgroups(this, lpGroup, bRemoteOnly);

	// Walk the list of nodes, removing each player from the group manually.
	// The reason for doing this manually is so that the lobby gets a chance
	// to remove every remote player out of the nametable whose only existence
	// was inside this room.  It also allows the lobby to remove the player's
	// ID from the map table.  Do this by calling the lobby's
	// DPLP_DeletePlayerFromGroup function which responds to that message.

	// Setup the DeletePlayerFromGroup data structure
	memset(&dpd, 0, sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP));
	dpd.dwSize = sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP);
	dpd.dwGroupID = dwGroupID;

	// Walk the list of groupnodes, deleting all of the remote players
	lpGroupnode = lpGroup->pGroupnodes;
	while(lpGroupnode)
	{
		// Save the next groupnode
		lpNextGroupnode = lpGroupnode->pNextGroupnode;
		
		// If the player is local, skip them
		if(lpGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		{
			lpGroupnode = lpNextGroupnode;
			continue;
		}

		// Get the lobby ID for the player
		dpd.dwPlayerID = lpGroup->pGroupnodes->pPlayer->dwID;

		// Now call the lobby's delete function, setting the fPropagate flag
		// to true so we put a delete message in the player's queue
		hr = PRV_DeleteRemotePlayerFromGroup(this, &dpd, TRUE);
		if(FAILED(hr))
		{
			// Same here, if this fails, something is tragically wrong
			// with the map table, so just continue;
			ASSERT(FALSE);
			break;
		}

		// Move to the next node
		lpGroupnode = lpNextGroupnode;
	}

} // PRV_RemoveSubgroupsAndPlayersFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendDeleteShortcutMessageForExitingGroup"
void PRV_SendDeleteShortcutMessageForExitingGroup(LPDPLOBBYI_DPLOBJECT this,
			LPDPLAYI_GROUP lpGroup)
{
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpGroupTemp = NULL;
	LPDPLAYI_SUBGROUP		lpSubgroupTemp = NULL;
	UINT					nGroupsIn;
	HRESULT					hr;


	DPF(7, "Entering PRV_SendDeleteShortcutMessageForExitingGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpGroup);

	// Take the dplay lock since we will be walking dplay's group list
	ENTER_DPLAY();

	// Get the number of subgroups this group is in
	nGroupsIn = lpGroup->nGroups;

	// Setup the static parts of the message, and get a pointer to the system group
	if(nGroupsIn)
	{
		// Build the message struct
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUPFROMGROUP);
		msg.dwPlayerID = lpGroup->dwID;

		// Get a pointer to the system group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_DPLAY();
			DPF_ERR("Unable to get a pointer to the system group - not sending deletegroupfromgroup messages");
			return;
		}
	}

	// Walk the list of groups, and send a DeleteGroupFromGroup message
	// for each shortcut
	lpGroupTemp = this->lpDPlayObject->pGroups;
	while(nGroupsIn && lpGroupTemp)
	{
		// Walk the list of subgroups for the group
		lpSubgroupTemp = lpGroupTemp->pSubgroups;
		while(nGroupsIn && lpSubgroupTemp)
		{
			// If the group is our group, send a message, but only if
			// it is not the parent group (since we will never do a
			// DeleteGroupFromGroup on a parent-child)
			if(lpSubgroupTemp->pGroup == lpGroup)
			{
				// Make sure it's not the group's parent
				if(lpGroup->dwIDParent != lpGroupTemp->dwID)
				{
					// Send the message
					msg.dwGroupID = lpGroupTemp->dwID;

					// Call dplay's DistributeGroupMessage function to put the message
					// in the queues of all the appropriate players
					hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
							(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
					if(FAILED(hr))
					{
						DPF(8, "Failed adding DeleteGroupFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
					}
				}

				// Decrement the count of subgroups
				nGroupsIn--;
			}
			
			// Move to the next subgroup
			lpSubgroupTemp = lpSubgroupTemp->pNextSubgroup;
		}

		// Move to the next group
		lpGroupTemp = lpGroupTemp->pNextGroup;
	}

	ASSERT(!nGroupsIn);

	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

} // PRV_SendDeleteShortcutMessageForExitingGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_DestroyGroup"
HRESULT DPLAPI DPLP_DestroyGroup(LPDPLOBBYSP lpILP,
					LPSPDATA_DESTROYREMOTEGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT				this;
	HRESULT								hr = DP_OK;
	LPDPLAYI_GROUP						lpGroup = NULL;
	LPDPLAYI_GROUPNODE					lpGroupNode = NULL;


	DPF(7, "Entering DPLP_DestroyGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_DESTROYGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved DestroyGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// This is either a group we are in, or it is a root group.  If it has
	// any players, it's a group we are in, so we need to delete all remote
	// players from the nametable and map table (if this is the only group
	// they are in).

	// Take the lock
	ENTER_DPLAY();

	// So, get dplay's internal group structure
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		// If we don't have an lpGroup, we need to fail because some of
		// the functions below will crash if lpGroup is invalid.
		DPF(8, "Unable to find group in nametable, dpidGroup = %lu", lpd->dwGroupID);
		LEAVE_LOBBY_ALL();
		return DPERR_INVALIDGROUP;
	}

	// Send messages to remove shortcuts to this group (since dplay won't
	// do it for us)
	PRV_SendDeleteShortcutMessageForExitingGroup(this, lpGroup);

	// Destroy all the remote subgroups and players
	PRV_RemoveSubgroupsAndPlayersFromGroup(this, lpGroup, lpd->dwGroupID, FALSE);

	// Now send a DestroyGroup system message to all the local players
	hr = PRV_BroadcastDestroyGroupMessage(this, lpd->dwGroupID);

	// Now call dplay's destroy group
	hr = InternalDestroyGroup(this->lpDPlayObject, lpGroup, FALSE); 
	if(FAILED(hr))
	{
		DPF(8, "Failed destroying group from nametable, hr = 0x%08x", hr);
	}

	// Drop the locks
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_DestroyGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_GetSPDataPointer"
HRESULT DPLAPI DPLP_GetSPDataPointer(LPDPLOBBYSP lpDPLSP, LPVOID * lplpData)
{
	LPDPLOBBYI_DPLOBJECT this;


	//	Make sure the SP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpDPLSP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// Go ahead and save the pointer
	*lplpData = this->lpSPData;

	return DP_OK;

} // DPLP_GetSPDataPointer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_HandleLobbySystemMessage"
HRESULT PRV_HandleLobbySystemMessage(LPDPLOBBYI_DPLOBJECT this,
						LPSPDATA_HANDLEMESSAGE lpd)
{
	LPDPLMSG_GENERIC				lpmsg = lpd->lpBuffer;
	LPDPLMSG_GETPROPERTYRESPONSE	lpgpr = NULL;
	LPDPLOBBYI_REQUESTNODE			lprn = NULL;
	HRESULT							hr = DP_OK;

	
	// If it's a property message, we need to deal with the request
	switch(lpmsg->dwType)
	{
		case DPLSYS_GETPROPERTYRESPONSE:
		case DPLSYS_SETPROPERTYRESPONSE:
		{
			// Cast it to a GetPropertyResponse message
			lpgpr = (LPDPLMSG_GETPROPERTYRESPONSE)lpmsg;
			
			// Find the request ID in our list of pending requests
			lprn = this->lprnHead;
			while(lprn)
			{
				if(lprn->dwRequestID == lpgpr->dwRequestID)
					break;
				else
					lprn = lprn->lpNext;
			}

			// Print some debug spew if we didn't find it, but return DP_OK since
			// we "handled" the message
			if(!lprn)
			{
				DPF(5, "Unable to find request ID in pending request list");
				return DP_OK;
			}

			// See if we slammed the guid, and replace it with GUID_NULL if we did
			if(lprn->dwFlags & GN_SLAMMED_GUID)
				lpgpr->guidPlayer = GUID_NULL;
			
			// If we found it, swap out the request ID, and send it to the
			// appropriate place
			lpgpr->dwRequestID = lprn->dwAppRequestID;
			if(lprn->dwFlags & GN_SELF_LOBBIED)
			{
				// Put the message in the lobby message receive queue
				hr = PRV_InjectMessageInQueue(lprn->lpgn, DPLMSG_STANDARD,
						lpgpr, lpd->dwBufSize, FALSE);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed to put message in lobby receive queue, hr = 0x%08x", hr);
					goto EXIT_HANDLELOBBYSYSTEMMESSAGE;
				}
			}
			else
			{
				// Call SendLobbyMessage to send the message to the game
				hr = PRV_WriteClientData(lprn->lpgn, DPLMSG_STANDARD,
						lpgpr, lpd->dwBufSize);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed to forward message to game, hr = 0x%08x", hr);
					goto EXIT_HANDLELOBBYSYSTEMMESSAGE;
				}
			}

			break;
		}
		default:
			break;
	}

EXIT_HANDLELOBBYSYSTEMMESSAGE:
	
	// Remove the pending request node if we serviced it (which would have
	// happened if we have a valid pointer to it)
	if(lprn)
		PRV_RemoveRequestNode(this, lprn);	
	
	return hr;

} // PRV_HandleLobbySystemMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_HandleMessage"
HRESULT DPLAPI DPLP_HandleMessage(LPDPLOBBYSP lpILP,
						LPSPDATA_HANDLEMESSAGE lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPMSG_PLAYERMESSAGE		lpmsg = NULL;
	LPBYTE					lpByte = NULL;
	DWORD					dwSize;
	BOOL					bAllocBuffer = FALSE;
	LPDPLAYI_PLAYER			lpPlayer = NULL;


	DPF(7, "Entering DPLP_HandleMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_HANDLEMESSAGE structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// If the message is a lobby system message, process it
	// NOTE: Make sure the size of the SPDATA_HANDLEMESSAGE is big enough
	// to contain a flags field (the shipping 5.0 bits did not have
	// this field, but the 5.1 bits did).
	if((lpd->dwSize > DPLOBBYPR_SIZE_HANDLEMESSAGE_DX50) &&
		(lpd->dwFlags & DPSEND_LOBBYSYSTEMMESSAGE))
	{
		hr = PRV_HandleLobbySystemMessage(this, lpd);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to handle lobby system message, hr = 0x%08x", hr);
		}

		LEAVE_DPLOBBY();
		return hr;
	}

	// REVIEW!!!! -- We should be able to handle a generic send to a group
	// as well as a player.  Currently, I don't think we do.

	// If this session is using naked messages, we can just send the buffer.
	// Otherwise, we need to allocate a MSG_PLAYERMESSAGE struct and fill
	// in the header.
	if(this->lpDPlayObject->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID)
	{
		lpmsg = lpd->lpBuffer;
		dwSize = lpd->dwBufSize;
	}
	else
	{
		// Calculate the size of the message
		dwSize = sizeof(MSG_PLAYERMESSAGE) + lpd->dwBufSize;

		// Allocate memory for a message buffer
		lpmsg = DPMEM_ALLOC(dwSize);
		if(!lpmsg)
		{
			DPF_ERR("Unable to allocate temporary message buffer");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_DPLP_HANDLEMESSAGE;
		}

		// Copy in the message header
		lpmsg->idFrom = lpd->dwFromID;
		lpmsg->idTo = lpd->dwToID;

		// Copy in the message
		lpByte = (LPBYTE)lpmsg + sizeof(MSG_PLAYERMESSAGE);
		memcpy(lpByte, lpd->lpBuffer, lpd->dwBufSize);

		// Set our flag indicating that we allocated a buffer
		bAllocBuffer = TRUE;
	}

	// Take the lock
	ENTER_DPLAY();

	// Find dplay's internal player struct for the To player
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwToID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERRVAL("Unable to find player in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDPLAYER;
		goto ERROR_DPLP_HANDLEMESSAGE;
	}

	// Call dplay's handleplayermessage function to put the message in the queue
	hr = HandlePlayerMessage(lpPlayer, (LPBYTE)lpmsg, dwSize, TRUE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	// Drop the lock
	LEAVE_DPLAY();
			

ERROR_DPLP_HANDLEMESSAGE:
	if(bAllocBuffer && lpmsg)
		DPMEM_FREE(lpmsg);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_HandleMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SendChatMessage"
HRESULT DPLAPI DPLP_SendChatMessage(LPDPLOBBYSP lpILP,
						LPSPDATA_CHATMESSAGE lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPMSG_CHAT				lpmsg = NULL;
	LPBYTE					lpByte = NULL;
	DWORD					dwSize;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	DWORD					dwStringSize;
	BOOL					bToGroup = FALSE;
		


	DPF(7, "Entering DPLP_SendChatMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_HANDLEMESSAGE structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Calculate the size of the message
	dwStringSize = WSTRLEN_BYTES(lpd->lpChat->lpszMessage);
	dwSize = sizeof(MSG_CHAT) + dwStringSize;

	// Allocate memory for a message buffer
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate temporary message buffer");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_DPLP_SENDCHATMESSAGE;
	}

	// Copy in the message header
	SET_MESSAGE_HDR(lpmsg);
	SET_MESSAGE_COMMAND(lpmsg,DPSP_MSG_CHAT);
	lpmsg->dwIDFrom = lpd->dwFromID;
	lpmsg->dwIDTo = lpd->dwToID;
	lpmsg->dwFlags = lpd->lpChat->dwFlags;
	lpmsg->dwMessageOffset = sizeof(MSG_CHAT);

	// Copy in the message
	lpByte = (LPBYTE)lpmsg + sizeof(MSG_CHAT);
	memcpy(lpByte, lpd->lpChat->lpszMessage, dwStringSize);


	// Take the lock
	ENTER_DPLAY();

	// Make sure it's from a valid player or the server player
	if(lpd->dwFromID != DPID_SERVERPLAYER)
	{
		lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwFromID);
		if(!VALID_DPLAY_PLAYER(lpPlayer)) 
		{
			LEAVE_DPLAY();
			DPF_ERR("Received chat message FROM invalid player id!!");
			hr = DPERR_INVALIDPLAYER;
			goto ERROR_DPLP_SENDCHATMESSAGE;
		}
	}

	// See who the message is for
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwToID);
	if(!VALID_DPLAY_PLAYER(lpPlayer)) 
	{
		// See if it's to a group
		lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwToID);
		if(!VALID_DPLAY_GROUP(lpGroup))
		{
			LEAVE_DPLAY();
			DPF_ERR("Received chat message for invalid player / group");
			hr = DPERR_INVALIDPLAYER;
			goto ERROR_DPLP_SENDCHATMESSAGE;
		}
		bToGroup = TRUE;
	}

	// Send it out
	if(bToGroup)
	{
		// Send the message
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroup,
				(LPBYTE)lpmsg, dwSize, FALSE, 0);						
	} 
	else 
	{
		// Send the message
		hr = HandlePlayerMessage(lpPlayer, (LPBYTE)lpmsg, dwSize, FALSE, 0);
	}

	// Drop the lock
	LEAVE_DPLAY();
			

ERROR_DPLP_SENDCHATMESSAGE:
	if(lpmsg)
		DPMEM_FREE(lpmsg);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_SendChatMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendDataChangedMessageLocally"
HRESULT PRV_SendDataChangedMessageLocally(LPDPLOBBYI_DPLOBJECT this,
		DPID dpidPlayer, LPVOID lpData, DWORD dwDataSize)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	LPMSG_PLAYERDATA		lpmsg = NULL;
	LPBYTE					lpByte = NULL;
	DWORD					dwSize;


	DPF(7, "Entering PRV_SendDataChangedMessageLocally");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, %lu",
			this, dpidPlayer, lpData, dwDataSize);


	// Take the lock
	ENTER_DPLAY();
	
	// Setup the message to put in the player's queue
	// Calculate the size of the message
	dwSize = sizeof(MSG_PLAYERDATA) + dwDataSize;

	// Allocate memory for the message
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate memory for temporary message structure");
		// Since the name has been changed, we'll just return success here
		hr = DP_OK;
		goto EXIT_SENDDATACHANGED;
	}

	// Now build the system message
	SET_MESSAGE_HDR(lpmsg);
	SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_PLAYERDATACHANGED);
	lpmsg->dwPlayerID = dpidPlayer;
	lpmsg->dwDataSize = dwDataSize;
	lpmsg->dwDataOffset = sizeof(MSG_PLAYERDATA);

	// Copy in the data
	lpByte = (LPBYTE)lpmsg + sizeof(MSG_PLAYERDATA);
	memcpy(lpByte, lpData, dwDataSize);

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_SENDDATACHANGED;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)lpmsg, dwSize, FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding SetGroupData message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

EXIT_SENDDATACHANGED:

	// Free our message
	if(lpmsg)
		DPMEM_FREE(lpmsg);
	
	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_SendDataChangedMessageLocally



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendNameChangedMessageLocally"
HRESULT PRV_SendNameChangedMessageLocally(LPDPLOBBYI_DPLOBJECT this,
		DPID dpidPlayer, LPDPNAME lpName, BOOL bPlayer)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	LPMSG_PLAYERNAME		lpmsg = NULL;
	DWORD					dwSize, dwShortSize = 0, dwLongSize = 0;
	LPBYTE					lpByte = NULL;

	DPF(7, "Entering PRV_SendNameChangedMessageLocally");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dpidPlayer, lpName, bPlayer);


	// Take the lock
	ENTER_DPLAY();
	
	// Setup the message to put in the player's queue
	// Calculate the size of the message
	if(lpName->lpszShortName)
		dwShortSize = WSTRLEN_BYTES(lpName->lpszShortName);
	if(lpName->lpszLongName)
		dwLongSize = WSTRLEN_BYTES(lpName->lpszLongName);
	dwSize = sizeof(MSG_PLAYERNAME) + dwShortSize + dwLongSize;

	// Allocate memory for the message
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate memory for temporary message structure");
		// Since the name has been changed, we'll just return success here
		hr = DP_OK;
		goto EXIT_SENDNAMECHANGED;
	}

	// Now build the system message
	SET_MESSAGE_HDR(lpmsg);
	if(bPlayer)
		SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_PLAYERNAMECHANGED);
	else
		SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_GROUPNAMECHANGED);
	lpmsg->dwPlayerID = dpidPlayer;
	lpmsg->dwShortOffset = sizeof(MSG_PLAYERNAME);
	lpmsg->dwLongOffset = sizeof(MSG_PLAYERNAME) + dwShortSize;

	// Copy in the names
	lpByte = (LPBYTE)lpmsg + sizeof(MSG_PLAYERNAME);
	memcpy(lpByte, lpName->lpszShortName, dwShortSize);
	lpByte += dwShortSize;
	memcpy(lpByte, lpName->lpszLongName, dwLongSize);

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_SENDNAMECHANGED;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)lpmsg, dwSize, FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding SetGroupName message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


EXIT_SENDNAMECHANGED:

	// Free our message
	if(lpmsg)
		DPMEM_FREE(lpmsg);
	
	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_SendNameChangedMessageLocally



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetGroupName"
HRESULT DPLAPI DPLP_SetGroupName(LPDPLOBBYSP lpILP,
					LPSPDATA_SETREMOTEGROUPNAME lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_SetGroupName");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETGROUPNAME structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// First see if the group is in our map table.  If it is not,
	// we should just ignore this message because it's for a
	// group we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved SetGroupName message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Take the lock
	ENTER_DPLAY();

	// See if the group is local or remote.  If it's local, ignore this message
	// and just return DP_OK becuase we've already sent this message locally.
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if((!lpGroup) || (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETGROUPNAME;
	}

	// Call dplay's internalsetname function to update the name in the cache
	hr = InternalSetName((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
			lpd->dwGroupID, lpd->lpName, FALSE, lpd->dwFlags, FALSE);
	if(FAILED(hr))
	{
		DPF(8, "Failed to SetGroupName internally for remote group, hr = 0x%08x", hr);
		goto ERROR_DPLP_SETGROUPNAME;
	}

	// Send the message to all the local players
	hr = PRV_SendNameChangedMessageLocally(this, lpd->dwGroupID, lpd->lpName, FALSE);

ERROR_DPLP_SETGROUPNAME:

	// Drop the locks
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_SetGroupName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendGroupOwnerMessageLocally"
HRESULT PRV_SendGroupOwnerMessageLocally(LPDPLOBBYI_DPLOBJECT this,
		DPID dpidGroup, DPID dpidNewOwner, DPID dpidOldOwner)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	MSG_GROUPOWNERCHANGED	msg;


	DPF(7, "Entering PRV_SendGroupOwnerMessageLocally");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			this, dpidGroup, dpidNewOwner, dpidOldOwner);


	// Take the lock
	ENTER_DPLAY();
	
	// Now build the system message
	memset(&msg, 0, sizeof(MSG_GROUPOWNERCHANGED));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_GROUPOWNERCHANGED);
	msg.dwIDGroup = dpidGroup;
	msg.dwIDNewOwner = dpidNewOwner;
	msg.dwIDOldOwner = dpidOldOwner;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_SENDGROUPOWNER;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_GROUPOWNERCHANGED), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding SetGroupOwner message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


EXIT_SENDGROUPOWNER:

	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_SendGroupOwnerMessageLocally



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetGroupOwner"
HRESULT DPLAPI DPLP_SetGroupOwner(LPDPLOBBYSP lpILP,
					LPSPDATA_SETREMOTEGROUPOWNER lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;
	DWORD					dwOldOwnerID;


	DPF(7, "Entering DPLP_SetGroupOwner");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETGROUPNAME structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// First see if the group is in our map table.  If it is not,
	// we should just ignore this message because it's for a
	// group we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved SetGroupOwner message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Take the lock
	ENTER_DPLAY();

	// See if the group is local or remote.  If it's local, ignore this message
	// and just return DP_OK becuase we've already sent this message locally.
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETGROUPOWNER;
	}

	// If the player is already the owner of the group, we don't need
	// to do any processing (this is the buffer in case the server
	// sends us duplicate messages for stuff we've already sent locally)
	if(lpGroup->dwOwnerID == lpd->dwOwnerID)
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETGROUPOWNER;
	}
	
	// Make sure the old owner is in our map table, otherwise just set
	// it to zero (the default)
	dwOldOwnerID = lpGroup->dwOwnerID;

	// Change the owner locally
	lpGroup->dwOwnerID = lpd->dwOwnerID;

	// Send a SetGroupOwner message locally
	PRV_SendGroupOwnerMessageLocally(this, lpd->dwGroupID,
		lpd->dwOwnerID, dwOldOwnerID);

ERROR_DPLP_SETGROUPOWNER:

	// Drop the locks
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_SetGroupOwner



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetPlayerName"
HRESULT DPLAPI DPLP_SetPlayerName(LPDPLOBBYSP lpILP,
					LPSPDATA_SETREMOTEPLAYERNAME lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPDPLAYI_PLAYER			lpPlayer = NULL;


	DPF(7, "Entering DPLP_SetPlayerName");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETPLAYERNAME structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// First see if the player is in our map table.  If it is not,
	// we should just ignore this message because it's for a
	// player we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwPlayerID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved SetPlayerName message for unknown player, dwPlayerID = %lu, discarding message", lpd->dwPlayerID);
		return DPERR_INVALIDPLAYER;
	}

	// Take the lock
	ENTER_DPLAY();

	// See if the player is local or remote.  If it's local, ignore this message
	// and just return DP_OK becuase we've already sent this message locally.
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwPlayerID);
	if((!lpPlayer) || (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETPLAYERNAME;
	}

	// Call dplay's internalsetname function to update the name in the cache
	hr = InternalSetName((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
			lpd->dwPlayerID, lpd->lpName, TRUE, lpd->dwFlags, FALSE);
	if(FAILED(hr))
	{
		DPF(8, "Failed to SetPlayerName internally for remote group, hr = 0x%08x", hr);
		goto ERROR_DPLP_SETPLAYERNAME;
	}

	// Send the message to all the local players
	hr = PRV_SendNameChangedMessageLocally(this, lpd->dwPlayerID, lpd->lpName, TRUE);


ERROR_DPLP_SETPLAYERNAME:

	// Drop the lock
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_SetPlayerName



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetSessionDesc"
HRESULT DPLAPI DPLP_SetSessionDesc(LPDPLOBBYSP lpILP,
						LPSPDATA_SETSESSIONDESC lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_SetSessionDesc");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETSESSIONDESC structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	LEAVE_DPLOBBY();
	return hr;

} // DPLP_SetSessionDesc



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetSPDataPointer"
HRESULT DPLAPI DPLP_SetSPDataPointer(LPDPLOBBYSP lpDPLSP, LPVOID lpData)
{
	LPDPLOBBYI_DPLOBJECT this;

	
	//	Make sure the SP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpDPLSP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// Go ahead and save the pointer
	this->lpSPData = lpData;

	return DP_OK;

} // DPLP_SetSPDataPointer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_BuildStartSessionMessage"
HRESULT PRV_BuildStartSessionMessage(LPVOID * lplpmsg, LPDWORD lpdwSize,
				LPDPLCONNECTION	lpConn, LPDPLAYI_PLAYER lpPlayer)
{
	LPMSG_STARTSESSION		lpmsg = NULL;
	DWORD					dwPackageSize;
	DWORD					dwSize;
	LPBYTE					lpTemp = NULL;
	DPNAME					dpn;
	HRESULT					hr;


	// Setup a local DPNAME struct for the player if the names exist
	if((lpPlayer->lpszShortName) || (lpPlayer->lpszLongName))
	{
		// Setup the struct
		memset(&dpn, 0, sizeof(DPNAME));
		dpn.dwSize = sizeof(DPNAME);
		dpn.lpszShortName = lpPlayer->lpszShortName;
		dpn.lpszLongName = lpPlayer->lpszLongName;
		lpConn->lpPlayerName = &dpn;
	}
	else
	{
		// Make sure the PlayerName pointer is NULL
		lpConn->lpPlayerName = NULL;
	}

	// Calculate the size of our message in Unicode
	PRV_GetDPLCONNECTIONPackageSize(lpConn, &dwPackageSize, NULL);
	dwSize = sizeof(MSG_STARTSESSION) + dwPackageSize -
				sizeof(DPLOBBYI_PACKEDCONNHEADER);

	// Allocate memory for the message
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate memory for temporary message structure");
		return DPERR_OUTOFMEMORY;
	}

	// Now build the system message
	SET_MESSAGE_HDR(lpmsg);
	SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_STARTSESSION);
	
	// Set the DPLCONNECTION pointer
	lpmsg->dwConnOffset = sizeof(MSG_STARTSESSION);
	lpTemp = (LPBYTE)lpmsg + lpmsg->dwConnOffset;

	// Copy in the package
	hr = PRV_PackageDPLCONNECTION(lpConn, lpTemp, FALSE);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to pack DPLCONNECTION struct, hr = 0x%08x", hr);
		DPMEM_FREE(lpmsg);
		return hr;
	}

	// Set the output pointers
	*lpdwSize = dwSize;
	*lplpmsg = lpmsg;

	return DP_OK;

} // PRV_BuildStartSessionMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_StartSession"
HRESULT DPLAPI DPLP_StartSession(LPDPLOBBYSP lpILP,
				LPSPDATA_STARTSESSIONCOMMAND lpd)
{
	LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLAYI_DPLAY			lpDP = NULL;
	DPLCONNECTION			conn;
	LPBYTE					lpmsg = NULL;
	HRESULT					hr = DP_OK;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	DWORD					dwMessageSize;
	LPDPLAYI_GROUPNODE		lpGroupnode = NULL;
	UINT					nPlayers;


	DPF(7, "Entering DPLP_StartSession");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_STARTSESSIONCOMMAND structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Make a local copy of the DPLCONNECTION structure since we will
	// be modifying some elements of it.  We are currently only modifying
	// elements in the DPLCONNECTION structure itself, so we can get
	// away with using it's pointers to SessionDesc and PlayerName structs,
	// but if we modify those in the future, we need to copy them as well
	memcpy(&conn, lpd->lpConn, sizeof(DPLCONNECTION));

	// Make a local variable pointer to the dplay object
	lpDP = this->lpDPlayObject;

	// Make sure we know about this group
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(8, "Received StartSessionCommand message for an unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		LEAVE_DPLOBBY();
		return DPERR_INVALIDGROUP;
	}

	// Take the dplay lock since we'll be looking at it's structures
	ENTER_DPLAY();	

	// See if the host is even in our nametable, if it isn't, we'll assume
	// we're not the host
	// See if the host is a local player, if it is, send separate messages
	if(IsLobbyIDInMapTable(this, lpd->dwHostID))
	{
		// Get dplay's player struct for the host player
		lpPlayer = PlayerFromID(lpDP, lpd->dwHostID);

		// If we know the host player (we should) and he's local, we
		// want to send the host message first
		if((lpPlayer) && (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			// So set the host bit
			conn.dwFlags |= DPLCONNECTION_CREATESESSION;

			// Build the StartSession message for the host
			hr = PRV_BuildStartSessionMessage(&lpmsg, &dwMessageSize,
						&conn, lpPlayer);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed building StartSessionCommand message, hr = 0x%08x", hr);
				goto EXIT_DPLP_STARTSESSION;
			}

			// Now send the message to the host player alone
			hr = HandlePlayerMessage(lpPlayer, (LPBYTE)lpmsg,
							dwMessageSize, FALSE, 0);
			if(FAILED(hr))
			{
				DPF(8, "Failed adding message to player's receive queue from lobby, hr = 0x%08x", hr);
			}

			// Free our message since we're done with it
			DPMEM_FREE(lpmsg);
			lpmsg = NULL;
			
			// Now fall through and send the join message to everyone else
			// in the group
		}
	}

	// We must be joining, so set the join bit, and make sure the host
	// bit isn't still set from above
	conn.dwFlags &= ~DPLCONNECTION_CREATESESSION;
	conn.dwFlags |= DPLCONNECTION_JOINSESSION;

	// Get a pointer to dplay's internal group structure
	lpGroup = GroupFromID(lpDP, lpd->dwGroupID);
	if(!lpGroup)
	{
		DPF(5, "Unable to find group in nametable, idGroup = %lu", lpd->dwGroupID);
		goto EXIT_DPLP_STARTSESSION;
	}


	// Figure out how many players we are looking for
	lpGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,lpDP->pSysPlayer->dwID);
	if (!lpGroupnode)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	nPlayers = lpGroupnode->nPlayers;

	// Walk the list of groupnodes, looking for nPlayers local players to give
	// the message to, excluding the host
	lpGroupnode = lpGroup->pGroupnodes;
	while ((nPlayers > 0) && (lpGroupnode))
	{
		if ((lpGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
			(lpGroupnode->pPlayer->dwID != lpd->dwHostID))
		{
			// Build the StartSession (join) message for this player
			hr = PRV_BuildStartSessionMessage(&lpmsg, &dwMessageSize,
						&conn, lpGroupnode->pPlayer);
			if(FAILED(hr))
			{
				DPF(5, "Failed building StartSessionCommand message, hr = 0x%08x", hr);
				goto EXIT_DPLP_STARTSESSION;
			}

			// Send the message to this player
			hr = HandlePlayerMessage(lpGroupnode->pPlayer, lpmsg,
					dwMessageSize, FALSE, 0);

			// Free our message
			if(lpmsg)
				DPMEM_FREE(lpmsg);
			lpmsg = NULL;

			nPlayers--;
		} // local & !host

		lpGroupnode = lpGroupnode->pNextGroupnode;

	} // while
	

EXIT_DPLP_STARTSESSION:

	if(lpmsg)
		DPMEM_FREE(lpmsg);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_StartSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dplunk.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplunk.c
 *  Content:	IUnknown implementation for dplobby
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	10/23/96	myronth	Added client/server methods
 *	11/08/96	myronth	Added PRV_GetDPLobbySPInterface
 *	11/20/96	myronth	Added LogoffServer call to Release code
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	New release code for DPlay3 (order different)
 *	3/13/97		myronth	Added FreeLibrary code for LP's
 *	3/17/97		myronth	Cleanup map table
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	5/8/97		myronth	Drop the lobby lock when calling the LP, Purged
 *						dead code
 *	7/30/97		myronth	Added request node cleanup for standard lobby messaging
 *	8/19/97		myronth Added PRV_GetLobbyObjectFromInterface
 *	8/19/97		myronth	Removed PRV_GetLobbyObjectFromInterface (not needed)
 *	12/2/97		myronth	Added IDirectPlayLobby3 interface
 *  2/2/99		aarono  Added lobbies to refcount on DPLAY dll to avoid
 *                      accidental unload.
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDPLobbySPInterface"
LPDPLOBBYSP PRV_GetDPLobbySPInterface(LPDPLOBBYI_DPLOBJECT this)
{
	LPDPLOBBYI_INTERFACE	lpInt;


	ASSERT(this);

	// Get an IDPLobbySP interface
	if(FAILED(PRV_GetInterface(this, &lpInt, &dplCallbacksSP)))
	{
		DPF_ERR("Unable to get non-reference counted DPLobbySP Interface pointer");
		ASSERT(FALSE);
		return NULL;
	}

	// Decrement the ref cnt on the interface
	lpInt->dwIntRefCnt--;

	// Return the interface pointer
	return (LPDPLOBBYSP)lpInt;

} // PRV_GetDPLobbySPInterface

// Find an interface with the pCallbacks vtbl on this object.
// If one doesn't exist, create it, increment the ref count,
// and return the interface
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetInterface"
HRESULT PRV_GetInterface(LPDPLOBBYI_DPLOBJECT this,
							LPDPLOBBYI_INTERFACE * ppInt,
							LPVOID lpCallbacks)
{
	LPDPLOBBYI_INTERFACE	lpCurrentInts = this->lpInterfaces;
	BOOL					bFound = FALSE;


	DPF(7, "Entering PRV_GetInterface");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, ppInt, lpCallbacks);

	ASSERT(ppInt);

	// See if there is already an interface
	while (lpCurrentInts && !bFound)
	{
		if (lpCurrentInts->lpVtbl == lpCallbacks)
		{
			bFound = TRUE;
		}
		else
			lpCurrentInts = lpCurrentInts->lpNextInterface;
	}

	// If there is one, return it
	if(bFound)
	{
		*ppInt = lpCurrentInts;
		(*ppInt)->dwIntRefCnt++;
		// we don't increment this->dwRefCnt, since it's one / interface object
		return DP_OK;
	}

	// Otherwise create one
	*ppInt = DPMEM_ALLOC(sizeof(DPLOBBYI_INTERFACE));
	if (!(*ppInt)) 
	{
		DPF_ERR("Could not alloc interface - out of memory");
		return E_OUTOFMEMORY;
	}

	(*ppInt)->dwIntRefCnt = 1;
	(*ppInt)->lpDPLobby = this;
	(*ppInt)->lpNextInterface = this->lpInterfaces;
	(*ppInt)->lpVtbl = lpCallbacks;

	this->lpInterfaces = *ppInt;
	this->dwRefCnt++;				// One time only for each interface object
	return DP_OK;
	
} // PRV_GetInterface


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_QueryInterface"
HRESULT DPLAPI DPL_QueryInterface(LPDIRECTPLAYLOBBY lpDPL, REFIID riid, LPVOID * ppvObj) 
{
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr;


	DPF(7, "Entering DPL_QueryInterface");
	DPF(9, "Parameters: 0x%08x, refiid, 0x%08x", lpDPL, ppvObj);

    ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		if ( !VALID_READ_UUID_PTR(riid) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}
		
		if ((!VALID_UUID_PTR(ppvObj)) )
		{
			LEAVE_DPLOBBY();
			DPF_ERR("Object pointer is invalid!");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLOBBY();
        return DPERR_INVALIDPARAMS;
    }

     *ppvObj=NULL;
        
    if( IsEqualIID(riid, &IID_IUnknown) || 
        IsEqualIID(riid, &IID_IDirectPlayLobby) )
    {
		// Get an IDirectPlayLobby Interface (Unicode)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobbyA) )
	{
		// Get an IDirectPlayLobbyA Interface (ANSI)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacksA);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby2) )
    {
		// Get an IDirectPlayLobby2 Interface (Unicode)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks2);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby2A) )
	{
		// Get an IDirectPlayLobby2A Interface (ANSI)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks2A);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby3) )
    {
		// Get an IDirectPlayLobby3 Interface (Unicode)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks3);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby3A) )
	{
		// Get an IDirectPlayLobby3A Interface (ANSI)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks3A);
	}
	else 
	{
	    hr =  E_NOINTERFACE;		
	}
        
    LEAVE_DPLOBBY();
    return hr;

} //DPL_QueryInterface


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_AddRef"
ULONG DPLAPI DPL_AddRef(LPDIRECTPLAYLOBBY lpDPL) 
{
	LPDPLOBBYI_INTERFACE lpInt = (LPDPLOBBYI_INTERFACE)lpDPL;    
    LPDPLOBBYI_DPLOBJECT this;


	DPF(7, "Entering DPL_AddRef");
	DPF(9, "Parameters: 0x%08x", lpDPL);

    ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return 0;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLOBBY();
        return 0;
    }


	// Make sure someone isn't calling AddRef on our IDPLobbySP interface
	if(lpInt->lpVtbl == &dplCallbacksSP)
	{
		DPF_ERR("You cannot call AddRef on an IDPLobbySP interface");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return 0;
	}

	// Increment the interface's reference count
    lpInt->dwIntRefCnt++;
        
    LEAVE_DPLOBBY();
    return (lpInt->dwIntRefCnt);

} //DPL_AddRef


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyDPLobby"
HRESULT PRV_DestroyDPLobby(LPDPLOBBYI_DPLOBJECT this) 
{
	HRESULT				hr = DP_OK;


	DPF(7, "Entering PRV_DestroyDPLobby");
	DPF(9, "Parameters: 0x%08x", this);

	// Since we can now be called from the DPlay3 object's Release code,
	// make sure we don't have any interface objects when we go to
	// free our lobby object.  Assert here if any interfaces exist.
	ASSERT(!this->lpInterfaces);

	// Walk the list of GameNodes, freeing them as you go
	while(this->lpgnHead)
		PRV_RemoveGameNodeFromList(this->lpgnHead);

	// Walk the list of pending lobby server requests and free them
	while(this->lprnHead)
		PRV_RemoveRequestNode(this, this->lprnHead);

	// Free our callback table if one exists
	if(this->pcbSPCallbacks)
		DPMEM_FREE(this->pcbSPCallbacks);

	// Free our ID Map Table if it exists
	if(this->lpMap)
		DPMEM_FREE(this->lpMap);

	// Free the dplobby object
	DPMEM_FREE(this);	

	gnObjects--;

	ASSERT(((int)gnObjects) >= 0);

	return DP_OK;

} // PRV_DestroyDPlayLobby


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyDPLobbyInterface"
HRESULT  PRV_DestroyDPLobbyInterface(LPDPLOBBYI_DPLOBJECT this,
								LPDPLOBBYI_INTERFACE lpInterface)
{
	LPDPLOBBYI_INTERFACE	lpIntPrev; // The interface preceeding pInt in the list
	BOOL					bFound = FALSE;


	DPF(7, "Entering PRV_DestroyDPLobbyInterface");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpInterface);

	// Remove pInt from the list of interfaces
	if (this->lpInterfaces == lpInterface)
	{
		// It's the 1st one, just remove it
		this->lpInterfaces = lpInterface->lpNextInterface;
	}
	else 
	{
		lpIntPrev = this->lpInterfaces;
		while (lpIntPrev && !bFound)
		{
			if (lpIntPrev->lpNextInterface == lpInterface)
			{
				bFound = TRUE;
			}
			else lpIntPrev = lpIntPrev->lpNextInterface;
		}
		if (!bFound)
		{
			ASSERT(FALSE);
			return E_UNEXPECTED;
		}
		// take pint out of the list
		lpIntPrev->lpNextInterface = lpInterface->lpNextInterface;
		
	}

	DPMEM_FREE(lpInterface);
	return DP_OK;

} // PRV_DestroyDPLobbyInterface


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Release"
ULONG PRV_Release(LPDPLOBBYI_DPLOBJECT this, LPDPLOBBYI_INTERFACE lpInterface)
{
	HRESULT				hr = DP_OK;
	SPDATA_SHUTDOWN		sdd;
	DWORD				dwError;


	DPF(7, "==> PRV_Release");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpInterface);

	ENTER_DPLOBBY();

	// Decrement the interface ref count
	if (0 == --(lpInterface->dwIntRefCnt))
	{
		LPDPLOBBYI_GAMENODE lpgn;
		// Notifying apps we launched that we are releasing
		// our lobby interface.
		lpgn=this->lpgnHead;
		while(lpgn){
			if(lpgn->dwFlags & GN_LOBBY_CLIENT) {
				hr=PRV_SendStandardSystemMessage((LPDIRECTPLAYLOBBY)lpInterface, DPLSYS_LOBBYCLIENTRELEASE, lpgn->dwGameProcessID);
				if(DP_OK != hr){
					DPF(0,"Couldn't send system message to game pid %x, hr=%x",lpgn->dwGameProcessID,hr);
				} else {
					DPF(9,"Told Process %x we are releasing the lobby interface",lpgn->dwGameProcessID);
				}
			}	
			lpgn=lpgn->lpgnNext;
		}	

		DPF(7,"Lobby interface Refcount hit 0, freeing\n");
		// Since we're destroying an interface, dec the object count
	    this->dwRefCnt--;
		
		// If our object ref cnt just went to zero, we need to call
		// shutdown in the LP if one is loaded
		if(this->dwFlags & DPLOBBYPR_SPINTERFACE)
		{
			// Clear our stack-based structure
			memset(&sdd, 0, sizeof(SPDATA_SHUTDOWN));

			// Call the Shutdown method in the SP
			if(CALLBACK_EXISTS(Shutdown))
			{
				sdd.lpISP = PRV_GetDPLobbySPInterface(this);

				// Drop the lock so the lobby provider's receive thread can get back
				// in with other messages if they show up in the queue before our
				// CreatePlayer response (which always happens)
				LEAVE_DPLOBBY();
				hr = CALL_LP(this, Shutdown, &sdd);
				ENTER_DPLOBBY();
			}
			else 
			{
				// All LP's should support Shutdown
				ASSERT(FALSE);
				hr = DPERR_UNAVAILABLE;
			}
			
			if (FAILED(hr)) 
			{
				DPF_ERR("Could not invoke Shutdown method in the Service Provider");
			}
		}

		// REVIEW!!!! -- Are we going to have the same problem dplay has
		// with SP's hanging around and crashing after we go away?  We
		// need to make sure the LP goes away first.
		if(this->hInstanceLP)
		{
			DPF(7,"About to free lobby provider library, hInstance %x\n",this->hInstanceLP);
			if (!FreeLibrary(this->hInstanceLP))
			{
				dwError = GetLastError();
				DPF_ERRVAL("Unable to free Lobby Provider DLL, dwError = %lu", dwError);
				ASSERT(FALSE);
			}

			// Just to be safe
			this->hInstanceLP = NULL;
		}

		// If the interface is the IDPLobbySP interface, we had to have been
		// called from the DPlay3 release code, so clear the SP flag since
		// we are going to remove the IDPLobbySP interface just below here.
		this->dwFlags &= ~DPLOBBYPR_SPINTERFACE;

		// Take the interface out of the table
		hr = PRV_DestroyDPLobbyInterface(this, lpInterface);
		if (FAILED(hr)) 
		{
			DPF(0,"Could not destroy DPLobby interface! hr = 0x%08lx\n", hr);
			ASSERT(FALSE);
		}

		// Now destroy the interface if the ref cnt is 0
		if(0 == this->dwRefCnt)
	    {
			// Destroy the DPLobby object
			DPF(0,"Destroying DirectPlayLobby object - ref cnt = 0!");
			hr = PRV_DestroyDPLobby(this);
			if (FAILED(hr)) 
			{
				DPF(0,"Could not destroy DPLobby! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
			}
	    
		} // 0 == this->dwRefCnt
		
		LEAVE_DPLOBBY();
		return 0;

	} //0 == pInt->dwIntRefCnt 

	DPF(7, "<==PRV_Release, rc=%d\n",lpInterface->dwIntRefCnt);
   	
    LEAVE_DPLOBBY();
    return (lpInterface->dwIntRefCnt);
} // PRV_Release
		


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Release"
ULONG DPLAPI DPL_Release(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_INTERFACE	lpInterface;
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_Release");
	DPF(9, "Parameters: 0x%08x", lpDPL);

    TRY
    {
		lpInterface = (LPDPLOBBYI_INTERFACE)lpDPL;
		if( !VALID_DPLOBBY_INTERFACE( lpInterface ))
		{
			return 0;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return 0;
    }


	// Make sure someone isn't calling Release on our IDPLobbySP interface
	if(lpInterface->lpVtbl == &dplCallbacksSP)
	{
		DPF_ERR("You cannot call Release on an IDPLobbySP interface");
		ASSERT(FALSE);
		return 0;
	}

	// Call our internal release function
	return PRV_Release(this, lpInterface);

} //DPL_Release



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeAllLobbyObjects"
void PRV_FreeAllLobbyObjects(LPDPLOBBYI_DPLOBJECT this)
{

	DPF(7, "Entering PRV_FreeAllLobbyObjects");
	DPF(9, "Parameters: 0x%08x", this);

	ASSERT(this);

	// If we have an SP interface, just call release on it
	if(this->dwFlags & DPLOBBYPR_SPINTERFACE)
	{
		// Assert if an interface doesn't exist, because it should
		ASSERT(this->lpInterfaces);
		PRV_Release(this, this->lpInterfaces);
		return;
	}

	// Otherwise, we should only have an uninitialized object,
	// which we should just be able to destroy
	PRV_DestroyDPLobby(this);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\dpneed.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpneed.h
 *  Content:	Private definitions needed by DPlay to build
 *
 *  History:
 *	Date	By		Reason
 *	======	=======	======
 *	6/16/96	myronth	Created it
 *	11/5/97	myronth	Added LOBBY_ALL macros
 ***************************************************************************/
#ifndef __DPNEED_INCLUDED__
#define __DPNEED_INCLUDED__

#define INIT_DPLOBBY_CSECT() InitializeCriticalSection(gpcsDPLCritSection);
#define FINI_DPLOBBY_CSECT() DeleteCriticalSection(gpcsDPLCritSection);
#define ENTER_DPLOBBY() EnterCriticalSection(gpcsDPLCritSection);
#define LEAVE_DPLOBBY() LeaveCriticalSection(gpcsDPLCritSection);

#define ENTER_LOBBY_ALL() ENTER_DPLAY(); ENTER_DPLOBBY();
#define LEAVE_LOBBY_ALL() LEAVE_DPLOBBY(); LEAVE_DPLAY();

#define INIT_DPLQUEUE_CSECT() InitializeCriticalSection(gpcsDPLQueueCritSection);
#define FINI_DPLQUEUE_CSECT() DeleteCriticalSection(gpcsDPLQueueCritSection);
#define ENTER_DPLQUEUE() EnterCriticalSection(gpcsDPLQueueCritSection);
#define LEAVE_DPLQUEUE() LeaveCriticalSection(gpcsDPLQueueCritSection);

#define INIT_DPLGAMENODE_CSECT() InitializeCriticalSection(gpcsDPLGameNodeCritSection);
#define FINI_DPLGAMENODE_CSECT() DeleteCriticalSection(gpcsDPLGameNodeCritSection);
#define ENTER_DPLGAMENODE() EnterCriticalSection(gpcsDPLGameNodeCritSection);
#define LEAVE_DPLGAMENODE() LeaveCriticalSection(gpcsDPLGameNodeCritSection);

#endif // __DPNEED_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\group.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       group.c
 *  Content:	Methods for managing groups
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	2/27/97		myronth	Created it
 *	3/17/97		myronth	Create/DestroyGroup, Removed unnecessary Enum functions
 *	3/20/97		myronth	AddPlayerToGroup, DeletePlayerFromGroup
 *	3/21/97		myronth	SetGroupName, Get/SetGroupData
 *	3/31/97		myronth	Removed dead code, Added CreateAndMapNewGroup function
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	5/6/97		kipo	GetGroup() now takes a parent ID
 *	5/8/97		myronth	Subgroup support, GroupConnSettings, StartSession,
 *						and drop the lobby lock when calling the LP
 *	5/12/97		myronth	Handle remote groups properly
 *	5/17/97		myronth	Added parent ID to CreateAndMapNewGroup calls, 
 *						Added send message code for DestroyGroup and
 *						DeletePlayerFromGroup on the local machine
 *	5/20/97		myronth	Send Delete & DestroyPlayer messages for remote
 *						players when a local player leaves a group (#8586)
 *						Made AddPlayerToGroup & DeletePlayerFromGroup return
 *						DPERR_ACCESSDENIED on remote players (#8679),
 *						Fixed a bunch of other lock bugs, Changed debug levels
 *	5/21/97		myronth	Pass CreateGroup flags through the lobby (#8813)
 *	5/22/97		myronth	Added functions to destroy remote subgroups when
 *						a local player leaves a group (#8810)
 *	5/23/97		myronth	Send messages locally for CreateGroup and
 *						CreateGroupInGroup (#8870)
 *	6/3/97		myronth	Added PRV_DestroySubgroups function (#9134) and
 *						rearranged some of the DestroyGroup code
 *	6/5/97		myronth	Added shortcut checking to PRV_DestroySubgroups by
 *						adding the PRV_AreSubgroupsShortcuts function
 *	6/6/97		myronth	Added PRV_DestroyGroupAndParents and PRV_Destroy-
 *						ShortcutsForExitingPlayer, cleaned up PRV_Delete-
 *						PlayerFromGroup, Fixed StartSession bugs (#9573,#9574)
 *	6/9/97		myronth	Only delete shortcuts (don't destroy the subgoup)
 *						in the PRV_DestroySubgroups function
 *	6/16/97		myronth	Fixed bad deletion of uncle groups & some subgroups
 *						during DeletePlayerFromGroup (#9655)
 *	6/20/97		myronth	Send AddGroupToGroup message locally to avoid
 *						sending duplicate messages.  Also added code to
 *						send local DeleteGroupFromGroup messages (#10139)
 *	6/24/97		myronth	Send AddPlayerToGroup message locally to avoid
 *						sending duplicate messages (#10287)
 *	8/22/97		myronth	Force guidInstance to NULL in SetGroupConnectionSettings
 *	9/29/97		myronth	Send local SetGroupName/Data msgs after call to
 *						lobby server succeeds (#12554)
 *	10/23/97	myronth	Added hidden group support (#12688), fixed crashing
 *						bug on DeletePlayerFromGroup (#12885)
 *	10/29/97	myronth	Added support for group owners, including
 *						DPL_SetGroupOwner and DPL_GetGroupOwner
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddGroupToGroup"
HRESULT DPLAPI PRV_AddGroupToGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwParentID,
					DWORD dwGroupID)
{
	SPDATA_ADDGROUPTOGROUP		ad;
	MSG_PLAYERMGMTMESSAGE		msg;
	LPDPLAYI_GROUP				lpGroupTo = NULL;
	HRESULT						hr = DP_OK;


	DPF(7, "Entering DPL_AddGroupToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwParentID, dwGroupID);


    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }

	
	// Setup our SPDATA struct
	memset(&ad, 0, sizeof(SPDATA_ADDGROUPTOGROUP));
	ad.dwSize = sizeof(SPDATA_ADDGROUPTOGROUP);
	ad.dwParentID = dwParentID;
	ad.dwGroupID = dwGroupID;

	// Call the AddGroupToGroup method in the SP
	if(CALLBACK_EXISTS(AddGroupToGroup))
	{
		ad.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, AddGroupToGroup, &ad);
		ENTER_DPLOBBY();
	}
	else 
	{
		// AddGroupToGroup is required
		DPF_ERR("The Lobby Provider callback for AddGroupToGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_ADDGROUPTOGROUP;
	}

	// If it succeeded, send the AddGroupToGroup message to our local players
	if(SUCCEEDED(hr))
	{
		// Take the dplay lock
		ENTER_DPLAY();
		
		// Find dplay's internal group struct for the To group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_DPLAY();
			DPF_ERR("Unable to find group in nametable");
			hr = DPERR_INVALIDGROUP;
			goto EXIT_ADDGROUPTOGROUP;
		}

		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDSHORTCUTTOGROUP);
		msg.dwPlayerID = dwGroupID;
		msg.dwGroupID = dwParentID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding AddGroupToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}

		// Drop the dplay lock
		LEAVE_DPLAY();
	}
	else
	{
		DPF_ERRVAL("Failed calling AddGroupToGroup in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_ADDGROUPTOGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_AddGroupToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddPlayerToGroup"
HRESULT DPLAPI PRV_AddPlayerToGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					DWORD dwPlayerID)
{
	SPDATA_ADDPLAYERTOGROUP		ad;
	LPDPLAYI_PLAYER				lpPlayer = NULL;
	MSG_PLAYERMGMTMESSAGE		msg;
	LPDPLAYI_GROUP				lpGroupTo = NULL;
	LPDPLAYI_GROUP				lpGroup = NULL;
	HRESULT						hr = DP_OK;


	DPF(7, "Entering DPL_AddPlayerToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwGroupID, dwPlayerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }

	
	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_ADDPLAYERTOGROUP;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_ADDPLAYERTOGROUP;
	}
	
	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&ad, 0, sizeof(SPDATA_ADDPLAYERTOGROUP));
	ad.dwSize = sizeof(SPDATA_ADDPLAYERTOGROUP);
	ad.dwGroupID = dwGroupID;
	ad.dwPlayerID = dwPlayerID;

	// Call the AddPlayerToGroup method in the SP
	if(CALLBACK_EXISTS(AddPlayerToGroup))
	{
		ad.lpISP = PRV_GetDPLobbySPInterface(this);
		
		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
		hr = CALL_LP(this, AddPlayerToGroup, &ad);
		ENTER_DPLOBBY();
	}
	else 
	{
		// AddPlayerToGroup is required
		DPF_ERR("The Lobby Provider callback for AddPlayerToGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_ADDPLAYERTOGROUP;
	}

	// If it succeeded, send the AddPlayerToGroup message to our local players
	if(SUCCEEDED(hr))
	{
		// Take the dplay lock
		ENTER_DPLAY();
		
		// Find dplay's internal group struct for the To group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_DPLAY();
			DPF_ERR("Unable to find group in nametable");
			hr = DPERR_INVALIDGROUP;
			goto EXIT_ADDPLAYERTOGROUP;
		}

		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDPLAYERTOGROUP);
		msg.dwPlayerID = dwPlayerID;
		msg.dwGroupID = dwGroupID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding AddPlayerToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
		else
		{
			// We need to see if this player is the group owner.  If it is,
			// we need to send a SetGroupOwner message as well.
			lpGroup = GroupFromID(this->lpDPlayObject, dwGroupID);
			if(lpGroup && (dwPlayerID == lpGroup->dwOwnerID))
			{
				// Now send the message
				PRV_SendGroupOwnerMessageLocally(this, dwGroupID, dwPlayerID, 0);
			}
		 }


		// Drop the dplay lock
		LEAVE_DPLAY();
	}
	else
	{
		DPF_ERRVAL("Failed calling AddPlayerToGroup in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_ADDPLAYERTOGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_AddPlayerToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateGroup"
HRESULT DPLAPI PRV_CreateGroup(LPDPLOBBYI_DPLOBJECT this, LPDPID lpidGroup,
			LPDPNAME lpName, LPVOID lpData, DWORD dwDataSize, DWORD dwFlags,
			DWORD dwOwnerID)
{
	SPDATA_CREATEGROUP		cg;
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	DWORD					dwInternalFlags;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_CreateGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			this, lpidGroup, lpName, lpData, dwDataSize, dwFlags, dwOwnerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&cg, 0, sizeof(SPDATA_CREATEGROUP));
	cg.dwSize = sizeof(SPDATA_CREATEGROUP);
	cg.lpName = lpName;
	cg.lpData = lpData;
	cg.dwDataSize = dwDataSize;
	cg.dwFlags = dwFlags;
	cg.dwGroupOwnerID = dwOwnerID;

	// Call the CreateGroup method in the SP
	if(CALLBACK_EXISTS(CreateGroup))
	{
		cg.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, CreateGroup, &cg);
		ENTER_DPLOBBY();
	}
	else 
	{
		// CreateGroup is required
		DPF_ERR("The Lobby Provider callback for CreateGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling CreateGroup in the Lobby Provider, hr = 0x%08x", hr);
		goto EXIT_CREATEGROUP;
	}

	// Setup the flags to pass to GetGroup
	dwInternalFlags = DPLAYI_PLAYER_PLAYERLOCAL;
	if(dwFlags & DPGROUP_STAGINGAREA)
		dwInternalFlags |= DPLAYI_GROUP_STAGINGAREA;
	if(dwFlags & DPGROUP_HIDDEN)
		dwInternalFlags |= DPLAYI_GROUP_HIDDEN;

	// Add the player to dplay's nametable and put it in our map table
	hr = PRV_CreateAndMapNewGroup(this, lpidGroup, lpName, lpData,
			dwDataSize, dwInternalFlags, cg.dwGroupID, 0, dwOwnerID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed creating a new local group, hr = 0x%08x", hr);
		// REVIEW!!!! -- We need to send a message back to the server saying
		// we couldn't complete the deal on our end.
		goto EXIT_CREATEGROUP;
	}

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = *lpidGroup;

	// Take the lock
	ENTER_DPLAY();

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		LEAVE_DPLAY();
		DPF_ERRVAL("Unable to find system group in nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message in
	// the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo, (LPBYTE)&msg,
			sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(2, "Failed adding CreateGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	LEAVE_DPLAY();

EXIT_CREATEGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_CreateGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateGroupInGroup"
HRESULT DPLAPI PRV_CreateGroupInGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwParentID,
			LPDPID lpidGroup, LPDPNAME lpName, LPVOID lpData, DWORD dwDataSize,
			DWORD dwFlags, DWORD dwOwnerID)
{
	SPDATA_CREATEGROUPINGROUP	cgig;
	MSG_PLAYERMGMTMESSAGE		msg;
	LPDPLAYI_GROUPNODE			lpGroupnode = NULL;
	LPDPLAYI_GROUP				lpGroupTo = NULL;
	HRESULT						hr = DP_OK;
	DWORD						dwInternalFlags;


	DPF(7, "Entering PRV_CreateGroupInGroup");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwParentID, lpidGroup, lpName, lpData, dwDataSize, dwFlags, dwOwnerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&cgig, 0, sizeof(SPDATA_CREATEGROUPINGROUP));
	cgig.dwSize = sizeof(SPDATA_CREATEGROUPINGROUP);
	cgig.dwParentID = dwParentID;
	cgig.lpName = lpName;
	cgig.lpData = lpData;
	cgig.dwDataSize = dwDataSize;
	cgig.dwFlags = dwFlags;
	cgig.dwGroupOwnerID = dwOwnerID;

	// Call the CreateGroupInGroup method in the SP
	if(CALLBACK_EXISTS(CreateGroupInGroup))
	{
		cgig.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, CreateGroupInGroup, &cgig);
		ENTER_DPLOBBY();
	}
	else 
	{
		// CreateGroupInGroup is required
		DPF_ERR("The Lobby Provider callback for CreateGroupInGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling CreateGroupInGroup in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}


	// Setup the flags to pass to GetGroup
	dwInternalFlags = DPLAYI_PLAYER_PLAYERLOCAL;
	if(dwFlags & DPGROUP_STAGINGAREA)
		dwInternalFlags |= DPLAYI_GROUP_STAGINGAREA;
	if(dwFlags & DPGROUP_HIDDEN)
		dwInternalFlags |= DPLAYI_GROUP_HIDDEN;


	// Add the group to dplay's nametable and put it in our map table
	hr = PRV_CreateAndMapNewGroup(this, lpidGroup, lpName, lpData,
			dwDataSize, dwInternalFlags, cgig.dwGroupID, dwParentID, dwOwnerID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed creating a new local group, hr = 0x%08x", hr);
		// REVIEW!!!! -- We need to send a message back to the server saying
		// we couldn't complete the deal on our end.
		goto EXIT_CREATEGROUPINGROUP;
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = *lpidGroup;

	// Find dplay's internal group struct for the To group
	// Since this is local, send it to all players
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		LEAVE_DPLAY();
		DPF_ERRVAL("Unable to find parent group in nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEGROUPINGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(2, "Failed adding CreateGroupInGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	// Drop the dplay lock
	LEAVE_DPLAY();


EXIT_CREATEGROUPINGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_CreateGroupInGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteGroupFromGroup"
HRESULT DPLAPI PRV_DeleteGroupFromGroup(LPDPLOBBYI_DPLOBJECT this,
					DWORD dwParentID, DWORD dwGroupID)
{
	SPDATA_DELETEGROUPFROMGROUP		dgd;
	MSG_PLAYERMGMTMESSAGE			msg;
	LPDPLAYI_GROUP					lpGroupTo = NULL;
	HRESULT							hr = DP_OK;


	DPF(7, "Entering DPL_DeleteGroupFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwParentID, dwGroupID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&dgd, 0, sizeof(SPDATA_DELETEGROUPFROMGROUP));
	dgd.dwSize = sizeof(SPDATA_DELETEGROUPFROMGROUP);
	dgd.dwParentID = dwParentID;
	dgd.dwGroupID = dwGroupID;

	// Call the DeleteGroupFromGroup method in the SP
	if(CALLBACK_EXISTS(DeleteGroupFromGroup))
	{
		dgd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DeleteGroupFromGroup, &dgd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DeleteGroupFromGroup is required
		DPF_ERR("The Lobby Provider callback for DeleteGroupFromGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	// If it succeeded, send the DeleteGroupFromGroup message to all local players
	if(SUCCEEDED(hr))
	{
		// Take the dplay lock
		ENTER_DPLAY();

		// Get a pointer to dplay's system group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_LOBBY_ALL();
			DPF_ERR("Unable to find system group in nametable, not sending DeleteGroupFromGroup message");
			return DPERR_INVALIDGROUP;
		}

		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUPFROMGROUP);
		msg.dwPlayerID = dwGroupID;
		msg.dwGroupID = dwParentID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DeleteGroupFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}

		// Drop the dplay lock
		LEAVE_DPLAY();
	}
	else
	{
		DPF_ERRVAL("Failed calling DeleteGroupFromGroup in the Lobby Provider, hr = 0x%08x", hr);
	}

	// The dplay InternalDeletePlayerFromGroup code will take care of the rest of
	// the internal cleanup (nametable, players, etc.), so we can just return
	// from here.

	LEAVE_DPLOBBY();
	return hr;

} // PRV_DeleteGroupFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DoSubgroupsContainLocalPlayers"
BOOL PRV_DoSubgroupsContainLocalPlayers(LPDPLAYI_GROUP lpGroup,
		BOOL bIncludeGroup)
{
	LPDPLAYI_GROUPNODE		lpGroupnode = NULL;
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;


	DPF(7, "Entering PRV_DoSubgroupsContainLocalPlayers");
	DPF(9, "Parameters: 0x%08x, %lu", lpGroup, bIncludeGroup);

	ASSERT(lpGroup);

	// Figure out how many local players are in this group.  If it's
	// nonzero, just return true from this function.  If the bIncludeGroup
	// parameter is set to FALSE, then don't look at the group passed in
	lpGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,
					lpGroup->lpDP->pSysPlayer->dwID);
	if(lpGroupnode && (lpGroupnode->nPlayers > 0) && bIncludeGroup)
		return TRUE;	

	// Walk the list of subgroups
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// We're going recursive here to do the entire heirarchy
		// Check out any of it's subgroups
		if((!(lpSubgroup->dwFlags & DPGROUP_SHORTCUT)) &&
			(PRV_DoSubgroupsContainLocalPlayers(lpSubgroup->pGroup, TRUE)))
			return TRUE;
		else
			lpSubgroup = lpSubgroup->pNextSubgroup;
		
	} // while subgroups

	return FALSE;

} // PRV_DoSubgroupsContainLocalPlayers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AreSubgroupsShortcuts"
BOOL PRV_AreSubgroupsShortcuts(LPDPLAYI_GROUP lpGroup)
{
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;


	DPF(7, "Entering PRV_AreSubgroupsShortcuts");
	DPF(9, "Parameters: 0x%08x", lpGroup);

	ASSERT(lpGroup);

	// If the group is one of the following, then we want to return TRUE so
	// it doesn't get nuked:
	// 1) Root group, nGroups > 0
	// 2) Root group, hidden, nGroups = 0
	// 2) Non-root group, nGroups > 1
	// Otherwise, we can check it's subgroups and return FALSE as appropriate
	if(((lpGroup->dwIDParent == 0) && ((lpGroup->nGroups > 0) ||
		(!(lpGroup->dwFlags & DPLAYI_GROUP_HIDDEN)) && (lpGroup->nGroups == 0))) ||
		((lpGroup->dwIDParent != 0) && (lpGroup->nGroups > 1)))
		return TRUE;	

	// Walk the list of subgroups
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// We're going recursive here to do the entire heirarchy
		// Check out any of it's subgroups
		if(PRV_AreSubgroupsShortcuts(lpSubgroup->pGroup))
			return TRUE;
		else
			lpSubgroup = lpSubgroup->pNextSubgroup;
		
	} // while subgroups

	return FALSE;

} // PRV_AreSubgroupsShortcuts



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyGroupAndParents"
void PRV_DestroyGroupAndParents(LPDPLOBBYI_DPLOBJECT this,
		LPDPLAYI_GROUP lpGroup, LPDPLAYI_GROUP lpStopParent)
{
	LPDPLAYI_GROUPNODE			lpGroupnode = NULL;
	LPDPLAYI_GROUP				lpParentGroup = NULL;
	SPDATA_DESTROYREMOTEGROUP	dg;
	DPID						dpidParent;
	HRESULT						hr;


	DPF(7, "Entering PRV_DestroyGroupAndParents");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, lpGroup, lpStopParent);

	ASSERT(lpGroup);

	// Now we need to decide if this is the last group this group was in.  If
	// it is, then we need to destroy the group as well, and remove them from
	// our map table.  Of course, only destroy the group if it is a remote group.
	// ALSO, we need to walk the heirarchy backward (up the tree) to the root
	// node and delete all groups that were only created to get to our shortcut.
	if(!(lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Walk our parental heirarchy until we reach a a root group.
		dpidParent = lpGroup->dwIDParent;
		while(dpidParent)
		{
			// Get dplay's internal group structures
			lpParentGroup = GroupFromID(this->lpDPlayObject, dpidParent);
			if(!lpParentGroup)
			{
				ASSERT(FALSE);
				DPF_ERRVAL("Unable to find group in nametable, dpidGroup = %lu", dpidParent);
				return;
			}

			// If there are any local players in the parent group, we don't want to
			// destroy it or any of it's subgroups (since players in the group will
			// be able to see subgroups)
			lpGroupnode = FindPlayerInGroupList(lpParentGroup->pSysPlayerGroupnodes,
					this->lpDPlayObject->pSysPlayer->dwID);
			if((lpGroupnode) && (lpGroupnode->nPlayers > 0))
				return;

			// Make sure we haven't reached our stop parent group if the caller
			// passed one in.  This will keep us from recursively destroying
			// a subgroup's parent, which we might be spinning on, deleting all
			// of it's subgroups.
			if(lpStopParent && (lpStopParent == lpParentGroup))
				return;

			// Destroy the subgroups
			PRV_DestroySubgroups(this, lpParentGroup, TRUE);

			// Get the next parent
			dpidParent = lpParentGroup->dwIDParent;
		}

		// See if we processed any parents, or if we already have a root
		// group.  If lpParentGroup is NULL, we have a root group, so just
		// stuff our group pointer in the parent group pointer
		if(!lpParentGroup)
			lpParentGroup = lpGroup;
		
		// Now see if our root group is hidden, and if it doesn't contain any
		// references, then we want to destroy it as well.
		if((!PRV_DoSubgroupsContainLocalPlayers(lpParentGroup, TRUE)) &&
			(!PRV_AreSubgroupsShortcuts(lpParentGroup)) &&
			(lpParentGroup->dwFlags & DPLAYI_GROUP_HIDDEN))
		{
			// Setup the SPDATA struct for DestroyRemoteGroup
			memset(&dg, 0, sizeof(SPDATA_DESTROYREMOTEGROUP));
			dg.dwSize = sizeof(SPDATA_DESTROYREMOTEGROUP);
			dg.dwGroupID = lpParentGroup->dwID;

			// Call our internal remote create
			hr = DPLP_DestroyGroup((LPDPLOBBYSP)this->lpInterfaces, &dg);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed destroying remote root group, hr = 0x%08x", hr);
			}
		}
	}

} // PRV_DestroyGroupAndParents



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyRemoteShortcutsForExitingPlayer"
void PRV_DestroyRemoteShortcutsForExitingPlayer(LPDPLOBBYI_DPLOBJECT this,
				LPDPLAYI_GROUP lpGroup, DWORD dwGroupID)
{
	SPDATA_DELETEREMOTEGROUPFROMGROUP	drgd;
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;
	LPDPLAYI_SUBGROUP		lpNextSubgroup = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_DestroyRemoteShortcutsForExitingPlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", this, lpGroup, dwGroupID);

	ASSERT(lpGroup);

	// Setup the SPDATA_DELETEREMOTEPLAYERFROMGROUP data struct
	memset(&drgd, 0, sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP));
	drgd.dwSize = sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP);
	drgd.dwParentID = dwGroupID;

	// Walk the list of subgroups, destroying all remote shortcuts
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// Save the next subgroup
		lpNextSubgroup = lpSubgroup->pNextSubgroup;

		// Make sure the group is remote and that this is really
		// a shortcut and not a child
		if(((lpSubgroup->dwFlags & DPGROUP_SHORTCUT)) &&
			(!(lpSubgroup->pGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)))
		{
			// Get the subgroup's lobby ID
			drgd.dwGroupID = lpSubgroup->pGroup->dwID;
			
			// Call our internal DeleteGroupFromGroup routine to delete
			// the shortcut and send the appropriate messages
			// NOTE: It is imperative that we pass in a pointer to the
			// group who's shortcuts we are removing as the stop parent.
			// If we do not, we run the risk of deleting it or one of
			// it's children that we haven't yet looped through, which
			// will result in a crash as we continue to walk the
			// subgroup list.
			hr = PRV_DeleteRemoteGroupFromGroup(this, &drgd, TRUE, lpGroup);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed deleting remote group from group, hr = 0x%08x", hr);
			}
		}


		// Go to the next one
		lpSubgroup = lpNextSubgroup;
	}

} // PRV_DestroyRemoteShortcutsForExitingPlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyRemotePlayersForExitingPlayer"
void PRV_DestroyRemotePlayersForExitingPlayer(LPDPLOBBYI_DPLOBJECT this,
				LPDPLAYI_GROUP lpGroup, DWORD dwGroupID)
{
	SPDATA_DELETEREMOTEPLAYERFROMGROUP	drpd;
	LPDPLAYI_GROUPNODE					lpGroupnode = NULL;
	LPDPLAYI_GROUPNODE					lpNextGroupnode = NULL;
	HRESULT								hr;


	DPF(7, "Entering PRV_DestroyRemotePlayersForExitingPlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpGroup);

	ASSERT(lpGroup);

	// Setup the SPDATA_DELETEREMOTEPLAYERFROMGROUP data struct
	memset(&drpd, 0, sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP));
	drpd.dwSize = sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP);
	drpd.dwGroupID = dwGroupID;
	
	// Walk the list of groupnodes, deleting remote players that are not in
	// any other groups
	lpGroupnode = lpGroup->pGroupnodes;
	while(lpGroupnode)
	{
		// Save our next groupnode pointer since our current groupnode
		// will be gone when we come back from the delete
		lpNextGroupnode = lpGroupnode->pNextGroupnode;

		// Delete the player from the group if it's remote and then
		// destroy the player if he is in no other groups
		if (!(lpGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			// Get the remote player's ID
			drpd.dwPlayerID = lpGroupnode->pPlayer->dwID;

			// Delete the player from the group
			hr = PRV_DeleteRemotePlayerFromGroup(this, &drpd, TRUE);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed deleting remote player from group, hr = 0x%08x", hr);
			}
		}

		lpGroupnode = lpNextGroupnode;

	} // while

} // PRV_DestroyRemotePlayersForExitingPlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroySubgroups"
void PRV_DestroySubgroups(LPDPLOBBYI_DPLOBJECT this, LPDPLAYI_GROUP lpGroup,
		BOOL bRemoteOnly)
{
	LPDPLAYI_SUBGROUP			lpSubgroup = NULL;
	LPDPLAYI_SUBGROUP			lpNextSubgroup = NULL;
	SPDATA_DESTROYREMOTEGROUP	dgd;
	SPDATA_DELETEREMOTEGROUPFROMGROUP	drg;
	HRESULT						hr;


	DPF(7, "Entering PRV_DestroySubgroups");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", this, lpGroup, bRemoteOnly);

	ASSERT(lpGroup);

	// Setup the static part of the SPDATA structures
	memset(&dgd, 0, sizeof(SPDATA_DESTROYREMOTEGROUP));
	dgd.dwSize = sizeof(SPDATA_DESTROYREMOTEGROUP);

	memset(&drg, 0, sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP));
	drg.dwSize = sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP);
	drg.dwParentID = lpGroup->dwID;

	// Walk the list of subgroups
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// Save the next subgroup
		lpNextSubgroup = lpSubgroup->pNextSubgroup;
		
		// Make sure it's a remote group if the flag is set
		if((bRemoteOnly) &&
			(lpSubgroup->pGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			lpSubgroup = lpNextSubgroup;
			continue;
		}
		
		// If the subgroup doesn't contain any local players,
		// nor do any of it's subgroups, then destroy it
		if((!bRemoteOnly) || 
			((!PRV_DoSubgroupsContainLocalPlayers(lpSubgroup->pGroup, TRUE)) &&
			(!PRV_AreSubgroupsShortcuts(lpSubgroup->pGroup))))
		{
			// If the group is a shortcut, just delete the link.  If it's a child,
			// destroy the subgroup.
			if(lpSubgroup->dwFlags & DPGROUP_SHORTCUT)
			{
				// Finish setting up the SPDATA structure
				drg.dwGroupID = lpSubgroup->pGroup->dwID;
	
				// Destroy the subgroup
				hr = DPLP_DeleteGroupFromGroup((LPDPLOBBYSP)this->lpInterfaces, &drg);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed deleting remote group from group, hr = 0x%08x", hr);
				}
			}
			else
			{
				// Finish setting up the SPDATA structure
				dgd.dwGroupID = lpSubgroup->pGroup->dwID;
	
				// Destroy the subgroup
				hr = DPLP_DestroyGroup((LPDPLOBBYSP)this->lpInterfaces, &dgd);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed destroying remote group, hr = 0x%08x", hr);
				}
			}
		}

		lpSubgroup = lpNextSubgroup;

	} // while lpSubgroups

} // PRV_DestroySubgroups



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeletePlayerFromGroup"
HRESULT DPLAPI PRV_DeletePlayerFromGroup(LPDPLOBBYI_DPLOBJECT this,
					DWORD dwGroupID, DWORD dwPlayerID)
{
	SPDATA_DELETEPLAYERFROMGROUP		dpd;
	MSG_PLAYERMGMTMESSAGE				msg;
	LPDPLAYI_PLAYER						lpPlayer = NULL;
	LPDPLAYI_GROUP						lpGroup =NULL;
	LPDPLAYI_GROUPNODE					lpGroupnode = NULL;
	HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_DeletePlayerFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwGroupID, dwPlayerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDGROUP;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		DPF_ERR("Cannot delete a remote player from a group");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}
	
	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&dpd, 0, sizeof(SPDATA_DELETEPLAYERFROMGROUP));
	dpd.dwSize = sizeof(SPDATA_DELETEPLAYERFROMGROUP);
	dpd.dwGroupID = dwGroupID;
	dpd.dwPlayerID = dwPlayerID;

	// Call the DeletePlayerFromGroup method in the SP
	if(CALLBACK_EXISTS(DeletePlayerFromGroup))
	{
		dpd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DeletePlayerFromGroup, &dpd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DeletePlayerFromGroup is required
		DPF_ERR("The Lobby Provider callback for DeletePlayerFromGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling DeletePlayerFromGroup in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// We need to remove all other players in the group and send the appropriate
	// message to the player we are about to delete because he won't see the
	// system messages for them once he leaves the group.  However, if any other
	// local players are in the group, we don't want to remove the remote players
	// from the nametable because the other local players need to see them.

	// Get a pointer to dplay's internal group structure
	lpGroup = GroupFromID(this->lpDPlayObject, dwGroupID);
	if(!lpGroup)
	{
		DPF_ERRVAL("Unable to find group in nametable, idGroup = %lu", dwGroupID);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}

	// Get a pointer to dplay's internal player structure
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		DPF_ERRVAL("Unable to find player in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}

	// We need to send a DeletePlayerFromGroup message to the player who
	// was deleted since he won't get the group message once he's gone

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEPLAYERFROMGROUP);
	msg.dwPlayerID = dwPlayerID;
	msg.dwGroupID = dwGroupID;

	// Call dplay's handleplayermessage function to put the message in the queue
	hr = HandlePlayerMessage(lpPlayer, (LPBYTE)&msg,
			sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed adding message to player's receive queue from lobby, hr = 0x%08x", hr);
		// Set the hresult back to DP_OK since only the message failed
		hr = DP_OK;
	}

	// Figure out how many local players are in this group.  If it's only 1,
	// then delete all the remote players.
	lpGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,
					this->lpDPlayObject->pSysPlayer->dwID);
	if((!lpGroupnode) || (lpGroupnode->nPlayers == 0))
	{
		// Destroy all remote players that are only in this group
		PRV_DestroyRemotePlayersForExitingPlayer(this, lpGroup, dwGroupID);

		// Destroy all the remote shortcut groups, making sure we are
		// not in them, and removing their entire parental heirarchy
		PRV_DestroyRemoteShortcutsForExitingPlayer(this, lpGroup, dwGroupID);

		// Destroy all remote subgroups of this group, making sure we're
		// not in them for some reason
		PRV_DestroySubgroups(this, lpGroup, TRUE);

		// Destroy the group we're leaving if it is remote as well as it's
		// parental chain.
		PRV_DestroyGroupAndParents(this, lpGroup, NULL);
	}


EXIT_DELETEPLAYERFROMGROUP:

	// The dplay InternalDeletePlayerFromGroup code will take care of the rest of
	// the internal cleanup (nametable, players, etc.), so we can just return
	// from here.

	LEAVE_LOBBY_ALL();
	return hr;

} // PRV_DeletePlayerFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyGroup"
HRESULT DPLAPI PRV_DestroyGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID)
{
	SPDATA_DESTROYGROUP		dg;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DestroyGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, dwLobbyID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&dg, 0, sizeof(SPDATA_DESTROYGROUP));
	dg.dwSize = sizeof(SPDATA_DESTROYGROUP);
	dg.dwGroupID = dwLobbyID;

	// Call the DestroyGroup method in the SP
	if(CALLBACK_EXISTS(DestroyGroup))
	{
		dg.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DestroyGroup, &dg);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DestroyGroup is required
		DPF_ERR("The Lobby Provider callback for DestroyGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling DestroyGroup in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}

	// Take the lock
	ENTER_DPLAY();

	// So, get dplay's internal group structure
	lpGroup = GroupFromID(this->lpDPlayObject, dwLobbyID);
	if(!lpGroup)
	{
		// This shouldn't ever happen.  If the groups isn't in the nametable,
		// we should never get this far.
		ASSERT(FALSE);
		LEAVE_LOBBY_ALL();
		DPF_ERRVAL("Unable to find group in nametable, dpidGroup = %lu", dwLobbyID);
		return DPERR_INVALIDGROUP;
	}

	// Send messages to remove shortcuts to this group (since dplay won't
	// do it for us)
	PRV_SendDeleteShortcutMessageForExitingGroup(this, lpGroup);

	// Destroy all the subgroups and remote players
	PRV_RemoveSubgroupsAndPlayersFromGroup(this, lpGroup, dwLobbyID, FALSE);

	// Drop the dplay lock since we're done mucking around with it's structures
	LEAVE_DPLAY();

	// Broadcast the DestroyGroup message
	hr = PRV_BroadcastDestroyGroupMessage(this, dwLobbyID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed to send DestroyGroup message to local players, hr = 0x%08x", hr);
	}

	// The dplay InternalDestroyGroup code will take care of the rest of
	// the internal cleanup (nametable, players, etc.), so we can just return
	// from here.

	LEAVE_DPLOBBY();
	return hr;

} // PRV_DestroyGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetGroupConnectionSettings"
HRESULT PRV_GetGroupConnectionSettings(LPDIRECTPLAY lpDP, DWORD dwFlags,
			DWORD dwGroupID, LPVOID lpData, LPDWORD lpdwSize) 
{
	SPDATA_GETGROUPCONNECTIONSETTINGS	gcs;
	LPDPLOBBYI_DPLOBJECT				this = NULL;
    LPDPLAYI_DPLAY						lpDPObject = NULL;
	LPDPLAYI_GROUP						lpGroup = NULL;
    HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_GetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, dwGroupID, lpData, lpdwSize);

    TRY
    {
        lpDPObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("Bad DPlay interface pointer - hr = 0x%08lx\n",hr);
			return hr;
        }
    
		if(!IS_LOBBY_OWNED(lpDPObject))
		{
			DPF_ERR("GetGroupConnectionSettings is only supported for lobby connections");
			return DPERR_UNSUPPORTED;
		}

		this = lpDPObject->lpLobbyObject;
		if(!VALID_DPLOBBY_PTR(this))
		{
			DPF_ERR("Bad DPLobby object");
			return DPERR_INVALIDOBJECT;
		}

		lpGroup = GroupFromID(lpDPObject, dwGroupID);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERR("Invalid group id");
            return DPERR_INVALIDGROUP;
        }

		if( !VALID_DWORD_PTR( lpdwSize ) )
		{
			DPF_ERR("lpdwSize was not a valid dword pointer!");
			return DPERR_INVALIDPARAMS;
		}

		if(lpData)
		{
			if( !VALID_WRITE_PTR(lpData, *lpdwSize) )
			{
				DPF_ERR("lpData is not a valid output buffer of the size specified in *lpdwSize");
				return DPERR_INVALIDPARAMS;
			}
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&gcs, 0, sizeof(SPDATA_GETGROUPCONNECTIONSETTINGS));
	gcs.dwSize = sizeof(SPDATA_GETGROUPCONNECTIONSETTINGS);
	gcs.dwFlags = dwFlags;
	gcs.dwGroupID = dwGroupID;
	gcs.lpdwBufferSize = lpdwSize;
	gcs.lpBuffer = lpData;

	// Call the GetGroupConnectionSettings method in the SP
	if(CALLBACK_EXISTS(GetGroupConnectionSettings))
	{
		gcs.lpISP = PRV_GetDPLobbySPInterface(this);
	    
		// Drop the dplay lock since we are going to send a guaranteed message
		LEAVE_LOBBY_ALL();

		hr = CALL_LP(this, GetGroupConnectionSettings, &gcs);

		// Take the lock back
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// GetGroupConnectionSettings is required
		DPF_ERR("The Lobby Provider callback for GetGroupConnectionSettings doesn't exist -- it's required");
		ASSERT(FALSE);
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr) && (hr != DPERR_BUFFERTOOSMALL))
	{
		DPF_ERRVAL("Failed calling GetGroupConnectionSettings in the Lobby Provider, hr = 0x%08x", hr);
	}

	return hr;

} // PRV_GetGroupConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetGroupConnectionSettings"
HRESULT DPLAPI DPL_GetGroupConnectionSettings(LPDIRECTPLAY lpDP, 
		DWORD dwFlags, DPID idGroup, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_GetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpData, lpdwSize);

	ENTER_LOBBY_ALL();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetGroupConnectionSettings(lpDP, dwFlags, idGroup,
							lpData,	lpdwSize);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_GetGroupConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetGroupData"
HRESULT DPLAPI PRV_GetGroupData(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					LPVOID lpData, LPDWORD lpdwDataSize)
{
	SPDATA_GETGROUPDATA		ggd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_GetGroupData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwGroupID, lpData, lpdwDataSize);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&ggd, 0, sizeof(SPDATA_GETGROUPDATA));
	ggd.dwSize = sizeof(SPDATA_GETGROUPDATA);
	ggd.dwGroupID = dwGroupID;
	ggd.lpdwDataSize = lpdwDataSize;
	ggd.lpData = lpData;

	// Call the GetGroupData method in the SP
	if(CALLBACK_EXISTS(GetGroupData))
	{
		ggd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetGroupData, &ggd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetGroupData is required
		DPF_ERR("The Lobby Provider callback for GetGroupData doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling GetGroupData in the Lobby Provider, hr = 0x%08x", hr);
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetGroupData



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetGroupOwner"
HRESULT DPAPI DPL_GetGroupOwner(LPDIRECTPLAY lpDP, DWORD dwGroupID,
		LPDPID lpidOwner)
{
	LPDPLAYI_DPLAY		this;
	LPDPLAYI_GROUP		lpGroup = NULL;
	HRESULT				hr;


	DPF(7, "Entering DPL_GetGroupOwner");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwGroupID, lpidOwner);

	ENTER_DPLAY();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		lpGroup = GroupFromID(this, dwGroupID);
	    if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == dwGroupID)) 
	    {
			LEAVE_DPLAY();
			DPF_ERR("Invalid group id");
	        return DPERR_INVALIDGROUP;
	    }

		if (!VALID_DWORD_PTR(lpidOwner))
		{
			LEAVE_DPLAY();
			DPF_ERR("Invalid owner id pointer");
			return DPERR_INVALIDPARAMS;	
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// This method is only valid in lobby session
	if(IS_LOBBY_OWNED(this))
	{	
		*lpidOwner = lpGroup->dwOwnerID;
	}
	else
	{
		DPF_ERR("GetGroupOwner is only supported for lobby sessions");
		hr = DPERR_UNSUPPORTED;
	}

	LEAVE_DPLAY();
	return hr;

} // DPL_GetGroupOwner



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetGroupConnectionSettings"
HRESULT PRV_SetGroupConnectionSettings(LPDIRECTPLAY lpDP, DWORD dwFlags,
				DWORD dwGroupID, LPDPLCONNECTION lpConn, BOOL bAnsi) 
{
	SPDATA_SETGROUPCONNECTIONSETTINGS	scs;
	LPDPLOBBYI_DPLOBJECT				this = NULL;
    LPDPLAYI_DPLAY						lpDPObject = NULL;
	LPDPLAYI_GROUP						lpGroup = NULL;
    HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_SetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDP, dwFlags, dwGroupID, lpConn, bAnsi);

    TRY
    {
        lpDPObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("Bad DPlay interface pointer - hr = 0x%08lx\n",hr);
			return hr;
        }
    
		if(!IS_LOBBY_OWNED(lpDPObject))
		{
			DPF_ERR("SetGroupConnectionSettings is only supported for lobby connections");
			return DPERR_UNSUPPORTED;
		}

		this = lpDPObject->lpLobbyObject;
		if(!VALID_DPLOBBY_PTR(this))
		{
			DPF_ERR("Bad DPLobby object");
			return DPERR_INVALIDOBJECT;
		}

		lpGroup = GroupFromID(lpDPObject, dwGroupID);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERR("Invalid group id");
            return DPERR_INVALIDGROUP;
        }

		hr = PRV_ValidateDPLCONNECTION(lpConn, FALSE);
		if(FAILED(hr))
		{
			DPF_ERR("Invalid DPLCONNECTION structure");
			return hr;
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            return DPERR_INVALIDFLAGS;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&scs, 0, sizeof(SPDATA_SETGROUPCONNECTIONSETTINGS));
	scs.dwSize = sizeof(SPDATA_SETGROUPCONNECTIONSETTINGS);
	scs.dwFlags = dwFlags;
	scs.dwGroupID = dwGroupID;
	scs.lpConn = lpConn;

	// Ensure that the guidInstance in the DPLCONNECTION structure is NULL
	lpConn->lpSessionDesc->guidInstance = GUID_NULL;

	// Call the SetGroupConnectionSettings method in the SP
	if(CALLBACK_EXISTS(SetGroupConnectionSettings))
	{
		scs.lpISP = PRV_GetDPLobbySPInterface(this);
	    
		// Drop the dplay lock since we're sending a guaranteed message
		LEAVE_LOBBY_ALL();

		hr = CALL_LP(this, SetGroupConnectionSettings, &scs);

		// Take the lock back
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// SetGroupConnectionSettings is required
		DPF_ERR("The Lobby Provider callback for SetGroupConnectionSettings doesn't exist -- it's required");
		ASSERT(FALSE);
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling SetGroupConnectionSettings in the Lobby Provider, hr = 0x%08x", hr);
	}

	return hr;

} // PRV_SetGroupConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetGroupConnectionSettings"
HRESULT DPLAPI DPL_SetGroupConnectionSettings(LPDIRECTPLAY lpDP, 
				DWORD dwFlags, DPID idGroup, LPDPLCONNECTION lpConn)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_SetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpConn);

	ENTER_LOBBY_ALL();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetGroupConnectionSettings(lpDP, dwFlags, idGroup, lpConn, FALSE);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_SetGroupConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetGroupData"
HRESULT DPLAPI PRV_SetGroupData(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					LPVOID lpData, DWORD dwDataSize, DWORD dwFlags)
{
	SPDATA_SETGROUPDATA		sgd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_SetGroupData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, %lu, 0x%08x",
			this, dwGroupID, lpData, dwDataSize, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&sgd, 0, sizeof(SPDATA_SETGROUPDATA));
	sgd.dwSize = sizeof(SPDATA_SETGROUPDATA);
	sgd.dwGroupID = dwGroupID;
	sgd.dwDataSize = dwDataSize;
	sgd.lpData = lpData;
	sgd.dwFlags = dwFlags;

	// Call the SetGroupData method in the SP
	if(CALLBACK_EXISTS(SetGroupData))
	{
		sgd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetGroupData, &sgd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetGroupData is required
		DPF_ERR("The Lobby Provider callback for SetGroupData doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETGROUPDATA;
	}

	// If it succeeded, send the SetGroupData message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendDataChangedMessageLocally(this, dwGroupID, lpData, dwDataSize);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetGroupData in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETGROUPDATA:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetGroupData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetGroupName"
HRESULT DPLAPI PRV_SetGroupName(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					LPDPNAME lpName, DWORD dwFlags)
{
	SPDATA_SETGROUPNAME		sgn;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_SetGroupName");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwGroupID, lpName, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&sgn, 0, sizeof(SPDATA_SETGROUPNAME));
	sgn.dwSize = sizeof(SPDATA_SETGROUPNAME);
	sgn.dwGroupID = dwGroupID;
	sgn.lpName = lpName;
	sgn.dwFlags = dwFlags;

	// Call the SetGroupName method in the SP
	if(CALLBACK_EXISTS(SetGroupName))
	{
		sgn.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetGroupName, &sgn);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetGroupName is required
		DPF_ERR("The Lobby Provider callback for SetGroupName doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETGROUPNAME;
	}

	// If it succeeded, send the SetGroupName message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendNameChangedMessageLocally(this, dwGroupID, lpName, FALSE);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetGroupName in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETGROUPNAME:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetGroupName



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetGroupOwner"
HRESULT DPLAPI DPL_SetGroupOwner(LPDIRECTPLAY lpDP, DWORD dwGroupID,
		DWORD dwOwnerID)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLAYI_DPLAY			lpDPlayObject;
	SPDATA_SETGROUPOWNER	sgo;
	LPDPLAYI_PLAYER			lpNewOwner = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;
	DWORD					dwOldOwnerID;


	DPF(7, "Entering DPL_SetGroupOwner");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwGroupID, dwOwnerID);

	ENTER_LOBBY_ALL();
	
    TRY
    {
		lpDPlayObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPlayObject );
		if (FAILED(hr))
		{
			LEAVE_LOBBY_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

        this = lpDPlayObject->lpLobbyObject;
		if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_LOBBY_ALL();
			return DPERR_INVALIDOBJECT;
        }

	    lpGroup = GroupFromID(lpDPlayObject, dwGroupID);
	    if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == dwGroupID)) 
	    {
			LEAVE_LOBBY_ALL();
			DPF_ERR("Invalid group id");
	        return DPERR_INVALIDGROUP;
	    }

	    // DPID_SERVERPLAYER is valid here
		if(dwOwnerID != DPID_SERVERPLAYER)
		{
			lpNewOwner = PlayerFromID(lpDPlayObject, dwOwnerID);
			if (!VALID_DPLAY_PLAYER(lpNewOwner))
			{
				LEAVE_LOBBY_ALL();
				DPF_ERR("Invalid new owner player id");
				return DPERR_INVALIDPLAYER;
			}
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_LOBBY_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	

	// do the send
	if(!IS_LOBBY_OWNED(lpDPlayObject))
	{
		DPF_ERR("SetGroupOwner is only supported for lobby sessions");
		hr = DPERR_UNSUPPORTED;
		goto EXIT_SETGROUPOWNER;
	}


	// Setup our SPDATA struct
	memset(&sgo, 0, sizeof(SPDATA_SETGROUPOWNER));
	sgo.dwSize = sizeof(SPDATA_SETGROUPOWNER);
	sgo.dwGroupID = dwGroupID;
	sgo.dwOwnerID = dwOwnerID;

	// Call the SetGroupOwner method in the SP
	if(CALLBACK_EXISTS(SetGroupOwner))
	{
		sgo.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// response (which always happens)
		LEAVE_LOBBY_ALL();
	    hr = CALL_LP(this, SetGroupOwner, &sgo);
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// SetGroupOwner is required
		DPF_ERR("The Lobby Provider callback for SetGroupOwner doesn't exist");
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETGROUPOWNER;
	}

	// If it succeeded, send the SetGroupOwner message to our local players
	if(SUCCEEDED(hr))
	{
		// Get a pointer to our internal data struct for the group, just in
		// case it changed for some reason while we had dropped the locks
		lpGroup = GroupFromID(this->lpDPlayObject, dwGroupID);
		if(!lpGroup)
		{
			DPF_ERR("Unable to find group in nametable -- local nametable will be incorrect");
			goto EXIT_SETGROUPOWNER;
		}

		// Save the old owner so we can put it in the message
		dwOldOwnerID = lpGroup->dwOwnerID;
		
		// Change the owner
		lpGroup->dwOwnerID = dwOwnerID;

		// Send a SetGroupOwner message locally
		PRV_SendGroupOwnerMessageLocally(this, dwGroupID, dwOwnerID, dwOldOwnerID);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetGroupOwner in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETGROUPOWNER:

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_SetGroupOwner



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_StartSession"
HRESULT DPLAPI DPL_StartSession(LPDIRECTPLAY lpDP, DWORD dwFlags, DWORD dwGroupID)
{
	SPDATA_STARTSESSION		ss;
	LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLAYI_DPLAY			lpDPObject = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_StartSession");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, dwGroupID);

	ENTER_LOBBY_ALL();

    TRY
    {
        lpDPObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("Bad DPlay interface pointer - hr = 0x%08lx\n",hr);
			goto ERROR_STARTSESSION;
        }
    
		if(!IS_LOBBY_OWNED(lpDPObject))
		{
			DPF_ERR("SetGroupConnectionSettings is only supported for lobby connections");
			hr = DPERR_UNSUPPORTED;
			goto ERROR_STARTSESSION;
		}

		this = lpDPObject->lpLobbyObject;
		if(!VALID_DPLOBBY_PTR(this))
		{
			DPF_ERR("Bad DPLobby object");
			hr = DPERR_INVALIDOBJECT;
			goto ERROR_STARTSESSION;
		}

		if(dwFlags)
		{
			DPF_ERR("Invalid flags");
			hr = DPERR_INVALIDFLAGS;
			goto ERROR_STARTSESSION;
		}

		lpGroup = GroupFromID(lpDPObject, dwGroupID);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERR("Invalid group id");
            hr = DPERR_INVALIDGROUP;
			goto ERROR_STARTSESSION;
        }

		// Make sure the group is a staging area
		if(!(lpGroup->dwFlags & DPLAYI_GROUP_STAGINGAREA))
		{
			DPF_ERR("StartSession can only be called on a Staging Area");
			hr = DPERR_INVALIDGROUP;
			goto ERROR_STARTSESSION;
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
		goto ERROR_STARTSESSION;
    }


	// Setup our SPDATA struct
	memset(&ss, 0, sizeof(SPDATA_STARTSESSION));
	ss.dwSize = sizeof(SPDATA_STARTSESSION);
	ss.dwGroupID = dwGroupID;
	ss.dwFlags = dwFlags;

	// Call the StartSession method in the SP
	if(CALLBACK_EXISTS(StartSession))
	{
		ss.lpISP = PRV_GetDPLobbySPInterface(this);

	    // Drop the dplay lock so we can send a guarateed message
		LEAVE_LOBBY_ALL();

		hr = CALL_LP(this, StartSession, &ss);

		// Take the lock back
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// StartSession is required
		DPF_ERR("The Lobby Provider callback for StartSession doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto ERROR_STARTSESSION;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling StartSession in the Lobby Provider, hr = 0x%08x", hr);
	}

ERROR_STARTSESSION:

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_StartSession



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateAndMapNewGroup"
HRESULT PRV_CreateAndMapNewGroup(LPDPLOBBYI_DPLOBJECT this,
			DPID * lpdpid, LPDPNAME lpName, LPVOID lpData,
			DWORD dwDataSize, DWORD dwFlags, DWORD dwLobbyID,
			DPID dpidParent, DWORD dwOwnerID)
{
	LPDPLAYI_GROUP		lpGroup = NULL, lpSysGroup = NULL;
	HRESULT				hr;
	DPID				dpidGroup, dpidSysPlayer;


	// Take the dplay lock
	ENTER_DPLAY();

	// Make sure the lobby ID is valid
	if(!IsValidLobbyID(dwLobbyID))
	{
		DPF_ERRVAL("ID %lu is reserved, cannot create new player", dwLobbyID);
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_CREATEANDMAPNEWGROUP;
	}

	// If this is a remote player, we need allocate a new nametable entry
	// for them and set the correct system player ID
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Allocate a new ID for the player
		hr = NS_AllocNameTableEntry(this->lpDPlayObject, &dpidGroup);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to allocate new nametable id, hr = 0x%08x", hr);
			goto EXIT_CREATEANDMAPNEWGROUP;
		}

		// Make sure we have a lobby system player (for all remote players
		// & groups). If we don't then allocate a new one.
		if(!(this->dpidSysPlayer))
		{
			hr = PRV_CreateAndMapNewPlayer(this, &dpidSysPlayer, NULL, NULL,
					NULL, 0, DPLAYI_PLAYER_SYSPLAYER,
					DPID_LOBBYREMOTESYSTEMPLAYER, TRUE);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Unable to create lobby system player, hr = 0x%08x", hr);
				ASSERT(FALSE);
				goto EXIT_CREATEANDMAPNEWGROUP;
			}

			// Set the lobby system player ID pointer to the new ID
			this->dpidSysPlayer = dpidSysPlayer;
		}
	}

	// Get a group struct for the group (if it's local, this will add it
	// to the nametable.  If it's remote, we need to add it below)
	hr = GetGroup(this->lpDPlayObject, &lpGroup, lpName, lpData,
					dwDataSize, dwFlags, dpidParent, dwLobbyID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed trying to add group to the nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEANDMAPNEWGROUP;
	}

	// Fixup the group's owner
	lpGroup->dwOwnerID = dwOwnerID;
	
	// If the group is remote, set the group's ID to the new one we
	// allocated and then set the system group ID to the lobby system group
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// 
		lpGroup->dwIDSysPlayer = this->dpidSysPlayer;

		// Add the group to the nametable
		hr = AddItemToNameTable(this->lpDPlayObject, (DWORD_PTR)lpGroup,
				&dpidGroup, TRUE, dwLobbyID);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("Unable to add new group to the nametable, hr = 0x%08x", hr);
			ASSERT(FALSE);
			goto EXIT_CREATEANDMAPNEWGROUP;
	    }

		// Set the group's ID
		lpGroup->dwID = dpidGroup;
	}

	// Set the output dpid pointer
	*lpdpid = lpGroup->dwID;

EXIT_CREATEANDMAPNEWGROUP:

	LEAVE_DPLAY();
	return hr;

} // PRV_CreateAndMapNewGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
EnumProcesses(
    DWORD * lpidProcess,
    DWORD   cb,
    DWORD * cbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

DWORD
WINAPI
GetModuleBaseNameA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    HANDLE hProcess
    );


BOOL
WINAPI
QueryWorkingSet(
    HANDLE hProcess,
    PVOID pv,
    DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    HANDLE hProcess
    );


typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

BOOL
WINAPI
GetWsChanges(
    HANDLE hProcess,
    PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    DWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW(
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA(
    HANDLE hProcess,
    LPVOID lpv,
    LPSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFilenameEx  GetMappedFilenameExW
#else
#define GetMappedFilenameEx  GetMappedFilenameExA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers(
    LPVOID *lpImageBase,
    DWORD cb,
    LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA(
    LPVOID ImageBase,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW(
    LPVOID ImageBase,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    DWORD PeakWorkingSetSize;
    DWORD WorkingSetSize;
    DWORD QuotaPeakPagedPoolUsage;
    DWORD QuotaPagedPoolUsage;
    DWORD QuotaPeakNonPagedPoolUsage;
    DWORD QuotaNonPagedPoolUsage;
    DWORD PagefileUsage;
    DWORD PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\sources.inc ===
TARGETNAME=dplobby
TARGETPATH=.\obj$(BUILD_ALT_DIR)
TARGETTYPE=LIBRARY

USE_MAPSYM=1

INCLUDES= \
	$(DXROOT)\inc;\
	..\;\
	..\..\..\dplay\dplay;\
	..\..\..\dplay\common;\
	..\..\..\misc; \
	..\..\..\dvoice\inc;

C_DEFINES=$(C_DEFINES) -DWINVER=0x0400

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES)	-DUNICODE -D_UNICODE -DNEW_DPF -DSECURITY_WIN32


NTPROFILEINPUT=yes


SOURCES= \
        ..\create.c \
        ..\dplenum.c \
        ..\dplgame.c \
        ..\dplobby.c \
        ..\dplobbya.c \
        ..\dplpack.c \
        ..\dplshare.c \
        ..\dplsp.c \
        ..\dplunk.c \
        ..\group.c \
        ..\player.c \
        ..\server.c \
        ..\session.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\server.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       server.c
 *  Content:	Methods for connecting and interrogating a lobby server
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	10/25/96	myronth	Created it
 *	11/20/96	myronth	Implemented Logon/LogoffServer
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Fixed LoadSP code for DPlay3, reg & DPF bug fixes
 *	3/13/97		myronth	Save hInstance handle for LP DLL
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	4/9/97		myronth	Fixed structure passed to LP at DPLSPInit
 *	5/8/97		myronth	Purged dead code
 *	6/19/97		myronth	Moved setting of DPLOBBYPR_SPINTERFACE flag (#10118)
 *  7/28/97		sohailm	PRV_FindLPGUIDInAddressCallback was assuming pointers 
 *						were valid after duration of call.
 *	10/3/97		myronth	Bumped version to DX6, added it to DPLSPInit struct (#12667)
 *	10/7/97		myronth	Save the LP version in the lobby struct for later use
 *	11/6/97		myronth	Added version existence flag and dwReserved values
 *						to SPDATA_INIT (#12916, #12917)
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------
#define NUM_CALLBACKS( ptr ) ((ptr->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID ))

typedef struct LOOKFORSP
{
	LPGUID	lpguid;
	LPBOOL	lpbSuccess;
} LOOKFORSP, FAR * LPLOOKFORSP;

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_VerifySPCallbacks"
HRESULT PRV_VerifySPCallbacks(LPDPLOBBYI_DPLOBJECT this)
{
	LPDWORD	lpCallback;
	int		nCallbacks = NUM_CALLBACKS(((LPSP_CALLBACKS)this->pcbSPCallbacks));
	int		i;


	DPF(2,"Verifying %d callbacks\n",nCallbacks);
	DPF(7, "Entering PRV_VerifySPCallbacks");
	DPF(9, "Parameters: 0x%08x", this);

	lpCallback = (LPDWORD)this->pcbSPCallbacks + 2; // + 1 for dwSize, + 1 for dwFlags

	for (i=0;i<nCallbacks ;i++ )
	{
		if ((lpCallback) && !VALIDEX_CODE_PTR(lpCallback)) 
		{
			DPF_ERR("SP provided bad callback pointer!");
			return E_FAIL;
		}
		lpCallback++;
	}

	return DP_OK;	

} // PRV_VerifySPCallbacks



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LookForSPCallback"
BOOL FAR PASCAL PRV_LookForSPCallback(LPGUID lpguidSP, LPWSTR lpSPName,
				DWORD dwMajorVersion, DWORD dwMinorVersion, LPVOID lpContext)
{
	LPLOOKFORSP		lplook = (LPLOOKFORSP)lpContext;


	ASSERT(lpguidSP);
	ASSERT(lplook);

	// Check the guid and see if they match
	if(IsEqualGUID(lpguidSP, lplook->lpguid))
	{
		// Set the flag to true and stop enumerating
		*(lplook->lpbSuccess) = TRUE;
		return FALSE;
	}

	return TRUE;

} // PRV_LookForSPCallback



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindSPName"
HRESULT PRV_FindSPName(LPGUID lpguidSP, LPWSTR * lplpName,
		LPDWORD lpdwReserved1, LPDWORD lpdwReserved2)
{
	HKEY		hkeyLobbySP=NULL, hkeySP;
	WCHAR		wszSPName[DPLOBBY_REGISTRY_NAMELEN];
	DWORD		dwIndex = 0, dwSPNameSize;
	WCHAR		wszGuidStr[GUID_STRING_SIZE];
	DWORD		dwGuidStrSize = sizeof(wszGuidStr);
	DWORD		dwFileStrSize = 0;
	DWORD		dwType = REG_SZ;
	LPWSTR		lpwszFile = NULL;
	GUID		guidSP;
	LOOKFORSP	look;
	LONG		lReturn;
	BOOL		bFound = FALSE;
	DWORD		dwError;
	HRESULT		hr;
	DWORD		dwSize;



	DPF(7, "Entering PRV_FindSPName");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpguidSP, lplpName);

	ASSERT(lpguidSP);
	ASSERT(lplpName);


	// First see if it is a Lobby SP
	// Open the DPLobby SP key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLOBBY_SP_KEY, 0,
								KEY_READ, &hkeyLobbySP);
	// If this fails, it just means that the DPLobby SP key doesn't exist (most
	// likely), so in that case, there are no Lobby SP's to enumerate.
	if(lReturn == ERROR_SUCCESS)
	{
		// Walk the list of Lobby SP's in the registry, enumerating them
		while(!bFound)
		{
		
			// Get the next key's name
			dwSPNameSize = DPLOBBY_REGISTRY_NAMELEN;
			lReturn = OS_RegEnumKeyEx(hkeyLobbySP, dwIndex++, (LPWSTR)&wszSPName,
							&dwSPNameSize, NULL, NULL, NULL, NULL);
			if(ERROR_NO_MORE_ITEMS == lReturn)
				break;
			else if(lReturn != ERROR_SUCCESS)
			{
				dwError = GetLastError();
				DPF(2, "Unable to get Lobby Provider name -- skipping provider -- dwError = %u", dwError);
				continue;
			}
			

			// Open the key
			lReturn = OS_RegOpenKeyEx(hkeyLobbySP, (LPWSTR)wszSPName, 0,
										KEY_READ, &hkeySP);
			if(lReturn != ERROR_SUCCESS)
			{
				DPF_ERR("Unable to open Lobby Service Provider key in the registry!");
				continue;
			}

			// Get the GUID of the SP
			dwGuidStrSize = GUID_STRING_SIZE;
			lReturn = OS_RegQueryValueEx(hkeySP, SZ_GUID, NULL, &dwType,
										(LPBYTE)&wszGuidStr, &dwGuidStrSize);
			if(lReturn != ERROR_SUCCESS)
			{
				RegCloseKey(hkeySP);
				DPF_ERR("Unable to query GUID key value!");
				continue;
			}

			// Convert the string to a real GUID
			GUIDFromString(wszGuidStr, &guidSP);

			// Check to see if the guid is the one we are looking for
			if(IsEqualGUID(&guidSP, lpguidSP))
			{
				// Allocate memory for the filename string
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_PATH, NULL, &dwType,
											NULL, &dwFileStrSize);
				if(lReturn != ERROR_SUCCESS)
				{
					RegCloseKey(hkeySP);
					DPF_ERR("Unable to get the size of the SP Path string");
					continue;
				}
				
				// Allocate memory for the string
				lpwszFile = DPMEM_ALLOC(dwFileStrSize);
				if(!lpwszFile)
				{
					RegCloseKey(hkeySP);
					DPF_ERR("Unable to allocate memory for temporary file string");
					continue;
				}

				// Get the filename string
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_PATH, NULL, &dwType,
											(LPBYTE)lpwszFile, &dwFileStrSize);
				if(lReturn != ERROR_SUCCESS)
				{
					RegCloseKey(hkeySP);
					DPF_ERR("Unable to get filename string from registry");
					continue;
				}

				// Get the Reserved1 value
				dwSize = sizeof(DWORD);
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED1, NULL,
							&dwType, (LPBYTE)lpdwReserved1, &dwSize);
				if (lReturn != ERROR_SUCCESS) 
				{
					DPF(0,"Could not read dwReserved1 lReturn = %d\n", lReturn);
					// It's ok if LP doesn't have one of these...
				}

				// Get the Reserved2 value
				dwSize = sizeof(DWORD);
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED2, NULL,
							&dwType, (LPBYTE)lpdwReserved2, &dwSize);
				if (lReturn != ERROR_SUCCESS) 
				{
					DPF(0,"Could not read dwReserved2 lReturn = %d\n", lReturn);
					// It's ok if LP doesn't have one of these...
				}

				// We've got our information, so set the flag and bail
				bFound = TRUE;
				RegCloseKey(hkeySP);
				break;
			}

			// Close the SP key
			RegCloseKey(hkeySP);
		}
	}

	// Close the Lobby SP key
	if(hkeyLobbySP)
	{
		RegCloseKey(hkeyLobbySP);
	}	

	// If we haven't found the SP, start checking the DPlay SP's for it
	if(!bFound)
	{
		// Set up a struct containing the guid and a success flag
		look.lpguid = lpguidSP;
		look.lpbSuccess = &bFound;
		
		// Call DirectPlayEnumerate and look for our SP
		hr = DirectPlayEnumerate(PRV_LookForSPCallback, &look);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to enumerate DirectPlay Service Providers");
		}

		// If the flag is TRUE, that means we found it, so set the output
		// pointer to a string containing our LobbySP for DPlay
		if(bFound)
		{
			hr = GetString(&lpwszFile, SZ_SP_FOR_DPLAY);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary string for filename");
			}
		}
	}	

	// If we haven't found the filename, return an error
	if(!bFound)
		return DPERR_GENERIC;

	// Set the output parameter
	*lplpName = lpwszFile;

	return DP_OK;

} // PRV_FindSPName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LoadSP"
HRESULT PRV_LoadSP(LPDPLOBBYI_DPLOBJECT this, LPGUID lpguidSP,
						LPVOID lpAddress, DWORD dwAddressSize)
{
	SPDATA_INIT				sd;
	SPDATA_SHUTDOWN			sdd;
	LPDPLOBBYSP				lpISP = NULL;
	LPWSTR					lpwszSP = NULL;
	HANDLE					hModule = NULL;
	HRESULT					hr;
	HRESULT					(WINAPI *SPInit)(LPSPDATA_INIT pSD);
	DWORD					dwError;
	DWORD					dwReserved1 = 0;
	DWORD					dwReserved2 = 0;


	DPF(7, "Entering PRV_LoadSP");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, lpguidSP, lpAddress);

	ASSERT(this);
	ASSERT(lpguidSP);


	// Find the requested Service Provider
	hr = PRV_FindSPName(lpguidSP, &lpwszSP, &dwReserved1, &dwReserved2);
	if(FAILED(hr))
	{
		DPF_ERR("Unabled to find requested LobbyProvider");
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}

 	// Try to load the specified sp
    hModule = OS_LoadLibrary(lpwszSP);
	if (!hModule) 
	{
		dwError = GetLastError();
		DPF_ERR("Could not load service provider\n");
		DPF(0, "GetLastError returned dwError = %d\n", dwError);
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}

	// Free the name string
	DPMEM_FREE(lpwszSP);
	lpwszSP = NULL;

	// Get our DPLSPInit entry point
    (FARPROC)SPInit = OS_GetProcAddress(hModule, "DPLSPInit");
	if (!SPInit) 
	{
		DPF(0,"Could not find service provider entry point");
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}

	// Get an IDPLobbySP to pass it
	hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *)&lpISP, &dplCallbacksSP);
	if (FAILED(hr)) 
	{
		DPF(0,"Unable to get an IDPLobbySP interface. hr = 0x%08lx\n",hr);
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}
	
	// Alloc the callbacks
	this->pcbSPCallbacks = DPMEM_ALLOC(sizeof(SP_CALLBACKS));
	if (!this->pcbSPCallbacks) 
	{
		DPF_ERR("Unable to allocate memory for SPCallback structure");
		LEAVE_DPLOBBY();
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_EXIT_LOADSP;
	}

	// Set up the init data struct
	memset(&sd,0,sizeof(sd));
	sd.lpCB = this->pcbSPCallbacks;
    sd.lpCB->dwSize = sizeof(SP_CALLBACKS);
	sd.lpCB->dwDPlayVersion = DPLSP_MAJORVERSION;
	sd.lpISP = lpISP;
	sd.lpAddress = lpAddress;
	sd.dwReserved1 = dwReserved1;
	sd.dwReserved2 = dwReserved2;

	hr = SPInit(&sd);
    if (FAILED(hr))
    {
    	DPF_ERR("Could not start up service provider!");
		goto ERROR_EXIT_LOADSP;
    }

	// Verify the callbacks are valid
	hr = PRV_VerifySPCallbacks(this);
    if (FAILED(hr))
    {
    	DPF_ERR("Invalid callbacks from service provider!");
		goto ERROR_EXIT_LOADSP;
    }

	// Make sure the SP version is valid
	if (sd.dwSPVersion < DPLSP_DX5VERSION)
	{
    	DPF_ERR("Incompatible version returned from lobby provider!");
		// Since the init succeeded, try to call shutdown
		memset(&sdd, 0, sizeof(SPDATA_SHUTDOWN));
		// REVIEW!!!! -- Should we pass a valid interface pointer
		// to the shutdown callback?  If so, which one?
		if (CALLBACK_EXISTS(Shutdown))
		{
			sdd.lpISP = PRV_GetDPLobbySPInterface(this);
			hr = CALL_LP(this, Shutdown, &sdd);
			if (FAILED(hr)) 
			{
				DPF_ERR("Could not invoke shutdown on the Lobby Provider");
			}
		}
		else 
		{
			ASSERT(FALSE);
		}

		hr = DPERR_UNAVAILABLE;
		goto ERROR_EXIT_LOADSP;
	}
	else
	{
		// Save the version of the lobby provider
		this->dwLPVersion = sd.dwSPVersion;
	}

	// Set the flag which tells us we have an IDPLobbySP interface
	this->dwFlags |= DPLOBBYPR_SPINTERFACE;

	// Save the hInstance for the LP's DLL
	this->hInstanceLP = hModule;

	return DP_OK;

ERROR_EXIT_LOADSP:
	
	// If the LP DLL was loaded, unload it
    if(hModule)
    {
        if(!FreeLibrary(hModule))
        {
			dwError = GetLastError();
			DPF_ERRVAL("Unable to free Lobby Provider DLL, dwError = %lu", dwError);
            ASSERT(FALSE);
        }
    }

	// Free our allocated callback table
	if(this->pcbSPCallbacks)
	{
		DPMEM_FREE(this->pcbSPCallbacks);
		this->pcbSPCallbacks = NULL;
	}

    return hr;

} // PRV_LoadSP



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindLPGUIDInAddressCallback"
BOOL FAR PASCAL PRV_FindLPGUIDInAddressCallback(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{	
	// See if this chunk is our LobbyProvider GUID
	if (IsEqualGUID(lpguidDataType, &DPAID_LobbyProvider))
	{
		// We found it, so we can stop enumerating chunks
		*((LPGUID)lpContext) = *((LPGUID)lpData);
		return FALSE;
	}
	
	// Try the next chunk
	return TRUE;

} // PRV_FindLPGUIDInAddressCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\session.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       session.c
 *  Content:	Methods for session management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	2/27/97		myronth	Created it
 *	3/12/97		myronth	Implemented EnumSessions, Open, & Close
 *	3/31/97		myronth	Removed dead code, Fixed EnumSessionReponse fn name
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	5/8/97		myronth	Drop lobby lock when calling the LP
 *	5/13/97		myronth	Handle Credentials in Open, pass them to LP
 *	6/4/97		myronth	Fixed PRV_Open to fail on DPOPEN_CREATE (#9491)
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_Close"
HRESULT DPLAPI PRV_Close(LPDPLOBBYI_DPLOBJECT this)
{
	SPDATA_CLOSE	cd;
	HRESULT			hr = DP_OK;


	DPF(7, "Entering PRV_Close");
	DPF(9, "Parameters: 0x%08x", this);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA structure
	memset(&cd, 0, sizeof(SPDATA_CLOSE));
	cd.dwSize = sizeof(SPDATA_CLOSE);

	// Call the Close method in the SP
	if(CALLBACK_EXISTS(Close))
	{
		cd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, Close, &cd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// Close is required
		DPF_ERR("The Lobby Provider callback for Close doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_Close



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumSessions"
HRESULT DPLAPI PRV_EnumSessions(LPDPLOBBYI_DPLOBJECT this,
		LPDPSESSIONDESC2 lpsd, DWORD dwTimeout, DWORD dwFlags)
{
	HRESULT					hr = DP_OK;
	SPDATA_ENUMSESSIONS		esd;


	DPF(7, "Entering PRV_EnumSessions");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			this, lpsd, dwTimeout, dwFlags);

	ASSERT(this);
	ASSERT(lpsd);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Call the EnumSessions method in the SP
	if(CALLBACK_EXISTS(EnumSessions))
	{
		// Clear our stack-based structure
		memset(&esd, 0, sizeof(SPDATA_ENUMSESSIONS));

		// Set up the structure and call the callback
		esd.dwSize = sizeof(SPDATA_ENUMSESSIONS);
		esd.lpISP = PRV_GetDPLobbySPInterface(this);
		esd.lpsd = lpsd;
		esd.dwTimeout = dwTimeout;
		esd.dwFlags = dwFlags;

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, EnumSessions, &esd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// EnumSessions is required
		// REVIEW!!!! -- What error should we return here????
		DPF_ERR("The Lobby Provider callback for EnumSessions doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
	}

	if(FAILED(hr)) 
	{
		DPF_ERR("Could not invoke EnumSessions in the Service Provider");
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_EnumSessions



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_EnumSessionsResponse"
HRESULT DPLAPI DPLP_EnumSessionsResponse(LPDPLOBBYSP lpDPLSP,
						LPSPDATA_ENUMSESSIONSRESPONSE lpr)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPMSG_ENUMSESSIONSREPLY	lpBuffer = NULL;
	LPBYTE					lpIndex = NULL;
	DWORD					dwNameLength, dwMessageSize;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_EnumSessionsResponse");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDPLSP, lpr);

	//	Make sure the SP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpDPLSP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("SP passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpr)
		{
			DPF_ERR("SPDATA_ENUMSESSIONSRESPONSE structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// REVIEW!!!! -- Can we put this packing code that's duplicated
	// from dplay into a single function???
	dwNameLength =  WSTRLEN_BYTES(lpr->lpsd->lpszSessionName);

	// Calculate the size of the message to send back to dplay
	dwMessageSize = sizeof(MSG_ENUMSESSIONSREPLY);
	dwMessageSize +=  dwNameLength;

	lpBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!lpBuffer) 
	{
		DPF(2, "Unable to allocate memory for EnumSessions request");
		return DPERR_OUTOFMEMORY;
	}

	// Set up the message
	SET_MESSAGE_HDR(lpBuffer);
    SET_MESSAGE_COMMAND(lpBuffer, DPSP_MSG_ENUMSESSIONSREPLY);
    lpBuffer->dpDesc =  *(lpr->lpsd);

	// Pack strings on end
	lpIndex = (LPBYTE)lpBuffer+sizeof(MSG_ENUMSESSIONSREPLY);
	if(dwNameLength) 
	{
		memcpy(lpIndex, lpr->lpsd->lpszSessionName, dwNameLength);
		lpBuffer->dwNameOffset = sizeof(MSG_ENUMSESSIONSREPLY);
	}

	// set string pointers to NULL - they must be set at client
	lpBuffer->dpDesc.lpszPassword = NULL;
	lpBuffer->dpDesc.lpszSessionName = NULL;

	// Now send it to dplay
	ENTER_DPLAY();
	hr = HandleEnumSessionsReply(this->lpDPlayObject, (LPBYTE)lpBuffer, NULL);
	LEAVE_DPLAY();

	// Free our buffer
	DPMEM_FREE(lpBuffer);

	return hr;

} // DPLP_EnumSessionsResponse



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_Open"
HRESULT DPLAPI PRV_Open(LPDPLOBBYI_DPLOBJECT this, LPDPSESSIONDESC2 lpsd,
				DWORD dwFlags, LPCDPCREDENTIALS lpCredentials)
{
	SPDATA_OPEN		od;
	HRESULT			hr = DP_OK;


	DPF(7, "Entering PRV_Open");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			this, lpsd, dwFlags, lpCredentials);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		// We cannot host a lobby session
		if(dwFlags & DPOPEN_CREATE)
		{
			DPF_ERR("Cannot host a lobby session");
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA structure
	memset(&od, 0, sizeof(SPDATA_OPEN));
	od.dwSize = sizeof(SPDATA_OPEN);
	od.lpsd = lpsd;
	od.dwFlags = dwFlags;
	od.lpCredentials = lpCredentials;

	// Call the ConnectServer method in the SP
	if(CALLBACK_EXISTS(Open))
	{
		od.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, Open, &od);
		ENTER_DPLOBBY();
	}
	else 
	{
		// Open is required
		DPF_ERR("The Lobby Provider callback for Open doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_Open
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\lobbysp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       lobbysp.h
 *  Content:    DirectPlayLobby data structures for Service Providers
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	====		==		======
 *	7/23/96		myronth	Created it
 *	10/23/96	myronth	Added IDPLobbySP interface stuff
 *	10/28/96	myronth	Changed to DX5 methods
 *	11/20/96	myronth	Added DPLOGONINFO to LogonServer data
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	3/12/97		myronth	Implemented EnumSessions, Removed Open & Close Responses
 *	3/13/97		myronth	Added link to global DPlay SP count (imported)
 *	3/17/97		myronth	Create/DestroyGroup/Player, Removed unnecessary
 *						Enum functions & structures
 *	3/21/97		myronth	SetGroup/PlayerName, Get/SetGroup/PlayerData, Removed
 *						more unnecessary response functions
 *	3/31/97		myronth	Removed dead code, Added new IDPLobbySP method structs
 *	4/4/97		myronth	Added new IDPLobbySP method structures
 *	4/9/97		myronth	Cleaned up SPINIT structure elements, Added
 *						GetCaps and GetPlayerCaps
 *	5/8/97		myronth	Subgroup methods, GroupConnSettings, StartSession
 *	5/13/97		myronth	Added Credentials to Open data struct
 *	5/17/97		myronth	SendChatMessage callback functions, structs, etc.
 *	5/23/97		myronth	Removed dwPlayerToID from the SPDATA structs
 *	6/3/97		myronth	Added dwPlayerFlags to SPDATA_ADDREMOTEPLAYERTOGROUP
 *	6/5/97		myronth	Added parent to SPDATA_ADDREMOTEPLAYERTOGROUP and
 *						added SPDATA_BUILDPARENTALHEIRARCHY message & structs
 *	7/30/97		myronth	Added dwFlags member to SPDATA_HANDLEMESSAGE
 *	10/3/97		myronth	Added dwDPlayVersion to DPLSPInit data struct
 *						Added player & group data to several remote structs
 *						Bumped version to DX6 (#12667)
 *	10/8/97		myronth	Rolled back the fix to #10961 which added lpData and
 *						dwDataSize to all remote structs -- It's not needed
 *	10/29/97	myronth	Added support for group owner and it's methods
 *	11/6/97		myronth	Added version existence flag and dwReserved values
 *						to SPDATA_INIT (#12916, #12917)
 *	12/29/97	myronth	Fixed DX6 macros (#15739)
 *@@END_MSINTERNAL
 ***************************************************************************/
#ifndef __LOBBYSP_INCLUDED__
#define __LOBBYSP_INCLUDED__

#include "dplobby.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


/*
 * gdwDPlaySPRefCount
 *
 * To ensure that the DPLAYX.DLL will not be unloaded before the lobby
 * provider, the lobby provider should statically link to DPLAYX.LIB and
 * increment this global during the DPLSPInit call and decrement this global
 * during Shutdown.
 */
extern __declspec(dllimport) DWORD gdwDPlaySPRefCount;


// A few forward declarations
typedef struct SPDATA_ADDGROUPTOGROUP * LPSPDATA_ADDGROUPTOGROUP;
typedef struct SPDATA_ADDPLAYERTOGROUP *LPSPDATA_ADDPLAYERTOGROUP;
typedef struct SPDATA_ADDREMOTEGROUPTOGROUP *LPSPDATA_ADDREMOTEGROUPTOGROUP;
typedef struct SPDATA_ADDREMOTEPLAYERTOGROUP *LPSPDATA_ADDREMOTEPLAYERTOGROUP;
typedef struct SPDATA_BUILDPARENTALHEIRARCHY *LPSPDATA_BUILDPARENTALHEIRARCHY;
typedef struct SPDATA_CHATMESSAGE *LPSPDATA_CHATMESSAGE;
typedef struct SPDATA_CLOSE *LPSPDATA_CLOSE;
typedef struct SPDATA_CREATEGROUP *LPSPDATA_CREATEGROUP;
typedef struct SPDATA_CREATEGROUPINGROUP *LPSPDATA_CREATEGROUPINGROUP;
typedef struct SPDATA_CREATEREMOTEGROUP *LPSPDATA_CREATEREMOTEGROUP;
typedef struct SPDATA_CREATEREMOTEGROUPINGROUP *LPSPDATA_CREATEREMOTEGROUPINGROUP;
typedef struct SPDATA_CREATEPLAYER *LPSPDATA_CREATEPLAYER;
typedef struct SPDATA_DELETEGROUPFROMGROUP * LPSPDATA_DELETEGROUPFROMGROUP;
typedef struct SPDATA_DELETEPLAYERFROMGROUP *LPSPDATA_DELETEPLAYERFROMGROUP;
typedef struct SPDATA_DELETEREMOTEGROUPFROMGROUP *LPSPDATA_DELETEREMOTEGROUPFROMGROUP;
typedef struct SPDATA_DELETEREMOTEPLAYERFROMGROUP *LPSPDATA_DELETEREMOTEPLAYERFROMGROUP;
typedef struct SPDATA_DESTROYGROUP *LPSPDATA_DESTROYGROUP;
typedef struct SPDATA_DESTROYREMOTEGROUP *LPSPDATA_DESTROYREMOTEGROUP;
typedef struct SPDATA_DESTROYPLAYER *LPSPDATA_DESTROYPLAYER;
typedef struct SPDATA_ENUMSESSIONS *LPSPDATA_ENUMSESSIONS;
typedef struct SPDATA_ENUMSESSIONSRESPONSE * LPSPDATA_ENUMSESSIONSRESPONSE;
typedef struct SPDATA_GETCAPS *LPSPDATA_GETCAPS;
typedef struct SPDATA_GETGROUPCONNECTIONSETTINGS *LPSPDATA_GETGROUPCONNECTIONSETTINGS;
typedef struct SPDATA_GETGROUPDATA *LPSPDATA_GETGROUPDATA;
typedef struct SPDATA_GETPLAYERCAPS *LPSPDATA_GETPLAYERCAPS;
typedef struct SPDATA_GETPLAYERDATA *LPSPDATA_GETPLAYERDATA;
typedef struct SPDATA_HANDLEMESSAGE *LPSPDATA_HANDLEMESSAGE;
typedef struct SPDATA_OPEN *LPSPDATA_OPEN;
typedef struct SPDATA_SEND *LPSPDATA_SEND;
typedef struct SPDATA_SETGROUPDATA *LPSPDATA_SETGROUPDATA;
typedef struct SPDATA_SETGROUPNAME *LPSPDATA_SETGROUPNAME;
typedef struct SPDATA_SETGROUPOWNER *LPSPDATA_SETGROUPOWNER;
typedef struct SPDATA_SETREMOTEGROUPNAME *LPSPDATA_SETREMOTEGROUPNAME;
typedef struct SPDATA_SETREMOTEGROUPOWNER *LPSPDATA_SETREMOTEGROUPOWNER;
typedef struct SPDATA_SETGROUPCONNECTIONSETTINGS *LPSPDATA_SETGROUPCONNECTIONSETTINGS;
typedef struct SPDATA_SETPLAYERDATA *LPSPDATA_SETPLAYERDATA;
typedef struct SPDATA_SETPLAYERNAME *LPSPDATA_SETPLAYERNAME;
typedef struct SPDATA_SETREMOTEPLAYERNAME *LPSPDATA_SETREMOTEPLAYERNAME;
typedef struct SPDATA_SETSESSIONDESC *LPSPDATA_SETSESSIONDESC;
typedef struct SPDATA_SHUTDOWN *LPSPDATA_SHUTDOWN;
typedef struct SPDATA_STARTSESSION *LPSPDATA_STARTSESSION;
typedef struct SPDATA_STARTSESSIONCOMMAND *LPSPDATA_STARTSESSIONCOMMAND;


/*
 *	IDPLobbySP
 *
 *	Lobby Service Providers are passed an IDPLobbySP interface
 *	in the LobbySPInit method. This interface is used to call
 *	back into DirectPlayLobby.
 */
struct IDPLobbySP;
typedef struct IDPLobbySP FAR* LPDPLOBBYSP;

#undef INTERFACE
#define INTERFACE IDPLobbySP
DECLARE_INTERFACE_( IDPLobbySP, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)               (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;
    /*** IDPLobbySP methods ***/
	STDMETHOD(AddGroupToGroup)              (THIS_ LPSPDATA_ADDREMOTEGROUPTOGROUP) PURE;
	STDMETHOD(AddPlayerToGroup)             (THIS_ LPSPDATA_ADDREMOTEPLAYERTOGROUP) PURE;
	STDMETHOD(CreateGroup)                  (THIS_ LPSPDATA_CREATEREMOTEGROUP) PURE;
	STDMETHOD(CreateGroupInGroup)           (THIS_ LPSPDATA_CREATEREMOTEGROUPINGROUP) PURE;
	STDMETHOD(DeleteGroupFromGroup)         (THIS_ LPSPDATA_DELETEREMOTEGROUPFROMGROUP) PURE;
	STDMETHOD(DeletePlayerFromGroup)        (THIS_ LPSPDATA_DELETEREMOTEPLAYERFROMGROUP) PURE;
	STDMETHOD(DestroyGroup)                 (THIS_ LPSPDATA_DESTROYREMOTEGROUP) PURE;
	STDMETHOD(EnumSessionsResponse)	        (THIS_ LPSPDATA_ENUMSESSIONSRESPONSE) PURE;
	STDMETHOD(GetSPDataPointer)		        (THIS_ LPVOID *) PURE;
	STDMETHOD(HandleMessage)				(THIS_ LPSPDATA_HANDLEMESSAGE) PURE;
	STDMETHOD(SendChatMessage)              (THIS_ LPSPDATA_CHATMESSAGE) PURE;
	STDMETHOD(SetGroupName)                 (THIS_ LPSPDATA_SETREMOTEGROUPNAME) PURE;
	STDMETHOD(SetPlayerName)                (THIS_ LPSPDATA_SETREMOTEPLAYERNAME) PURE;
	STDMETHOD(SetSessionDesc)               (THIS_ LPSPDATA_SETSESSIONDESC) PURE;
	STDMETHOD(SetSPDataPointer)		        (THIS_ LPVOID) PURE;
	STDMETHOD(StartSession)                 (THIS_ LPSPDATA_STARTSESSIONCOMMAND) PURE;
    /*** Methods added for DX6 ***/
    STDMETHOD(CreateCompoundAddress)        (THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(EnumAddress)                  (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
	STDMETHOD(SetGroupOwner)				(THIS_ LPSPDATA_SETREMOTEGROUPOWNER) PURE;
};

/*
 * GUID for IDPLobbySP
 */
// IID_IDPLobbySP	{5A4E5A20-2CED-11d0-A889-00A0C905433C}
DEFINE_GUID(IID_IDPLobbySP, 0x5a4e5a20, 0x2ced, 0x11d0, 0xa8, 0x89, 0x0, 0xa0, 0xc9, 0x5, 0x43, 0x3c);

/*
 * Major version number for service provider.
 *
 * The most-significant 16 bits are reserved for the DirectPlay
 * major version number. The least-significant 16 bits are for
 * use by the service provider.
 */
#define DPLSP_MAJORVERSION               0x00060000

// Major version used by DX5
#define DPLSP_DX5VERSION                 0x00050000

// Size of the SPDATA_INIT structure in DX5
#define DPLSP_SIZE_DX5_INIT_STRUCT       (16)

//--------------------------------------------------------------------------
//
//	Service Provider Callback Stuff
//
//--------------------------------------------------------------------------

// Callback prototypes
typedef HRESULT (WINAPI *LPSP_ADDGROUPTOGROUP)(LPSPDATA_ADDGROUPTOGROUP);
typedef HRESULT	(WINAPI *LPSP_ADDPLAYERTOGROUP)(LPSPDATA_ADDPLAYERTOGROUP);
typedef HRESULT	(WINAPI *LPSP_BUILDPARENTALHEIRARCHY)(LPSPDATA_BUILDPARENTALHEIRARCHY);
typedef HRESULT	(WINAPI *LPSP_CLOSE)(LPSPDATA_CLOSE);
typedef HRESULT	(WINAPI *LPSP_CREATEGROUP)(LPSPDATA_CREATEGROUP);
typedef HRESULT (WINAPI *LPSP_CREATEGROUPINGROUP)(LPSPDATA_CREATEGROUPINGROUP);
typedef HRESULT	(WINAPI *LPSP_CREATEPLAYER)(LPSPDATA_CREATEPLAYER);
typedef HRESULT (WINAPI *LPSP_DELETEGROUPFROMGROUP)(LPSPDATA_DELETEGROUPFROMGROUP);
typedef HRESULT	(WINAPI *LPSP_DELETEPLAYERFROMGROUP)(LPSPDATA_DELETEPLAYERFROMGROUP);
typedef HRESULT	(WINAPI *LPSP_DESTROYGROUP)(LPSPDATA_DESTROYGROUP);
typedef HRESULT	(WINAPI *LPSP_DESTROYPLAYER)(LPSPDATA_DESTROYPLAYER);
typedef HRESULT	(WINAPI *LPSP_ENUMSESSIONS)(LPSPDATA_ENUMSESSIONS);
typedef HRESULT (WINAPI *LPSP_GETCAPS)(LPSPDATA_GETCAPS);
typedef HRESULT (WINAPI *LPSP_GETGROUPCONNECTIONSETTINGS)(LPSPDATA_GETGROUPCONNECTIONSETTINGS);
typedef HRESULT	(WINAPI *LPSP_GETGROUPDATA)(LPSPDATA_GETGROUPDATA);
typedef HRESULT (WINAPI *LPSP_GETPLAYERCAPS)(LPSPDATA_GETPLAYERCAPS);
typedef HRESULT	(WINAPI *LPSP_GETPLAYERDATA)(LPSPDATA_GETPLAYERDATA);
typedef HRESULT	(WINAPI *LPSP_HANDLEMESSAGE)(LPSPDATA_HANDLEMESSAGE);
typedef HRESULT	(WINAPI *LPSP_OPEN)(LPSPDATA_OPEN);
typedef HRESULT	(WINAPI *LPSP_SEND)(LPSPDATA_SEND);
typedef HRESULT	(WINAPI *LPSP_SENDCHATMESSAGE)(LPSPDATA_CHATMESSAGE);
typedef HRESULT (WINAPI *LPSP_SETGROUPCONNECTIONSETTINGS)(LPSPDATA_SETGROUPCONNECTIONSETTINGS);
typedef HRESULT	(WINAPI *LPSP_SETGROUPDATA)(LPSPDATA_SETGROUPDATA);
typedef HRESULT	(WINAPI *LPSP_SETGROUPNAME)(LPSPDATA_SETGROUPNAME);
typedef HRESULT	(WINAPI *LPSP_SETGROUPOWNER)(LPSPDATA_SETGROUPOWNER);
typedef HRESULT	(WINAPI *LPSP_SETPLAYERDATA)(LPSPDATA_SETPLAYERDATA);
typedef HRESULT	(WINAPI *LPSP_SETPLAYERNAME)(LPSPDATA_SETPLAYERNAME);
typedef HRESULT	(WINAPI *LPSP_SHUTDOWN)(LPSPDATA_SHUTDOWN);
typedef HRESULT (WINAPI *LPSP_STARTSESSION)(LPSPDATA_STARTSESSION);

// Callback table for dplay to call into service provider
typedef struct SP_CALLBACKS
{
    DWORD								dwSize;
    DWORD								dwDPlayVersion;
    LPSP_ADDGROUPTOGROUP				AddGroupToGroup;
	LPSP_ADDPLAYERTOGROUP				AddPlayerToGroup;
	LPSP_BUILDPARENTALHEIRARCHY			BuildParentalHeirarchy;
	LPSP_CLOSE							Close;
    LPSP_CREATEGROUP					CreateGroup;
	LPSP_CREATEGROUPINGROUP				CreateGroupInGroup;
	LPSP_CREATEPLAYER					CreatePlayer;
    LPSP_DELETEGROUPFROMGROUP			DeleteGroupFromGroup;
	LPSP_DELETEPLAYERFROMGROUP			DeletePlayerFromGroup;
    LPSP_DESTROYGROUP					DestroyGroup;
	LPSP_DESTROYPLAYER					DestroyPlayer;
	LPSP_ENUMSESSIONS					EnumSessions;
	LPSP_GETCAPS						GetCaps;
	LPSP_GETGROUPCONNECTIONSETTINGS		GetGroupConnectionSettings;
	LPSP_GETGROUPDATA					GetGroupData;
	LPSP_GETPLAYERCAPS					GetPlayerCaps;
	LPSP_GETPLAYERDATA					GetPlayerData;
	LPSP_OPEN							Open;
	LPSP_SEND							Send;
	LPSP_SENDCHATMESSAGE				SendChatMessage;
	LPSP_SETGROUPCONNECTIONSETTINGS		SetGroupConnectionSettings;
	LPSP_SETGROUPDATA					SetGroupData;
	LPSP_SETGROUPNAME					SetGroupName;
	LPSP_SETPLAYERDATA					SetPlayerData;
	LPSP_SETPLAYERNAME					SetPlayerName;
	LPSP_SHUTDOWN						Shutdown;
	LPSP_STARTSESSION					StartSession;
	LPSP_SETGROUPOWNER					SetGroupOwner;
} SP_CALLBACKS, * LPSP_CALLBACKS;             


// CALLBACK DATA STRUCTURES. These are passed by DPLAY to the sp when
// the callback is invoked
typedef struct SPDATA_ADDGROUPTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the parent group
	DWORD			dwGroupID;		// ID of the new group to be created (output param)
} SPDATA_ADDGROUPTOGROUP;

typedef struct SPDATA_ADDPLAYERTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwPlayerID;		// ID of the player
} SPDATA_ADDPLAYERTOGROUP;

typedef struct SPDATA_ADDREMOTEGROUPTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwAnchorID;		// ID of the anchor group (group the shortcut is added to)
	DWORD			dwGroupID;		// ID of the group the shortcut references
	DWORD			dwParentID;		// ID of the group's parent (not the group being added to)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	DWORD			dwGroupFlags;	// Group flags for the group the shortcut references
	DWORD			dwGroupOwnerID;	// ID of the owner of the group the shortcut references
} SPDATA_ADDREMOTEGROUPTOGROUP;

typedef struct SPDATA_ADDREMOTEPLAYERTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwPlayerID;		// ID of the player
	DWORD			dwPlayerFlags;	// Player flags
	LPDPNAME		lpName;			// Name of the player
} SPDATA_ADDREMOTEPLAYERTOGROUP;

typedef struct SPDATA_BUILDPARENTALHEIRARCHY
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group to build the heirarchy for
	DWORD			dwMessage;		// Message type the lobby errored on
	DWORD			dwParentID;		// ID of the parent (for an AddGroupToGroup call)
} SPDATA_BUILDPARENTALHEIRARCHY;

typedef struct SPDATA_CLOSE
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
} SPDATA_CLOSE;

typedef struct SPDATA_CREATEGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group (output parameter)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreateGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEGROUP;

typedef struct SPDATA_CREATEGROUPINGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the parent group
	DWORD			dwGroupID;		// ID of the new group to be created (output param)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreateGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEGROUPINGROUP;

typedef struct SPDATA_CREATEREMOTEGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group (output parameter)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreateGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEREMOTEGROUP;

typedef struct SPDATA_CREATEREMOTEGROUPINGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the parent group
	DWORD			dwGroupID;		// ID of the new group to be created (output param)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	DWORD			dwFlags;		// CreateGroupInGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEREMOTEGROUPINGROUP;

typedef struct SPDATA_CREATEPLAYER
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the group (output parameter)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreatePlayer flags
} SPDATA_CREATEPLAYER;

typedef struct SPDATA_DELETEGROUPFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the Parent Group
	DWORD			dwGroupID;		// ID of the Group to be deleted
} SPDATA_DELETEGROUPFROMGROUP;

typedef struct SPDATA_DELETEPLAYERFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	DWORD			dwPlayerID;		// ID of the Player
} SPDATA_DELETEPLAYERFROMGROUP;

typedef struct SPDATA_DELETEREMOTEGROUPFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the Parent Group
	DWORD			dwGroupID;		// ID of the Group to be deleted
} SPDATA_DELETEREMOTEGROUPFROMGROUP;

typedef struct SPDATA_DELETEREMOTEPLAYERFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	DWORD			dwPlayerID;		// ID of the Player
} SPDATA_DELETEREMOTEPLAYERFROMGROUP;

typedef struct SPDATA_DESTROYGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the player on the lobby
} SPDATA_DESTROYGROUP;

typedef struct SPDATA_DESTROYREMOTEGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the player on the lobby
} SPDATA_DESTROYREMOTEGROUP;

typedef struct SPDATA_DESTROYPLAYER
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player on the lobby
} SPDATA_DESTROYPLAYER;

typedef struct SPDATA_ENUMSESSIONS
{
	DWORD				dwSize;		// Size of this structure
	LPDPLOBBYSP			lpISP;		// Pointer to an IDPLobbySP interface
	LPDPSESSIONDESC2	lpsd;		// SessionDesc to enumerate on
	DWORD               dwTimeout;	// Timeout value
	DWORD               dwFlags;	// Flags
} SPDATA_ENUMSESSIONS;

typedef struct SPDATA_ENUMSESSIONSRESPONSE
{
	DWORD				dwSize;		// Size of this structure
	LPDPSESSIONDESC2	lpsd;		// SessionDesc returned by server
} SPDATA_ENUMSESSIONSRESPONSE;

typedef struct SPDATA_GETCAPS
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFlags;		// Flags
	LPDPCAPS		lpcaps;			// Pointer to DPCAPS structure
} SPDATA_GETCAPS;

typedef struct SPDATA_GETGROUPCONNECTIONSETTINGS
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwFlags;		// Flags
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	LPDWORD			lpdwBufferSize;	// Pointer to the size of the buffer
	LPVOID			lpBuffer;		// Pointer to a buffer
} SPDATA_GETGROUPCONNECTIONSETTINGS;

typedef struct SPDATA_GETGROUPDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	LPDWORD			lpdwDataSize;	// Pointer to the size of the lpData buffer
	LPVOID			lpData;			// Pointer to a data buffer
} SPDATA_GETGROUPDATA;

typedef struct SPDATA_GETPLAYERCAPS
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFlags;		// Flags
	DWORD			dwPlayerID;		// ID of the Player
	LPDPCAPS		lpcaps;			// Pointer to DPCAPS structure
} SPDATA_GETPLAYERCAPS;

typedef struct SPDATA_GETPLAYERDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the Player
	LPDWORD			lpdwDataSize;	// Pointer to the size of the lpData buffer
	LPVOID			lpData;			// Pointer to a data buffer
} SPDATA_GETPLAYERDATA;

typedef struct SPDATA_HANDLEMESSAGE
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwFromID;		// ID of the player from
	DWORD			dwToID;			// ID of the player to
	LPVOID			lpBuffer;		// Message buffer
	DWORD			dwBufSize;		// Size of the message buffer
	DWORD			dwFlags;		// Message flags
} SPDATA_HANDLEMESSAGE;

typedef struct SPDATA_OPEN
{
	DWORD				dwSize;		// Size of this structure (including data)
	LPDPLOBBYSP			lpISP;	    // Pointer to an IDPLobbySP interface
	LPDPSESSIONDESC2	lpsd;		// Pointer to SessionDesc of the Lobby to open
	DWORD				dwFlags;	// Flags
	LPCDPCREDENTIALS	lpCredentials;	// Pointer to a Credentials structure
} SPDATA_OPEN;

typedef struct SPDATA_SEND
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFromID;		// ID of the player from
	DWORD			dwToID;			// ID of the player to
	DWORD			dwFlags;		// Flags
	LPVOID			lpBuffer;		// Message buffer
	DWORD			dwBufSize;		// Size of the message buffer
} SPDATA_SEND;

typedef struct SPDATA_CHATMESSAGE
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFromID;		// ID of the player from
	DWORD			dwToID;			// ID of the player to
	DWORD			dwFlags;		// Send Flags
	LPDPCHAT		lpChat;			// Pointer to a DPCHAT structure
} SPDATA_CHATMESSAGE;

typedef struct SPDATA_SETGROUPCONNECTIONSETTINGS
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwFlags;		// Flags
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPDPLCONNECTION	lpConn;			// Pointer to a DPLCONNECTION structure
} SPDATA_SETGROUPCONNECTIONSETTINGS;

typedef struct SPDATA_SETGROUPDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPVOID			lpData;			// Pointer to the new group data
	DWORD			dwDataSize;		// Size of lpData
	DWORD			dwFlags;		// Flags
} SPDATA_SETGROUPDATA;

typedef struct SPDATA_SETGROUPNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETGROUPNAME;

typedef struct SPDATA_SETREMOTEGROUPNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETREMOTEGROUPNAME;

typedef struct SPDATA_SETGROUPOWNER
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwOwnerID;		// ID of the group's owner
} SPDATA_SETGROUPOWNER;

typedef struct SPDATA_SETREMOTEGROUPOWNER
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwOwnerID;		// ID of the group's owner
} SPDATA_SETREMOTEGROUPOWNER;

typedef struct SPDATA_SETPLAYERDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player
	LPVOID			lpData;			// Pointer to the new player data
	DWORD			dwDataSize;		// Size of lpData
	DWORD			dwFlags;		// Flags
} SPDATA_SETPLAYERDATA;

typedef struct SPDATA_SETPLAYERNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETPLAYERNAME;

typedef struct SPDATA_SETREMOTEPLAYERNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETREMOTEPLAYERNAME;

typedef struct SPDATA_SETSESSIONDESC
{
	DWORD				dwSize;		// Size of this structure
	LPDPSESSIONDESC2	lpsd;		// Pointer to a SessionDesc struct
	LPDPLOBBYSP			lpISP;		// Pointer to an IDPLobbySP interface
} SPDATA_SETSESSIONDESC;

typedef struct SPDATA_SHUTDOWN
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
} SPDATA_SHUTDOWN;

typedef struct SPDATA_STARTSESSION
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFlags;		// Flags
	DWORD			dwGroupID;		// ID of the group who's session to start
} SPDATA_STARTSESSION;

typedef struct SPDATA_STARTSESSIONCOMMAND
{
	DWORD			dwFlags;		// Flags
	DWORD			dwGroupID;		// Group ID of the group to start the session on
	DWORD			dwHostID;		// ID of the host player for the session
	LPDPLCONNECTION	lpConn;			// Pointer to a DPLCONNECTION struct for the session information
} SPDATA_STARTSESSIONCOMMAND;

// Data structure passed to the service provider at DPLSPInit
typedef struct SPDATA_INIT 
{
	LPSP_CALLBACKS      lpCB;			// Lobby Provider fills in entry points
    DWORD               dwSPVersion;	// Lobby provider fills in version number 16 | 16 , major | minor version 
	LPDPLOBBYSP         lpISP;			// DPLobbySP interface pointer
	LPDPADDRESS			lpAddress;		// DPADDRESS of the Lobby (partial or complete)
	DWORD				dwReserved1;	// Reserved DWORD from the registry entry for the LP
	DWORD				dwReserved2;	// Reserved DWORD from the registry entry for the LP
} SPDATA_INIT, * LPSPDATA_INIT;

// This is the function that DPLobby calls to
// get the SP to fill in callbacks
typedef HRESULT (WINAPI *LPSP_INIT)(LPSPDATA_INIT);
HRESULT WINAPI DPLSPInit(LPSPDATA_INIT);


/****************************************************************************
 *
 * IDirectPlayLobby interface macros
 *
 ****************************************************************************/


#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDPLobbySP_QueryInterface(p,a,b)         (p)->lpVtbl->QueryInterface(p,a,b)
#define IDPLobbySP_AddRef(p)                     (p)->lpVtbl->AddRef(p)
#define IDPLobbySP_Release(p)                    (p)->lpVtbl->Release(p)
#define IDPLobbySP_AddGroupToGroup(p,a)          (p)->lpVtbl->AddGroupToGroup(p,a)
#define IDPLobbySP_AddPlayerToGroup(p,a)         (p)->lpVtbl->AddPlayerToGroup(p,a)
#define IDPLobbySP_CreateCompoundAddress(p,a,b,c,d) (p)->lpVtbl->CreateCompoundAddress(p,a,b,c,d)
#define IDPLobbySP_CreateGroup(p,a)              (p)->lpVtbl->CreateGroup(p,a)
#define IDPLobbySP_CreateGroupInGroup(p,a)       (p)->lpVtbl->CreateGroupInGroup(p,a)
#define IDPLobbySP_DeleteGroupFromGroup(p,a)     (p)->lpVtbl->DeleteGroupFromGroup(p,a)
#define IDPLobbySP_DeletePlayerFromGroup(p,a)    (p)->lpVtbl->DeletePlayerFromGroup(p,a)
#define IDPLobbySP_DestroyGroup(p,a)             (p)->lpVtbl->DestroyGroup(p,a)
#define IDPLobbySP_EnumAddress(p,a,b,c,d)        (p)->lpVtbl->EnumAddress(p,a,b,c,d)
#define IDPLobbySP_EnumSessionsResponse(p,a)     (p)->lpVtbl->EnumSessionsResponse(p,a)
#define IDPLobbySP_GetSPDataPointer(p,a)         (p)->lpVtbl->GetSPDataPointer(p,a)
#define IDPLobbySP_HandleMessage(p,a)            (p)->lpVtbl->HandleMessage(p,a)
#define IDPLobbySP_SetGroupName(p,a)             (p)->lpVtbl->SetGroupName(p,a)
#define IDPLobbySP_SetPlayerName(p,a)            (p)->lpVtbl->SetPlayerName(p,a)
#define IDPLobbySP_SetSessionDesc(p,a)           (p)->lpVtbl->SetSessionDesc(p,a)
#define IDPLobbySP_StartSession(p,a)             (p)->lpVtbl->StartSession(p,a)
#define IDPLobbySP_SetGroupOwner(p,a)            (p)->lpVtbl->SetGroupOwner(p,a)
#define IDPLobbySP_SetSPDataPointer(p,a)         (p)->lpVtbl->SetSPDataPointer(p,a)

#else /* C++ */

#define IDPLobbySP_QueryInterface(p,a,b)         (p)->QueryInterface(a,b)
#define IDPLobbySP_AddRef(p)                     (p)->AddRef()
#define IDPLobbySP_Release(p)                    (p)->Release()
#define IDPLobbySP_AddGroupToGroup(p,a)          (p)->AddGroupToGroup(a)
#define IDPLobbySP_AddPlayerToGroup(p,a)         (p)->AddPlayerToGroup(a)
#define IDPLobbySP_CreateCompoundAddress(p,a,b,c,d) (p)->CreateCompoundAddress(a,b,c,d)
#define IDPLobbySP_CreateGroup(p,a)              (p)->CreateGroup(a)
#define IDPLobbySP_CreateGroupInGroup(p,a)       (p)->CreateGroupInGroup(a)
#define IDPLobbySP_DeleteGroupFromGroup(p,a)     (p)->DeleteGroupFromGroup(a)
#define IDPLobbySP_DeletePlayerFromGroup(p,a)    (p)->DeletePlayerFromGroup(a)
#define IDPLobbySP_DestroyGroup(p,a)             (p)->DestroyGroup(a)
#define IDPLobbySP_EnumAddress(p,a,b,c,d)        (p)->EnumAddress(a,b,c,d)
#define IDPLobbySP_EnumSessionsResponse(p,a)     (p)->EnumSessionsResponse(a)
#define IDPLobbySP_GetSPDataPointer(p,a)         (p)->GetSPDataPointer(a)
#define IDPLobbySP_HandleMessage(p,a)            (p)->HandleMessage(a)
#define IDPLobbySP_SetGroupName(p,a)             (p)->SetGroupName(a)
#define IDPLobbySP_SetPlayerName(p,a)            (p)->SetPlayerName(a)
#define IDPLobbySP_SetSessionDesc(p,a)           (p)->SetSessionDesc(a)
#define IDPLobbySP_StartSession(p,a)             (p)->StartSession(a)
#define IDPLobbySP_SetGroupOwner(p,a)            (p)->SetGroupOwner(a)
#define IDPLobbySP_SetSPDataPointer(p,a)         (p)->SetSPDataPointer(a)

#endif /* C or C++ */


#ifdef __cplusplus
};
#endif // __cplusplus

#endif // __LOBBYSP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\player.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       player.c
 *  Content:	Methods for player management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	2/27/97		myronth	Created it
 *	3/17/97		myronth	Create/DestroyPlayer, Removed unnecessary Enum fn's
 *	3/21/97		myronth	SetPlayerName, Get/SetPlayerData, Removed more
 *						unnecessary functions
 *	3/25/97		myronth	Fixed GetPlayer prototype (1 new parameter)
 *	3/31/97		myronth	Removed dead code, Implemented Send, Added
 *						CreateAndMapNewPlayer function
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	4/10/97		myronth	Added support for GetPlayerCaps
 *	5/8/97		myronth	Drop lobby lock when calling LP, Propagate player's
 *						receive event on CreatePlayer call
 *	5/12/97		myronth	Handle remote players properly, create a lobby
 *						system player for all remote players & groups
 *	5/17/97		myronth	SendChatMessage
 *	5/20/97		myronth	Made AddPlayerToGroup & DeletePlayerFromGroup return
 *						DPERR_ACCESSDENIED on remote players (#8679),
 *						Fixed a bunch of other lock bugs, Changed debug levels
 *	6/3/97		myronth	Added support for player flags in CreatePlayer
 *	9/29/97		myronth	Send local SetPlayerName/Data msgs after call to
 *						lobby server succeeds (#12554)
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreatePlayer"
HRESULT DPLAPI PRV_CreatePlayer(LPDPLOBBYI_DPLOBJECT this, LPDPID lpidPlayer,
						LPDPNAME lpName, HANDLE hEvent, LPVOID lpData,
						DWORD dwDataSize, DWORD dwFlags)
{
	SPDATA_CREATEPLAYER		cp;
	HRESULT					hr = DP_OK;
	DWORD					dwPlayerFlags;


	DPF(7, "Entering PRV_CreatePlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x",
			this, lpidPlayer, lpName, hEvent, lpData, dwDataSize, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&cp, 0, sizeof(SPDATA_CREATEPLAYER));
	cp.dwSize = sizeof(SPDATA_CREATEPLAYER);
	cp.lpName = lpName;
	cp.lpData = lpData;
	cp.dwDataSize = dwDataSize;
	cp.dwFlags = dwFlags;

	// Call the CreatePlayer method in the SP
	if(CALLBACK_EXISTS(CreatePlayer))
	{
		cp.lpISP = PRV_GetDPLobbySPInterface(this);
	    
		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
		hr = CALL_LP(this, CreatePlayer, &cp);
		ENTER_DPLOBBY();
	}
	else 
	{
		// CreatePlayer is required
		DPF_ERR("The Lobby Provider callback for CreatePlayer doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling CreatePlayer in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}

	// Fix up the player flags
	dwPlayerFlags = DPLAYI_PLAYER_PLAYERLOCAL;
	if(dwFlags & DPPLAYER_SPECTATOR)
		dwPlayerFlags |= DPLAYI_PLAYER_SPECTATOR;

	// Add the player to dplay's nametable and put it in our map table
	hr = PRV_CreateAndMapNewPlayer(this, lpidPlayer, lpName, hEvent, lpData,
			dwDataSize, dwPlayerFlags, cp.dwPlayerID, FALSE);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed creating a new local player, hr = 0x%08x", hr);
		// REVIEW!!!! -- We need to send a message back to the server saying
		// we couldn't complete the deal on our end.
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_CreatePlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyPlayer"
HRESULT DPLAPI PRV_DestroyPlayer(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID)
{
	SPDATA_DESTROYPLAYER	dp;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DestroyPlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, dwLobbyID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwLobbyID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_DESTROYPLAYER;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_DESTROYPLAYER;
	}
	
	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&dp, 0, sizeof(SPDATA_DESTROYPLAYER));
	dp.dwSize = sizeof(SPDATA_DESTROYPLAYER);
	dp.dwPlayerID = dwLobbyID;

	// Call the DestroyPlayer method in the SP
	if(CALLBACK_EXISTS(DestroyPlayer))
	{
		dp.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DestroyPlayer, &dp);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DestroyPlayer is required
		DPF_ERR("The Lobby Provider callback for DestroyPlayer doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_DESTROYPLAYER;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling DestroyPlayer in the Lobby Provider, hr = 0x%08x", hr);
		goto EXIT_DESTROYPLAYER;
	}

	// The dplay InternalDestroyPlayer code will take care of the rest of
	// the internal cleanup (nametable, groups, etc.), so we can just return
	// from here.

EXIT_DESTROYPLAYER:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_DestroyPlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetPlayerCaps"
HRESULT DPLAPI PRV_GetPlayerCaps(LPDPLOBBYI_DPLOBJECT this, DWORD dwFlags,
				DWORD dwPlayerID, LPDPCAPS lpcaps)
{
	SPDATA_GETPLAYERCAPS	gcd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_GetPlayerCaps");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			this, dwFlags, dwPlayerID, lpcaps);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }

	
	// Setup our SPDATA struct
	memset(&gcd, 0, sizeof(SPDATA_GETCAPS));
	gcd.dwSize = sizeof(SPDATA_GETCAPS);
	gcd.dwFlags = dwFlags;
	gcd.dwPlayerID = dwPlayerID;
	gcd.lpcaps = lpcaps;

	// Call the GetPlayerCaps method in the LP
	if(CALLBACK_EXISTS(GetPlayerCaps))
	{
		gcd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetPlayerCaps, &gcd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetPlayerCaps is required
		DPF_ERR("The Lobby Provider callback for GetPlayerCaps doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_GETPLAYERCAPS;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling GetPlayerCaps in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_GETPLAYERCAPS:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetPlayerCaps



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetPlayerData"
HRESULT DPLAPI PRV_GetPlayerData(LPDPLOBBYI_DPLOBJECT this, DWORD dwPlayerID,
					LPVOID lpData, LPDWORD lpdwDataSize)
{
	SPDATA_GETPLAYERDATA	gpd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_GetPlayerData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwPlayerID, lpData, lpdwDataSize);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&gpd, 0, sizeof(SPDATA_GETPLAYERDATA));
	gpd.dwSize = sizeof(SPDATA_GETPLAYERDATA);
	gpd.dwPlayerID = dwPlayerID;
	gpd.lpdwDataSize = lpdwDataSize;
	gpd.lpData = lpData;

	// Call the GetPlayerData method in the SP
	if(CALLBACK_EXISTS(GetPlayerData))
	{
		gpd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetPlayerData, &gpd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetPlayerData is required
		DPF_ERR("The Lobby Provider callback for GetPlayerData doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_GETPLAYERDATA;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling GetPlayerData in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_GETPLAYERDATA:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetPlayerData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_Send"
HRESULT DPLAPI PRV_Send(LPDPLOBBYI_DPLOBJECT this, DWORD dwFromID, DWORD dwToID,
					DWORD dwFlags, LPVOID lpBuffer, DWORD dwBufSize)
{
	SPDATA_SEND		sd;
	HRESULT			hr = DP_OK;


	DPF(7, "Entering PRV_Send");
	DPF(9, "Parameters: 0x%08x, %lu, %lu, 0x%08x, 0x%08x, %lu",
			this, dwFromID, dwToID, dwFlags, lpBuffer, dwBufSize);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA structure
	memset(&sd, 0, sizeof(SPDATA_SEND));
	sd.dwSize = sizeof(SPDATA_SEND);
	sd.dwFromID = dwFromID;
	sd.dwToID = dwToID;
	sd.dwFlags = dwFlags;
	sd.lpBuffer = lpBuffer;
	sd.dwBufSize = dwBufSize;

	// Call the Send method in the SP
	if(CALLBACK_EXISTS(Send))
	{
		sd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, Send, &sd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// Send is required
		DPF_ERR("The Lobby Provider callback for Send doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_Send



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendChatMessage"
HRESULT DPLAPI PRV_SendChatMessage(LPDPLOBBYI_DPLOBJECT this, DWORD dwFromID,
			DWORD dwToID, DWORD dwFlags, LPDPCHAT lpChat)
{
	SPDATA_CHATMESSAGE		sd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_SendChatMessage");
	DPF(9, "Parameters: 0x%08x, %lu, %lu, 0x%08x, 0x%08x",
			this, dwFromID, dwToID, dwFlags, lpChat);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA structure
	memset(&sd, 0, sizeof(SPDATA_CHATMESSAGE));
	sd.dwSize = sizeof(SPDATA_CHATMESSAGE);
	sd.dwFromID = dwFromID;
	sd.dwToID = dwToID;
	sd.dwFlags = dwFlags;
	sd.lpChat = lpChat;

	// Call the SendChatMessage method in the SP
	if(CALLBACK_EXISTS(SendChatMessage))
	{
		sd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SendChatMessage, &sd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SendChatMessage is required
		DPF_ERR("The Lobby Provider callback for SendChatMessage doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SENDCHATMESSAGE;
	}

EXIT_SENDCHATMESSAGE:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SendChatMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetPlayerData"
HRESULT DPLAPI PRV_SetPlayerData(LPDPLOBBYI_DPLOBJECT this, DWORD dwPlayerID,
					LPVOID lpData, DWORD dwDataSize, DWORD dwFlags)
{
	SPDATA_SETPLAYERDATA	spd;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_SetPlayerData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, %lu, 0x%08x",
			this, dwPlayerID, lpData, dwDataSize, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_SETPLAYERDATA;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_SETPLAYERDATA;
	}
	
	// Drop the dplay lock since we're finished
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&spd, 0, sizeof(SPDATA_SETPLAYERDATA));
	spd.dwSize = sizeof(SPDATA_SETPLAYERDATA);
	spd.dwPlayerID = dwPlayerID;
	spd.dwDataSize = dwDataSize;
	spd.lpData = lpData;
	spd.dwFlags = dwFlags;

	// Call the SetPlayerData method in the SP
	if(CALLBACK_EXISTS(SetPlayerData))
	{
		spd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetPlayerData, &spd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetPlayerData is required
		DPF_ERR("The Lobby Provider callback for SetPlayerData doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETPLAYERDATA;
	}

	// If it succeeded, send the SetPlayerData message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendDataChangedMessageLocally(this, dwPlayerID, lpData, dwDataSize);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetPlayerData in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETPLAYERDATA:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetPlayerData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetPlayerName"
HRESULT DPLAPI PRV_SetPlayerName(LPDPLOBBYI_DPLOBJECT this, DWORD dwPlayerID,
					LPDPNAME lpName, DWORD dwFlags)
{
	SPDATA_SETPLAYERNAME	spn;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_SetPlayerName");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwPlayerID, lpName, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_SETPLAYERNAME;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_SETPLAYERNAME;
	}
	
	// Drop the dplay lock since we're finished
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&spn, 0, sizeof(SPDATA_SETPLAYERNAME));
	spn.dwSize = sizeof(SPDATA_SETPLAYERNAME);
	spn.dwPlayerID = dwPlayerID;
	spn.lpName = lpName;
	spn.dwFlags = dwFlags;

	// Call the SetPlayerName method in the SP
	if(CALLBACK_EXISTS(SetPlayerName))
	{
		spn.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetPlayerName, &spn);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetPlayerName is required
		DPF_ERR("The Lobby Provider callback for SetPlayerName doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETPLAYERNAME;
	}

	// If it succeeded, send the SetPlayerName message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendNameChangedMessageLocally(this, dwPlayerID, lpName, TRUE);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetPlayerName in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETPLAYERNAME:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetPlayerName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GrowMapTable"
HRESULT PRV_GrowMapTable(LPDPLOBBYI_DPLOBJECT this)
{
	LPDPLOBBYI_MAPIDNODE	lpTempMap = NULL;


	// If we haven't already allocated a buffer, allocate one with
	// DPLOBBYPR_DEFAULTMAPENTRIES entries in it
	if(!this->lpMap)
	{
		this->lpMap = DPMEM_ALLOC(DPLOBBYPR_DEFAULTMAPENTRIES *
							sizeof(DPLOBBYI_MAPIDNODE));
		if(!this->lpMap)
		{
			DPF(2, "Unable to allocate memory for ID map table");
			return DPERR_OUTOFMEMORY;
		}

		this->dwTotalMapEntries = DPLOBBYPR_DEFAULTMAPENTRIES;
		return DP_OK;
	}

	// Otherwise, grow the table by the default number of entries
	lpTempMap = DPMEM_REALLOC(this->lpMap, (this->dwTotalMapEntries +
				DPLOBBYPR_DEFAULTMAPENTRIES * sizeof(DPLOBBYI_MAPIDNODE)));
	if(!lpTempMap)
	{
		DPF(2, "Unable to grow map table");
		return DPERR_OUTOFMEMORY;
	}

	this->lpMap = lpTempMap;
	this->dwTotalMapEntries += DPLOBBYPR_DEFAULTMAPENTRIES *
								sizeof(DPLOBBYI_MAPIDNODE);

	return DP_OK;

} // PRV_GrowMapTable



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DoesLobbyIDExist"
BOOL PRV_DoesLobbyIDExist(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID,
		LPDWORD lpdwIndex)
{
	DWORD	dwIndex = 0;


	if(this->lpMap && this->dwMapEntries)
	{
		// REVIEW!!!! -- We need to make this faster -- use a sorted array
		while(dwIndex < this->dwMapEntries)
		{
			if(this->lpMap[dwIndex++].dwLobbyID == dwLobbyID)
			{
				*lpdwIndex = --dwIndex;
				return TRUE;
			}
		}
	}

	return FALSE;

} // PRV_DoesLobbyIDExist



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddMapIDNode"
HRESULT PRV_AddMapIDNode(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID, DPID dpid)
{
	HRESULT		hr = DP_OK;
	DWORD		dwIndex = 0;


	// Make sure we have room for a new entry
	if(this->dwMapEntries == this->dwTotalMapEntries)
	{
		hr = PRV_GrowMapTable(this);
		if(FAILED(hr))
			return hr;
	}

	// Verify that this LobbyID doesn't already exist in the table
	if(PRV_DoesLobbyIDExist(this, dwLobbyID, &dwIndex))
	{
		DPF(2, "Tried to add Lobby ID to map table which already existed, overwriting data");
		ASSERT(FALSE);
		this->lpMap[dwIndex].dwLobbyID = dwLobbyID;
		this->lpMap[dwIndex].dpid = dpid;
		return hr;
	}	

	// REVIEW!!!! -- We need to add this in and keep the array sorted to
	// make lookups faster, but for now, don't worry about it.
	// Fill in a new node at the end of the array
	this->lpMap[this->dwMapEntries].dwLobbyID = dwLobbyID;
	this->lpMap[this->dwMapEntries].dpid = dpid;
	this->dwMapEntries++;

	return hr;

} // PRV_AddMapIDNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteMapIDNode"
BOOL PRV_DeleteMapIDNode(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID)
{
	DWORD	dwIndex = 0;


	// Make sure we have entries
	if((this->lpMap) && (this->dwMapEntries))
	{
		// REVIEW!!!! -- We need to make this faster by using a sorted array
		while(dwIndex < this->dwMapEntries)
		{
			if(this->lpMap[dwIndex].dwLobbyID == dwLobbyID)
			{
				// Check for the boundary case (last entry)
				if((++dwIndex) == this->dwMapEntries)
				{
					// This is the last entry, so don't do anything but
					// decrement the number of entries
					this->dwMapEntries--;
					return TRUE;
				}
				else
				{
					// Move all entries from here to the end of the list
					// up one array entry
					MoveMemory((LPDPLOBBYI_MAPIDNODE)(&this->lpMap[dwIndex-1]),
						(LPDPLOBBYI_MAPIDNODE)(&this->lpMap[dwIndex]),
						((this->dwMapEntries - dwIndex) *
						sizeof(DPLOBBYI_MAPIDNODE)));

					// Decrement the count of entries
					this->dwMapEntries--;
					
					return TRUE;
				}
			}
			else
				dwIndex++;
		}
	}

	// We weren't able to delete the entry in the map table
	DPF(2, "Trying to delete an entry in the map ID table which doesn't exist");
	ASSERT(FALSE);
	return FALSE;

} // PRV_DeleteMapIDNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDPIDByLobbyID"
BOOL PRV_GetDPIDByLobbyID(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID,
									DPID * lpdpid)
{
	DWORD	dwIndex = 0;

	
	// Take care of the known cases or else look in the map table
	switch(dwLobbyID)
	{
		case DPID_ALLPLAYERS:
		case DPID_SERVERPLAYER:
			*lpdpid = dwLobbyID;
			return TRUE;

		default:
			// Walk the list look for the ID
			while(dwIndex < this->dwMapEntries)
			{
				if(this->lpMap[dwIndex].dwLobbyID == dwLobbyID)
				{
					*lpdpid = this->lpMap[dwIndex].dpid;
					return TRUE;
				}
				else
					dwIndex++;
			}
	}

	return FALSE;

} // PRV_GetDPIDByLobbyID



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetLobbyIDByDPID"
BOOL PRV_GetLobbyIDByDPID(LPDPLOBBYI_DPLOBJECT this, DPID dpid,
									LPDWORD lpdwLobbyID)
{
	DWORD	dwIndex = 0;

	
	// Take care of the known cases or else look in the map table
	switch(dpid)
	{
		case DPID_ALLPLAYERS:
		case DPID_SERVERPLAYER:
			*lpdwLobbyID = dpid;
			return TRUE;

		default:
			// Walk the list look for the ID
			while(dwIndex < this->dwMapEntries)
			{
				if(this->lpMap[dwIndex].dpid == dpid)
				{
					*lpdwLobbyID = this->lpMap[dwIndex].dwLobbyID;
					return TRUE;
				}
				else
					dwIndex++;
			}
			break;
	}

	return FALSE;

} // PRV_GetLobbyIDByDPID



#undef DPF_MODNAME
#define DPF_MODNAME "IsLobbyIDInMapTable"
BOOL IsLobbyIDInMapTable(LPDPLOBBYI_DPLOBJECT this, DWORD dwID)
{
	DPID	dpidTemp;

	// If we can get it, then it's in there
	if(PRV_GetDPIDByLobbyID(this, dwID, &dpidTemp))
		return TRUE;

	// Otherwise, return FALSE
	return FALSE;

} // IsLobbyIDInMapTable



#undef DPF_MODNAME
#define DPF_MODNAME "IsValidLobbyID"
BOOL IsValidLobbyID(DWORD dwID)
{
	// If it's in our reserved range, it's invalid.  Otherwise, it's valid
	if(dwID <= DPID_RESERVEDRANGE)
		return FALSE;
	else
		return TRUE;

} // IsValidLobbyID



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateAndMapNewPlayer"
HRESULT PRV_CreateAndMapNewPlayer(LPDPLOBBYI_DPLOBJECT this,
			DPID * lpdpid, LPDPNAME lpName, HANDLE hEvent, LPVOID lpData,
			DWORD dwDataSize, DWORD dwFlags, DWORD dwLobbyID,
			BOOL bSystemPlayer)
{
	LPDPLAYI_PLAYER		lpPlayer = NULL, lpSysPlayer = NULL;
	HRESULT				hr = DP_OK;
	DPID				dpidPlayer = 0, dpidSysPlayer = 0;


	// Take the dplay lock
	ENTER_DPLAY();

	// Make sure the lobby ID is valid, but only if it's not a system player
	if((!bSystemPlayer) && (!IsValidLobbyID(dwLobbyID)))
	{
		DPF_ERRVAL("ID %lu is reserved, cannot create new player", dwLobbyID);
	    hr = DPERR_INVALIDPLAYER;
		goto EXIT_CREATEANDMAPNEWPLAYER;
	}

	// If this is a remote player, we need allocate a new nametable entry
	// for them and set the correct system player ID
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Allocate a new ID for the player
		hr = NS_AllocNameTableEntry(this->lpDPlayObject, &dpidPlayer);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to allocate new nametable id, hr = 0x%08x", hr);
			goto EXIT_CREATEANDMAPNEWPLAYER;
		}

		// Make sure we have a lobby system player (for all remote players)
		// If we don't then allocate a new one, unless we are creating
		// the system player currently
		if((!(this->dpidSysPlayer)) && (!(dwFlags & DPLAYI_PLAYER_SYSPLAYER)))
		{
			hr = PRV_CreateAndMapNewPlayer(this, &dpidSysPlayer, NULL, NULL, NULL,
					0, DPLAYI_PLAYER_SYSPLAYER,
					DPID_LOBBYREMOTESYSTEMPLAYER, TRUE);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Unable to create lobby system player, hr = 0x%08x", hr);
				ASSERT(FALSE);
				goto EXIT_CREATEANDMAPNEWPLAYER;
			}

			// Set the lobby system player ID pointer to the new ID
			this->dpidSysPlayer = dpidSysPlayer;
		}
	}

	// Get a player struct for the player (if it's local, this will add it
	// to the nametable.  If it's remote, we need to add it below)
	hr = GetPlayer(this->lpDPlayObject, &lpPlayer, lpName, hEvent, lpData,
					dwDataSize, dwFlags, NULL, dwLobbyID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed trying to add player to the nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEANDMAPNEWPLAYER;
	}

	// If the player is remote, set the player's ID to the new one we
	// allocated and then set the system player ID to the lobby system player
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Set the player's system player
		lpPlayer->dwIDSysPlayer = this->dpidSysPlayer;

		// Add the player to the nametable
		hr = AddItemToNameTable(this->lpDPlayObject, (DWORD_PTR)lpPlayer,
				&dpidPlayer, TRUE, dwLobbyID);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("Unable to add new player to the nametable, hr = 0x%08x", hr);
			ASSERT(FALSE);
			goto EXIT_CREATEANDMAPNEWPLAYER;
	    }

		// Set the player's ID
		lpPlayer->dwID = dpidPlayer;
	}

	// Set the output dpid pointer
	*lpdpid = lpPlayer->dwID;

EXIT_CREATEANDMAPNEWPLAYER:

	LEAVE_DPLAY();
	return hr;

} // PRV_CreateAndMapNewPlayer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplobby\dplobby\tlhelp32.h ===
/*****************************************************************************\
*                                                                             *
* tlhelp32.h -	WIN32 tool help functions, types, and definitions	      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h/winbase.h must be #included first			      *
*                                                                             *
* Copyright (c) 1994-1995, Microsoft Corp.   All rights reserved. 	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP32
#define _INC_TOOLHELP32


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MAX_MODULE_NAME32 255

/****** Shapshot function **********************************************/

HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
//
// The th32ProcessID argument is only used if TH32CS_SNAPHEAPLIST or
// TH32CS_SNAPMODULE is specified. th32ProcessID == 0 means the current
// process.
//
// NOTE that all of the snapshots are global except for the heap and module
//	lists which are process specific. To enumerate the heap or module
//	state for all WIN32 processes call with TH32CS_SNAPALL and the
//	current process. Then for each process in the TH32CS_SNAPPROCESS
//	list that isn't the current process, do a call with just
//	TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.
//
// dwFlags
//
#define TH32CS_SNAPHEAPLIST 0x00000001
#define TH32CS_SNAPPROCESS  0x00000002
#define TH32CS_SNAPTHREAD   0x00000004
#define TH32CS_SNAPMODULE   0x00000008
#define TH32CS_SNAPALL	    (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)
#define TH32CS_INHERIT	    0x80000000
//
// Use CloseHandle to destroy the snapshot
//

/****** heap walking ***************************************************/

typedef struct tagHEAPLIST32
{
    DWORD  dwSize;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap (in owning process's context!)
    DWORD  dwFlags;
} HEAPLIST32;
typedef HEAPLIST32 *  PHEAPLIST32;
typedef HEAPLIST32 *  LPHEAPLIST32;
//
// dwFlags
//
#define HF32_DEFAULT	  1  // process's default heap
#define HF32_SHARED	  2  // is shared heap

BOOL WINAPI Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);
BOOL WINAPI Heap32ListNext(HANDLE hSnapshot, LPHEAPLIST32 lphl);

typedef struct tagHEAPENTRY32
{
    DWORD  dwSize;
    HANDLE hHandle;	// Handle of this heap block
    DWORD  dwAddress;	// Linear address of start of block
    DWORD  dwBlockSize; // Size of block in bytes
    DWORD  dwFlags;
    DWORD  dwLockCount;
    DWORD  dwResvd;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap block is in
} HEAPENTRY32;
typedef HEAPENTRY32 *  PHEAPENTRY32;
typedef HEAPENTRY32 *  LPHEAPENTRY32;
//
// dwFlags
//
#define LF32_FIXED    0x00000001
#define LF32_FREE     0x00000002
#define LF32_MOVEABLE 0x00000004

BOOL WINAPI Heap32First(LPHEAPENTRY32 lphe, DWORD th32ProcessID,
			DWORD th32HeapID);
BOOL WINAPI Heap32Next(LPHEAPENTRY32 lphe);
BOOL WINAPI Toolhelp32ReadProcessMemory(DWORD	th32ProcessID,
					LPCVOID lpBaseAddress,
					LPVOID	lpBuffer,
					DWORD	cbRead,
					LPDWORD lpNumberOfBytesRead);

/***** Process walking *************************************************/

typedef struct tagPROCESSENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;	    // this process
    DWORD   th32DefaultHeapID;
    DWORD   th32ModuleID;	    // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;	    // Base priority of process's threads
    DWORD   dwFlags;
    char    szExeFile[MAX_PATH];    // Path
} PROCESSENTRY32;
typedef PROCESSENTRY32 *  PPROCESSENTRY32;
typedef PROCESSENTRY32 *  LPPROCESSENTRY32;

BOOL WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
BOOL WINAPI Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

/***** Thread walking **************************************************/

typedef struct tagTHREADENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ThreadID;	// this thread
    DWORD   th32OwnerProcessID; // Process this thread is associated with
    LONG    tpBasePri;
    LONG    tpDeltaPri;
    DWORD   dwFlags;
} THREADENTRY32;
typedef THREADENTRY32 *  PTHREADENTRY32;
typedef THREADENTRY32 *  LPTHREADENTRY32;

BOOL WINAPI Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL WINAPI Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);

/***** Module walking *************************************************/

typedef struct tagMODULEENTRY32
{
    DWORD   dwSize;
    DWORD   th32ModuleID;	// This module
    DWORD   th32ProcessID;	// owning process
    DWORD   GlblcntUsage;	// Global usage count on the module
    DWORD   ProccntUsage;	// Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;	// Base address of module in th32ProcessID's context
    DWORD   modBaseSize;	// Size in bytes of module starting at modBaseAddr
    HMODULE hModule;		// The hModule of this module in th32ProcessID's context
    char    szModule[MAX_MODULE_NAME32 + 1];
    char    szExePath[MAX_PATH];
} MODULEENTRY32;
typedef MODULEENTRY32 *  PMODULEENTRY32;
typedef MODULEENTRY32 *  LPMODULEENTRY32;

//
// NOTE CAREFULLY that the modBaseAddr and hModule fields are valid ONLY
// in th32ProcessID's process context.
//

BOOL WINAPI Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
BOOL WINAPI Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

#ifdef __cplusplus
}
#endif

#endif // _INC_TOOLHELP32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\creg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.cpp
 *  Content:	
 *			This module contains the implementation of the CRegistry class.
 *			For a class description, see creg.h
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/16/99	rodtoll	Created
 *	08/18/99	rodtoll	Added Register/UnRegister that can be used to
 *						allow COM objects to register themselves.
 *	08/25/99	rodtoll	Updated to provide read/write of binary (blob) data
 *	10/05/99	rodtoll	Added DPF_MODNAMEs
 *	10/07/99	rodtoll	Updated to work in Unicode
 *	10/08/99	rodtoll	Fixes to DeleteKey / Reg/UnReg for Win9X
 *	10/15/99	rodtoll	Plugged some memory leaks
 *	10/27/99	pnewson	added Open() call that takes a GUID
 *	01/18/00	mjn		Added GetMaxKeyLen function
 *	01/24/00	mjn		Added GetValueSize function
 * 	01/24/00	rodtoll	Fixed error handling for ReadString (Unicode version)
 * 	04/21/2000 	rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 *             	rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *                     	to allow reads of REG_BINARY when expecting REG_DWORD
 *	05/02/00	mjn		Changed CRegistry::Open() to use KEY_READ when Create set to FALSE
 *  06/08/00    rmt     Updated to use common string utils
 *  07/06/00	rmt		Modified to allow seperate read/write parameter
 * 	07/09/2000	rodtoll	Added signature bytes 
 *  07/21/00	rmt		Fixed a memory leak
 *  08/08/2000	rmt		Bug #41736 - AV in call to lstrcpy by COM_GetDllName 
 *	08/28/2000	masonb	Voice Merge: Modified platform checks to use osind.cpp layer
 *  08/30/2000	rodtoll	Bug #171822 - PREFIX Bug
 *  04/13/2001	VanceO	Moved granting registry permissions into common, and
 *						added DeleteValue and EnumValues.
 *  06/19/2001  RichGr  DX8.0 added special security rights for "everyone" - remove them if
 *                      they exist with new RemoveAllAccessSecurityPermissions() method.
 ***************************************************************************/

#include "dncmni.h"


#ifndef DPNBUILD_NOREGISTRY


#ifdef WINNT

// Security function prototypes

typedef BOOL (*PALLOCATEANDINITIALIZESID)(
  PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, // authority
  BYTE nSubAuthorityCount,                        // count of subauthorities
  DWORD dwSubAuthority0,                          // subauthority 0
  DWORD dwSubAuthority1,                          // subauthority 1
  DWORD dwSubAuthority2,                          // subauthority 2
  DWORD dwSubAuthority3,                          // subauthority 3
  DWORD dwSubAuthority4,                          // subauthority 4
  DWORD dwSubAuthority5,                          // subauthority 5
  DWORD dwSubAuthority6,                          // subauthority 6
  DWORD dwSubAuthority7,                          // subauthority 7
  PSID *pSid                                      // SID
);

typedef VOID (*PBUILDTRUSTEEWITHSID)(
  PTRUSTEE pTrustee,  // structure
  PSID pSid           // trustee name
);

typedef DWORD (*PSETENTRIESINACL)(
  ULONG cCountOfExplicitEntries,           // number of entries
  PEXPLICIT_ACCESS pListOfExplicitEntries, // buffer
  PACL OldAcl,                             // original ACL
  PACL *NewAcl                             // new ACL
);

typedef DWORD (*PSETSECURITYINFO)(
  HANDLE handle,                     // handle to object
  SE_OBJECT_TYPE ObjectType,         // object type
  SECURITY_INFORMATION SecurityInfo, // buffer
  PSID psidOwner,                    // new owner SID
  PSID psidGroup,                    // new primary group SID
  PACL pDacl,                        // new DACL
  PACL pSacl                         // new SACL
);

typedef PVOID (*PFREESID)(
  PSID pSid   // SID to free
);

#endif // WINNT


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::CRegistry"
// CRegistry Constructor
//
// This is the default constructor for the registry class.  It
// is used to construct a registry object which has not yet
// opened a handle to the registry.  Open must be called before
// this object can be used.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::CRegistry( ): m_isOpen(FALSE), m_dwSignature(VSIG_CREGISTRY)
{
}

// CRegistry Destructor
//
// This is the destructor for the class, and will close the connection
// to the registry if this object has one open.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::~CRegistry() 
{
	if( m_isOpen ) 
	{
		Close();
	}

	m_dwSignature = VSIG_CREGISTRY_FREE;
}

// DeleteSubKey
//
// This function causes the key specified by the string equivalent of
// the pGuidName parameter to be deleted from the point in the registry
// this object is rooted at, if the key exists.  If the object does not
// have an open connection to the registry, or the keyName is not specified
//
// Parmaters:
// const GUID *pGuidName - GUID whose equivalent string needs to be deleted
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteSubKey( const GUID *pGuidName )
{

   	WCHAR wszGuidString[GUID_STRING_LEN];
	
	DNASSERT( pGuidName != NULL );

	// convert the guid to a string
	if(!StringFromGUID2(*pGuidName, wszGuidString, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	return DeleteSubKey(wszGuidString);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::DeleteSubKey"
// DeleteSubKey
//
// This function causes the key specified by the keyName parameter
// to be deleted from the point in the registry this object is rooted
// at, if the key exists.  If the object does not have an open connection
// to the registry, or the keyName is not specified, FALSE is returned
//
// Parmaters:
// const TCHAR *keyName - key name to delete
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteSubKey( const LPCWSTR keyName ) 
{

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	LONG	retValue;
	
#ifdef UNICODE
	retValue = RegDeleteKeyW( m_regHandle, keyName );
#else
	LPSTR lpstrKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}
	else
	{
		retValue = RegDeleteKeyA( m_regHandle, lpstrKeyName );

		DNFree(lpstrKeyName);
	}
#endif // UNICODE
	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::DeleteValue"
// DeleteValue
//
// This function causes the value specified by the valueName parameter
// to be deleted from the point in the registry this object is rooted
// at, if the value exists.  If the object does not have an open connection
// to the registry, or the valueName is not specified, FALSE is returned
//
// Parmaters:
// const TCHAR *keyName - key name to delete
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteValue( const LPCWSTR valueName ) 
{

	if( valueName == NULL || !IsOpen() ) return FALSE;

	LONG	retValue;
	
#ifdef UNICODE
	retValue = RegDeleteValueW( m_regHandle, valueName );
#else
	LPSTR lpstrValueName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrValueName, valueName ) ) )
	{
		return FALSE;
	}
	else
	{
		retValue = RegDeleteValueA( m_regHandle, lpstrValueName );

		DNFree(lpstrValueName);
	}
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const TCHAR *path - The path relative to the root specified by
//                    branch where the registry connection will
//                    be opened.
// BOOL create - Settings this parameter conrols how this function
//               handles opens on paths which don't exists.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const LPCWSTR pathName, BOOL fReadOnly, BOOL create, BOOL fCustomSAM, REGSAM samCustom ) 
{

	DWORD	dwResult;	// Temp used in call to RegXXXX
	LONG	result;		// used to store results

	if( pathName == NULL )
		return FALSE;

	// If there is an open connection, close it.
	if( m_isOpen ) 
	{
		Close();
	}

	m_fReadOnly = fReadOnly;

#ifdef UNICODE
	// Create or open the key based on create parameter
	if( create ) 
	{
		result = RegCreateKeyExW( branch, pathName, 0, NULL, REG_OPTION_NON_VOLATILE, (fCustomSAM) ? samCustom : KEY_ALL_ACCESS,
				                 NULL, &m_regHandle, &dwResult );
	} 
	else 
	{
		result = RegOpenKeyExW( branch, pathName, 0, (fReadOnly) ? KEY_READ : ((fCustomSAM) ? samCustom : KEY_ALL_ACCESS), &m_regHandle );
	}
#else
	LPSTR lpszKeyName;

	if( STR_AllocAndConvertToANSI( &lpszKeyName, pathName ) == S_OK && pathName )
	{
		if( create ) 
		{
			result = RegCreateKeyExA( branch, lpszKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
					                 NULL, &m_regHandle, &dwResult );
		} 
		else 
		{
			result = RegOpenKeyExA( branch, lpszKeyName, 0, (fReadOnly) ? KEY_READ : KEY_ALL_ACCESS, &m_regHandle );
		}

		DNFree(lpszKeyName);
	}
	else
	{
		return FALSE;
	}
#endif // UNICODE

	// If succesful, initialize object, otherwise set it to
	// not open state.
	if( result == ERROR_SUCCESS ) 
	{
		m_isOpen	 = TRUE;
		m_baseHandle = branch;
		return TRUE;

	} 
	else 
	{
		m_isOpen = FALSE;
		return FALSE;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// In this version of the function, the path is specified as
// a guid instead of a string. The function will attempt to open
// a key with a name in the form "{CB4961DB-D2FA-43f3-942A-991D9294DDBB}"
// that corresponds to the guid as you would expect.
//
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const LPGUID lpguid - The path relative to the root specified by
//                    branch where the registry connection will
//                    be opened. See comment above.
// BOOL create - Settings this parameter conrols how this function
//               handles opens on paths which don't exists.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const GUID* lpguid, BOOL fReadOnly, BOOL create, BOOL fCustomSAM, REGSAM samCustom ) 
{
	WCHAR wszGuidString[GUID_STRING_LEN];
	
	DNASSERT( lpguid != NULL );

	// convert the guid to a string
	if (!StringFromGUID2(*lpguid, wszGuidString, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	return Open(branch, wszGuidString, fReadOnly, create, fCustomSAM, samCustom);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Close"
// Close
//
// This function will close an open connection to the registry
// if this object has one.  Otherwise it does nothing.
//
// Parameters:
// N/A
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.  If the object
//        is not open it will return TRUE.
//
BOOL CRegistry::Close() 
{

	LONG retValue;

	if( m_isOpen ) 
	{
		retValue = RegCloseKey( m_regHandle );
        if( retValue == ERROR_SUCCESS )
        {
            m_isOpen = FALSE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
	} 
	else 
	{
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::EnumKeys"
// EnumKeys
//
// This function can be used to enumerate the keys at the point
// in the registry rooted at the root this object was opened
// with, at the path specified when opening the object.
//
// To properly enumerate the keys you should pass 0 as the index on
// the first call, and increment the index parameter by one on each
// call.  You can stop enumerating when the function returns FALSE.
//
// Parameters:
// LPWSTR lpwStrName - The current key in the enumeration will be returned
//                 in this string.  Unless the enumeration fails or
//                 ended at which case this parameter won't be touched.
//
// LPDWORD lpdwStringLen - pointer to length of string buffer, or place to
//						to store size required.
//
// DWORD index - The current enum index.  See above for details.
//
// Returns:
// BOOL - FALSE when enumeration is done or on error, TRUE otherwise.
//
BOOL CRegistry::EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index )
{
#ifdef UNICODE
	wchar_t buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	FILETIME tmpTime;

	if( RegEnumKeyExW( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen  )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    lstrcpyW( lpwStrName, buffer );

		*lpdwStringLen = bufferSize+1;
	    
	    return TRUE;
	}	
#else
	char buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	FILETIME tmpTime;

	if( RegEnumKeyExA( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    if( FAILED( STR_jkAnsiToWide( lpwStrName, buffer, *lpdwStringLen ) ) )
	    {
	    	return FALSE;
	    }
	    else
	    {
			*lpdwStringLen = bufferSize+1;
	    	return TRUE;
	    }
	}	
#endif // UNICODE
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::EnumValues"
// EnumValues
//
// This function can be used to enumerate the values at the point
// in the registry rooted at the root this object was opened
// with, at the path specified when opening the object.
//
// To properly enumerate the values you should pass 0 as the index on
// the first call, and increment the index parameter by one on each
// call.  You can stop enumerating when the function returns FALSE.
//
// Parameters:
// LPWSTR lpwStrName - The current value in the enumeration will be returned
//                 in this string.  Unless the enumeration fails or
//                 ended at which case this parameter won't be touched.
//
// LPDWORD lpdwStringLen - pointer to length of string buffer, or place to
//						to store size required.
//
// DWORD index - The current enum index.  See above for details.
//
// Returns:
// BOOL - FALSE when enumeration is done or on error, TRUE otherwise.
//
BOOL CRegistry::EnumValues( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index )
{
#ifdef UNICODE
	wchar_t buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;

	if( RegEnumValueW( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, NULL ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen  )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    lstrcpyW( lpwStrName, buffer );

		*lpdwStringLen = bufferSize+1;
	    
	    return TRUE;
	}	
#else
	char buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;

	if( RegEnumValueA( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, NULL ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    if( FAILED( STR_jkAnsiToWide( lpwStrName, buffer, *lpdwStringLen ) ) )
	    {
	    	return FALSE;
	    }
	    else
	    {
			*lpdwStringLen = bufferSize+1;
	    	return TRUE;
	    }
	}	
#endif // UNICODE
}


// This comment documents ALL of the Read<Data Type> functions which
// follow.
//
// CRegistry Read<Data Type> Functions
//
// The set of ReadXXXXX functions for the CRegistry class are
// responsible for reading <data type> type data from the registry.
// The object must have an open connection to the registry before
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to read
// <datatype> & - A reference to the specific data type where
//				  the data will be placed on a succesful read.
//                This parameter will be unaffected if the read
//                fails.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//


// This comment documents ALL of the Write<Data Type> functions which
// follow.
//
// CRegistry Write<Data Type> Functions
//
// The set of Write<Data Type> functions for the CRegistry class are
// responsible for writing <data type> type data to the registry.
// The object must have an open connection to the registry before
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to write
// <datatype> & - A reference to the specific data type which
//                contains the data to be written to the registry.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteString"
// WriteString
//
// Writes Strings's to the registry, see block comment above
// for details.
//
BOOL CRegistry::WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue )
{

	LONG		retValue;
	
	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) lpwstrValue, (lstrlenW( lpwstrValue )+1)*sizeof(wchar_t) );	
#else
	LPSTR lpstrKeyName;
	LPSTR lpstrValue;
	
	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrValue, lpwstrValue ) ) )
	{
		DNFree(lpstrKeyName);
		return FALSE;
	}
	
	retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrValue, lstrlenA( lpstrValue )+1 );

	DNFree(lpstrKeyName);
	DNFree(lpstrValue);
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadString"
// ReadString
//
// Reads CString's from the registry, see block comment above
// for details.
//
BOOL CRegistry::ReadString( const LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength )
{
	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	LONG		retValue;
	DWORD		tmpSize;
	DWORD		tmpType;	

#ifdef UNICODE
	wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
	tmpSize = MAX_REGISTRY_STRING_SIZE*sizeof(wchar_t);
	
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );
	if (retValue != ERROR_SUCCESS)
	{
		return FALSE;
	}

	if( (tmpSize/2) > *lpdwLength || !lpwstrValue )
	{
		*lpdwLength = (tmpSize/2);
		return FALSE;
	}

	lstrcpyW( lpwstrValue, buffer );

	*lpdwLength = (tmpSize/2);

	return TRUE;
#else
	LPSTR lpstrKeyName;
	char buffer[MAX_REGISTRY_STRING_SIZE];
	tmpSize = MAX_REGISTRY_STRING_SIZE;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}
		
	retValue = RegQueryValueExA( m_regHandle, lpstrKeyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );
	if (retValue != ERROR_SUCCESS)
	{
		DNFree(lpstrKeyName);
		return FALSE;
	}

	DNFree(lpstrKeyName);

	if( tmpSize > *lpdwLength || !lpwstrValue )
	{
		*lpdwLength = tmpSize;
		return FALSE;
	}

	if( FAILED( STR_jkAnsiToWide( lpwstrValue, buffer, *lpdwLength ) ) )
	{
		return FALSE;
	}

	*lpdwLength = tmpSize;	

	if( retValue == ERROR_SUCCESS && tmpType == REG_SZ ) 
	{
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
#endif // UNICODE
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteGUID"
// WriteGUID
//
// Writes GUID's to the registry, see block comment above
// for details.  The GUID is written in the format it is usually
// displayed.  (But without the '{''s).
//
BOOL CRegistry::WriteGUID( LPCWSTR keyName, const GUID &guid )
{
	LONG retValue;
	WCHAR wszGuidString[GUID_STRING_LEN];

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

	if (!StringFromGUID2(guid, wszGuidString, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) wszGuidString, (lstrlenW( wszGuidString )+1)*sizeof(wchar_t) );
#else
	HRESULT hr;
	LPSTR lpstrKeyName;
	LPSTR lpstrKeyValue;

	hr = STR_AllocAndConvertToANSI( &lpstrKeyName, keyName );
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "STR_AllocAndConvertToANSI failed, code: 0x%08x", hr);
		return FALSE;
	}
	
	hr = STR_AllocAndConvertToANSI( &lpstrKeyValue, wszGuidString );
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "STR_AllocAndConvertToANSI failed, code: 0x%08x", hr);
		DNFree(lpstrKeyName);
		return FALSE;
	}

	retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrKeyValue, lstrlenA( lpstrKeyValue )+1);

	DNFree(lpstrKeyName);
	DNFree(lpstrKeyValue);
#endif // UNICODE
	
	if( retValue == ERROR_SUCCESS )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadGUID"
// ReadGUID
//
// Reads GUID's from the registry, see block comment above
// for details.  The GUID must be stored in the format written by
// the WriteGUID function or it will not be read correctly.
//
BOOL CRegistry::ReadGUID( LPCWSTR keyName, GUID* pguid )
{
	wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD		dwLength = MAX_REGISTRY_STRING_SIZE;
    HRESULT hr;

    if( !ReadString( keyName, buffer, &dwLength ) )
    {
        return FALSE;
    }
    else
    {
    	hr = CLSIDFromString(buffer, pguid);
    	if (FAILED(hr))
    	{
    		DPFX(DPFPREP, 0, "CLSIDFromString failed, code: 0x%08x", hr);
    		return FALSE;
    	}
    	return TRUE;
    }
}



#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteDWORD"
// WriteDWORD
//
// Writes DWORDS to the registry, see block comment above
// for details.
//
BOOL CRegistry::WriteDWORD( LPCWSTR keyName, DWORD value ) 
{

	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );		
#else
	LPSTR lpszKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
	{
		return FALSE;
	}

	retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );

	DNFree(lpszKeyName);
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);
}



#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadDWORD"
// ReadDWORD
//
// Reads DWORDS from the registry, see block comment above
// for details.
//
BOOL CRegistry::ReadDWORD( LPCWSTR keyName, DWORD* presult ) 
{

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	LONG		retValue;
	DWORD		tmpValue;
	DWORD		tmpType;
	DWORD		tmpSize;

	tmpSize = sizeof( DWORD );

#ifdef UNICODE
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
#else
	LPSTR lpszKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
	{
		return FALSE;
	}

	retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
	
	DNFree(lpszKeyName);
#endif // UNICODE

	if( retValue == ERROR_SUCCESS && (tmpType == REG_DWORD || tmpType == REG_BINARY) && tmpSize == sizeof(DWORD) ) 
	{
		*presult = tmpValue;
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
}

#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Register"
BOOL CRegistry::Register( LPCWSTR lpszProgID, const LPCWSTR lpszDesc, const LPCWSTR lpszProgName, const GUID* pguidCLSID, LPCWSTR lpszVerIndProgID )
{
	CRegistry core;

	DNASSERT( lpszDesc != NULL );
	DNASSERT( lpszProgID != NULL );

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[GUID_STRING_LEN];
    wchar_t lpszKeyName[_MAX_PATH];

	// convert the guid to a string
	if (!StringFromGUID2(*pguidCLSID, lpszGUID, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
		DPFX(DPFPREP,  0, "Unable to open/create registry key \"%ls\"", lpszKeyName );
		return FALSE;
    }

    core.WriteString( L"", lpszDesc );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\InProcServer32 section
    swprintf( lpszKeyName, L"CLSID\\%s\\InProcServer32", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
    	DPFX(DPFPREP,  0, "Unable to open/create registry key \"%ls\"", lpszKeyName );
    	return FALSE;
    }
    core.WriteString( L"", lpszProgName );
    core.WriteString( L"ThreadingModel", L"Both" );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\VersionIndependentProgID section
    if( lpszVerIndProgID != NULL )
    {
	    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
	    {
	    	DPFX(DPFPREP,  0, "Unable to open/create verind registry key \"%ls\"", lpszKeyName );
	    	return FALSE;
	    }
    
	    core.WriteString( L"", lpszVerIndProgID );
	    core.Close();
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\ProgID section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
    	DPFX(DPFPREP,  0, "Unable to open/create verind registry key \"%ls\"", lpszKeyName );
    	return FALSE;
    }

    core.WriteString( L"", lpszProgID );
    core.Close();

	// Write The VersionIND ProgID
	
	if( lpszVerIndProgID != NULL )
	{
		if( !core.Open( HKEY_CLASSES_ROOT, lpszVerIndProgID, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszVerIndProgID );
		}
		else
		{
			core.WriteString( L"", lpszDesc );
			core.Close();			
		}

		swprintf( lpszKeyName, L"%s\\CLSID", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszGUID );
			core.Close();
		}

		swprintf( lpszKeyName, L"%s\\CurVer", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszProgID );
			core.Close();
		}		
	}

	if( !core.Open( HKEY_CLASSES_ROOT, lpszProgID, FALSE, TRUE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszDesc );
		core.Close();
	}
	
	swprintf( lpszKeyName, L"%s\\CLSID", lpszProgID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszGUID );
		core.Close();
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::UnRegister"
BOOL CRegistry::UnRegister( const GUID* pguidCLSID )
{
	CRegistry core, cregClasses, cregSub;

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[GUID_STRING_LEN];
    wchar_t lpszKeyName[_MAX_PATH];
    wchar_t szProgID[MAX_REGISTRY_STRING_SIZE];
    wchar_t szVerIndProgID[MAX_REGISTRY_STRING_SIZE];
    DWORD dwSize = MAX_REGISTRY_STRING_SIZE;

	// convert the guid to a string
	if (!StringFromGUID2(*pguidCLSID, lpszGUID, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	if( !cregClasses.Open( HKEY_CLASSES_ROOT, L"", FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open HKEY_CLASSES_ROOT" );
		return FALSE;
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open \"%ls\"", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;	

    if( core.ReadString( L"", szProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szProgID );
    	
    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
    		return FALSE;
    	}
    	
    	if( !cregClasses.DeleteSubKey( szProgID ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete HKEY_CLASSES_ROOT/ProgID" );

    		return FALSE;
    	}
    }

	core.Close();

    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open \"%ls\"", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;
	
    if( core.ReadString( L"", szVerIndProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
    		return FALSE;
    	}

    	swprintf( lpszKeyName, L"%s\\CurVer", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
    		return FALSE;
    	}
    	
    	
    	if( !cregClasses.DeleteSubKey( szVerIndProgID ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"HKEY_CLASSES_ROOT/%ls\"", szVerIndProgID);

    		return FALSE;
    	}
    }

    core.Close();

	swprintf( lpszKeyName, L"CLSID\\%s\\InprocServer32", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}	

	swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}

    return TRUE;
}

#endif // !DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadBlob"
BOOL CRegistry::ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize )
{
	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG		retValue;
	DWORD		tmpType;

#ifdef UNICODE
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, lpbBuffer, lpdwSize );	
#else
	LPSTR lpszKeyName;
		
	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
	{
		return FALSE;
	}

	retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, lpbBuffer, lpdwSize );

	DNFree(lpszKeyName);
#endif // UNICODE
	
	if( retValue == ERROR_SUCCESS && tmpType == REG_BINARY ) 
	{
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteBlob"
BOOL CRegistry::WriteBlob( LPCWSTR keyName, const BYTE* const lpbBuffer, DWORD dwSize )
{
	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_BINARY, lpbBuffer, dwSize );
#else
	LPSTR lpszKeyName;
	
	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
		return FALSE;

	retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_BINARY, lpbBuffer, dwSize );
	
	DNFree(lpszKeyName);	
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GetMaxKeyLen"
BOOL CRegistry::GetMaxKeyLen( DWORD* pdwMaxKeyLen )
{
	LONG	retVal;

#ifdef UNICODE
	retVal = RegQueryInfoKeyW( m_regHandle,NULL,NULL,NULL,NULL,pdwMaxKeyLen,
			NULL,NULL,NULL,NULL,NULL,NULL);
#else
	retVal = RegQueryInfoKeyA( m_regHandle,NULL,NULL,NULL,NULL,pdwMaxKeyLen,
			NULL,NULL,NULL,NULL,NULL,NULL);
#endif // UNICODE

	return (retVal == ERROR_SUCCESS);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GetValueLength"
// GetValueLength
//
// Determines the length of a particular key value
//
BOOL CRegistry::GetValueLength( const LPCWSTR keyName, DWORD *const pdwValueLength )
{
	LONG		retValue;
	DWORD		tmpLength;

	if ( keyName == NULL || pdwValueLength == NULL || !IsOpen() )
	{
		return FALSE;
	}

#ifdef UNICODE
	DWORD	dwType;
		
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &dwType, NULL, &tmpLength );
	if (retValue != ERROR_SUCCESS)
	{
		return FALSE;
	}

	//
	// if this is a string, we need to compensate for WCHAR characters being
	// returned
	//
	if ( dwType == REG_SZ )
	{
		tmpLength /= sizeof( WCHAR );
	}
#else
	LPSTR lpstrKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}
		
	retValue = RegQueryValueExA( m_regHandle, lpstrKeyName, 0, NULL, NULL, &tmpLength );

	DNFree(lpstrKeyName);	

	if (retValue != ERROR_SUCCESS)
	{
		return FALSE;
	}
#endif // UNICODE

	*pdwValueLength = tmpLength;

	return TRUE;
}


#ifdef WINNT

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GrantAllAccessSecurityPermissions"
// GrantAllAccessSecurityPermissions
//
// Gives the given key all access for everyone rights
//
// Taken from hresMumbleKeyEx in diregutl.c in the dinput tree.
//
BOOL CRegistry::GrantAllAccessSecurityPermissions()
{
	BOOL						fResult = FALSE;
	HRESULT						hr;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibrary( _T("advapi32.dll") );

	if( !hModuleADVAPI32 )
	{
		DPFX(DPFPREP,  0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = reinterpret_cast<PFREESID>( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = reinterpret_cast<PSETSECURITYINFO>( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = reinterpret_cast<PBUILDTRUSTEEWITHSID>( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = reinterpret_cast<PALLOCATEANDINITIALIZESID>( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPFX(DPFPREP,  0, "Failed loading entry points" );
		goto EXIT;
	}

    // Describe the access we want to create the key with
    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
    ExplicitAccess.grfAccessPermissions = ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER);
    									/*KEY_QUERY_VALUE | KEY_SET_VALUE 
                                        | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS
                                        | KEY_NOTIFY | KEY_CREATE_LINK
                                        | DELETE | READ_CONTROL; */
    ExplicitAccess.grfAccessMode = SET_ACCESS;      // discard any existing AC info
    ExplicitAccess.grfInheritance =  SUB_CONTAINERS_AND_OBJECTS_INHERIT;

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( m_regHandle, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
			else
			{
				fResult = TRUE;
			}
		} 
		else
		{
			DPFX(DPFPREP,  0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPFX(DPFPREP,  0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return fResult;
}


#endif // WINNT

#ifdef WINNT

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::RemoveAllAccessSecurityPermissions"
// RemoveAllAccessSecurityPermissions
//
// Removes "all access for everyone" rights from the specified key.
// This is identical to GrantAllAccessSecurityPermissions(), except that
// now we REVOKE_ACCESS instead of SET_ACCESS, and we don't have to fill
// out the rest of the EXPLICIT_ACCESS struct.
//
//
BOOL CRegistry::RemoveAllAccessSecurityPermissions()
{
	BOOL						fResult = FALSE;
	HRESULT						hr;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibrary( _T("advapi32.dll") );

	if( !hModuleADVAPI32 )
	{
		DPFX(DPFPREP,  0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = reinterpret_cast<PFREESID>( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = reinterpret_cast<PSETSECURITYINFO>( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = reinterpret_cast<PBUILDTRUSTEEWITHSID>( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = reinterpret_cast<PALLOCATEANDINITIALIZESID>( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPFX(DPFPREP,  0, "Failed loading entry points" );
		goto EXIT;
	}

    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
	ExplicitAccess.grfAccessMode = REVOKE_ACCESS;		//Remove any existing ACEs for the specified trustee

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,	// trustee is "Everyone"
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( m_regHandle, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
			else
			{
				fResult = TRUE;
			}
		} 
		else
		{
			DPFX(DPFPREP,  0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPFX(DPFPREP,  0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return fResult;
}

#endif // WINNT


#endif // ! DPNBUILD_NOREGISTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\callstack.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CallStack.cpp
 *  Content:	Call stack tracking class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/13/2001	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"

#ifdef DBG

#ifndef DPNBUILD_NOIMAGEHLP
#define	_IMAGEHLP_SOURCE_
#include	<Imagehlp.h>
#endif // !DPNBUILD_NOIMAGEHLP

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifndef DPNBUILD_NOIMAGEHLP
//
// prototypes for ImageHlp.DLL functions we get from LoadLibrary().
//
typedef DWORD	(__stdcall * PIMAGEHELP_SYMGETOPTIONS)( void );
typedef DWORD	(__stdcall * PIMAGEHELP_SYMSETOPTIONS)( DWORD SymOptions );
typedef	BOOL	(__stdcall * PIMAGEHELP_SYMINITIALIZE)( HANDLE hProcess, PSTR pUserSearchPath, BOOL fInvadeProcess );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR)( HANDLE hProcess, DWORD dwAddress, PDWORD pdwDisplacement, PIMAGEHLP_SYMBOL pSymbol );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR64)( HANDLE hProcess, DWORD_PTR dwAddress, PDWORD_PTR pdwDisplacement, PIMAGEHLP_SYMBOL64 pSymbol );

#endif // !DPNBUILD_NOIMAGEHLP

//**********************************************************************
// Class function definitions
//**********************************************************************

void	CCallStack::NoteCurrentCallStack( void )
{
	void		**CallersEBP = NULL;
	void		*ReturnAddr;
	UINT_PTR	i,iCount;
	const void	*StackTop;
	const void	*StackBottom;
	static const void	*const min_dll_base = NULL;


	StackTop = GetStackTop();
	StackBottom = GetStackBottom();
	memset(	m_CallStack, 0x00, sizeof( m_CallStack ) );

#ifdef	_X86_
	_asm
	{
		mov eax,[ebp]
		mov CallersEBP,eax
	}
#endif	// _X86_

	_try
	{
		//
		// this code can generate exception if it steps back too far...
		//
 		for ( i = 0, iCount = 0; i < CALLSTACK_DEPTH; iCount++ )
		{
			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
				break;
			ReturnAddr = CallersEBP[ 1 ];
			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
				m_CallStack[ i++ ] = ReturnAddr;
			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
		}
	}
	_except(EXCEPTION_EXECUTE_HANDLER)  // went too far back on the stack, rest of array is filled with zeros
	{
//		DPFX(DPFPREP,  0, "Benign access violation creating return address stack." );
	}
}

const void* CCallStack::GetStackTop( void ) const
{
	void	*pReturn = NULL;

#ifdef	_X86_
	_asm	mov eax,dword ptr fs:[4]
	_asm	mov pReturn, eax
#endif	// _X86_

	return	pReturn;
}

const void	*CCallStack::GetStackBottom( void ) const
{
	void	*pReturn = NULL;

#ifdef	_X86_
	_asm	mov eax,dword ptr fs:[8]
	_asm	mov pReturn, eax
#endif	// _X86_

	return	pReturn;
}

void CCallStack::GetCallStackString( TCHAR *const pOutputString ) const
{
	static const TCHAR	CallStackTitle[] = _T("\nCALL STACK:\n");
	static const TCHAR	CallStackTitleWithSymbols[] = _T("\nCALL STACK:\tFUNCTION DETAILS:\n");
	
#ifndef DPNBUILD_NOIMAGEHLP 
	static enum
	{
		IMAGEHELP_STATUS_UNKNOWN,
		IMAGEHELP_STATUS_LOADED,
		IMAGEHELP_STATUS_LOAD_FAILED
	} ImageHelpStatus = IMAGEHELP_STATUS_UNKNOWN;

	static HINSTANCE	hImageHelp = NULL;
	static PIMAGEHELP_SYMGETOPTIONS			pSymGetOptions = NULL;
	static PIMAGEHELP_SYMSETOPTIONS			pSymSetOptions = NULL;
	static PIMAGEHELP_SYMINITIALIZE			pSymInitialize = NULL;

#ifndef	_WIN64	
	static PIMAGEHELP_SYMGETSYMFROMADDR		pSymGetSymFromAddr = NULL;
#else
	static PIMAGEHELP_SYMGETSYMFROMADDR64	pSymGetSymFromAddr = NULL;
#endif	// _WIN64

	//
	// if ImageHelp isn't loaded attempt to load it
	//
	if ( ImageHelpStatus == IMAGEHELP_STATUS_UNKNOWN )
	{
		ImageHelpStatus = IMAGEHELP_STATUS_LOAD_FAILED;

		hImageHelp = LoadLibrary( _T("ImageHLP.DLL") );
		if ( hImageHelp == NULL )
		{
			goto FailedImageHelpLoad;
		}

		pSymGetOptions = reinterpret_cast<PIMAGEHELP_SYMGETOPTIONS>( GetProcAddress( hImageHelp, "SymGetOptions" ) );
		pSymSetOptions = reinterpret_cast<PIMAGEHELP_SYMSETOPTIONS>( GetProcAddress( hImageHelp, "SymSetOptions" ) );
		pSymInitialize = reinterpret_cast<PIMAGEHELP_SYMINITIALIZE>( GetProcAddress( hImageHelp, "SymInitialize" ) );

#ifndef	_WIN64		
		pSymGetSymFromAddr = reinterpret_cast<PIMAGEHELP_SYMGETSYMFROMADDR>( GetProcAddress( hImageHelp, "SymGetSymFromAddr" ) );
#else	// _WIN64
		pSymGetSymFromAddr = reinterpret_cast<PIMAGEHELP_SYMGETSYMFROMADDR64>( GetProcAddress( hImageHelp, "SymGetSymFromAddr64" ) );
#endif	// _WIN64

		if ( ( pSymGetOptions == NULL ) ||
			 ( pSymSetOptions == NULL ) ||
			 ( pSymInitialize == NULL ) ||
			 ( pSymGetSymFromAddr == NULL ) )
		{
			goto FailedImageHelpLoad;
		}

		pSymSetOptions( SYMOPT_DEFERRED_LOADS | pSymGetOptions() );

		if ( pSymInitialize( GetCurrentProcess(), NULL, TRUE ) == FALSE )
		{
			if ( pSymInitialize( GetCurrentProcess(), NULL, FALSE ) == FALSE )
			{
				goto FailedImageHelpLoad;
			}
		}

		ImageHelpStatus = IMAGEHELP_STATUS_LOADED;
	}

FailedImageHelpLoad:
	if ( ImageHelpStatus == IMAGEHELP_STATUS_LOADED )
	{
		memcpy( pOutputString, CallStackTitleWithSymbols, sizeof( CallStackTitleWithSymbols ) );
	}
	else
#endif // !DPNBUILD_NOIMAGEHLP
	{
		memcpy( pOutputString, CallStackTitle, sizeof( CallStackTitle ) );
	}

	for ( DWORD dwIndex = 0; ( ( dwIndex < CALLSTACK_DEPTH ) && ( m_CallStack[ dwIndex ] != NULL ) ); dwIndex++ )
	{
		TCHAR	AddressBuffer[ CALLSTACK_BUFFER_SIZE ];


#ifndef DPNBUILD_NOIMAGEHLP
		if ( ImageHelpStatus == IMAGEHELP_STATUS_LOADED )
		{
			TCHAR	ImageBuffer[ CALLSTACK_BUFFER_SIZE + sizeof(IMAGEHLP_SYMBOL) ];
			DWORD_PTR	dwFunctionDisplacement;
#ifndef	_WIN64
			IMAGEHLP_SYMBOL	*const pImageHelpSymbol = reinterpret_cast<IMAGEHLP_SYMBOL*>( ImageBuffer );
#else	// _WIN64
			IMAGEHLP_SYMBOL64	*const pImageHelpSymbol = reinterpret_cast<IMAGEHLP_SYMBOL64*>( ImageBuffer );
#endif	// _WIN64


			pImageHelpSymbol->SizeOfStruct = sizeof( *pImageHelpSymbol );
			pImageHelpSymbol->Flags = 0;
			pImageHelpSymbol->Address = reinterpret_cast<DWORD_PTR>( m_CallStack[ dwIndex ] );
            pImageHelpSymbol->MaxNameLength = sizeof( ImageBuffer ) - sizeof( *pImageHelpSymbol ) - 14;   // account for \t%s+0x00000000\n\0
            if ( pSymGetSymFromAddr( GetCurrentProcess(),
									 reinterpret_cast<DWORD_PTR>( m_CallStack[ dwIndex ] ),
									 &dwFunctionDisplacement,
									 pImageHelpSymbol
									 ) != FALSE )
            {
                if ( dwFunctionDisplacement != 0 )
				{
#ifdef _X86_
					wsprintf( AddressBuffer, _T("0x%x\t%hs+0x%x\n"), (DWORD)m_CallStack[ dwIndex ], pImageHelpSymbol->Name, dwFunctionDisplacement );
#else
					wsprintf( AddressBuffer, _T("0x%p\t%hs+0x%x\n"), m_CallStack[ dwIndex ], pImageHelpSymbol->Name, dwFunctionDisplacement );
#endif // _X86_
				}
                else
				{
#ifdef _X86_
                    wsprintf( AddressBuffer, _T("0x%x\t%hs\n"), (DWORD)m_CallStack[ dwIndex ], pImageHelpSymbol->Name );
#else
                    wsprintf( AddressBuffer, _T("0x%p\t%hs\n"), m_CallStack[ dwIndex ], pImageHelpSymbol->Name );
#endif // _X86_
				}

				_tcscat( pOutputString, AddressBuffer );

				//
				// continue FOR loop
				//
				continue;
            }
		}	
#endif // !DPNBUILD_NOIMAGEHLP

#ifdef _X86_
		wsprintf( AddressBuffer, _T("0x%08x\n"), (DWORD)m_CallStack[ dwIndex ] );
#else
		wsprintf( AddressBuffer, _T("0x%p\n"), m_CallStack[ dwIndex ] );
#endif // _X86_
		_tcscat( pOutputString, AddressBuffer );
	}

	return;
}
//**********************************************************************

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\callstack.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CallStack.h
 *  Content:	Call stack tracking class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/13/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef	__CALLSTACK_H__
#define	__CALLSTACK_H__

#ifdef DBG

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// Size of temp buffer to build strings into.
// If the call stack depth is increased, increase the size of the buffer
// to prevent stack corruption with long symbol names.
//
#define	CALLSTACK_BUFFER_SIZE	8192
#define CALLSTACK_DEPTH			12

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

class	CCallStack
{
	public:
		CCallStack(){}
		~CCallStack(){}

		void	NoteCurrentCallStack( void );
		void	GetCallStackString( TCHAR *const pOutputString ) const;

	private:
		const void*		m_CallStack[CALLSTACK_DEPTH];
		const void		*GetStackTop( void ) const;
		const void		*GetStackBottom( void ) const;
};

#endif // DBG

#endif	// __CALLSTACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\classbilink.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassBilink.h
 *  Content:	Class-based bilink
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	09/17/99	jtk		Derived from bilink.c
 *	08/15/00	masonb		Changed assert to DNASSERT and added DNASSERT(this)
 *
 ***************************************************************************/

#ifndef __CLASS_BILINK_H__
#define __CLASS_BILINK_H__

#include "dndbg.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	CONTAINING_OBJECT
#define CONTAINING_OBJECT(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (UINT_PTR)(&((type *)0)->field)))
#endif // CONTAINING_OBJECT

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function Prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

class	CBilink
{
public:
	CBilink(){};
	~CBilink(){};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::Initialize"
	void	Initialize( void )
	{
		DNASSERT( this != NULL );

		m_pNext = this;
		m_pPrev = this;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::GetNext"
	CBilink	*GetNext( void ) const 
	{ 
		DNASSERT( this != NULL );

		return m_pNext; 
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::GetPrev"
	CBilink *GetPrev( void ) const 
	{ 
		DNASSERT( this != NULL );

		return m_pPrev; 
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::IsEmpty"
	BOOL	IsEmpty( void ) const
	{
		DNASSERT( this != NULL );
		DNASSERT( m_pNext != NULL );

		if ( ( m_pNext == m_pPrev ) &&
			 ( m_pNext == this ) )
		{
			return	TRUE;
		}

		return	FALSE;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::IsListMember"
	BOOL	IsListMember( const CBilink *const pList ) const
	{
		CBilink *	pTemp;


		DNASSERT( this != NULL );
		DNASSERT( pList != NULL );

		pTemp = pList->GetNext();
		while ( pTemp != pList )
		{
			if ( pTemp == this )
			{
				return	TRUE;
			}
			pTemp = pTemp->GetNext();
		}

		return	FALSE;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::InsertAfter"
	void	InsertAfter( CBilink* const pList )
	{
		DNASSERT( this != NULL );
		DNASSERT( pList->m_pNext != NULL );
		DNASSERT( pList->m_pPrev != NULL );
		DNASSERT( !IsListMember( pList ) );
		DNASSERT( IsEmpty() );

		m_pNext = pList->m_pNext;
		m_pPrev = pList;
		pList->m_pNext->m_pPrev = this;
		pList->m_pNext = this;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::InsertBefore"
	void	InsertBefore( CBilink* const pList )
	{
		DNASSERT( this != NULL );
		DNASSERT( pList->m_pNext != NULL );
		DNASSERT( pList->m_pPrev != NULL );
		DNASSERT( !IsListMember( pList ) );
		DNASSERT( IsEmpty() );

		m_pNext = pList;
		m_pPrev = pList->m_pPrev;
		pList->m_pPrev->m_pNext = this;
		pList->m_pPrev = this;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::RemoveFromList"
	void	RemoveFromList( void )
	{
		DNASSERT( this != NULL );
		DNASSERT( m_pNext != NULL );
		DNASSERT( m_pPrev != NULL );
		DNASSERT( m_pNext->m_pPrev == this );
		DNASSERT( m_pPrev->m_pNext == this );

		m_pNext->m_pPrev = m_pPrev;
		m_pPrev->m_pNext = m_pNext;
		Initialize();
	}

private:
	CBilink	*m_pNext;
	CBilink	*m_pPrev;
};

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __CLASS_BILINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\createin.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       createin.h
 *  Content:	defines functions required by the generic class factory
 *
 *
 *	The generic class factory (classfac.c) requires these functions to be
 *	implemented by the COM object(s) its supposed to be generating
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#ifndef __CREATEINS__
#define __CREATEINS__


#ifndef DPNBUILD_LIBINTERFACE


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// you must implement this function to create an instance of your COM object
HRESULT	DoCreateInstance(LPCLASSFACTORY This, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid,
    						LPVOID *ppvObj);

// you must implement this function.  Given a class id, you must respond
//	whether or not your DLL implements it
BOOL	IsClassImplemented(REFCLSID rclsid);

#ifdef __cplusplus
}
#endif // __cplusplus


#endif // ! DPNBUILD_LIBINTERFACE

#endif // __CREATEINS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\creg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.h
 *  Content:	definition of the CRegistry class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/16/99	rodtoll	Created
 *	08/18/99	rodtoll	Added Register/UnRegister that can be used to
 *						allow COM objects to register themselves.
 *	08/25/99	rodtoll	Updated to provide read/write of binary (blob) data
 *	10/07/99	rodtoll	Updated to work in Unicode
 *	10/27/99	pnewson	added Open() call that takes a GUID
 *	01/18/00	mjn		Added GetMaxKeyLen function
 *	01/24/00	mjn		Added GetValueSize function
 *	04/05/2000	jtk		Changed GetVauleSize to GetValueLength and modified to return WCHAR lengths
 * 	04/21/2000   	rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 *      	        rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *		                to allow reads of REG_BINARY when expecting REG_DWORD 
 * 	07/09/2000	rodtoll	Added signature bytes 
 *	08/28/2000	masonb	Voice Merge: Modified platform checks to use osind.cpp layer (removed CRegistry::CheckUnicodePlatform)
 *  04/13/2001	VanceO	Moved granting registry permissions into common, and
 *						added DeleteValue and EnumValues.
 *  06/19/2001  RichGr  DX8.0 added special security rights for "everyone" - remove them if
 *                      they exist with new RemoveAllAccessSecurityPermissions() method.
 *
 ***************************************************************************/

#ifndef __CREGISTRY_H
#define __CREGISTRY_H


#ifndef DPNBUILD_NOREGISTRY


// Useful definition
#define MAX_REGISTRY_STRING_SIZE		_MAX_PATH+1

#define DPN_KEY_ALL_ACCESS				((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER)


#define VSIG_CREGISTRY			'GERV'
#define VSIG_CREGISTRY_FREE		'GER_'

#define ReadBOOL( keyname, boolptr ) ReadDWORD( (keyname), (DWORD*) (boolptr) )
#define WriteBOOL( keyname, boolval ) WriteDWORD( (keyname), (DWORD) (boolval) )


// CRegistry
//
// This class handles reading/writing to the windows registry.  Each instance
// of the CRegistry class is attached to a single registry handle, which is
// an open handle to a point in the registry tree.
//
class CRegistry
{

public:

	CRegistry();
	~CRegistry();

    BOOL        EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index = 0 );
    BOOL        EnumValues( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index = 0 );

	BOOL		Open( const HKEY branch, const LPCWSTR pathName, BOOL fReadOnly = TRUE, BOOL create = FALSE, BOOL fCustomSAM = FALSE, REGSAM samCustom = NULL);
	BOOL		Open( const HKEY branch, const GUID* lpguid, BOOL fReadOnly = TRUE, BOOL create = FALSE, BOOL fCustomSAM = FALSE, REGSAM samCustom = NULL);
	BOOL		Close();

	BOOL		IsOpen() const	{ return m_isOpen;	};

	BOOL		DeleteSubKey( LPCWSTR keyName );
	BOOL        	DeleteSubKey( const GUID *pGuidName );

	BOOL		DeleteValue( LPCWSTR valueName );

    BOOL        ReadGUID( LPCWSTR keyName, GUID* guid );
    BOOL        WriteGUID( LPCWSTR keyName, const GUID &guid );

	BOOL		WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue );
	BOOL		ReadString( LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength );

	BOOL		WriteDWORD( LPCWSTR keyName, DWORD value );
	BOOL		ReadDWORD( LPCWSTR keyName, DWORD* presult );

	BOOL		ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize );
	BOOL		WriteBlob( LPCWSTR keyName, const BYTE* const lpbBuffer, DWORD dwSize );

	BOOL		GetMaxKeyLen( DWORD* pdwMaxKeyLen );
	BOOL		GetValueLength( const LPCWSTR keyName, DWORD *const pdwValueLength );

#ifdef WINNT
	BOOL		GrantAllAccessSecurityPermissions();
	BOOL		RemoveAllAccessSecurityPermissions();
#endif // WINNT

#ifndef DPNBUILD_NOCOMREGISTER
	static BOOL	Register( LPCWSTR lpszProgID, LPCWSTR lpszDesc, LPCWSTR lpszProgName, const GUID* pguidCLSID, LPCWSTR lpszVerIndProgID );
	static BOOL UnRegister( const GUID* pguidCLSID );
#endif // !DPNBUILD_NOCOMREGISTER

	// Data access functions
	operator	HKEY() const		{ return m_regHandle; };
	HKEY		GetBaseHandle() const { return m_baseHandle; };
	HKEY		GetHandle() const { return m_regHandle; };

protected:

	DWORD	m_dwSignature;	// Signature
	BOOL    m_fReadOnly;

	BOOL	m_isOpen;		// BOOL indicating if the object is open
	HKEY	m_regHandle;	// Handle to the registry which is represented by this object
	HKEY	m_baseHandle;	// Handle to the root of the part of the registry
							// this object is in.  E.g. HKEY_LOCAL_MACHINE
};


#endif // ! DPNBUILD_NOREGISTRY


#endif // __CREGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\critsectracking.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryTracking.cpp
 *  Content:	Debug memory tracking for detecting leaks, overruns, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	1/10/2002	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"

#ifndef DPNBUILD_ONLYONETHREAD
#ifdef DBG


//
// Uncomment this line to turn critical section internal structure validation on.
//
//#define DNCS_VALIDATE



#define	DN_INVALID_THREAD_ID			-1

CBilink				g_blAllCritSecs;
CBilink				g_blGlobalCritSecsHeldGroup;
CRITICAL_SECTION	g_CSLock;
DWORD				g_dwNumCritSecsAllocated = 0;
DWORD				g_dwNumCritSecsEntered = 0;


#ifdef DNCS_VALIDATE
void DNCSTrackInternalValidate();
#else // ! DNCS_VALIDATE
#define DNCSTrackInternalValidate()
#endif // DNCS_VALIDATE


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInitialize"
BOOL DNCSTrackInitialize()
{
	g_blAllCritSecs.Initialize();
	g_blGlobalCritSecsHeldGroup.Initialize();

	if ( DNOSInitializeCriticalSection(&g_CSLock) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critical section tracking code!" );
		DNASSERT( FALSE );
		return FALSE;
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackDeinitialize"
void DNCSTrackDeinitialize()
{
	DeleteCriticalSection(&g_CSLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackDumpLeaks"
BOOL DNCSTrackDumpLeaks()
{
	DNCRITICAL_SECTION* pCS;
	TCHAR CallStackBuffer[CALLSTACK_BUFFER_SIZE];
	BOOL fLeaked = FALSE;

	EnterCriticalSection(&g_CSLock);
	while (!g_blAllCritSecs.IsEmpty())
	{
		pCS = CONTAINING_OBJECT(g_blAllCritSecs.GetNext(), DNCRITICAL_SECTION, blAllCritSecs);
		
		pCS->AllocCallStack.GetCallStackString(CallStackBuffer);

		DPFX(DPFPREP,  0, "Critical Section leaked at address 0x%p\n%s", pCS, CallStackBuffer );

		pCS->blAllCritSecs.RemoveFromList();

		DeleteCriticalSection(&pCS->CriticalSection);

		fLeaked = TRUE;
	}
	LeaveCriticalSection(&g_CSLock);

	return fLeaked;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInitializeCriticalSection"
BOOL DNCSTrackInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	BOOL fReturn;

	DNASSERT( pCriticalSection != NULL );
	memset( pCriticalSection, 0x00, sizeof( *pCriticalSection ) );

	pCriticalSection->OwningThreadID = DN_INVALID_THREAD_ID;
	pCriticalSection->MaxLockCount = -1;
	pCriticalSection->blCritSecsHeld.Initialize();
	pCriticalSection->blAllCritSecs.Initialize();
	pCriticalSection->pblCritSecsHeldGroup = &g_blGlobalCritSecsHeldGroup;

	fReturn = DNOSInitializeCriticalSection(&pCriticalSection->CriticalSection);
	if ( fReturn != FALSE )
	{
		pCriticalSection->AllocCallStack.NoteCurrentCallStack();

		EnterCriticalSection(&g_CSLock);
		pCriticalSection->blAllCritSecs.InsertBefore(&g_blAllCritSecs);
		g_dwNumCritSecsAllocated++;
		DNCSTrackInternalValidate();
		LeaveCriticalSection(&g_CSLock);
	}

	return	fReturn;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackDeleteCriticalSection"
void DNCSTrackDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( pCriticalSection->LockCount == 0 );

	EnterCriticalSection(&g_CSLock);

	pCriticalSection->blAllCritSecs.RemoveFromList();
	g_dwNumCritSecsAllocated--;

	// NOTE: If they delete the CS without leaving it, still remove it from the held list.
	// If asserts are on, this will have asserted above at LockCount == 0.
	// Calling this is safe whether it is on the list or not.
	pCriticalSection->blCritSecsHeld.RemoveFromList();

	DNCSTrackInternalValidate();
	
	LeaveCriticalSection(&g_CSLock);

	DeleteCriticalSection( &pCriticalSection->CriticalSection );
	memset( &pCriticalSection->CriticalSection, 0x00, sizeof( pCriticalSection->CriticalSection ) );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalRecursionCount"
void DNCSTrackSetCriticalSectionRecursionCount( DNCRITICAL_SECTION *const pCriticalSection, const UINT_PTR RecursionCount )
{
	DNASSERT( pCriticalSection != NULL );

	pCriticalSection->MaxLockCount = RecursionCount + 1;

	DNASSERT( pCriticalSection->MaxLockCount != 0 );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalSectionGroup"
void DNCSTrackSetCriticalSectionGroup( DNCRITICAL_SECTION *const pCriticalSection, CBilink * const pblGroup )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( pblGroup != NULL );

	pCriticalSection->pblCritSecsHeldGroup = pblGroup;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalSectionLockOrder"
void DNCSTrackSetCriticalSectionLockOrder( DNCRITICAL_SECTION *const pCriticalSection, const DWORD dwLockOrder )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( dwLockOrder > 0 );

	pCriticalSection->dwLockOrder = dwLockOrder;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackEnterCriticalSection"
void DNCSTrackEnterCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	UINT_PTR	ThisThreadID;

	DNASSERT( pCriticalSection != NULL );

	EnterCriticalSection( &pCriticalSection->CriticalSection );

	ThisThreadID = GetCurrentThreadId();
	if ( pCriticalSection->OwningThreadID != ThisThreadID )
	{
		DNASSERT( pCriticalSection->OwningThreadID == DN_INVALID_THREAD_ID );

		pCriticalSection->OwningThreadID = ThisThreadID;

		DNASSERT( pCriticalSection->LockCount == 0 );
	}
	else
	{
		DNASSERT( pCriticalSection->LockCount != 0 );
	}

	if ( pCriticalSection->LockCount == 0 )
	{
		pCriticalSection->CallStack.NoteCurrentCallStack();

		// Track this critical section that was just entered for the first time.

		EnterCriticalSection(&g_CSLock);

		pCriticalSection->LockCount++;

		//
		// If this critical section has a lock order, assert that we're not
		// violating it.
		//
		if (pCriticalSection->dwLockOrder != 0)
		{
			CBilink *				pBilink;
			DNCRITICAL_SECTION *	pCS;

			pBilink = pCriticalSection->pblCritSecsHeldGroup->GetNext();
			while (pBilink != pCriticalSection->pblCritSecsHeldGroup)
			{
				pCS = CONTAINING_OBJECT(pBilink, DNCRITICAL_SECTION, blCritSecsHeld);
				if (pCS->dwLockOrder != 0)
				{
					DNASSERT( pCS->dwLockOrder <= pCriticalSection->dwLockOrder );
				}
				pBilink = pBilink->GetNext();
			}
		}
		
		pCriticalSection->blCritSecsHeld.InsertBefore(pCriticalSection->pblCritSecsHeldGroup);
		DNASSERT(g_dwNumCritSecsEntered < g_dwNumCritSecsAllocated);
		g_dwNumCritSecsEntered++;
		DNCSTrackInternalValidate();
		LeaveCriticalSection(&g_CSLock);
	}
	else
	{
		pCriticalSection->LockCount++;
	}

	if ( pCriticalSection->LockCount > pCriticalSection->MaxLockCount )
	{
		if ( pCriticalSection->MaxLockCount == 1 )
		{
			TCHAR	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];

			//
			// Exceeded recursion depth of 1, display stack of call originally
			// holding the lock.
			//
			pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );

			DPFX(DPFPREP, 0, "Critical section 0x%p has been reentered!\nOriginal Holder's Stack:\n%s", pCriticalSection, CallStackBuffer);

			DNASSERT(FALSE);
		}
		else
		{
			//
			// exceeded recursion depth, check your code!!
			//
			DNASSERT(FALSE);
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackLeaveCriticalSection"
void DNCSTrackLeaveCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( pCriticalSection->OwningThreadID == GetCurrentThreadId() );
	DNASSERT( pCriticalSection->LockCount <= pCriticalSection->MaxLockCount );
	DNASSERT( pCriticalSection->LockCount != 0 );

	if ( pCriticalSection->LockCount == 1 )
	{
		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
		pCriticalSection->OwningThreadID = DN_INVALID_THREAD_ID;

		// Track this critical section being left for the last time.
		EnterCriticalSection(&g_CSLock);
		pCriticalSection->LockCount--;
		pCriticalSection->blCritSecsHeld.RemoveFromList();
		DNASSERT(g_dwNumCritSecsEntered > 0);
		g_dwNumCritSecsEntered--;
		DNCSTrackInternalValidate();
		LeaveCriticalSection(&g_CSLock);
	}
	else
	{
		pCriticalSection->LockCount--;
	}

	LeaveCriticalSection( &pCriticalSection->CriticalSection );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackCriticalSectionIsTakenByThisThread"
void DNCSTrackCriticalSectionIsTakenByThisThread( const DNCRITICAL_SECTION *const pCriticalSection, const BOOL fFlag )
{
	DNASSERT( fFlag == ( pCriticalSection->OwningThreadID == GetCurrentThreadId() ) );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackNoCriticalSectionsTakenByThisThread"
void DNCSTrackNoCriticalSectionsTakenByThisThread( CBilink * pblGroup )
{
	CBilink* pBilink;
	DNCRITICAL_SECTION* pCS;

	if (pblGroup == NULL)
	{
		pblGroup = &g_blGlobalCritSecsHeldGroup;
	}

	EnterCriticalSection(&g_CSLock);

	pBilink = pblGroup->GetNext();
	while (pBilink != pblGroup)
	{
		pCS = CONTAINING_OBJECT(pBilink, DNCRITICAL_SECTION, blCritSecsHeld);
		DNASSERT( pCS->OwningThreadID != GetCurrentThreadId() );
		pBilink = pBilink->GetNext();
	}

	DNCSTrackInternalValidate();

	LeaveCriticalSection(&g_CSLock);
}



#ifdef DNCS_VALIDATE

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInternalValidate"
void DNCSTrackInternalValidate()
{
	CBilink* pBilink;
	DNCRITICAL_SECTION* pCS;
	DWORD dwNumAllocated = 0;
	DWORD dwNumEntered = 0;

	//
	// The global critical section lock must be held!
	//

	DNASSERT(g_dwNumCritSecsEntered <= g_dwNumCritSecsAllocated);
	
	pBilink = g_blAllCritSecs.GetNext();
	while (pBilink != &g_blAllCritSecs)
	{
		DNASSERT(pBilink->GetNext() != pBilink);
		DNASSERT(pBilink->GetPrev() != pBilink);
		DNASSERT(pBilink->IsListMember(&g_blAllCritSecs));
		
		pCS = CONTAINING_OBJECT(pBilink, DNCRITICAL_SECTION, blAllCritSecs);

		dwNumAllocated++;
		if (pCS->blCritSecsHeld.IsEmpty())
		{
			DNASSERT(pCS->LockCount == 0);
		}
		else
		{
			DNASSERT(pCS->LockCount > 0);
			dwNumEntered++;
		}

		pBilink = pBilink->GetNext();		
	}
	
	DNASSERT(dwNumAllocated == g_dwNumCritSecsAllocated);
	DNASSERT(dwNumEntered == g_dwNumCritSecsEntered);
}

#endif // DNCS_VALIDATE


#endif // DBG
#endif // !DPNBUILD_ONLYONETHREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\critsectracking.h ===
/*==========================================================================
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CritsecTracking.h
 *  Content:	Debug critical section tracking for detecting leaks, nesting, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 	1/10/2002	masonb	Created
 *
 ***************************************************************************/

#ifndef	__CRITSECTRACKING_H__
#define	__CRITSECTRACKING_H__

#include "callstack.h"
#include "classbilink.h"

#ifdef DPNBUILD_ONLYONETHREAD

#define	DNEnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )
#define DNInitializeCriticalSection( pCriticalSection )	TRUE
#define DNDeleteCriticalSection( pCriticalSection )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )
#define	DebugSetCriticalSectionGroup( pCS, pblGroup )
#define	DebugSetCriticalSectionLockOrder( pCS, dwLockOrder )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	AssertNoCriticalSectionsTakenByThisThread()
#define	AssertNoCriticalSectionsFromGroupTakenByThisThread( pblGroup )

#else // !DPNBUILD_ONLYONETHREAD

#ifdef DBG

struct DNCRITICAL_SECTION
{
	CRITICAL_SECTION	CriticalSection;

	UINT_PTR		OwningThreadID;
	UINT_PTR		MaxLockCount;
	UINT_PTR		LockCount;
	CCallStack		CallStack;
	CCallStack		AllocCallStack;
	CBilink			blAllCritSecs;
	CBilink			blCritSecsHeld;
	CBilink *		pblCritSecsHeldGroup;
	DWORD			dwLockOrder;
};

BOOL DNCSTrackInitialize();
void DNCSTrackDeinitialize();
BOOL DNCSTrackDumpLeaks();

BOOL	DNCSTrackInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackEnterCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackLeaveCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackSetCriticalSectionRecursionCount( DNCRITICAL_SECTION *const pCriticalSection, const UINT_PTR RecursionCount );
void	DNCSTrackSetCriticalSectionGroup( DNCRITICAL_SECTION *const pCriticalSection, CBilink * const pblGroup );
void	DNCSTrackSetCriticalSectionLockOrder( DNCRITICAL_SECTION *const pCriticalSection, const DWORD dwLockOrder );
void	DNCSTrackCriticalSectionIsTakenByThisThread( const DNCRITICAL_SECTION *const pCriticalSection, const BOOL fFlag );
void	DNCSTrackNoCriticalSectionsTakenByThisThread( CBilink * pblGroup );

#define	DNInitializeCriticalSection( arg )				DNCSTrackInitializeCriticalSection( arg )
#define	DNDeleteCriticalSection( arg )					DNCSTrackDeleteCriticalSection( arg )
#define	DNEnterCriticalSection( arg )					DNCSTrackEnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )					DNCSTrackLeaveCriticalSection( arg )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )		DNCSTrackSetCriticalSectionRecursionCount( pCS, Count )
#define	DebugSetCriticalSectionGroup( pCS, pblGroup )			DNCSTrackSetCriticalSectionGroup( pCS, pblGroup )
#define	DebugSetCriticalSectionLockOrder( pCS, dwLockOrder )		DNCSTrackSetCriticalSectionLockOrder( pCS, dwLockOrder )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )		DNCSTrackCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	AssertNoCriticalSectionsTakenByThisThread()			DNCSTrackNoCriticalSectionsTakenByThisThread( NULL )
#define	AssertNoCriticalSectionsFromGroupTakenByThisThread( pblGroup )	DNCSTrackNoCriticalSectionsTakenByThisThread( pblGroup )

#else // !DBG

#define DNCRITICAL_SECTION CRITICAL_SECTION

#define	DNInitializeCriticalSection( arg )				DNOSInitializeCriticalSection( arg )
#define	DNDeleteCriticalSection( arg )					DeleteCriticalSection( arg )
#define	DNEnterCriticalSection( arg )					EnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )					LeaveCriticalSection( arg )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )
#define	DebugSetCriticalSectionGroup( pCS, pblGroup )
#define	DebugSetCriticalSectionLockOrder( pCS, dwLockOrder )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	AssertNoCriticalSectionsTakenByThisThread()
#define	AssertNoCriticalSectionsFromGroupTakenByThisThread( pblGroup )

#endif // DBG
#endif // DPNBUILD_ONLYONETHREAD

#endif	// __CRITSECTRACKING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\dncmni.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNCOMMONi.h
 *  Content:    DirectPlay Common master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNCOMMONI_H__
#define __DNCOMMONI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#include <xtl.h>
#else // ! _XBOX or XBOX_ON_DESKTOP
#include <windows.h>
#include <mmsystem.h>
#ifndef WINCE
#include <inetmsg.h>
#endif // ! WINCE
#include <tapi.h>
#include <stdio.h> // swscanf being used by guidutil.cpp
#ifdef WINNT
#include <accctrl.h>
#include <aclapi.h>
#endif // WINNT
#include <winsock.h>
#endif // ! _XBOX or XBOX_ON_DESKTOP
#include <tchar.h>


// 
// Common private includes
//
#include "dndbg.h"
#include "osind.h"
#include "classbilink.h"
#include "creg.h"
#include "strutils.h"
#include "CallStack.h"
#include "CritsecTracking.h"
#include "HandleTracking.h"
#include "MemoryTracking.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


#endif // __DNCOMMONI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\dndbg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.c
 *  Content:	debug support for DirectPlay8
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *  07-16-99	johnkan	Fixed include of OSInd.h, defined WSPRINTF macro
 *  07-19-99	vanceo	Explicitly declared OutStr as returning void for NT
 *						Build environment.
 *	07-22-99	a-evsch	Check for multiple Inits,  and release CritSec when DebugPrintf
 *						returns early.
 *	08-02-99	a-evsch	Added LOGPF support. LW entries only go into shared-file log
 *	08-31-99	johnkan	Removed include of <OSIND.H>
 *  02-17-00  	rodtoll	Added Memory / String validation routines
 *  05-23-00    RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-16-00    jchauvin IA64:  Added %p parsing to change back to %x for Win9x machines in DebugPrintf, DebugPrintfNoLock, LogPrintf
 *  07-24-00    RichGr  IA64: As there's no separate build for Win9x, added code to detect Win9x for the %p parse-and-replace.
 *	07-29-00	masonb	Rewrite to add logging by subcomponent, perf improvements, process ID
 *	08/28/2000	masonb	Voice Merge: Modified asm in DebugPrintf to preserve registers that may have affected Voice
 *  03/29/2001  RichGr  If DPINST is defined for Performance Instrumentation, allow free build to pick up the code.
 *	
 *  Notes:
 *	
 *  Use /Oi compiler option for strlen()
 *
 ***************************************************************************/

#include "dncmni.h"
#include "memlog.h"

#if defined(DBG) || defined(DPINST)

void DebugPrintfInit(void);
void DebugPrintfFini(void);

// The constructor of this will be called prior to DllMain and the destructor
// after DllMain, so we can be assured of having the logging code properly
// initialized and deinitialized for the life of the module.
struct _InitDbg
{
	_InitDbg() { DebugPrintfInit(); }
	~_InitDbg() { DebugPrintfFini(); }
} DbgInited;

//===============
// Debug  support
//===============

/*******************************************************************************
	This file contains support for the following types of logging:
		1. Logging to a VXD (Win9x only)
		2. Logging to a shared memory region
		3. Logging to the Debug Output
		4. Logging to a message box
		5. FUTURE: Logging to a file

	General:
	========

	Debug Logging and playback is designed to operate on both Win9x and
	Windows NT (Windows 2000).  A shared file is used to capture information
	and can be played back using dp8log.exe.

	Under NT you can use the 'dt' command of NTSD to dump structures.  For
	example:

		dt DIRECTPLAYOBJECT <some memory address>

	will show all of the members of the DIRECTPLAYOBJECT structure at the
	specified address.  Some features are available only in post-Win2k
	versions of NTSD which can be obtained at http://dbg.

	Logging:
	========

	Debug Logging is controlled by settings in the WIN.INI file, under
	the section heading [DirectPlay8].  There are several settings:

	debug=9

	controls the default debug level.  All messages, at or below that debug level
	are printed.  You can control logging by each component specified in the
	g_rgszSubCompName member by adding its name to the end of the 'debug' setting:

	debug.addr=9

	sets the logging level for the addressing subcomponent to 9, leaving all
	others at either their specified level or the level specified by 'debug'
	if there is no specific level specified.

	The second setting controls where the log is seen.  If not specified, all
	debug logs are sent through the standard DebugPrint and will appear in a
	debugger if it is attached.

	log=0 {no debug output}
	log=1 {spew to console only}
	log=2 {spew to shared memory log only}
	log=3 {spew to console and shared memory log}
	log=4 {spew to message box}

	This setting can also be divided by subcomponent, so:

	log=3
	log.protocol=2

	sends logs for the 'protocol' subcomponent to the shared memory log only, and
	all other logs to both locations.

	example win.ini...

	[DirectPlay8]
	Debug=7		; lots of spew
	log=2		; don't spew to debug window

	[DirectPlay8]
	Debug=0		; only fatal errors spewed to debug window

	Asserts:
	========
	Asserts are used to validate assumptions in the code.  For example
	if you know that the variable jojo should be > 700 and are depending
	on it in subsequent code, you SHOULD put an assert before the code
	that acts on that assumption.  The assert would look like:

	DNASSERT(jojo>700);

	Asserts generally will produce 3 lines of debug spew to highlight the
	breaking of the assumption.  You can add text to your asserts by ANDing:
	
	  DNASSERT(jojo>700 && "Jojo was too low");
	
	Will show the specified text when the assert occurs. For testing, you might
	want to set the system to break in on asserts.  This is done in the
	[DirectPlay8] section of WIN.INI by setting BreakOnAssert=TRUE:

	[DirectPlay8]
	Debug=0
	BreakOnAssert=1
	Verbose=1

	The Verbose setting enables logging of file, function, and line information.

	Debug Breaks:
	=============
	When something really severe happens and you want the system to break in
	so that you can debug it later, you should put a debug break in the code
	path.  Some people use the philosophy that all code paths must be
	verified by hand tracing each one in the debugger.  If you abide by this
	you should place a DEBUG_BREAK() in every code path and remove them
	from the source as you trace each.  When you have good coverage but
	some unhit paths (error conditions) you should force those paths in
	the debugger.

	Debug Logging to Shared Memory Region:
	======================================

	All processes will share the same memory region, and will log the specified amount
	of activity.  The log can be viewed with the DPLOG.EXE utility.

	Debug Logging to Debug Output:
	==============================
	This option uses OutputDebugString to log the specified amount of activity.

	Debug Logging to Message Box:
	==============================
	This option uses MessageBox to log the specified amount of activity.

==============================================================================*/

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

#define ASSERT_BUFFER_SIZE   8192
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_MESSAGE_LEVEL 0

#define PROF_SECT		_T("DirectPlay8")

DWORD g_dwMemLogNumEntries = 40000;		// Default Num entries for MEM log, settable in win.ini
DWORD g_dwMemLogLineSize = DPLOG_MAX_STRING;	// Default number of bytes per log entry

//
// Globals for shared memory based logging
//
#ifndef DPNBUILD_SINGLEPROCESS
HANDLE g_hMemLogFile = 0; // NOTE: This is 0 because CreateFileMapping returns 0 on failure
HANDLE g_hMemLogMutex = 0; // NOTE: This is 0 because CreateMutex returns 0 on failure
#endif // ! DPNBUILD_SINGLEPROCESS
PSHARED_LOG_FILE g_pMemLog = 0;

BOOL g_fMemLogInited = FALSE;

#ifndef DPNBUILD_SINGLEPROCESS
DWORD g_fAssertGrabMutex = FALSE;
#endif // ! DPNBUILD_SINGLEPROCESS

// Values for g_rgDestination
#define LOG_TO_DEBUG    1
#define LOG_TO_MEM      2
#define LOG_TO_MSGBOX   4

LPTSTR g_rgszSubCompName[] =
{
	_T("UNK"),			// DN_SUBCOMP_GLOBAL		0
	_T("CORE"),			// DN_SUBCOMP_CORE			1
	_T("ADDR"),			// DN_SUBCOMP_ADDR			2
	_T("LOBBY"),		// DN_SUBCOMP_LOBBY			3
	_T("PROTOCOL"),		// DN_SUBCOMP_PROTOCOL		4
	_T("VOICE"),		// DN_SUBCOMP_VOICE			5
	_T("DPNSVR"),		// DN_SUBCOMP_DPNSVR		6
	_T("WSOCK"),		// DN_SUBCOMP_WSOCK			7
	_T("MODEM"),		// DN_SUBCOMP_MODEM			8
	_T("COMMON"),		// DN_SUBCOMP_COMMON		9
	_T("NATHELP"),		// DN_SUBCOMP_NATHELP		10
	_T("TOOLS"),		// DN_SUBCOMP_TOOLS			11
	_T("THREADPOOL"),	// DN_SUBCOMP_THREADPOOL	12
	_T("MAX"),			// DN_SUBCOMP_MAX			13	// NOTE: this should never get used, but
														// is needed due to the way DebugPrintfInit
														// is written, since it reads one past the end.
};

#define MAX_SUBCOMPS (sizeof(g_rgszSubCompName)/sizeof(g_rgszSubCompName[0]) - 1)
#ifdef _XBOX
#pragma TODO(vanceo, "See below, fix DNGetProfileInt")
extern UINT		g_rgLevel[MAX_SUBCOMPS];
extern UINT		g_rgDestination[MAX_SUBCOMPS];
extern UINT		g_rgBreakOnAssert[MAX_SUBCOMPS];
#pragma TODO(vanceo, "Don't define these globals, force the application to decide logging levels?")
//										=  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12
UINT	g_rgLevel[MAX_SUBCOMPS]			= {1, 9, 1, 1, 7, 1, 1, 7, 1, 1, 1, 1, 7};
UINT	g_rgDestination[MAX_SUBCOMPS]	= {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2};
//UINT	g_rgDestination[MAX_SUBCOMPS]	= {3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2};
UINT	g_rgBreakOnAssert[MAX_SUBCOMPS]	= {1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 3};
#else // ! _XBOX
UINT	g_rgLevel[MAX_SUBCOMPS] = {0};
UINT	g_rgDestination[MAX_SUBCOMPS] = {LOG_TO_DEBUG | LOG_TO_MEM};
UINT	g_rgBreakOnAssert[MAX_SUBCOMPS] = {1};// if non-zero, causes DEBUG_BREAK on false asserts.
#endif // ! _XBOX

// if TRUE, file/line/module information is printed and logged.
DWORD	g_fLogFileAndLine = FALSE;	



// Create a shared file for logging information on the fly
// This support allows the current log to be dumped from the
// user mode DP8LOG.EXE application.  This is useful when debugging
// in MSSTUDIO or in NTSD.  When DP8LOG.EXE is invoked, note that
// the application will get halted until the log is completely dumped
// so it is best to dump the log to a file.

#undef DPF_MODNAME
#define DPF_MODNAME "InitMemLogString"
static BOOL InitMemLogString(VOID)
{
	if(!g_fMemLogInited)
	{
		BOOL fInitLogFile = TRUE;

#ifdef DPNBUILD_SINGLEPROCESS
		g_pMemLog = (PSHARED_LOG_FILE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (DPLOG_HEADERSIZE + (DPLOG_ENTRYSIZE*g_dwMemLogNumEntries)));
		if (!g_pMemLog)
		{
			return FALSE;
		}
#else // ! DPNBUILD_SINGLEPROCESS
		g_hMemLogFile = CreateFileMapping(INVALID_HANDLE_VALUE, DNGetNullDacl(), PAGE_READWRITE, 0, (DPLOG_HEADERSIZE + (DPLOG_ENTRYSIZE*g_dwMemLogNumEntries)), GLOBALIZE_STR _T(BASE_LOG_MEMFILENAME));
		if (!g_hMemLogFile)
		{
			return FALSE;
		}
		if (GetLastError() == ERROR_ALREADY_EXISTS)
		{
			fInitLogFile = FALSE;
		}

		g_hMemLogMutex = CreateMutex(DNGetNullDacl(), FALSE, GLOBALIZE_STR _T(BASE_LOG_MUTEXNAME));
		if (!g_hMemLogMutex)
		{
			CloseHandle(g_hMemLogFile);
			g_hMemLogFile = 0;
			return FALSE;
		}
		g_pMemLog = (PSHARED_LOG_FILE)MapViewOfFile(g_hMemLogFile, FILE_MAP_ALL_ACCESS,0,0,0);
		if (!g_pMemLog)
		{
			CloseHandle(g_hMemLogMutex);
			g_hMemLogMutex = 0;
			CloseHandle(g_hMemLogFile);
			g_hMemLogFile = 0;
			return FALSE;
		}
#endif // ! DPNBUILD_SINGLEPROCESS

		// NOTE: The above 3 functions do return NULL in the case of a failure,
		// not INVALID_HANDLE_VALUE
		if (fInitLogFile)
		{
			g_pMemLog->nEntries = g_dwMemLogNumEntries;
			g_pMemLog->cbLine   = g_dwMemLogLineSize;
			g_pMemLog->iWrite   = 0;
		}
		else
		{
			// This happens when someone before us has already created the mem log.  Could be a previous DPlay instance or TestNet.
			g_dwMemLogNumEntries = g_pMemLog->nEntries;
			g_dwMemLogLineSize = g_pMemLog->cbLine;
		}

		if (g_dwMemLogNumEntries && g_dwMemLogLineSize)
		{
			g_fMemLogInited = TRUE;
		}
	}
	return g_fMemLogInited;
}

// Log a string to a shared file.  This file can be dumped using the
// DPLOG.EXE utility.
//
// dwLength is in bytes and does not include the '\0'
//
void MemLogString(LPCTSTR str, size_t dwLength)
{
	PMEMLOG_ENTRY pEntry;
	size_t cbCopy;


	// If this isn't inited, InitMemLogString failed earlier
	if(!g_fMemLogInited)
	{
		return;
	}

#ifndef DPNBUILD_SINGLEPROCESS
	WaitForSingleObject(g_hMemLogMutex, INFINITE);
#endif // ! DPNBUILD_SINGLEPROCESS

	pEntry = (PMEMLOG_ENTRY)(((PUCHAR)(g_pMemLog + 1)) + (g_pMemLog->iWrite * (sizeof(MEMLOG_ENTRY) + g_dwMemLogLineSize)));
	g_pMemLog->iWrite = (g_pMemLog->iWrite + 1) % g_dwMemLogNumEntries;

#ifndef DPNBUILD_SINGLEPROCESS
	ReleaseMutex(g_hMemLogMutex);
#endif // ! DPNBUILD_SINGLEPROCESS

	pEntry->tLogged = GETTIMESTAMP();

	cbCopy = dwLength + sizeof(TCHAR);		// Add the terminating NULL
	if(cbCopy > g_dwMemLogLineSize)
	{
		cbCopy = g_dwMemLogLineSize;
	}
	memcpy(pEntry->str, str, cbCopy);
	pEntry->str[(cbCopy / sizeof(TCHAR)) - 2] = _T('\n');		// Ensure we always end with a return
	pEntry->str[(cbCopy / sizeof(TCHAR)) - 1] = _T('\0');		// Ensure we always NULL terminate
}

// DebugPrintfInit() - initialize DPF support.
void DebugPrintfInit()
{
	BOOL fUsingMemLog = FALSE;

	TCHAR szLevel[32] = {0};
	_tcscpy(szLevel, _T("debug"));

	TCHAR szDest[32] = {0};
	_tcscpy(szDest, _T("log"));

	TCHAR szBreak[32] = {0};
	_tcscpy(szBreak, _T("breakonassert"));

	// Loop through all the subcomps, and get the level and destination for each
	for (int iSubComp = 0; iSubComp < MAX_SUBCOMPS; iSubComp++)
	{
		// NOTE: The setting under "debug" sets the default and will be used if you
		// don't specify settings for each subcomp
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#pragma BUGBUG(vanceo, "Make DNGetProfileInt work")
		g_rgLevel[iSubComp] = DNGetProfileInt(PROF_SECT, szLevel, g_rgLevel[iSubComp]);
		g_rgDestination[iSubComp] = DNGetProfileInt(PROF_SECT, szDest, g_rgDestination[iSubComp]);
		g_rgBreakOnAssert[iSubComp] = DNGetProfileInt( PROF_SECT, szBreak, g_rgBreakOnAssert[iSubComp]);
#else // ! _XBOX or XBOX_ON_DESKTOP
		g_rgLevel[iSubComp] = DNGetProfileInt(PROF_SECT, szLevel, g_rgLevel[0]);
		g_rgDestination[iSubComp] = DNGetProfileInt(PROF_SECT, szDest, g_rgDestination[0]);
		g_rgBreakOnAssert[iSubComp] = DNGetProfileInt( PROF_SECT, szBreak, g_rgBreakOnAssert[0]);
#endif // ! _XBOX or XBOX_ON_DESKTOP

		if (g_rgDestination[iSubComp] & LOG_TO_MEM)
		{
			fUsingMemLog = TRUE;
		}

		// Set up for the next subcomp
		_tcscpy(szLevel + 5, _T(".")); // 5 is strlen of "debug", we are building debug.addr, etc.
		_tcscpy(szLevel + 6, g_rgszSubCompName[iSubComp + 1]);

		_tcscpy(szDest + 3, _T(".")); // 3 is strlen of "log", we are building log.addr, etc.
		_tcscpy(szDest + 4, g_rgszSubCompName[iSubComp + 1]);

		_tcscpy(szBreak + 13, _T(".")); // 13 is strlen of "breakonassert", we are building breakonassert.addr, etc.
		_tcscpy(szBreak + 14, g_rgszSubCompName[iSubComp + 1]);
	}

	g_dwMemLogNumEntries = DNGetProfileInt( PROF_SECT, _T("MemLogEntries"), 40000);
	g_fLogFileAndLine = DNGetProfileInt( PROF_SECT, _T("Verbose"), 0);
#ifndef DPNBUILD_SINGLEPROCESS
	g_fAssertGrabMutex = DNGetProfileInt( PROF_SECT, _T("AssertGrabMutex"), 0);
#endif // ! DPNBUILD_SINGLEPROCESS

	if (fUsingMemLog)
	{
		// Open the shared log file
		InitMemLogString();	
	}
}

// DebugPrintfFini() - release resources used by DPF support.
void DebugPrintfFini()
{
	if(g_pMemLog)
	{
#ifdef DPNBUILD_SINGLEPROCESS
		HeapFree(GetProcessHeap(), 0, g_pMemLog);
#else // ! DPNBUILD_SINGLEPROCESS
		UnmapViewOfFile(g_pMemLog);
#endif // ! DPNBUILD_SINGLEPROCESS
		g_pMemLog = NULL;
	}
#ifndef DPNBUILD_SINGLEPROCESS
	if(g_hMemLogMutex)
	{
		CloseHandle(g_hMemLogMutex);
		g_hMemLogMutex = 0;
	}
	if(g_hMemLogFile)
	{
		CloseHandle(g_hMemLogFile);
		g_hMemLogFile = 0;
	}
#endif // ! DPNBUILD_SINGLEPROCESS
	g_fMemLogInited = FALSE;
}

void DebugPrintfX(LPCTSTR szFile, DWORD dwLine, LPCTSTR szModName, DWORD dwSubComp, DWORD dwDetail, ...)
{
	DNASSERT(dwSubComp < MAX_SUBCOMPS);

	if(g_rgLevel[dwSubComp] < dwDetail)
	{
		return;
	}
	
	TCHAR  cMsg[ ASSERT_BUFFER_SIZE ];
	va_list argptr;
	LPTSTR pszCursor = cMsg;

	va_start(argptr, dwDetail);


#ifdef UNICODE
	WCHAR szFormat[ASSERT_BUFFER_SIZE];
	LPSTR szaFormat;
	szaFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
	STR_jkAnsiToWide(szFormat, szaFormat, ASSERT_BUFFER_SIZE);
#else
	LPSTR szFormat;
	szFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
#endif // UNICODE


	cMsg[0] = 0;

#ifdef WIN95
    TCHAR  *psz = NULL;
	CHAR  cTemp[ ASSERT_BUFFER_SIZE ];
		
    strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
	szFormat = cTemp;					    // Point szFormat at the local string

    while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
       *(psz+1) = 'x';                      // Substitute 'x' for 'p'.  Don't try to expand
#endif // WIN95

	// Prints out / logs as:
	// 1. Verbose
	// subcomp:dwDetail:ProcessId:ThreadId:File:Function:Line:DebugString
	// e.g.
	// ADDR:2:0450:0378:(c:\somefile.cpp)BuildURLA(L25)Can you believe it?
	//
	// 2. Regular
	// subcomp:dwDetail:ProcessId:ThreadId:Function:DebugString

#ifndef DPNBUILD_SINGLEPROCESS
	pszCursor += wsprintf(pszCursor,_T("%s:%1d:%04x:%04x:"),g_rgszSubCompName[dwSubComp],dwDetail,GetCurrentProcessId(),GetCurrentThreadId());
#else
	pszCursor += wsprintf(pszCursor,_T("%s:%1d:%04x:"),g_rgszSubCompName[dwSubComp],dwDetail,GetCurrentThreadId());
#endif // ! DPNBUILD_SINGLEPROCESS

	if (g_fLogFileAndLine)
	{
		LPCTSTR c;

		int i = _tcslen(szFile);
		if (i < 25)
		{
			c = szFile;
		}
		else
		{
			c = szFile + i - 25;
		}

		pszCursor += wsprintf(pszCursor, _T("(%s)(L%d)"), c, dwLine);
	}

	pszCursor += wsprintf(pszCursor, _T("%s: "), szModName);

	pszCursor += wvsprintf(pszCursor, szFormat, argptr);

	_tcscpy(pszCursor, _T("\n"));
	pszCursor += _tcslen(pszCursor);

	if(g_rgDestination[dwSubComp] & LOG_TO_DEBUG)
	{
		// log to debugger output
		OutputDebugString(cMsg);
	}

	if(g_rgDestination[dwSubComp] & LOG_TO_MEM)
	{
		// log to shared file, pass length not including '\0'
		MemLogString(cMsg, ((PBYTE)pszCursor - (PBYTE)cMsg));
	}	

#ifndef _XBOX
	if(g_rgDestination[dwSubComp] & LOG_TO_MSGBOX)
	{
		// log to Message Box
		MessageBox(NULL, cMsg, _T("DirectPlay Log"), MB_OK);
	}
#endif // ! _XBOX

	va_end(argptr);

	return;
}


//
// NOTE: I don't want to get into error checking for buffer overflows when
// trying to issue an assertion failure message. So instead I just allocate
// a buffer that is "bug enough" (I know, I know...)
//

void _DNAssert( LPCTSTR szFile, DWORD dwLine, LPCTSTR szFnName, DWORD dwSubComp, LPCTSTR szCondition, DWORD dwLevel )
{
    TCHAR buffer[ASSERT_BUFFER_SIZE];


	// For level 1 we always print the message to the log, but we may not actually break.  For other levels
	// we either print and break or do neither.
	if (dwLevel <= g_rgBreakOnAssert[dwSubComp] || dwLevel == 1)
	{
		// Build the debug stream message
		wsprintf( buffer, _T("ASSERTION FAILED! File: %s Line: %d: %s"), szFile, dwLine, szCondition);

		// Actually issue the message. These messages are considered error level
		// so they all go out at error level priority.

		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, "%s", buffer );
		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

		// Should we drop into the debugger?
		if(g_rgBreakOnAssert[dwSubComp])
		{
#ifndef DPNBUILD_SINGLEPROCESS
			// Don't let dpnsvr keep writing to the log
			if (g_hMemLogMutex && g_fAssertGrabMutex)
			{
				WaitForSingleObject(g_hMemLogMutex, INFINITE);
			}
#endif // ! DPNBUILD_SINGLEPROCESS

			// Into the debugger we go...
			DEBUG_BREAK();

#ifndef DPNBUILD_SINGLEPROCESS
			if (g_hMemLogMutex && g_fAssertGrabMutex)
			{
				ReleaseMutex(g_hMemLogMutex);
			}
#endif // ! DPNBUILD_SINGLEPROCESS
		}
	}
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\memlog.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memlog.h
 *  Content:	format of the memory log for DPlay debugging
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  08-24-00		masonb		Created
 *
 ***************************************************************************/

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

#define DPLOG_MAX_STRING (512 * sizeof(TCHAR))	// Max string length (in bytes) for MEM logging

#define DPLOG_HEADERSIZE (sizeof(SHARED_LOG_FILE))
#define DPLOG_ENTRYSIZE (sizeof(MEMLOG_ENTRY) + DPLOG_MAX_STRING)

#define BASE_LOG_MEMFILENAME  	"DPLAY8MEMLOG-0"
#define BASE_LOG_MUTEXNAME 	"DPLAY8MEMLOGMUTEX-0"

#pragma warning(disable:4200) // 0 length array
typedef struct _MEM_LOG_ENTRY 
{
	DWORD	tLogged;
	TCHAR	str[0];
} MEMLOG_ENTRY, *PMEMLOG_ENTRY;

typedef struct _SHARED_LOG_FILE
{
	DWORD   	nEntries;
	DWORD		cbLine;
	DWORD 		iWrite;
} SHARED_LOG_FILE, *PSHARED_LOG_FILE;
#pragma warning(default:4200)


#ifdef DPNBUILD_LIBINTERFACE
extern PSHARED_LOG_FILE		g_pMemLog;
#endif // DPNBUILD_LIBINTERFACE


#endif // _DPLAY_SHARED_MEMLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\dndbg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.h
 *  Content:	debug support functions for DirectNet
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *	07-16-99	johnkan	Added DEBUG_ONLY, DBG_CASSERT, fixed DPFERR to take an argument
 *  02-17-00	rodtoll	Added Memory / String validation routines
 *  05-23-00	RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-27-00	masonb	Rewrite to make sub-component stuff work, improve perf
 *  08/28/2000	masonb	Voice Merge: Part of header guard was missing (#define _DNDBG_H_)
 *  10/25/2001	vanceo	Use NT build friendly BUGBUG, TODO, plus add PRINTVALUE.
 *
 ***************************************************************************/

#ifndef _DNDBG_H_
#define _DNDBG_H_

#ifdef __cplusplus
	extern "C" {
#endif // __cplusplus

// DEBUG_BREAK()
#if defined(DBG) || defined(DPINST)
	#define DEBUG_BREAK() DebugBreak()
#endif // defined(DBG) || defined(DPINST)


//==================================================================================
// Useful macros based on some DNet code (which was taken from code by ToddLa)
//==================================================================================
//
// Macros that generate compile time messages.  Use these with #pragma:
//
//	#pragma TODO(vanceo, "Fix this later")
//	#pragma BUGBUG(vanceo, "Busted!")
//	#pragma PRINTVALUE(DPERR_SOMETHING)
//
// To turn them off, define TODO_OFF, BUGBUG_OFF, PRINTVALUE_OFF in your project
// preprocessor defines.
//
//
// If we're building under VC, (as denoted by the preprocessor define
// DPNBUILD_ENV_NT), these expand to look like:
//
//	D:\directory\file.cpp(101) : BUGBUG: vanceo: Busted!
//
// in your output window, and you should be able to double click on it to jump
// directly to that location (line 101 of D:\directory\file.cpp).
//
// If we're building under the NT build environment, these expand to look like:
//
//	BUGBUG: vanceo: D:\directory\file.cpp(101) : Busted!
//
// because (at least right now) the build process thinks that a failure occurred if
// a message beginning with a filename and line number is printed.  It used to work
// just fine, but who knows.
//

#ifdef DPNBUILD_ENV_NT
#define __TODO(user, msgstr, n)								message("TODO: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __BUGBUG(user, msgstr, n)							message("BUGBUG: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __PRINTVALUE(itemnamestr, itemvaluestr, n)			message("PRINTVALUE: " __FILE__ "(" #n ") : " itemnamestr " = " itemvaluestr)
#else // ! DPNBUILD_ENV_NT
#define __TODO(user, msgstr, n)								message(__FILE__ "(" #n ") : TODO: " #user ": " msgstr)
#define __BUGBUG(user, msgstr, n)							message(__FILE__ "(" #n ") : BUGBUG: " #user ": " msgstr)
#define __PRINTVALUE(itemnamestr, itemvaluestr, n)			message(__FILE__ "(" #n ") : PRINTVALUE: " itemnamestr " = " itemvaluestr)
#endif // ! DPNBUILD_ENV_NT


#define _TODO(user, msgstr, n)								__TODO(user, msgstr, n)
#define _BUGBUG(user, msgstr, n)							__BUGBUG(user, msgstr, n)
#define _PRINTVALUE(itemstr, item, n)						__PRINTVALUE(itemstr, #item, n)


#ifdef TODO_OFF
#define TODO(user, msgstr)
#else
#define TODO(user, msgstr)									_TODO(user, msgstr, __LINE__)
#endif // TODO_OFF

#ifdef BUGBUG_OFF
#define BUGBUG(user, msgstr)
#else
#define BUGBUG(user, msgstr)								_BUGBUG(user, msgstr, __LINE__)
#endif // BUGBUG_OFF

#ifdef PRINTVALUE_OFF
#define PRINTVALUE(item)
#else
#define PRINTVALUE(item)									_PRINTVALUE(#item, item, __LINE__)
#endif // PRINTVALUE_OFF



//========================
// Debug Logging support
//========================

/*=============================================================================
 Usage:

 In code, you can use DPF to print to the log or the debug windows of the
 running application.  The format of DPF (debug printf) is as follows:

	DPFX(DPFPREP,level, string *fmt, arg1, arg2, ...);

 level specifies how important this debug printf is.  The standard convention
 for debug levels is as follows.  This is no way strictly enforced for
 personal use, but by the time the code is checked in, it should be as close
 to this as possible...

  DPF_ERRORLEVEL:		Error useful for application developers.
  DPF_WARNINGLEVEL:		Warning useful for application developers.
  DPF_ENTRYLEVEL:		API Entered
  DPF_APIPARAM:			API parameters, API return values
  DPF_LOCKS:			Driver conversation
  DPF_INFOLEVEL:		Deeper program flow notifications
  DPF_STRUCTUREDUMP:	Dump structures
  DPF_TRACELEVEL:		Trace messages

 When printing a critical error, you can use:
	
	  DPERR( "String" );

 which will print a string at debug level zero.

 In order to cause the code to stop and break in.  You can use ASSERT() or
 DEBUG_BREAK().  In order for ASSERT to break in, you must have
 BreakOnAssert set in the win.ini file section (see osindep.cpp).

=============================================================================*/

#define DPF_ERRORLEVEL			0
#define DPF_WARNINGLEVEL		1
#define DPF_ENTRYLEVEL			2
#define DPF_APIPARAM			3
#define DPF_LOCKS				4
#define DPF_INFOLEVEL			5
#define DPF_STRUCTUREDUMP		6
#define DPF_TRACELEVEL			9

// For Voice
#define DVF_ERRORLEVEL			0
#define DVF_WARNINGLEVEL		1
#define DVF_ENTRYLEVEL			2
#define DVF_APIPARAM			3
#define DVF_LOCKS				4
#define DVF_INFOLEVEL			5
#define DVF_STRUCTUREDUMP		6
#define DVF_TRACELEVEL			9


#define DN_SUBCOMP_GLOBAL		0
#define DN_SUBCOMP_CORE			1
#define DN_SUBCOMP_ADDR			2
#define DN_SUBCOMP_LOBBY		3
#define DN_SUBCOMP_PROTOCOL		4
#define DN_SUBCOMP_VOICE		5
#define DN_SUBCOMP_DPNSVR		6
#define DN_SUBCOMP_WSOCK		7
#define DN_SUBCOMP_MODEM		8
#define DN_SUBCOMP_COMMON		9
#define DN_SUBCOMP_NATHELP		10
#define DN_SUBCOMP_TOOLS		11
#define DN_SUBCOMP_THREADPOOL	12

#ifdef DBG

extern void DebugPrintfX(LPCTSTR szFile, DWORD dwLineNumber,LPCTSTR szFnName, DWORD dwSubComp, DWORD dwDetail, ...);
extern void _DNAssert(LPCTSTR szFile, DWORD dwLineNumber, LPCTSTR szFnName, DWORD dwSubComp, LPCTSTR szCondition, DWORD dwLevel);

#define DPFX						DebugPrintfX

#define DPFPREP						_T(__FILE__),__LINE__,_T(DPF_MODNAME), DPF_SUBCOMP

#define DPFERR(a) 					DebugPrintfX(DPFPREP, DPF_ERRORLEVEL, a )
#ifdef DPNBUILD_USEASSUME
#define DNASSERT(condition)			__assume(condition)
#define DNASSERTX(condition, level)	DBG_CASSERT(level > 1); if (!(condition)) _DNAssert(DPFPREP, _T(#condition), level)
#else // ! DPNBUILD_USEASSUME
#define DNASSERT(condition) 		if (!(condition)) _DNAssert(DPFPREP, _T(#condition), 1)
#define DNASSERTX(condition, level)	if (!(condition)) _DNAssert(DPFPREP, _T(#condition), level)
#endif // ! DPNBUILD_USEASSUME

#define DBG_CASSERT(exp)			switch (0) case 0: case exp:
#define DEBUG_ONLY(arg)				arg
#define DPF_RETURN(a) 				DPFX(DPFPREP,DPF_APIPARAM,"Returning: 0x%lx",a);    return a;
#define DPF_ENTER() 				DPFX(DPFPREP,DPF_TRACELEVEL, "Enter");
#define DPF_EXIT() 					DPFX(DPFPREP,DPF_TRACELEVEL, "Exit");


#else // NOT DBG

	// C4002: too many actual parameters for macro 'identifier'
	#pragma warning(disable:4002)
	#define DPFX()
	#define DPFERR(a)
#ifdef DPNBUILD_USEASSUME
	#define DNASSERT(condition)			__assume(condition)
	#define DNASSERTX(condition, level)
#else // ! DPNBUILD_USEASSUME
	#define DNASSERT(condition)
	#define DNASSERTX(condition, level)
#endif // ! DPNBUILD_USEASSUME
	#define DBG_CASSERT(exp)
	#define DEBUG_ONLY(arg)
	#define DPF_RETURN(a)				return a;	
	#define DPF_ENTER()
	#define DPF_EXIT()

#endif // DBG

#ifdef __cplusplus
	}	//extern "C"
#endif // __cplusplus

#endif // _DNDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\memorytracking.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryTracking.h
 *  Content:	Debug memory tracking for detecting leaks, overruns, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/14/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef	__MEMORYTRACKING_H__
#define	__MEMORYTRACKING_H__



#ifdef DBG

BOOL DNMemoryTrackInitialize(DWORD_PTR dwpMaxMemUsage);
void DNMemoryTrackDeinitialize();

BOOL DNMemoryTrackDumpLeaks();


void* DNMemoryTrackHeapAlloc(DWORD_PTR MemorySize);
void DNMemoryTrackHeapFree(void* pMemory);
void DNMemoryTrackValidateMemory();

#define DNMalloc( size )							DNMemoryTrackHeapAlloc( size )
#define DNFree( pData )								DNMemoryTrackHeapFree( pData )
#define DNValidateMemory()							DNMemoryTrackValidateMemory()

#else // !DBG

#ifdef DPNBUILD_FIXEDMEMORYMODEL

BOOL DNMemoryTrackInitialize(DWORD_PTR dwpMaxMemUsage);
void DNMemoryTrackDeinitialize();
extern HANDLE		g_hMemoryHeap;
#define DNMemoryTrackGetHeap()						(g_hMemoryHeap)

#else // ! DPNBUILD_FIXEDMEMORYMODEL

#define DNMemoryTrackInitialize(dwMaxMemUsage)		(TRUE)
#define DNMemoryTrackDeinitialize()
#define DNMemoryTrackGetHeap						GetProcessHeap

#endif // ! DPNBUILD_FIXEDMEMORYMODEL

#define DNMalloc( size )							HeapAlloc( DNMemoryTrackGetHeap(), 0, size )
#define DNFree( pData )								HeapFree( DNMemoryTrackGetHeap(), 0, pData )
#define DNValidateMemory()

#endif // DBG


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL

void DNMemoryTrackAllowAllocations(BOOL fAllow);
extern BOOL		g_fAllocationsAllowed;
#define DNMemoryTrackAreAllocationsAllowed()		(g_fAllocationsAllowed)

#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

#define DNMemoryTrackAllowAllocations( fAllow )
#define DNMemoryTrackAreAllocationsAllowed()		(TRUE)

#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL



#endif	// __MEMORYTRACKING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\handletracking.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTracking.cpp
 *  Content:    Handle Tracking debug logic
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/31/2001	masonb	Created
 *
 *
 ***************************************************************************/

#include "dncmni.h"


#ifdef DBG

CBilink g_blHandles;
#ifndef DPNBUILD_ONLYONETHREAD
DNCRITICAL_SECTION g_HandleLock;
#endif // !DPNBUILD_ONLYONETHREAD

#define IsValidHandle(x) \
	(x != NULL && x != INVALID_HANDLE_VALUE && \
	(x->type == TypeEvent || \
	 x->type == TypeMutex || \
	 x->type == TypeSemaphore || \
	 x->type == TypeFile || \
	 x->type == TypeFileMap || \
	 x->type == TypeThread || \
	 x->type == TypeProcess || \
	 x->type == TypeSpecial))

BOOL DNHandleTrackInitialize()
{
	g_blHandles.Initialize();
	return DNInitializeCriticalSection(&g_HandleLock);
}

VOID DNHandleTrackDeinitialize()
{
	DNDeleteCriticalSection(&g_HandleLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNHandleTrackDumpLeaks"
BOOL DNHandleTrackDumpLeaks()
{
	BOOL fLeaked = FALSE;

	DNEnterCriticalSection(&g_HandleLock);
	while(!g_blHandles.IsEmpty())
	{
		DNHANDLE dnh = CONTAINING_RECORD(g_blHandles.GetNext(), TRACKED_HANDLE, blHandle);
		dnh->blHandle.RemoveFromList();

		fLeaked = TRUE;

		// Dump dnh details
		switch(dnh->type)
		{
		case TypeEvent:
			DPFX(DPFPREP, 0, "Event leaked %p", dnh->handle);
			break;
		case TypeMutex:
			DPFX(DPFPREP, 0, "Mutex leaked %p", dnh->handle);
			break;
		case TypeSemaphore:
			DPFX(DPFPREP, 0, "Semaphore leaked %p", dnh->handle);
			break;
		case TypeFile:
			DPFX(DPFPREP, 0, "File leaked %p", dnh->handle);
			break;
#ifndef DPNBUILD_SINGLEPROCESS
		case TypeFileMap:
			DPFX(DPFPREP, 0, "FileMapping leaked %p", dnh->handle);
			break;
#endif // ! DPNBUILD_SINGLEPROCESS
		case TypeThread:
			DPFX(DPFPREP, 0, "Thread leaked %p", dnh->handle);
			break;
#ifndef DPNBUILD_SINGLEPROCESS
		case TypeProcess:
			DPFX(DPFPREP, 0, "Process leaked %p", dnh->handle);
			break;
#endif // ! DPNBUILD_SINGLEPROCESS
		case TypeSpecial:
			DPFX(DPFPREP, 0, "Special handle leaked %p", dnh->handle);
			break;

		default:
			DPFX(DPFPREP, 0, "Unknown handle leaked %p", dnh->handle);
			DNASSERT(0);
			break;
		}

		// Show the callstack of the place the handle was allocated.
		TCHAR		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
		dnh->AllocCallStack.GetCallStackString( CallStackBuffer );
		DPFX(DPFPREP,  0, "%s\n", CallStackBuffer );

		DNFree(dnh);		
	}
	DNLeaveCriticalSection(&g_HandleLock);

	return fLeaked;
}

DNHANDLE DNHandleTrackMakeDNHANDLE(HANDLE h)
{
	if (h == 0 || h == INVALID_HANDLE_VALUE)
	{
		return (DNHANDLE)h;
	}

	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeSpecial;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	return dnh;
}

VOID DNHandleTrackRemoveDNHANDLE(DNHANDLE dnh)
{
	DNASSERT(IsValidHandle(dnh));

	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.RemoveFromList();
	DNLeaveCriticalSection(&g_HandleLock);

	DNFree(dnh);
}

HANDLE 	 DNHandleTrackHandleFromDNHANDLE(DNHANDLE h)
{
	if (h == 0 || h == INVALID_HANDLE_VALUE)
	{
		return (HANDLE)h;
	}

	DNASSERT(IsValidHandle(h));
	return h->handle;
}

#ifndef DPNBUILD_SINGLEPROCESS
// NOTE: pCurrentDirectory is const on the desktop, but non-const on WinCE
BOOL DNHandleTrackCreateProcess(LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, DNPROCESS_INFORMATION* lpProcessInformation)
{
	PROCESS_INFORMATION pi;
	DWORD dwLastError;

	DNHANDLE dnhProcess = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnhProcess)
	{
		return FALSE;
	}

	DNHANDLE dnhThread = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnhThread)
	{
		DNFree(dnhProcess);
		return FALSE;
	}

	// NOTE: On CE only the current directory is declared non-const so cast it off
#ifdef WINCE
	if (!CreateProcess(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, (LPTSTR)lpCurrentDirectory, lpStartupInfo, &pi))
#else // !WINCE
	if (!CreateProcess(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, &pi))
#endif // WINCE
	{
		dwLastError = GetLastError();
		DNFree(dnhProcess);
		DNFree(dnhThread);
		SetLastError(dwLastError);
		return FALSE;
	}
	dwLastError = GetLastError();
	
	dnhProcess->AllocCallStack.NoteCurrentCallStack();
	dnhProcess->handle = pi.hProcess;
	dnhProcess->type = TypeProcess;
	dnhProcess->blHandle.Initialize();
	
	dnhThread->AllocCallStack.NoteCurrentCallStack();
	dnhThread->handle = pi.hThread;
	dnhThread->type = TypeThread;
	dnhThread->blHandle.Initialize();

	DNEnterCriticalSection(&g_HandleLock);
	dnhProcess->blHandle.InsertBefore(&g_blHandles);
	dnhThread->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	lpProcessInformation->hProcess = dnhProcess;
	lpProcessInformation->hThread = dnhThread;
	lpProcessInformation->dwProcessId = pi.dwProcessId;
	lpProcessInformation->dwThreadId = pi.dwThreadId;

	SetLastError(dwLastError);
	return TRUE;
}

DNHANDLE DNHandleTrackOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
{
	DWORD dwLastError;

	HANDLE h = OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeProcess;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}
#endif // ! DPNBUILD_SINGLEPROCESS

DNHANDLE DNHandleTrackCreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
	DWORD dwLastError;

	HANDLE h = CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeThread;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackCreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = CreateEvent(lpEventAttributes, bManualReset, bInitialState, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeEvent;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackOpenEvent(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = OpenEvent(dwDesiredAccess, bInheritHandle, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeEvent;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackSetEvent(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeEvent);
	return SetEvent(hHandle->handle);
}

BOOL DNHandleTrackResetEvent(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeEvent);
	return ResetEvent(hHandle->handle);
}

DNHANDLE DNHandleTrackCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = CreateMutex(lpMutexAttributes, bInitialOwner, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeMutex;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackOpenMutex(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = OpenMutex(dwDesiredAccess, bInheritHandle, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeMutex;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackReleaseMutex(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeMutex);
	return ReleaseMutex(hHandle->handle);
}

DNHANDLE DNHandleTrackCreateSemaphore(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = CreateSemaphore(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeSemaphore;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackReleaseSemaphore(DNHANDLE hHandle, LONG lReleaseCount, LPLONG lpPreviousCount)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeSemaphore);
	return ReleaseSemaphore(hHandle->handle, lReleaseCount, lpPreviousCount);
}

DNHANDLE DNHandleTrackCreateFile(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	DWORD dwLastError;

	HANDLE h = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	if (h == INVALID_HANDLE_VALUE)
	{
		return DNINVALID_HANDLE_VALUE;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeFile;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

#ifndef DPNBUILD_SINGLEPROCESS
DNHANDLE DNHandleTrackCreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName)
{
	DWORD dwLastError;

	// If someone wants to actually map a file, we need to make param 1 a DNHANDLE and do the appropriate work here.
	DNASSERT(hFile == INVALID_HANDLE_VALUE);

	HANDLE h = CreateFileMapping(hFile, lpAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeFileMap;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackOpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = OpenFileMapping(dwDesiredAccess, bInheritHandle, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeFileMap;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}
#endif // ! DPNBUILD_SINGLEPROCESS

DWORD DNHandleTrackWaitForSingleObject(DNHANDLE hHandle, DWORD dwMilliseconds)
{
	DNASSERT(IsValidHandle(hHandle));
	return WaitForSingleObject(hHandle->handle, dwMilliseconds);
}

DWORD DNHandleTrackWaitForSingleObjectEx(DNHANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
{
	DNASSERT(IsValidHandle(hHandle));
	return WaitForSingleObjectEx(hHandle->handle, dwMilliseconds, bAlertable);
}

DWORD DNHandleTrackWaitForMultipleObjects(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds)
{
	DNASSERT(nCount <= MAXIMUM_WAIT_OBJECTS);
	HANDLE rgh[MAXIMUM_WAIT_OBJECTS];
	DWORD iHandle;

	for (iHandle = 0; iHandle < nCount; iHandle++)
	{
		DNASSERT(IsValidHandle(lpHandles[iHandle]));
		rgh[iHandle] = lpHandles[iHandle]->handle;
	}
	for (;iHandle < MAXIMUM_WAIT_OBJECTS; iHandle++)
	{
		rgh[iHandle] = 0;
	}
	return WaitForMultipleObjects(nCount, rgh, fWaitAll, dwMilliseconds);
}

DWORD DNHandleTrackWaitForMultipleObjectsEx(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
{
	DNASSERT(nCount <= MAXIMUM_WAIT_OBJECTS);
	HANDLE rgh[MAXIMUM_WAIT_OBJECTS];
	DWORD iHandle;

	for (iHandle = 0; iHandle < nCount; iHandle++)
	{
		DNASSERT(IsValidHandle(lpHandles[iHandle]));
		rgh[iHandle] = lpHandles[iHandle]->handle;
	}
	for (;iHandle < MAXIMUM_WAIT_OBJECTS; iHandle++)
	{
		rgh[iHandle] = 0;
	}
	return WaitForMultipleObjectsEx(nCount, rgh, fWaitAll, dwMilliseconds, bAlertable);
}

DWORD DNHandleTrackSignalObjectAndWait(DNHANDLE hObjectToSignal, DNHANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
{
	DNASSERT(IsValidHandle(hObjectToSignal));
	DNASSERT(IsValidHandle(hObjectToWaitOn));
	DNASSERT(hObjectToSignal->handle != hObjectToWaitOn->handle);

#ifdef WINNT
	return SignalObjectAndWait(hObjectToSignal->handle, hObjectToWaitOn->handle, dwMilliseconds, bAlertable);
#else // ! WINNT
	BOOL	fResult;

	fResult = SetEvent(hObjectToSignal->handle);
	DNASSERT(fResult);
	return WaitForSingleObjectEx(hObjectToWaitOn->handle, dwMilliseconds, bAlertable);
#endif // ! WINNT
}

BOOL DNHandleTrackCloseHandle(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));

	DNEnterCriticalSection(&g_HandleLock);
	hHandle->blHandle.RemoveFromList();
	DNLeaveCriticalSection(&g_HandleLock);

	HANDLE h = hHandle->handle;

	DNFree(hHandle);

	return CloseHandle(h);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\memorytracking.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryTracking.cpp
 *  Content:	Debug memory tracking for detecting leaks, overruns, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/14/2001	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"



#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
BOOL				g_fAllocationsAllowed = TRUE;
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

#ifdef DBG

#ifdef _WIN64
#define	GUARD_SIGNATURE	0xABABABABABABABAB
#else // !_WIN64
#define	GUARD_SIGNATURE	0xABABABAB
#endif // _WIN64

// Structure prepended to memory allocations to check for leaks.
struct MEMORY_HEADER
{
	CBilink			blLinkage;				 // size = two pointers
	DWORD_PTR		dwpSize;				 // size = pointer
	CCallStack		AllocCallStack;			 // size = 12 pointers
	DWORD_PTR		dwpPreGuard;			 // size = pointer
	// We want what follows to always be 16-byte aligned and #pragma pack doesn't seem to ensure that
};

CRITICAL_SECTION	g_AllocatedMemoryLock;
CBilink				g_blAllocatedMemory;
DWORD_PTR			g_dwpCurrentNumMemAllocations = 0;
DWORD_PTR			g_dwpCurrentMemAllocated = 0;
DWORD_PTR			g_dwpTotalNumMemAllocations = 0;
DWORD_PTR			g_dwpTotalMemAllocated = 0;
DWORD_PTR			g_dwpPeakNumMemAllocations = 0;
DWORD_PTR			g_dwpPeakMemAllocated = 0;

#endif // DBG



#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))

HANDLE				g_hMemoryHeap = NULL;




#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackInitialize"
BOOL DNMemoryTrackInitialize(DWORD_PTR dwpMaxMemUsage)
{
	// Ensure that we stay heap aligned for SLISTs
#ifdef _WIN64
	DBG_CASSERT(sizeof(MEMORY_HEADER) % 16 == 0);
#else // !_WIN64
	DBG_CASSERT(sizeof(MEMORY_HEADER) % 8 == 0);
#endif // _WIN64

	// Check for double init
	DNASSERT(g_hMemoryHeap == NULL);
#ifdef DPNBUILD_FIXEDMEMORYMODEL
	DNASSERT(dwpMaxMemUsage != 0);
#else // ! DPNBUILD_FIXEDMEMORYMODEL
	DNASSERT(dwpMaxMemUsage == 0);
#endif // ! DPNBUILD_FIXEDMEMORYMODEL

	DPFX(DPFPREP, 5, "Initializing Memory Tracking");

	// In debug we always maintain a separate heap and track allocations.  In retail, 
	// we don't track allocations, and will use the process heap except for
	// DPNBUILD_FIXEDMEMORYMODEL builds, where we use a separate heap so we
	// can cap the total allocation size.
#ifdef DPNBUILD_ONLYONETHREAD
	g_hMemoryHeap = HeapCreate(HEAP_NO_SERIALIZE,	// flags
#else // ! DPNBUILD_ONLYONETHREAD
	g_hMemoryHeap = HeapCreate(0,					// flags
#endif // ! DPNBUILD_ONLYONETHREAD
								dwpMaxMemUsage,		// initial size
								dwpMaxMemUsage		// maximum heap size (if 0, it can grow)
								);

	if (g_hMemoryHeap == NULL)
	{
		DPFX(DPFPREP,  0, "Failed to create memory heap!");
		return FALSE;
	}

#ifdef DBG
#pragma TODO(masonb, "Handle possibility of failure")
	InitializeCriticalSection(&g_AllocatedMemoryLock);

	g_blAllocatedMemory.Initialize();

	g_dwpCurrentNumMemAllocations = 0;
	g_dwpCurrentMemAllocated = 0;
	g_dwpTotalNumMemAllocations = 0;
	g_dwpTotalMemAllocated = 0;
	g_dwpPeakNumMemAllocations = 0;
	g_dwpPeakMemAllocated = 0;
#endif // DBG

	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackDeinitialize"
void DNMemoryTrackDeinitialize()
{
	// Validate the heap if we're on NT and a debug build, and then destroy the heap.
	if (g_hMemoryHeap != NULL)
	{
		BOOL	fResult;
#ifdef DBG
		DWORD	dwError;


		DPFX(DPFPREP, 5, "Deinitializing Memory Tracking");
		DPFX(DPFPREP, 5, "Total num mem allocations = %u", g_dwpTotalNumMemAllocations);
		DPFX(DPFPREP, 5, "Total mem allocated       = %u", g_dwpTotalMemAllocated);
		DPFX(DPFPREP, 5, "Peak num mem allocations  = %u", g_dwpPeakNumMemAllocations);
		DPFX(DPFPREP, 5, "Peak mem allocated        = %u", g_dwpPeakMemAllocated);

		DeleteCriticalSection(&g_AllocatedMemoryLock);

#ifdef WINNT
		// Validate heap contents before shutdown.  This code only works on NT.
		fResult = HeapValidate(g_hMemoryHeap, 0, NULL);
		if (! fResult)
		{
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem validating heap on destroy %d!", dwError );
			DNASSERT(! "Problem validating heap on destroy!");
		}
#endif // WINNT
#endif // DBG

		fResult = HeapDestroy(g_hMemoryHeap);
		if (! fResult)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem destroying heap %d!", dwError );
			DNASSERT(! "Problem destroying heap!");
#endif // DBG
		}

		g_hMemoryHeap = NULL;
	}
}

#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL



#ifdef DBG

#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackHeapAlloc"
void* DNMemoryTrackHeapAlloc(DWORD_PTR dwpSize)
{
	MEMORY_HEADER* pMemory;
	void* pReturn;

	DNASSERT(g_hMemoryHeap != NULL);

	// Voice and lobby currently try allocating 0 byte buffers, can't enable this check yet.
	//DNASSERT( Size > 0 );

	DNMemoryTrackValidateMemory();

	if (DNMemoryTrackAreAllocationsAllowed())
	{
		// We need enough room for our header plus what the user wants plus the guard signature at the end
		pMemory = (MEMORY_HEADER*)HeapAlloc(g_hMemoryHeap, 0, sizeof(MEMORY_HEADER) + dwpSize + sizeof(DWORD_PTR));
		if (pMemory != NULL)
		{
			pMemory->blLinkage.Initialize();
			pMemory->dwpSize = dwpSize;
			pMemory->AllocCallStack.NoteCurrentCallStack();
			pMemory->dwpPreGuard = GUARD_SIGNATURE;
			*(UNALIGNED DWORD_PTR*)((BYTE*)(pMemory + 1) + dwpSize) = GUARD_SIGNATURE;

			EnterCriticalSection(&g_AllocatedMemoryLock);
			pMemory->blLinkage.InsertAfter(&g_blAllocatedMemory);
			g_dwpCurrentNumMemAllocations++;
			g_dwpCurrentMemAllocated += dwpSize;
			g_dwpTotalNumMemAllocations++;
			g_dwpTotalMemAllocated += dwpSize;
			if (g_dwpCurrentNumMemAllocations > g_dwpPeakNumMemAllocations)
			{
				g_dwpPeakNumMemAllocations = g_dwpCurrentNumMemAllocations;
			}
			if (g_dwpCurrentMemAllocated > g_dwpPeakMemAllocated)
			{
				g_dwpPeakMemAllocated = g_dwpCurrentMemAllocated;
			}
			LeaveCriticalSection(&g_AllocatedMemoryLock);

			pReturn = pMemory + 1;

			// We require that the pointers we pass back are heap aligned
			DNASSERT(((DWORD_PTR)pReturn & 0xF) == 0 || // IA64
				     (((DWORD_PTR)pReturn & 0x7) == 0 && ((DWORD_PTR)pMemory & 0xF) == 0x8) || // NT32
					 (((DWORD_PTR)pReturn & 0x3) == 0 && ((DWORD_PTR)pMemory & 0xF) == 0x4) || // WIN9X
					 (((DWORD_PTR)pReturn & 0x3) == 0 && ((DWORD_PTR)pMemory & 0xF) == 0xC) // WIN9X
					 );

			DPFX(DPFPREP, 5, "Memory Allocated, pData[%p], Size[%d]", pReturn, dwpSize);
		}
		else
		{
			DPFX(DPFPREP, 0, "Failed allocating memory.");
			pReturn = NULL;
		}
	}
	else
	{
		DPFX(DPFPREP, 0, "Memory allocations are not currently allowed!");
		DNASSERT(! "Memory allocations are not currently allowed!");
		pReturn = NULL;
	}

	return pReturn;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackHeapFree"
void DNMemoryTrackHeapFree(void* pvData)
{
	CBilink* pbl;
	MEMORY_HEADER* pMemory;

	DNASSERT(g_hMemoryHeap != NULL);

	DNMemoryTrackValidateMemory();

	if (pvData == NULL)
	{
		return;
	}

	EnterCriticalSection( &g_AllocatedMemoryLock );

	// Verify that we know of this pointer
	pbl = g_blAllocatedMemory.GetNext();
	while (pbl != &g_blAllocatedMemory)
	{
		pMemory = CONTAINING_RECORD(pbl, MEMORY_HEADER, blLinkage);
		if ((pMemory + 1) == pvData)
		{
			break;
		}
		pbl = pbl->GetNext();
	}
	DNASSERT(pbl != &g_blAllocatedMemory);

	pMemory->blLinkage.RemoveFromList();
	g_dwpCurrentNumMemAllocations--;
	g_dwpCurrentMemAllocated -= pMemory->dwpSize;

	LeaveCriticalSection(&g_AllocatedMemoryLock);

	DPFX(DPFPREP, 5, "Memory Freed, pData[%p], Size[%d]", pMemory + 1, pMemory->dwpSize);

	// Zero it in case someone is still trying to use it
	memset(pMemory, 0, sizeof(MEMORY_HEADER) + pMemory->dwpSize + sizeof(DWORD_PTR));

	HeapFree(g_hMemoryHeap, 0, pMemory);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackValidateMemory"
void DNMemoryTrackValidateMemory()
{
	CBilink* pbl;
	MEMORY_HEADER* pMemory;
	LPCTSTR pszCause;
	DWORD_PTR dwpNumAllocations = 0;
	DWORD_PTR dwpTotalAllocated = 0;
	TCHAR CallStackBuffer[CALLSTACK_BUFFER_SIZE];

	DNASSERT(g_hMemoryHeap != NULL);

	// validate all of the allocated memory
	EnterCriticalSection( &g_AllocatedMemoryLock );

	pbl = g_blAllocatedMemory.GetNext();
	while (pbl != &g_blAllocatedMemory)
	{
		pMemory = CONTAINING_RECORD(pbl, MEMORY_HEADER, blLinkage);

		if (pMemory->dwpPreGuard != GUARD_SIGNATURE)
		{
			pszCause = _T("UNDERRUN DETECTED");
		}
		else if (*(UNALIGNED DWORD_PTR*)((BYTE*)(pMemory + 1) + pMemory->dwpSize) != GUARD_SIGNATURE)
		{
			pszCause = _T("OVERRUN DETECTED");
		}
		else
		{
			pszCause = NULL;
			dwpNumAllocations++;
			dwpTotalAllocated += pMemory->dwpSize;
		}

		if (pszCause)
		{
			pMemory->AllocCallStack.GetCallStackString(CallStackBuffer);

			DPFX(DPFPREP, 0, "Memory corruption[%s], pData[%p], Size[%d]\n%s", pszCause, pMemory + 1, pMemory->dwpSize, CallStackBuffer);

			DNASSERT(FALSE);
		}

		pbl = pbl->GetNext();
	}

	DNASSERT(dwpNumAllocations == g_dwpCurrentNumMemAllocations);
	DNASSERT(dwpTotalAllocated == g_dwpCurrentMemAllocated);

	LeaveCriticalSection(&g_AllocatedMemoryLock);

#ifdef WINNT
	// Ask the OS to validate the heap
	if (HeapValidate(g_hMemoryHeap, 0, NULL) == FALSE)
	{
		DNASSERT(FALSE);
	}
#endif // WINNT
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackDumpLeaks"
BOOL DNMemoryTrackDumpLeaks()
{
	MEMORY_HEADER* pMemory;
	TCHAR CallStackBuffer[CALLSTACK_BUFFER_SIZE];
	BOOL fLeaked = FALSE;

	DNASSERT(g_hMemoryHeap != NULL);

	EnterCriticalSection( &g_AllocatedMemoryLock );

	while (!g_blAllocatedMemory.IsEmpty())
	{
		pMemory = CONTAINING_RECORD(g_blAllocatedMemory.GetNext(), MEMORY_HEADER, blLinkage);

		pMemory->AllocCallStack.GetCallStackString(CallStackBuffer);

		DPFX(DPFPREP, 0, "Memory leaked, pData[%p], Size[%d]\n%s", pMemory + 1, pMemory->dwpSize, CallStackBuffer);

		pMemory->blLinkage.RemoveFromList();

		HeapFree(g_hMemoryHeap, 0, pMemory);

		fLeaked = TRUE;
	}

	LeaveCriticalSection(&g_AllocatedMemoryLock);

	return fLeaked;
}

#endif // DBG


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL

#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackAllowAllocations"
void DNMemoryTrackAllowAllocations(BOOL fAllow)
{
	DPFX(DPFPREP, 1, "Memory allocations allowed = %i.", fAllow);
	DNInterlockedExchange((LONG*) (&g_fAllocationsAllowed), fAllow);
}

#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\osind.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.cpp
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By	Reason
 *   ====		==	======
 *	07/12/99	jtk		Created
 *	09/21/99	rodtoll	Fixed for retail builds
 *	09/22/99	jtk		Added callstacks to memory allocations
 *	08/28/2000	masonb	Voice Merge: Allow new and delete with size of 0
 *  11/28/2000  rodtoll	WinBug #206257 - Retail DPNET.DLL links to DebugBreak()
 *  12/22/2000  aarono	ManBug # 190380 use process heap for retail
 *  10/16/2001  vanceo	Add AssertNoCriticalSectionsTakenByThisThread capability
 ***************************************************************************/

#include "dncmni.h"


#define PROF_SECT		_T("DirectPlay8")

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// debug variable to make sure we're initialized before having any functions
// called
//
DEBUG_ONLY( static	BOOL		g_fOSIndirectionLayerInitialized = FALSE );

//
// OS items
//
#if ((! defined(WINCE)) && (! defined(_XBOX)))
static OSVERSIONINFO g_OSVersionInfo;
#endif // ! WINCE and ! _XBOX

#ifndef DPNBUILD_NOSERIALSP
static HINSTANCE g_hApplicationInstance;
#endif // ! DPNBUILD_NOSERIALSP

//
// Global Pools
//
#if ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY)))
CFixedPool g_fpClassFactories;
CFixedPool g_fpObjectDatas;
CFixedPool g_fpInterfaceLists;
#endif // ! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY

#ifdef WINNT
PSECURITY_ATTRIBUTES g_psa = NULL;
SECURITY_ATTRIBUTES g_sa;
BYTE g_pSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
BOOL g_fDaclInited = FALSE;
PACL g_pEveryoneACL = NULL;
#endif // WINNT

#ifndef DPNBUILD_LIBINTERFACE
#define CLASSFAC_POOL_INITED 	0x00000001
#define OBJDATA_POOL_INITED 	0x00000002
#define INTLIST_POOL_INITED 	0x00000004
#endif // ! DPNBUILD_LIBINTERFACE
#ifdef DBG
#define HANDLE_TRACKING_INITED	0x00000008
#endif // DBG
#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))
#define MEMORY_TRACKING_INITED	0x00000010
#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL
#if ((defined(DBG)) && (! defined(DPNBUILD_ONLYONETHREAD)))
#define CRITSEC_TRACKING_INITED	0x00000020
#endif // DBG and ! DPNBUILD_ONLYONETHREAD

#if !defined(DPNBUILD_LIBINTERFACE) || defined(DBG) || defined(DPNBUILD_FIXEDMEMORYMODEL)
DWORD g_dwCommonInitFlags = 0;
#endif // !defined(DPNBUILD_LIBINTERFACE) || defined(DBG) || defined(DPNBUILD_FIXEDMEMORYMODEL)

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// DNOSIndirectionInit - initialize the OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization unsuccessful
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionInit"

BOOL	DNOSIndirectionInit( DWORD_PTR dwpMaxMemUsage )
{
	BOOL			fReturn;

#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized == FALSE );
#endif // DBG

	//
	// initialize
	//
	fReturn = TRUE;

#if ((! defined(WINCE)) && (! defined(_XBOX)))
	//
	// note OS version
	//
	memset( &g_OSVersionInfo, 0x00, sizeof( g_OSVersionInfo ) );
	g_OSVersionInfo.dwOSVersionInfoSize = sizeof( g_OSVersionInfo );
	if ( GetVersionEx( &g_OSVersionInfo ) == FALSE )
	{
		goto Failure;
	}
#endif // ! WINCE and ! _XBOX

#ifndef DPNBUILD_NOSERIALSP
	//
	// note application instance
	//
	g_hApplicationInstance = GetModuleHandle( NULL );
	if ( g_hApplicationInstance == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to GetModuleHandle: 0x%x", dwError );
		goto Failure;
	}
#endif // ! DPNBUILD_NOSERIALSP

#if ((defined(DBG)) && (! defined(DPNBUILD_ONLYONETHREAD)))
	//
	// initialize critical section tracking code before anything else!
	//
	if ( DNCSTrackInitialize() == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critsec tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
	g_dwCommonInitFlags |= CRITSEC_TRACKING_INITED;
#endif // DBG and ! DPNBUILD_ONLYONETHREAD

#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))
	//
	// initialize memory tracking before creating new memory heap
	//
	if ( DNMemoryTrackInitialize(dwpMaxMemUsage) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize memory tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
	g_dwCommonInitFlags |= MEMORY_TRACKING_INITED;
#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL

#ifdef DBG
	//
	// initialize handle tracking
	//
	if ( DNHandleTrackInitialize() == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize handle tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
	g_dwCommonInitFlags |= HANDLE_TRACKING_INITED;
#endif // DBG

#if ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY)))
	//
	// Initialize global pools
	//
	if (!g_fpClassFactories.Initialize( sizeof( _IDirectPlayClassFactory ), NULL, NULL, NULL, NULL))
	{
		DPFX(DPFPREP,  0, "Failed to initialize class factory pool!" );
		goto Failure;
	}
	g_dwCommonInitFlags |= CLASSFAC_POOL_INITED;

	if (!g_fpObjectDatas.Initialize( sizeof( _OBJECT_DATA ), NULL, NULL, NULL, NULL))
	{
		DPFX(DPFPREP,  0, "Failed to initialize object data pool!" );
		goto Failure;
	}
	g_dwCommonInitFlags |= OBJDATA_POOL_INITED;

	if (!g_fpInterfaceLists.Initialize( sizeof( _INTERFACE_LIST ), NULL, NULL, NULL, NULL))
	{
		DPFX(DPFPREP,  0, "Failed to initialize interface list pool!" );
		goto Failure;
	}
	g_dwCommonInitFlags |= INTLIST_POOL_INITED;
#endif // ! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY

	srand(GETTIMESTAMP());

#if (((! defined(WINCE)) && (! defined(_XBOX))) || (! defined(DPNBUILD_NOSERIALSP)) || (defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)) || ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY))) )
Exit:
#endif // (! WINCE and ! _XBOX) or ! DPNBUILD_NOSERIALSP or DBG or DPNBUILD_FIXEDMEMORYMODEL or (! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY)
	if ( fReturn != FALSE )
	{
		DEBUG_ONLY( g_fOSIndirectionLayerInitialized = TRUE );
	}

	return fReturn;

#if (((! defined(WINCE)) && (! defined(_XBOX))) || (! defined(DPNBUILD_NOSERIALSP)) || (defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)) || ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY))) )
Failure:
	fReturn = FALSE;

	DNOSIndirectionDeinit();

	goto Exit;
#endif // (! WINCE and ! _XBOX) or ! DPNBUILD_NOSERIALSP or DBG or DPNBUILD_FIXEDMEMORYMODEL or (! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY)
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNOSIndirectionDeinit - deinitialize OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionDeinit"

void	DNOSIndirectionDeinit( void )
{
#if ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY)))
	//
	// DeInitialize global pools
	//
	if (g_dwCommonInitFlags & CLASSFAC_POOL_INITED)
	{
		g_fpClassFactories.DeInitialize();
	}
	if (g_dwCommonInitFlags & OBJDATA_POOL_INITED)
	{
		g_fpObjectDatas.DeInitialize();
	}
	if (g_dwCommonInitFlags & INTLIST_POOL_INITED)
	{
		g_fpInterfaceLists.DeInitialize();
	}
#endif // ! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY

#ifdef DBG
	if (g_dwCommonInitFlags & HANDLE_TRACKING_INITED)
	{
		if (DNHandleTrackDumpLeaks())
		{
			// There were leaks, break so we can look at the log
			DNASSERT(0);
		}
		DNHandleTrackDeinitialize();
	}
#endif // DBG

#if ((defined(DBG)) && (! defined(DPNBUILD_ONLYONETHREAD)))
	//
	// Display CritSec leaks before displaying memory leaks, because displaying memory leaks
	// may free the memory for the CritSec and corrupt the CritSec bilink
	//
	if (g_dwCommonInitFlags & CRITSEC_TRACKING_INITED)
	{
		if (DNCSTrackDumpLeaks())
		{
			// There were leaks, break so we can look at the log
			DNASSERT(0);
		}
		DNCSTrackDeinitialize();
	}
#endif // DBG and ! DPNBUILD_ONLYONETHREAD

#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))
	if (g_dwCommonInitFlags & MEMORY_TRACKING_INITED)
	{
#ifdef DBG
		if (DNMemoryTrackDumpLeaks())
		{
			// There were leaks, break so we can look at the log
			DNASSERT(0);
		}
#endif // DBG
		DNMemoryTrackDeinitialize();
	}
#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL

#ifdef WINNT
	// This should be done after functions that use a Dacl will no longer be
	// called (CreateMutex, CreateFile, etc).
	if (g_pEveryoneACL)
	{
		HeapFree(GetProcessHeap(), 0, g_pEveryoneACL);
		g_pEveryoneACL = NULL;
	}
#endif // WINNT

	DEBUG_ONLY( g_fOSIndirectionLayerInitialized = FALSE );

#if !defined(DPNBUILD_LIBINTERFACE) || defined(DBG)
	g_dwCommonInitFlags = 0;
#endif // !defined(DPNBUILD_LIBINTERFACE) || defined(DBG)
}
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DNinet_ntow"
void DNinet_ntow( IN_ADDR in, WCHAR* pwsz )
{
	// NOTE: pwsz should be 16 characters (4 3-digit numbers + 3 '.' + \0)
	swprintf(pwsz, L"%d.%d.%d.%d", in.s_net, in.s_host, in.s_lh, in.s_impno);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNGetRandomNumber"
DWORD DNGetRandomNumber()
{
	return (rand() | (rand() << 16));
}

#if ((! defined(WINCE)) && (! defined(_XBOX)))
//**********************************************************************
// ------------------------------
// DNGetOSType - get OS type
//
// Entry:		Nothing
//
// Exit:		OS type
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetOSType"

UINT_PTR	DNGetOSType( void )
{
#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
#endif // DBG
	return	g_OSVersionInfo.dwPlatformId;
}
#endif // ! WINCE and ! _XBOX


#ifdef WINNT

//**********************************************************************
// ------------------------------
// DNOSIsXPOrGreater - return TRUE if OS is WindowsXP or later or NT flavor
//
// Entry:		Nothing
//
// Exit:		BOOL
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIsXPOrGreater"

BOOL DNOSIsXPOrGreater( void )
{
#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
#endif // DBG

	return ((g_OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
		    ((g_OSVersionInfo.dwMajorVersion > 5) || ((g_OSVersionInfo.dwMajorVersion == 5) && (g_OSVersionInfo.dwMinorVersion >= 1))) 
		    );
}

//**********************************************************************

//**********************************************************************
// ------------------------------
// DNGetNullDacl - get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accesible by all users.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl()
{
	PSID                     psidEveryone      = NULL;
	SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
	DWORD					 dwAclSize;

	// This is done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*)g_pSD, SECURITY_DESCRIPTOR_REVISION))
		{
			DPFX(DPFPREP,  0, "Failed to initialize security descriptor" );
			goto Error;
		}

		// Create SID for the Everyone group.
		if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0,
                                      0, 0, 0, 0, 0, 0, &psidEveryone))
		{
			DPFX(DPFPREP,  0, "Failed to allocate Everyone SID" );
			goto Error;
		}

		dwAclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidEveryone) - sizeof(DWORD);

		// Allocate the ACL, this won't be a tracked allocation and we will let process cleanup destroy it
		g_pEveryoneACL = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
		if (g_pEveryoneACL == NULL)
		{
			DPFX(DPFPREP,  0, "Failed to allocate ACL buffer" );
			goto Error;
		}

		// Intialize the ACL.
		if (!InitializeAcl(g_pEveryoneACL, dwAclSize, ACL_REVISION))
		{
			DPFX(DPFPREP,  0, "Failed to initialize ACL" );
			goto Error;
		}

		// Add the ACE.
		if (!AddAccessAllowedAce(g_pEveryoneACL, ACL_REVISION, GENERIC_ALL, psidEveryone))
		{
			DPFX(DPFPREP,  0, "Failed to add ACE to ACL" );
			goto Error;
		}

		// We no longer need the SID that was allocated.
		FreeSid(psidEveryone);
		psidEveryone = NULL;

		// Add the ACL to the security descriptor..
		if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*)g_pSD, TRUE, g_pEveryoneACL, FALSE))
		{
			DPFX(DPFPREP,  0, "Failed to add ACL to security descriptor" );
			goto Error;
		}

		g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		g_sa.lpSecurityDescriptor = g_pSD;
		g_sa.bInheritHandle = FALSE;

		g_psa = &g_sa;

		g_fDaclInited = TRUE;
	}
Error:
	if (psidEveryone)
	{
		FreeSid(psidEveryone);
		psidEveryone = NULL;
	}
	return g_psa;
}
//**********************************************************************
#endif // WINNT

#ifndef DPNBUILD_NOSERIALSP
//**********************************************************************
// ------------------------------
// DNGetApplicationInstance - application instance
//
// Entry:		Nothing
//
// Exit:		Application instance
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetApplicationInstance"

HINSTANCE	DNGetApplicationInstance( void )
{
#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
#endif // DBG
	return	g_hApplicationInstance;
}
//**********************************************************************
#endif // ! DPNBUILD_NOSERIALSP


#ifndef DPNBUILD_ONLYONETHREAD
//**********************************************************************
// ------------------------------
// DNOSInitializeCriticalSection - initialize a critical section
//
// Entry:		Pointer to critical section
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failue
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSInitializeCriticalSection"

BOOL DNOSInitializeCriticalSection( CRITICAL_SECTION* pCriticalSection )
{
	BOOL	fReturn;

	DNASSERT( pCriticalSection != NULL );
	fReturn = TRUE;

	//
	// attempt to enter the critical section once
	//
	_try
	{
#ifdef WINNT
			// Pre-allocate the critsec event by setting the high bit of the spin count and set spin to 1000
			// NT converts the spin to 0 for single proc machines.
			fReturn = InitializeCriticalSectionAndSpinCount( pCriticalSection , 0x80000000 | 1000);
#else
			InitializeCriticalSection( pCriticalSection );
#endif // WINNT
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		fReturn = FALSE;
	}

	_try
	{
		if (fReturn)
		{
			EnterCriticalSection( pCriticalSection );
		}
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		DeleteCriticalSection(pCriticalSection);
		fReturn = FALSE;
	}

	//
	// if we didn't fail on entering the critical section, make sure
	// we release it
	//
	if ( fReturn != FALSE )
	{
		LeaveCriticalSection( pCriticalSection );
	}

	return	fReturn;
}
//**********************************************************************
#endif // !DPNBUILD_ONLYONETHREAD


#ifdef DBG
#if ((defined(WINCE)) || ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP))))

#undef DPF_MODNAME
#define DPF_MODNAME "DNGetProfileInt"

UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault)
{
	DWORD		dwResult;
#ifndef _XBOX
	CRegistry	reg;
#endif // ! _XBOX


	DNASSERT(_tcscmp(lpszSection, _T("DirectPlay8")) == 0);

#ifdef _XBOX
#pragma TODO(vanceo, "Implement GetProfileInt functionality for Xbox")
	dwResult = nDefault;
#else // ! _XBOX
	if (!reg.Open(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\DirectPlay8")))
	{
		// NOTE: This will occur during DllRegisterServer for the first time
		return nDefault;
	}

	if (!reg.ReadDWORD(lpszEntry, &dwResult))
	{
		return nDefault;
	}
#endif // ! _XBOX

	return dwResult;
}

#endif // WINCE or (_XBOX and ! XBOX_ON_DESKTOP)
#endif // DBG



#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)

//**********************************************************************
//**
//** Begin CE layer.  Here we implement functions we need that aren't on CE.
//**
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "OpenEvent"

HANDLE WINAPI OpenEvent(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
	HANDLE h;

	h = CreateEvent(0, 1, 0, lpName);
	if (!h)
	{
		return NULL;
	}
	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		CloseHandle(h);
		return NULL;
	}
	return h;
}

#undef DPF_MODNAME
#define DPF_MODNAME "OpenFileMapping"

HANDLE WINAPI OpenFileMapping(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
	HANDLE h;
	DWORD dwFlags = 0;

	if (dwDesiredAccess & FILE_MAP_WRITE)
	{
		// If they ask for FILE_MAP_ALL_ACCESS or FILE_MAP_WRITE, they get read and write
		dwFlags = PAGE_READWRITE;
	}
	else
	{
		// If they only ask for FILE_MAP_READ, they get read only
		dwFlags = PAGE_READONLY;
	}

	h = CreateFileMapping(INVALID_HANDLE_VALUE, 0, dwFlags, 0, 1, lpName);
	if (!h)
	{
		return NULL;
	}
	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		CloseHandle(h);
		return NULL;
	}
	return h;
}

#undef DPF_MODNAME
#define DPF_MODNAME "OpenMutex"

HANDLE WINAPI OpenMutex(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
	HANDLE h;

	h = CreateMutex(0, 0, lpName);
	if (!h)
	{
		return NULL;
	}
	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		CloseHandle(h);
		return NULL;
	}
	return h;
}

/*
#ifdef _X86_
__declspec(naked)
LONG WINAPI InterlockedExchangeAdd( LPLONG Addend, LONG Increment )
{
	__asm 
	{
		mov			ecx, [esp + 4]	; get addend address
		mov			eax, [esp + 8]	; get increment value
		lock xadd	[ecx], eax	; exchange add}
		ret
	}
}
#endif // _X86
*/
#endif // WINCE
//**********************************************************************
//**
//** End CE layer.  Here we implement functions we need that aren't on CE.
//**
//**********************************************************************


#if ((defined(WINCE)) || (defined(DPNBUILD_LIBINTERFACE)))

#undef DPF_MODNAME
#define DPF_MODNAME "DNCoCreateGuid"

HRESULT DNCoCreateGuid(GUID* pguid)
{
	pguid->Data1 = (rand() << 16) | rand();
	pguid->Data2 = (WORD)rand();
	pguid->Data3 = (WORD)rand();
	pguid->Data4[0] = (BYTE)rand();
	pguid->Data4[1] = (BYTE)rand();
	pguid->Data4[2] = (BYTE)rand();
	pguid->Data4[3] = (BYTE)rand();
	pguid->Data4[4] = (BYTE)rand();
	pguid->Data4[5] = (BYTE)rand();
	pguid->Data4[6] = (BYTE)rand();
	pguid->Data4[7] = (BYTE)rand();

	return S_OK;
}

#endif // WINCE or DPNBUILD_LIBINTERFACE



#ifndef DPNBUILD_NOPARAMVAL

BOOL IsValidStringA( const CHAR * const lpsz )
{
#ifndef WINCE
	return (!IsBadStringPtrA( lpsz, 0xFFFF ) );
#else
	const char* szTmpLoc = lpsz;

	//
	// If it is a NULL pointer just return FALSE, they are always bad
	//
	if (szTmpLoc == NULL) 
	{
		return FALSE;
	}

	_try 
	{
		for( ; *szTmpLoc ; szTmpLoc++ );
	}
	_except(EXCEPTION_EXECUTE_HANDLER) 
	{
		return FALSE;
	}
    
	return TRUE;

#endif // WINCE
}

BOOL IsValidStringW( const WCHAR * const  lpwsz )
{
#ifndef WINCE
	return (!IsBadStringPtrW( lpwsz, 0xFFFF ) );
#else
	const wchar_t *szTmpLoc = lpwsz;
	
	//
	// If it is a NULL pointer just return FALSE, they are always bad
	//
	if( szTmpLoc == NULL )
	{
		return FALSE;
	}
	
	_try
	{
		for( ; *szTmpLoc ; szTmpLoc++ );
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		return FALSE;
	}

	return TRUE;
#endif // WINCE
}

#endif // !DPNBUILD_NOPARAMVAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\handletracking.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTracking.h
 *  Content:    Handle Tracking Header File
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/31/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef __HANDLETRACKING_H__
#define __HANDLETRACKING_H__

#ifdef DBG

BOOL DNHandleTrackInitialize();
VOID DNHandleTrackDeinitialize();
BOOL DNHandleTrackDumpLeaks();

enum HandleType
{
	TypeEvent,
	TypeMutex,
	TypeSemaphore,
	TypeFile,
	TypeFileMap,		// not used when DPNBUILD_SINGLEPROCESS defined
	TypeThread,
	TypeProcess,		// not used when DPNBUILD_SINGLEPROCESS defined
	TypeSpecial
};

struct TRACKED_HANDLE
{
	HANDLE handle;
	HandleType type;
	CBilink blHandle;
	CCallStack AllocCallStack;
};

typedef TRACKED_HANDLE* DNHANDLE;
#define DNINVALID_HANDLE_VALUE ((DNHANDLE)INVALID_HANDLE_VALUE)

#ifndef DPNBUILD_SINGLEPROCESS
struct DNPROCESS_INFORMATION
{
	DNHANDLE hProcess; 
    DNHANDLE hThread; 
    DWORD dwProcessId; 
    DWORD dwThreadId; 
};
#endif // ! DPNBUILD_SINGLEPROCESS

DNHANDLE DNHandleTrackMakeDNHANDLE(HANDLE h);
VOID	 DNHandleTrackRemoveDNHANDLE(DNHANDLE dnh);
HANDLE 	 DNHandleTrackHandleFromDNHANDLE(DNHANDLE h);

#ifndef DPNBUILD_SINGLEPROCESS
BOOL	 DNHandleTrackCreateProcess(LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, DNPROCESS_INFORMATION* lpProcessInformation);
DNHANDLE DNHandleTrackOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
#endif // ! DPNBUILD_SINGLEPROCESS

DNHANDLE DNHandleTrackCreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);

DNHANDLE DNHandleTrackCreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName);
DNHANDLE DNHandleTrackOpenEvent(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
BOOL	 DNHandleTrackSetEvent(DNHANDLE hHandle);
BOOL	 DNHandleTrackResetEvent(DNHANDLE hHandle);

DNHANDLE DNHandleTrackCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName);
DNHANDLE DNHandleTrackOpenMutex(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
BOOL	 DNHandleTrackReleaseMutex(DNHANDLE hHandle);

DNHANDLE DNHandleTrackCreateSemaphore(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName);
BOOL	 DNHandleTrackReleaseSemaphore(DNHANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);

DNHANDLE DNHandleTrackCreateFile(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
#ifndef DPNBUILD_SINGLEPROCESS
DNHANDLE DNHandleTrackCreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName);
DNHANDLE DNHandleTrackOpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
#endif // ! DPNBUILD_SINGLEPROCESS

DWORD	 DNHandleTrackWaitForSingleObject(DNHANDLE hHandle, DWORD dwMilliseconds);
DWORD	 DNHandleTrackWaitForSingleObjectEx(DNHANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
DWORD	 DNHandleTrackWaitForMultipleObjects(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds);
DWORD	 DNHandleTrackWaitForMultipleObjectsEx(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds, BOOL bAlertable);
DWORD	 DNHandleTrackSignalObjectAndWait(DNHANDLE hObjectToSignal, DNHANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);

BOOL	 DNHandleTrackCloseHandle(DNHANDLE hHandle);


#define MAKE_DNHANDLE(x) DNHandleTrackMakeDNHANDLE(x)
#define REMOVE_DNHANDLE(x) DNHandleTrackRemoveDNHANDLE(x)
#define HANDLE_FROM_DNHANDLE(x) DNHandleTrackHandleFromDNHANDLE(x)

#define DNCreateProcess DNHandleTrackCreateProcess
#define DNOpenProcess DNHandleTrackOpenProcess

#define DNCreateThread DNHandleTrackCreateThread

#define DNCreateEvent DNHandleTrackCreateEvent
#define DNOpenEvent DNHandleTrackOpenEvent
#define DNSetEvent DNHandleTrackSetEvent
#define DNResetEvent DNHandleTrackResetEvent

#define DNCreateMutex DNHandleTrackCreateMutex
#define DNOpenMutex DNHandleTrackOpenMutex
#define DNReleaseMutex DNHandleTrackReleaseMutex

#define DNCreateSemaphore DNHandleTrackCreateSemaphore
#define DNReleaseSemaphore DNHandleTrackReleaseSemaphore

#define DNCreateFile DNHandleTrackCreateFile
#define DNCreateFileMapping DNHandleTrackCreateFileMapping
#define DNOpenFileMapping DNHandleTrackOpenFileMapping

#define DNWaitForSingleObject DNHandleTrackWaitForSingleObject
#define DNWaitForSingleObjectEx DNHandleTrackWaitForSingleObjectEx
#define DNWaitForMultipleObjects DNHandleTrackWaitForMultipleObjects
#define DNWaitForMultipleObjectsEx DNHandleTrackWaitForMultipleObjectsEx
#define DNSignalObjectAndWait DNHandleTrackSignalObjectAndWait

#define DNCloseHandle DNHandleTrackCloseHandle

#else // !DBG

#define DNInitializeHandleTracking() TRUE
#define DNDeinitializeHandleTracking()
#define DNDumpLeakedHandles() FALSE

#define DNHANDLE HANDLE
#define DNINVALID_HANDLE_VALUE INVALID_HANDLE_VALUE
#define MAKE_DNHANDLE(x) x
#define REMOVE_DNHANDLE(x) 
#define HANDLE_FROM_DNHANDLE(x) x

#ifndef DPNBUILD_SINGLEPROCESS
#define DNPROCESS_INFORMATION PROCESS_INFORMATION
#define DNCreateProcess CreateProcess
#define DNOpenProcess OpenProcess
#endif // ! DPNBUILD_SINGLEPROCESS

#define DNCreateThread CreateThread

#define DNCreateEvent CreateEvent
#define DNOpenEvent OpenEvent
#define DNSetEvent SetEvent
#define DNResetEvent ResetEvent

#define DNCreateMutex CreateMutex
#define DNOpenMutex OpenMutex
#define DNReleaseMutex ReleaseMutex

#define DNCreateSemaphore CreateSemaphore
#define DNReleaseSemaphore ReleaseSemaphore

#define DNCreateFile CreateFile
#ifndef DPNBUILD_SINGLEPROCESS
#define DNCreateFileMapping CreateFileMapping
#define DNOpenFileMapping OpenFileMapping
#endif // ! DPNBUILD_SINGLEPROCESS

#define DNWaitForSingleObject WaitForSingleObject

#define DNWaitForSingleObjectEx WaitForSingleObjectEx
#define DNWaitForMultipleObjects WaitForMultipleObjects
#define DNWaitForMultipleObjectsEx WaitForMultipleObjectsEx
#ifdef WINNT
#define DNSignalObjectAndWait SignalObjectAndWait
#else // ! WINNT
#define DNSignalObjectAndWait(hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable) SetEvent(hObjectToSignal),WaitForSingleObjectEx(hObjectToWaitOn, dwMilliseconds, bAlertable)
#endif // ! WINNT

#define DNCloseHandle CloseHandle

#endif // DBG

#endif // __HANDLETRACKING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\osind.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.h
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/12/1999	jtk		Created
 *	10/16/2001	vanceo		Added AssertNoCriticalSectionsTakenByThisThread capability
 *
 ***************************************************************************/

#ifndef	__OSIND_H__
#define	__OSIND_H__

#include "CallStack.h"
#include "ClassBilink.h"
#include "HandleTracking.h"
#include "CritsecTracking.h"
#include "MemoryTracking.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define GUID_STRING_LEN 39

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif // OFFSETOF

#ifndef	LENGTHOF
#define	LENGTHOF( arg )				( sizeof( arg ) / sizeof( arg[ 0 ] ) )
#endif // OFFSETOF

#ifndef _MIN
#define _MIN(a, b) ((a) < (b) ? (a) : (b))
#endif // _MIN

#ifndef _MAX
#define _MAX(a, b) ((a) > (b) ? (a) : (b))
#endif // _MAX

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// initialization functions
//
BOOL	DNOSIndirectionInit( DWORD_PTR dwpMaxMemUsage );
void	DNOSIndirectionDeinit( void );

#ifndef DPNBUILD_NOPARAMVAL

extern BOOL IsValidStringA( const CHAR * const swzString );
#define DNVALID_STRING_A(a)		IsValidStringA(a)

extern BOOL IsValidStringW( const WCHAR * const szString );
#define DNVALID_STRING_W(a)		IsValidStringW(a)

#define DNVALID_WRITEPTR(a,b)	(!IsBadWritePtr(a,b))
#define DNVALID_READPTR(a,b)	(!IsBadReadPtr(a,b))

#endif // ! DPNBUILD_NOPARAMVAL

//
// Function to get OS version.  Supported returns:
//	VER_PLATFORM_WIN32_WINDOWS - Win9x
//	VER_PLATFORM_WIN32_NT - WinNT
//	VER_PLATFORM_WIN32s - Win32s on Win3.1
//	VER_PLATFORM_WIN32_CE - WinCE
//	
#if ((! defined(WINCE)) && (! defined(_XBOX)))
UINT_PTR	DNGetOSType( void );
#endif // ! WINCE and ! _XBOX

struct in_addr;
typedef struct in_addr IN_ADDR;
void DNinet_ntow( IN_ADDR sin, WCHAR* pwsz );

#ifdef WINNT
BOOL		DNOSIsXPOrGreater( void );
#endif // WINNT

#ifndef DPNBUILD_NOSERIALSP
// Used only by serial provider
HINSTANCE	DNGetApplicationInstance( void );
#endif // ! DPNBUILD_NOSERIALSP

#ifdef WINNT
PSECURITY_ATTRIBUTES DNGetNullDacl();
#else
#define DNGetNullDacl() 0
#endif // WINNT

#ifndef VER_PLATFORM_WIN32_CE
#define VER_PLATFORM_WIN32_CE           3
#endif // VER_PLATFORM_WIN32_CE

#if ((defined(WINCE)) || (defined(_XBOX)))
#define	IsUnicodePlatform TRUE
#else // ! WINCE and ! _XBOX
#define	IsUnicodePlatform (DNGetOSType() == VER_PLATFORM_WIN32_NT || DNGetOSType() == VER_PLATFORM_WIN32_CE)
#endif // ! WINCE and ! _XBOX


#ifdef WINCE
#define GETTIMESTAMP() GetTickCount()
#else
#define GETTIMESTAMP() timeGetTime()
#endif // WINCE

DWORD DNGetRandomNumber();

//
// Interlocked functions (not actually interlocked when DPNBUILD_ONLYONETHREAD)
//
#ifdef DPNBUILD_ONLYONETHREAD
inline LONG DNInterlockedIncrement( IN OUT LONG volatile *Addend )
{
	return ++(*Addend);
}
inline LONG DNInterlockedDecrement( IN OUT LONG volatile *Addend )
{
	return --(*Addend);
}
inline LONG DNInterlockedExchange( IN OUT LONG volatile *Target, IN LONG Value )
{
	LONG	Previous;


	Previous = *Target;
	*Target = Value;
	return Previous;
}
inline LONG DNInterlockedExchangeAdd( IN OUT LONG volatile *Addend, IN LONG Value )
{
	LONG	Previous;


	Previous = *Addend;
	*Addend = Previous + Value;
	return Previous;
}
inline LONG DNInterlockedCompareExchange( IN OUT LONG volatile *Destination, IN LONG Exchange, IN LONG Comperand )
{
	LONG	Previous;


	Previous = *Destination;
	if (Previous == Comperand)
	{
		*Destination = Exchange;
	}
	return Previous;
}
inline PVOID DNInterlockedCompareExchangePointer( IN OUT PVOID volatile *Destination, IN PVOID Exchange, IN PVOID Comperand )
{
	PVOID	Previous;


	Previous = *Destination;
	if (Previous == Comperand)
	{
		*Destination = Exchange;
	}
	return Previous;
}
inline PVOID DNInterlockedExchangePointer( IN OUT PVOID volatile *Target, IN PVOID Value )
{
	PVOID	Previous;


	Previous = *Target;
	*Target = Value;
	return Previous;
}
#else // ! DPNBUILD_ONLYONETHREAD
/*
#ifdef WINCE
#if defined(_ARM_)
#define InterlockedExchangeAdd \
        ((long (*)(long *target, long increment))(PUserKData+0x3C0))
#elif defined(_X86_)
LONG WINAPI InterlockedExchangeAdd( LPLONG Addend, LONG Increment );
#else
#error("Unknown platform")
#endif // Platform
#endif // WINCE
*/
#define DNInterlockedIncrement( Addend )											InterlockedIncrement( Addend )
#define DNInterlockedDecrement( Addend )											InterlockedDecrement( Addend )
#define DNInterlockedExchange( Target, Value )										InterlockedExchange( Target, Value )
#define DNInterlockedExchangeAdd( Target, Value )									InterlockedExchangeAdd( Target, Value )
#ifdef WINCE
// NOTE: Params 2 and 3 reversed intentionally, CE is that way
#define DNInterlockedCompareExchange( Destination, Exchange, Comperand )			InterlockedTestExchange( Destination, Comperand, Exchange )
#else // !WINCE
#define DNInterlockedCompareExchange( Destination, Exchange, Comperand )			InterlockedCompareExchange( Destination, Exchange, Comperand )
#endif // WINCE
#define DNInterlockedCompareExchangePointer( Destination, Exchange, Comperand )		InterlockedCompareExchangePointer( Destination, Exchange, Comperand )
#define DNInterlockedExchangePointer( Target, Value )								InterlockedExchangePointer( Target, Value )
#endif // ! DPNBUILD_ONLYONETHREAD

// Special initialize to set spin count, avoid out-of-memory exceptions at Enter/Leave
BOOL DNOSInitializeCriticalSection( CRITICAL_SECTION* pCriticalSection );

#ifdef WINNT
#define GLOBALIZE_STR _T("Global\\")
#else
#define GLOBALIZE_STR _T("")
#endif // WINNT

#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)
#define _TWINCE(x) __T(x)
#else
#define _TWINCE(x) x
#endif // WINCE

//
// Memory functions
//

#ifdef DPNBUILD_LIBINTERFACE

#define new		__wont_compile_dont_use_new_operator__
#define delete	__wont_compile_dont_use_delete_operator__

#else // ! DPNBUILD_LIBINTERFACE

//**********************************************************************
// ------------------------------
// operator new - allocate memory for a C++ class
//
// Entry:		Size of memory to allocate
//
// Exit:		Pointer to memory
//				NULL = no memory available
//
// Notes:	This function is for classes only and will ASSERT on zero sized
//			allocations!  This function also doesn't do the whole proper class
//			thing of checking for replacement 'new handlers' and will not throw
//			an exception if allocation fails.
// ------------------------------
inline	void*	__cdecl operator new( size_t size )
{
	return DNMalloc( size );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// operator delete - deallocate memory for a C++ class
//
// Entry:		Pointer to memory
//
// Exit:		Nothing
//
// Notes:	This function is for classes only and will ASSERT on NULL frees!
// ------------------------------
inline	void	__cdecl operator delete( void *pData )
{
	//
	// Voice and lobby currently try allocating 0 byte buffers, can't disable this check yet.
	//
	if( pData == NULL )
		return;
	
	DNFree( pData );
}
//**********************************************************************

#endif // ! DPNBUILD_LIBINTERFACE


#ifdef WINCE
#ifdef DBG
UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);
#endif // DBG

#ifndef WINCE_ON_DESKTOP
HANDLE WINAPI OpenEvent(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName);
HANDLE WINAPI OpenFileMapping(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName);
HANDLE WINAPI OpenMutex(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName);
#endif // !WINCE_ON_DESKTOP

#define WaitForSingleObjectEx(handle, time, fAlertable) WaitForSingleObject(handle, time)
#define WaitForMultipleObjectsEx(count, handles, waitall, time, fAlertable) WaitForMultipleObjects(count, handles, waitall, time)
#ifndef WINCE_ON_DESKTOP
#define GetWindowLongPtr(a, b) GetWindowLong(a, b)
#define GWLP_USERDATA GWL_USERDATA
#define SetWindowLongPtr(a, b, c) SetWindowLong(a, b, c)
#endif // WINCE_ON_DESKTOP
#define SleepEx(a, b) Sleep(a)

#ifndef MUTEX_ALL_ACCESS
#define MUTEX_ALL_ACCESS 0
#endif // MUTEX_ALL_ACCESS
#ifndef NORMAL_PRIORITY_CLASS
#define NORMAL_PRIORITY_CLASS 0
#endif // NORMAL_PRIORITY_CLASS

#else // ! WINCE
#ifdef DBG
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);
#else // ! _XBOX or XBOX_ON_DESKTOP
#define DNGetProfileInt(lpszSection, lpszEntry, nDefault)	GetProfileInt(lpszSection, lpszEntry, nDefault)
#endif// ! _XBOX or XBOX_ON_DESKTOP
#endif // DBG
#endif // ! WINCE

#if ((defined(WINCE)) || (defined(DPNBUILD_LIBINTERFACE)))
HRESULT DNCoCreateGuid(GUID* pguid);
#else // ! WINCE and ! DPNBUILD_LIBINTERFACE
#define DNCoCreateGuid CoCreateGuid
#endif // ! WINCE and ! DPNBUILD_LIBINTERFACE

#ifdef _XBOX
#define swprintf	wsprintfW
#endif // _XBOX

#endif	// __OSIND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\sources.inc ===
TARGETNAME=common
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dncmni.h
PRECOMPILED_PCH=dncmni.pch
PRECOMPILED_OBJ=dncmni.obj

INCLUDES=..\;..\..\inc;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES= \
	CallStack.cpp \
        creg.cpp \
	CritsecTracking.cpp \
	dndbg.cpp \
	HandleTracking.cpp \
	MemoryTracking.cpp \
	osind.cpp \
	strutils.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\strutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.h
 *  Content:    Defines the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __STRUTILS_H
#define __STRUTILS_H

HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr);
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr);

#ifndef WINCE

HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);

HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
						const DWORD dwWCHARStringLength,
						char *const pString,
						DWORD *const pdwStringLength );

HRESULT	STR_AnsiToWide( const char *const pString,
						const DWORD dwStringLength,
						WCHAR *const pWCHARString,
						DWORD *const pdwWCHARStringLength );

#endif // !WINCE

#endif // __STRUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\common\strutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.cpp
 *  Content:    Implements the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *   08/28/2000	masonb	Voice Merge: Added check of return code of MultiByteToWideChar in STR_jkAnsiToWide
 *   09/16/2000 aarono  fix STR_AllocAndConvertToANSI, ANSI doesn't mean 1 byte per DBCS character so we
 *                       must allow up to 2 bytes per char when allocating buffer (B#43286)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncmni.h"

/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkWideToAnsi"
HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr)
{
	int rval;
	BOOL fDefault = FALSE;

	// can't call us w/ null pointer & non-zero cch
	DNASSERT(lpWStr || !cchStr);

	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,NULL,&fDefault);

	DNASSERT(!fDefault);
	
	if(rval == 0)
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

} // WideToAnsi

#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkAnsiToWide"
/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 */
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr)
{
	int rval;

	DNASSERT(lpStr);
	DNASSERT(lpWStr);

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
	if (!rval)
	{
		DPFX(DPFPREP,0,"MultiByteToWideChar failed in STR_jkAnsiToWide");
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}  // AnsiToWide

#ifndef WINCE

#undef DPF_MODNAME
#define DPF_MODNAME "STR_WideToAnsi"

//**********************************************************************
// ------------------------------
// WideToANSI - convert a wide string to an ANSI string
//
// Entry:		Pointer to source wide string
//				Size of source string (in WCHAR units, -1 implies NULL-terminated)
//				Pointer to ANSI string destination
//				Pointer to size of ANSI destination
//
// Exit:		Error code:
//				E_FAIL = operation failed
//				S_OK = operation succeded
//				E_OUTOFMEMORY = destination buffer too small
// ------------------------------
HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
						const DWORD dwWCHARStringLength,
						char *const pString,
						DWORD *const pdwStringLength )
{
	HRESULT	hr;
	int		iReturn;
	BOOL	fDefault;
	char	cMilleniumHackBuffer;	
	char	*pMilleniumHackBuffer;


	DNASSERT( pWCHARString != NULL );
	DNASSERT( pdwStringLength != NULL );
	DNASSERT( ( pString != NULL ) || ( *pdwStringLength == 0 ) );

	//
	// Initialize.  A hack needs to be implemented for WinME parameter
	// validation, because when you pass zero for a destination size, you
	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
	//
	hr = S_OK;

	if ( *pdwStringLength == 0 )
	{
		pMilleniumHackBuffer = &cMilleniumHackBuffer;
	}
	else
	{
		pMilleniumHackBuffer = pString;
	}

	fDefault = FALSE;
	iReturn = WideCharToMultiByte( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pWCHARString,			// pointer to WCHAR string
								   dwWCHARStringLength,		// size of WCHAR string
								   pMilleniumHackBuffer,	// pointer to destination ANSI string
								   *pdwStringLength,		// size of destination string
								   NULL,					// pointer to default for unmappable characters (none)
								   &fDefault				// pointer to flag indicating that default was used
								   );
	if ( iReturn == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX( DPFPREP, 0, "Failed to convert WCHAR to multi-byte! %d", dwError );
		hr = E_FAIL;
	}
	else
	{
		if ( *pdwStringLength == 0 )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			DNASSERT( hr == S_OK );
		}

		*pdwStringLength = iReturn;
	}

	//
	// if you hit this ASSERT it's because you've probably got ASCII text as your
	// input WCHAR string.  Double-check your input!!
	//
	DNASSERT( fDefault == FALSE );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ANSIToWide - convert an ANSI string to a wide string
//
// Entry:		Pointer to source multi-byte (ANSI) string
//				Size of source string (-1 imples NULL-terminated)
//				Pointer to multi-byte string destination
//				Pointer to size of multi-byte destination (in WCHAR units)
//
// Exit:		Error code:
//				E_FAIL = operation failed
//				S_OK = operation succeded
//				E_OUTOFMEMORY = destination buffer too small
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "STR_AnsiToWide"
HRESULT	STR_AnsiToWide( const char *const pString,
						const DWORD dwStringLength,
						WCHAR *const pWCHARString,
						DWORD *const pdwWCHARStringLength )
{
	HRESULT	hr;
	int		iReturn;
	WCHAR	MilleniumHackBuffer;
	WCHAR	*pMilleniumHackBuffer;


	DNASSERT( pString != NULL );
	DNASSERT( pdwWCHARStringLength != NULL );
	DNASSERT( ( pWCHARString != NULL ) || ( *pdwWCHARStringLength == 0 ) );

	//
	// Initialize.  A hack needs to be implemented for WinME parameter
	// validation, because when you pass zero for a destination size, you
	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
	//
	hr = S_OK;

	if ( *pdwWCHARStringLength == 0 )
	{
		pMilleniumHackBuffer = &MilleniumHackBuffer;
	}
	else
	{
		pMilleniumHackBuffer = pWCHARString;
	}
	
	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pString,					// pointer to multi-byte string			
								   dwStringLength,			// size of string (assume null-terminated)
								   pMilleniumHackBuffer,	// pointer to destination wide-char string
								   *pdwWCHARStringLength	// size of destination in WCHARs
								   );
	if ( iReturn == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to convert multi-byte to WCHAR! %d", dwError );
		hr = E_FAIL;
	}
	else
	{
		if ( *pdwWCHARStringLength == 0 )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			DNASSERT( hr == S_OK );
		}

		*pdwWCHARStringLength = iReturn;
	}

	return	hr;
}
//**********************************************************************




//	WideToAnsi
//
//	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
//
//	CHAR	*pStr		CHAR string
//	WCHAR	*pWStr		WCHAR string
//	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
#undef DPF_MODNAME
#define DPF_MODNAME "STR_AllocAndConvertToANSI"
/*
 ** GetAnsiString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszAnsi - pointer to string
 *				lpszWide - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and converts lpszWide to ansi
 *
 *  RETURNS: string length
 *
 */
HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
{
	int iStrLen;
	BOOL bDefault;
	
	DNASSERT(ppszAnsi);

	if (!lpszWide)
	{
		*ppszAnsi = NULL;
		return S_OK;
	}

	*ppszAnsi = (char*) DNMalloc((wcslen(lpszWide)*2+1)*sizeof(char));
	if (!*ppszAnsi)	
	{
		DPFX(DPFPREP,0, "could not get ansi string -- out of memory");
		return E_OUTOFMEMORY;
	}

	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)*2+1,
			NULL,&bDefault);

	return S_OK;
} // OSAL_AllocAndConvertToANSI



#endif // !WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpastclassfac.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnhupnpclassfac.cpp
 *
 *  Content:	a generic class factory.
 *
 *
 *	This is a generic C++ class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instance of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *	10/13/98  jwo		Created it.
 *	04/08/01  vanceo	Converted to C++.
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/


#include "dpnhpasti.h"



#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// class factory class definition
//
typedef class GPClassFactory:public IClassFactory
{
	public:
		GPClassFactory(const CLSID * pclsid)	{ m_dwRefCnt = 0; memcpy(&m_clsid, pclsid, sizeof(CLSID)); };
		~GPClassFactory(void)				{};


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);
		STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
		STDMETHODIMP LockServer(BOOL fLock);


	private:
		DWORD		m_dwRefCnt;
		CLSID		m_clsid;
} GPCLASSFACTORY, *LPGPCLASSFACTORY;


//
// function prototype for CoLockObjectExternal()
//
typedef	HRESULT (WINAPI * PCOLOCKOBJECTEXTERNAL)(LPUNKNOWN, BOOL, BOOL );

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// count of outstanding COM interfaces, defined in dpnathlpdllmain.cpp
//
extern volatile LONG	g_lOutstandingInterfaceCount;



//**********************************************************************
// Function prototypes
//**********************************************************************


//**********************************************************************
// Function definitions
//**********************************************************************




/*
 * GPClassFactory::QueryInterface
 */
STDMETHODIMP GPClassFactory::QueryInterface(
											REFIID riid,
											LPVOID *ppvObj )
{
	HRESULT hr;

    *ppvObj = NULL;


    if( IsEqualIID(riid, IID_IClassFactory) ||
                    IsEqualIID(riid, IID_IUnknown))
    {
        this->m_dwRefCnt++;
        *ppvObj = this;
		hr = S_OK;
    }
    else
    {
		hr = E_NOINTERFACE;
    }


	return hr;

} /* GPClassFactory::QueryInterface */


/*
 * GPClassFactory::AddRef
 */
STDMETHODIMP_(ULONG) GPClassFactory::AddRef( void )
{
    this->m_dwRefCnt++;
    return this->m_dwRefCnt;
} /* GPClassFactory::AddRef */



/*
 * GPClassFactory::Release
 */
STDMETHODIMP_(ULONG) GPClassFactory::Release( void )
{
    this->m_dwRefCnt--;

    if( this->m_dwRefCnt != 0 )
    {
        return this->m_dwRefCnt;
    }

    delete this;
    return 0;

} /* GPClassFactory::Release */




/*
 * GPClassFactory::CreateInstance
 *
 * Creates an instance of the object
 */
STDMETHODIMP GPClassFactory::CreateInstance(
											LPUNKNOWN pUnkOuter,
											REFIID riid,
    										LPVOID *ppvObj
											)
{
    HRESULT					hr = S_OK;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(this, pUnkOuter, this->m_clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* GPClassFactory::CreateInstance */



/*
 * GPClassFactory::LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP GPClassFactory::LockServer(
                BOOL fLock
				)
{
    HRESULT		hr;
    HINSTANCE	hdll;


    /*
     * call CoLockObjectExternal
     */
    hr = E_UNEXPECTED;
    hdll = LoadLibrary( _T("OLE32.DLL") );
    if( hdll != NULL )
    {
        PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;


		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
        }
        else
        {
        }
    }
    else
    {
    }

	return hr;

} /* GPClassFactory::LockServer */



/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
EXP STDAPI  DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
    HRESULT		hr;

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
//	you must implement GetClassID() for your specific COM object
	if (!IsClassImplemented(rclsid))
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, IID_IUnknown ) &&
	    !IsEqualIID( riid, IID_IClassFactory ) )
    {
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = new GPClassFactory(&rclsid);
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

    hr = pcf->QueryInterface( riid, ppvObj );
    if( FAILED( hr ) )
    {
        delete pcf;
        *ppvObj = NULL;
    }
    else
    {
    }

    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
EXP STDAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

	
	if ( g_lOutstandingInterfaceCount == 0 )
	{
		hr = S_OK;
	}

    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpastcachemap.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhpastcachemap.h
 *
 *  Content:	Header for cached mapping object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



//=============================================================================
// Object flags
//=============================================================================
#define CACHEMAPOBJ_TCP					DPNHQUERYADDRESS_TCP						// a TCP port instead of UDP
#define CACHEMAPOBJ_NOTFOUND			DPNHQUERYADDRESS_CACHENOTFOUND				// the address was actually not found
#define CACHEMAPOBJ_PRIVATEBUTUNMAPPED	DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED	// the address is private, but was not mapped on the Internet gateway



//=============================================================================
// Macros
//=============================================================================
#define CACHEMAP_FROM_BILINK(b)		(CONTAINING_OBJECT(b, CCacheMap, m_blList))

//
// TCP queries need to match TCP mappings, (and UDP needs to match UDP).
//
#define QUERYFLAGSMASK(dwFlags)		(dwFlags & DPNHQUERYADDRESS_TCP)



//=============================================================================
// Forward declarations
//=============================================================================
class CCacheMap;




//=============================================================================
// Main interface object class
//=============================================================================
class CCacheMap
{
	public:
#undef DPF_MODNAME
#define DPF_MODNAME "CCacheMap::CCacheMap"
		CCacheMap(const SOCKADDR_IN * const psaddrinQueryAddress,
				const DWORD dwExpirationTime,
				const DWORD dwFlags)
		{
			this->m_blList.Initialize();

			this->m_Sig[0] = 'C';
			this->m_Sig[1] = 'M';
			this->m_Sig[2] = 'A';
			this->m_Sig[3] = 'P';
			this->m_dwQueryAddressV4	= psaddrinQueryAddress->sin_addr.S_un.S_addr;
			this->m_wQueryPort			= psaddrinQueryAddress->sin_port;
			this->m_dwFlags				= dwFlags; // works because CACHEMAPOBJ_xxx == DPNHQUERYADDRESS_xxx.
			this->m_dwExpirationTime	= dwExpirationTime;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CCacheMap::~CCacheMap"
		~CCacheMap(void)
		{
			DNASSERT(this->m_blList.IsEmpty());
		};

		inline BOOL DoesMatchQuery(const SOCKADDR_IN * const psaddrinQueryAddress,
									const DWORD dwFlags) const
		{
			//
			// Is this even the right address?
			//
			if ((this->m_dwQueryAddressV4 != psaddrinQueryAddress->sin_addr.S_un.S_addr) ||
				(this->m_wQueryPort != psaddrinQueryAddress->sin_port))
			{
				return FALSE;
			}

			//
			// Of the ones that matter (QUERYFLAGSMASK), make sure all
			// required flags are present, and all flags that aren't
			// required are not present.
			// Remember CACHEMAPOBJ_xxx == DPNHQUERYADDRESS_xxx.
			//
			return ((QUERYFLAGSMASK(this->m_dwFlags) == QUERYFLAGSMASK(dwFlags)) ? TRUE : FALSE);
		};

		inline BOOL IsNotFound(void) const					{ return ((this->m_dwFlags & CACHEMAPOBJ_NOTFOUND) ? TRUE : FALSE); };
		inline BOOL IsPrivateButUnmapped(void) const			{ return ((this->m_dwFlags & CACHEMAPOBJ_PRIVATEBUTUNMAPPED) ? TRUE : FALSE); };

		inline void GetResponseAddressV4(SOCKADDR_IN * const psaddrinAddress) const
		{
			ZeroMemory(psaddrinAddress, sizeof(*psaddrinAddress));
			psaddrinAddress->sin_family				= AF_INET;
			psaddrinAddress->sin_addr.S_un.S_addr	= this->m_dwResponseAddressV4;
			psaddrinAddress->sin_port				= this->m_wResponsePort;
		};

		inline DWORD GetExpirationTime(void) const			{ return this->m_dwExpirationTime; };

		inline void SetResponseAddressV4(const DWORD dwAddressV4,
										const WORD wPort)
		{
			this->m_dwResponseAddressV4	= dwAddressV4;
			this->m_wResponsePort		= wPort;
		};


		CBilink		m_blList;		// list of all the mappings cached

	
	private:
		BYTE	m_Sig[4];				// debugging signature ('CMAP')
		DWORD	m_dwFlags;				// flags for this object

		DWORD	m_dwQueryAddressV4;		// IPv4 address searched
		WORD	m_wQueryPort;			// IPv4 port searched
		DWORD	m_dwResponseAddressV4;	// IPv4 address mapping corresponding to query
		WORD	m_wResponsePort;		// IPv4 port mapping corresponding to query
		DWORD	m_dwExpirationTime;		// time when this cached mapping expires
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpastdevice.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhpastdevice.h
 *
 *  Content:	Header for device object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/




//=============================================================================
// Object flags
//=============================================================================
#define DEVICE_LOCALPASTSERVER_ICS						0x01	// the local PAST server is an Internet Connection Sharing server
#define DEVICE_LOCALPASTSERVER_PFWONLY					0x02	// the local PAST server is a personal firewall server only
#define DEVICE_LOCALPASTSERVER_PUBLICADDRESSAVAILABLE	0x04	// the local PAST server has public addresses available
#define DEVICE_REMOTEPASTSERVER_PUBLICADDRESSAVAILABLE	0x08	// the remote PAST server has public addresses available
#ifdef DBG
   #define DEVICE_PRIMARY								0x10	// this device appears to be the primary adapter with which its gateway should be reached
   #define DEVICE_SECONDARY								0x20	// this device appears to be a secondary adapter on a shared network
   #define DEVICE_NOGATEWAY								0x40	// this device does not currently have a gateway
#endif // DBG


//=============================================================================
// Macros
//=============================================================================
#define DEVICE_FROM_BILINK(b)		(CONTAINING_OBJECT(b, CDevice, m_blList))
#define DEVICE_FROM_TEMP_BILINK(b)	(CONTAINING_OBJECT(b, CDevice, m_blTempList))



//=============================================================================
// Typedefs
//=============================================================================
class CDevice;





//=============================================================================
// Device object class
//=============================================================================
class CDevice
{
	public:
#undef DPF_MODNAME
#define DPF_MODNAME "CDevice::CDevice"
		CDevice(const DWORD dwLocalAddressV4)
		{
			this->m_blList.Initialize();
			this->m_blTempList.Initialize();
			this->m_blOwnedRegPorts.Initialize();

			this->m_Sig[0] = 'D';
			this->m_Sig[1] = 'E';
			this->m_Sig[2] = 'V';
			this->m_Sig[3] = 'I';

			this->m_dwFlags							= 0;
			this->m_dwLocalAddressV4				= dwLocalAddressV4;
			this->m_sPASTSocket						= INVALID_SOCKET;
			//ZeroMemory(&this->m_saddrinPASTSocketAddress, sizeof(this->m_saddrinPASTSocketAddress));
			this->m_dwFirstPASTDiscoveryTime		= 0;

			this->m_dwLocalPASTClientID				= 0;
			this->m_dwLocalPASTMsgID				= 0;
			this->m_tuLocalPASTRetry				= 0;
			this->m_blLocalPASTCachedMaps.Initialize();

			this->m_dwRemotePASTServerAddressV4		= 0;
			this->m_dwRemotePASTClientID			= 0;
			this->m_dwRemotePASTMsgID				= 0;
			this->m_tuRemotePASTRetry				= 0;
			this->m_blRemotePASTCachedMaps.Initialize();

#ifdef DBG
			this->m_dwNumLocalPASTServerFailures	= 0;
			this->m_dwNumRemotePASTServerFailures	= 0;
#endif // DBG
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDevice::~CDevice"
		~CDevice(void)
		{
#ifdef DBG
			DPFX(DPFPREP, 7, "(0x%p) NumLocalPASTServerFailures = %u, NumRemotePASTServerFailures = %u",
				this, this->m_dwNumLocalPASTServerFailures,
				this->m_dwNumRemotePASTServerFailures);


			DNASSERT(this->m_blList.IsEmpty());
			DNASSERT(this->m_blTempList.IsEmpty());
			DNASSERT(this->m_blOwnedRegPorts.IsEmpty());

			DNASSERT(this->m_sPASTSocket == INVALID_SOCKET);

			DNASSERT(this->m_dwLocalPASTClientID == 0);
			DNASSERT(this->m_blLocalPASTCachedMaps.IsEmpty());

			DNASSERT(this->m_dwRemotePASTClientID == 0);
			DNASSERT(this->m_blRemotePASTCachedMaps.IsEmpty());
#endif // DBG
		};


		inline BOOL HasLocalICSPASTServer(void) const			{ return ((this->m_dwFlags & DEVICE_LOCALPASTSERVER_ICS) ? TRUE : FALSE); };
		inline BOOL HasLocalPFWOnlyPASTServer(void) const		{ return ((this->m_dwFlags & DEVICE_LOCALPASTSERVER_PFWONLY) ? TRUE : FALSE); };
		inline BOOL IsPASTPublicAddressAvailable(const BOOL fRemote) const
		{
			if (fRemote)
			{
				return ((this->m_dwFlags & DEVICE_REMOTEPASTSERVER_PUBLICADDRESSAVAILABLE) ? TRUE : FALSE);
			}
			else
			{
				return ((this->m_dwFlags & DEVICE_LOCALPASTSERVER_PUBLICADDRESSAVAILABLE) ? TRUE : FALSE);
			}
		};

#ifdef DBG
		inline BOOL IsPrimaryDevice(void) const					{ return ((this->m_dwFlags & DEVICE_PRIMARY) ? TRUE : FALSE); };
		inline BOOL IsSecondaryDevice(void) const				{ return ((this->m_dwFlags & DEVICE_SECONDARY) ? TRUE : FALSE); };
		inline BOOL HasNoGateway(void) const					{ return ((this->m_dwFlags & DEVICE_NOGATEWAY) ? TRUE : FALSE); };
#endif // DBG

		inline DWORD GetLocalAddressV4(void) const				{ return this->m_dwLocalAddressV4; };
		inline SOCKET GetPASTSocket(void) const					{ return this->m_sPASTSocket; };

		//inline SOCKADDR_IN * GetPASTSocketAddressPtr(void)	{ return (&this->m_saddrinPASTSocketAddress); };

		inline DWORD GetFirstPASTDiscoveryTime(void) const		{ return this->m_dwFirstPASTDiscoveryTime; };

		inline DWORD GetPASTClientID(const BOOL fRemote) const
		{
			if (fRemote)
			{
				return (this->m_dwRemotePASTClientID);
			}
			else
			{
				return (this->m_dwLocalPASTClientID);
			}
		}

		inline CBilink * GetPASTCachedMaps(const BOOL fRemote)
		{
			if (fRemote)
			{
				return (&this->m_blLocalPASTCachedMaps);
			}
			else
			{
				return (&this->m_blRemotePASTCachedMaps);
			}
		}

		inline DWORD GetNextLocalPASTMsgID(void)					{ return (this->m_dwLocalPASTMsgID++); };
		inline DWORD * GetLocalPASTRetryTimeoutPtr(void)			{ return (&this->m_tuLocalPASTRetry); };

		inline DWORD GetRemotePASTServerAddressV4(void) const		{ return (this->m_dwRemotePASTServerAddressV4); };
		inline DWORD GetNextRemotePASTMsgID(void)					{ return (this->m_dwRemotePASTMsgID++); };
		inline DWORD * GetRemotePASTRetryTimeoutPtr(void)			{ return (&this->m_tuRemotePASTRetry); };


#undef DPF_MODNAME
#define DPF_MODNAME "CDevice::NoteLocalPASTServerIsICS"
		inline void NoteLocalPASTServerIsICS(void)
		{
			DNASSERT(this->m_dwLocalPASTClientID != 0);
			this->m_dwFlags &= ~DEVICE_LOCALPASTSERVER_PFWONLY;
			this->m_dwFlags |= DEVICE_LOCALPASTSERVER_ICS;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDevice::NoteLocalPASTServerIsPFWOnly"
		inline void NoteLocalPASTServerIsPFWOnly(void)
		{
			DNASSERT(this->m_dwLocalPASTClientID != 0);
			this->m_dwFlags &= ~DEVICE_LOCALPASTSERVER_ICS;
			this->m_dwFlags |= DEVICE_LOCALPASTSERVER_PFWONLY;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDevice::NotePASTPublicAddressAvailable"
		inline void NotePASTPublicAddressAvailable(const BOOL fRemote)
		{
			if (fRemote)
			{
				DNASSERT(this->m_dwRemotePASTClientID != 0);
				DNASSERT(! (this->m_dwFlags & DEVICE_REMOTEPASTSERVER_PUBLICADDRESSAVAILABLE));
				this->m_dwFlags |= DEVICE_REMOTEPASTSERVER_PUBLICADDRESSAVAILABLE;
			}
			else
			{
				DNASSERT(this->m_dwLocalPASTClientID != 0);
				DNASSERT(! (this->m_dwFlags & DEVICE_LOCALPASTSERVER_PUBLICADDRESSAVAILABLE));
				this->m_dwFlags |= DEVICE_LOCALPASTSERVER_PUBLICADDRESSAVAILABLE;
			}
		};

		inline void NoteNoLocalPASTServer(void)	{ this->m_dwFlags &= ~(DEVICE_LOCALPASTSERVER_ICS | DEVICE_LOCALPASTSERVER_PFWONLY); };

		inline void NoteNoPASTPublicAddressAvailable(const BOOL fRemote)
		{
			if (fRemote)
			{
				this->m_dwFlags &= ~DEVICE_REMOTEPASTSERVER_PUBLICADDRESSAVAILABLE;
			}
			else
			{
				this->m_dwFlags &= ~DEVICE_LOCALPASTSERVER_PUBLICADDRESSAVAILABLE;
			}
		};

#ifdef DBG
		inline void NotePrimaryDevice(void)		{ this->m_dwFlags |= DEVICE_PRIMARY; };
		inline void NoteSecondaryDevice(void)	{ this->m_dwFlags |= DEVICE_SECONDARY; };
		inline void NoteNoGateway(void)			{ this->m_dwFlags |= DEVICE_NOGATEWAY; };

		inline void ClearGatewayFlags(void)		{ this->m_dwFlags &= ~(DEVICE_PRIMARY | DEVICE_SECONDARY | DEVICE_NOGATEWAY); };
#endif // DBG

		inline void SetPASTSocket(const SOCKET sSocket)				{ this->m_sPASTSocket = sSocket; };

		inline void SetFirstPASTDiscoveryTime(const DWORD dwTime)	{ this->m_dwFirstPASTDiscoveryTime = dwTime; };


		inline void SetPASTClientID(const DWORD dwClientID, const BOOL fRemote)
		{
			if (fRemote)
			{
				this->m_dwRemotePASTClientID = dwClientID;
			}
			else
			{
				this->m_dwLocalPASTClientID = dwClientID;
			}
		}

		inline void ResetLocalPASTMsgIDAndRetryTimeout(const DWORD tuRetryTimeout)
		{
			this->m_dwLocalPASTMsgID	= 0;
			this->m_tuLocalPASTRetry	= tuRetryTimeout;
		};

		inline void SetRemotePASTServerAddressV4(const DWORD dwAddressV4)	{ this->m_dwRemotePASTServerAddressV4 = dwAddressV4; };

		inline void ResetRemotePASTMsgIDAndRetryTimeout(const DWORD tuRetryTimeout)
		{
			this->m_dwRemotePASTMsgID	= 0;
			this->m_tuRemotePASTRetry	= tuRetryTimeout;
		};


#ifdef DBG
		inline void IncrementPASTServerFailures(const BOOL fRemote)
		{
			if (fRemote)
			{
				this->m_dwNumRemotePASTServerFailures++;
			}
			else
			{
				this->m_dwNumLocalPASTServerFailures++;
			}
		};
#endif // DBG




		CBilink		m_blList;			// list of all the available devices
		CBilink		m_blTempList;		// temporary list of all the available devices
		CBilink		m_blOwnedRegPorts;	// list of all the ports registered using this device

	
	private:
		//
		// Note that all values here are protected by the global CNATHelpPAST lock.
		//
		BYTE			m_Sig[4];							// debugging signature ('DEVI')
		DWORD			m_dwFlags;							// flags describing this object
		DWORD			m_dwLocalAddressV4;					// address this object represents (and the local PAST server's address, if present)
		SOCKET			m_sPASTSocket;						// socket opened for PAST communication on this device
		//SOCKADDR_IN		m_saddrinPASTSocketAddress;			// address (and port) of the PAST communications socket
		DWORD			m_dwFirstPASTDiscoveryTime;			// the time we first sent remote PAST discovery (registration) traffic from this particular port

		DWORD			m_dwLocalPASTClientID;				// client ID assigned by local PAST server
		DWORD			m_dwLocalPASTMsgID;					// next msg ID to be sent to local PAST server
		DWORD			m_tuLocalPASTRetry;					// current retry timeout for messages sent to local PAST server
		CBilink			m_blLocalPASTCachedMaps;			// list of cached mappings for query addresses performed on the local PAST server

		DWORD			m_dwRemotePASTServerAddressV4;		// address this object represents
		DWORD			m_dwRemotePASTClientID;				// client ID assigned by local PAST server
		DWORD			m_dwRemotePASTMsgID;				// next msg ID to be sent to remote PAST server
		DWORD			m_tuRemotePASTRetry;				// current retry timeout for messages sent to remote PAST server
		CBilink			m_blRemotePASTCachedMaps;			// list of cached mappings for query address performed on the remote PAST server

#ifdef DBG
		DWORD			m_dwNumLocalPASTServerFailures;		// how many times a local PAST server returned an error or stopped responding and had to be cleared
		DWORD			m_dwNumRemotePASTServerFailures;	// how many times a remote PAST server returned an error or stopped responding and had to be cleared
#endif // DBG
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpasti.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhpasti.h
 *
 *  Content:	DPNHPAST master internal header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/

#ifndef __DPNHPASTI_H__
#define __DPNHPASTI_H__


//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//

#define INCL_WINSOCK_API_TYPEDEFS 1

#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <ole2.h>
#include <wincrypt.h>	// for random numbers
#include <mmsystem.h>   // NT BUILD requires this for timeGetTime
#include <iphlpapi.h>
#include <tchar.h>

// 
// DirectPlay public includes
//
#include "dpnathlp.h"


// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"
#include "classbilink.h"
#include "creg.h"
#include "createin.h"
#include "strutils.h"


// 
// DirectPlayNATHelp private includes
//

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_NATHELP

#include "dpnhpastlocals.h"
#include "pastmsgs.h"
#include "dpnhpastdevice.h"
#include "dpnhpastregport.h"
#include "dpnhpastcachemap.h"
#include "dpnhpastintfobj.h"




#endif // __DPNHPASTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpastdllmain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnhpastdllmain.cpp
 *
 *  Content:	DPNHPAST DLL entry points.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



#include "dpnhpasti.h"





//=============================================================================
// External globals
//=============================================================================
volatile LONG		g_lOutstandingInterfaceCount = 0;			// number of outstanding interfaces

DNCRITICAL_SECTION	g_csGlobalsLock;							// lock protecting all of the following globals
CBilink				g_blNATHelpPASTObjs;						// bilink of all the NATHelpPAST interface objects
DWORD				g_dwHoldRand;								// current random number sequence

DWORD				g_dwPASTICSMode;							// whether using PAST ICS is enabled or not
DWORD				g_dwPASTPFWMode;							// whether using PAST PFW is enabled or not
INT					g_iUnicastTTL = 1;							// unicast TTL value, or 0 to use default set by OS; normally we use 1
DWORD				g_dwDefaultGatewayV4 = INADDR_BROADCAST;	// default to broadcasting when searching for PAST server
DWORD				g_dwSubnetMaskV4 = 0x00FFFFFF;				// = 0xFFFFFF00 in Intel order = 255.255.255.0, a class C network
DWORD				g_dwNoActiveNotifyPollInterval = 25000;		// start by polling every 25 seconds
DWORD				g_dwMinUpdateServerStatusInterval = 1000;	// don't hit the network more often than every 1 second
DWORD				g_dwPollIntervalBackoff = 30000;			// backoff an additional 0 to 30 seconds if no network changes occur
DWORD				g_dwMaxPollInterval = 300000;				// don't go more than 5 minutes without polling
BOOL				g_fKeepPollingForRemoteGateway = FALSE;		// whether to continue to search for new Internet gateway devices if none were found during startup
DWORD				g_dwReusePortTime = 60000;					// how long to keep using the same port for polling remote Internet gateway devices (default is 1 minute)
DWORD				g_dwCacheLifeFound = 30000;					// how long to cache QueryAddress results where the address was found
DWORD				g_dwCacheLifeNotFound = 30000;				// how long to cache QueryAddress results where the address was not found






//=============================================================================
// Defines
//=============================================================================
#define REGKEY_VALUE_GUID							L"Guid"
#define REGKEY_VALUE_DIRECTPLAY8PRIORITY			L"DirectPlay8Priority"
#define REGKEY_VALUE_DIRECTPLAY8INITFLAGS			L"DirectPlay8InitFlags"
#define REGKEY_VALUE_PASTICSMODE					L"PASTICSMode"
#define REGKEY_VALUE_PASTPFWMODE					L"PASTPFWMode"
#define REGKEY_VALUE_UNICASTTTL						L"UnicastTTL"
#define REGKEY_VALUE_DEFAULTGATEWAYV4				L"GatewayV4"
#define REGKEY_VALUE_SUBNETMASKV4					L"SubnetMaskV4"
#define REGKEY_VALUE_NOACTIVENOTIFYPOLLINTERVAL		L"NoActiveNotifyPollInterval"
#define REGKEY_VALUE_MINUPDATESERVERSTATUSINTERVAL	L"MinUpdateServerStatusInterval"
#define REGKEY_VALUE_POLLINTERVALBACKOFF			L"PollIntervalBackoff"
#define REGKEY_VALUE_MAXPOLLINTERVAL				L"MaxPollInterval"
#define REGKEY_VALUE_KEEPPOLLINGFORREMOTEGATEWAY	L"KeepPollingForRemoteGateway"
#define REGKEY_VALUE_REUSEPORTTIME					L"ReusePortTime"
#define REGKEY_VALUE_CACHELIFEFOUND					L"CacheLifeFound"
#define REGKEY_VALUE_CACHELIFENOTFOUND				L"CacheLifeNotFound"


#define DEFAULT_DIRECTPLAY8PRIORITY					2
#define DEFAULT_DIRECTPLAY8INITFLAGS				DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT






//=============================================================================
// Local prototypes
//=============================================================================
BOOL InitializeProcessGlobals(void);
void CleanupProcessGlobals(void);
void InitializeGlobalRand(const DWORD dwSeed);





#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"
//=============================================================================
// DllMain
//-----------------------------------------------------------------------------
//
// Description: DLL entry point.
//
// Arguments:
//	HANDLE hDllInst		- Handle to this DLL module.
//	DWORD dwReason		- Reason for calling this function.
//	LPVOID lpvReserved	- Reserved.
//
// Returns: TRUE if all goes well, FALSE otherwise.
//=============================================================================
BOOL WINAPI DllMain(HANDLE hDllInst,
					DWORD dwReason,
					LPVOID lpvReserved)
{
	BOOL	fResult = TRUE;

	
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			DPFX(DPFPREP, 2, "====> ENTER: DLLMAIN(%p): Process Attach: %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId());

			//
			// Ignore thread attach/detach messages.
			//
			DisableThreadLibraryCalls((HMODULE) hDllInst);

			//
			// Attempt to initialize the OS abstraction layer.
			//
			if (DNOSIndirectionInit(0))
			{
				//
				// Attempt to initialize process-global items.
				//
				if (! InitializeProcessGlobals())
				{
					DPFX(DPFPREP, 0, "Failed to initialize globals!");
					DNOSIndirectionDeinit();
					fResult = FALSE;
				}
			}
			else
			{
				DPFX(DPFPREP, 0, "Failed to initialize OS indirection layer!");
				fResult = FALSE;
			}
		
			break;
		}

		case DLL_THREAD_ATTACH:
		{
			//
			// Ignore.
			//
			break;
		}

		case DLL_THREAD_DETACH:
		{
			//
			// Ignore.
			//
			break;
		}

		case DLL_PROCESS_DETACH:
		{
			DPFX(DPFPREP, 2, "====> EXIT: DLLMAIN(%p): Process Detach %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId());

			CleanupProcessGlobals();

			DNOSIndirectionDeinit();
			
			break;
		}

		default:
		{
			DNASSERT(FALSE);
			break;
		}
	}

	return fResult;
} // DllMain



#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
//=============================================================================
// DllRegisterServer
//-----------------------------------------------------------------------------
//
// Description: Registers the DirectPlay NAT Helper PAST COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully unregistered DirectPlay NAT Helper PAST.
//	E_FAIL	- Failed unregistering DirectPlay NAT Helper PAST.
//=============================================================================
HRESULT WINAPI DllRegisterServer(void)
{
	CRegistry	RegObject;


	//
	// Register this COM object CLSID.
	//
	if (! CRegistry::Register(L"DirectPlayNATHelperPAST.1",
							L"DirectPlay NAT Helper PAST Object",
							L"dpnhpast.dll",
							&CLSID_DirectPlayNATHelpPAST,
							L"DirectPlayNATHelperPAST"))
	{
		DPFX(DPFPREP, 0, "Could not register DirectPlay NAT Helper PAST object!");
		return E_FAIL;
	}


	//
	// Write this object's GUID and DirectPlay8 availability to the registry.
	//

	if (! RegObject.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY, FALSE, TRUE))
	{
		DPFX(DPFPREP, 0, "Couldn't create DirectPlay NAT Helper PAST key!");
		return E_FAIL;
	}

	if (! RegObject.WriteGUID(REGKEY_VALUE_GUID, CLSID_DirectPlayNATHelpPAST))
	{
		DPFX(DPFPREP, 0, "Couldn't write GUID to registry!");
		return E_FAIL;
	}

	if (! RegObject.WriteDWORD(REGKEY_VALUE_DIRECTPLAY8PRIORITY, DEFAULT_DIRECTPLAY8PRIORITY))
	{
		DPFX(DPFPREP, 0, "Couldn't write DirectPlay8 priority to registry!");
		return E_FAIL;
	}

	if (! RegObject.WriteDWORD(REGKEY_VALUE_DIRECTPLAY8INITFLAGS, DEFAULT_DIRECTPLAY8INITFLAGS))
	{
		DPFX(DPFPREP, 0, "Couldn't write DirectPlay8 init flags to registry!");
		return E_FAIL;
	}

	RegObject.Close();


	return S_OK;
} // DllRegisterServer





#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
//=============================================================================
// DllUnregisterServer
//-----------------------------------------------------------------------------
//
// Description: Unregisters the DirectPlay NAT Helper PAST COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully unregistered DirectPlay NAT Helper PAST.
//	E_FAIL	- Failed unregistering DirectPlay NAT Helper PAST.
//=============================================================================
STDAPI DllUnregisterServer(void)
{
	CRegistry	RegObject;


	//
	// Unregister the class.
	//
	if (! CRegistry::UnRegister(&CLSID_DirectPlayNATHelpPAST))
	{
		DPFX(DPFPREP, 0, "Failed to unregister DirectPlay NAT Helper PAST object!");
		return E_FAIL;
	}


	//
	// Try removing all the subitems we registered.
	//

	if (! RegObject.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY, FALSE, FALSE))
	{
		DPFX(DPFPREP, 0, "Couldn't open DirectPlay NAT Helper key!  Ignoring.");
	}
	else
	{
		if (! RegObject.DeleteValue(REGKEY_VALUE_GUID))
		{
			DPFX(DPFPREP, 0, "Couldn't delete GUID registry value!  Ignoring.");
		}

		if (! RegObject.DeleteValue(REGKEY_VALUE_DIRECTPLAY8PRIORITY))
		{
			DPFX(DPFPREP, 0, "Couldn't delete DirectPlay8 priority registry value!  Ignoring.");
		}

		if (! RegObject.DeleteValue(REGKEY_VALUE_DIRECTPLAY8INITFLAGS))
		{
			DPFX(DPFPREP, 0, "Couldn't delete DirectPlay8 init flags registry value!  Ignoring.");
		}

		RegObject.Close();
	}

	return S_OK;
} // DllUnregisterServer

#endif // !DPNBUILD_NOCOMREGISTER



#ifndef WINCE

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayNATHelpCreate"
//=============================================================================
// DirectPlayNATHelpCreate
//-----------------------------------------------------------------------------
//
// Description: Creates an IDirectPlayNATHelp interface object.
//
// Arguments:
//	GUID * pIID				- Pointer to IDirectPlayNATHelp interface GUID.
//	void ** ppvInterface	- Place to store pointer to interface object
//								created.
//
// Returns: HRESULT
//	DPNH_OK					- Creating the object was successful.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	DPNHERR_OUTOFMEMORY		- Not enough memory to create the object.
//	E_NOINTERFACE			- The requested interface was invalid.
//=============================================================================
HRESULT WINAPI DirectPlayNATHelpCreate(const GUID * pIID, void ** ppvInterface)
{
	HRESULT			hr;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pIID, ppvInterface);

	hr = DoCreateInstance(NULL,							// no class factory object necessary
						NULL,							// ?
						CLSID_DirectPlayNATHelpPAST,	// DirectPlayNATHelp class
						(*pIID),						// requested interface
						ppvInterface);					// place to store interface

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
} // DirectPlayNATHelpCreate

#endif // !WINCE





#undef DPF_MODNAME
#define DPF_MODNAME "InitializeProcessGlobals"
//=============================================================================
// InitializeProcessGlobals
//-----------------------------------------------------------------------------
//
// Description: Initialize global items needed for the DLL to operate.
//
// Arguments: None.
//
// Returns: TRUE if successful, FALSE if an error occurred.
//=============================================================================
BOOL InitializeProcessGlobals(void)
{
	BOOL	fReturn = TRUE;


	if (! DNInitializeCriticalSection(&g_csGlobalsLock))
	{
		fReturn = FALSE;
	}

	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&g_csGlobalsLock, 0);


	g_blNATHelpPASTObjs.Initialize();


	//
	// Seed the random number generator with the current time.
	//
	InitializeGlobalRand(GETTIMESTAMP());


	return fReturn;
} // InitializeProcessGlobals




#undef DPF_MODNAME
#define DPF_MODNAME "CleanupProcessGlobals"
//=============================================================================
// CleanupProcessGlobals
//-----------------------------------------------------------------------------
//
// Description: Releases global items used by DLL.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CleanupProcessGlobals(void)
{
	CBilink *		pBilink;
	CNATHelpPAST *	pNATHelpPAST;


	if (! g_blNATHelpPASTObjs.IsEmpty())
	{
		//
		// This assert is far more descriptive than hitting one of those in the
		// cleanup code that complain about flags incorrectly being set.
		//
		DNASSERT(! "DPNHPAST.DLL unloading without all objects having been released!  The caller's DirectPlayNATHelpPAST cleanup code needs to be fixed!");


		//
		// Force close all the objects still outstanding.
		//
		pBilink = g_blNATHelpPASTObjs.GetNext();
		while (pBilink != &g_blNATHelpPASTObjs)
		{
			pNATHelpPAST = NATHELPPAST_FROM_BILINK(pBilink);
			pBilink = pBilink->GetNext();


			DPFX(DPFPREP, 0, "Forcefully releasing object 0x%p!", pNATHelpPAST);

			pNATHelpPAST->Close(0); // ignore error
			

			//
			// Forcefully remove it from the list and delete it instead of
			// using pNATHelpPAST->Release().
			//
			pNATHelpPAST->m_blList.RemoveFromList();
			pNATHelpPAST->UninitializeObject();
			delete pNATHelpPAST;
		}
	}

	DNDeleteCriticalSection(&g_csGlobalsLock);
} // CleanupProcessGlobals




#undef DPF_MODNAME
#define DPF_MODNAME "ReadRegistrySettings"
//=============================================================================
// ReadRegistrySettings
//-----------------------------------------------------------------------------
//
// Description: Reads registry settings to override behavior of this DLL and to
//				turn on some debugging features.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void ReadRegistrySettings(void)
{
	CRegistry	RegObject;
	DWORD		dwNewValue;
	BOOL		fNewValue;


	//
	// Try opening the registry key.
	//
	if (RegObject.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY) != FALSE)
	{
		//
		// Lock out other interfaces from modifying the globals simultaneously.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);


		//
		// If we successfully read a new mode, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_PASTICSMODE, &dwNewValue))
		{
			g_dwPASTICSMode = dwNewValue;
			DPFX(DPFPREP, 1, "Using PAST ICS mode %u.", g_dwPASTICSMode);
		}


		//
		// If we successfully read a new mode, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_PASTPFWMODE, &dwNewValue))
		{
			g_dwPASTPFWMode = dwNewValue;
			DPFX(DPFPREP, 1, "Using PAST PFW mode %u.", g_dwPASTPFWMode);
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_UNICASTTTL, &dwNewValue))
		{
			g_iUnicastTTL = dwNewValue;
			if (g_iUnicastTTL != 0)
			{
				DPFX(DPFPREP, 1, "Using unicast TTL of %i.", g_iUnicastTTL);
			}
			else
			{
				DPFX(DPFPREP, 1, "Using OS default unicast TTL.");
			}
		}


		//
		// If we successfully read a new default gateway, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_DEFAULTGATEWAYV4, &dwNewValue))
		{
			g_dwDefaultGatewayV4 = dwNewValue;
			DPFX(DPFPREP, 1, "Using default gateway 0x%08lx.", g_dwDefaultGatewayV4);
		}


		//
		// If we successfully read a new mask, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_SUBNETMASKV4, &dwNewValue))
		{
			g_dwSubnetMaskV4 = dwNewValue;
			DPFX(DPFPREP, 1, "Using subnet mask 0x%08lx.", g_dwSubnetMaskV4);
		}


		//
		// If we successfully read a new interval, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_NOACTIVENOTIFYPOLLINTERVAL, &dwNewValue))
		{
			g_dwNoActiveNotifyPollInterval = dwNewValue;
			DPFX(DPFPREP, 1, "Using no-active-notify recommended poll interval %u ms.", g_dwNoActiveNotifyPollInterval);
		}


		//
		// If we successfully read a new interval, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_MINUPDATESERVERSTATUSINTERVAL, &dwNewValue))
		{
			g_dwMinUpdateServerStatusInterval = dwNewValue;
			DPFX(DPFPREP, 1, "Using minimum update-server-status interval %u ms.", g_dwMinUpdateServerStatusInterval);
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_POLLINTERVALBACKOFF, &dwNewValue))
		{
			if (dwNewValue != 0)
			{
				g_dwPollIntervalBackoff = dwNewValue;
				DPFX(DPFPREP, 1, "Using poll interval backoff between 0 and %u ms.",
					g_dwPollIntervalBackoff);
			}
			else
			{
				DPFX(DPFPREP, 0, "Ignoring invalid poll interval backoff setting, using default between 0 and %u ms!",
					g_dwPollIntervalBackoff);
			}
		}


		//
		// If we successfully read a new interval, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_MAXPOLLINTERVAL, &dwNewValue))
		{
			//
			// Make sure the value is greater than the starting value.
			//
			if (dwNewValue >= g_dwNoActiveNotifyPollInterval)
			{
				g_dwMaxPollInterval = dwNewValue;
				DPFX(DPFPREP, 1, "Using max poll interval of %u ms.",
					g_dwMaxPollInterval);
			}
			else
			{
				g_dwMaxPollInterval = g_dwNoActiveNotifyPollInterval;
				DPFX(DPFPREP, 0, "Ignoring max poll interval of %u ms, the starting value is %u ms.",
					g_dwMaxPollInterval);
			}
		}
		else
		{
			//
			// Make sure the max poll interval default value is greater than
			// the starting value because we may have read in a new
			// g_dwNoActiveNotifyPollInterval that makes the default
			// g_dwMaxPollInterval invalid.
			//
			if (g_dwMaxPollInterval < g_dwNoActiveNotifyPollInterval)
			{
				g_dwMaxPollInterval = g_dwNoActiveNotifyPollInterval;
				DPFX(DPFPREP, 0, "Resetting max poll interval to %u ms so as to meet starting value.",
					g_dwMaxPollInterval);
			}
		}


		//
		// If we successfully read a new boolean, save it.
		//
		if (RegObject.ReadBOOL(REGKEY_VALUE_KEEPPOLLINGFORREMOTEGATEWAY, &fNewValue))
		{
			g_fKeepPollingForRemoteGateway = fNewValue;
			if (g_fKeepPollingForRemoteGateway)
			{
				DPFX(DPFPREP, 1, "Will continue to poll for remote gateways.");
			}
			else
			{
				//
				// This is actually default behavior, but print out a statement
				// anyway.
				//
				DPFX(DPFPREP, 1, "Continually polling for remote gateways is disallowed by registry key.");
			}
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_REUSEPORTTIME, &dwNewValue))
		{
			g_dwReusePortTime = dwNewValue;
			DPFX(DPFPREP, 1, "Reusing remote gateway discovery ports for %u ms.",
				g_dwReusePortTime);
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_CACHELIFEFOUND, &dwNewValue))
		{
			g_dwCacheLifeFound = dwNewValue;
			DPFX(DPFPREP, 1, "Caching found addresses for %u ms.",
				g_dwCacheLifeFound);
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_CACHELIFENOTFOUND, &dwNewValue))
		{
			g_dwCacheLifeNotFound = dwNewValue;
			DPFX(DPFPREP, 1, "Caching not-found addresses for %u ms.",
				g_dwCacheLifeNotFound);
		}


		//
		// Okay, we're done.  Drop the lock.
		//
		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Done reading registry.
		//
		RegObject.Close();
	}
} // ReadRegistrySettings





#undef DPF_MODNAME
#define DPF_MODNAME "InitializeGlobalRand"
//=============================================================================
// InitializeGlobalRand
//-----------------------------------------------------------------------------
//
// Description:   Initializes the fallback global psuedo-random number
//				generator, using the given seed value.
//
// Arguments:
//	DWORD dwSeed	- Seed to use.
//
// Returns: None.
//=============================================================================
void InitializeGlobalRand(const DWORD dwSeed)
{
	//
	// We don't need to hold a lock, since this should only be done once,
	// during initialization time.
	//
	g_dwHoldRand = dwSeed;
} // InitializeGlobalRand





#undef DPF_MODNAME
#define DPF_MODNAME "GetGlobalRand"
//=============================================================================
// GetGlobalRand
//-----------------------------------------------------------------------------
//
// Description:   Generates a pseudo-random DWORD.
//
// Arguments: None.
//
// Returns: Pseudo-random number.
//=============================================================================
DWORD GetGlobalRand(void)
{
	HCRYPTPROV	hCryptProv;
	DWORD		dwResult;
	WORD		wResult1;
	WORD		wResult2;
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	if (CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
	{
		if (CryptGenRandom(hCryptProv, sizeof(dwResult), (BYTE*) (&dwResult)))
		{
			CryptReleaseContext(hCryptProv, 0);
			return dwResult;
		}
#ifdef DBG
		else
		{
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Crypto couldn't generate random number (err = %u)!",
				dwError);
		}
#endif // DBG

		CryptReleaseContext(hCryptProv, 0);
	}
#ifdef DBG
	else
	{
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't acquire crypto provider context (err = %u)!",
			dwError);
	}
#endif // DBG


	//
	// We couldn't use the crypto API to generate a random number, so make
	// our own based off the C run time source.
	//

	DNEnterCriticalSection(&g_csGlobalsLock);

	g_dwHoldRand = ((g_dwHoldRand * 214013L + 2531011L) >> 16) & 0x7fff;
	wResult1 = (WORD) g_dwHoldRand;
	g_dwHoldRand = ((g_dwHoldRand * 214013L + 2531011L) >> 16) & 0x7fff;
	wResult2 = (WORD) g_dwHoldRand;

	DNLeaveCriticalSection(&g_csGlobalsLock);

	return MAKELONG(wResult1, wResult2);
} // GetGlobalRand




#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"
//=============================================================================
// DoCreateInstance
//-----------------------------------------------------------------------------
//
// Description: Creates an instance of an interface.  Required by the general
//				purpose class factory functions.
//
// Arguments:
//	LPCLASSFACTORY This		- Pointer to class factory.
//	LPUNKNOWN pUnkOuter		- Pointer to unknown interface.
//	REFCLSID rclsid			- Reference of GUID of desired interface.
//	REFIID riid				- Reference to another GUID?
//	LPVOID * ppvObj			- Pointer to pointer to interface.
//
// Returns: HRESULT
//=============================================================================
HRESULT DoCreateInstance(LPCLASSFACTORY This,
						LPUNKNOWN pUnkOuter,
						REFCLSID rclsid,
						REFIID riid,
						LPVOID * ppvObj)
{
	HRESULT			hr;
	BOOL			fNotCreatedWithCOM;
	CNATHelpPAST *	pNATHelpPAST = NULL;


	DNASSERT(ppvObj != NULL);


	if (! IsEqualCLSID(rclsid, CLSID_DirectPlayNATHelpPAST))
	{
		//
		// This shouldn't happen if they called IClassFactory::CreateObject
		// correctly.
		//
		DNASSERT(FALSE);

		//
		// Return an error.
		//
		hr = E_UNEXPECTED;
		goto Failure;
	}


	//
	// If the class factory pointer is NULL, then we were called by the
	// DirectPlayNATHelpCreate function.
	//
	if (This == NULL)
	{
		fNotCreatedWithCOM = TRUE;
	}
	else
	{
		fNotCreatedWithCOM = FALSE;
	}


	//
	// Create the object instance.
	//
	pNATHelpPAST = new CNATHelpPAST(fNotCreatedWithCOM);
	if (pNATHelpPAST == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Initialize the base object (which might fail).
	//
	hr = pNATHelpPAST->InitializeObject();
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize object!");
		delete pNATHelpPAST;
		pNATHelpPAST = NULL;
		goto Failure;
	}


	//
	// Add it to the global list.
	//
	DNEnterCriticalSection(&g_csGlobalsLock);

	pNATHelpPAST->m_blList.InsertBefore(&g_blNATHelpPASTObjs);
	
	g_lOutstandingInterfaceCount++;	// update count so DllCanUnloadNow works correctly

	DNLeaveCriticalSection(&g_csGlobalsLock);


	//
	// Get the right interface for the caller and bump the refcount.
	//
	hr = pNATHelpPAST->QueryInterface(riid, ppvObj);
	if (hr != S_OK)
	{
		goto Failure;
	}


Exit:

	//
	// Release the local reference to the object.  If this function was
	// successful, there's still a reference in ppvObj.
	//
	if (pNATHelpPAST != NULL)
	{
		pNATHelpPAST->Release();
		pNATHelpPAST = NULL;
	}

	return hr;


Failure:

	//
	// Make sure we don't hand back a pointer.
	//
	(*ppvObj) = NULL;

	goto Exit;
} // DoCreateInstance




#undef DPF_MODNAME
#define DPF_MODNAME "IsClassImplemented"
//=============================================================================
// IsClassImplemented
//-----------------------------------------------------------------------------
//
// Description: Determine if a class is implemented in this DLL.  Required by
//				the general purpose class factory functions.
//
// Arguments:
//	REFCLSID rclsid		- Reference to class GUID.
//
// Returns: BOOL
//	TRUE	 - This DLL implements the class.
//	FALSE	 - This DLL doesn't implement the class.
//=============================================================================
BOOL IsClassImplemented(REFCLSID rclsid)
{
	return (IsEqualCLSID(rclsid, CLSID_DirectPlayNATHelpPAST));
} // IsClassImplemented
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpastintfobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnhpastintfobj.cpp
 *
 *  Content:	DPNHPAST main interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



#include "dpnhpasti.h"





//=============================================================================
// Definitions
//=============================================================================
#define DEFAULT_INITIAL_PAST_RETRY_TIMEOUT				25000		// start retry timer at 25 ms
#define PAST_CONNECT_RETRY_INTERVAL_MS					250			// 250 ms
#define PAST_CONNECT_RETRY_INTERVAL_US					(PAST_CONNECT_RETRY_INTERVAL_MS * 1000)
#define MAX_NUM_PAST_TRIES_CONNECT						2			// how many times to send a registration request message, in case of packet loss
#define MAX_PAST_RETRY_TIME_US							250000		// max retry interval is 250 ms
#define MAX_NUM_PAST_TRIES								5

#define PAST_RESPONSE_BUFFER_SIZE						150

#define LEASE_RENEW_TIME								120000		// renew if less than 2 minutes remaining

#define FAKE_PORT_LEASE_TIME							300000		// 5 minutes

#define IOCOMPLETE_WAIT_INTERVAL						100			// 100 ms between attempts
#define MAX_NUM_IOCOMPLETE_WAITS						10			// wait at most 1 second

#define MAX_RESERVED_PORT								1024

#define MAX_NUM_RANDOM_PORT_TRIES						5






#ifndef DPNBUILD_NOWINSOCK2
//=============================================================================
// WinSock 1 version of IP options
//=============================================================================
#define IP_TTL_WINSOCK1				7
#endif // ! DPNBUILD_NOWINSOCK2




//=============================================================================
// Macros
//=============================================================================
//#ifdef _X86
#define IS_CLASSD_IPV4_ADDRESS(dwAddr)	(( (*((BYTE*) &(dwAddr))) & 0xF0) == 0xE0)	// 1110 high bits or 224.0.0.0 - 239.255.255.255 multicast address, in network byte order
#define NTOHS(x)						( (((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00) )
#define HTONS(x)						NTOHS(x)
//#endif _X86





//=============================================================================
// Local static variables
//=============================================================================
static timeval	s_tv0 = {0, 0};






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::CNATHelpPAST"
//=============================================================================
// CNATHelpPAST constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CNATHelpPAST object.
//
// Arguments:
//	BOOL fNotCreatedWithCOM		- TRUE if this object is being instantiated
//									without COM, FALSE if it is through COM.
//
// Returns: None (the object).
//=============================================================================
CNATHelpPAST::CNATHelpPAST(const BOOL fNotCreatedWithCOM)
{
	this->m_blList.Initialize();


	this->m_Sig[0]	= 'N';
	this->m_Sig[1]	= 'A';
	this->m_Sig[2]	= 'T';
	this->m_Sig[3]	= 'H';

	this->m_lRefCount						= 1; // someone must have a pointer to this object

	if (fNotCreatedWithCOM)
	{
		this->m_dwFlags						= NATHELPPASTOBJ_NOTCREATEDWITHCOM;
	}
	else
	{
		this->m_dwFlags						= 0;
	}

	this->m_dwLockThreadID					= 0;
	this->m_hAlertEvent						= NULL;
	this->m_hAlertIOCompletionPort			= NULL;
	this->m_dwAlertCompletionKey			= 0;

	this->m_blDevices.Initialize();
	this->m_blRegisteredPorts.Initialize();
	this->m_blUnownedPorts.Initialize();

	this->m_dwLastUpdateServerStatusTime	= 0;
	this->m_dwNextPollInterval				= 0;
	this->m_dwNumLeases						= 0;
	this->m_dwEarliestLeaseExpirationTime	= 0;

	this->m_hIpHlpApiDLL					= NULL;
	this->m_pfnGetAdaptersInfo				= NULL;
	this->m_pfnGetIpForwardTable			= NULL;
	this->m_pfnGetBestRoute					= NULL;

	this->m_sIoctls							= INVALID_SOCKET;
	this->m_wIoctlSocketPort				= 0;
	this->m_polAddressListChange			= NULL;

	this->m_hWinSockDLL						= NULL;
	this->m_pfnWSAStartup					= NULL;
	this->m_pfnWSACleanup					= NULL;
	this->m_pfnWSAGetLastError				= NULL;
	this->m_pfnsocket						= NULL;
	this->m_pfnclosesocket					= NULL;
	this->m_pfnbind							= NULL;
	this->m_pfnsetsockopt					= NULL;
	this->m_pfngetsockname					= NULL;
	this->m_pfnselect						= NULL;
	this->m_pfn__WSAFDIsSet					= NULL;
	this->m_pfnrecvfrom						= NULL;
	this->m_pfnsendto						= NULL;
	this->m_pfngethostname					= NULL;
	this->m_pfngethostbyname				= NULL;
	this->m_pfninet_addr					= NULL;
	this->m_pfnWSASocketA					= NULL;
	this->m_pfnWSAIoctl						= NULL;
	this->m_pfnWSAGetOverlappedResult		= NULL;

#ifdef DBG
	this->m_dwNumDeviceAdds					= 0;
	this->m_dwNumDeviceRemoves				= 0;
	this->m_dwNumServerFailures				= 0;
#endif // DBG
} // CNATHelpPAST::CNATHelpPAST






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::~CNATHelpPAST"
//=============================================================================
// CNATHelpPAST destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CNATHelpPAST object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CNATHelpPAST::~CNATHelpPAST(void)
{
	DPFX(DPFPREP, 7, "(0x%p) NumDeviceAdds = %u, NumDeviceRemoves = %u, NumServerFailures = %u",
		this, this->m_dwNumDeviceAdds, this->m_dwNumDeviceRemoves,
		this->m_dwNumServerFailures);


	DNASSERT(this->m_blList.IsEmpty());


	DNASSERT(this->m_lRefCount == 0);
	DNASSERT((this->m_dwFlags & ~NATHELPPASTOBJ_NOTCREATEDWITHCOM) == 0);

	DNASSERT(this->m_dwLockThreadID == 0);
	DNASSERT(this->m_hAlertEvent == NULL);
	DNASSERT(this->m_hAlertIOCompletionPort == NULL);

	DNASSERT(this->m_blDevices.IsEmpty());
	DNASSERT(this->m_blRegisteredPorts.IsEmpty());
	DNASSERT(this->m_blUnownedPorts.IsEmpty());

	DNASSERT(this->m_dwNumLeases == 0);

	DNASSERT(this->m_hIpHlpApiDLL == NULL);
	DNASSERT(this->m_hWinSockDLL == NULL);

	DNASSERT(this->m_sIoctls == INVALID_SOCKET);
	DNASSERT(this->m_polAddressListChange == NULL);


	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 'h';
} // CNATHelpPAST::~CNATHelpPAST




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::QueryInterface"
//=============================================================================
// CNATHelpPAST::QueryInterface
//-----------------------------------------------------------------------------
//
// Description: Retrieves a new reference for an interfaces supported by this
//				CNATHelpPAST object.
//
// Arguments:
//	REFIID riid			- Reference to interface ID GUID.
//	LPVOID * ppvObj		- Place to store pointer to object.
//
// Returns: HRESULT
//	S_OK					- Returning a valid interface pointer.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	E_NOINTERFACE			- Invalid interface was specified.
//=============================================================================
STDMETHODIMP CNATHelpPAST::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = DPNH_OK;


	DPFX(DPFPREP, 3, "(0x%p) Parameters: (REFIID, 0x%p)", this, ppvObj);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid NATHelper object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDirectPlayNATHelp)))
	{
		DPFX(DPFPREP, 0, "Unsupported interface!");
		hr = E_NOINTERFACE;
		goto Failure;
	}

	if ((ppvObj == NULL) ||
		(IsBadWritePtr(ppvObj, sizeof(void*))))
	{
		DPFX(DPFPREP, 0, "Invalid interface pointer specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}


	//
	// Add a reference, and return the interface pointer (which is actually
	// just the object pointer, they line up because CNATHelpPAST inherits from
	// the interface declaration).
	//
	this->AddRef();
	(*ppvObj) = this;


Exit:

	DPFX(DPFPREP, 3, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::AddRef"
//=============================================================================
// CNATHelpPAST::AddRef
//-----------------------------------------------------------------------------
//
// Description: Adds a reference to this CNATHelpPAST object.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CNATHelpPAST::AddRef(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());


	//
	// There must be at least 1 reference to this object, since someone is
	// calling AddRef.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedIncrement(&this->m_lRefCount);

	DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);

	return lRefCount;
} // CNATHelpPAST::AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::Release"
//=============================================================================
// CNATHelpPAST::Release
//-----------------------------------------------------------------------------
//
// Description: Removes a reference to this CNATHelpPAST object.  When the
//				refcount reaches 0, this object is destroyed.
//				You must NULL out your pointer to this object after calling
//				this function.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CNATHelpPAST::Release(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());

	//
	// There must be at least 1 reference to this object, since someone is
	// calling Release.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedDecrement(&this->m_lRefCount);

	//
	// Was that the last reference?  If so, we're going to destroy this object.
	//
	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount hit 0, destroying object.", this);

		//
		// First pull it off the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		this->m_blList.RemoveFromList();

		DNASSERT(g_lOutstandingInterfaceCount > 0);
		g_lOutstandingInterfaceCount--;	// update count so DLL can unload now works correctly
		
		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Make sure it's closed.
		//
		if (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED)
		{
			//
			// Assert so that the user can fix his/her broken code!
			//
			DNASSERT(! "DirectPlayNATHelpPAST object being released without calling Close first!");

			//
			// Then go ahead and do the right thing.  Ignore error, we can't do
			// much about it.
			//
			this->Close(0);
		}


		//
		// Then uninitialize the object.
		//
		this->UninitializeObject();

		//
		// Finally delete this (!) object.
		//
		delete this;
	}
	else
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);
	}

	return lRefCount;
} // CNATHelpPAST::Release




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::Initialize"
//=============================================================================
// CNATHelpPAST::Initialize
//-----------------------------------------------------------------------------
//
// Description:    Prepares the object for use.  No attempt is made to contact
//				any Internet gateway servers at this time.  The user should
//				call GetCaps with the DPNHGETCAPS_UPDATESERVERSTATUS flag to
//				search for a server.
//
//				   Initialize must be called before using any other function,
//				and must be balanced with a call to Close.  Initialize can only
//				be called once unless Close returns it to the uninitialized
//				state.
//
//				   One of DPNHINITIALIZE_DISABLEREMOTENATSUPPORT or
//				DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT may be specified,
//				but not both.
//
// Arguments:
//	DWORD dwFlags	- Flags to use when initializing.
//
// Returns: HRESULT
//	DPNH_OK						- Initialization was successful.
//	DPNHERR_ALREADYINITIALIZED	- Initialize has already been called.
//	DPNHERR_GENERIC				- An error occurred while initializing.
//	DPNHERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT		- The interface object is invalid.
//	DPNHERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNHERR_OUTOFMEMORY			- There is not enough memory to initialize.
//	DPNHERR_REENTRANT			- The interface has been re-entered on the same
//									thread.
//=============================================================================
STDMETHODIMP CNATHelpPAST::Initialize(const DWORD dwFlags)
{
	HRESULT			hr;
	BOOL			fHaveLock = FALSE;
	BOOL			fSetFlags = FALSE;
	BOOL			fWinSockStarted = FALSE;
	WSADATA			wsadata;
	int				iError;
	SOCKADDR_IN		saddrinTemp;
	int				iAddressSize;
#ifdef DBG
	DWORD			dwError;
#endif // DBG


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%lx)", this, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}


	//
	// Validate the parameters.
	//

	if (dwFlags & ~(DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT))
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}

	//
	// Both flags cannot be specified at the same time.  If the caller doesn't
	// want any NAT functionality, why use this object all?
	//
	if ((dwFlags & (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)) == (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT))
	{
		DPFX(DPFPREP, 0, "Either DISABLEGATEWAYSUPPORT flag or DISABLELOCALFIREWALLSUPPORT flag can be used, but not both!");
		hr = DPNHERR_INVALIDFLAGS;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}



	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if ((this->m_dwFlags & ~NATHELPPASTOBJ_NOTCREATEDWITHCOM) != 0)
	{
		DPFX(DPFPREP, 0, "Object already initialized!");
		hr = DPNHERR_ALREADYINITIALIZED;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}


	//
	// Read in the manual override settings from the registry
	//
	ReadRegistrySettings();


	//
	// We're not completely initialized yet, but set the flag(s) now.
	//
	this->m_dwFlags |= NATHELPPASTOBJ_INITIALIZED;
	fSetFlags = TRUE;


	//
	// Store the user's settings.
	//

	if (dwFlags & DPNHINITIALIZE_DISABLEGATEWAYSUPPORT)
	{
		DPFX(DPFPREP, 1, "User requested that Internet gateways not be supported.");
	}
	else
	{
		this->m_dwFlags |= NATHELPPASTOBJ_USEPASTICS;
	}

	if (dwFlags & DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)
	{
		DPFX(DPFPREP, 1, "User requested that local PAST PFW not be supported.");
	}
	else
	{
		this->m_dwFlags |= NATHELPPASTOBJ_USEPASTPFW;
	}


	//
	// Take into account the registry override settings.
	//

	switch (g_dwPASTICSMode)
	{
		case OVERRIDEMODE_FORCEON:
		{
			//
			// Force PAST ICS on.
			//
			DPFX(DPFPREP, 1, "Forcing PAST ICS support on.");
			this->m_dwFlags |= NATHELPPASTOBJ_USEPASTICS;
			break;
		}

		case OVERRIDEMODE_FORCEOFF:
		{
			//
			// Force PAST ICS off.
			//
			DPFX(DPFPREP, 1, "Forcing PAST ICS support off.");
			this->m_dwFlags &= ~NATHELPPASTOBJ_USEPASTICS;
			break;
		}

		default:
		{
			//
			// Leave PAST ICS settings alone.
			//
			break;
		}
	}

	switch (g_dwPASTPFWMode)
	{
		case OVERRIDEMODE_FORCEON:
		{
			//
			// Force PAST PFW on.
			//
			DPFX(DPFPREP, 1, "Forcing PAST PFW support on.");
			this->m_dwFlags |= NATHELPPASTOBJ_USEPASTPFW;
			break;
		}

		case OVERRIDEMODE_FORCEOFF:
		{
			//
			// Force PAST PFW off.
			//
			DPFX(DPFPREP, 1, "Forcing PAST PFW support off.");
			this->m_dwFlags &= ~NATHELPPASTOBJ_USEPASTPFW;
			break;
		}

		default:
		{
			//
			// Leave PAST PFW settings alone.
			//
			break;
		}
	}


	//
	// Try loading the IP helper DLL.
	//
	this->m_hIpHlpApiDLL = LoadLibrary( _T("iphlpapi.dll") );
	if (this->m_hIpHlpApiDLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Unable to load \"iphlpapi.dll\" (error = 0x%lx).",
			dwError);
#endif // DBG

		//
		// That's not fatal, we can still function.
		//
	}
	else
	{
		//
		// Load the functions we'll use.
		//

		this->m_pfnGetAdaptersInfo = (PFN_GETADAPTERSINFO) GetProcAddress(this->m_hIpHlpApiDLL,
																		"GetAdaptersInfo");
		if (this->m_pfnGetAdaptersInfo == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Unable to get \"GetAdaptersInfo\" function (error = 0x%lx)!",
				dwError);
#endif // DBG
			goto Exit;
		}

		this->m_pfnGetIpForwardTable = (PFN_GETIPFORWARDTABLE) GetProcAddress(this->m_hIpHlpApiDLL,
																			"GetIpForwardTable");
		if (this->m_pfnGetIpForwardTable == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Unable to get \"GetIpForwardTable\" function (error = 0x%lx)!",
				dwError);
#endif // DBG
			goto Exit;
		}

		this->m_pfnGetBestRoute = (PFN_GETBESTROUTE) GetProcAddress(this->m_hIpHlpApiDLL,
																	"GetBestRoute");
		if (this->m_pfnGetBestRoute == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Unable to get \"GetBestRoute\" function (error = 0x%lx)!",
				dwError);
#endif // DBG
			goto Exit;
		}
	}


	//
	// Load WinSock, we always need it.
	//
	this->m_hWinSockDLL = LoadLibrary( _T("ws2_32.dll") );
	if (this->m_hWinSockDLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Couldn't load \"ws2_32.dll\" (err = 0x%lx), resorting to WinSock 1 functionality.",
			dwError);
#endif // DBG

		this->m_hWinSockDLL = LoadLibrary( _T("wsock32.dll") );
		if (this->m_hWinSockDLL == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't load \"wsock32.dll\" either (err = 0x%lx)!.",
				dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		//
		// Remember that we had to resort to WinSock 1.
		//
		this->m_dwFlags |= NATHELPPASTOBJ_WINSOCK1;
	}
	else
	{
		DPFX(DPFPREP, 1, "Loaded \"ws2_32.dll\", using WinSock 2 functionality.");
	}


	//
	// Load pointers to all the functions we use in WinSock.
	//
	hr = this->LoadWinSockFunctionPointers();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't load WinSock function pointers!");
		goto Failure;
	}


	//
	// Fire up WinSock.  Request 2.2 if we can.  For the most part we only use
	// version 1.1 capabilities and interfaces anyway.  The only exceptions are
	// using using the event or I/O completion port handles for notification.
	//
	ZeroMemory(&wsadata, sizeof(wsadata));

	if (this->m_dwFlags & NATHELPPASTOBJ_WINSOCK1)
	{
		iError = this->m_pfnWSAStartup(MAKEWORD(1, 1), &wsadata);
	}
	else
	{
		iError = this->m_pfnWSAStartup(MAKEWORD(2, 2), &wsadata);
	}
	if (iError != 0)
	{
		DPFX(DPFPREP, 0, "Couldn't startup WinSock (error = %i)!", iError);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	fWinSockStarted = TRUE;

	DPFX(DPFPREP, 4, "Initialized WinSock version %u.%u.",
		LOBYTE(wsadata.wVersion), HIBYTE(wsadata.wVersion));



	//
	// Try creating a UDP socket for use with WSAIoctl.  Do this even if we're
	// WinSock 1 and can't use WSAIoctl socket.  This allows us to make sure
	// TCP/IP is installed and working.
	//

	this->m_sIoctls = this->m_pfnsocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (this->m_sIoctls == INVALID_SOCKET)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't create Ioctl socket, error = %u!", dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Try binding the socket.  This is a continuation of the validation.
	//
	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family				= AF_INET;
	//saddrinTemp.sin_addr.S_un.S_addr	= INADDR_ANY;
	//saddrinTemp.sin_port				= 0;

	if (this->m_pfnbind(this->m_sIoctls,
						(SOCKADDR *) (&saddrinTemp),
						sizeof(saddrinTemp)) != 0)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't bind the Ioctl socket to arbitrary port on any interface, error = %u!",
			dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Get the address + port tuple actually bound.
	//
	iAddressSize = sizeof(saddrinTemp);
	if (this->m_pfngetsockname(this->m_sIoctls,
								(SOCKADDR*) (&saddrinTemp),
								&iAddressSize) != 0)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't get socket name, error = %u!", dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	//
	// WinSock needs to have bound to all adapters (because we told it to).
	//
	DNASSERT(saddrinTemp.sin_addr.S_un.S_addr == INADDR_ANY);

	this->m_wIoctlSocketPort = saddrinTemp.sin_port;

	DPFX(DPFPREP, 8, "Bound Ioctl socket to port %u.",
		NTOHS(this->m_wIoctlSocketPort));


	//
	// Build the list of IP capable devices.
	//
	hr = this->CheckForNewDevices(NULL);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't build device list!");
		goto Failure;
	}


	//
	// We could technically try to contact PAST servers right now, but we don't
	// because it's a slow blocking operation, and users have to call GetCaps
	// at least once anyway.
	//


Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	this->RemoveAllItems();

	if (this->m_sIoctls != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(this->m_sIoctls);	// ignore error
		this->m_sIoctls = INVALID_SOCKET;
	}

	if (fWinSockStarted)
	{
		this->m_pfnWSACleanup(); // ignore error
	}

	if (this->m_hWinSockDLL != NULL)
	{
		this->m_pfnWSAStartup				= NULL;
		this->m_pfnWSACleanup				= NULL;
		this->m_pfnWSAGetLastError			= NULL;
		this->m_pfnsocket					= NULL;
		this->m_pfnclosesocket				= NULL;
		this->m_pfnbind						= NULL;
		this->m_pfnsetsockopt				= NULL;
		this->m_pfngetsockname				= NULL;
		this->m_pfnselect					= NULL;
		this->m_pfn__WSAFDIsSet				= NULL;
		this->m_pfnrecvfrom					= NULL;
		this->m_pfnsendto					= NULL;
		this->m_pfngethostname				= NULL;
		this->m_pfngethostbyname			= NULL;
		this->m_pfninet_addr				= NULL;
		this->m_pfnWSASocketA				= NULL;
		this->m_pfnWSAIoctl					= NULL;
		this->m_pfnWSAGetOverlappedResult	= NULL;

		this->m_dwFlags &= ~NATHELPPASTOBJ_WINSOCK1;

		FreeLibrary(this->m_hWinSockDLL);
		this->m_hWinSockDLL = NULL;
	}

	if (this->m_hIpHlpApiDLL != NULL)
	{
		this->m_pfnGetAdaptersInfo		= NULL;
		this->m_pfnGetIpForwardTable	= NULL;
		this->m_pfnGetBestRoute			= NULL;

		FreeLibrary(this->m_hIpHlpApiDLL);
		this->m_hIpHlpApiDLL = NULL;
	}

	if (fSetFlags)
	{
		this->m_dwFlags &= ~(NATHELPPASTOBJ_INITIALIZED |
							NATHELPPASTOBJ_USEPASTICS |
							NATHELPPASTOBJ_USEPASTPFW |
							NATHELPPASTOBJ_DEVICECHANGED);
	}

	goto Exit;
} // CNATHelpPAST::Initialize






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::Close"
//=============================================================================
// CNATHelpPAST::Close
//-----------------------------------------------------------------------------
//
// Description:    Shuts down and de-registers this application with any
//				Internet gateway servers.  All port assignments are implicitly
//				freed as a result of this operation.
//
//				   This must balance a successful call to Initialize.
//
// Arguments:
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- Closing the helper API was successful.
//	DPNHERR_GENERIC			- An error occurred while closing.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory to close.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpPAST::Close(const DWORD dwFlags)
{
	HRESULT		hr;
	BOOL		fHaveLock = FALSE;
	int			iError;
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%lx)", this, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// We need to actively deregister any devices which are registered with
	// Internet gateways.
	//
	this->RemoveAllItems();


	//
	// Close the Ioctl socket.
	//
	DNASSERT(this->m_sIoctls != INVALID_SOCKET);
	this->m_pfnclosesocket(this->m_sIoctls);	// ignore error
	this->m_sIoctls = INVALID_SOCKET;



	//
	// If we submitted overlapped I/O, see if it got cancelled.
	//
	if (this->m_polAddressListChange != NULL)
	{
		OSVERSIONINFO		osvi;
		OSVERSIONINFOEX		osvix;
		BOOL				fCanWait;
		DWORD				dwAttempt;


		ZeroMemory(&osvi, sizeof(osvi));
		osvi.dwOSVersionInfoSize = sizeof(osvi);

		if (GetVersionEx(&osvi))
		{
			//
			// Any platform but Win2K Gold, Win2K + SP1, or Win2K + SP2 can
			// just go ahead and wait for the I/O to complete.
			//
			if ((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
				(osvi.dwMajorVersion > 5) ||
				(osvi.dwMinorVersion > 0))
			{
				DPFX(DPFPREP, 3, "Windows %s version %u.%u detected, waiting for address list change Ioctl to complete.",
					((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) ? _T("9x") : _T("NT")),
					osvi.dwMajorVersion, osvi.dwMinorVersion);

				fCanWait = TRUE;
			}
			else
			{
				//
				// Win2K versions < SP3 have a bug where the I/O is not always
				// cancelled by closing the socket.  We can't wait for the
				// completion, sometimes it doesn't happen.
				//

				fCanWait = FALSE;

				ZeroMemory(&osvix, sizeof(osvix));
				osvix.dwOSVersionInfoSize = sizeof(osvix);

				if (GetVersionEx((LPOSVERSIONINFO) (&osvix)))
				{
					//
					// If SP3 or later is applied, we know it's fixed.
					//
					if (osvix.wServicePackMajor >= 3)
					{
						DPFX(DPFPREP, 3, "Windows 2000 Service Pack %u detected, waiting for address list change Ioctl to complete.",
							osvix.wServicePackMajor);
						fCanWait = TRUE;
					}
#ifdef DBG
					else
					{
						if (osvix.wServicePackMajor == 0)
						{
							DPFX(DPFPREP, 2, "Windows 2000 Gold detected, not waiting for address list change Ioctl to complete.");
						}
						else
						{
							DPFX(DPFPREP, 2, "Windows 2000 Service Pack %u detected, not waiting for address list change Ioctl to complete.",
								osvix.wServicePackMajor);
						}
					}
#endif // DBG
				}
#ifdef DBG
				else
				{
					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Couldn't get extended OS version information (err = %u)!.",
						dwError);
				}
#endif // DBG
			}


			//
			// Wait, if we can.  Otherwise, leak the memory.
			//
			if (fCanWait)
			{
				//
				// Keep looping until I/O completes.  We will give up after a
				// while to prevent hangs.
				//
				dwAttempt = 0;
				while (! HasOverlappedIoCompleted(this->m_polAddressListChange))
				{
					DPFX(DPFPREP, 2, "Waiting %u ms for address list change Ioctl to complete.",
						IOCOMPLETE_WAIT_INTERVAL);

					//
					// Give the OS some time to complete it.
					//
					Sleep(IOCOMPLETE_WAIT_INTERVAL);

					dwAttempt++;

					if (dwAttempt >= MAX_NUM_IOCOMPLETE_WAITS)
					{
						break;
					}
				}
			}
			else
			{
				//
				// Just leak the memory.  See above notes and debug print
				// statements
				//
			}
		}
#ifdef DBG
		else
		{
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't get OS version information (err = %u)!",
				dwError);
		}
#endif // DBG


		//
		// We've either freed the memory or committed to leaking the object.
		//
		if (HasOverlappedIoCompleted(this->m_polAddressListChange))
		{
			//
			// We didn't allocate it through DNMalloc, use the matching free
			// function.
			//
			HeapFree(GetProcessHeap(), 0, this->m_polAddressListChange);
		}
		else
		{
			DPFX(DPFPREP, 1, "Overlapped address list change Ioctl has not completed yet, leaking %u byte overlapped structure at 0x%p.",
				sizeof(WSAOVERLAPPED), this->m_polAddressListChange);
		}

		this->m_polAddressListChange = NULL;
	}



	//
	// Cleanup WinSock.
	//
	iError = this->m_pfnWSACleanup();
	if (iError != 0)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't cleanup WinSock (error = %u)!", dwError);
#endif // DBG

		//
		// Continue anyway, so we can finish cleaning up the object.
		//
	}


	//
	// Unload the library.
	//

	this->m_pfnWSAStartup				= NULL;
	this->m_pfnWSACleanup				= NULL;
	this->m_pfnWSAGetLastError			= NULL;
	this->m_pfnsocket					= NULL;
	this->m_pfnclosesocket				= NULL;
	this->m_pfnbind						= NULL;
	this->m_pfnsetsockopt				= NULL;
	this->m_pfngetsockname				= NULL;
	this->m_pfnselect					= NULL;
	this->m_pfn__WSAFDIsSet				= NULL;
	this->m_pfnrecvfrom					= NULL;
	this->m_pfnsendto					= NULL;
	this->m_pfngethostname				= NULL;
	this->m_pfngethostbyname			= NULL;
	this->m_pfninet_addr				= NULL;
	this->m_pfnWSASocketA				= NULL;
	this->m_pfnWSAIoctl					= NULL;
	this->m_pfnWSAGetOverlappedResult	= NULL;

	FreeLibrary(this->m_hWinSockDLL);
	this->m_hWinSockDLL = NULL;


	//
	// If we loaded IPHLPAPI.DLL, unload it.
	//
	if (this->m_hIpHlpApiDLL != NULL)
	{
		this->m_pfnGetAdaptersInfo		= NULL;
		this->m_pfnGetIpForwardTable	= NULL;
		this->m_pfnGetBestRoute			= NULL;

		FreeLibrary(this->m_hIpHlpApiDLL);
		this->m_hIpHlpApiDLL = NULL;
	}


	//
	// If there was an alert event, we're done with it.
	//
	if (this->m_hAlertEvent != NULL)
	{
		CloseHandle(this->m_hAlertEvent);
		this->m_hAlertEvent = NULL;
	}

	//
	// If there was an alert I/O completion port, we're done with it.
	//
	if (this->m_hAlertIOCompletionPort != NULL)
	{
		CloseHandle(this->m_hAlertIOCompletionPort);
		this->m_hAlertIOCompletionPort = NULL;
	}


	//
	// Turn off flags which should reset it back to 0 or just the
	// NOTCREATEDWITHCOM flag.
	//
	this->m_dwFlags &= ~(NATHELPPASTOBJ_INITIALIZED |
						NATHELPPASTOBJ_USEPASTICS |
						NATHELPPASTOBJ_USEPASTPFW |
						NATHELPPASTOBJ_WINSOCK1 |
						NATHELPPASTOBJ_DEVICECHANGED |
						NATHELPPASTOBJ_ADDRESSESCHANGED |
						NATHELPPASTOBJ_PORTREGISTERED);
	DNASSERT((this->m_dwFlags & ~NATHELPPASTOBJ_NOTCREATEDWITHCOM) == 0);


	this->DropLock();
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpPAST::Close





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::GetCaps"
//=============================================================================
// CNATHelpPAST::GetCaps
//-----------------------------------------------------------------------------
//
// Description:    Retrieves the capabilities of the Internet gateway server(s)
//				and information on leased ports.  This function should be
//				called periodically with the DPNHGETCAPS_UPDATESERVERSTATUS
//				flag to automatically extend port leases that are about to
//				expire (that are in last 2 minutes of their lease).
//
//				   The DPNHGETCAPS_UPDATESERVERSTATUS flag also causes
//				detection of changes in the servers' status since the last
//				similar call to GetCaps.  If a new server becomes available, an
//				existing one became unavailable, or a server's public address
//				changed in a way that affects an existing registered port
//				mapping, then DPNHSUCCESS_ADDRESSESCHANGED is returned instead
//				of DPNH_OK.  The user should then update its port binding
//				information via GetRegisteredAddresses.
//
//				   When DPNHGETCAPS_UPDATESERVERSTATUS is specified, this
//				function may block for a short period of time while attempts
//				are made to communicate with the server(s).
//
//				   GetCaps must be called with the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag at least once prior to
//				using the GetRegisteredAddresses or QueryAddress methods.
//
// Arguments:
//	DPNHCAPS * pdpnhcaps	- Pointer to structure to be filled with the NAT
//								helper's current capabilities.  The dwSize
//								field of the structure must be filled in before
//								calling GetCaps.
//	DWORD dwFlags			- Flags to use when retrieving capabilities
//								(DPNHGETCAPS_xxx).
//
// Returns: HRESULT
//	DPNH_OK							- Determining capabilities was successful.
//										Address status has not changed.
//	DPNHSUCCESS_ADDRESSESCHANGED	- One or more of the registered port
//										mappings' addresses changed, retrieve
//										updated mappings with
//										GetRegisteredAddress.
//	DPNHERR_GENERIC					- An error occurred while determining
//										capabilities.
//	DPNHERR_INVALIDFLAGS			- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT			- The interface object is invalid.
//	DPNHERR_INVALIDPARAM			- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER			- An invalid pointer was specified.
//	DPNHERR_NOTINITIALIZED			- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY				- There is not enough memory to get
//										capabilities.
//	DPNHERR_REENTRANT				- The interface has been re-entered on the
//										same thread.
//=============================================================================
STDMETHODIMP CNATHelpPAST::GetCaps(DPNHCAPS * const pdpnhcaps,
									const DWORD dwFlags)
{
	HRESULT				hr;
	BOOL				fHaveLock = FALSE;
	DWORD				dwCurrentTime;
	DWORD				dwLeaseTimeRemaining;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx)",
		this, pdpnhcaps, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((pdpnhcaps == NULL) ||
		(IsBadWritePtr(pdpnhcaps, sizeof(DPNHCAPS))))
	{
		DPFX(DPFPREP, 0, "Invalid caps structure pointer specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pdpnhcaps->dwSize != sizeof(DPNHCAPS))
	{
		DPFX(DPFPREP, 0, "Invalid caps structure specified, dwSize must be %u!",
			sizeof(DPNHCAPS));
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags & ~DPNHGETCAPS_UPDATESERVERSTATUS)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// Fill in the base caps structure.
	//

	pdpnhcaps->dwFlags = 0;

	pdpnhcaps->dwNumRegisteredPorts = 0;

	pdpnhcaps->dwMinLeaseTimeRemaining = -1;

	//
	// pdpnhcaps->dwRecommendedGetCapsInterval is initialized below
	//


	if (dwFlags & DPNHGETCAPS_UPDATESERVERSTATUS)
	{
		//
		// Remove any cached mappings that have expired.
		//
		this->ExpireOldCachedMappings();


		//
		// Extend leases, if necessary.
		//
		hr = this->ExtendAllExpiringLeases();
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Extending all expiring leases failed!");
			goto Failure;
		}


		//
		// Check for any new devices.
		//
		hr = this->CheckForNewDevices(NULL);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Checking for new devices failed!");
			goto Failure;
		}


		//
		// Check for possible changes in any server's status.  The
		// ADDRESSESCHANGED flag will be set on this object if there were
		// changes that affected existing port mappings.
		//
		hr = this->UpdateServerStatus();
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Updating servers' status failed!");
			goto Failure;
		}


		//
		// Okay, so if things are different, alert the caller.
		//
		if (this->m_dwFlags & NATHELPPASTOBJ_ADDRESSESCHANGED)
		{
			hr = DPNHSUCCESS_ADDRESSESCHANGED;
			this->m_dwFlags &= ~NATHELPPASTOBJ_ADDRESSESCHANGED;
		}


#ifdef DBG
		//
		// This flag should have been turned off by now if it ever got turned
		// on.
		//
		DNASSERT(! (this->m_dwFlags & NATHELPPASTOBJ_DEVICECHANGED));


		//
		// Print the current device and mapping status for debugging purposes.
		//
		this->DebugPrintCurrentStatus();
#endif // DBG
	}
	else
	{
		//
		// Not extending expiring leases or updating server status.
		//
	}


	//
	// Loop through all the devices, getting their gateway capabilities.
	//
	pBilink = this->m_blDevices.GetNext();
	while (pBilink != (&this->m_blDevices))
	{
		pDevice = DEVICE_FROM_BILINK(pBilink);

		if (pDevice->GetPASTClientID(TRUE) != 0)
		{
			//
			// PAST servers do not actively notify you of address changes.
			//
			pdpnhcaps->dwFlags |= DPNHCAPSFLAG_GATEWAYPRESENT | DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY;

			if (pDevice->IsPASTPublicAddressAvailable(TRUE))
			{
				pdpnhcaps->dwFlags |= DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE;
			}
		}

		if (pDevice->GetPASTClientID(FALSE) != 0)
		{
			if (pDevice->HasLocalPFWOnlyPASTServer())
			{
				//
				// PAST servers do not actively notify you of address changes.
				//
				pdpnhcaps->dwFlags |= DPNHCAPSFLAG_LOCALFIREWALLPRESENT | DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY;

				DNASSERT(pDevice->IsPASTPublicAddressAvailable(FALSE));
			}
			else
			{
				//
				// PAST servers do not actively notify you of address changes.
				//
				pdpnhcaps->dwFlags |= DPNHCAPSFLAG_GATEWAYPRESENT | DPNHCAPSFLAG_GATEWAYISLOCAL | DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY;

				if (pDevice->IsPASTPublicAddressAvailable(FALSE))
				{
					pdpnhcaps->dwFlags |= DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE;
				}
			}
		}


		pBilink = pBilink->GetNext();
	}


	//
	// Loop through all registered ports, counting them.
	// We have the appropriate lock.
	//
	pBilink = this->m_blRegisteredPorts.GetNext();
	dwCurrentTime = timeGetTime();

	while (pBilink != (&this->m_blRegisteredPorts))
	{
		pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

		//
		// Count these registered addresses toward the total.
		//
		pdpnhcaps->dwNumRegisteredPorts += pRegisteredPort->GetNumAddresses();


		pDevice = pRegisteredPort->GetOwningDevice();
		if (pDevice != NULL)
		{
			DNASSERT(! (pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts)));

			//
			// If they're registered with any PAST servers and also calculate
			// the minimum lease time remaining.
			//

			if (pDevice->GetPASTClientID(FALSE) != 0)
			{
				dwLeaseTimeRemaining = pRegisteredPort->GetPASTLeaseExpiration(FALSE) - dwCurrentTime;
				if (dwLeaseTimeRemaining < pdpnhcaps->dwMinLeaseTimeRemaining)
				{
					//
					// Temporarily store how much time remains.
					//
					pdpnhcaps->dwMinLeaseTimeRemaining = dwLeaseTimeRemaining;
				}
			}

			if (pDevice->GetPASTClientID(TRUE) != 0)
			{
				dwLeaseTimeRemaining = pRegisteredPort->GetPASTLeaseExpiration(TRUE) - dwCurrentTime;
				if (dwLeaseTimeRemaining < pdpnhcaps->dwMinLeaseTimeRemaining)
				{
					//
					// Temporarily store how much time remains.
					//
					pdpnhcaps->dwMinLeaseTimeRemaining = dwLeaseTimeRemaining;
				}
			}
		}
		else
		{
			DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
		}

		pBilink = pBilink->GetNext();
	}


	//
	// There are different default recommended GetCaps intervals depending on
	// whether there's a server present, and whether it supports active address
	// change notification (that we can alert on) or not.
	//
	// If there are any leases which need to be renewed before that default
	// time, the recommendation will be shortened appropriately.
	//

	//
	// If GetCaps hasn't been called with UPDATESERVERSTATUS yet, recommend an
	// immediate check.
	//
	if (this->m_dwLastUpdateServerStatusTime == 0)
	{
		DPFX(DPFPREP, 1, "Server status has not been updated yet, recommending immediate GetCaps.");

		//
		// Drop the lock, we're done here.
		//
		this->DropLock();
		fHaveLock = FALSE;

		goto Exit;
	}


	//
	// In an ideal world, we could get notified of changes and we would never
	// have to poll.  Unfortunately that isn't the case.  We need to recommend
	// a relatively short poll interval.
	//
	// Start by figuring out how long it's been since the last server update.
	// This calculation really should not go negative.  If it does, it means
	// the caller hasn't updated the server status in ages anyway, so we should
	// recommend immediate GetCaps.
	//
	// Otherwise if the 'port registered' flag is still set at this point, then
	// the user must have called GetCaps previously, then RegisterPorts, then
	// made this second GetCaps call before g_dwMinUpdateServerStatusInterval
	// elapsed.  Recommend that the user call us again as soon as the minimum
	// update interval does elapse.
	//
	// In all other cases, generate a recommendation based on the current
	// backed off poll interval.
	//
	dwCurrentTime = dwCurrentTime - this->m_dwLastUpdateServerStatusTime;

	if ((int) dwCurrentTime < 0)
	{
		DPFX(DPFPREP, 1, "Server status was last updated a really long time ago (%u ms), recommending immediate GetCaps.",
			dwCurrentTime);
		pdpnhcaps->dwRecommendedGetCapsInterval = 0;
	}
	else if (this->m_dwFlags & NATHELPPASTOBJ_PORTREGISTERED)
	{
		DPFX(DPFPREP, 1, "Didn't handle new port registration because server was last updated %u ms ago, (poll interval staying at %u ms).",
			dwCurrentTime, this->m_dwNextPollInterval);

		pdpnhcaps->dwRecommendedGetCapsInterval = g_dwMinUpdateServerStatusInterval - dwCurrentTime;
		if ((int) pdpnhcaps->dwRecommendedGetCapsInterval < 0)
		{
			pdpnhcaps->dwRecommendedGetCapsInterval = 0;
		}
	}
	else
	{
		DPFX(DPFPREP, 7, "Server was last updated %u ms ago, current poll interval is %u ms.",
			dwCurrentTime, this->m_dwNextPollInterval);

		//
		// Calculate a new recommended interval based on the current value, and
		// backoff that interval if necessary.
		//
		pdpnhcaps->dwRecommendedGetCapsInterval = this->m_dwNextPollInterval - dwCurrentTime;
		this->m_dwNextPollInterval += GetGlobalRand() % g_dwPollIntervalBackoff;
		if (this->m_dwNextPollInterval > g_dwMaxPollInterval)
		{
			this->m_dwNextPollInterval = g_dwMaxPollInterval;
			DPFX(DPFPREP, 3, "Capping next poll interval at %u ms.",
				this->m_dwNextPollInterval);
		}
		else
		{
			DPFX(DPFPREP, 8, "Next poll interval will be %u ms.",
				this->m_dwNextPollInterval);
		}


		//
		// If that time went negative, then it implies that the interval has
		// already elapsed.  Recommend immediate GetCaps.
		//
		if (((int) pdpnhcaps->dwRecommendedGetCapsInterval) < 0)
		{
			DPFX(DPFPREP, 1, "Recommended interval already elapsed (%i ms), suggesting immediate GetCaps.",
				((int) pdpnhcaps->dwRecommendedGetCapsInterval));
			pdpnhcaps->dwRecommendedGetCapsInterval = 0;
		}
	}


	this->DropLock();
	fHaveLock = FALSE;


	//
	// If there is a non-INFINITE lease time remaining, see if that affects the
	// GetCaps interval.
	//
	if (pdpnhcaps->dwMinLeaseTimeRemaining != -1)
	{
		//
		// If there are leases that need to be refreshed before the default
		// recommendation, then use those instead.
		//
		if (pdpnhcaps->dwMinLeaseTimeRemaining < LEASE_RENEW_TIME)
		{
			DPFX(DPFPREP, 1, "Lease needs renewing right away (min %u < %u ms), recommending immediate GetCaps.",
				pdpnhcaps->dwMinLeaseTimeRemaining, LEASE_RENEW_TIME);

			pdpnhcaps->dwRecommendedGetCapsInterval = 0;
		}
		else
		{
			//
			// Either pick the time when the lease should be renewed or leave
			// it as the recommended time, whichever is shorter.
			//
			if ((pdpnhcaps->dwMinLeaseTimeRemaining - LEASE_RENEW_TIME) < pdpnhcaps->dwRecommendedGetCapsInterval)
			{
				pdpnhcaps->dwRecommendedGetCapsInterval = pdpnhcaps->dwMinLeaseTimeRemaining - LEASE_RENEW_TIME;
			}
		}
	}


	DPFX(DPFPREP, 7, "GetCaps flags = 0x%lx, num registered ports = %u, min lease time remaining = %i, recommended interval = %i.",
		pdpnhcaps->dwFlags,
		pdpnhcaps->dwNumRegisteredPorts,
		((int) pdpnhcaps->dwMinLeaseTimeRemaining),
		((int) pdpnhcaps->dwRecommendedGetCapsInterval));


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpPAST::GetCaps





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::RegisterPorts"
//=============================================================================
// CNATHelpPAST::RegisterPorts
//-----------------------------------------------------------------------------
//
// Description:    Asks for public realm port(s) that are aliases for the local
//				port(s) on this private realm node.  If a server is available,
//				all traffic directed to the gateway on the public side at the
//				allocated public ports-- which the gateway provides and
//				specifies in the response-- will be directed to the specified
//				local ports.  If the DPNHREGISTERPORTS_FIXEDPORTS flag is not
//				specified, the ports assigned on the public interface are
//				arbitrary (i.e. may not be the same as those in awLocalPort).
//				The address and ports actually allocated can be retrieved by
//				calling GetRegisteredAddresses.
//
//				   The address component for every SOCKADDR structure in the
//				array must be the same.  A separate RegisterPorts call is
//				required to register multiple ports that are not using the same
//				interface.  The address can be INADDR_ANY, in which case the
//				"best" server will be used.  If multiple servers are available
//				via different adapters, an adapter with an Internet gateway is
//				selected.  If no adapters have Internet gateways, the first
//				adapter with a local firewall is selected.  If neither are
//				available, then the first one where either a gateway or a
//				firewall becomes available will be automatically selected.
//				Once one of the adapters has been assigned, it cannot be
//				changed.  Since the server chosen by this method may not be
//				optimal for a particular application, it is recommended that
//				individual addresses be registered instead of INADDR_ANY.
//
//				   If the address in aLocalAddresses is not one of those
//				available to the local machine, the registration will still
//				succeed.  If an adapter with that address becomes available,
//				the port mapping will automatically be applied, and it will
//				gain a public mapping with any server available to that
//				adapter.  If the address was originally available but the
//				network adapter is subsequently removed from the system, any
//				public address mapping is lost.  It will be automatically
//				regained if the local address becomes available again.  It is
//				recommended that the caller detect local address changes
//				independently and de-register/re-register mappings per adapter
//				as appropriate for maximum control.
//
//				   If the DPNHREGISTERPORTS_SHAREDPORTS flag is used, the
//				server will allow other NAT clients to register it as well.
//				Any UDP traffic received on the public interface will be
//				forwarded to all clients registered.  This requires the
//				DPNHREGISTERPORTS_FIXEDPORTS flag and cannot be used with
//				DPNHREGISTERPORTS_TCP.
//
//				   The user should specify a requested lease time that the
//				server will attempt to honor.  The actual time remaining can be
//				can be retrieved by calling GetRegisteredAddresses.
//
//				   Note that if a server is not available, this function will
//				still succeed. GetRegisteredAddresses will return
//				DPNHERR_NOMAPPING for the handle returned in phRegisteredPorts
//				in that case.  If the server arrives later during the session,
//				calling GetCaps periodically can detect this and automatically
//				map previously registered ports.  Use GetRegisteredAddresses to
//				retrieve the newly mapped address when that occurs.
//
//				   Only 16 ports may be registered at a time, but RegisterPorts
//				may be called as many times as desired.
//
//				   The same array of addresses may be registered more than
//				once.  Each DPNHHANDLE returned must be released with
//				DeregisterPorts or Close.  If an individual address was
//				previously registered but in a different array or a different
//				order in the array, then the DPNHERR_PORTALREADYREGISTERED
//				error code is returned.
//
// Arguments:
//	SOCKADDR * aLocalAddresses		- Array of local address and port tuples
//										for which remote ports are requested.
//	DWORD dwAddressesSize			- Size of entire local addresses array.
//	DWORD dwNumAddresses			- Number of SOCKADDR structures in local
//										addresses array.
//	DWORD dwLeaseTime				- Requested time, in milliseconds, to lease
//										the ports.  As long as GetCaps is
//										called before this time has expired,
//										the lease will automatically be
//										renewed.
//	DPNHHANDLE * phRegisteredPorts	- Place to store an identifier for this
//										binding which can later be used to
//										query or release the binding.
//	DWORD dwFlags					- Flags to use when registering the port
//										(DPNHREGISTERPORTS_xxx).
//
// Returns: HRESULT
//	DPNH_OK							- The ports were successfully registered
//										(although no public address may be
//										available yet).
//	DPNHERR_GENERIC					- An error occurred that prevented
//										registration of the requested ports.
//	DPNHERR_INVALIDFLAGS			- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT			- The interface object is invalid.
//	DPNHERR_INVALIDPARAM			- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER			- An invalid pointer was specified.
//	DPNHERR_NOTINITIALIZED			- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY				- There is not enough memory to register
//										the ports.
//	DPNHERR_PORTALREADYREGISTERED	- At least one of the ports has already
//										been registered in a different address
//										array or order.
//	DPNHERR_REENTRANT				- The interface has been re-entered on the
//										same thread.
//=============================================================================
STDMETHODIMP CNATHelpPAST::RegisterPorts(const SOCKADDR * const aLocalAddresses,
										const DWORD dwAddressesSize,
										const DWORD dwNumAddresses,
										const DWORD dwLeaseTime,
										DPNHHANDLE * const phRegisteredPorts,
										const DWORD dwFlags)
{
	HRESULT				hr;
	HRESULT				temphr;
	ULONG				ulFirstAddress;
	DWORD				dwTemp;
	DWORD				dwMatch;
	BOOL				fHaveLock = FALSE;
	BOOL				fGotLocalPASTMapping = FALSE;
	BOOL				fGotRemotePASTMapping = FALSE;
	CRegisteredPort *	pRegisteredPort = NULL;
	CDevice *			pDevice = NULL;
	CBilink *			pBilink;
	SOCKADDR_IN *		psaddrinTemp;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, %u, %u, %u, 0x%p, 0x%lx)",
		this, aLocalAddresses, dwAddressesSize, dwNumAddresses, dwLeaseTime,
		phRegisteredPorts, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (aLocalAddresses == NULL)
	{
		DPFX(DPFPREP, 0, "Local addresses array cannot be NULL!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwNumAddresses == 0)
	{
		DPFX(DPFPREP, 0, "Number of addresses cannot be 0!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwAddressesSize != (dwNumAddresses * sizeof(SOCKADDR)))
	{
		DPFX(DPFPREP, 0, "Addresses array size invalid!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (IsBadReadPtr(aLocalAddresses, dwAddressesSize))
	{
		DPFX(DPFPREP, 0, "Local addresses array buffer is invalid!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwNumAddresses > DPNH_MAX_SIMULTANEOUS_PORTS)
	{
		DPFX(DPFPREP, 0, "Only %u ports may be registered at a time!", DPNH_MAX_SIMULTANEOUS_PORTS);
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) aLocalAddresses)->sin_family != AF_INET)
	{
		DPFX(DPFPREP, 0, "First address in array is not AF_INET, only IPv4 addresses are supported!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_addr == INADDR_BROADCAST)
	{
		DPFX(DPFPREP, 0, "First address cannot be broadcast address!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) aLocalAddresses)->sin_port == 0)
	{
		DPFX(DPFPREP, 0, "First port in array is 0, a valid port must be specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	ulFirstAddress = ((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_addr;

	for(dwTemp = 1; dwTemp < dwNumAddresses; dwTemp++)
	{
		//
		// Make sure this address family type is supported.
		//
		if (((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_family != AF_INET)
		{
			DPFX(DPFPREP, 0, "Address at array index %u is not AF_INET, all items in the array must be the same IPv4 address!",
				dwTemp);
			hr = DPNHERR_INVALIDPARAM;
			goto Failure;
		}

		//
		// If this address doesn't match the first, then the caller broke the
		// rules.
		//
		if (((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_addr != ulFirstAddress)
		{
			//
			// Don't use inet_ntoa because we may not be initialized yet.
			//
			DPFX(DPFPREP, 0, "Address %u.%u.%u.%u at array index %u differs from the first, all addresses in the array must match!",
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b1,
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b2,
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b3,
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b4,
				dwTemp);
			hr = DPNHERR_INVALIDPARAM;
			goto Failure;
		}

		//
		// Make sure this port isn't 0 either.
		//
		if (((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_port == 0)
		{
			DPFX(DPFPREP, 0, "Port at array index %u is 0, valid ports must be specified!", dwTemp);
			hr = DPNHERR_INVALIDPARAM;
			goto Failure;
		}
	}

	if (dwLeaseTime == 0)
	{
		DPFX(DPFPREP, 0, "Invalid lease time specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if ((phRegisteredPorts == NULL) ||
		(IsBadWritePtr(phRegisteredPorts, sizeof(DPNHHANDLE))))
	{
		DPFX(DPFPREP, 0, "Invalid port mapping handle pointer specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwFlags & ~(DPNHREGISTERPORTS_TCP | DPNHREGISTERPORTS_FIXEDPORTS | DPNHREGISTERPORTS_SHAREDPORTS))
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}

	if (dwFlags & DPNHREGISTERPORTS_SHAREDPORTS)
	{
		//
		// SHAREDPORTS cannot be used with TCP and requires a FIXEDPORTS.
		//
		if ((dwFlags & DPNHREGISTERPORTS_TCP) || (! (dwFlags & DPNHREGISTERPORTS_FIXEDPORTS)))
		{
			DPFX(DPFPREP, 0, "SHAREDPORTS flag requires FIXEDPORTS flag and cannot be used with TCP flag!");
			hr = DPNHERR_INVALIDFLAGS;
			goto Failure;
		}
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}



	//
	// Loop through all existing registered port mappings and look for this
	// array of ports.
	//
	pBilink = this->m_blRegisteredPorts.GetNext();
	while (pBilink != &this->m_blRegisteredPorts)
	{
		pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

		//
		// Don't bother looking at addresses of the wrong type or at arrays of
		// the wrong size.
		//
		if (((pRegisteredPort->IsTCP() && (dwFlags & DPNHREGISTERPORTS_TCP)) ||
			((! pRegisteredPort->IsTCP()) && (! (dwFlags & DPNHREGISTERPORTS_TCP)))) &&
			(pRegisteredPort->GetNumAddresses() == dwNumAddresses))
		{
			psaddrinTemp = pRegisteredPort->GetPrivateAddressesArray();
			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				//
				// If the addresses don't match, stop looping.
				//
				if ((psaddrinTemp[dwTemp].sin_port != ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_port) ||
					(psaddrinTemp[dwTemp].sin_addr.S_un.S_addr != ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_addr))
				{
					break;
				}
			}


			//
			// If all the addresses matched, then this item was already
			// registered.
			//
			if (dwTemp >= dwNumAddresses)
			{
				DPFX(DPFPREP, 1, "Array of %u addresses was already registered, returning existing mapping 0x%p.",
					dwNumAddresses, pRegisteredPort);
				goto ReturnUserHandle;
			}

			DPFX(DPFPREP, 7, "Existing mapping 0x%p does not match all %u addresses.",
				pRegisteredPort, dwNumAddresses);
		}
		else
		{
			//
			// Existing mapping isn't same type or doesn't have same number of
			// items in array.
			//
		}

		pBilink = pBilink->GetNext();
	}


	//
	// If we're here, none of the existing mappings match.  Loop through each
	// of the ports and make sure they aren't already registered inside some
	// other mapping.
	//
	for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
	{
		pBilink = this->m_blRegisteredPorts.GetNext();
		while (pBilink != &this->m_blRegisteredPorts)
		{
			pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

			psaddrinTemp = pRegisteredPort->GetPrivateAddressesArray();
			for(dwMatch = 0; dwMatch < pRegisteredPort->GetNumAddresses(); dwMatch++)
			{
				//
				// If the addresses match, then we can't map these ports.
				//
				if ((psaddrinTemp[dwMatch].sin_port == ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_port) &&
					(psaddrinTemp[dwMatch].sin_addr.S_un.S_addr == ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_addr))
				{
					DPFX(DPFPREP, 0, "Existing mapping 0x%p already registered the address %u.%u.%u.%u:%u!",
						pRegisteredPort,
						psaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b1,
						psaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b2,
						psaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b3,
						psaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b4,
						NTOHS(psaddrinTemp[dwMatch].sin_port));

					//
					// Clear the pointer so we don't delete the object.
					//
					pRegisteredPort = NULL;

					hr = DPNHERR_PORTALREADYREGISTERED;
					goto Failure;
				}
			}

			pBilink = pBilink->GetNext();
		}
	}


	//
	// If we're here the ports are all unique.  Create a new mapping object
	// we'll use to refer to the binding.
	//
	pRegisteredPort = new CRegisteredPort(dwLeaseTime, dwFlags);
	if (pRegisteredPort == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	hr = pRegisteredPort->SetPrivateAddresses((SOCKADDR_IN*) aLocalAddresses, dwNumAddresses);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't store private addresses array!");
		goto Failure;
	}


	//
	// Find the device that matches the given addresses.
	//
	// The first entry of aLocalAddresses is representative of all entries since
	// they should all share the same address.
	//
	// Since there won't be an existing registered port for this address, don't
	// bother looking through them for a matching address.
	//
	pDevice = this->FindMatchingDevice((SOCKADDR_IN*) (&aLocalAddresses[0]),
										FALSE);
	if (pDevice == NULL)
	{
		DPFX(DPFPREP, 1, "No device for given address (%u.%u.%u.%u), storing 0x%p in unowned list.",
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b4,
			pRegisteredPort);

		pRegisteredPort->m_blDeviceList.InsertBefore(&this->m_blUnownedPorts);
	}
	else
	{
		pRegisteredPort->MakeDeviceOwner(pDevice);


		//
		// If we have a client ID, that means the server is available.  So if
		// there's either a local or remote PAST server, we can request the
		// mapping right now.
		// Start with the local PAST server.
		//

		if (pDevice->GetPASTClientID(FALSE) != 0)
		{
			hr = this->AssignOrListenPASTPort(pRegisteredPort, FALSE);
			if (hr != DPNH_OK)
			{
				if (hr != DPNHERR_PORTUNAVAILABLE)
				{
					DPFX(DPFPREP, 0, "Couldn't assign port mapping with local PAST server (0x%lx)!  Ignoring.", hr);

					//
					// We'll treat this as non-fatal, but we have to dump the
					// server.
					//
					this->ClearDevicesPASTServer(pDevice, FALSE);
				}
				else
				{
					DPFX(DPFPREP, 1, "Local PAST server indicated that the port was unavailable.");
					pRegisteredPort->NotePASTPortUnavailable(FALSE);
				}

				hr = DPNH_OK;
			}
			else
			{
				fGotLocalPASTMapping = TRUE;
			}
		}
		else
		{
			//
			// No local PAST server.
			//
		}


		//
		// Check remote PAST server, too.
		//
		if (pDevice->GetPASTClientID(TRUE) != 0)
		{
			hr = this->AssignOrListenPASTPort(pRegisteredPort, TRUE);
			if (hr != DPNH_OK)
			{
				if (hr != DPNHERR_PORTUNAVAILABLE)
				{
					DPFX(DPFPREP, 0, "Couldn't assign port mapping with remote PAST server (0x%lx)!  Ignoring.", hr);

					//
					// We'll treat this as non-fatal, but we have to dump the
					// server.
					//
					this->ClearDevicesPASTServer(pDevice, TRUE);
				}
				else
				{
					DPFX(DPFPREP, 1, "Remote PAST server indicated that the port was unavailable.");
					pRegisteredPort->NotePASTPortUnavailable(TRUE);
				}

				hr = DPNH_OK;
			}
			else
			{
				fGotRemotePASTMapping = TRUE;
			}
		}
		else
		{
			//
			// No remote PAST server.
			//
		}
	}


	//
	// Save the mapping in the global list (we have the lock).
	//
	pRegisteredPort->m_blGlobalList.InsertBefore(&this->m_blRegisteredPorts);


ReturnUserHandle:

	//
	// Remember that a port has been registered.
	//
	this->m_dwFlags |= NATHELPPASTOBJ_PORTREGISTERED;

	//
	// We're about to give the port to the user.
	//
	pRegisteredPort->AddUserRef();

	//
	// We're going to give the user a direct pointer to the object (disguised
	// as an opaque DPNHHANDLE, of course).
	//
	(*phRegisteredPorts) = (DPNHHANDLE) pRegisteredPort;


	this->DropLock();
	fHaveLock = FALSE;


	DPFX(DPFPREP, 5, "Returning registered port 0x%p (first private address = %u.%u.%u.%u:%u).",
		pRegisteredPort,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b1,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b2,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b3,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b4,
		NTOHS(((SOCKADDR_IN*) aLocalAddresses)[0].sin_port));


	hr = DPNH_OK;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fGotRemotePASTMapping)
	{
		temphr = this->FreePASTPort(pRegisteredPort, TRUE);
		if (temphr != DPNH_OK)
		{
			//
			// We'll treat this as non-fatal, but we have to dump the server.
			//
			this->ClearDevicesPASTServer(pRegisteredPort->GetOwningDevice(), TRUE);
		}
	}

	if (fGotLocalPASTMapping)
	{
		temphr = this->FreePASTPort(pRegisteredPort, FALSE);
		if (temphr != DPNH_OK)
		{
			//
			// We'll treat this as non-fatal, but we have to dump the server.
			//
			this->ClearDevicesPASTServer(pRegisteredPort->GetOwningDevice(), FALSE);
		}
	}

	if (pRegisteredPort != NULL)
	{
		if (pDevice != NULL)
		{
			pRegisteredPort->ClearDeviceOwner();
		}

		pRegisteredPort->ClearPrivateAddresses();
		delete pRegisteredPort;
	}

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpPAST::RegisterPorts






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::GetRegisteredAddresses"
//=============================================================================
// CNATHelpPAST::GetRegisteredAddresses
//-----------------------------------------------------------------------------
//
// Description:    Returns the current public address mappings for a given
//				registered port group.  If there are no servers currently
//				available, then DPNHERR_SERVERNOTAVAILABLE is returned.  If the
//				servers' public interfaces are not currently valid, then
//				DPNHERR_NOMAPPING is returned, but appropriate values will
//				still be placed in pdwAddressTypeFlags and
//				pdwLeaseTimeRemaining.
//
//				   If the mapping was registered with the
//				DPNHREGISTERPORTS_FIXEDPORTS flag, but at least one port is
//				already in use on the gateway, then DPNHERR_PORTUNAVAILABLE is
//				returned and appropriate flags will still be placed in
//				pdwAddressTypeFlags.
//
//				   If the local machine has a cooperative firewall installed,
//				the requested port is opened locally on the firewall before
//				being mapped on the Internet gateway.  Normally this function
//				returns the public address on the Internet gateway address when
//				both are present.  Since some firewalls remap the port number
//				when opening non-fixed ports, the
//				DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY allows the
//				caller to retrieve the locally remapped address, even if there
//				is a mapping on an Internet gateway.
//
//				   Some gateway devices do not natively support ports that are
//				not fixed, and may generate the DPNHERR_PORTUNAVAILABLE return
//				code even when the DPNHREGISTERPORTS_FIXEDPORTS flag was not
//				specified.  The caller should de-register the port mapping
//				handle, rebind the application to different ports, and call
//				RegisterPorts again.
//
//				   If the buffer indicated by paPublicAddresses is too small,
//				then the size required is returned in pdwPublicAddressesSize
//				and DPNHERR_BUFFERTOOSMALL is returned.  Otherwise the number of
//				bytes written is returned in pdwPublicAddressesSize.
//
//				   Even though the addresses are returned as individual
//				SOCKADDRs, all ports registered at the same time will share the
//				same public address.  Only the port components will vary.
//
//				   All buffers are optional and may be NULL, but if
//				paPublicAddresses is specified, it must be accompanied by an
//				appropriate size in pdwPublicAddressesSize.
//
//				   If GetCaps has not been previously called with the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag at least once, then the
//				error code DPNHERR_UPDATESERVERSTATUS is returned.
//
// Arguments:
//	DPNHHANDLE hRegisteredPorts		- Handle for a specific binding returned by
//										RegisterPorts.
//	SOCKADDR * paPublicAddresses	- Buffer to return assigned public realm
//										address, or NULL if not desired.
//	DWORD * pdwPublicAddressesSize	- Pointer to size of paPublicAddresses
//										buffer, or place to store size
//										required/written.  Cannot be NULL if
//										paPublicAddresses is not NULL.
//	DWORD * pdwAddressTypeFlags		- Place to store flags describing the
//										address types returned, or NULL if not
//										desired.
//	DWORD * pdwLeaseTimeRemaining	- Place to store approximate number of
//										milliseconds remaining in the port
//										lease, or NULL if not desired.  Call
//										GetCaps to automatically extend leases
//										about to expire.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK						- Information on the port mapping was found and
//									the addresses were stored in
//									paPublicAddresses.
//	DPNHERR_BUFFERTOOSMALL		- There was not enough room in the buffer to
//									store the addresses. 
//	DPNHERR_GENERIC				- An error occurred while retrieving the
//									requested port mapping.
//	DPNHERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT		- The interface object is invalid.
//	DPNHERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER		- An invalid pointer was specified.
//	DPNHERR_NOMAPPING			- The server(s) do not have valid public
//									interfaces.
//	DPNHERR_NOTINITIALIZED		- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY			- There is not enough memory to get the
//									addresses.
//	DPNHERR_PORTUNAVAILABLE		- At least one of the ports is not available on
//									the server.
//	DPNHERR_REENTRANT			- The interface has been re-entered on the same
//									thread.
//	DPNHERR_SERVERNOTAVAILABLE	- No servers are currently present.
//	DPNHERR_UPDATESERVERSTATUS	- GetCaps has not been called with the
//									DPNHGETCAPS_UPDATESERVERSTATUS flag yet.
//=============================================================================
STDMETHODIMP CNATHelpPAST::GetRegisteredAddresses(const DPNHHANDLE hRegisteredPorts,
												SOCKADDR * const paPublicAddresses,
												DWORD * const pdwPublicAddressesSize,
												DWORD * const pdwAddressTypeFlags,
												DWORD * const pdwLeaseTimeRemaining,
												const DWORD dwFlags)
{
	HRESULT				hr;
	CRegisteredPort *	pRegisteredPort;
	BOOL				fHaveLock = FALSE;
	BOOL				fRegisteredWithServer = FALSE;
	BOOL				fFoundValidMapping = FALSE;
	BOOL				fPortIsUnavailable = FALSE;
	DWORD				dwSizeRequired;
	DWORD				dwAddressTypeFlags;
	DWORD				dwCurrentTime;
	DWORD				dwTempLeaseTimeRemaining;
	DWORD				dwLeaseTimeRemaining = -1;
	CDevice *			pDevice;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, 0x%p, 0x%p, 0x%lx)",
		this, hRegisteredPorts, paPublicAddresses, pdwPublicAddressesSize,
		pdwAddressTypeFlags, pdwLeaseTimeRemaining, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	pRegisteredPort = (CRegisteredPort*) hRegisteredPorts;
	if (! pRegisteredPort->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid registered port mapping handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (paPublicAddresses != NULL)
	{
		if ((pdwPublicAddressesSize == NULL) ||
			(IsBadWritePtr(pdwPublicAddressesSize, sizeof(DWORD))))
		{
			DPFX(DPFPREP, 0, "When specifying a public addresses buffer, a valid size must be given!");
			hr = DPNHERR_INVALIDPOINTER;
			goto Failure;
		}

		if (IsBadWritePtr(paPublicAddresses, (*pdwPublicAddressesSize)))
		{
			DPFX(DPFPREP, 0, "The public addresses buffer is invalid!");
			hr = DPNHERR_INVALIDPOINTER;
			goto Failure;
		}
	}
	else
	{
		if ((pdwPublicAddressesSize != NULL) &&
			(IsBadWritePtr(pdwPublicAddressesSize, sizeof(DWORD))))
		{
			DPFX(DPFPREP, 0, "Invalid pointer for size of public addresses buffer!");
			hr = DPNHERR_INVALIDPOINTER;
			goto Failure;
		}
	}

	if ((pdwAddressTypeFlags != NULL) &&
		(IsBadWritePtr(pdwAddressTypeFlags, sizeof(DWORD))))
	{
		DPFX(DPFPREP, 0, "Invalid pointer for address type flags!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if ((pdwLeaseTimeRemaining != NULL) &&
		(IsBadWritePtr(pdwLeaseTimeRemaining, sizeof(DWORD))))
	{
		DPFX(DPFPREP, 0, "Invalid pointer for lease time remaining!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwFlags & ~DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}



	//
	// Start the flags off with the information regarding TCP vs. UDP.
	//
	if (pRegisteredPort->IsTCP())
	{
		dwAddressTypeFlags = DPNHADDRESSTYPE_TCP;
	}
	else
	{
		dwAddressTypeFlags = 0;
	}


	//
	// Add in other flags we know already.
	//

	if (pRegisteredPort->IsFixedPort())
	{
		dwAddressTypeFlags |= DPNHADDRESSTYPE_FIXEDPORTS;
	}

	if (pRegisteredPort->IsSharedPort())
	{
		dwAddressTypeFlags |= DPNHADDRESSTYPE_SHAREDPORTS;
	}




	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwLastUpdateServerStatusTime == 0)
	{
		DPFX(DPFPREP, 0, "GetCaps has not been called with UPDATESERVERSTATUS flag yet!");
		hr = DPNHERR_UPDATESERVERSTATUS;
		goto Failure;
	}


	//
	// Get a shortcut pointer to the device (may not exist).
	//
	pDevice = pRegisteredPort->GetOwningDevice();


	//
	// Get the current time for both the remote and local lease calculations.
	//
	dwCurrentTime = timeGetTime();


	if (! (dwFlags & DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY))
	{
		//
		// Check for a mapping on a remote PAST server.
		//
		if (pRegisteredPort->GetPASTBindID(TRUE) != 0)
		{
			DNASSERT(pDevice != NULL);

			//
			// There's a bind ID, so there must be a public address array.
			//
			DNASSERT(pRegisteredPort->HasPASTPublicAddressesArray(TRUE));


			fRegisteredWithServer = TRUE;


			//
			// Make sure the remote PAST server is currently giving out a valid
			// public address.  If so, hand it out.
			//
			if (pDevice->IsPASTPublicAddressAvailable(TRUE))
			{
				if (pdwPublicAddressesSize != NULL)
				{
					dwSizeRequired = pRegisteredPort->GetAddressesSize();

					if ((paPublicAddresses == NULL) ||
						(dwSizeRequired > (*pdwPublicAddressesSize)))
					{
						//
						// Not enough room in buffer, return the size required
						// and the BUFFERTOOSMALL error code.
						//
						(*pdwPublicAddressesSize) = dwSizeRequired;
						hr = DPNHERR_BUFFERTOOSMALL;
					}
					else
					{
						//
						// Buffer was large enough, return the size written.
						//
						(*pdwPublicAddressesSize) = dwSizeRequired;
						pRegisteredPort->CopyPASTPublicAddresses((SOCKADDR_IN*) paPublicAddresses,
																TRUE);
					}
				}
				else
				{
					//
					// Not using address buffer.
					//
				}

				fFoundValidMapping = TRUE;
			}
			else
			{
				DPFX(DPFPREP, 8, "The remote PAST server is not currently handing out valid public address mappings.");
			}


			//
			// Add in the flag indicating that there's a remote ICS server.
			//
			dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAY;


			//
			// Get the relative remote PAST server lease time remaining.
			//
			dwTempLeaseTimeRemaining = pRegisteredPort->GetPASTLeaseExpiration(TRUE) - dwCurrentTime;

			if (((int) dwTempLeaseTimeRemaining) < 0)
			{
				DPFX(DPFPREP, 1, "Registered port mapping's remote PAST server lease has already expired, returning 0 for lease time remaining.");
				dwLeaseTimeRemaining = 0;
			}
			else
			{
				//
				// The values are relative, so we don't have to worry about
				// wraparound.
				//
				//if (dwTempLeaseTimeRemaining < dwLeaseTimeRemaining)
				//{
					dwLeaseTimeRemaining = dwTempLeaseTimeRemaining;
				//}
			}
		}
		else
		{
			//
			// No bind ID, no public address array.
			//
			DNASSERT(! pRegisteredPort->HasPASTPublicAddressesArray(TRUE));


			if (pRegisteredPort->IsPASTPortUnavailable(TRUE))
			{
				DNASSERT(pDevice != NULL);

				fRegisteredWithServer = TRUE;
				fPortIsUnavailable = TRUE;

				DPFX(DPFPREP, 8, "The remote PAST server indicates the port(s) are unavailable.");

				//
				// Add in the flag indicating that there's a remote ICS server.
				//
				dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAY;
			}
#ifdef DBG
			else
			{
				//
				// No remote PAST server or it's an unowned port.
				//
				if (pDevice != NULL)
				{
					DNASSERT(pDevice->GetPASTClientID(TRUE) == 0);
				}
				else
				{
					DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
				}
			}
#endif // DBG
		}
	}
	else
	{
		//
		// We're not allowed to return the remote PAST mapping.
		//
		DPFX(DPFPREP, 8, "Ignoring any Internet gateway mappings, LOCALFIREWALLREMAPONLY was specified.");
	}


	//
	// Finally, check for a mapping on a local PAST server.
	//
	if (pRegisteredPort->GetPASTBindID(FALSE) != 0)
	{
		DNASSERT(pDevice != NULL);

		//
		// There's a bind ID, so there must be a public address array.
		//
		DNASSERT(pRegisteredPort->HasPASTPublicAddressesArray(FALSE));


		fRegisteredWithServer = TRUE;


		//
		// If we didn't already get a remote mapping, return this local one.
		//
		if (! fFoundValidMapping)
		{
			//
			// Make sure the local PAST server is currently giving out a valid
			// public address.  If so, hand it out.
			//
			if (pDevice->IsPASTPublicAddressAvailable(FALSE))
			{
				if (pdwPublicAddressesSize != NULL)
				{
					dwSizeRequired = pRegisteredPort->GetAddressesSize();

					if ((paPublicAddresses == NULL) ||
						(dwSizeRequired > (*pdwPublicAddressesSize)))
					{
						//
						// Not enough room in buffer, return the size required
						// and the BUFFERTOOSMALL error code.
						//
						(*pdwPublicAddressesSize) = dwSizeRequired;
						hr = DPNHERR_BUFFERTOOSMALL;
					}
					else
					{
						//
						// Buffer was large enough, return the size written.
						//
						(*pdwPublicAddressesSize) = dwSizeRequired;
						pRegisteredPort->CopyPASTPublicAddresses((SOCKADDR_IN*) paPublicAddresses,
																FALSE);
					}
				}
				else
				{
					//
					// Not using address buffer.
					//
				}

				fFoundValidMapping = TRUE;
			}
			else
			{
				DPFX(DPFPREP, 8, "The local PAST server is not currently handing out valid public address mappings.");
			}
		}
		else
		{
			DPFX(DPFPREP, 6, "Ignoring possible local PAST server mapping due to remote PAST server mapping.");
		}


		//
		// Add in the flag indicating whether this is a PFW only or ICS server.
		//
		if (pDevice->HasLocalPFWOnlyPASTServer())
		{
			dwAddressTypeFlags |= DPNHADDRESSTYPE_LOCALFIREWALL;
		}
		else
		{
			dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAY | DPNHADDRESSTYPE_GATEWAYISLOCAL;
		}


		//
		// Get the relative time remaining.
		//
		dwTempLeaseTimeRemaining = pRegisteredPort->GetPASTLeaseExpiration(FALSE) - dwCurrentTime;

		if (((int) dwTempLeaseTimeRemaining) < 0)
		{
			DPFX(DPFPREP, 1, "Registered port mapping's local PAST server lease has already expired, returning 0 for lease time remaining.");
			dwLeaseTimeRemaining = 0;
		}
		else
		{
			//
			// If that time remaining is less than the remote PAST server lease
			// time (if any), overwrite it with the shorter time.  The values
			// are relative, so we don't have to worry about wraparound.
			//
			if (dwTempLeaseTimeRemaining < dwLeaseTimeRemaining)
			{
				dwLeaseTimeRemaining = dwTempLeaseTimeRemaining;
			}
		}
	}
	else
	{
		//
		// No bind ID, no public address array.
		//
		DNASSERT(! pRegisteredPort->HasPASTPublicAddressesArray(FALSE));


		if (pRegisteredPort->IsPASTPortUnavailable(FALSE))
		{
			DNASSERT(pDevice != NULL);

			fRegisteredWithServer = TRUE;
			fPortIsUnavailable = TRUE;

			DPFX(DPFPREP, 8, "The local PAST server indicates the port(s) are unavailable.");


			//
			// Add in the flag indicating whether this is a PFW only or ICS server.
			//
			if (pDevice->HasLocalPFWOnlyPASTServer())
			{
				dwAddressTypeFlags |= DPNHADDRESSTYPE_LOCALFIREWALL;
			}
			else
			{
				dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAY | DPNHADDRESSTYPE_GATEWAYISLOCAL;
			}
		}
#ifdef DBG
		else
		{
			//
			// No local PAST server or it's an unowned port.
			//
			if (pDevice != NULL)
			{
				DNASSERT(pDevice->GetPASTClientID(FALSE) == 0);
			}
			else
			{
				DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
			}
		}
#endif // DBG
	}
		

	this->DropLock();
	fHaveLock = FALSE;


	if (fRegisteredWithServer)
	{
		DNASSERT(dwAddressTypeFlags & (DPNHADDRESSTYPE_LOCALFIREWALL | DPNHADDRESSTYPE_GATEWAY));


		if (! fFoundValidMapping)
		{
			if (fPortIsUnavailable)
			{
				//
				// The servers indicated that the ports were already in use.
				// Return PORTUNAVAILABLE.
				//
				DPFX(DPFPREP, 1, "The Internet gateway(s) could not map the port, returning PORTUNAVAILABLE.");
				hr = DPNHERR_PORTUNAVAILABLE;
			}
			else
			{
				//
				// The servers didn't have public addresses.  Return NOMAPPING.
				//
				DPFX(DPFPREP, 1, "The Internet gateway(s) did not offer valid public addresses, returning NOMAPPING.");
				hr = DPNHERR_NOMAPPING;
			}
		}
		else
		{
			//
			// One of the servers had a public address.
			//
			DNASSERT((hr == DPNH_OK) || (hr == DPNHERR_BUFFERTOOSMALL));
		}
	}
	else
	{
		//
		// The ports aren't registered, because there aren't any gateways.
		// Return SERVERNOTAVAILABLE.
		//
		DPFX(DPFPREP, 1, "No Internet gateways, returning SERVERNOTAVAILABLE.");
		hr = DPNHERR_SERVERNOTAVAILABLE;
	}


	//
	// If the caller wants information on the type of these addresses, return
	// the flags we detected.
	//
	if (pdwAddressTypeFlags != NULL)
	{
		(*pdwAddressTypeFlags) = dwAddressTypeFlags;
	}


	//
	// Return the minimum lease time remaining that we already calculated, if
	// the caller wants it.
	//
	if (pdwLeaseTimeRemaining != NULL)
	{
		(*pdwLeaseTimeRemaining) = dwLeaseTimeRemaining;
	}


#ifdef DBG
	//
	// If the port is unavailable or there aren't any servers, we better not
	// have a lease time.
	//
	if ((hr == DPNHERR_PORTUNAVAILABLE) ||
		(hr == DPNHERR_SERVERNOTAVAILABLE))
	{
		DNASSERT(dwLeaseTimeRemaining == -1);
	}


	//
	// If there aren't any servers, we better not have server flags.
	//
	if (hr == DPNHERR_SERVERNOTAVAILABLE)
	{
		DNASSERT(! (dwAddressTypeFlags & (DPNHADDRESSTYPE_LOCALFIREWALL | DPNHADDRESSTYPE_GATEWAY)));
	}
#endif // DBG


	DPFX(DPFPREP, 5, "Registered port 0x%p addr type flags = 0x%lx, lease time remaining = %i.",
		pRegisteredPort, dwAddressTypeFlags, (int) dwLeaseTimeRemaining);


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpPAST::GetRegisteredAddresses





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::DeregisterPorts"
//=============================================================================
// CNATHelpPAST::DeregisterPorts
//-----------------------------------------------------------------------------
//
// Description:    Removes the lease record for the port group and informs the
//				Internet gateway server that the binding is no longer needed.
//				The port mapping handle must not be used after de-registering
//				it.
//
// Arguments:
//	DPNHHANDLE hRegisteredPorts		- Handle for a specific binding returned by
//										RegisterPorts.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The binding was successfully released.
//	DPNHERR_GENERIC			- An error occurred that prevented the
//								de-registration of the ports.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory to de-register.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpPAST::DeregisterPorts(const DPNHHANDLE hRegisteredPorts,
											const DWORD dwFlags)
{
	HRESULT				hr;
	CRegisteredPort *	pRegisteredPort;
	BOOL				fHaveLock = FALSE;
	LONG				lResult;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx)",
		this, hRegisteredPorts, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	pRegisteredPort = (CRegisteredPort*) hRegisteredPorts;
	if (! pRegisteredPort->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid registered port mapping handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// If this isn't the last user reference on the registered port, don't
	// unmap it yet.
	//
	lResult = pRegisteredPort->DecUserRef();
	if (lResult != 0)
	{
		DPFX(DPFPREP, 1, "Still %i references left on registered port 0x%p, not unmapping.",
			lResult, pRegisteredPort);
		goto Exit;
	}


	//
	// First, unmap from remote PAST server, if necessary.
	//
	if (pRegisteredPort->GetPASTBindID(TRUE) != 0)
	{
		DNASSERT(pRegisteredPort->GetOwningDevice() != NULL);


		//
		// Free the port.
		//
		hr = this->FreePASTPort(pRegisteredPort, TRUE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't free port mapping with remote PAST server (0x%lx)!  Ignoring.", hr);

			//
			// We'll treat this as non-fatal, but we have to dump the server.
			//
			this->ClearDevicesPASTServer(pRegisteredPort->GetOwningDevice(), TRUE);
			hr = DPNH_OK;
		}
	}


	//
	// Then unmap from local PAST server, if necessary.
	//
	if (pRegisteredPort->GetPASTBindID(FALSE) != 0)
	{
		DNASSERT(pRegisteredPort->GetOwningDevice() != NULL);


		//
		// Free the port.
		//
		hr = this->FreePASTPort(pRegisteredPort, FALSE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't free port mapping with local PAST server (0x%lx)!  Ignoring.", hr);

			//
			// We'll treat this as non-fatal, but we have to dump the server.
			//
			this->ClearDevicesPASTServer(pRegisteredPort->GetOwningDevice(), FALSE);
			hr = DPNH_OK;
		}
	}


	//
	// Pull the item out of the lists.
	// We have the appropriate lock.
	//

	pRegisteredPort->m_blGlobalList.RemoveFromList();

	if (pRegisteredPort->GetOwningDevice() != NULL)
	{
		pRegisteredPort->ClearDeviceOwner();
	}
	else
	{
		DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
		pRegisteredPort->m_blDeviceList.RemoveFromList();
	}

	pRegisteredPort->ClearPrivateAddresses();
	delete pRegisteredPort;


Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::DeregisterPorts





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::QueryAddress"
//=============================================================================
// CNATHelpPAST::QueryAddress
//-----------------------------------------------------------------------------
//
// Description:    Some Internet gateways do not loopback if an attempt is made
//				to connect to an address behind (on the same private side of)
//				the public interface.  QueryAddress is used to determine a
//				possible private alias for a given public address.
//
//				   In most cases, this function is called prior to connecting
//				to a new address.  pSourceAddress should contain the address of
//				the socket that will perform the connect.  Similar to
//				RegisterPorts, the address may be INADDR_ANY, in which case the
//				"best" server will be used.  Since the server chosen may not be
//				optimal for a particular application, it is recommended that a
//				specific network interface be used instead of INADDR_ANY, when
//				possible.
//
//				   If no mapping for that address has been made by the gateway,
//				the error code DPNHERR_NOMAPPING is returned.  When the
//				DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED flag is used, an
//				extra effort is made to determine whether the address is behind
//				the same Internet gateway without being mapped on the gateway.
//				If that is the case, DPNHERR_NOMAPPINGBUTPRIVATE is returned.
//				DPNHERR_NOMAPPING is still returned for addresses that are
//				neither mapped nor private.
//
//				   pQueryAddress may not be INADDR_ANY or INADDR_BROADCAST.
//				The port component may be zero if and only if the
//				DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED flag is used.  If
//				the port is zero, a specific mapping cannot be verified, and
//				only the DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED aspect of
//				the address is tested.
//
//				   The resulting address (or lack thereof) can be cached for
//				quick future retrieval using the DPNHQUERYADDRESS_CACHEFOUND
//				and DPNHQUERYADDRESS_CACHENOTFOUND flags.  The cached mappings
//				will expire in 1 minute, or whenever the server's address
//				changes.
//
//				   If the given source address is not currently connected to an
//				Internet gateway, then the error DPNHERR_SERVERNOTAVAILABLE is
//				returned.
//
//				   If GetCaps has not been previously called with the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag at least once, then the
//				error code DPNHERR_UPDATESERVERSTATUS is returned.
//
// Arguments:
//	SOCKADDR * pSourceAddress	- Address for network interface that is using
//									the address in question.
//	SOCKADDR * pQueryAddress	- Address to look up.
//	SOCKADDR * pResponseAddress	- Place to store public address, if one exists.
//	int iAddressesSize			- Size of the SOCKADDR structure used for the
//									pSourceAddress, pQueryAddress and
//									pResponseAddress buffers.
//	DWORD dwFlags				- Flags to use when querying
//									(DPNHQUERYADDRESS_xxx).
//
// Returns: HRESULT
//	DPNH_OK						- The address was found and its mapping was
//									stored in pResponseAddress.
//	DPNHERR_GENERIC				- An error occurred that prevented mapping the
//									requested address.
//	DPNHERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT		- The interface object is invalid.
//	DPNHERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER		- An invalid pointer was specified.
//	DPNHERR_NOMAPPING			- The server indicated that no mapping for the
//									requested address was found.
//	DPNHERR_NOMAPPINGBUTPRIVATE	- The server indicated that no mapping was
//									found, but it is a private address.
//	DPNHERR_NOTINITIALIZED		- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY			- There is not enough memory to query.
//	DPNHERR_REENTRANT			- The interface has been re-entered on the same
//									thread.
//	DPNHERR_SERVERNOTAVAILABLE	- There are no servers to query.
//	DPNHERR_UPDATESERVERSTATUS	- GetCaps has not been called with the
//									DPNHGETCAPS_UPDATESERVERSTATUS flag yet.
//=============================================================================
STDMETHODIMP CNATHelpPAST::QueryAddress(const SOCKADDR * const pSourceAddress,
										const SOCKADDR * const pQueryAddress,
										SOCKADDR * const pResponseAddress,
										const int iAddressesSize,
										const DWORD dwFlags)
{
	HRESULT			hr;
	HRESULT			temphr;
	BOOL			fHaveLock = FALSE;
	CDevice *		pDevice;
	SOCKADDR_IN *	psaddrinNextServerQueryAddress = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, %i, 0x%lx)",
		this, pSourceAddress, pQueryAddress, pResponseAddress, iAddressesSize,
		dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (pSourceAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid source address specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pQueryAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid query address specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pResponseAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid response address specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (iAddressesSize < sizeof(SOCKADDR_IN))
	{
		DPFX(DPFPREP, 0, "The address buffers must be at least %i bytes!",
			sizeof(SOCKADDR_IN));
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (IsBadReadPtr(pSourceAddress, sizeof(SOCKADDR_IN)))
	{
		DPFX(DPFPREP, 0, "Invalid source address buffer used!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (IsBadReadPtr(pQueryAddress, sizeof(SOCKADDR_IN)))
	{
		DPFX(DPFPREP, 0, "Invalid query address buffer used!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (IsBadWritePtr(pResponseAddress, sizeof(SOCKADDR_IN)))
	{
		DPFX(DPFPREP, 0, "Invalid response address buffer used!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if ((((SOCKADDR_IN*) pSourceAddress)->sin_family != AF_INET) ||
		(((SOCKADDR_IN*) pQueryAddress)->sin_family != AF_INET))
	{
		DPFX(DPFPREP, 0, "Source or query address is not AF_INET, only IPv4 addresses are supported!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_addr == INADDR_BROADCAST)
	{
		DPFX(DPFPREP, 0, "Source address cannot be broadcast address!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if ((((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_addr == INADDR_ANY) ||
		(((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_addr == INADDR_BROADCAST))
	{
		//
		// Don't use inet_ntoa because we may not be initialized yet.
		//
		DPFX(DPFPREP, 0, "Query address (%u.%u.%u.%u) is invalid, cannot be zero or broadcast!",
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b4);
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags & ~(DPNHQUERYADDRESS_TCP | DPNHQUERYADDRESS_CACHEFOUND | DPNHQUERYADDRESS_CACHENOTFOUND | DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED))
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}

	if ((((SOCKADDR_IN*) pQueryAddress)->sin_port == 0) &&
		(! (dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED)))
	{
		DPFX(DPFPREP, 0, "Query address port cannot be zero unless CHECKFORPRIVATEBUTUNMAPPED is specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwLastUpdateServerStatusTime == 0)
	{
		DPFX(DPFPREP, 0, "GetCaps has not been called with UPDATESERVERSTATUS flag yet!");
		hr = DPNHERR_UPDATESERVERSTATUS;
		goto Failure;
	}


	pDevice = this->FindMatchingDevice((SOCKADDR_IN*) pSourceAddress, TRUE);
	if (pDevice == NULL)
	{
		DPFX(DPFPREP, 1, "Couldn't determine appropriate owning device for given source address, returning SERVERNOTAVAILABLE.");
		hr = DPNHERR_SERVERNOTAVAILABLE;
		goto Exit;
	}


	//
	// Assume no servers are available.  This will get overridden as
	// appropriate.
	//
	hr = DPNHERR_SERVERNOTAVAILABLE;


	//
	// Start by querying the address passed in.
	//
	psaddrinNextServerQueryAddress = (SOCKADDR_IN*) pQueryAddress;


	//
	// If the port is zero, then we can't actually lookup a mapping.  Just do
	// the address locality check.
	//
	if (psaddrinNextServerQueryAddress->sin_port == 0)
	{
		//
		// We should have caught this in parameter validation above, but I'm
		// being paranoid.
		//
		DNASSERT(dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED);


		//
		// We don't cache these results, since there's no server (and thus, no
		// network traffic) associated with it.  No need to look anything up.
		//


		//
		// If there aren't any servers, then no need to check.
		//
		if ((pDevice->GetPASTClientID(TRUE) == 0) &&
			(pDevice->GetPASTClientID(FALSE) == 0))
		{
			DPFX(DPFPREP, 5, "No port queried and there aren't any gateways, returning SERVERNOTAVAILABLE.");
			hr = DPNHERR_SERVERNOTAVAILABLE;
		}
		else
		{
			//
			// There is an Internet gateway of some kind, our locality check
			// would be meaningful.
			//
			if (this->IsAddressLocal(pDevice, psaddrinNextServerQueryAddress))
			{
				DPFX(DPFPREP, 5, "No port queried, but address appears to be local, returning NOMAPPINGBUTPRIVATE.");
				hr = DPNHERR_NOMAPPINGBUTPRIVATE;
			}
			else
			{
				DPFX(DPFPREP, 5, "No port queried and address does not appear to be local, returning NOMAPPING.");
				hr = DPNHERR_NOMAPPING;
			}
		}


		//
		// We've done all we can do.
		//
		goto Exit;
	}


	//
	// First try to query the remote PAST server, if there is one.
	//
	if (pDevice->GetPASTClientID(TRUE) != 0)
	{
		DNASSERT(pDevice->GetPASTSocket() != INVALID_SOCKET);

		hr = this->InternalPASTQueryAddress(pDevice,
											psaddrinNextServerQueryAddress,
											(SOCKADDR_IN*) pResponseAddress,
											dwFlags,
											TRUE);
		switch (hr)
		{
			case DPNH_OK:
			{
				//
				// If there is a local PAST server, we want to query it for the
				// public address we were just returned.  This technically
				// would allow us to chain more than one level of Internet
				// gateways, however it really won't work.  I'm just doing it
				// because it doesn't hurt.
				//
				// Handing the same buffer to InternalPASTQueryAddress for both
				// the query and response addresses is okay.
				//
				psaddrinNextServerQueryAddress = (SOCKADDR_IN*) pResponseAddress;
				break;
			}

			case DPNHERR_NOMAPPING:
			{
				//
				// There's no mapping, continue to the local PAST server query.
				//
				break;
			}

			case DPNHERR_NOMAPPINGBUTPRIVATE:
			{
				//
				// There's no mapping although the address is private, continue
				// to the local PAST server query.
				//
				break;
			}

			case DPNHERR_SERVERNOTRESPONDING:
			{
				//
				// The server stopped responding, but treat that as non-fatal.
				// It will be detected properly the next time GetCaps is
				// called.  We set the return code to DPNHERR_NOMAPPING in case
				// there is no local PAST server to override the value.
				//
				DPFX(DPFPREP, 1, "Remote PAST server stopped responding while querying port mapping.");
				hr = DPNHERR_NOMAPPING;

				//
				// Continue through to querying the local server.
				//
				break;
			}

			default:
			{
				DPFX(DPFPREP, 0, "Querying remote PAST server for port mapping failed!");
				goto Failure;
				break;
			}
		}
	}
	else
	{
		//
		// No remote PAST server.
		//
	}


	//
	// Then try to query the local PAST server, if there is one.
	//
	if (pDevice->GetPASTClientID(FALSE) != 0)
	{
		DNASSERT(pDevice->GetPASTSocket() != INVALID_SOCKET);

		temphr = this->InternalPASTQueryAddress(pDevice,
												psaddrinNextServerQueryAddress,
												(SOCKADDR_IN*) pResponseAddress,
												dwFlags,
												FALSE);
		switch (temphr)
		{
			case DPNH_OK:
			{
				//
				// Success!
				//
				hr = DPNH_OK;
				break;
			}

			case DPNHERR_NOMAPPING:
			{
				//
				// There's no mapping.  Overwrite the return value if we didn't
				// have a remote PAST server to query.
				//
				if (hr == DPNHERR_SERVERNOTAVAILABLE)
				{
					hr = DPNHERR_NOMAPPING;
				}
				break;
			}

			case DPNHERR_NOMAPPINGBUTPRIVATE:
			{
				//
				// There's no mapping although the address is private.
				// Overwrite the return value if we didn't have a remote PAST
				// server to query.
				//
				if (hr == DPNHERR_SERVERNOTAVAILABLE)
				{
					hr = DPNHERR_NOMAPPINGBUTPRIVATE;
				}
				break;
			}

			case DPNHERR_SERVERNOTRESPONDING:
			{
				//
				// The server stopped responding, but treat that as non-fatal.
				// It will be detected properly the next time GetCaps is
				// called.
				//
				DPFX(DPFPREP, 1, "Local PAST server stopped responding while querying port mapping.");
				

				//
				// Overwrite the return value if we didn't have a remote PAST
				// server to query.
				//
				if (hr == DPNHERR_SERVERNOTAVAILABLE)
				{
					hr = DPNHERR_NOMAPPING;
				}
				break;
			}

			default:
			{
				DPFX(DPFPREP, 0, "Querying local PAST server for port mapping failed!");
				goto Failure;
				break;
			}
		}
	}
	else
	{
		//
		// No local PAST server.
		//
	}


	//
	// If we got here with hr still set to SERVERNOTAVAILABLE, that means
	// there weren't any servers.  The error code is appropriate, leave it
	// alone.
	//
#ifdef DBG
	if (hr == DPNHERR_SERVERNOTAVAILABLE)
	{
		DPFX(DPFPREP, 1, "No Internet gateways, unable to query port mapping.");
	}
#endif // DBG
	



Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::QueryAddress





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::SetAlertEvent"
//=============================================================================
// CNATHelpPAST::SetAlertEvent
//-----------------------------------------------------------------------------
//
// Description:    This function allows the user to specify an event that will
//				be set when some maintenance needs to be performed.  The user
//				should call GetCaps using the DPNHGETCAPS_UPDATESERVERSTATUS
//				flag when the event is signalled.
//
//				   This function is not available on Windows 95 without WinSock
//				2, may only be called once, and cannot be used after
//				SetAlertIOCompletionPort is called.
//
//					Note that the event is used in addition to the regular
//				polling of GetCaps, it simply allows the polling to be less
//				frequent.
//
// Arguments:
//	HANDLE hEvent	- Handle to event to signal when GetCaps is to be called.
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The event was successfully registered.
//	DPNHERR_GENERIC			- An error occurred that prevented registering the
//								event.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpPAST::SetAlertEvent(const HANDLE hEvent,
										const DWORD dwFlags)
{
	HRESULT		hr;
	BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx)", this, hEvent, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (hEvent == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid event handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwFlags & NATHELPPASTOBJ_WINSOCK1)
	{
		DPFX(DPFPREP, 0, "Cannot use alert mechanism on WinSock 1!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if ((this->m_hAlertEvent != NULL) || (this->m_hAlertIOCompletionPort != NULL))
	{
		DPFX(DPFPREP, 0, "An alert event or I/O completion port has already been set!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Now save the event handle.
	//
	if (! DuplicateHandle(GetCurrentProcess(),
						hEvent,
						GetCurrentProcess(),
						&this->m_hAlertEvent,
						0,
						FALSE,
						DUPLICATE_SAME_ACCESS))
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't duplicate event (error = %u)!", dwError);
#endif // DBG

		DNASSERT(this->m_hAlertEvent == NULL);

		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}


	//
	// Create overlapped structure.  Don't allocate it through DNMalloc,
	// because we may have to leak it on purpose.  We don't want those memory
	// allocation asserts firing in that case.
	//
	this->m_polAddressListChange = (WSAOVERLAPPED*) HeapAlloc(GetProcessHeap(),
															HEAP_ZERO_MEMORY,
															sizeof(WSAOVERLAPPED));
	if (this->m_polAddressListChange == NULL)
	{
		//
		// Close the alert handle we set.
		//
		CloseHandle(this->m_hAlertEvent);
		this->m_hAlertEvent = NULL;

		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Save the event in the address list change overlapped structure.
	//
	this->m_polAddressListChange->hEvent = this->m_hAlertEvent;


	//
	// Start getting notified of local address changes.
	//
	hr = this->RequestLocalAddressListChangeNotification();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");

		//
		// Free the memory we allocated.
		//
		HeapFree(GetProcessHeap(), 0, this->m_polAddressListChange);
		this->m_polAddressListChange = NULL;

		//
		// Close the alert handle we set.
		//
		CloseHandle(this->m_hAlertEvent);
		this->m_hAlertEvent = NULL;

		goto Failure;
	}


Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::SetAlertEvent






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::SetAlertIOCompletionPort"
//=============================================================================
// CNATHelpPAST::SetAlertIOCompletionPort
//-----------------------------------------------------------------------------
//
// Description:    This function allows the user to specify an I/O completion
//				port that will receive notification when some maintenance needs
//				to be performed.  The user should call GetCaps using the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag when the packet with the
//				given completion key is dequeued.
//
//				   This function is only available on Windows NT, may only be
//				called once, and cannot be used after SetAlertEvent is called.
//
//					Note that the completion port is used in addition to the
//				regular polling of GetCaps, it simply allows the polling to be
//				less frequent.
//
// Arguments:
//	HANDLE hIOCompletionPort		- Handle to I/O completion port which will
//										be used to signal when GetCaps is to be
//										called.
//	DWORD dwCompletionKey			- Key to use when indicating I/O
//										completion.
//	DWORD dwNumConcurrentThreads	- Number of concurrent threads allowed to
//										process, or zero for default.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The I/O completion port was successfully
//								registered.
//	DPNHERR_GENERIC			- An error occurred that prevented registering the
//								I/O completion port.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpPAST::SetAlertIOCompletionPort(const HANDLE hIOCompletionPort,
													const DWORD dwCompletionKey,
													const DWORD dwNumConcurrentThreads,
													const DWORD dwFlags)
{
	HRESULT		hr;
	BOOL		fHaveLock = FALSE;
	HANDLE		hIOCompletionPortResult;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx, %u, 0x%lx)",
		this, hIOCompletionPort, dwCompletionKey, dwNumConcurrentThreads, dwFlags);



	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (hIOCompletionPort == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid I/O completion port handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwFlags & NATHELPPASTOBJ_WINSOCK1)
	{
		DPFX(DPFPREP, 0, "Cannot use alert mechanism on WinSock 1!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if ((this->m_hAlertEvent != NULL) || (this->m_hAlertIOCompletionPort != NULL))
	{
		DPFX(DPFPREP, 0, "An alert event or I/O completion port has already been set!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Now save the I/O completion port handle.
	//
	if (! DuplicateHandle(GetCurrentProcess(),
						hIOCompletionPort,
						GetCurrentProcess(),
						&this->m_hAlertIOCompletionPort,
						0,
						FALSE,
						DUPLICATE_SAME_ACCESS))
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't duplicate I/O completion port (error = %u)!", dwError);
#endif // DBG

		DNASSERT(this->m_hAlertIOCompletionPort == NULL);

		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	this->m_dwAlertCompletionKey = dwCompletionKey;


	//
	// Associate our Ioctl socket with this IO completion port.
	//
	DNASSERT(this->m_sIoctls != INVALID_SOCKET);
	hIOCompletionPortResult = CreateIoCompletionPort((HANDLE) this->m_sIoctls,
													this->m_hAlertIOCompletionPort,
													dwCompletionKey,
													dwNumConcurrentThreads);
	if (hIOCompletionPortResult == NULL)
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't associate I/O completion port with Ioctl socket (error = %u)!", dwError);
#endif // DBG

		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	//
	// We should have just gotten the same I/O completion port back.
	//
	DNASSERT(hIOCompletionPortResult == this->m_hAlertIOCompletionPort);


	//
	// Create overlapped structure.  Don't allocate it through DNMalloc,
	// because we may have to leak it on purpose.  We don't want those memory
	// allocation asserts firing in that case.
	//
	this->m_polAddressListChange = (WSAOVERLAPPED*) HeapAlloc(GetProcessHeap(),
															HEAP_ZERO_MEMORY,
															sizeof(WSAOVERLAPPED));
	if (this->m_polAddressListChange == NULL)
	{
		//
		// Close the alert IOCP we set.
		//
		CloseHandle(this->m_hAlertIOCompletionPort);
		this->m_hAlertIOCompletionPort = NULL;

		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Start getting notified of local address changes.
	//
	hr = this->RequestLocalAddressListChangeNotification();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");

		//
		// Free the memory we allocated.
		//
		HeapFree(GetProcessHeap(), 0, this->m_polAddressListChange);
		this->m_polAddressListChange = NULL;

		//
		// Close the alert IOCP we set.
		//
		CloseHandle(this->m_hAlertIOCompletionPort);
		this->m_hAlertIOCompletionPort = NULL;

		goto Failure;
	}



Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::SetAlertIOCompletionPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::ExtendRegisteredPortsLease"
//=============================================================================
// CNATHelpPAST::ExtendRegisteredPortsLease
//-----------------------------------------------------------------------------
//
// Description:    Manually extends the lease of the given registered port
//				mapping by the requested time.  The periodic calling of GetCaps
//				can take care of this for the user, this function is only
//				necessary to change the lease extension time or for finer
//				control of individual mappings.
//
//				   The user should specify a requested lease extension time
//				that the server will attempt to honor.  It will be added to any
//				time remaining in the existing lease, and the new total can be
//				retrieved by calling GetRegisteredAddresses.
//
// Arguments:
//	DPNHHANDLE hRegisteredPorts		- Handle for a specific binding returned by
//										RegisterPorts.
//	DWORD dwLeaseTime				- Requested time, in milliseconds, to
//										extend the lease.  If 0, the previous
//										requested lease time is used.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The lease was successfully extended.
//	DPNHERR_GENERIC			- An error occurred that prevented the extending
//								the lease.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory to extend the lease.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpPAST::ExtendRegisteredPortsLease(const DPNHHANDLE hRegisteredPorts,
													const DWORD dwLeaseTime,
													const DWORD dwFlags)
{
	HRESULT				hr;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;
	BOOL				fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, %u, 0x%lx)",
		this, hRegisteredPorts, dwLeaseTime, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	pRegisteredPort = (CRegisteredPort*) hRegisteredPorts;
	if (! pRegisteredPort->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid registered port mapping handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// If they wanted to change the lease time, update it.
	//
	if (dwLeaseTime != 0)
	{
		pRegisteredPort->UpdateRequestedLeaseTime(dwLeaseTime);
	}

	
	pDevice = pRegisteredPort->GetOwningDevice();

	
	//
	// If the ports are mapped on a remote PAST servers, extend that lease.
	//
	if (pRegisteredPort->GetPASTBindID(TRUE) != 0)
	{
		DNASSERT(pDevice != NULL);


		hr = this->ExtendPASTLease(pRegisteredPort, TRUE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't extend port mapping lease on remote PAST server (0x%lx)!  Ignoring.", hr);

			//
			// We'll treat this as non-fatal, but we have to dump the server.
			//
			this->ClearDevicesPASTServer(pDevice, TRUE);
			hr = DPNH_OK;
		}
	}
	else
	{
		DPFX(DPFPREP, 2, "Port mapping not registered with remote PAST server.");
	}


	//
	// Next extend the mappings on the local PAST server, if possible.
	//
	if (pRegisteredPort->GetPASTBindID(FALSE) != 0)
	{
		DNASSERT(pDevice != NULL);


		hr = this->ExtendPASTLease(pRegisteredPort, FALSE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't extend port mapping lease on local PAST server (0x%lx)!  Ignoring.", hr);

			//
			// We'll treat this as non-fatal, but we have to dump the server.
			//
			this->ClearDevicesPASTServer(pDevice, FALSE);
			hr = DPNH_OK;
		}
	}
	else
	{
		DPFX(DPFPREP, 2, "Port mapping not registered with local PAST server.");
	}


	this->DropLock();
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpPAST::ExtendRegisteredPortsLease






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::InitializeObject"
//=============================================================================
// CNATHelpPAST::InitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Sets up the object for use like the constructor, but may
//				fail with OUTOFMEMORY.  Should only be called by class factory
//				creation routine.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK			- Initialization was successful.
//	E_OUTOFMEMORY	- There is not enough memory to initialize.
//=============================================================================
HRESULT CNATHelpPAST::InitializeObject(void)
{
	HRESULT		hr;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);

	DNASSERT(this->IsValidObject());


	//
	// Create the lock.
	// 

	if (! DNInitializeCriticalSection(&this->m_csLock))
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);


	hr = S_OK;

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::InitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::UninitializeObject"
//=============================================================================
// CNATHelpPAST::UninitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the object like the destructor, mostly to balance
//				InitializeObject.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpPAST::UninitializeObject(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->IsValidObject());


	DNDeleteCriticalSection(&this->m_csLock);


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CNATHelpPAST::UninitializeObject




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::TakeLock"
//=============================================================================
// CNATHelpPAST::TakeLock
//-----------------------------------------------------------------------------
//
// Description:    Takes the main object lock.
//
// Arguments: None.
//
// Returns: DPNH_OK if lock was taken successfully, DPNHERR_REENTRANT if lock
//			was re-entered.
//=============================================================================
HRESULT CNATHelpPAST::TakeLock(void)
{
	HRESULT		hr = DPNH_OK;
#ifdef DBG
	DWORD		dwStartTime;


	dwStartTime = timeGetTime();
#endif // DBG


	DNEnterCriticalSection(&this->m_csLock);


	//
	// If this same thread is already holding the lock, then bail.
	//
	if (this->m_dwLockThreadID == GetCurrentThreadId())
	{
		DPFX(DPFPREP, 0, "Thread re-entering!");
		goto Failure;
	}


#ifdef DBG
	DPFX(DPFPREP, 8, "Took main object lock, elapsed time = %u ms.",
		(timeGetTime() - dwStartTime));
#endif // DBG

	//
	// Save this thread's ID so we know who's holding the lock.
	//
	this->m_dwLockThreadID = GetCurrentThreadId();


Exit:

	return hr;


Failure:

	//
	// We're reentering.  Drop the lock and return the failure.
	//
	DNLeaveCriticalSection(&this->m_csLock);

	hr = DPNHERR_REENTRANT;

	goto Exit;
} // CNATHelpPAST::TakeLock




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::DropLock"
//=============================================================================
// CNATHelpPAST::DropLock
//-----------------------------------------------------------------------------
//
// Description:    Drops the main object lock.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpPAST::DropLock(void)
{
	DNASSERT(this->m_dwLockThreadID == GetCurrentThreadId());

	this->m_dwLockThreadID = 0;
	DNLeaveCriticalSection(&this->m_csLock);

	DPFX(DPFPREP, 8, "Dropped main object lock.");
} // CNATHelpPAST::DropLock




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::LoadWinSockFunctionPointers"
//=============================================================================
// CNATHelpPAST::LoadWinSockFunctionPointers
//-----------------------------------------------------------------------------
//
// Description:    Loads pointers to all the functions that we use in WinSock.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK			- Loading was successful.
//	DPNHERR_GENERIC	- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::LoadWinSockFunctionPointers(void)
{
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#ifdef DBG

#define PRINTERRORIFDEBUG(name)						\
	{\
		dwError = GetLastError();\
		DPFX(DPFPREP, 0, "Couldn't get \"%hs\" function!  0x%lx", name, dwError);\
	}

#else

#define PRINTERRORIFDEBUG(name)

#endif // DBG


#define LOADWINSOCKFUNCTION(var, proctype, name)	\
	{\
		var = (##proctype) GetProcAddress(this->m_hWinSockDLL, name);\
		if (var == NULL)\
		{\
			PRINTERRORIFDEBUG(name);\
			hr = DPNHERR_GENERIC;\
			goto Failure;\
		}\
	}

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	HRESULT		hr = DPNH_OK;
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	LOADWINSOCKFUNCTION(this->m_pfnWSAStartup,				LPFN_WSASTARTUP,				"WSAStartup");
	LOADWINSOCKFUNCTION(this->m_pfnWSACleanup,				LPFN_WSACLEANUP,				"WSACleanup");
	LOADWINSOCKFUNCTION(this->m_pfnWSAGetLastError,			LPFN_WSAGETLASTERROR,			"WSAGetLastError");
	LOADWINSOCKFUNCTION(this->m_pfnsocket,					LPFN_SOCKET,					"socket");
	LOADWINSOCKFUNCTION(this->m_pfnclosesocket,				LPFN_CLOSESOCKET,				"closesocket");
	LOADWINSOCKFUNCTION(this->m_pfnbind,					LPFN_BIND,						"bind");
	LOADWINSOCKFUNCTION(this->m_pfnsetsockopt,				LPFN_SETSOCKOPT,				"setsockopt");
	LOADWINSOCKFUNCTION(this->m_pfngetsockname,				LPFN_GETSOCKNAME,				"getsockname");
	LOADWINSOCKFUNCTION(this->m_pfnselect,					LPFN_SELECT,					"select");
	LOADWINSOCKFUNCTION(this->m_pfn__WSAFDIsSet,			LPFN___WSAFDISSET,				"__WSAFDIsSet");
	LOADWINSOCKFUNCTION(this->m_pfnrecvfrom,				LPFN_RECVFROM,					"recvfrom");
	LOADWINSOCKFUNCTION(this->m_pfnsendto,					LPFN_SENDTO,					"sendto");
	LOADWINSOCKFUNCTION(this->m_pfngethostname,				LPFN_GETHOSTNAME,				"gethostname");
	LOADWINSOCKFUNCTION(this->m_pfngethostbyname,			LPFN_GETHOSTBYNAME,				"gethostbyname");
	LOADWINSOCKFUNCTION(this->m_pfninet_addr,				LPFN_INET_ADDR,					"inet_addr");

	if (! (this->m_dwFlags & NATHELPPASTOBJ_WINSOCK1))
	{
		LOADWINSOCKFUNCTION(this->m_pfnWSASocketA,				LPFN_WSASOCKETA,				"WSASocketA");
		LOADWINSOCKFUNCTION(this->m_pfnWSAIoctl,				LPFN_WSAIOCTL,					"WSAIoctl");
		LOADWINSOCKFUNCTION(this->m_pfnWSAGetOverlappedResult,	LPFN_WSAGETOVERLAPPEDRESULT,	"WSAGetOverlappedResult");
	}


Exit:

	return hr;


Failure:

	hr = DPNHERR_GENERIC;

	goto Exit;
} // CNATHelpPAST::LoadWinSockFunctionPointers




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::CheckForNewDevices"
//=============================================================================
// CNATHelpPAST::CheckForNewDevices
//-----------------------------------------------------------------------------
//
// Description:    Detects new IP capable devices that have been added and
//				removes old ones no longer available.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	BOOL * pfFoundNewDevices	Pointer to boolean to set to TRUE if new
//								devices were added, or NULL if don't care.
//
// Returns: HRESULT
//	DPNH_OK				- The check was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::CheckForNewDevices(BOOL * const pfFoundNewDevices)
{
	HRESULT				hr = DPNH_OK;
	DWORD				dwError;
	int					iReturn;
	char				szName[1000];
	PHOSTENT			phostent;
	IN_ADDR **			ppinaddr;
	DWORD				dwAddressesSize = 0;
	DWORD				dwNumAddresses = 0;
	IN_ADDR *			painaddrAddresses = NULL;
	CBilink *			pBilinkDevice;
	CDevice *			pDevice = NULL; // NULL it for PREfix, even though fDeviceCreated guards it
	BOOL				fDeviceCreated = FALSE;
	BOOL				fFound;
	CBilink *			pBilinkRegPort;
	CRegisteredPort *	pRegisteredPort;
	SOCKET				sTemp = INVALID_SOCKET;
	SOCKADDR_IN			saddrinTemp;
	//int					iAddressSize;
	BOOL				fTemp;
	DWORD				dwTemp;
	SOCKET_ADDRESS *	paSocketAddresses;



	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	//
	// Handle any address list change Ioctl completions that may have gotten us
	// here.
	//
	if ((this->m_hAlertEvent != NULL) ||
		(this->m_hAlertIOCompletionPort != NULL))
	{
		DNASSERT(this->m_sIoctls != INVALID_SOCKET);
		DNASSERT(this->m_polAddressListChange != NULL);

		if (this->m_pfnWSAGetOverlappedResult(this->m_sIoctls,					//
												this->m_polAddressListChange,	//
												&dwTemp,						// ignore bytes transferred
												FALSE,							// don't wait
												&dwTemp))						// ignore flags
		{
			DPFX(DPFPREP, 1, "Received address list change notification.");
			

			//
			// Overlapped result completed.  Reissue it.
			//
			hr = this->RequestLocalAddressListChangeNotification();
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");
				goto Failure;
			}
		}
		else
		{
			//
			// Figure out what error it was.
			//
			dwError = this->m_pfnWSAGetLastError();
			switch (dwError)
			{
				case WSA_IO_INCOMPLETE:
				{
					//
					// It hasn't completed yet.
					//
					break;
				}

				case ERROR_OPERATION_ABORTED:
				{
					//
					// The thread that we originally submitted the Ioctl on
					// went away and so the OS kindly cancelled the operation
					// on us.  How nice.  Well, let's try resubmitting it.
					//

					DPFX(DPFPREP, 1, "Thread that submitted previous address list change notification went away, rerequesting.");
					
					hr = this->RequestLocalAddressListChangeNotification();
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");
						goto Failure;
					}
					break;
				}
			
				default:
				{
					DPFX(DPFPREP, 0, "Couldn't get overlapped result, error = %u!  Ignoring.", dwError);
					break;
				}
			} // end switch (on error)
		}
	}


	//
	// If we're on WinSock 2, let's try getting the address list with
	// an Ioctl.
	//
	if (! (this->m_dwFlags & NATHELPPASTOBJ_WINSOCK1))
	{
		DNASSERT(this->m_sIoctls != INVALID_SOCKET);
		DNASSERT(this->m_pfnWSAIoctl != NULL);

		//
		// Keep trying to get the address list until we have a large enough
		// buffer.  We use the IN_ADDR array pointer simply because it's
		// already there.  We know that IN_ADDRs are smaller than
		// SOCKET_ADDRESSes, so we can reuse the same buffer.
		//
		do
		{
			iReturn = this->m_pfnWSAIoctl(this->m_sIoctls,			// use the special Ioctl socket
										SIO_ADDRESS_LIST_QUERY,		//
										NULL,						// no input data
										0,							// no input data
										painaddrAddresses,			// output buffer
										dwAddressesSize,			// output buffer size
										&dwTemp,					// bytes needed
										NULL,						// no overlapped structure
										NULL);						// no completion routine

			if (iReturn != 0)
			{
				dwError = this->m_pfnWSAGetLastError();

				//
				// Free the previous buffer, no matter what error it was.
				//
				if (painaddrAddresses != NULL)
				{
					DNFree(painaddrAddresses);
					painaddrAddresses = NULL;
				}
				
				if (dwError != WSAEFAULT)
				{
					DPFX(DPFPREP, 0, "Retrieving address list failed (err = %u)!", dwError);

					//
					// We'll try the old-fashioned WinSock 1 way.
					//
					break;
				}


				//
				// Be absolutely sure WinSock isn't causing us trouble.
				//
				if (dwTemp < sizeof(SOCKET_ADDRESS_LIST))
				{
					DPFX(DPFPREP, 0, "Received an invalid buffer size (%u < %u)!",
						dwTemp, sizeof(SOCKET_ADDRESS_LIST));

					//
					// We'll try the old-fashioned WinSock 1 way.
					//
					break;
				}


				//
				// The buffer wasn't large enough.  Try again.
				//
				painaddrAddresses = (IN_ADDR*) DNMalloc(dwTemp);
				if (painaddrAddresses == NULL)
				{
					hr = DPNHERR_OUTOFMEMORY;
					goto Failure;
				}

				dwAddressesSize = dwTemp;
			}
			else
			{
				//
				// Success!  We're going to being sneaky and reuse the buffer.
				// We know that the SOCKET_ADDRESS_LIST returned will be larger
				// than an array of IN_ADDRs, so we can save a malloc.
				//
				// But first, be absolutely sure WinSock isn't causing us
				// trouble.
				//

				if (painaddrAddresses == NULL)
				{
					DPFX(DPFPREP, 0, "WinSock returned success with a NULL buffer!");

					//
					// We'll try the old-fashioned WinSock 1 way.
					//
					break;
				}

				dwNumAddresses = ((SOCKET_ADDRESS_LIST*) painaddrAddresses)->iAddressCount;
				dwAddressesSize = 0;


				//
				// Make sure there are addresses. 
				//
				if (dwNumAddresses > 0)
				{
					DPFX(DPFPREP, 7, "WinSock 2 Ioctl returned %u addresses:", dwNumAddresses);

					paSocketAddresses = ((SOCKET_ADDRESS_LIST*) painaddrAddresses)->Address;
					for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
					{
						DNASSERT(paSocketAddresses[dwTemp].iSockaddrLength == sizeof(SOCKADDR_IN));
						DNASSERT(paSocketAddresses[dwTemp].lpSockaddr != NULL);
						DNASSERT(paSocketAddresses[dwTemp].lpSockaddr->sa_family == AF_INET);

						//
						// Ignore 0.0.0.0 addresses.
						//
						if (((SOCKADDR_IN*) (paSocketAddresses[dwTemp].lpSockaddr))->sin_addr.S_un.S_addr != INADDR_NONE)
						{
							//
							// Move the IN_ADDR component of this address
							// toward the front of the buffer, into it's
							// correct place in the array.
							//
							painaddrAddresses[dwTemp].S_un.S_addr = ((SOCKADDR_IN*) (paSocketAddresses[dwTemp].lpSockaddr))->sin_addr.S_un.S_addr;

							DPFX(DPFPREP, 7, "\t%u- %u.%u.%u.%u",
								dwTemp,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b1,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b2,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b3,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b4);
						}
						else
						{
							DPFX(DPFPREP, 1, "\t%u- Ignoring 0.0.0.0 address.", dwTemp);
							dwAddressesSize++;

							//
							// The code should handle this fine, but why is
							// WinSock doing this to us?
							//
							DNASSERT(FALSE);
						}
					}

					//
					// Subtract out any invalid addresses that we skipped.
					//
					dwNumAddresses -= dwAddressesSize;
					if (dwNumAddresses == 0)
					{
						DPFX(DPFPREP, 1, "WinSock 2 reported only invalid addresses, hoping WinSock 1 method picks up the loopback address.");

						DNFree(painaddrAddresses);
						painaddrAddresses = NULL;
					}
				}
				else
				{
					DPFX(DPFPREP, 1, "WinSock 2 Ioctl did not report any valid addresses, hoping WinSock 1 method picks up the loopback address.");

					DNFree(painaddrAddresses);
					painaddrAddresses = NULL;
				}

				//
				// Get out of the loop.
				//
				break;
			}
		}
		while (TRUE);
	}


	//
	// Get the list of all available addresses from the WinSock 1 API if we
	// don't already have them.
	//
	if (painaddrAddresses == NULL)
	{
		if (this->m_pfngethostname(szName, 1000) != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't get host name, error = %u!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		phostent = this->m_pfngethostbyname(szName);
		if (phostent == NULL)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't retrieve addresses, error = %u!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		//
		// WinSock says that you need to copy this data before you make any
		// other API calls.  So first we count the number of entries we need to
		// copy.
		//
		ppinaddr = (IN_ADDR**) phostent->h_addr_list;
		while ((*ppinaddr) != NULL)
		{
			//
			// Ignore 0.0.0.0 addresses.
			//
			if ((*ppinaddr)->S_un.S_addr != INADDR_NONE)
			{
				dwNumAddresses++;
			}
			else
			{
				DPFX(DPFPREP, 1, "Ignoring 0.0.0.0 address.");

				//
				// The code should handle this fine, but why is WinSock doing
				// this to us?
				//
				DNASSERT(FALSE);
			}

			ppinaddr++;
		}


		//
		// If there aren't any addresses, we must fail.  WinSock 1 ought to
		// report the loopback address at least.
		//
		if (dwNumAddresses == 0)
		{
			DPFX(DPFPREP, 0, "WinSock 1 did not report any valid addresses!");
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		DPFX(DPFPREP, 7, "WinSock 1 method returned %u valid addresses:", dwNumAddresses);

		painaddrAddresses = (IN_ADDR*) DNMalloc(dwNumAddresses * sizeof(IN_ADDR));
		if (painaddrAddresses == NULL)
		{
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}

		//
		// Now copy all the addresses.
		//
		ppinaddr = (IN_ADDR**) phostent->h_addr_list;
		
		dwTemp = 0;
		while ((*ppinaddr) != NULL)
		{
			//
			// Ignore 0.0.0.0 addresses again.
			//
			if ((*ppinaddr)->S_un.S_addr != INADDR_NONE)
			{
				painaddrAddresses[dwTemp].S_un.S_addr = (*ppinaddr)->S_un.S_addr;
				
				DPFX(DPFPREP, 7, "\t%u- %u.%u.%u.%u",
					dwTemp,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b1,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b2,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b3,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b4);

				dwTemp++;
			}

			ppinaddr++;
		}
				
		DNASSERT(dwTemp == dwNumAddresses);
	}
	else
	{
		//
		// Already have addresses array.
		//
	}


	//
	// Make sure that all of the devices we currently know about are still
	// around.
	//
	pBilinkDevice = this->m_blDevices.GetNext();
	while (pBilinkDevice != &this->m_blDevices)
	{
		pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
		pBilinkDevice = pBilinkDevice->GetNext();

		fFound = FALSE;
		for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
		{
			if (painaddrAddresses[dwTemp].S_un.S_addr == pDevice->GetLocalAddressV4())
			{
				fFound = TRUE;
				break;
			}
		}

		if (fFound)
		{
			//
			// It may be time for this device to use a different port...
			//
			dwTemp = pDevice->GetFirstPASTDiscoveryTime();
			if ((dwTemp != 0) && ((GETTIMESTAMP() - dwTemp) > g_dwReusePortTime))
			{
				ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
				saddrinTemp.sin_family				= AF_INET;
				saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();

				sTemp = this->CreatePASTSocket(&saddrinTemp);
				if (sTemp != INVALID_SOCKET)
				{
					//
					// Sanity check that we didn't lose the device address.
					//
					DNASSERT(saddrinTemp.sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4());

					DPFX(DPFPREP, 4, "Device 0x%p PAST socket 0x%p (%u.%u.%u.%u:%u) created to replace existing one.",
						pDevice,
						sTemp,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
						NTOHS(saddrinTemp.sin_port));

					pDevice->SetFirstPASTDiscoveryTime(0);

					//
					// Close the existing socket.
					//
					this->m_pfnclosesocket(pDevice->GetPASTSocket());

					//
					// Transfer ownership of the new socket to the device.
					//
					pDevice->SetPASTSocket(sTemp);
					sTemp = INVALID_SOCKET;

					DPFX(DPFPREP, 8, "Device 0x%p got re-assigned PAST socket 0x%p.",
						pDevice, pDevice->GetPASTSocket());
				}
				else
				{
					DPFX(DPFPREP, 0, "Couldn't create a replacement PAST socket for device 0x%p!  Using existing one.",
						pDevice);
				}
			}
		}
		else
		{
			//
			// Didn't find this device in the returned list, forget about
			// it.
			//
#ifdef DBG
			{
				IN_ADDR		inaddrTemp;


				inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();
				DPFX(DPFPREP, 1, "Device 0x%p no longer exists, removing (address was %u.%u.%u.%u).",
					pDevice,
					inaddrTemp.S_un.S_un_b.s_b1,
					inaddrTemp.S_un.S_un_b.s_b2,
					inaddrTemp.S_un.S_un_b.s_b3,
					inaddrTemp.S_un.S_un_b.s_b4);
			}

			this->m_dwNumDeviceRemoves++;
#endif // DBG


			//
			// Override the minimum UpdateServerStatus interval so that we can
			// get information on any local public address changes due to the
			// possible loss of a server on this interface.
			//
			this->m_dwFlags |= NATHELPPASTOBJ_DEVICECHANGED;

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();


			//
			// Forcefully mark the PAST servers as disconnected.
			//
			if (pDevice->GetPASTClientID(TRUE) != 0)
			{
				this->ClearDevicesPASTServer(pDevice, TRUE);
			}

			if (pDevice->GetPASTClientID(FALSE) != 0)
			{
				this->ClearDevicesPASTServer(pDevice, FALSE);
			}

			//
			// Mark all ports that were registered to this device as unowned
			// by putting them into the wildcard list.
			//
			pBilinkRegPort = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilinkRegPort != &pDevice->m_blOwnedRegPorts)
			{
				pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegPort);
				pBilinkRegPort = pBilinkRegPort->GetNext();

				DPFX(DPFPREP, 1, "Registered port 0x%p's device went away, marking as unowned.",
					pRegisteredPort);

				DNASSERT(pRegisteredPort->GetPASTBindID(TRUE) == 0);
				DNASSERT(pRegisteredPort->GetPASTBindID(FALSE) == 0);

				DNASSERT(! pRegisteredPort->HasPASTPublicAddressesArray(TRUE));
				DNASSERT(! pRegisteredPort->HasPASTPublicAddressesArray(FALSE));

				DNASSERT(! pRegisteredPort->IsPASTPortUnavailable(TRUE));
				DNASSERT(! pRegisteredPort->IsPASTPortUnavailable(FALSE));

				pRegisteredPort->ClearDeviceOwner();
				pRegisteredPort->m_blDeviceList.RemoveFromList();
				pRegisteredPort->m_blDeviceList.InsertBefore(&this->m_blUnownedPorts);

				//
				// The user doesn't directly need to be informed.  If the ports
				// previously had public addresses, the ADDRESSESCHANGED flag
				// would have already been set by ClearDevicesPASTServer. If
				// they didn't have ports with public addresses, then the user
				// won't see any difference and thus ADDRESSESCHANGED wouldn't
				// need to be set.
				//
			}

			pDevice->m_blList.RemoveFromList();


			//
			// Close the sockets.
			//

			this->m_pfnclosesocket(pDevice->GetPASTSocket());
			pDevice->SetPASTSocket(INVALID_SOCKET);


			delete pDevice;
		}
	}


	//
	// Search for all returned devices in our existing list, and add new
	// entries for each one that we didn't already know about.
	//
	for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
	{
		fFound = FALSE;

		pBilinkDevice = this->m_blDevices.GetNext();
		while (pBilinkDevice != &this->m_blDevices)
		{
			pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
			pBilinkDevice = pBilinkDevice->GetNext();

			if (pDevice->GetLocalAddressV4() == painaddrAddresses[dwTemp].S_un.S_addr)
			{
				fFound = TRUE;
				break;
			}
		}

		if (! fFound)
		{
			//
			// We didn't know about this device.  Create a new object.
			//
			pDevice = new CDevice(painaddrAddresses[dwTemp].S_un.S_addr);
			if (pDevice == NULL)
			{
				hr = DPNHERR_OUTOFMEMORY;
				goto Failure;
			}

			fDeviceCreated = TRUE;


#ifdef DBG
			DPFX(DPFPREP, 1, "Found new device %u.%u.%u.%u, (object = 0x%p).",
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b1,
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b2,
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b3,
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b4,
				pDevice);

			this->m_dwNumDeviceAdds++;
#endif // DBG


			//
			// Override the minimum UpdateServerStatus interval so that we can
			// get information on this new device.
			//
			this->m_dwFlags |= NATHELPPASTOBJ_DEVICECHANGED;

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();


			//
			// Create the PAST socket.
			//

			ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
			saddrinTemp.sin_family				= AF_INET;
			saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();

			sTemp = this->CreatePASTSocket(&saddrinTemp);
			if (sTemp == INVALID_SOCKET)
			{
				DPFX(DPFPREP, 0, "Couldn't create PAST socket!  Ignoring address (and destroying device 0x%p).",
					pDevice);

				//
				// Get rid of the device.
				//
				delete pDevice;
				pDevice = NULL;


				//
				// Forget about device in case of failure later.
				//
				fDeviceCreated = FALSE;


				//
				// Move to next address.
				//
				continue;
			}

			//
			// Sanity check that we didn't lose the device address.
			//
			DNASSERT(saddrinTemp.sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4());

			DPFX(DPFPREP, 4, "Device 0x%p PAST socket 0x%p (%u.%u.%u.%u:%u) created.",
				pDevice,
				sTemp,
				saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
				saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
				saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
				saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
				NTOHS(saddrinTemp.sin_port));


			//
			// Transfer ownership of the socket to the device.
			//
			pDevice->SetPASTSocket(sTemp);
			sTemp = INVALID_SOCKET;

			DPFX(DPFPREP, 8, "Device 0x%p got assigned PAST socket 0x%p.",
				pDevice, pDevice->GetPASTSocket());



			//
			// Add the device to our known list.
			//
			pDevice->m_blList.InsertBefore(&this->m_blDevices);


			//
			// Inform the caller if they care.
			//
			if (pfFoundNewDevices != NULL)
			{
				(*pfFoundNewDevices) = TRUE;
			}


			//
			// Forget about device in case of failure later.
			//
			fDeviceCreated = FALSE;
		}
	}


	//
	// If we got some very weird failures and ended up here without any
	// devices, complain to management (or the caller of this function, that's
	// probably more convenient).
	//
	if (this->m_blDevices.IsEmpty())
	{
		DPFX(DPFPREP, 0, "No usable devices, cannot proceed!", 0);
		DNASSERTX(! "No usable devices!", 2);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


Exit:

	if (painaddrAddresses != NULL)
	{
		DNFree(painaddrAddresses);
		painaddrAddresses = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (sTemp != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(sTemp);
		sTemp = INVALID_SOCKET;
	}

	if (fDeviceCreated)
	{
		delete pDevice;
	}

	goto Exit;
} // CNATHelpPAST::CheckForNewDevices






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::CheckForLocalPASTServerAndRegister"
//=============================================================================
// CNATHelpPAST::CheckForLocalPASTServerAndRegister
//-----------------------------------------------------------------------------
//
// Description:    Checks for a local PAST server on the given device.  If one
//				is found, a new client is registered.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device to check.
//
// Returns: HRESULT
//	DPNH_OK				- The check was successful (may not be a server,
//							though).
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::CheckForLocalPASTServerAndRegister(CDevice * const pDevice)
{
	HRESULT			hr = DPNH_OK;
	DWORD			dwError;
	SOCKET			sTemp = INVALID_SOCKET;
	SOCKADDR_IN		saddrinTemp;
	BOOL			fAddressAlreadyChanged;
	DWORD			dwOriginalNextPollInterval;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pDevice);


	//
	// Open a datagram socket on this device.
	//
	sTemp = this->m_pfnsocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sTemp == INVALID_SOCKET)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't create datagram socket, error = %u!", dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Try binding it to the PAST port first to see if there's a local PAST
	// server on the device.
	//
	// We could just go ahead and try to register with a server, but if one
	// doesn't exist, the registration code would block during the timeout.  By
	// simply checking if the port is in use, we can avoid that timeout.  The
	// only slight cost is if two PASTHelps happened to be trying this at the
	// exact same time, one could be tricked by the other into thinking that
	// the port was in use.  In that case, it would falsely try to register...
	// but then timeout.  Not a big deal, that's treated as non-fatal below.
	//
	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family				= AF_INET;
	saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
	saddrinTemp.sin_port				= HTONS(PAST_HOST_PORT);

	if (this->m_pfnbind(sTemp,
						(SOCKADDR *) (&saddrinTemp),
						sizeof(saddrinTemp)) != 0)
	{
		//
		// The bind failed.  We'll print the exact error, but assume it was
		// because the port was in use.
		//
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 1, "Couldn't bind datagram socket %u.%u.%u.%u:%u to PAST server port, assuming because there's a local PAST server (error = %u).",
			saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
			saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
			saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
			saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
			NTOHS(saddrinTemp.sin_port),
			dwError);
#endif // DBG

		//
		// Save the current poll interval in case we need to restore it.
		//
		dwOriginalNextPollInterval = this->m_dwNextPollInterval;

		//
		// We should register with this local PAST server right now.
		// This might reset the poll interval.
		//
		hr = this->RegisterWithLocalPASTServer(pDevice);
		if (hr != DPNH_OK)
		{
			if (hr == DPNHERR_SERVERNOTRESPONDING)
			{
				//
				// If the server isn't responding, we'll treat it as non-fatal,
				// but obviously we can't use the server.
				//
				DPFX(DPFPREP, 1, "Local PAST server does not respond to registrations, ignoring.");
			}
			else
			{
				//
				// Some other failure.  Annoying, but ignore it.
				//
				DPFX(DPFPREP, 0, "Couldn't register with local PAST server (err = 0x%lx)!  Ignoring.",
					hr);
			}

			hr = DPNH_OK;

			//
			// Drop through.
			//
		}
		else
		{
			fAddressAlreadyChanged = (this->m_dwFlags & NATHELPPASTOBJ_ADDRESSESCHANGED) ? TRUE : FALSE;


			//
			// We need to bind a temporary port to detect ICS vs. FW-only.
			// UpdatePASTPublicAddressValidity does this in addition to
			// checking public address validity like the function name
			// says.
			//
			hr = this->UpdatePASTPublicAddressValidity(pDevice, FALSE);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't update new local PAST server public address validity!", hr);
				goto Failure;
			}

			
			//
			// If we encountered an error that caused the PAST server to be
			// removed, then we shouldn't (and can't) try registering any
			// existing ports.
			//
			// Otherwise, make sure we're allowed to work with the type of PAST
			// server found.  If we aren't de-register.  If we are, bind any
			// ports already associated with this device.
			//
			if ((pDevice->GetPASTClientID(FALSE) == 0) ||
				((pDevice->HasLocalICSPASTServer()) && (! (this->m_dwFlags & NATHELPPASTOBJ_USEPASTICS))) ||
				((pDevice->HasLocalPFWOnlyPASTServer()) && (! (this->m_dwFlags & NATHELPPASTOBJ_USEPASTPFW))))
			{

				if (pDevice->GetPASTClientID(FALSE) != 0)
				{
					DPFX(DPFPREP, 2, "Not allowed to use local %s PAST server, de-registering.",
						((pDevice->HasLocalICSPASTServer()) ? _T("ICS") : _T("PFW only")));


					hr = this->DeregisterWithPASTServer(pDevice, FALSE);
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't de-register with local PAST server (err = 0x%lx)!  Ignoring.",
							hr);
						
						//
						// Consider ourselves de-registered.
						//
						pDevice->SetPASTClientID(0, FALSE);

						//
						// Continue anyway...
						//
						hr = DPNH_OK;
					}

					this->ClearAllPASTServerRegisteredPorts(pDevice, FALSE);
					this->RemoveAllPASTCachedMappings(pDevice, FALSE);
					pDevice->NoteNoPASTPublicAddressAvailable(FALSE);
					pDevice->NoteNoLocalPASTServer();
				}
				else
				{
					DPFX(DPFPREP, 1, "Local PAST server was removed while trying to update public address validity.");
				}


				//
				// Prevent the user from thinking the addresses changed unless
				// something else caused the address change notification.
				//
				if (! fAddressAlreadyChanged)
				{
					this->m_dwFlags &= ~NATHELPPASTOBJ_ADDRESSESCHANGED;
				}
				
				//
				// Go back to the previous poll interval.
				//
				this->m_dwNextPollInterval = dwOriginalNextPollInterval;
			}
			else
			{
				if (! pDevice->m_blOwnedRegPorts.IsEmpty())
				{
					DPFX(DPFPREP, 2, "Local PAST server now available, registering existing ports.");


					hr = this->RegisterAllPortsWithPAST(pDevice, FALSE);
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't register existing ports with new local PAST server!", hr);
						goto Failure;
					}


#ifdef DBG
					//
					// If we didn't encounter an error that caused the PAST
					// server to be removed, then the
					// NATHELPPASTOBJ_ADDRESSESCHANGED flag must have been set
					// by the AssignOrListenPorts function.
					//
					if (pDevice->GetPASTClientID(TRUE) != 0)
					{
						DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_ADDRESSESCHANGED);
					}
					else
					{
						DPFX(DPFPREP, 1, "Local PAST server was removed while trying to register existing ports.");
					}
#endif // DBG
				}
				else
				{
					DPFX(DPFPREP, 2, "Local PAST server now available, but no previously registered ports.");
				}
			}
		} // end else (successfully registered with local PAST server)
	}
	else
	{
		//
		// The bind succeeded.  Doesn't look like there's a local PAST server.
		//
		DPFX(DPFPREP, 7, "Bound datagram socket %u.%u.%u.%u:%u, no local PAST server present.",
			saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
			saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
			saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
			saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
			NTOHS(saddrinTemp.sin_port));
	}


Exit:

	if (sTemp != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(sTemp);
	}


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::CheckForLocalPASTServerAndRegister






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::RemoveAllItems"
//=============================================================================
// CNATHelpPAST::RemoveAllItems
//-----------------------------------------------------------------------------
//
// Description:    Removes all devices (de-registering with Internet gateways
//				if necessary).  This removes all registered port mapping
//				objects, as well.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpPAST::RemoveAllItems(void)
{
	HRESULT				hr;
	CBilink *			pBilinkDevice;
	CDevice *			pDevice;
	CBilink *			pBilinkRegisteredPort;
	CRegisteredPort *	pRegisteredPort;


	DPFX(DPFPREP, 7, "(0x%p) Enter", this);


	pBilinkDevice = this->m_blDevices.GetNext();
	while (pBilinkDevice != &this->m_blDevices)
	{
		pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
		pBilinkDevice = pBilinkDevice->GetNext();


		DPFX(DPFPREP, 5, "Destroying device 0x%p.",
			pDevice);


		pDevice->m_blList.RemoveFromList();


		//
		// De-register from remote PAST server if necessary.
		//
		if (pDevice->GetPASTClientID(TRUE) != 0)
		{
			hr = this->DeregisterWithPASTServer(pDevice, TRUE);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't de-register with remote PAST server (err = 0x%lx)!  Ignoring.",
					hr);
				
				//
				// Consider ourselves de-registered.
				//
				pDevice->SetPASTClientID(0, TRUE);

				//
				// Continue anyway, so we can finish cleaning up the object.
				//
			}

			this->ClearAllPASTServerRegisteredPorts(pDevice, TRUE);
			this->RemoveAllPASTCachedMappings(pDevice, TRUE);
			pDevice->NoteNoPASTPublicAddressAvailable(TRUE);
		}

		//
		// De-register from local PAST server if necessary.
		//
		if (pDevice->GetPASTClientID(FALSE) != 0)
		{
			hr = this->DeregisterWithPASTServer(pDevice, FALSE);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't de-register with local PAST server (err = 0x%lx)!  Ignoring.",
					hr);
				
				//
				// Consider ourselves de-registered.
				//
				pDevice->SetPASTClientID(0, FALSE);

				//
				// Continue anyway, so we can finish cleaning up the object.
				//
			}

			this->ClearAllPASTServerRegisteredPorts(pDevice, FALSE);
			this->RemoveAllPASTCachedMappings(pDevice, FALSE);
			pDevice->NoteNoPASTPublicAddressAvailable(FALSE);
		}


		//
		// All of the device's registered ports are implicitly freed.
		//

		pBilinkRegisteredPort = pDevice->m_blOwnedRegPorts.GetNext();

		while (pBilinkRegisteredPort != &pDevice->m_blOwnedRegPorts)
		{
			pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegisteredPort);
			pBilinkRegisteredPort = pBilinkRegisteredPort->GetNext();


			DPFX(DPFPREP, 5, "Destroying registered port 0x%p (under device 0x%p).",
				pRegisteredPort, pDevice);


			pRegisteredPort->ClearDeviceOwner();
			pRegisteredPort->m_blGlobalList.RemoveFromList();

			if (pRegisteredPort->GetPASTBindID(TRUE) != 0)
			{
				pRegisteredPort->SetPASTBindID(0, TRUE);
				pRegisteredPort->ClearPASTPublicAddresses(TRUE);
				DNASSERT(this->m_dwNumLeases > 0);
				this->m_dwNumLeases--;

				DPFX(DPFPREP, 7, "Remote PAST lease for 0x%p cleared, total num leases = %u.",
					pRegisteredPort, this->m_dwNumLeases);
			}

			if (pRegisteredPort->GetPASTBindID(FALSE) != 0)
			{
				pRegisteredPort->SetPASTBindID(0, FALSE);
				pRegisteredPort->ClearPASTPublicAddresses(FALSE);
				DNASSERT(this->m_dwNumLeases > 0);
				this->m_dwNumLeases--;

				DPFX(DPFPREP, 7, "Local PAST lease for 0x%p cleared, total num leases = %u.",
					pRegisteredPort, this->m_dwNumLeases);
			}

			pRegisteredPort->ClearPrivateAddresses();


			//
			// The user implicitly released this port.
			//
			pRegisteredPort->ClearAllUserRefs();

			delete pRegisteredPort;
		}


		//
		// Close the socket.
		//
		this->m_pfnclosesocket(pDevice->GetPASTSocket());
		pDevice->SetPASTSocket(INVALID_SOCKET);


		//
		// Now we can dump the device object.
		//
		delete pDevice;
	}


	//
	// Removing all the devices normally removes all the registered ports, but
	// there may still be more wildcard ports that were never associated with
	// any device.
	//

	pBilinkRegisteredPort = this->m_blUnownedPorts.GetNext();
	while (pBilinkRegisteredPort != &this->m_blUnownedPorts)
	{
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegisteredPort);
		pBilinkRegisteredPort = pBilinkRegisteredPort->GetNext();


		DPFX(DPFPREP, 5, "Destroying unowned registered port 0x%p.",
			pRegisteredPort);


		pRegisteredPort->m_blDeviceList.RemoveFromList();
		pRegisteredPort->m_blGlobalList.RemoveFromList();

		pRegisteredPort->ClearPrivateAddresses();

		DNASSERT(pRegisteredPort->GetPASTBindID(TRUE) == 0);
		DNASSERT(pRegisteredPort->GetPASTBindID(FALSE) == 0);

		//
		// The user implicitly released this port.
		//
		pRegisteredPort->ClearAllUserRefs();

		delete pRegisteredPort;
	}


	DNASSERT(this->m_blRegisteredPorts.IsEmpty());


	DPFX(DPFPREP, 7, "(0x%p) Leave", this);
} // CNATHelpPAST::RemoveAllItems





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::FindMatchingDevice"
//=============================================================================
// CNATHelpPAST::FindMatchingDevice
//-----------------------------------------------------------------------------
//
// Description:    Searches the list of devices for the object matching the
//				given address, or NULL if one could not be found.
//
//				   If fMatchRegPort is TRUE, the list of registered ports
//				associated with devices is searched first for an exact match to
//				the address passed in.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	SOCKADDR_IN * psaddrinMatch		- Pointer to address to look up.
//	BOOL fMatchRegPort				- Whether existing registered ports should
//										be checked for an exact match first.
//
// Returns: CDevice
//	NULL if no match, valid object otherwise.
//=============================================================================
CDevice * CNATHelpPAST::FindMatchingDevice(const SOCKADDR_IN * const psaddrinMatch,
											const BOOL fMatchRegPort)
{
	HRESULT				hr;
	BOOL				fUpdatedDeviceList = FALSE;
	CDevice *			pDeviceRemoteICSServer = NULL;
	CDevice *			pDeviceLocalICSServer = NULL;
	CDevice *			pDeviceLocalPFWOnlyServer = NULL;
	SOCKADDR_IN *		psaddrinTemp;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;
	DWORD				dwTemp;


	do
	{
		//
		// First, make sure there are devices to choose from.
		//
		if (this->m_blDevices.IsEmpty())
		{
			DPFX(DPFPREP, 0, "No devices, can't match address %u.%u.%u.%u!",
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);
			pDevice = NULL;
			goto Exit;
		}


		//
		// It's possible that the address we're trying to match is an already
		// registered port.  Look through all owned port mappings for this
		// address, if we're allowed.
		//
		if (fMatchRegPort)
		{
			pBilink = this->m_blRegisteredPorts.GetNext();
			while (pBilink != &this->m_blRegisteredPorts)
			{
				pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

				//
				// Only check this registered port if it has an owning device.
				//
				pDevice = pRegisteredPort->GetOwningDevice();
				if (pDevice != NULL)
				{
					//
					// Check each port in the array.
					//
					psaddrinTemp = pRegisteredPort->GetPrivateAddressesArray();
					for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
					{
						//
						// If the address matches, we have a winner.
						//
						if ((psaddrinTemp[dwTemp].sin_addr.S_un.S_addr == psaddrinMatch->sin_addr.S_un.S_addr) &&
							(psaddrinTemp[dwTemp].sin_port == psaddrinMatch->sin_port))
						{
							DPFX(DPFPREP, 7, "Registered port 0x%p index %u matches address %u.%u.%u.%u:%u, returning owning device 0x%p.",
								pRegisteredPort,
								dwTemp,
								psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
								psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
								psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
								psaddrinMatch->sin_addr.S_un.S_un_b.s_b4,
								NTOHS(psaddrinMatch->sin_port),
								pDevice);
							goto Exit;
						}
					}
				}

				pBilink = pBilink->GetNext();
			}
		}


		//
		// Darn, the address is not already registered.  Well, match it up with
		// a device as best as possible.
		//

		pBilink = this->m_blDevices.GetNext();

		do
		{
			pDevice = DEVICE_FROM_BILINK(pBilink);
			
			if ((pDevice->GetLocalAddressV4() == psaddrinMatch->sin_addr.S_un.S_addr))
			{
				DPFX(DPFPREP, 7, "Device 0x%p matches address %u.%u.%u.%u.",
					pDevice,
					psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
					psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
					psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
					psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);
				goto Exit;
			}

			//
			// Remember this device if it has the first remote ICS server we've
			// seen.
			//
			if ((pDevice->GetPASTClientID(TRUE) != 0) &&
				(pDeviceRemoteICSServer == NULL))
			{
				pDeviceRemoteICSServer = pDevice;
			}


			//
			// Remember this device if it has the first local ICS or firewall
			// only server we've seen.
			//
			if (pDevice->GetPASTClientID(FALSE) != 0)
			{
				if ((pDevice->HasLocalICSPASTServer()) &&
					(pDeviceLocalICSServer == NULL))
				{
					pDeviceLocalICSServer = pDevice;
				}
				else if ((pDevice->HasLocalPFWOnlyPASTServer()) &&
						(pDeviceLocalPFWOnlyServer == NULL))
				{
					pDeviceLocalPFWOnlyServer = pDevice;
				}
			}


			DPFX(DPFPREP, 7, "Device 0x%p does not match address %u.%u.%u.%u.",
				pDevice,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);

			pBilink = pBilink->GetNext();
		}
		while (pBilink != &this->m_blDevices);


		//
		// If we got here, there's no matching device.  It might be because the
		// caller detected an address change faster than we did.  Try updating
		// our device list and searching again (if we haven't already).
		//

		if (fUpdatedDeviceList)
		{
			break;
		}


		//
		// Don't bother updating the list to match INADDR_ANY, we know that
		// will never match anything.
		//
		if (psaddrinMatch->sin_addr.S_un.S_addr == INADDR_ANY)
		{
			DPFX(DPFPREP, 7, "Couldn't find matching device for INADDR_ANY, as expected.");
			break;
		}


		DPFX(DPFPREP, 7, "Couldn't find matching device for %u.%u.%u.%u, updating device list and searching again.",
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);


		hr = this->CheckForNewDevices(&fUpdatedDeviceList);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't check for new devices (0x%lx), continuing.",
				hr);
			//
			// Hmm, we have to treat it as non-fatal. Don't search again,
			// though.
			//
			break;
		}

		//
		// If we didn't actually get any new devices, don't bother searching
		// again.
		//
		if (! fUpdatedDeviceList)
		{
			break;
		}

		//
		// fUpdatedDeviceList is set to TRUE so we'll only loop one more time.
		//
	}
	while (TRUE);


	//
	// If we got here, there's still no matching device.  If it's the wildcard
	// value, that's to be expected, but we need to pick a device in the
	// following order:
	//    1. device has an Internet gateway
	//    2. device has a firewall
	// If none of those exists or it's not the wildcard value, we have to give
	// up.
	//
	if (psaddrinMatch->sin_addr.S_un.S_addr == INADDR_ANY)
	{
		if (pDeviceRemoteICSServer != NULL)
		{
			pDevice = pDeviceRemoteICSServer;

			DPFX(DPFPREP, 1, "Picking device 0x%p with remote ICS server to match INADDR_ANY.",
				pDevice);
		}
		else if (pDeviceLocalICSServer != NULL)
		{
			pDevice = pDeviceLocalICSServer;

			DPFX(DPFPREP, 1, "Picking device 0x%p with local ICS server to match INADDR_ANY.",
				pDevice);
		}
		else if (pDeviceLocalPFWOnlyServer != NULL)
		{
			pDevice = pDeviceLocalPFWOnlyServer;

			DPFX(DPFPREP, 1, "Picking device 0x%p with local PFW-only server to match INADDR_ANY.",
				pDevice);
		}
		else
		{
			pDevice = NULL;

			DPFX(DPFPREP, 1, "No suitable device to match INADDR_ANY.");
		}
	}
	else
	{
		pDevice = NULL;

		DPFX(DPFPREP, 7, "No devices match address %u.%u.%u.%u.",
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);
	}


Exit:

	return pDevice;
} // CNATHelpPAST::FindMatchingDevice







#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::RegisterWithLocalPASTServer"
//=============================================================================
// CNATHelpPAST::RegisterWithLocalPASTServer
//-----------------------------------------------------------------------------
//
// Description:    Attempts to register with a local PAST server.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Device to use when registering.
//
// Returns: HRESULT
//	DPNH_OK							- The registration attempt completed
//										without error.
//	DPNHERR_SERVERNOTRESPONDING		- No server responded to the registration
//										attempt.
//	DPNHERR_GENERIC					- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::RegisterWithLocalPASTServer(CDevice * const pDevice)
{
	HRESULT				hr;
	SOCKADDR_IN			saddrinServerAddress;
	DWORD				dwMsgID;
	PAST_MSG_REGISTER	RegisterReq;
	PAST_RESPONSE_INFO	RespInfo;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pDevice);


	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);
	DNASSERT(pDevice->GetPASTSocket() != INVALID_SOCKET);


	//
	// Create a SOCKADDR to address the PAST service.
	//
	// Also initialize the message sequencing.  Each message response pair is
	// numbered sequentially to allow differentiation from retries over UDP.
	//
	// And finally, reset the current retry timeout (even though it doesn't
	// affect this special case Register message).
	//
	ZeroMemory(&saddrinServerAddress, sizeof(saddrinServerAddress));
	saddrinServerAddress.sin_family				= AF_INET;
	saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
	saddrinServerAddress.sin_port				= HTONS(PAST_HOST_PORT);

	DNASSERT(pDevice->GetPASTClientID(FALSE) == 0);
	pDevice->ResetLocalPASTMsgIDAndRetryTimeout(DEFAULT_INITIAL_PAST_RETRY_TIMEOUT);
	dwMsgID = pDevice->GetNextLocalPASTMsgID();
	DNASSERT(dwMsgID == 0);


	//
	// Remember the current time, if this is the first thing we've sent from
	// this port.
	//
	if (pDevice->GetFirstPASTDiscoveryTime() == 0)
	{
		pDevice->SetFirstPASTDiscoveryTime(GETTIMESTAMP());
	}


	//
	// Build the request message.
	//

	ZeroMemory(&RegisterReq, sizeof(RegisterReq));
	RegisterReq.version		= PAST_VERSION;
	RegisterReq.command		= PAST_MSGID_REGISTER_REQUEST;

	RegisterReq.msgid.code	= PAST_PARAMID_MESSAGEID;
	RegisterReq.msgid.len	= sizeof(RegisterReq.msgid) - sizeof(PAST_PARAM);
	RegisterReq.msgid.msgid	= dwMsgID;


	//
	// Send the message and get the reply.
	//
	hr = this->ExchangeAndParsePAST(pDevice->GetPASTSocket(),
									(SOCKADDR*) (&saddrinServerAddress),
									sizeof(saddrinServerAddress),
									(char *) &RegisterReq,
									sizeof(RegisterReq),
									dwMsgID,
									NULL,
									&RespInfo);
	if (hr != DPNH_OK)
	{
		//
		// If exchanging the registration attempt failed, see if it was because
		// the server wasn't responding.
		//
		if (hr != DPNHERR_SERVERNOTRESPONDING)
		{
			DPFX(DPFPREP, 0, "Registering with a PAST server failed!");
			goto Failure;
		}

		//
		// Server non-existence is considered non-fatal, but it still means
		// we're done here.
		//
		DPFX(DPFPREP, 1, "No PAST server responded, registration was not successful.");

		goto Exit;
	}

	if (RespInfo.cMsgType != PAST_MSGID_REGISTER_RESPONSE)
	{
		DPFX(DPFPREP, 0, "Unexpected response type %u, failing registration!", RespInfo.cMsgType);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	//
	// If we got here, then we successfully registered with a server.
	//

	pDevice->SetPASTClientID(RespInfo.dwClientID, FALSE);


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::RegisterWithLocalPASTServer





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::DeregisterWithPASTServer"
//=============================================================================
// CNATHelpPAST::DeregisterWithPASTServer
//-----------------------------------------------------------------------------
//
// Description:    Attempts to deregister with the PAST server (local or
//				remote, as determined by fRemote).
//
//				   All port assignments are implicitly freed.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Device to use when deregistering.
//	BOOL fRemote		- TRUE if should attempt to deregister with remote
//							server, FALSE if deregistering with local server.
//
// Returns: HRESULT
//	DPNH_OK				- The deregistration completed successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::DeregisterWithPASTServer(CDevice * const pDevice,
												const BOOL fRemote)
{
	HRESULT							hr = DPNH_OK;
	SOCKADDR_IN						saddrinServerAddress;
	DWORD							dwClientID;
	DWORD							dwMsgID;
	DWORD *							ptuRetry;
	PAST_MSG_DEREGISTER_REQUEST		DeregisterReq;
	PAST_RESPONSE_INFO				RespInfo;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)", this, pDevice, fRemote);


	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);
	DNASSERT(pDevice->GetPASTSocket() != INVALID_SOCKET);


	//
	// Create a SOCKADDR to address the PAST service, and get the appropriate
	// client ID, initial retry timeout, and next message ID to use.
	//
	ZeroMemory(&saddrinServerAddress, sizeof(saddrinServerAddress));
	saddrinServerAddress.sin_family					= AF_INET;
	saddrinServerAddress.sin_port					= HTONS(PAST_HOST_PORT);

	if (fRemote)
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetRemotePASTServerAddressV4();
		dwMsgID = pDevice->GetNextRemotePASTMsgID();
		ptuRetry = pDevice->GetRemotePASTRetryTimeoutPtr();
	}
	else
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
		dwMsgID = pDevice->GetNextLocalPASTMsgID();
		ptuRetry = pDevice->GetLocalPASTRetryTimeoutPtr();
	}

	dwClientID = pDevice->GetPASTClientID(fRemote);
	DNASSERT(dwClientID != 0);
	
	
	//
	// Build the request message.
	//
	
	ZeroMemory(&DeregisterReq, sizeof(DeregisterReq));
	DeregisterReq.version			= PAST_VERSION;
	DeregisterReq.command			= PAST_MSGID_DEREGISTER_REQUEST;

	DeregisterReq.clientid.code		= PAST_PARAMID_CLIENTID;
	DeregisterReq.clientid.len		= sizeof(DeregisterReq.clientid) - sizeof(PAST_PARAM);
	DeregisterReq.clientid.clientid	= dwClientID;

	DeregisterReq.msgid.code		= PAST_PARAMID_MESSAGEID;
	DeregisterReq.msgid.len			= sizeof(DeregisterReq.msgid) - sizeof(PAST_PARAM);
	DeregisterReq.msgid.msgid		= dwMsgID;


	//
	// Send the message and get the reply.
	//
	hr = this->ExchangeAndParsePAST(pDevice->GetPASTSocket(),
									(SOCKADDR*) (&saddrinServerAddress),
									sizeof(saddrinServerAddress),
									(char *) &DeregisterReq,
									sizeof(DeregisterReq),
									dwMsgID,
									ptuRetry,
									&RespInfo);
	if (hr != DPNH_OK)
	{
		if (hr != DPNHERR_SERVERNOTRESPONDING)
		{
			DPFX(DPFPREP, 0, "De-registering with server failed!");
			goto Failure;
		}

		//
		// Server stopped responding, but who cares, we were de-registering
		// anyway.
		//
		DPFX(DPFPREP, 1, "Server stopped responding while de-registering!  Ignoring.");

		hr = DPNH_OK;
	}
	else
	{
		if (RespInfo.cMsgType != PAST_MSGID_DEREGISTER_RESPONSE)
		{
			DPFX(DPFPREP, 0, "Got unexpected response type %u, failed de-registering!", RespInfo.cMsgType);
			hr = DPNHERR_GENERIC;
			goto Failure;
		}
	}

	pDevice->SetPASTClientID(0, fRemote);


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::DeregisterWithPASTServer





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::ExtendAllExpiringLeases"
//=============================================================================
// CNATHelpPAST::ExtendAllExpiringLeases
//-----------------------------------------------------------------------------
//
// Description:    Renews any port leases that are close to expiring (within 2
//				minutes of expiration time).
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK				- Lease extension was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::ExtendAllExpiringLeases(void)
{
	HRESULT				hr = DPNH_OK;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;
	DWORD				dwLeaseTimeRemaining;


	DPFX(DPFPREP, 5, "Enter");


	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);


	//
	// Walk the list of all registered ports and check for leases that need to
	// be extended.
	// The lock is already held.
	//

	pBilink = this->m_blRegisteredPorts.GetNext();

	while (pBilink != (&this->m_blRegisteredPorts))
	{
		pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

		pDevice = pRegisteredPort->GetOwningDevice();


		//
		// If the port is registered remotely, extend that lease, if necessary.
		//
		if (pRegisteredPort->GetPASTBindID(TRUE) != 0)
		{
			DNASSERT(pDevice != NULL);


			dwLeaseTimeRemaining = pRegisteredPort->GetPASTLeaseExpiration(TRUE) - timeGetTime();

			if (dwLeaseTimeRemaining < LEASE_RENEW_TIME)
			{
				hr = this->ExtendPASTLease(pRegisteredPort, TRUE);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't extend port mapping lease on remote PAST server (0x%lx)!  Ignoring.", hr);

					//
					// We'll treat this as non-fatal, but we have to dump the server.
					//
					this->ClearDevicesPASTServer(pDevice, TRUE);
					hr = DPNH_OK;
				}
			}
		}

		//
		// If the port is registered locally, extend that lease, if necessary.
		//
		if (pRegisteredPort->GetPASTBindID(FALSE) != 0)
		{
			DNASSERT(pDevice != NULL);


			dwLeaseTimeRemaining = pRegisteredPort->GetPASTLeaseExpiration(FALSE) - timeGetTime();

			if (dwLeaseTimeRemaining < LEASE_RENEW_TIME)
			{
				hr = this->ExtendPASTLease(pRegisteredPort, FALSE);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't extend port mapping lease on local PAST server (0x%lx)!  Ignoring.", hr);

					//
					// We'll treat this as non-fatal, but we have to dump the server.
					//
					this->ClearDevicesPASTServer(pDevice, FALSE);
					hr = DPNH_OK;
				}
			}
		}

		pBilink = pBilink->GetNext();
	}


	DNASSERT(hr == DPNH_OK);

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CNATHelpPAST::ExtendAllExpiringLeases





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::UpdateServerStatus"
//=============================================================================
// CNATHelpPAST::UpdateServerStatus
//-----------------------------------------------------------------------------
//
// Description:    Checks to see if any Internet gateways have stopped
//				responding or are now available.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK				- The update was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::UpdateServerStatus(void)
{
	HRESULT		hr = DPNH_OK;
	CBilink		blNoRemotePASTList;
	DWORD		dwMinUpdateServerStatusInterval;
	DWORD		dwCurrentTime;
	CBilink *	pBilink;
	CDevice *	pDevice;
	CDevice *	pDeviceRemoteICSServer = NULL;
	CDevice *	pDeviceLocalICSServer = NULL;
	CDevice *	pDeviceLocalPFWOnlyServer = NULL;
	BOOL		fSendRemoteGatewayDiscovery;


	DPFX(DPFPREP, 5, "Enter");


	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);


	blNoRemotePASTList.Initialize();


	//
	// Cache the current value of the global.  This should be atomic so no need
	// to take the globals lock.
	//
	dwMinUpdateServerStatusInterval = g_dwMinUpdateServerStatusInterval;


	//
	// Capture the current time.
	//
	dwCurrentTime = timeGetTime();


	//
	// If this isn't the first time to update server status, but it hasn't been
	// very long since we last checked, don't.  This will prevent unnecessary
	// network traffic if GetCaps is called frequently (in response to many
	// alert events, for example).
	//
	// However, if we just found a new device, update the status anyway.
	//
	//
	if (this->m_dwLastUpdateServerStatusTime != 0)
	{
		if ((dwCurrentTime - this->m_dwLastUpdateServerStatusTime) < dwMinUpdateServerStatusInterval)
		{
			if (! (this->m_dwFlags & NATHELPPASTOBJ_DEVICECHANGED))
			{
				DPFX(DPFPREP, 5, "Server status was just updated at %u, not updating again (time = %u, min interval = %u).",
					this->m_dwLastUpdateServerStatusTime,
					dwCurrentTime,
					dwMinUpdateServerStatusInterval);

				//
				// hr == DPNH_OK
				//
				goto Exit;
			}


			DPFX(DPFPREP, 5, "Server status was just updated at %u (time = %u, min interval = %u), but there was a device change that may affect things.",
				this->m_dwLastUpdateServerStatusTime,
				dwCurrentTime,
				dwMinUpdateServerStatusInterval);

			//
			// Continue...
			//
		}


		//
		// If we're allowed to keep polling for remote gateways after startup,
		// do so.  Otherwise, only do it if a device has changed or a port has
		// been registered since our last check.
		//
		if ((g_fKeepPollingForRemoteGateway) ||
			(this->m_dwFlags & NATHELPPASTOBJ_DEVICECHANGED) ||
			(this->m_dwFlags & NATHELPPASTOBJ_PORTREGISTERED))
		{
			fSendRemoteGatewayDiscovery = TRUE;
		}
		else
		{
			fSendRemoteGatewayDiscovery = FALSE;
		}
	}
	else
	{
		//
		// We always poll for new remote gateways during startup.
		//
		fSendRemoteGatewayDiscovery = TRUE;
	}


	//
	// Prevent the timer from landing exactly on 0.
	//
	if (dwCurrentTime == 0)
	{
		dwCurrentTime = 1;
	}
	this->m_dwLastUpdateServerStatusTime = dwCurrentTime;


	//
	// Turn off the 'device changed' and 'port registered' flags, if they were
	// on.
	//
	this->m_dwFlags &= ~(NATHELPPASTOBJ_DEVICECHANGED | NATHELPPASTOBJ_PORTREGISTERED);


	//
	// Loop through all the devices.
	//
	pBilink = this->m_blDevices.GetNext();
	while (pBilink != &this->m_blDevices)
	{
		pDevice = DEVICE_FROM_BILINK(pBilink);


		//
		// This might be a new device, so register any ports with this address
		// that were previously unowned (because this device's address was
		// unknown at the time).
		//
		hr = this->RegisterPreviouslyUnownedPortsWithDevice(pDevice, FALSE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't register previously unowned ports with device 0x%p!.",
				pDevice);
			goto Failure;
		}


		if (pDevice->GetPASTClientID(FALSE) == 0)
		{
			//
			// The device did not previously have a local PAST server.  See if
			// one came online.
			//

			DNASSERT((pDevice->GetPASTCachedMaps(FALSE))->IsEmpty());

			hr = this->CheckForLocalPASTServerAndRegister(pDevice);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't check for local PAST server (and register with it) on device 0x%p!",
					pDevice);
				goto Failure;
			}
			
			if (pDevice->GetPASTClientID(FALSE) != 0)
			{
				//
				// Wow, a local PAST server is now available.
				//

				//
				// Remember the device if it has the first local ICS or PFW
				// PAST server we've seen.
				//
				if ((pDevice->HasLocalICSPASTServer()) &&
					(pDeviceLocalICSServer == NULL))
				{
					DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_USEPASTICS);
					pDeviceLocalICSServer = pDevice;
				}
				else if ((pDevice->HasLocalPFWOnlyPASTServer()) &&
						(pDeviceLocalPFWOnlyServer == NULL))
				{
					DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_USEPASTPFW);
					pDeviceLocalPFWOnlyServer = pDevice;
				}


				//
				// We don't need to register all the existing mappings
				// associated with the device that the user has already
				// requested.  CheckForLocalPASTServerAndRegister took care of
				// that for us.
				//
			}
			else
			{
				DPFX(DPFPREP, 7, "Still no local PAST server on device 0x%p.",
					pDevice);
			}
		}
		else
		{
			//
			// The device previously had a local PAST server.
			//


			//
			// Make sure the server is still alive and see whether it's handing
			// out valid public addresses or not.
			//
			hr = this->UpdatePASTPublicAddressValidity(pDevice, FALSE);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't update local PAST server public address validity on device 0x%p!",
					pDevice);
				goto Failure;
			}


			//
			// If there's still a PAST server, remember the device if it's the
			// first local ICS or PFW PAST server we've seen.
			//
			if (pDevice->GetPASTClientID(FALSE) != 0)
			{
				if ((pDevice->HasLocalICSPASTServer()) &&
					(pDeviceLocalICSServer == NULL))
				{
					pDeviceLocalICSServer = pDevice;
				}
				else if ((pDevice->HasLocalPFWOnlyPASTServer()) &&
					(pDeviceLocalPFWOnlyServer == NULL))
				{
					pDeviceLocalPFWOnlyServer = pDevice;
				}
			}
		}

		
		if (this->m_dwFlags & NATHELPPASTOBJ_USEPASTICS)
		{
			if (pDevice->GetPASTClientID(TRUE) == 0)
			{
				//
				// The device did not previously have a remote PAST server.
				// Remember it so we can check if one came online below,
				// unless we're not allowed to perform remote gateway
				// discovery.
				//

				DNASSERT((pDevice->GetPASTCachedMaps(TRUE))->IsEmpty());

				if (fSendRemoteGatewayDiscovery)
				{
					pDevice->m_blTempList.InsertBefore(&blNoRemotePASTList);
				}
			}
			else
			{
				//
				// The device previously had a remote PAST server.
				//


				//
				// Make sure the server is still alive and see whether it's
				// handing out valid public addresses or not.
				//
				hr = this->UpdatePASTPublicAddressValidity(pDevice, TRUE);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't update remote PAST server public address validity on device 0x%p!",
						pDevice);
					goto Failure;
				}


				//
				// If there's still a PAST server, remember the device if it's
				// the first remote PAST server we've seen.
				//
				if ((pDevice->GetPASTClientID(TRUE) != 0) &&
					(pDeviceRemoteICSServer == NULL))
				{
					pDeviceRemoteICSServer = pDevice;
				}
			}
		}
		else
		{
			//
			// Not using PAST for ICS NAT traversal.
			//
		}


		pBilink = pBilink->GetNext();
	}


	//
	// Update any devices that don't currently have remote PAST servers.
	//
	if (! blNoRemotePASTList.IsEmpty())
	{
		DNASSERT(fSendRemoteGatewayDiscovery);
		hr = this->RegisterMultipleDevicesWithRemotePAST(&blNoRemotePASTList,
														&pDeviceRemoteICSServer);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't register multiple devices with remote PAST servers!");
			goto Failure;
		}
	}


	//
	// Some new servers may have come online.  If so, we can now map wildcard
	// ports that were registered previously.  Figure out which device that is.
	//
	if (pDeviceRemoteICSServer != NULL)
	{
		pDevice = pDeviceRemoteICSServer;
	}
	else if (pDeviceLocalICSServer != NULL)
	{
		pDevice = pDeviceLocalICSServer;
	}
	else if (pDeviceLocalPFWOnlyServer != NULL)
	{
		pDevice = pDeviceLocalPFWOnlyServer;
	}
	else
	{
		pDevice = NULL;
	}

	if (pDevice != NULL)
	{
		//
		// Register any wildcard ports that are unowned with this best device.
		//
		hr = this->RegisterPreviouslyUnownedPortsWithDevice(pDevice, TRUE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't register unowned wildcard ports with device 0x%p!.",
				pDevice);
			goto Failure;
		}
	}
#ifdef DBG
	else
	{
		DPFX(DPFPREP, 7, "No devices have a remote or local PAST server.");
	}
#endif // DBG


	DPFX(DPFPREP, 7, "Spent %u ms updating server status, starting at %u.",
		(timeGetTime() - dwCurrentTime), dwCurrentTime);


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// Remove any items still in the temp list.
	//
	pBilink = blNoRemotePASTList.GetNext();
	while (pBilink != &blNoRemotePASTList)
	{
		pDevice = DEVICE_FROM_TEMP_BILINK(pBilink);
		pBilink = pBilink->GetNext();

		pDevice->m_blTempList.RemoveFromList();
	}

	goto Exit;
} // CNATHelpPAST::UpdateServerStatus





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::AssignOrListenPASTPort"
//=============================================================================
// CNATHelpPAST::AssignOrListenPASTPort
//-----------------------------------------------------------------------------
//
// Description:    Attempts to assign a port mapping with the PAST server.
//				This may detect a change in server address.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Pointer to port object mapping to
//											assign.
//	BOOL fRemote						- TRUE if should assign with remote
//											server, FALSE if assign with local
//											server.
//
// Returns: HRESULT
//	DPNH_OK							- The assignment was successful.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_PORTUNAVAILABLE			- The server could not bind one of the
//										ports.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the
//										message.
//=============================================================================
HRESULT CNATHelpPAST::AssignOrListenPASTPort(CRegisteredPort * const pRegisteredPort,
											const BOOL fRemote)
{
	HRESULT				hr = DPNH_OK;
	CDevice *			pDevice;
	SOCKADDR_IN			saddrinServerAddress;
	DWORD				dwClientID;
	DWORD				dwMsgID;
	DWORD *				ptuRetry;
	BOOL				fListenRequest;
	BOOL				fSharedUDPListener;
	CHAR				cNumPorts;
	DWORD				dwLeaseTimeInSecs;
	SOCKADDR_IN *		pasaddrinAddressesToAssign;
	DWORD				dwMsgSize;
	PVOID				pvRequest = NULL;
	PBYTE				pbCurrent;
	CHAR				cTemp;
	PAST_RESPONSE_INFO	RespInfo;
	CBilink *			pBilink;
	CRegisteredPort *	pTempRegisteredPort;
	BOOL				fResult;
	BOOL				fFirstLease;
	HRESULT				temphr;
#ifdef DBG
	DWORD				dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)",
		this, pRegisteredPort, fRemote);


	DNASSERT(pRegisteredPort != NULL);

	pDevice = pRegisteredPort->GetOwningDevice();
	DNASSERT(pDevice != NULL);

	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);
	DNASSERT(pDevice->GetPASTSocket() != INVALID_SOCKET);


	//
	// Create a SOCKADDR to address the PAST service, and get the appropriate
	// client ID, initial retry timeout, and next message ID to use.
	//
	ZeroMemory(&saddrinServerAddress, sizeof(saddrinServerAddress));
	saddrinServerAddress.sin_family					= AF_INET;
	saddrinServerAddress.sin_port					= HTONS(PAST_HOST_PORT);

	if (fRemote)
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetRemotePASTServerAddressV4();
		dwMsgID = pDevice->GetNextRemotePASTMsgID();
		ptuRetry = pDevice->GetRemotePASTRetryTimeoutPtr();
	}
	else
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
		dwMsgID = pDevice->GetNextLocalPASTMsgID();
		ptuRetry = pDevice->GetLocalPASTRetryTimeoutPtr();
	}

	dwClientID = pDevice->GetPASTClientID(fRemote);
	DNASSERT(dwClientID != 0);


	fListenRequest = pRegisteredPort->IsFixedPort();
	fSharedUDPListener = pRegisteredPort->IsSharedPort();
	pasaddrinAddressesToAssign = pRegisteredPort->GetPrivateAddressesArray();
	cNumPorts = (CHAR) pRegisteredPort->GetNumAddresses();	// the possible loss of data is okay, capped at DPNH_MAX_SIMULTANEOUS_PORTS anyway
	DNASSERT(cNumPorts > 0);
	dwLeaseTimeInSecs = pRegisteredPort->GetRequestedLeaseTime() / 1000;


	//
	// If this is a remote attempt and it was already mapped with a local
	// Personal Firewall PAST server, be sure to use those addresses.  The
	// PFW PAST server will give different port values, and if there's a NAT
	// upstream we need to map the ports that are actually reachable
	// externally.  Yes, you could consider it user error to have a firewall
	// enabled when you're behind a NAT: why wouldn't they just enable firewall
	// behavior on the NAT?  However, we'll support that.
	//
	if ((fRemote) &&
		(pDevice->HasLocalPFWOnlyPASTServer()) &&
		(pDevice->IsPASTPublicAddressAvailable(FALSE)) &&
		(! pRegisteredPort->IsPASTPortUnavailable(FALSE)))
	{
		DNASSERT(pDevice->GetPASTClientID(FALSE) != 0);
		DNASSERT(pRegisteredPort->GetPASTBindID(FALSE) != 0);

		DPFX(DPFPREP, 2, "Using public addresses previously returned by local Personal Firewall-only PAST server.");
		pasaddrinAddressesToAssign = pRegisteredPort->GetPASTPublicAddressesArray(FALSE);
	}

	DNASSERT(pasaddrinAddressesToAssign != NULL);


	DPFX(DPFPREP, 7, "Sending %s%sfor %u ports (first = %u.%u.%u.%u:%u), requesting %u second lease.",
		((fListenRequest) ? _T("LISTEN_REQUEST") : _T("ASSIGN_REQUEST_RSAP_IP")),
		((fSharedUDPListener) ? _T(" (with SHARED UDP LISTENER vendor code) ") : _T(" ")),
		cNumPorts,
		pasaddrinAddressesToAssign[0].sin_addr.S_un.S_un_b.s_b1,
		pasaddrinAddressesToAssign[0].sin_addr.S_un.S_un_b.s_b2,
		pasaddrinAddressesToAssign[0].sin_addr.S_un.S_un_b.s_b3,
		pasaddrinAddressesToAssign[0].sin_addr.S_un.S_un_b.s_b4,
		NTOHS(pasaddrinAddressesToAssign[0].sin_port),
		dwLeaseTimeInSecs);


	//
	// Build the request message.  We take advantage of the fact that both the
	// ASSIGN_REQUEST, LISTEN_REQUEST, and SHAREDLISTEN_REQUEST messages look
	// almost identical, except SHAREDLISTEN_REQUESTs have an extra vendor
	// option.
	//

	dwMsgSize = (sizeof(PAST_MSG_ASSIGNORLISTEN_REQUEST) + ((cNumPorts - 1) * sizeof(WORD) * 2));
	if (! fSharedUDPListener)
	{
		dwMsgSize -= sizeof(PAST_PARAM_MSVENDOR_CODE);
	}

	pvRequest = DNMalloc(dwMsgSize);
	if (pvRequest == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	pbCurrent = (PBYTE) pvRequest;



	(*pbCurrent++)									= PAST_VERSION;
	(*pbCurrent++)									= (fListenRequest) ? PAST_MSGID_LISTEN_REQUEST : PAST_MSGID_ASSIGN_REQUEST_RSAP_IP;

	((PAST_PARAM_CLIENTID*) pbCurrent)->code		= PAST_PARAMID_CLIENTID;
	((PAST_PARAM_CLIENTID*) pbCurrent)->len			= sizeof(PAST_PARAM_CLIENTID) - sizeof(PAST_PARAM);
	((PAST_PARAM_CLIENTID*) pbCurrent)->clientid	= dwClientID;
	pbCurrent += sizeof (PAST_PARAM_CLIENTID);


	//
	// Local Address (will be returned by PAST server, use don't-care value).
	//
	((PAST_PARAM_ADDRESS*) pbCurrent)->code			= PAST_PARAMID_ADDRESS;
	((PAST_PARAM_ADDRESS*) pbCurrent)->len			= sizeof(PAST_PARAM_ADDRESS) - sizeof(PAST_PARAM);
	((PAST_PARAM_ADDRESS*) pbCurrent)->version		= PAST_ADDRESSTYPE_IPV4;
	((PAST_PARAM_ADDRESS*) pbCurrent)->addr			= PAST_ANY_ADDRESS;
	pbCurrent += sizeof (PAST_PARAM_ADDRESS);

	//
	// Local Port, this is the port the user has opened for which we are
	// assigning a global alias.
	//
	// NOTE: Ports appeared to be transferred in x86 format, contrary to the
	// spec, which says network byte order.
	//
	(*pbCurrent++)									= PAST_PARAMID_PORTS;
	*((WORD*) pbCurrent)							= sizeof(CHAR) + (sizeof(WORD) * cNumPorts);
	pbCurrent += 2;
	(*pbCurrent++)									= cNumPorts;
	for(cTemp = 0; cTemp < cNumPorts; cTemp++)
	{
		*((WORD*) pbCurrent) = NTOHS(pasaddrinAddressesToAssign[cTemp].sin_port);
		pbCurrent += 2;
	}

	//
	// Remote Address (not used with our flow control policy and reserved for
	// future use, use don't-care value)
	//
	((PAST_PARAM_ADDRESS*) pbCurrent)->code			= PAST_PARAMID_ADDRESS;
	((PAST_PARAM_ADDRESS*) pbCurrent)->len			= sizeof(PAST_PARAM_ADDRESS) - sizeof(PAST_PARAM);
	((PAST_PARAM_ADDRESS*) pbCurrent)->version		= PAST_ADDRESSTYPE_IPV4;
	((PAST_PARAM_ADDRESS*) pbCurrent)->addr			= PAST_ANY_ADDRESS;
	pbCurrent += sizeof (PAST_PARAM_ADDRESS);

	(*pbCurrent++)									= PAST_PARAMID_PORTS;
	*((WORD*) pbCurrent)							= sizeof(CHAR) + (sizeof(WORD) * cNumPorts);
	pbCurrent += 2;
	(*pbCurrent++)									= cNumPorts;
	//for(cTemp = 0; cTemp < cNumPorts; cTemp++)
	//{
	//	*((WORD*) pbCurrent) = NTOHS(PAST_ANY_PORT);
	//	pbCurrent += 2;
	//}
	pbCurrent += cNumPorts * sizeof(WORD);



	//
	// The following parameters are optional according to PAST spec.
	//

	//
	// Lease code, ask for what the user wants, but they shouldn't count on
	// getting that.
	//
	((PAST_PARAM_LEASE*) pbCurrent)->code			= PAST_PARAMID_LEASE;
	((PAST_PARAM_LEASE*) pbCurrent)->len			= sizeof(PAST_PARAM_LEASE) - sizeof(PAST_PARAM);
	((PAST_PARAM_LEASE*) pbCurrent)->leasetime		= dwLeaseTimeInSecs;
	pbCurrent += sizeof (PAST_PARAM_LEASE);

	//
	// Tunnel Type is IP-IP (PAST currently ignores it, actually).
	//
	((PAST_PARAM_TUNNELTYPE*) pbCurrent)->code			= PAST_PARAMID_TUNNELTYPE;
	((PAST_PARAM_TUNNELTYPE*) pbCurrent)->len			= sizeof(PAST_PARAM_TUNNELTYPE) - sizeof(PAST_PARAM);
	((PAST_PARAM_TUNNELTYPE*) pbCurrent)->tunneltype	= PAST_TUNNEL_IP_IP;
	pbCurrent += sizeof (PAST_PARAM_TUNNELTYPE);

	//
	// Message ID is optional, but we use it since we use UDP for a transport
	// it is required.
	//
	((PAST_PARAM_MESSAGEID*) pbCurrent)->code		= PAST_PARAMID_MESSAGEID;
	((PAST_PARAM_MESSAGEID*) pbCurrent)->len		= sizeof(PAST_PARAM_MESSAGEID) - sizeof(PAST_PARAM);
	((PAST_PARAM_MESSAGEID*) pbCurrent)->msgid		= dwMsgID;
	pbCurrent += sizeof (PAST_PARAM_MESSAGEID);


	//
	// The following parameters are vendor specific options.
	//

	//
	// Specify port type MS vendor option.
	//
	((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->code			= PAST_PARAMID_VENDOR;
	((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->len			= sizeof(PAST_PARAM_MSVENDOR_CODE) - sizeof(PAST_PARAM);
	((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->vendorid		= PAST_MS_VENDOR_ID;
	((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->option			= (pRegisteredPort->IsTCP()) ? PAST_VC_MS_TCP_PORT : PAST_VC_MS_UDP_PORT;
	pbCurrent += sizeof (PAST_PARAM_MSVENDOR_CODE);

	//
	// Specify no-tunneling MS vendor option.
	//
	((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->code			= PAST_PARAMID_VENDOR;
	((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->len			= sizeof(PAST_PARAM_MSVENDOR_CODE) - sizeof(PAST_PARAM);
	((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->vendorid		= PAST_MS_VENDOR_ID;
	((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->option			= PAST_VC_MS_NO_TUNNEL;
	pbCurrent += sizeof (PAST_PARAM_MSVENDOR_CODE);

	//
	// A shared UDP port listen type has an extra vendor option.
	//
	if (fSharedUDPListener)
	{
		((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->code		= PAST_PARAMID_VENDOR;
		((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->len		= sizeof(PAST_PARAM_MSVENDOR_CODE) - sizeof(PAST_PARAM);
		((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->vendorid	= PAST_MS_VENDOR_ID;
		((PAST_PARAM_MSVENDOR_CODE*) pbCurrent)->option		= PAST_VC_MS_SHARED_UDP_LISTENER;
		pbCurrent += sizeof (PAST_PARAM_MSVENDOR_CODE);
	}

	
	//
	// Send the message and get the reply.
	//
	hr = this->ExchangeAndParsePAST(pDevice->GetPASTSocket(),
									(SOCKADDR*) (&saddrinServerAddress),
									sizeof(saddrinServerAddress),
									(char *) pvRequest,
									dwMsgSize,
									dwMsgID,
									ptuRetry,
									&RespInfo);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Sending Assign/Listen Port request to server failed (err = 0x%lx)!", hr);
		goto Failure;
	}

	if ((RespInfo.cMsgType == PAST_MSGID_ERROR_RESPONSE) &&
		(RespInfo.wError == PASTERR_PORTUNAVAILABLE))
	{
		DPFX(DPFPREP, 1, "Couldn't assign/listen, port was unavailable.");
		hr = DPNHERR_PORTUNAVAILABLE;
		goto Failure;
	}

	if (((fListenRequest) && (RespInfo.cMsgType != PAST_MSGID_LISTEN_RESPONSE)) ||
		((! fListenRequest) && (RespInfo.cMsgType != PAST_MSGID_ASSIGN_RESPONSE_RSAP_IP)))
	{
		DPFX(DPFPREP, 0, "Got unexpected response type %u, failed assign/listen!", RespInfo.cMsgType);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Make sure the port count is valid.
	//
	if (RespInfo.cNumLocalPorts != cNumPorts)
	{
		DPFX(DPFPREP, 0, "PAST server returned an invalid number of local ports with success message (%u != %u)!  Assuming port unavailable.",
			RespInfo.cNumLocalPorts, cNumPorts);
		DNASSERTX(! "Why is PAST server returning bogus number of ports?", 2);
		hr = DPNHERR_PORTUNAVAILABLE;
		goto Failure;
	}


	//
	// Store the public address for the registered port, even if it's the
	// no-public-address address (0.0.0.0).
	//
	hr = pRegisteredPort->SetPASTPublicV4Addresses(RespInfo.dwLocalAddressV4,
													RespInfo.awLocalPorts,
													RespInfo.cNumLocalPorts,
													fRemote);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set requested mapping's public addresses!");
		goto Failure;
	}


	//
	// Remember the bind ID, actual lease time (convert back to milliseconds),
	// and address we were given.
	//
	pRegisteredPort->SetPASTBindID(RespInfo.dwBindID, fRemote);
	pRegisteredPort->SetPASTLeaseExpiration((timeGetTime() + (RespInfo.dwLeaseTime * 1000)),
											fRemote);

	//
	// Note whether this was the first lease or not.
	//
	fFirstLease = (this->m_dwNumLeases == 0) ? TRUE : FALSE;
	this->m_dwNumLeases++;

	DPFX(DPFPREP, 7, "%s PAST lease for 0x%p added, total num leases = %u.",
		((fRemote) ? _T("Remote") : _T("Local")), pRegisteredPort, this->m_dwNumLeases);


	//
	// We have different behavior whether the address is valid or not.
	//
	if (RespInfo.dwLocalAddressV4 == 0)
	{
		DPFX(DPFPREP, 1, "PAST server gave 0x%p an invalid address mapping for %u seconds (expires at %u).",
			pRegisteredPort, RespInfo.dwLeaseTime,
			pRegisteredPort->GetPASTLeaseExpiration(fRemote));

		//
		// If the mapping's IP address was zero, then we can't go handing it
		// around.
		//
		// Further, if any other ports were registered with the server, their
		// addresses are now all bogus as well, since it is assumed that the
		// server will always hand out the same address for all assignments.
		//
		if (pDevice->IsPASTPublicAddressAvailable(fRemote))
		{
			pDevice->NoteNoPASTPublicAddressAvailable(fRemote);

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();

			//
			// Any cached mappings could now be invalid.  Force future
			// re-queries to hit the network.
			//
			this->RemoveAllPASTCachedMappings(pDevice, fRemote);


			//
			// Loop through the existing registered port mappings and clear the
			// addresses.
			// We have the appropriate lock.
			//
			pBilink = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilink != &pDevice->m_blOwnedRegPorts)
			{
				pTempRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

				if (pTempRegisteredPort != pRegisteredPort)
				{
					if (pTempRegisteredPort->GetPASTBindID(fRemote) != 0)
					{
						DPFX(DPFPREP, 3, "Existing registered port mapping 0x%p is no longer valid.",
							pTempRegisteredPort);

						DNASSERT(! pTempRegisteredPort->IsPASTPortUnavailable(fRemote));
						DNASSERT(pTempRegisteredPort->HasPASTPublicAddressesArray(fRemote));
						DNASSERT(pTempRegisteredPort->IsFirstPASTPublicV4AddressDifferent(0, fRemote));

						//
						// Sorry, the address is gone.
						//
						pTempRegisteredPort->UpdatePASTPublicV4Addresses(RespInfo.dwLocalAddressV4,
																		fRemote);

						//
						// The user should call GetCaps to detect the address
						// change. Note that GetRegisteredAddresses will already be
						// returning NOMAPPING now, though.
						//
						this->m_dwFlags |= NATHELPPASTOBJ_ADDRESSESCHANGED;
					}
					else
					{
						DNASSERT(! pTempRegisteredPort->HasPASTPublicAddressesArray(fRemote));
					}
				}
				else
				{
					//
					// Skip the port we just registered.
					//
				}

				pBilink = pBilink->GetNext();
			}
		}
#ifdef DBG
		else
		{
			DPFX(DPFPREP, 7, "Still no public address for any ports.");


			//
			// Loop through the existing registered port mappings and make sure
			// they don't have addresses (debug only).
			// We have the appropriate lock.
			//
			pBilink = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilink != &pDevice->m_blOwnedRegPorts)
			{
				pTempRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

				if (pTempRegisteredPort->IsPASTPortUnavailable(fRemote))
				{
					DNASSERT(pTempRegisteredPort->GetPASTBindID(fRemote) == 0);
					DNASSERT(! pTempRegisteredPort->HasPASTPublicAddressesArray(fRemote));
				}
				else
				{
					//
					// Can't assert these things because we may not have tried
					// mapping this port yet.
					//
					/*
					DNASSERT(pTempRegisteredPort->GetPASTBindID(fRemote) != 0);
					DNASSERT(pTempRegisteredPort->HasPASTPublicAddressesArray(fRemote));
					DNASSERT(! (pTempRegisteredPort->IsFirstPASTPublicV4AddressDifferent(RespInfo.dwLocalAddressV4, fRemote)));
					*/
				}

				pBilink = pBilink->GetNext();
			}
		}
#endif // DBG
	}
	else
	{
		DPFX(DPFPREP, 2, "PAST server gave 0x%p a valid address mapping for %u seconds (expires at %u).",
			pRegisteredPort, RespInfo.dwLeaseTime,
			pRegisteredPort->GetPASTLeaseExpiration(fRemote));


		//
		// The server may have previously been handing back invalid mappings.
		// If any other ports were registered with the server that didn't get
		// mapped, those addresses are now valid as well, since it is assumed
		// that the server will will always hand out the same address for all
		// assignments.
		//
		if (! pDevice->IsPASTPublicAddressAvailable(fRemote))
		{
			pDevice->NotePASTPublicAddressAvailable(fRemote);

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();

			//
			// Any cached mappings could now be invalid.  Force future
			// re-queries to hit the network.
			//
			this->RemoveAllPASTCachedMappings(pDevice, fRemote);


			//
			// Loop through the existing registered port mappings and set the
			// addresses.
			// We have the appropriate lock.
			//
			pBilink = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilink != &pDevice->m_blOwnedRegPorts)
			{
				pTempRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

				if (pTempRegisteredPort != pRegisteredPort)
				{
					if (pTempRegisteredPort->GetPASTBindID(fRemote) != 0)
					{
						DPFX(DPFPREP, 3, "Existing registered port mapping 0x%p now has an address.",
							pTempRegisteredPort);

						DNASSERT(! pTempRegisteredPort->IsPASTPortUnavailable(fRemote));
						DNASSERT(pTempRegisteredPort->HasPASTPublicAddressesArray(fRemote));

						//
						// Woohoo, there's an address now.
						//
						pTempRegisteredPort->UpdatePASTPublicV4Addresses(RespInfo.dwLocalAddressV4,
																		fRemote);

						//
						// The user should call GetCaps to detect the address
						// change. Note that GetRegisteredAddresses will already be
						// returning the new addresses now, though.
						//
						this->m_dwFlags |= NATHELPPASTOBJ_ADDRESSESCHANGED;
					}
					else
					{
						DNASSERT(! pTempRegisteredPort->HasPASTPublicAddressesArray(fRemote));
					}
				}
				else
				{
					//
					// Skip the port we just registered.
					//
				}

				pBilink = pBilink->GetNext();
			}
		}
		else
		{
			//
			// We assume that the server will always hand out the same address
			// to every mapping.  Double check that if there's something in the
			// list already then it has the same IP address.  If not, the
			// address has changed.  Loop through the existing registered port
			// mappings and convert them to use the same address as was just
			// handed out.
			// We have the appropriate lock.
			//
			pBilink = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilink != &pDevice->m_blOwnedRegPorts)
			{
				pTempRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

				if (pTempRegisteredPort != pRegisteredPort)
				{
					if (pTempRegisteredPort->GetPASTBindID(fRemote) != 0)
					{
						DNASSERT(! pTempRegisteredPort->IsPASTPortUnavailable(fRemote));
						DNASSERT(pTempRegisteredPort->HasPASTPublicAddressesArray(fRemote));
						DNASSERT(pTempRegisteredPort->IsFirstPASTPublicV4AddressDifferent(0, fRemote));

						if (pTempRegisteredPort->IsFirstPASTPublicV4AddressDifferent(RespInfo.dwLocalAddressV4, fRemote))
						{
							DPFX(DPFPREP, 3, "Existing registered port mapping 0x%p differs from address just returned from PAST server.",
								pTempRegisteredPort);

							pTempRegisteredPort->UpdatePASTPublicV4Addresses(RespInfo.dwLocalAddressV4, fRemote);

							//
							// The user should call GetCaps to detect the address
							// change. Note that GetRegisteredAddresses will already be
							// returning the new addresses now, though.
							//
							this->m_dwFlags |= NATHELPPASTOBJ_ADDRESSESCHANGED;
						}
						else
						{
							//
							// Address is same.
							//
						}
					}
					else
					{
						DNASSERT(! pTempRegisteredPort->HasPASTPublicAddressesArray(fRemote));
					}
				}
				else
				{
					//
					// Skip the port we just registered.
					//
				}

				pBilink = pBilink->GetNext();
			}
		}
	}


	//
	// Remember this expiration time if it's the one that's going to expire
	// soonest.
	//
	if ((fFirstLease) ||
		((int) (pRegisteredPort->GetPASTLeaseExpiration(fRemote) - this->m_dwEarliestLeaseExpirationTime) < 0))
	{
		if (fFirstLease)
		{
			DPFX(DPFPREP, 1, "Registered port 0x%p's %s PAST lease is the first lease (expires at %u).",
				pRegisteredPort,
				((fRemote) ? _T("remote") : _T("local")),
				pRegisteredPort->GetPASTLeaseExpiration(fRemote));
		}
		else
		{
			DPFX(DPFPREP, 1, "Registered port 0x%p's %s PAST lease expires at %u which is earlier than the next earliest lease expiration (%u).",
				pRegisteredPort,
				((fRemote) ? _T("remote") : _T("local")),
				pRegisteredPort->GetPASTLeaseExpiration(fRemote),
				this->m_dwEarliestLeaseExpirationTime);
		}

		this->m_dwEarliestLeaseExpirationTime = pRegisteredPort->GetPASTLeaseExpiration(fRemote);


		//
		// Ping the event if there is one so that the user's GetCaps interval
		// doesn't miss this new, shorter lease.
		//
		if (this->m_hAlertEvent != NULL)
		{
			fResult = SetEvent(this->m_hAlertEvent);
#ifdef DBG
			if (! fResult)
			{
				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Couldn't set alert event 0x%p!  err = %u",
					this->m_hAlertEvent, dwError);

				//
				// Ignore failure...
				//
			}
#endif // DBG
		}


		//
		// Ping the I/O completion port if there is one so that the user's
		// GetCaps interval doesn't miss this new, shorter lease.
		//
		if (this->m_hAlertIOCompletionPort != NULL)
		{
			fResult = PostQueuedCompletionStatus(this->m_hAlertIOCompletionPort,
												0,
												this->m_dwAlertCompletionKey,
												NULL);
#ifdef DBG
			if (! fResult)
			{
				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Couldn't queue key %u on alert IO completion port 0x%p!  err = %u",
					this->m_dwAlertCompletionKey,
					this->m_hAlertIOCompletionPort,
					dwError);

				//
				// Ignore failure...
				//
			}
#endif // DBG
		}
	}


Exit:

	if (pvRequest != NULL)
	{
		DNFree(pvRequest);
		pvRequest = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// If we registered the port, de-register it.
	//
	if (pRegisteredPort->GetPASTBindID(fRemote) != 0)
	{
		temphr = this->FreePASTPort(pRegisteredPort, fRemote);
		if (temphr != DPNH_OK)
		{
			//
			// We'll treat this as non-fatal, but we have to dump the server.
			//
			this->ClearDevicesPASTServer(pRegisteredPort->GetOwningDevice(), fRemote);
		}
	}

	goto Exit;
} // CNATHelpPAST::AssignOrListenPASTPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::FreePASTPort"
//=============================================================================
// CNATHelpPAST::FreePASTPort
//-----------------------------------------------------------------------------
//
// Description:    Release a port mapping with the PAST server.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Pointer to port object mapping to
//											release.
//	BOOL fRemote						- TRUE if should free from remote
//											server, FALSE if freeing from local
//											server.
//
// Returns: HRESULT
//	DPNH_OK							- The release was successful.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the
//										message.
//=============================================================================
HRESULT CNATHelpPAST::FreePASTPort(CRegisteredPort * const pRegisteredPort,
									const BOOL fRemote)
{
	HRESULT					hr = DPNH_OK;
	CDevice *				pDevice;
	SOCKADDR_IN				saddrinServerAddress;
	DWORD					dwClientID;
	DWORD					dwMsgID;
	DWORD *					ptuRetry;
	PAST_MSG_FREE_REQUEST	FreeReq;
	PAST_RESPONSE_INFO		RespInfo;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)",
		this, pRegisteredPort, fRemote);


	DNASSERT(pRegisteredPort != NULL);

	pDevice = pRegisteredPort->GetOwningDevice();
	DNASSERT(pDevice != NULL);

	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);
	DNASSERT(pDevice->GetPASTSocket() != INVALID_SOCKET);


	//
	// Create a SOCKADDR to address the PAST service, and get the appropriate
	// client ID, initial retry timeout, and next message ID to use.
	//
	ZeroMemory(&saddrinServerAddress, sizeof(saddrinServerAddress));
	saddrinServerAddress.sin_family					= AF_INET;
	saddrinServerAddress.sin_port					= HTONS(PAST_HOST_PORT);

	if (fRemote)
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetRemotePASTServerAddressV4();
		dwMsgID = pDevice->GetNextRemotePASTMsgID();
		ptuRetry = pDevice->GetRemotePASTRetryTimeoutPtr();
	}
	else
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
		dwMsgID = pDevice->GetNextLocalPASTMsgID();
		ptuRetry = pDevice->GetLocalPASTRetryTimeoutPtr();
	}

	dwClientID = pDevice->GetPASTClientID(fRemote);
	DNASSERT(dwClientID != 0);


	//
	// Build the request message.
	//

	ZeroMemory(&FreeReq, sizeof(FreeReq));
	FreeReq.version				= PAST_VERSION;
	FreeReq.command				= PAST_MSGID_FREE_REQUEST;

	FreeReq.clientid.code		= PAST_PARAMID_CLIENTID;
	FreeReq.clientid.len		= sizeof(FreeReq.clientid) - sizeof(PAST_PARAM);
	FreeReq.clientid.clientid	= dwClientID;

	FreeReq.bindid.code			= PAST_PARAMID_BINDID;
	FreeReq.bindid.len			= sizeof(FreeReq.bindid) - sizeof(PAST_PARAM);
	FreeReq.bindid.bindid		= pRegisteredPort->GetPASTBindID(fRemote);

	FreeReq.msgid.code			= PAST_PARAMID_MESSAGEID;
	FreeReq.msgid.len			= sizeof(FreeReq.msgid) - sizeof(PAST_PARAM);
	FreeReq.msgid.msgid			= dwMsgID;


	//
	// Send the message and get the reply.
	//
	hr = this->ExchangeAndParsePAST(pDevice->GetPASTSocket(),
									(SOCKADDR*) (&saddrinServerAddress),
									sizeof(saddrinServerAddress),
									(char *) &FreeReq,
									sizeof(FreeReq),
									dwMsgID,
									ptuRetry,
									&RespInfo);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Freeing port mapping failed!");
		goto Failure;
	}

	if (RespInfo.cMsgType != PAST_MSGID_FREE_RESPONSE)
	{
		DPFX(DPFPREP, 0, "Got unexpected response type %u, failed freeing port mapping!", RespInfo.cMsgType);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	pRegisteredPort->SetPASTBindID(0, fRemote);
	pRegisteredPort->ClearPASTPublicAddresses(fRemote);


	//
	// One more lease is gone.
	//
	DNASSERT(this->m_dwNumLeases > 0);
	this->m_dwNumLeases--;

	DPFX(DPFPREP, 7, "%s PAST lease for 0x%p removed, total num leases = %u.",
		((fRemote) ? _T("Remote") : _T("Local")), pRegisteredPort, this->m_dwNumLeases);


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::FreePASTPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::InternalPASTQueryAddress"
//=============================================================================
// CNATHelpPAST::InternalPASTQueryAddress
//-----------------------------------------------------------------------------
//
// Description:    Queries a port mapping with the PAST server.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice						- Pointer to device whose PAST
//												server should be queried.
//	SOCKADDR_IN * psaddrinQueryAddress		- Address to look up.
//	SOCKADDR_IN * psaddrinResponseAddress	- Place to store public address, if
//												one exists.
//	DWORD dwFlags							- Flags to use when querying.
//	BOOL fRemote							- TRUE if querying remote, FALSE 
//												querying local server.
//
// Returns: HRESULT
//	DPNH_OK							- The query was successful.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_NOMAPPING				- The server did not have a mapping for the
//										given address.
//	DPNHERR_NOMAPPINGBUTPRIVATE		- The server indicated that no mapping
//										exists, but the address is private.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the
//										message.
//=============================================================================
HRESULT CNATHelpPAST::InternalPASTQueryAddress(CDevice * const pDevice,
												const SOCKADDR_IN * const psaddrinQueryAddress,
												SOCKADDR_IN * const psaddrinResponseAddress,
												const DWORD dwFlags,
												const BOOL fRemote)
{
	HRESULT							hr;
	CBilink *						pblCachedMaps;
	DWORD							dwCurrentTime;
	CBilink *						pBilink;
	CCacheMap *						pCacheMap;
	SOCKADDR_IN						saddrinServerAddress;
	DWORD							dwClientID;
	DWORD							dwMsgID;
	DWORD *							ptuRetry;
	PAST_MSG_QUERY_REQUEST_PORTS	QueryReq;
	PAST_RESPONSE_INFO				RespInfo;
	DWORD							dwCacheMapFlags;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, 0x%lx, %i)",
		this, pDevice, psaddrinQueryAddress, psaddrinResponseAddress,
		dwFlags, fRemote);


	DNASSERT(pDevice != NULL);
	DNASSERT(psaddrinQueryAddress != NULL);
	DNASSERT(psaddrinResponseAddress != NULL);

	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);
	DNASSERT(pDevice->GetPASTSocket() != INVALID_SOCKET);


	DPFX(DPFPREP, 7, "Querying for address %u.%u.%u.%u:%u %s.",
		psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b1,
		psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b2,
		psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b3,
		psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b4,
		NTOHS(psaddrinQueryAddress->sin_port),
		((dwFlags & DPNHQUERYADDRESS_TCP) ? _T("TCP") : _T("UDP")));

	
	//
	// First, check if we've looked this address up recently and already have
	// the result cached.
	// The lock is already held.
	//
	pblCachedMaps = pDevice->GetPASTCachedMaps(fRemote);
	dwCurrentTime = timeGetTime();

	pBilink = pblCachedMaps->GetNext();
	while (pBilink != pblCachedMaps)
	{
		pCacheMap = CACHEMAP_FROM_BILINK(pBilink);
		pBilink = pBilink->GetNext();


		//
		// Make sure this cached mapping hasn't expired.
		//
		if ((int) (pCacheMap->GetExpirationTime() - dwCurrentTime) < 0)
		{
			DPFX(DPFPREP, 5, "Cached mapping 0x%p has expired.", pCacheMap);

			pCacheMap->m_blList.RemoveFromList();
			delete pCacheMap;
		}
		else
		{
			//
			// If this mapping is for the right address and type of address,
			// then we've already got our answer.
			//
			if (pCacheMap->DoesMatchQuery(psaddrinQueryAddress, dwFlags))
			{
				if (pCacheMap->IsNotFound())
				{
					if ((dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED) &&
						(pCacheMap->IsPrivateButUnmapped()))
					{
						DPFX(DPFPREP, 5, "Address was already determined to not have a mapping but still be private.");
						hr = DPNHERR_NOMAPPINGBUTPRIVATE;
					}
					else
					{
						DPFX(DPFPREP, 5, "Address was already determined to not have a mapping.");
						hr = DPNHERR_NOMAPPING;
					}
				}
				else
				{
					pCacheMap->GetResponseAddressV4(psaddrinResponseAddress);

					DPFX(DPFPREP, 5, "Address was already determined to have a mapping.");
					hr = DPNH_OK;
				}

				goto Exit;
			}
		}
	}


	dwCacheMapFlags = QUERYFLAGSMASK(dwFlags);

	//
	// If we're here, we haven't already cached the answer.
	//
	// Create a SOCKADDR to address the PAST service, and get the appropriate
	// client ID, initial retry timeout, and next message ID to use.
	//
	ZeroMemory(&saddrinServerAddress, sizeof(saddrinServerAddress));
	saddrinServerAddress.sin_family					= AF_INET;
	saddrinServerAddress.sin_port					= HTONS(PAST_HOST_PORT);

	if (fRemote)
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetRemotePASTServerAddressV4();
		dwMsgID = pDevice->GetNextRemotePASTMsgID();
		ptuRetry = pDevice->GetRemotePASTRetryTimeoutPtr();
	}
	else
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
		dwMsgID = pDevice->GetNextLocalPASTMsgID();
		ptuRetry = pDevice->GetLocalPASTRetryTimeoutPtr();
	}

	dwClientID = pDevice->GetPASTClientID(fRemote);
	DNASSERT(dwClientID != 0);


	//
	// Build the request message for asking the server.
	//

	ZeroMemory(&QueryReq, sizeof(QueryReq));
	QueryReq.version			= PAST_VERSION;
	QueryReq.command			= PAST_MSGID_QUERY_REQUEST;

	QueryReq.clientid.code		= PAST_PARAMID_CLIENTID;
	QueryReq.clientid.len		= sizeof(QueryReq.clientid) - sizeof(PAST_PARAM);
	QueryReq.clientid.clientid	= dwClientID;

	QueryReq.address.code		= PAST_PARAMID_ADDRESS;
	QueryReq.address.len		= sizeof(QueryReq.address) - sizeof(PAST_PARAM);
	QueryReq.address.version	= PAST_ADDRESSTYPE_IPV4;
	QueryReq.address.addr		= psaddrinQueryAddress->sin_addr.s_addr;

	//
	// NOTE: Ports appeared to be transferred in x86 format, contrary to
	// the spec, which says network byte order.
	//
	QueryReq.port.code			= PAST_PARAMID_PORTS;
	QueryReq.port.len			= sizeof(QueryReq.port) - sizeof(PAST_PARAM);
	QueryReq.port.nports		= 1;
	QueryReq.port.port			= NTOHS(psaddrinQueryAddress->sin_port);

	QueryReq.porttype.code		= PAST_PARAMID_VENDOR;
	QueryReq.porttype.len		= sizeof(QueryReq.porttype) - sizeof(PAST_PARAM);
	QueryReq.porttype.vendorid	= PAST_MS_VENDOR_ID;
	QueryReq.porttype.option	= (dwFlags & DPNHQUERYADDRESS_TCP) ? PAST_VC_MS_TCP_PORT : PAST_VC_MS_UDP_PORT;

	QueryReq.querytype.code		= PAST_PARAMID_VENDOR;
	QueryReq.querytype.len		= sizeof(QueryReq.querytype) - sizeof(PAST_PARAM);
	QueryReq.querytype.vendorid	= PAST_MS_VENDOR_ID;
	QueryReq.querytype.option	= PAST_VC_MS_QUERY_MAPPING;

	QueryReq.msgid.code			= PAST_PARAMID_MESSAGEID;
	QueryReq.msgid.len			= sizeof(QueryReq.msgid) - sizeof(PAST_PARAM);
	QueryReq.msgid.msgid		= dwMsgID;

	//
	// Send the message and get the reply.
	//
	hr = this->ExchangeAndParsePAST(pDevice->GetPASTSocket(),
									(SOCKADDR*) (&saddrinServerAddress),
									sizeof(saddrinServerAddress),
									(char *) &QueryReq,
									sizeof(QueryReq),
									dwMsgID,
									ptuRetry,
									&RespInfo);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Querying port mapping failed!");
		goto Failure;
	}

	if (RespInfo.cMsgType != PAST_MSGID_QUERY_RESPONSE)
	{
		//
		// We got something, but it's not the right response.  Try determining
		// if the address is local, if allowed.
		//
		if (dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED)
		{
			//
			// If Personal Firewall is enabled, don't bother checking if the
			// address is local.  Anything on the other side of the firewall is
			// considered non-local.
			//
			if ((pDevice->GetPASTClientID(FALSE) == 0) ||
				(! pDevice->HasLocalPFWOnlyPASTServer()))
			{
				if (this->IsAddressLocal(pDevice, psaddrinQueryAddress))
				{
					DPFX(DPFPREP, 5, "Address appears to be local, returning NOMAPPINGBUTPRIVATE.");

					dwCacheMapFlags |= CACHEMAPOBJ_PRIVATEBUTUNMAPPED;

					hr = DPNHERR_NOMAPPINGBUTPRIVATE;
				}
				else
				{
					DPFX(DPFPREP, 5, "Address does not appear to be local, returning NOMAPPING.");

					hr = DPNHERR_NOMAPPING;
				}
			}
			else
			{
				DPFX(DPFPREP, 5, "Device 0x%p has Personal Firewall enabled, not checking address locality and returning NOMAPPING.");

				hr = DPNHERR_NOMAPPING;
			}
		}
		else
		{
			DPFX(DPFPREP, 1, "Got non-success response type %u while querying port mapping, assuming does not exist.", RespInfo.cMsgType);
			hr = DPNHERR_NOMAPPING;
		}


		//
		// Cache the fact that we could not determine a mapping for that
		// address, if allowed.
		//
		if (dwFlags & DPNHQUERYADDRESS_CACHENOTFOUND)
		{
			pCacheMap = new CCacheMap(psaddrinQueryAddress,
									(GETTIMESTAMP() + g_dwCacheLifeNotFound),
									(dwCacheMapFlags | CACHEMAPOBJ_NOTFOUND));
			if (pCacheMap == NULL)
			{
				hr = DPNHERR_OUTOFMEMORY;
				goto Failure;
			}

			pCacheMap->m_blList.InsertBefore(pblCachedMaps);
		}

		goto Failure;
	}


	//
	// Make sure the port count is valid.
	//
	if (RespInfo.cNumLocalPorts != 1)
	{
		DPFX(DPFPREP, 0, "PAST server returned an invalid number of local ports with success message (%u)!  Assuming no mapping.",
			RespInfo.cNumLocalPorts);
		DNASSERTX(! "Why is PAST server returning bogus number of ports?", 2);
		hr = DPNHERR_NOMAPPING;
		goto Failure;
	}
	

	//
	// Convert the loopback address to the device address.
	//
	if (RespInfo.dwLocalAddressV4 == NETWORKBYTEORDER_INADDR_LOOPBACK)
	{
		RespInfo.dwLocalAddressV4 = pDevice->GetLocalAddressV4();

		DPFX(DPFPREP, 1, "Converted loopback address to device address (%u.%u.%u.%u).",
			((IN_ADDR*) (&RespInfo.dwLocalAddressV4))->S_un.S_un_b.s_b1,
			((IN_ADDR*) (&RespInfo.dwLocalAddressV4))->S_un.S_un_b.s_b2,
			((IN_ADDR*) (&RespInfo.dwLocalAddressV4))->S_un.S_un_b.s_b3,
			((IN_ADDR*) (&RespInfo.dwLocalAddressV4))->S_un.S_un_b.s_b4);
	}

	//
	// Ensure that we're not getting something bogus.  Use saddrinServerAddress
	// as a temporary variable.
	//
	saddrinServerAddress.sin_addr.S_un.S_addr = RespInfo.dwLocalAddressV4;
	if ((RespInfo.dwLocalAddressV4 == 0) ||
		(RespInfo.awLocalPorts[0] == 0) ||
		(! this->IsAddressLocal(pDevice, &saddrinServerAddress)))
	{
		DPFX(DPFPREP, 0, "PAST server returned an invalid private address (%u.%u.%u.%u:%u)!  Assuming no mapping.",
			((IN_ADDR*) (&RespInfo.dwLocalAddressV4))->S_un.S_un_b.s_b1,
			((IN_ADDR*) (&RespInfo.dwLocalAddressV4))->S_un.S_un_b.s_b2,
			((IN_ADDR*) (&RespInfo.dwLocalAddressV4))->S_un.S_un_b.s_b3,
			((IN_ADDR*) (&RespInfo.dwLocalAddressV4))->S_un.S_un_b.s_b4,
			NTOHS(RespInfo.awLocalPorts[0]));
		DNASSERTX(! "Why is PAST server returning invalid private address?", 2);
		hr = DPNHERR_NOMAPPING;
		goto Failure;
	}


	//
	// Return the address mapping to our caller.
	//
	ZeroMemory(psaddrinResponseAddress, sizeof(SOCKADDR_IN));
	psaddrinResponseAddress->sin_family			= AF_INET;
	psaddrinResponseAddress->sin_addr.s_addr	= RespInfo.dwLocalAddressV4;
	psaddrinResponseAddress->sin_port			= RespInfo.awLocalPorts[0];

	//
	// Cache the fact that we found a mapping for that address, if allowed.
	//
	if (dwFlags & DPNHQUERYADDRESS_CACHEFOUND)
	{
		pCacheMap = new CCacheMap(psaddrinQueryAddress,
								(GETTIMESTAMP() + g_dwCacheLifeFound),
								dwCacheMapFlags);
		if (pCacheMap == NULL)
		{
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}

		pCacheMap->SetResponseAddressV4(RespInfo.dwLocalAddressV4,
										RespInfo.awLocalPorts[0]);

		pCacheMap->m_blList.InsertBefore(pblCachedMaps);
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::InternalPASTQueryAddress




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::ExtendPASTLease"
//=============================================================================
// CNATHelpPAST::ExtendPASTLease
//-----------------------------------------------------------------------------
//
// Description:    Asks the PAST server to extend a port mapping lease.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Pointer to port object mapping to
//											extend.
//	BOOL fRemote						- TRUE if extending on remote server,
//											FALSE if extending on local server.
//
// Returns: HRESULT
//	DPNH_OK							- The extension was successful.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the
//										message.
//=============================================================================
HRESULT CNATHelpPAST::ExtendPASTLease(CRegisteredPort * const pRegisteredPort,
									const BOOL fRemote)
{
	HRESULT						hr = DPNH_OK;
	CDevice *					pDevice;
	SOCKADDR_IN					saddrinServerAddress;
	DWORD						dwClientID;
	DWORD						dwMsgID;
	DWORD *						ptuRetry;
	PAST_MSG_EXTEND_REQUEST		ExtendReq;
	PAST_RESPONSE_INFO			RespInfo;
	BOOL						fResult;
#ifdef DBG
	DWORD						dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)",
		this, pRegisteredPort, fRemote);


	DNASSERT(pRegisteredPort != NULL);

	pDevice = pRegisteredPort->GetOwningDevice();
	DNASSERT(pDevice != NULL);

	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);
	DNASSERT(pDevice->GetPASTSocket() != INVALID_SOCKET);


	//
	// Create a SOCKADDR to address the PAST service, and get the appropriate
	// client ID, initial retry timeout, and next message ID to use.
	//
	ZeroMemory(&saddrinServerAddress, sizeof(saddrinServerAddress));
	saddrinServerAddress.sin_family					= AF_INET;
	saddrinServerAddress.sin_port					= HTONS(PAST_HOST_PORT);

	if (fRemote)
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetRemotePASTServerAddressV4();
		dwMsgID = pDevice->GetNextRemotePASTMsgID();
		ptuRetry = pDevice->GetRemotePASTRetryTimeoutPtr();
	}
	else
	{
		saddrinServerAddress.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
		dwMsgID = pDevice->GetNextLocalPASTMsgID();
		ptuRetry = pDevice->GetLocalPASTRetryTimeoutPtr();
	}

	dwClientID = pDevice->GetPASTClientID(fRemote);
	DNASSERT(dwClientID != 0);


	//
	// Build the request message.
	//

	ZeroMemory(&ExtendReq, sizeof(ExtendReq));
	ExtendReq.version			= PAST_VERSION;
	ExtendReq.command			= PAST_MSGID_EXTEND_REQUEST;

	ExtendReq.clientid.code		= PAST_PARAMID_CLIENTID;
	ExtendReq.clientid.len		= sizeof(ExtendReq.clientid) - sizeof(PAST_PARAM);
	ExtendReq.clientid.clientid	= dwClientID;

	ExtendReq.bindid.code		= PAST_PARAMID_BINDID;
	ExtendReq.bindid.len		= sizeof(DWORD);
	ExtendReq.bindid.bindid		= pRegisteredPort->GetPASTBindID(fRemote);

	//
	// Lease code, ask for what the user wants, but they shouldn't count on
	// getting that.
	// Convert the request (in milliseconds) to PAST's time unit (in seconds).
	//
	ExtendReq.lease.code		= PAST_PARAMID_LEASE;
	ExtendReq.lease.len			= sizeof(ExtendReq.lease) - sizeof(PAST_PARAM);
	ExtendReq.lease.leasetime	= pRegisteredPort->GetRequestedLeaseTime() / 1000;


	ExtendReq.msgid.code		= PAST_PARAMID_MESSAGEID;
	ExtendReq.msgid.len			= sizeof(ExtendReq.msgid) - sizeof(PAST_PARAM);
	ExtendReq.msgid.msgid		= dwMsgID;


	
	//
	// Send the message and get the reply.
	//
	hr = this->ExchangeAndParsePAST(pDevice->GetPASTSocket(),
									(SOCKADDR*) (&saddrinServerAddress),
									sizeof(saddrinServerAddress),
									(char *) &ExtendReq,
									sizeof(ExtendReq),
									dwMsgID,
									ptuRetry,
									&RespInfo);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Sending port lease extension request to server failed!");
		goto Failure;
	}

	if (RespInfo.cMsgType != PAST_MSGID_EXTEND_RESPONSE)
	{
		DPFX(DPFPREP, 0, "Got unexpected response type %u, failed port lease extension!", RespInfo.cMsgType);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Note the lease time extension (which is in seconds).  It had better be
	// longer than our auto-extension rate.  We use it to extend the current
	// lease expiration (which is in milliseconds).
	//

	DNASSERT((RespInfo.dwLeaseTime * 1000) > LEASE_RENEW_TIME);
	pRegisteredPort->SetPASTLeaseExpiration((timeGetTime() + (RespInfo.dwLeaseTime * 1000)),
											fRemote);
	
	DPFX(DPFPREP, 8, "Extended lease (registered port = 0x%p) to %u seconds from now, expires at %u.",
		pRegisteredPort, RespInfo.dwLeaseTime,
		pRegisteredPort->GetPASTLeaseExpiration(fRemote));


	//
	// Remember this expiration time if it's the one that's going to expire
	// soonest.
	//
	DNASSERT(this->m_dwNumLeases > 0);
	if ((int) (pRegisteredPort->GetPASTLeaseExpiration(fRemote) - this->m_dwEarliestLeaseExpirationTime) < 0)
	{
		DPFX(DPFPREP, 1, "Registered port 0x%p's %s PAST lease expires at %u which is earlier than the next earliest lease expiration (%u).",
			pRegisteredPort,
			((fRemote) ? _T("remote") : _T("local")),
			pRegisteredPort->GetPASTLeaseExpiration(fRemote),
			this->m_dwEarliestLeaseExpirationTime);

		this->m_dwEarliestLeaseExpirationTime = pRegisteredPort->GetPASTLeaseExpiration(fRemote);


		//
		// Ping the event if there is one so that the user's GetCaps interval
		// doesn't miss this new, shorter lease.
		//
		if (this->m_hAlertEvent != NULL)
		{
			fResult = SetEvent(this->m_hAlertEvent);
#ifdef DBG
			if (! fResult)
			{
				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Couldn't set alert event 0x%p!  err = %u",
					this->m_hAlertEvent, dwError);

				//
				// Ignore failure...
				//
			}
#endif // DBG
		}


		//
		// Ping the I/O completion port if there is one so that the user's
		// GetCaps interval doesn't miss this new, shorter lease.
		//
		if (this->m_hAlertIOCompletionPort != NULL)
		{
			fResult = PostQueuedCompletionStatus(this->m_hAlertIOCompletionPort,
												0,
												this->m_dwAlertCompletionKey,
												NULL);
#ifdef DBG
			if (! fResult)
			{
				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Couldn't queue key %u on alert IO completion port 0x%p!  err = %u",
					this->m_dwAlertCompletionKey,
					this->m_hAlertIOCompletionPort,
					dwError);

				//
				// Ignore failure...
				//
			}
#endif // DBG
		}
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::ExtendPASTLease





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::UpdatePASTPublicAddressValidity"
//=============================================================================
// CNATHelpPAST::UpdatePASTPublicAddressValidity
//-----------------------------------------------------------------------------
//
// Description:    Checks to see if the given device's PAST server is handing
//				out valid public addresses or not.
//
//				   The PAST server information might be cleared if a failure
//				occurs.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device that should be checked.
//	BOOL fRemote		- Whether the local or remote PAST server should be
//							checked.
//
// Returns: HRESULT
//	DPNH_OK				- The update was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::UpdatePASTPublicAddressValidity(CDevice * const pDevice,
													const BOOL fRemote)
{
	HRESULT				hr;
	SOCKADDR_IN			saddrinTemp;
	CRegisteredPort *	pTempRegisteredPort = NULL;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)",
		this, pDevice, fRemote);

	//
	// Create a temporary port mapping object.  We mark it as "local PAST port
	// unavailable" when checking remove PAST servers because we have not and
	// will not attempt to map the local port when there is a local PAST
	// server.  Since AssignOrListenPASTPort assumes the local port will have
	// been mapped first, we need to prevent it from trying to use that address
	// and crashing.
	//
	pTempRegisteredPort = new CRegisteredPort(FAKE_PORT_LEASE_TIME,
												((fRemote) ? REGPORTOBJ_PORTUNAVAILABLE_PAST_LOCAL : 0));
	if (pTempRegisteredPort == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	pTempRegisteredPort->MakeDeviceOwner(pDevice);


	//
	// Pick an arbitrary port value to map.  In this case, we should just use
	// the socket we're using for Ioctl communication, since that port is
	// guaranteed to be unique by WinSock (so no multi-PASTHelp-instance race
	// conditions like if we had used a hardcoded temporary port).
	// One difference: the Ioctl socket is bound to INADDR_ANY, but we'll use
	// the specific device address so our ICS vs. PFW-only address comparison
	// below works correctly.  This shouldn't make a difference, since a port
	// in use by INADDR_ANY should be the same as the same port in use on each
	// of the adapters.
	//
	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family				= AF_INET;
	saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
	saddrinTemp.sin_port				= this->m_wIoctlSocketPort;


	//
	// Assign it the communication socket's address.
	//
	hr = pTempRegisteredPort->SetPrivateAddresses(&saddrinTemp, 1);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set temporary private addresses!");
		goto Failure;
	}


	DPFX(DPFPREP, 7, "Temporarily assigning port %u.%u.%u.%u:%u to check server status.",
		saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
		saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
		saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
		saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
		NTOHS(this->m_wIoctlSocketPort));

	//
	// Attempt to map it.  AssignOrListenPASTPort will handle the actual logic
	// of changing addresses.
	//
	hr = this->AssignOrListenPASTPort(pTempRegisteredPort, fRemote);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't assign temporary port mapping with server (0x%lx)!  Ignoring.", hr);

		//
		// We'll treat this as non-fatal, but we'll dump the server.
		//
		this->ClearDevicesPASTServer(pDevice, fRemote);
		hr = DPNH_OK;
	}
	else
	{
		//
		// If we're checking the local server, determine whether it's a local ICS
		// server or it's Personal Firewall only.
		//
		if (! fRemote)
		{
			//
			// If public address is the same, it's PFW only, if it's different,
			// it's ICS (although that could be PFWed, too).  If there's no
			// public address, then we can't really tell.  It should be safe to
			// assume that it's ICS, since this device must have an address or
			// else it wouldn't exist.
			//
			if ((! pDevice->IsPASTPublicAddressAvailable(FALSE)) ||
				(pTempRegisteredPort->IsFirstPASTPublicV4AddressDifferent(saddrinTemp.sin_addr.S_un.S_addr, FALSE)))
			{
#ifdef DBG
				if (! pDevice->IsPASTPublicAddressAvailable(FALSE))
				{
					DPFX(DPFPREP, 2, "Device %u.%u.%u.%u (object = 0x%p) doesn't have public address, assuming ICS.",
						saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
						pDevice);
				}
				else
				{
					SOCKADDR_IN *	pasaddrinPublic;
					

					pasaddrinPublic = pTempRegisteredPort->GetPASTPublicAddressesArray(FALSE);
					DPFX(DPFPREP, 2, "Device %u.%u.%u.%u (object = 0x%p) has different public address (%u.%u.%u.%u), appears to be ICS.",
						saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
						pDevice,
						pasaddrinPublic[0].sin_addr.S_un.S_un_b.s_b1,
						pasaddrinPublic[0].sin_addr.S_un.S_un_b.s_b2,
						pasaddrinPublic[0].sin_addr.S_un.S_un_b.s_b3,
						pasaddrinPublic[0].sin_addr.S_un.S_un_b.s_b4);
				}
#endif // DBG

				pDevice->NoteLocalPASTServerIsICS();
			}
			else
			{
				DPFX(DPFPREP, 2, "Device %u.%u.%u.%u (object = 0x%p) has same public address, appears to be firewall only.",
					saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
					pDevice);

				pDevice->NoteLocalPASTServerIsPFWOnly();
			}
		}
		else
		{
			//
			// A remote PAST server.
			//
		}


		//
		// Free the temporary port, because we don't need it.
		//
		hr = this->FreePASTPort(pTempRegisteredPort, fRemote);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't free temporary port mapping (0x%lx)!", hr);

			//
			// We'll treat this as non-fatal, but we have to drop the PAST
			// server.
			//
			this->ClearDevicesPASTServer(pDevice, fRemote);
			hr = DPNH_OK;
		}
	}

	//
	// If we're here we either never mapped the temporary port, explicitly
	// freed the port, or deregistered (which implies freeing the port).  So
	// we're done with the object.
	//
	pTempRegisteredPort->ClearDeviceOwner();
	pTempRegisteredPort->ClearPrivateAddresses();
	delete pTempRegisteredPort;
	pTempRegisteredPort = NULL;



Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pTempRegisteredPort != NULL)
	{
		delete pTempRegisteredPort;
	}

	goto Exit;
} // CNATHelpPAST::UpdatePASTPublicAddressValidity





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::RegisterAllPortsWithPAST"
//=============================================================================
// CNATHelpPAST::RegisterAllPortsWithPAST
//-----------------------------------------------------------------------------
//
// Description:    Registers all ports owned by the given device with the PAST
//				server.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device whose ports should be registered.
//	BOOL fRemote		- TRUE if registering on remote server, FALSE if
//							registering on local server.
//
// Returns: HRESULT
//	DPNH_OK				- The extension was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::RegisterAllPortsWithPAST(CDevice * const pDevice,
												const BOOL fRemote)
{
	HRESULT				hr = DPNH_OK;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)",
		this, pDevice, fRemote);


	DNASSERT(pDevice != NULL);
	DNASSERT(pDevice->GetPASTSocket() != INVALID_SOCKET);


	pBilink = pDevice->m_blOwnedRegPorts.GetNext();
	while (pBilink != &pDevice->m_blOwnedRegPorts)
	{
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

		DNASSERT(pRegisteredPort->GetPASTBindID(fRemote) == 0);


		hr = this->AssignOrListenPASTPort(pRegisteredPort, fRemote);
		if (hr != DPNH_OK)
		{
			if (hr != DPNHERR_PORTUNAVAILABLE)
			{
				DPFX(DPFPREP, 0, "Couldn't assign port mapping with server (0x%lx)!  Ignoring.", hr);

				//
				// We'll treat this as non-fatal, but we have to dump the
				// server and bail out of here.
				//
				this->ClearDevicesPASTServer(pDevice, fRemote);
				hr = DPNH_OK;
				goto Exit;
			}


			//
			// Uh oh, the server couldn't register one of the ports!  We don't
			// have a way of directly informing the user now.  We'll have to
			// mark the port and continue.
			//
			DPFX(DPFPREP, 1, "Server indicated that the port was unavailable.");
			pRegisteredPort->NotePASTPortUnavailable(fRemote);
			hr = DPNH_OK;
		}
		else
		{
			//
			// Hey, this now has an address.
			//
			DPFX(DPFPREP, 2, "Previously registered port 0x%p now has a %s PAST server public address.",
				pRegisteredPort, ((fRemote) ? _T("remote") : _T("local")));
			this->m_dwFlags |= NATHELPPASTOBJ_ADDRESSESCHANGED;
		}

		pBilink = pBilink->GetNext();
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CNATHelpPAST::RegisterAllPortsWithPAST





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::RegisterPreviouslyUnownedPortsWithDevice"
//=============================================================================
// CNATHelpPAST::RegisterPreviouslyUnownedPortsWithDevice
//-----------------------------------------------------------------------------
//
// Description:    Associates unknown ports with the given device, and
//				registers them with the device's PAST server(s).
//
//				   If fWildcardToo is FALSE, only previously unowned ports that
//				match the device's address are associated.  If TRUE, unowned
//				INADDR_ANY ports are associated as well.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device to take ownership of ports.
//	BOOL fAll			- Whether all ports should be associated.
//
// Returns: HRESULT
//	DPNH_OK				- The extension was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::RegisterPreviouslyUnownedPortsWithDevice(CDevice * const pDevice,
																const BOOL fWildcardToo)
{
	HRESULT				hr = DPNH_OK;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;
	SOCKADDR_IN *		pasaddrinPrivate;
#ifdef DBG
	BOOL				fAssignedPort = FALSE;
	IN_ADDR				inaddrTemp;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)",
		this, pDevice, fWildcardToo);


	//
	// Loop through all unowned ports, assign them to the device if
	// appropriate, then register them.
	//
	pBilink = this->m_blUnownedPorts.GetNext();
	while (pBilink != &this->m_blUnownedPorts)
	{
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);
		pBilink = pBilink->GetNext();

		//
		// The registered port must match the device's address in order to
		// associate them.  If wildcards are allowed, then INADDR_ANY
		// registrations can be associated, too.
		//
		//
		// All addresses should be same (if there are more than one), so just
		// compare the first one in the array.
		//
		pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

		if (pasaddrinPrivate[0].sin_addr.S_un.S_addr != pDevice->GetLocalAddressV4())
		{
			if (pasaddrinPrivate[0].sin_addr.S_un.S_addr != INADDR_ANY)
			{
				DPFX(DPFPREP, 7, "Unowned registered port 0x%p private address %u.%u.%u.%u doesn't match device 0x%p's, skipping.",
					pRegisteredPort,
					pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b1,
					pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b2,
					pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b3,
					pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b4,
					pDevice);
				continue;
			}
			
#ifdef DBG
			inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();
#endif // DBG

			if (! fWildcardToo)
			{
#ifdef DBG
				DPFX(DPFPREP, 7, "Unowned registered port 0x%p (INADDR_ANY) not allowed to be associated with device 0x%p (address %u.%u.%u.%u), skipping.",
					pRegisteredPort,
					pDevice,
					inaddrTemp.S_un.S_un_b.s_b1,
					inaddrTemp.S_un.S_un_b.s_b2,
					inaddrTemp.S_un.S_un_b.s_b3,
					inaddrTemp.S_un.S_un_b.s_b4);
#endif // DBG

				continue;
			}

#ifdef DBG
			DPFX(DPFPREP, 7, "Unowned registered port 0x%p (INADDR_ANY) becoming associated with device 0x%p (address %u.%u.%u.%u).",
				pRegisteredPort,
				pDevice,
				inaddrTemp.S_un.S_un_b.s_b1,
				inaddrTemp.S_un.S_un_b.s_b2,
				inaddrTemp.S_un.S_un_b.s_b3,
				inaddrTemp.S_un.S_un_b.s_b4);
#endif // DBG
		}
		else
		{
			DPFX(DPFPREP, 7, "Unowned registered port 0x%p private address %u.%u.%u.%u matches device 0x%p's, associating.",
				pRegisteredPort,
				pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b1,
				pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b2,
				pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b3,
				pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b4,
				pDevice);

			//
			// The way it's currently implemented, all non-wildcard ports
			// should be registered before we even try to register the wildcard
			// ones.
			//
			DNASSERT(! fWildcardToo);
		}


		//
		// If we made it here, we can associate the port with the device.
		//


		pRegisteredPort->m_blDeviceList.RemoveFromList();
		pRegisteredPort->MakeDeviceOwner(pDevice);


		//
		// Attempt to automatically map it with the (new) local server, if
		// present.
		//
		if (pDevice->GetPASTClientID(FALSE) != 0)
		{
			hr = this->AssignOrListenPASTPort(pRegisteredPort, FALSE);
			if (hr != DPNH_OK)
			{
				if (hr != DPNHERR_PORTUNAVAILABLE)
				{
					DPFX(DPFPREP, 0, "Couldn't assign port mapping 0x%p with local server (0x%lx)!  Ignoring.",
						pRegisteredPort, hr);

					//
					// We'll treat this as non-fatal, but we have to dump the
					// server.
					//
					this->ClearDevicesPASTServer(pDevice, FALSE);
				}
				else
				{
					//
					// Uh oh, the server couldn't register one of the ports!
					// We don't have a way of directly informing the user now.
					// We'll have to mark the port and continue.
					//
					DPFX(DPFPREP, 1, "Local PAST server indicated that the port (0x%p) was unavailable.",
						pRegisteredPort);
					pRegisteredPort->NotePASTPortUnavailable(FALSE);
				}

				hr = DPNH_OK;
			}
			else
			{
				//
				// Ta da, user needs to note address mapping changes.
				//
				DPFX(DPFPREP, 1, "Previously unowned port 0x%p now bound to device object 0x%p and mapped locally.",
					pRegisteredPort, pDevice);

				this->m_dwFlags |= NATHELPPASTOBJ_ADDRESSESCHANGED;

#ifdef DBG
				fAssignedPort = TRUE;
#endif // DBG
			}
		}


		//
		// Attempt to automatically map it with the (new) remote PAST server,
		// if present.
		//
		if (pDevice->GetPASTClientID(TRUE) != 0)
		{
			hr = this->AssignOrListenPASTPort(pRegisteredPort, TRUE);
			if (hr != DPNH_OK)
			{
				if (hr != DPNHERR_PORTUNAVAILABLE)
				{
					DPFX(DPFPREP, 0, "Couldn't assign port mapping 0x%p with remote PAST server (0x%lx)!  Ignoring.",
						pRegisteredPort, hr);

					//
					// We'll treat this as non-fatal, but we have to dump the
					// server.
					//
					this->ClearDevicesPASTServer(pDevice, TRUE);
				}
				else
				{
					//
					// Uh oh, the server couldn't register one of the ports!
					// We don't have a way of directly informing the user now.
					// We'll have to mark the port and continue.
					//
					DPFX(DPFPREP, 1, "Remote PAST server indicated that the port (0x%p) was unavailable.",
						pRegisteredPort);
					pRegisteredPort->NotePASTPortUnavailable(TRUE);
				}

				hr = DPNH_OK;
			}
			else
			{
				//
				// Ta da, user needs to note address mapping changes.
				//
				DPFX(DPFPREP, 1, "Previously unowned port 0x%p now bound to device object 0x%p and mapped remotely.",
					pRegisteredPort, pDevice);

				this->m_dwFlags |= NATHELPPASTOBJ_ADDRESSESCHANGED;

#ifdef DBG
				fAssignedPort = TRUE;
#endif // DBG
			}
		}
	}


#ifdef DBG
	if (! fAssignedPort)
	{
		DPFX(DPFPREP, 1, "No unowned ports were bound to device object 0x%p.",
			pDevice);
	}
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CNATHelpPAST::RegisterPreviouslyUnownedPortsWithDevice





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::ExchangeAndParsePAST"
//=============================================================================
// CNATHelpPAST::ExchangeAndParsePAST
//-----------------------------------------------------------------------------
//
// Description:    Sends a message to the PAST server and waits for a response,
//				which is parsed into a PAST_RESPONSE_INFO buffer.  The message
//				will be continually retried at the current retry interval
//				unless ptuRetry == NULL, which indicates that this is the
//				initial message looking for a server, in which case it will be
//				tried twice over a second.  If there is no response,
//				DPNHERR_SERVERNOTRESPONDING is returned.
//
//				   Since there is almost no scenario where we don't immediately
//				need to know the response, there is no point in doing this
//				asynchronously.  The assumption is that a PAST server is
//				sufficiently local that long retries are not necessary.
//
// Arguments:
//	SOCKET sSocket					- Socket to use when sending.
//	SOCKADDR * psaddrServerAddress	- Pointer to address of server.
//	int iAddressesSize				- Size of psaddrServerAddress and
//										psaddrRecvAddress.
//	char * pcRequestBuffer			- Pointer to request message to send.
//	int iRequestBufferSize			- Size of request message.
//	DWORD dwMsgID					- ID of the message being sent (to
//										correlate responses).
//	DWORD * ptuRetry				- Pointer to current retry time value
//										(may be modified), or NULL if this is
//										an initial registration (a different
//										timer strategy is used).
//	PAST_RESPONSE_INFO * pRespInfo	- Pointer to structure that will be filled
//										in with values from the server's
//										response message.
//
// Returns: HRESULT
//	DPNH_OK							- The request and response were
//										successfully exchanged.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the message.
//=============================================================================
HRESULT CNATHelpPAST::ExchangeAndParsePAST(const SOCKET sSocket,
											const SOCKADDR * const psaddrServerAddress,
											const int iAddressesSize,
											const char * const pcRequestBuffer,
											const int iRequestBufferSize,
											const DWORD dwMsgID,
											DWORD * const ptuRetry,
											PAST_RESPONSE_INFO * const pRespInfo)
{
	HRESULT			hr = DPNH_OK;
	char			acRespBuffer[PAST_RESPONSE_BUFFER_SIZE];
	timeval			tv;
	FD_SET			fdsRead;
	DWORD			dwTriesRemaining;
	int				iReturn;
	SOCKADDR_IN		saddrinReceive;
	int				iRecvAddressSize = iAddressesSize;
	DWORD			dwError;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, %i, 0x%p, %i, %u, 0x%p, 0x%p)",
		this, sSocket, psaddrServerAddress, iAddressesSize, pcRequestBuffer,
		iRequestBufferSize, dwMsgID, ptuRetry, pRespInfo);


	DNASSERT(sSocket != INVALID_SOCKET);
	DNASSERT(psaddrServerAddress != NULL);
	DNASSERT(iAddressesSize == sizeof(SOCKADDR_IN));
	DNASSERT(pcRequestBuffer != NULL);
	DNASSERT(iRequestBufferSize != 0);
	DNASSERT(pRespInfo != NULL);

	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);


	ZeroMemory(pRespInfo, sizeof(*pRespInfo));
#ifdef DBG
	ZeroMemory(acRespBuffer, sizeof(acRespBuffer));
#endif // DBG


	if (ptuRetry == NULL)
	{
		//
		// On initial registration requests we try twice with a 250ms total
		// timeout.
		//
		tv.tv_usec	= PAST_CONNECT_RETRY_INTERVAL_US;
		tv.tv_sec	= 0;
		dwTriesRemaining = MAX_NUM_PAST_TRIES_CONNECT;
	}
	else
	{
		//
		// All normal traffic uses the current retry interval and a default
		// number of tries.
		//
		tv.tv_usec	= (*ptuRetry);
		tv.tv_sec	= 0;
		dwTriesRemaining = MAX_NUM_PAST_TRIES;
	}


	FD_ZERO(&fdsRead);
	FD_SET(sSocket, &fdsRead);



	//
	// First clear out any extraneous responses from previous communication.
	//
	while (this->m_pfnselect(0, &fdsRead, NULL, NULL, &s_tv0) != 0)
	{
		iReturn = this->m_pfnrecvfrom(sSocket,
									acRespBuffer,
									sizeof(acRespBuffer),
									0,
									(SOCKADDR*) (&saddrinReceive),
									&iRecvAddressSize);
		if ((iReturn == 0) || (iReturn == SOCKET_ERROR))
		{
			dwError = this->m_pfnWSAGetLastError();

			//
			// WSAENOBUFS means WinSock is out of memory.
			//
			if (dwError == WSAENOBUFS)
			{
				DPFX(DPFPREP, 0, "WinSock returned WSAENOBUFS while clearing incoming queue!");
				hr = DPNHERR_OUTOFMEMORY;
				goto Failure;
			}

			//
			// Ignore WSAECONNRESET, that's just WinSock's way of telling us
			// that the target actively refused a previous message we tried to
			// send.  Since we don't know which send WinSock means, we can't do
			// a whole lot about it.
			//
			if (dwError != WSAECONNRESET)
			{
				DPFX(DPFPREP, 0, "Got sockets error %u trying to receive (clearing incoming queue)!", dwError);
				hr = DPNHERR_GENERIC;
				goto Failure;
			}

			DPFX(DPFPREP, 2, "Ignoring CONNRESET while clearing incoming queue.");
		}
		else
		{
			//
			// If we got here, that means there's a message.
			//

#ifdef DBG
			DPFX(DPFPREP, 2, "Found extra response from previous PAST request (sent by %u.%u.%u.%u:%u), parsing for fun.",
				saddrinReceive.sin_addr.S_un.S_un_b.s_b1,
				saddrinReceive.sin_addr.S_un.S_un_b.s_b2,
				saddrinReceive.sin_addr.S_un.S_un_b.s_b3,
				saddrinReceive.sin_addr.S_un.S_un_b.s_b4,
				NTOHS(saddrinReceive.sin_port));

			//
			// For grins, let's see what this message is.  Ignore errors.
			//
			this->ParsePASTMessage(acRespBuffer, iReturn, pRespInfo);
			ZeroMemory(pRespInfo, sizeof(*pRespInfo));
#endif // DBG

			if (ptuRetry != NULL)
			{
				//
				// Don't re-try so quickly, since responses to our retries are
				// lagging.
				//
				if ((*ptuRetry) < MAX_PAST_RETRY_TIME_US)
				{
					(*ptuRetry) *= 2;

					DPFX(DPFPREP, 8, "Backing initial retry timer off to %u usec.",
						(*ptuRetry));
				}
			}
		}
			
		
		DNASSERT(iRecvAddressSize == iAddressesSize);


		FD_ZERO(&fdsRead);
		FD_SET(sSocket, &fdsRead);
	}


	//
	// Now do the exchange, get a response to the request (does retries too).
	//
	do
	{
		DPFX(DPFPREP, 7, "Sending PAST request type %u (%i bytes, msg id = %u) to server (%u.%u.%u.%u:%u).",
			((PPAST_MSG) pcRequestBuffer)->msgtype, iRequestBufferSize, dwMsgID,
			((SOCKADDR_IN*) psaddrServerAddress)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) psaddrServerAddress)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) psaddrServerAddress)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) psaddrServerAddress)->sin_addr.S_un.S_un_b.s_b4,
			NTOHS(((SOCKADDR_IN*) psaddrServerAddress)->sin_port));

		//
		// First, send off the request.
		//
		iReturn = this->m_pfnsendto(sSocket,
									pcRequestBuffer,
									iRequestBufferSize,
									0,
									psaddrServerAddress,
									iAddressesSize);

		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u when sending to PAST gateway!", dwError);
#endif // DBG

			//
			// It's possible that we caught WinSock at a bad time,
			// particularly with WSAEADDRNOTAVAIL (10049), which seems to
			// occur if the address is going away (and we haven't detected
			// it in CheckForNewDevices yet).
			//
			// Break out of the receive loop, which should result in the
			// DPNHERR_SERVERNOTRESPONDING error.
			//
			break;
		}

		if (iReturn != iRequestBufferSize)
		{
			DPFX(DPFPREP, 0, "Didn't send entire datagram (%i != %i)?!", iReturn, iRequestBufferSize);
			DNASSERT(FALSE);
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		//
		// Now see if we get a response.
		//
Wait:
		
		FD_ZERO(&fdsRead);
		FD_SET(sSocket, &fdsRead);

		iReturn = this->m_pfnselect(0, &fdsRead, NULL, NULL, &tv);
		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u trying to select on PAST socket!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		
		//
		// If our socket was signalled, there's data to read.
		//
		//if (FD_ISSET(sSocket, &fdsRead))
		if (this->m_pfn__WSAFDIsSet(sSocket, &fdsRead))
		{
			iReturn = this->m_pfnrecvfrom(sSocket,
										acRespBuffer,
										sizeof(acRespBuffer),
										0,
										(SOCKADDR*) (&saddrinReceive),
										&iRecvAddressSize);

			if ((iReturn == 0) || (iReturn == SOCKET_ERROR))
			{
				dwError = this->m_pfnWSAGetLastError();

				//
				// If we get WSAECONNRESET here, we can probably assume that
				// it's because of the message we just sent.  That means that
				// there's no PAST server on the gateway.
				//
				if (dwError == WSAECONNRESET)
				{
					if (ptuRetry == NULL)
					{
						DPFX(DPFPREP, 2, "Got CONNRESET while waiting for initial registration response, assuming no PAST server.");
					}
					else
					{
						DPFX(DPFPREP, 0, "Got CONNRESET while waiting for PAST server response!");
					}

					//
					// Break out of the loop, it should result in the
					// DPNHERR_SERVERNOTRESPONDING error code.
					//
					break;
				}

				//
				// WSAENOBUFS means WinSock is out of memory.
				//
				if (dwError == WSAENOBUFS)
				{
					DPFX(DPFPREP, 0, "WinSock returned WSAENOBUFS when waiting for response!");
					hr = DPNHERR_OUTOFMEMORY;
				}
				else
				{
					DPFX(DPFPREP, 0, "Got sockets error %u trying to receive (waiting for response)!", dwError);
					hr = DPNHERR_GENERIC;
				}

				goto Failure;
			}


			//
			// We got some data.
			//
			
			DNASSERT(iRecvAddressSize == iAddressesSize);


			hr = this->ParsePASTMessage(acRespBuffer, iReturn, pRespInfo);
			if (hr != DPNH_OK)
			{
				//
				// We couldn't handle the response, try again (without touching
				// the remaining tries or backoff timer).
				//
				DPFX(DPFPREP, 0, "Failed parsing message from %u.%u.%u.%u:%u (err = %lx), ignoring.",
					saddrinReceive.sin_addr.S_un.S_un_b.s_b1,
					saddrinReceive.sin_addr.S_un.S_un_b.s_b2,
					saddrinReceive.sin_addr.S_un.S_un_b.s_b3,
					saddrinReceive.sin_addr.S_un.S_un_b.s_b4,
					NTOHS(saddrinReceive.sin_port),
					hr);
				goto Wait;
			}

			if (saddrinReceive.sin_addr.S_un.S_addr != ((SOCKADDR_IN*) psaddrServerAddress)->sin_addr.S_un.S_addr)
			{
				//
				// This message is not from the server to which we sent the
				// request.  Ignore it.
				//
				DPFX(DPFPREP, 0, "Got message from unexpected source (%u.%u.%u.%u:%u), ignoring %i byte message.",
					saddrinReceive.sin_addr.S_un.S_un_b.s_b1,
					saddrinReceive.sin_addr.S_un.S_un_b.s_b2,
					saddrinReceive.sin_addr.S_un.S_un_b.s_b3,
					saddrinReceive.sin_addr.S_un.S_un_b.s_b4,
					NTOHS(saddrinReceive.sin_port),
					iReturn);
				goto Wait;
			}

			if (pRespInfo->dwMsgID != dwMsgID)
			{
				//
				// We got a response to a different message, try again
				// (without touching the remaining tries or backoff timer).
				//
				DPFX(DPFPREP, 0, "Got messageid %u, expecting messageid %u, ignoring %i byte message.",
					pRespInfo->dwMsgID, dwMsgID, iReturn);
				goto Wait;
			}

			//
			// If we got here, then it looks like we got the response we want.
			// We're done.
			//
			DPFX(DPFPREP, 8, "Received expected messageid %u from %u.%u.%u.%u:%u, it's %i bytes.",
				pRespInfo->dwMsgID,
				saddrinReceive.sin_addr.S_un.S_un_b.s_b1,
				saddrinReceive.sin_addr.S_un.S_un_b.s_b2,
				saddrinReceive.sin_addr.S_un.S_un_b.s_b3,
				saddrinReceive.sin_addr.S_un.S_un_b.s_b4,
				NTOHS(saddrinReceive.sin_port),
				iReturn);
			goto Exit;
		}


		//
		// The initial registration attempt is a special case since we don't
		// know if the server exists or not.  Once we're registered, we expect
		// the server to be available, so we'll retry more times and
		// temporarily back off further each time.
		//
		if (ptuRetry != NULL)
		{
			tv.tv_usec *= 2;	// exponential backoff.
			DPFX(DPFPREP, 7, "Didn't get response, increasing temporary timeout value to %u.", tv.tv_usec);
		}	

		dwTriesRemaining--;
	}
	while (dwTriesRemaining > 0);


	//
	// If we got here, it means we didn't get a response.
	//
	hr = DPNHERR_SERVERNOTRESPONDING;
	//goto Failure;


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::ExchangeAndParsePAST






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::RegisterMultipleDevicesWithRemotePAST"
//=============================================================================
// CNATHelpPAST::RegisterMultipleDevicesWithRemotePAST
//-----------------------------------------------------------------------------
//
// Description:    Sends a registration message to the remote PAST server for
//				all the devices in the temporary pSourceList simultaneously
//				and waits for replies.  A pointer to the first device that
//				successfully registers with a remote PAST server will be placed
//				in ppFirstDeviceWithRemoteServer.  All devices will be removed
//				removed from pSourceList.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CBilink * pSourceList						- Temporary bilink with all
//													devices to check.  Will be
//													emptied.
//	CDevice ** ppFirstDeviceWithRemoteServer	- Place to store first device
//													which successfully
//													registers with a remote
//													PAST server
//
// Returns: HRESULT
//	DPNH_OK				- The devices were successfully handled.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::RegisterMultipleDevicesWithRemotePAST(CBilink * pSourceList,
															CDevice ** ppFirstDeviceWithRemoteServer)
{
	HRESULT				hr;
	CBilink *			pBilink;
	CDevice *			pDevice;
	CBilink *			pBilinkSameGateway;
	CDevice *			pDeviceSameGateway;
	char				acRespBuffer[PAST_RESPONSE_BUFFER_SIZE];
	timeval				tv;
	FD_SET				fdsRead;
	int					iReturn;
	PAST_MSG_REGISTER	RegisterReq;
	SOCKADDR_IN			saddrinServerAddress;
	int					iRecvAddressSize = sizeof(SOCKADDR_IN);
	PAST_RESPONSE_INFO	RespInfo;
	DWORD				dwError;
	DWORD				dwTry;
	DWORD				dwFinishTime;
	DWORD				dwTimeRemaining;
	SOCKADDR_IN			saddrinReceive;


	DPFX(DPFPREP, 5, "(0x%p) Parameters (0x%p, 0x%p)",
		this, pSourceList, ppFirstDeviceWithRemoteServer);


	DNASSERT(this->m_dwFlags & NATHELPPASTOBJ_INITIALIZED);


#ifdef DBG
	ZeroMemory(acRespBuffer, sizeof(acRespBuffer));
#endif // DBG


	//
	// Loop through each device.
	//
	pBilink = pSourceList->GetNext();
	while (pBilink != pSourceList)
	{
		pDevice = DEVICE_FROM_TEMP_BILINK(pBilink);
		pBilink = pBilink->GetNext();


		DNASSERT(pDevice->GetPASTClientID(TRUE) == 0);


		//
		// Create the temporary set.
		//
		FD_ZERO(&fdsRead);
		FD_SET(pDevice->GetPASTSocket(), &fdsRead);


		//
		// Try to get the device's gateway's address.  This might return FALSE
		// if the device does not have a gateway.  In that case, we will ignore
		// the device.  Otherwise the address should be filled in with the
		// gateway or broadcast address.
		//
		if (! this->GetAddressToReachGateway(pDevice,
											&saddrinServerAddress.sin_addr))
		{
			DPFX(DPFPREP, 2, "Device 0x%p should not attempt to reach a gateway.",
				pDevice);

			//
			// Take it out of the list, but continue.
			//
			pDevice->m_blTempList.RemoveFromList();
		}
		else
		{
			//
			// Store the address with the device for use below.
			//
			pDevice->SetRemotePASTServerAddressV4(saddrinServerAddress.sin_addr.S_un.S_addr);


			//
			// Clear out any extraneous responses from previous communication.
			//
			while (this->m_pfnselect(0, &fdsRead, NULL, NULL, &s_tv0) != 0)
			{
				iReturn = this->m_pfnrecvfrom(pDevice->GetPASTSocket(),
											acRespBuffer,
											sizeof(acRespBuffer),
											0,
											(SOCKADDR*) (&saddrinReceive),
											&iRecvAddressSize);
				if ((iReturn == 0) || (iReturn == SOCKET_ERROR))
				{
					dwError = this->m_pfnWSAGetLastError();

					//
					// Ignore WSAECONNRESET, that's just WinSock's way of
					// telling us that the target actively refused a previous
					// message we tried to send.  Since we don't know which
					// send WinSock means, we can't do a whole lot about it.
					//
					if (dwError != WSAECONNRESET)
					{
						DPFX(DPFPREP, 0, "Got sockets error %u on device 0x%p trying to receive (clearing incoming queue)!  Ignoring.",
							dwError, pDevice);

						//
						// Take it out of the list, but continue.
						//
						pDevice->m_blTempList.RemoveFromList();
					}
					else
					{
						DPFX(DPFPREP, 2, "Ignoring CONNRESET on device 0x%p while clearing incoming queue.",
							pDevice);
					}
				}
				else
				{
					//
					// If we got here, that means there's a message.
					//

#ifdef DBG
					DPFX(DPFPREP, 2, "Found extra response from previous PAST request on device 0x%p (sent by %u.%u.%u.%u:%u), parsing for fun.",
						pDevice,
						saddrinReceive.sin_addr.S_un.S_un_b.s_b1,
						saddrinReceive.sin_addr.S_un.S_un_b.s_b2,
						saddrinReceive.sin_addr.S_un.S_un_b.s_b3,
						saddrinReceive.sin_addr.S_un.S_un_b.s_b4,
						NTOHS(saddrinReceive.sin_port));

					//
					// For grins, let's see what this message is.  Ignore
					// errors.
					//
					ZeroMemory(&RespInfo, sizeof(RespInfo));
					this->ParsePASTMessage(acRespBuffer, iReturn, &RespInfo);
#endif // DBG
				}


				DNASSERT(iRecvAddressSize == sizeof(saddrinServerAddress));


				FD_ZERO(&fdsRead);
				FD_SET(pDevice->GetPASTSocket(), &fdsRead);
			}
		} // end else (device can try to reach gateway)
	}


	//
	// If there aren't any devices that aren't registered, we're done.
	//
	if (pSourceList->IsEmpty())
	{
		DPFX(DPFPREP, 8, "No devices remaining to be checked.");
		hr = DPNH_OK;
		goto Exit;
	}


	//
	// Build the registration request message.
	//

	ZeroMemory(&RegisterReq, sizeof(RegisterReq));
	RegisterReq.version		= PAST_VERSION;
	RegisterReq.command		= PAST_MSGID_REGISTER_REQUEST;

	RegisterReq.msgid.code	= PAST_PARAMID_MESSAGEID;
	RegisterReq.msgid.len	= sizeof(RegisterReq.msgid) - sizeof(PAST_PARAM);
	//RegisterReq.msgid.msgid	= 0;	// it always starts at 0 for registration


	ZeroMemory(&saddrinServerAddress, sizeof(saddrinServerAddress));
	saddrinServerAddress.sin_family		= AF_INET;
	//saddrinServerAddress.sin_addr		= ? // filled in below
	saddrinServerAddress.sin_port		= HTONS(PAST_HOST_PORT);


	//
	// Now actually try to register with all the ports.  Keep looping until
	// either all devices are registered or we exceed the number of tries.
	//
	for(dwTry = 0; dwTry < MAX_NUM_PAST_TRIES_CONNECT; dwTry++)
	{
		//
		// Send the message for all devices that aren't registered yet.
		//
		pBilink = pSourceList->GetNext();
		while (pBilink != pSourceList)
		{
			pDevice = DEVICE_FROM_TEMP_BILINK(pBilink);
			pBilink = pBilink->GetNext();


			//
			// Remember the current time, if this is the first thing we've sent
			// from this port.
			//
			if (pDevice->GetFirstPASTDiscoveryTime() == 0)
			{
				pDevice->SetFirstPASTDiscoveryTime(GETTIMESTAMP());
			}


			//
			// Retrieve the gateway address we detected above.
			//
			saddrinServerAddress.sin_addr.S_un.S_addr = pDevice->GetRemotePASTServerAddressV4();


			//
			// Try sending the registration message.
			//

			DPFX(DPFPREP, 7, "Device 0x%p sending PAST registration request (type %u, %i bytes) to server (%u.%u.%u.%u:%u).",
				pDevice, RegisterReq.command, sizeof(RegisterReq),
				saddrinServerAddress.sin_addr.S_un.S_un_b.s_b1,
				saddrinServerAddress.sin_addr.S_un.S_un_b.s_b2,
				saddrinServerAddress.sin_addr.S_un.S_un_b.s_b3,
				saddrinServerAddress.sin_addr.S_un.S_un_b.s_b4,
				NTOHS(saddrinServerAddress.sin_port));


			iReturn = this->m_pfnsendto(pDevice->GetPASTSocket(),
										(char*) (&RegisterReq),
										sizeof(RegisterReq),
										0,
										(SOCKADDR*) (&saddrinServerAddress),
										sizeof(saddrinServerAddress));

			if (iReturn == SOCKET_ERROR)
			{
#ifdef DBG
				dwError = this->m_pfnWSAGetLastError();
				DPFX(DPFPREP, 0, "Device 0x%p got sockets error %u when sending to PAST gateway!",
					pDevice, dwError);
#endif // DBG

				//
				// It's possible that we caught WinSock at a bad time,
				// particularly with WSAEADDRNOTAVAIL (10049), which seems to
				// occur if the address is going away (and we haven't detected
				// it in CheckForNewDevices yet).
				//
				// Ignore the error, we can survive.  Take the out of the list,
				// but continue.
				//
				pDevice->m_blTempList.RemoveFromList();


				//
				// If there aren't any more devices, we can bail.
				//
				if (pSourceList->IsEmpty())
				{
					DPFX(DPFPREP, 1, "Last device got sendto error, exiting gracefully.");
					hr = DPNH_OK;
					goto Exit;
				}
			}
			else
			{
				if (iReturn != sizeof(RegisterReq))
				{
					DPFX(DPFPREP, 0, "Didn't send entire datagram (%i != %i)?!",
						iReturn, sizeof(RegisterReq));
					DNASSERT(FALSE);
					hr = DPNHERR_GENERIC;
					goto Failure;
				}
			}
		}


		//
		// Remember how long to wait for replies to this send attempt.
		//
		dwFinishTime = timeGetTime() + PAST_CONNECT_RETRY_INTERVAL_MS;
		dwTimeRemaining = PAST_CONNECT_RETRY_INTERVAL_MS;


		//
		// Keep looping until all devices are registered or we timeout.
		//
		do
		{
			//
			// Rebuild the socket set.
			//
			FD_ZERO(&fdsRead);

			pBilink = pSourceList->GetNext();
			while (pBilink != pSourceList)
			{
				pDevice = DEVICE_FROM_TEMP_BILINK(pBilink);

				DNASSERT(pDevice->GetPASTClientID(TRUE) == 0);

				FD_SET(pDevice->GetPASTSocket(), &fdsRead);

				//
				// Move to next device
				//
				pBilink = pBilink->GetNext();
			}


			tv.tv_usec	= dwTimeRemaining * 1000;
			tv.tv_sec	= 0;

			//
			// Wait for data to come in on any of the sockets.
			//
			iReturn = this->m_pfnselect(0, &fdsRead, NULL, NULL, &tv);
			if (iReturn == SOCKET_ERROR)
			{
#ifdef DBG
				dwError = this->m_pfnWSAGetLastError();
				DPFX(DPFPREP, 0, "Got sockets error %u trying to select on PAST sockets!", dwError);
#endif // DBG
				hr = DPNHERR_GENERIC;
				goto Failure;
			}


			//
			// Stop looping if we timed out; it's time to repeat the message
			// (or exit, if no more tries left).
			//
			if (iReturn == 0)
			{
				DPFX(DPFPREP, 7, "No more sockets have data, try = %u of %u.",
					(dwTry + 1), MAX_NUM_PAST_TRIES_CONNECT);
				break;
			}


			//
			// If we're here, data came in on at least one of the sockets.
			// Read it and parse it.
			//
			pBilink = pSourceList->GetNext();
			while (pBilink != pSourceList)
			{
				pDevice = DEVICE_FROM_TEMP_BILINK(pBilink);
				pBilink = pBilink->GetNext();


				//
				// If this device's socket is set there's data to read.
				//
				//if (FD_ISSET(pDevice->GetPASTSocket(), &fdsRead))
				if (this->m_pfn__WSAFDIsSet(pDevice->GetPASTSocket(), &fdsRead))
				{
					iReturn = this->m_pfnrecvfrom(pDevice->GetPASTSocket(),
												acRespBuffer,
												sizeof(acRespBuffer),
												0,
												(SOCKADDR*) (&saddrinReceive),
												&iRecvAddressSize);

					if ((iReturn == 0) || (iReturn == SOCKET_ERROR))
					{
#ifdef DBG
						dwError = this->m_pfnWSAGetLastError();

						//
						// If we get WSAECONNRESET here, we can probably assume
						// that it's because of the message we just sent.  That
						// means that there's no PAST server on the gateway.
						//
						if (dwError == WSAECONNRESET)
						{
							DPFX(DPFPREP, 2, "Got CONNRESET while waiting for registration response on device 0x%p, assuming no PAST server.",
								pDevice);
						}
						else
						{
							DPFX(DPFPREP, 0, "Got sockets error %u trying to receive on device 0x%p (waiting for response)!  Ignoring",
								dwError);
						}
#endif // DBG

						//
						// Take it out of the list, but continue.
						//
						pDevice->m_blTempList.RemoveFromList();


						//
						// We can also be smart and remove any other devices
						// with the same gateway because they will have the
						// same problem; WinSock might not even give another
						// notification for the other sockets.  Don't try this
						// trick for the broadcast address, though.
						//
						if (pDevice->GetRemotePASTServerAddressV4() != INADDR_BROADCAST)
						{
							pBilinkSameGateway = pSourceList->GetNext();
							while (pBilinkSameGateway != pSourceList)
							{
								pDeviceSameGateway = DEVICE_FROM_TEMP_BILINK(pBilinkSameGateway);
								pBilinkSameGateway = pBilinkSameGateway->GetNext();

								if (pDeviceSameGateway->GetRemotePASTServerAddressV4() == pDevice->GetRemotePASTServerAddressV4())
								{
#ifdef DBG
									saddrinServerAddress.sin_addr.S_un.S_addr = pDevice->GetRemotePASTServerAddressV4();

									DPFX(DPFPREP, 3, "Removing device 0x%p, because it shares gateway %u.%u.%u.%u with device 0x%p.",
										pDeviceSameGateway,
										saddrinServerAddress.sin_addr.S_un.S_un_b.s_b1,
										saddrinServerAddress.sin_addr.S_un.S_un_b.s_b2,
										saddrinServerAddress.sin_addr.S_un.S_un_b.s_b3,
										saddrinServerAddress.sin_addr.S_un.S_un_b.s_b4,
										pDevice);
#endif // DBG

									//
									// Before we remove this similar device,
									// make sure we don't screw up the list of
									// remaining devices.  Otherwise, that
									// outer list traversal may get caught in
									// an infinite loop.
									//
									if ((&pDeviceSameGateway->m_blTempList) == pBilink)
									{
										pBilink = pBilink->GetNext();
									}

									pDeviceSameGateway->m_blTempList.RemoveFromList();
								}
							}
						}
						else
						{
							//
							// Sent to broadcast address, can't optimize.
							//
						}


						//
						// If there aren't any more devices, we can bail.
						//
						if (pSourceList->IsEmpty())
						{
							DPFX(DPFPREP, 1, "Last device got recvfrom error, exiting gracefully.");
							hr = DPNH_OK;
							goto Exit;
						}
					}
					else
					{
						//
						// We got some data.
						//
						
						DNASSERT(iRecvAddressSize == sizeof(saddrinServerAddress));


						ZeroMemory(&RespInfo, sizeof(RespInfo));

						hr = this->ParsePASTMessage(acRespBuffer, iReturn, &RespInfo);
						if (hr != DPNH_OK)
						{
							//
							// We couldn't handle the response, try again.
							//
							DPFX(DPFPREP, 0, "Failed parsing message (err = %lx), ignoring.",
								hr);
						}
						else
						{
							if (RespInfo.dwMsgID != 0)
							{
								//
								// We got a response to a different message,
								// try again.
								//
								DPFX(DPFPREP, 0, "Got messageid %u, expecting messageid 0, ignoring.",
									RespInfo.dwMsgID);
							}
							else
							{
								if (RespInfo.cMsgType != PAST_MSGID_REGISTER_RESPONSE)
								{
									//
									// We got an unxpected response type, try
									// again.
									//
									DPFX(DPFPREP, 0, "Got message type %u, expecting %u, ignoring.",
										RespInfo.cMsgType, PAST_MSGID_REGISTER_RESPONSE);
								}
								else
								{
									//
									// If we got here, then it looks like we
									// got the response we want.
									//

									//
									// If we were broadcasting, accept the
									// first response we receive.  Otherwise,
									// throw out the message if it's not from
									// the address we expect.
									//

									if (saddrinServerAddress.sin_addr.S_un.S_addr == INADDR_BROADCAST)
									{
										DPFX(DPFPREP, 4, "Accepting response from PAST server %u.%u.%u.%u:%u.",
											saddrinReceive.sin_addr.S_un.S_un_b.s_b1,
											saddrinReceive.sin_addr.S_un.S_un_b.s_b2,
											saddrinReceive.sin_addr.S_un.S_un_b.s_b3,
											saddrinReceive.sin_addr.S_un.S_un_b.s_b4,
											NTOHS(saddrinReceive.sin_port));

										pDevice->SetRemotePASTServerAddressV4(saddrinReceive.sin_addr.S_un.S_addr);
									}
									

									if (pDevice->GetRemotePASTServerAddressV4() == saddrinReceive.sin_addr.S_un.S_addr)
									{
										pDevice->SetPASTClientID(RespInfo.dwClientID, TRUE);


										//
										// Move to the next message ID.
										//
										pDevice->ResetRemotePASTMsgIDAndRetryTimeout(DEFAULT_INITIAL_PAST_RETRY_TIMEOUT);
										pDevice->GetNextRemotePASTMsgID();

										
										//
										// Pull this device from the list of
										// remaining devices.
										//
										pDevice->m_blTempList.RemoveFromList();


										//
										// Register all the existing mappings
										// associated with the device that the
										// user has already requested.
										//
										if (! pDevice->m_blOwnedRegPorts.IsEmpty())
										{
											hr = this->RegisterAllPortsWithPAST(pDevice, TRUE);
											if (hr != DPNH_OK)
											{
												DPFX(DPFPREP, 0, "Couldn't register all existing ports with remote PAST server!");
												goto Failure;
											}


#ifdef DBG
											//
											// If we didn't encounter an error
											// that caused the PAST server to
											// be removed, then the
											// NATHELPPASTOBJ_ADDRESSESCHANGED
											// flag must have been set by the
											// AssignOrListenPorts function.
											//
											if (pDevice->GetPASTClientID(TRUE) != 0)
											{
												if (! (this->m_dwFlags & NATHELPPASTOBJ_ADDRESSESCHANGED))
												{
													DPFX(DPFPREP, 1, "Successfully registered with remote PAST server, but no addresses changed; all ports should be unavailable.");
												}
											}
											else
											{
												DPFX(DPFPREP, 1, "Remote PAST server was removed while trying to register existing ports.");
											}
#endif // DBG
										}
										else
										{
											BOOL	fAddressAlreadyChanged;


											DPFX(DPFPREP, 2, "Remote PAST server now available for device 0x%p, but no ports are currently registered.",
												pDevice);


											fAddressAlreadyChanged = (this->m_dwFlags & NATHELPPASTOBJ_ADDRESSESCHANGED) ? TRUE : FALSE;


											//
											// Forcefully check if there's a
											// public address available.
											//
											hr = this->UpdatePASTPublicAddressValidity(pDevice, TRUE);
											if (hr != DPNH_OK)
											{
												DPFX(DPFPREP, 0, "Couldn't update remote PAST server address validity!");
												goto Failure;
											}


											//
											// Prevent the user from thinking
											// the addresses changed unless
											// something else already caused
											// the address change notification.
											//
											if (! fAddressAlreadyChanged)
											{
												this->m_dwFlags &= ~NATHELPPASTOBJ_ADDRESSESCHANGED;
											}
										}


										//
										// Store this device, if it's the first
										// one that successfully registered.
										//
										if ((*ppFirstDeviceWithRemoteServer) == NULL)
										{
											DPFX(DPFPREP, 7, "Saving device 0x%p that was just registered with new remote PAST server.",
												pDevice);
											(*ppFirstDeviceWithRemoteServer) = pDevice;
										}
										else
										{
											DPFX(DPFPREP, 7, "Already have device with remote PAST server 0x%p, not storing newly registered 0x%p.",
												(*ppFirstDeviceWithRemoteServer), pDevice);
										}


										//
										// If there aren't any more devices, we
										// can bail.
										//
										if (pSourceList->IsEmpty())
										{
											DPFX(DPFPREP, 7, "Last device (0x%p) got registered with remote PAST server.",
												pDevice);
											hr = DPNH_OK;
											goto Exit;
										}
									}
									else
									{
										DPFX(DPFPREP, 0, "Ignoring correctly formed message from %u.%u.%u.%u:%u!",
											saddrinReceive.sin_addr.S_un.S_un_b.s_b1,
											saddrinReceive.sin_addr.S_un.S_un_b.s_b2,
											saddrinReceive.sin_addr.S_un.S_un_b.s_b3,
											saddrinReceive.sin_addr.S_un.S_un_b.s_b4,
											NTOHS(saddrinReceive.sin_port));
									}
								} // end else (got correct message type)
							} // end else (got correct message ID)
						} // end else (failed parsing message)
					} // end else (successfully received data)
				}
				else
				{
					//
					// Socket did not receive any data.
					//
				}
			}


			//
			// Calculate how much time remains.  If that went negative, loop
			// one extra time (with a timeout of 0).  We will bail after the
			// select if no data arrived while we were processing the last
			// round of data.
			//
			dwTimeRemaining = dwFinishTime - timeGetTime();
			if ((int) dwTimeRemaining < 0)
			{
				dwTimeRemaining = 0;
			}
		}
		while (TRUE);

		//
		// Go to next attempt
		//
	}


	//
	// If we're here some devices still do not have remote PAST servers.
	// There should still be items in the temp source list.
	//
	DNASSERT(! pSourceList->IsEmpty());

	//
	// Remove any remaining items from the temp source list.
	//
	pBilink = pSourceList->GetNext();
	while (pBilink != pSourceList)
	{
		pDevice = DEVICE_FROM_TEMP_BILINK(pBilink);
		pBilink = pBilink->GetNext();

		pDevice->m_blTempList.RemoveFromList();
	}

	hr = DPNH_OK;


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::RegisterMultipleDevicesWithRemotePAST





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::ParsePASTMessage"
//=============================================================================
// CNATHelpPAST::ParsePASTMessage
//-----------------------------------------------------------------------------
//
// Description:    Parses a PAST message and extracts the codes into fields in
//				a standardized structure.
//
//				   This is not completely general, as we know that we will only
//				operate with v4 addresses and our commands will never deal with
//				more than 1 address/port at a time.  PAST allows for multiple
//				ports to be allocated in a single request, but we do not take
//				advantage of this feature. If you need to handle such multiple
//				address requests and responses, then you will need to change
//				this function.
//
// Arguments:
//	char * pcMsg					- Pointer to buffer containing a PAST
//										request or response message.
//	int iMsgSize					- Size of message buffer in bytes.
//	PAST_RESPONSE_INFO * pRespInfo	- Pointer to structure that is filled with
//										the parameters from the PAST message.
//
// Returns: HRESULT
//	DPNH_OK					- Parsing was successful.
//	DPNHERR_INVALIDPARAM	- An invalid buffer was given.
//	DPNHERR_GENERIC			- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::ParsePASTMessage(const char * const pcMsg,
										const int iMsgSize,
										PAST_RESPONSE_INFO * const pRespInfo)
{
	HRESULT			hr = DPNH_OK;
	BOOL			fGotlAddress = FALSE;
	BOOL			fGotlPort = FALSE;
	PPAST_PARAM		pParam;
	PPAST_PARAM		pNextParam;
	const char *	pcEnd;
	char *			pcData;
	char			cTemp;
#ifdef DBG
	char			szPortList[(DPNH_MAX_SIMULTANEOUS_PORTS * 7) + 1]; // "nnnnn, " + NULL termination
	char *			pszTemp;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i, 0x%p)",
		this, pcMsg, iMsgSize, pRespInfo);


	if (iMsgSize < 2)
	{
		DPFX(DPFPREP, 0, "Buffer too small to be valid PAST message (%i bytes)!", iMsgSize);
		DNASSERTX(! "Buffer too small to be valid PAST message!", 2);
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}	

	pRespInfo->cVersion = ((PPAST_MSG) pcMsg)->version;
	pRespInfo->cMsgType = ((PPAST_MSG) pcMsg)->msgtype;


	DPFX(DPFPREP, 3, "version %u msgtype %u", pRespInfo->cVersion, pRespInfo->cMsgType);

	pParam = (PPAST_PARAM) (pcMsg + sizeof(PAST_MSG));
	pcEnd = pcMsg + iMsgSize;

	while ((char *) (pParam + 1) < pcEnd)
	{
		pcData = (char *) (pParam + 1);
		pNextParam = (PPAST_PARAM) (pcData + pParam->len);

		if ((pParam->len > (iMsgSize - sizeof(PAST_MSG) - sizeof(PAST_PARAM))) ||
			((char *) pNextParam > pcEnd))
		{
			break;
		}	

		switch (pParam->code)
		{
			case PAST_PARAMID_ADDRESS:
			{
				if (pParam->len >= 1)
				{
					//
					// Addresses are type[1]|addr[?]
					//
					if ((*pcData) != PAST_ADDRESSTYPE_IPV4)
					{
						DPFX(DPFPREP, 0, "Got unexpected PAST address code type %u!", (*pcData));
						hr = DPNHERR_GENERIC;
						goto Failure;
					}

					//
					// Validate the size of the address parameter.
					//
					if (pParam->len == 5)
					{
						if (! fGotlAddress)
						{
							CopyMemory(&pRespInfo->dwLocalAddressV4, pcData + 1, 4);

							DPFX(DPFPREP, 3, "Got local address %u.%u.%u.%u.",
								((IN_ADDR *) (&pRespInfo->dwLocalAddressV4))->S_un.S_un_b.s_b1,
								((IN_ADDR *) (&pRespInfo->dwLocalAddressV4))->S_un.S_un_b.s_b2,
								((IN_ADDR *) (&pRespInfo->dwLocalAddressV4))->S_un.S_un_b.s_b3,
								((IN_ADDR *) (&pRespInfo->dwLocalAddressV4))->S_un.S_un_b.s_b4);

							if ((pRespInfo->dwLocalAddressV4 == INADDR_BROADCAST) ||
								(IS_CLASSD_IPV4_ADDRESS(pRespInfo->dwLocalAddressV4)))
							{
								DPFX(DPFPREP, 1, "Ignoring invalid local address and using INADDR_ANY instead.");
								pRespInfo->dwLocalAddressV4 = 0;
							}

							fGotlAddress = TRUE;
						}
						else
						{	
							fGotlPort = TRUE; // just in case there wasn't a local port

							CopyMemory(&pRespInfo->dwRemoteAddressV4, pcData + 1, 4);

							DPFX(DPFPREP, 3, "Got remote address %u.%u.%u.%u.",
								((IN_ADDR *) (&pRespInfo->dwRemoteAddressV4))->S_un.S_un_b.s_b1,
								((IN_ADDR *) (&pRespInfo->dwRemoteAddressV4))->S_un.S_un_b.s_b2,
								((IN_ADDR *) (&pRespInfo->dwRemoteAddressV4))->S_un.S_un_b.s_b3,
								((IN_ADDR *) (&pRespInfo->dwRemoteAddressV4))->S_un.S_un_b.s_b4);

							if ((pRespInfo->dwRemoteAddressV4 == INADDR_BROADCAST) ||
								(IS_CLASSD_IPV4_ADDRESS(pRespInfo->dwRemoteAddressV4)))
							{
								DPFX(DPFPREP, 7, "Ignoring invalid remote address and using INADDR_ANY instead.");
								pRespInfo->dwRemoteAddressV4 = 0;
							}

						}
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring address parameter with invalid length (%u)!",
							pParam->len);
					}
				}
				else
				{
					DPFX(DPFPREP, 1, "Ignoring 0 byte address parameter.");
				}

				break;
			}

			case PAST_PARAMID_PORTS:
			{
				if (pParam->len >= 1)
				{
					//
					// Validate the port count.
					//
					if ((*pcData) == 0)
					{
						DPFX(DPFPREP, 1, "Ignoring %u byte port parameter with 0 ports.",
							pParam->len);
						break;
					}

					//
					// Validate the size of the parameter.
					//
					if (pParam->len < (((*pcData) * sizeof (WORD)) + 1))
					{
						DPFX(DPFPREP, 0, "Port parameter is %u bytes, but is reporting %u ports!  Ignoring.",
							pParam->len, (*pcData));
						break;
					}

					//
					// NOTE: Ports appeared to be transferred in x86 format,
					// contrary to the spec, which says network byte order.
					//

					//
					// Ports are Count[1]|Port[2]....Port[2]
					//
					if (! fGotlPort)
					{
						pRespInfo->cNumLocalPorts = (*pcData);

						if (pRespInfo->cNumLocalPorts > DPNH_MAX_SIMULTANEOUS_PORTS)
						{
							DPFX(DPFPREP, 0, "Got %u local ports, only using first %u:",
								pRespInfo->cNumLocalPorts, DPNH_MAX_SIMULTANEOUS_PORTS);

							pRespInfo->cNumLocalPorts = DPNH_MAX_SIMULTANEOUS_PORTS;
						}
						else
						{
							DPFX(DPFPREP, 3, "Got %u local ports:",
								pRespInfo->cNumLocalPorts);
						}

						//
						// Copy the port array.
						//
						CopyMemory(pRespInfo->awLocalPorts, (pcData + 1),
									(pRespInfo->cNumLocalPorts * sizeof (WORD)));

						//
						// Unfortunately we want the array to have ports in
						// network byte order for real.  Loop through each port
						// and switch them.
						//
#ifdef DBG
						szPortList[0] = '\0';	// initialize
						pszTemp = szPortList;
#endif // DBG
						for(cTemp = 0; cTemp < pRespInfo->cNumLocalPorts; cTemp++)
						{
#ifdef DBG
							pszTemp += wsprintfA(pszTemp, "%u, ", pRespInfo->awLocalPorts[cTemp]);
#endif // DBG
							pRespInfo->awLocalPorts[cTemp] = HTONS(pRespInfo->awLocalPorts[cTemp]);
						}
						
#ifdef DBG
						szPortList[strlen(szPortList) - 2] = '\0';	// chop off trailing ", "
						DPFX(DPFPREP, 3, "     {%hs}", szPortList);
#endif // DBG

						fGotlPort = TRUE;					
					}
					else
					{
						if (pRespInfo->cNumRemotePorts > 0)
						{
							DPFX(DPFPREP, 0, "Already received %u remote ports, ignoring %u more.",
								pRespInfo->cNumRemotePorts, (*pcData));
						}
						else
						{
							pRespInfo->cNumRemotePorts = (*pcData);

							if (pRespInfo->cNumRemotePorts > DPNH_MAX_SIMULTANEOUS_PORTS)
							{
								DPFX(DPFPREP, 0, "Got %u remote ports, only using first %u:",
									pRespInfo->cNumRemotePorts, DPNH_MAX_SIMULTANEOUS_PORTS);

								pRespInfo->cNumRemotePorts = DPNH_MAX_SIMULTANEOUS_PORTS;
							}
							else
							{
								DPFX(DPFPREP, 3, "Got %u remote ports:",
									pRespInfo->cNumRemotePorts);
							}

							//
							// Copy the port array.
							//
							CopyMemory(pRespInfo->awRemotePorts, (pcData + 1),
										(pRespInfo->cNumRemotePorts * sizeof (WORD)));

							//
							// Unfortunately we want the array to have ports in
							// network byte order for real.  Loop through each
							// port and switch them.
							//
#ifdef DBG
							szPortList[0] = '\0';	// initialize
							pszTemp = szPortList;
#endif // DBG
							for(cTemp = 0; cTemp < pRespInfo->cNumRemotePorts; cTemp++)
							{
#ifdef DBG
								pszTemp += wsprintfA(pszTemp, "%u, ", pRespInfo->awRemotePorts[cTemp]);
#endif // DBG
								pRespInfo->awRemotePorts[cTemp] = HTONS(pRespInfo->awRemotePorts[cTemp]);
							}

#ifdef DBG
							szPortList[strlen(szPortList) - 2] = '\0';	// chop off trailing ", "
							DPFX(DPFPREP, 3, "     {%hs}", szPortList);
#endif // DBG
						}
					}
				}
				else
				{
					DPFX(DPFPREP, 1, "Ignoring 0 byte port parameter.");
				}
				break;
			}

			case PAST_PARAMID_LEASE:
			{
				if (pParam->len == 4)
				{
					CopyMemory(&pRespInfo->dwLeaseTime, pcData, 4);
					DPFX(DPFPREP, 3, "Got lease of %u seconds.", pRespInfo->dwLeaseTime);
				}
				else
				{
					if (pParam->len == 0)
					{
						DPFX(DPFPREP, 1, "Ignoring empty lease parameter.");
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring lease parameter with invalid length (%u)!",
							pParam->len);
					}
				}

				break;
			}

			case PAST_PARAMID_CLIENTID:
			{
				if (pParam->len == 4)
				{
					CopyMemory(&pRespInfo->dwClientID, pcData, 4);
					DPFX(DPFPREP, 3, "Got client ID %u.", pRespInfo->dwClientID);
				}
				else
				{
					if (pParam->len == 0)
					{
						DPFX(DPFPREP, 1, "Ignoring empty client ID parameter.");
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring client ID parameter with invalid length (%u)!",
							pParam->len);
					}
				}

				break;
			}

			case PAST_PARAMID_BINDID:
			{
				if (pParam->len == 4)
				{
					CopyMemory(&pRespInfo->dwBindID, pcData, 4);
					DPFX(DPFPREP, 3, "Got bind ID %u.", pRespInfo->dwBindID);
				}
				else
				{
					if (pParam->len == 0)
					{
						DPFX(DPFPREP, 1, "Ignoring empty bind ID parameter.");
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring bind ID parameter with invalid length (%u)!",
							pParam->len);
					}
				}

 				break;
			}

			case PAST_PARAMID_MESSAGEID:
			{
				if (pParam->len == 4)
				{
					CopyMemory(&pRespInfo->dwMsgID, pcData, 4);
					DPFX(DPFPREP, 3, "Got message ID %u.", pRespInfo->dwMsgID);
				}
				else
				{
					if (pParam->len == 0)
					{
						DPFX(DPFPREP, 1, "Ignoring empty message ID parameter.");
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring message ID parameter with invalid length (%u)!",
							pParam->len);
					}
				}

				break;
			}

			case PAST_PARAMID_TUNNELTYPE:
			{
				if (pParam->len == 1)
				{
					DPFX(DPFPREP, 3, "Got tunnel type %u, ignoring.", (*pcData));
				}
				else
				{
					if (pParam->len == 0)
					{
						DPFX(DPFPREP, 1, "Ignoring empty tunnel type parameter.");
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring tunnel type parameter with invalid length (%u)!",
							pParam->len);
					}
				}
				break;
			}

			case PAST_PARAMID_PASTMETHOD:
			{
				if (pParam->len == 1)
				{
					DPFX(DPFPREP, 3, "Got PAST method %u, ignoring.", (*pcData));
				}
				else
				{
					if (pParam->len == 0)
					{
						DPFX(DPFPREP, 1, "Ignoring empty PAST method parameter.");
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring PAST method parameter with invalid length (%u)!",
							pParam->len);
					}
				}
				break;
			}

			case PAST_PARAMID_ERROR:
			{
				if (pParam->len == 2)
				{
#ifdef DBG
					char *		pszErrorString;
#endif // DBG


					CopyMemory(&pRespInfo->wError, pcData, 2);

#ifdef DBG
					switch (pRespInfo->wError)
					{
						case PASTERR_UNKNOWNERROR:
						{
							pszErrorString = "UNKNOWNERROR";
							break;
						}

						case PASTERR_BADBINDID:
						{
							pszErrorString = "BADBINDID";
							break;
						}

						case PASTERR_BADCLIENTID:
						{
							pszErrorString = "BADCLIENTID";
							break;
						}

						case PASTERR_MISSINGPARAM:
						{
							pszErrorString = "MISSINGPARAM";
							break;
						}

						case PASTERR_DUPLICATEPARAM:
						{
							pszErrorString = "DUPLICATEPARAM";
							break;
						}

						case PASTERR_ILLEGALPARAM:
						{
							pszErrorString = "ILLEGALPARAM";
							break;
						}

						case PASTERR_ILLEGALMESSAGE:
						{
							pszErrorString = "ILLEGALMESSAGE";
							break;
						}

						case PASTERR_REGISTERFIRST:
						{
							pszErrorString = "REGISTERFIRST";
							break;
						}

						case PASTERR_BADMESSAGEID:
						{
							pszErrorString = "BADMESSAGEID";
							break;
						}

						case PASTERR_ALREADYREGISTERED:
						{
							pszErrorString = "ALREADYREGISTERED";
							break;
						}

						case PASTERR_ALREADYUNREGISTERED:
						{
							pszErrorString = "ALREADYUNREGISTERED";
							break;
						}

						case PASTERR_BADTUNNELTYPE:
						{
							pszErrorString = "BADTUNNELTYPE";
							break;
						}

						case PASTERR_ADDRUNAVAILABLE:
						{
							pszErrorString = "ADDRUNAVAILABLE";
							break;
						}

						case PASTERR_PORTUNAVAILABLE:
						{
							pszErrorString = "PORTUNAVAILABLE";
							break;
						}

						default:
						{
							pszErrorString = "? unknown ?";
							break;
						}
					}

					DPFX(DPFPREP, 1, "Got PAST error %u, %hs.",
						pRespInfo->wError, pszErrorString);
#endif // DBG
 				}
				else
				{
					if (pParam->len == 0)
					{
						DPFX(DPFPREP, 1, "Ignoring empty PAST error parameter.");
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring PAST error parameter with invalid length (%u)!",
							pParam->len);
					}
				}

				break;
			}

			case PAST_PARAMID_FLOWPOLICY:
			{
				if (pParam->len == 2)
				{
					DPFX(DPFPREP, 3, "Got PAST flow policy local %u, remote %u; ignoring.",
						(*pcData), *(pcData + 1));
				}
				else
				{
					if (pParam->len == 0)
					{
						DPFX(DPFPREP, 1, "Ignoring empty flow policy parameter.");
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring flow policy parameter with invalid length (%u)!",
							pParam->len);
					}
				}
				break;
			}

			case PAST_PARAMID_VENDOR:
			{
  				DPFX(DPFPREP, 1, "Got %u byte vendor code parameter, ignoring.",
					pParam->len);
				break;
			}

			default:
			{
				DPFX(DPFPREP, 0, "Got %u byte unknown parameter code %u, ignoring.",
					pParam->len, pParam->code);
				break;
			}
		}

		pParam = pNextParam;
	}


Failure:
//Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CNATHelpPAST::ParsePASTMessage







#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::RequestLocalAddressListChangeNotification"
//=============================================================================
// CNATHelpPAST::RequestLocalAddressListChangeNotification
//-----------------------------------------------------------------------------
//
// Description:    Attempts to request asynchronous notification (via the
//				user's alert event or I/O completion port) when the local
//				address list changes.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK				- The notification request was successfully submitted.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpPAST::RequestLocalAddressListChangeNotification(void)
{
	HRESULT		hr;
	DWORD		dwTemp;
	int			iReturn;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(! (this->m_dwFlags & NATHELPPASTOBJ_WINSOCK1));
	DNASSERT(this->m_sIoctls != INVALID_SOCKET);
	DNASSERT(this->m_pfnWSAIoctl != NULL);
	DNASSERT((this->m_hAlertEvent != NULL) || (this->m_hAlertIOCompletionPort != NULL));
	DNASSERT(this->m_polAddressListChange != NULL);

	do
	{
		iReturn = this->m_pfnWSAIoctl(this->m_sIoctls,				// use the special Ioctl socket
									SIO_ADDRESS_LIST_CHANGE,		//
									NULL,							// no input data
									0,								// no input data
									NULL,							// no output data
									0,								// no output data
									&dwTemp,						// ignore bytes returned
									this->m_polAddressListChange,	// overlapped structure
									NULL);							// no completion routine

		if (iReturn != 0)
		{
			dwTemp = this->m_pfnWSAGetLastError();
			if (dwTemp != WSA_IO_PENDING)
			{
				DPFX(DPFPREP, 0, "Submitting address list change notification request failed (err = %u)!", dwTemp);
				hr = DPNHERR_GENERIC;
				goto Failure;
			}


			//
			// Pending is what we want, we're set.
			//
			hr = DPNH_OK;
			break;
		}


		//
		// Address list changed right away?
		//
		DPFX(DPFPREP, 1, "Address list changed right away somehow, submitting again.");
	}
	while (TRUE);



Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpPAST::RequestLocalAddressListChangeNotification






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::CreatePASTSocket"
//=============================================================================
// CNATHelpPAST::CreatePASTSocket
//-----------------------------------------------------------------------------
//
// Description:    Creates a PAST communication socket bound to a new random
//				port on the specified IP interface.  Completely random (but
//				non-reserved) port numbers are chosen first, but if those ports
//				are in use, WinSock is allowed to choose.  The port actually
//				selected will be returned in psaddrinAddress.
//
// Arguments:
//	SOCKADDR_IN * psaddrinAddress	- Pointer to base address to use when
//										binding.  The port will be modified.
//
// Returns: SOCKET
//=============================================================================
SOCKET CNATHelpPAST::CreatePASTSocket(SOCKADDR_IN * const psaddrinAddress)
{
	SOCKET	sTemp;
	DWORD	dwTry;
	int		iTemp;
	BOOL	fTemp;
#ifdef DBG
	DWORD	dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, psaddrinAddress);


	//
	// Create the socket.
	//
	sTemp = this->m_pfnsocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sTemp == INVALID_SOCKET)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't create datagram socket, error = %u!", dwError);
#endif // DBG
		goto Failure;
	}


	//
	// Try binding the socket to a completely random port a few times.
	//
	for(dwTry = 0; dwTry < MAX_NUM_RANDOM_PORT_TRIES; dwTry++)
	{
		//
		// Pick a completely random port.  For the moment, the value is stored
		// in host byte order while we make sure it's not a reserved value.
		//
		do
		{
			psaddrinAddress->sin_port = (WORD) GetGlobalRand();
		}
		while ((psaddrinAddress->sin_port <= MAX_RESERVED_PORT) ||
				(psaddrinAddress->sin_port == 1900) ||	// SSDP
				(psaddrinAddress->sin_port == 2234) ||	// PAST
				(psaddrinAddress->sin_port == 6073) ||	// DPNSVR
				(psaddrinAddress->sin_port == 47624));	// DPLAYSVR

		//
		// Now try binding to the port (in network byte order).
		//
		psaddrinAddress->sin_port = HTONS(psaddrinAddress->sin_port);
		if (this->m_pfnbind(sTemp, (SOCKADDR*) psaddrinAddress, sizeof(SOCKADDR_IN)) == 0)
		{
			//
			// We successfully bound to the port.
			//
			break;
		}

		//
		// Assume that the port is in use.
		//
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 2, "Couldn't bind to port %u (err = %u), continuing.",
			NTOHS(psaddrinAddress->sin_port), dwError);
#endif // DBG

		psaddrinAddress->sin_port = 0;
	}


	//
	// If we ran out of completely random port attempts, just let WinSock
	// choose it.
	//
	if (psaddrinAddress->sin_port == 0)
	{
		if (this->m_pfnbind(sTemp, (SOCKADDR*) psaddrinAddress, sizeof(SOCKADDR_IN)) != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Failed binding to any port (err = %u)!",
				dwError);
#endif // DBG
			goto Failure;
		}


		//
		// Find out what port WinSock chose.
		//
		iTemp = sizeof(SOCKADDR_IN);
		if (this->m_pfngetsockname(sTemp,
								(SOCKADDR *) psaddrinAddress,
								&iTemp) != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't get the socket's address, error = %u!",
				dwError);
#endif // DBG
			goto Failure;
		}
		DNASSERT(psaddrinAddress->sin_port != 0);
	}


	//
	// Set the unicast TTL, if requested.  Use the appropriate constant for the
	// the version of WinSock we're using.
	//
	if (g_iUnicastTTL != 0)
	{
		iTemp = this->m_pfnsetsockopt(sTemp,
									IPPROTO_IP,
#ifdef DPNBUILD_NOWINSOCK2
									IP_TTL,
#else // ! DPNBUILD_NOWINSOCK2
									((this->m_dwFlags & NATHELPPASTOBJ_WINSOCK1) ? IP_TTL_WINSOCK1 : IP_TTL),
#endif // ! DPNBUILD_NOWINSOCK2
									(char *) (&g_iUnicastTTL),
									sizeof(g_iUnicastTTL));
		if (iTemp != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't set unicast TTL socket option, error = %u!  Ignoring.",
				dwError);
#endif // DBG

			//
			// Continue...
			//
		}
	}


	//
	// Set the socket up to allow broadcasts in case we can't determine the
	// gateway.
	//
	fTemp = TRUE;
	if (this->m_pfnsetsockopt(sTemp,
							SOL_SOCKET,
							SO_BROADCAST,
							(char *) (&fTemp),
							sizeof(fTemp)) != 0)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't set broadcast socket option, error = %u!", dwError);
#endif // DBG
		goto Failure;
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%x]", this, sTemp);

	return sTemp;


Failure:

	if (sTemp != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(sTemp);
		sTemp = INVALID_SOCKET;
	}

	goto Exit;
} // CNATHelpPAST::CreatePASTSocket






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::GetAddressToReachGateway"
//=============================================================================
// CNATHelpPAST::GetAddressToReachGateway
//-----------------------------------------------------------------------------
//
// Description:    Retrieves the address of the gateway for the given device,
//				or the broadcast address if unable to be determined.
//
//				   This will return TRUE if the gateway's address was found, or
//				the IPHLPAPI DLL could not be used (Win95).  FALSE is returned
//				if IPHLPAPI reported that there was no gateway (ICS private
//				side adapter).
//
// Arguments:
//	CDevice * pDevice	- Pointer to device whose gateway should be retrieved.
//	IN_ADDR * pinaddr	- Place to store gateway or broadcast address.
//
// Returns: BOOL
//	TRUE	- Gateway address was found or had to use broadcast.
//	FALSE	- There is no gateway, do not attempt to use the address.
//=============================================================================
BOOL CNATHelpPAST::GetAddressToReachGateway(CDevice * const pDevice,
											IN_ADDR * const pinaddr)
{
	DWORD					dwError;
	BOOL					fResult = TRUE;
	ULONG					ulSize;
	PIP_ADAPTER_INFO		pAdaptersBuffer = NULL;
	PIP_ADAPTER_INFO		pAdapterInfo;
	PIP_ADDR_STRING			pIPAddrString;
	DWORD					dwAdapterIndex;
	PMIB_IPFORWARDTABLE		pIPForwardTableBuffer = NULL;
	DWORD					dwTemp;
	PMIB_IPFORWARDROW 		pIPForwardRow;



	//
	// Fill in the default address.  This should be atomic, so don't worry
	// about locking the globals.
	//
	pinaddr->S_un.S_addr = g_dwDefaultGatewayV4;

#ifdef DBG
	pDevice->ClearGatewayFlags();
#endif // DBG


	//
	// If this is the loopback address, then don't bother looking for a
	// gateway, we won't find one.
	//
	if (pDevice->GetLocalAddressV4() == NETWORKBYTEORDER_INADDR_LOOPBACK)
	{
		DPFX(DPFPREP, 8, "No gateway for loopback address (device = 0x%p).",
			pDevice);

		//
		// No gateway.
		//
#ifdef DBG
		pDevice->NoteNoGateway();
#endif // DBG
		fResult = FALSE;
		goto Exit;
	}


	//
	// If we didn't load the IP helper DLL, we can't do our fancy gateway
	// tricks.
	//
	if (this->m_hIpHlpApiDLL == NULL)
	{
		DPFX(DPFPREP, 4, "Didn't load \"iphlpapi.dll\", returning default address for device 0x%p.",
			pDevice);
		goto Exit;
	}


	//
	// Keep trying to get the list of adapters until we get ERROR_SUCCESS or a
	// legitimate error (other than ERROR_BUFFER_OVERFLOW or
	// ERROR_INSUFFICIENT_BUFFER).
	//
	ulSize = 0;
	do
	{
		dwError = this->m_pfnGetAdaptersInfo(pAdaptersBuffer, &ulSize);
		if (dwError == ERROR_SUCCESS)
		{
			//
			// We succeeded, we should be set.  But make sure there are
			// adapters for us to use.
			//
			if (ulSize < sizeof(IP_ADAPTER_INFO))
			{
				DPFX(DPFPREP, 0, "Getting adapters info succeeded but didn't return any valid adapters (%u < %u), returning default address for device 0x%p.",
					ulSize, sizeof(IP_ADAPTER_INFO), pDevice);
				goto Exit;
			}

			break;
		}

		if ((dwError != ERROR_BUFFER_OVERFLOW) &&
			(dwError != ERROR_INSUFFICIENT_BUFFER))
		{
			DPFX(DPFPREP, 0, "Unable to get adapters info (error = 0x%lx), returning default address for device 0x%p.",
				dwError, pDevice);
			goto Exit;
		}

		//
		// We need more adapter space.  Make sure there are adapters for us to
		// use.
		//
		if (ulSize < sizeof(IP_ADAPTER_INFO))
		{
			DPFX(DPFPREP, 0, "Getting adapters info didn't return any valid adapters (%u < %u), returning default address for device 0x%p.",
				ulSize, sizeof(IP_ADAPTER_INFO), pDevice);
			goto Exit;
		}

		//
		// If we previously had a buffer, free it.
		//
		if (pAdaptersBuffer != NULL)
		{
			DNFree(pAdaptersBuffer);
		}

		//
		// Allocate the buffer.
		//
		pAdaptersBuffer = (PIP_ADAPTER_INFO) DNMalloc(ulSize);
		if (pAdaptersBuffer == NULL)
		{
			DPFX(DPFPREP, 0, "Unable to allocate memory for adapters info, returning default address for device 0x%p.",
				pDevice);
			goto Exit;
		}
	}
	while (TRUE);


	//
	// Now find the device in the adapter list returned.  Loop through all
	// adapters.
	//
	pAdapterInfo = pAdaptersBuffer;
	while (pAdapterInfo != NULL)
	{
		//
		// Loop through all addresses for this adapter looking for the one for
		// the device we have bound.
		//
		pIPAddrString = &pAdapterInfo->IpAddressList;
		while (pIPAddrString != NULL)
		{
			if (this->m_pfninet_addr(pIPAddrString->IpAddress.String) == pDevice->GetLocalAddressV4())
			{
				pinaddr->S_un.S_addr = this->m_pfninet_addr(pAdapterInfo->GatewayList.IpAddress.String);
				if ((pinaddr->S_un.S_addr == INADDR_ANY) ||
					(pinaddr->S_un.S_addr == INADDR_NONE))
				{
					DPFX(DPFPREP, 8, "Found address for device 0x%p under adapter index %u (\"%hs\") but there is no gateway.",
						pDevice, pAdapterInfo->Index, pAdapterInfo->Description,
						pAdapterInfo->GatewayList.IpAddress.String);

					//
					// Although this isn't reporting a gateway, we may still
					// want to use this adapter.  That's because this could be
					// a multihomed machine with multiple NICs on the same
					// network, where this one isn't the "default" adapter.
					// So save the index so we can search for it later.
					//
					dwAdapterIndex = pAdapterInfo->Index;

					goto CheckRouteTable;
				}


				//
				// Make sure the address doesn't match the local device.
				//
				if (pinaddr->S_un.S_addr == pDevice->GetLocalAddressV4())
				{
					DPFX(DPFPREP, 1, "Gateway address for device 0x%p (adapter index %u, \"%hs\") matches device IP address %hs!  Forcing no gateway.",
						pDevice, pAdapterInfo->Index, pAdapterInfo->Description,
						pAdapterInfo->GatewayList.IpAddress.String);

					//
					// Pretend there's no gateway, since the one we received is
					// bogus.
					//
#ifdef DBG
					pDevice->NoteNoGateway();
#endif // DBG
					fResult = FALSE;
				}
				else
				{
					DPFX(DPFPREP, 7, "Found address for device 0x%p under adapter index %u (\"%hs\"), gateway = %hs.",
						pDevice, pAdapterInfo->Index, pAdapterInfo->Description,
						pAdapterInfo->GatewayList.IpAddress.String);

#ifdef DBG
					pDevice->NotePrimaryDevice();
#endif // DBG
				}

				goto Exit;
			}

			pIPAddrString = pIPAddrString->Next;
		}

		if (! fResult)
		{
			break;
		}

		pAdapterInfo = pAdapterInfo->Next;
	}


	//
	// If we got here, then we didn't find the address.  fResult will still be
	// TRUE.
	//
	DPFX(DPFPREP, 0, "Did not find adapter with matching address, returning default address for device 0x%p.",
		pDevice);
	goto Exit;


CheckRouteTable:

	//
	// The adapter info structure said that the device doesn't have a gateway.
	// However for some reason the gateway is only reported for the "default"
	// device when multiple NICs can reach the same network.  Check the routing
	// table to determine if there's a gateway for secondary devices.
	//
	
	//
	// Keep trying to get the routing table until we get ERROR_SUCCESS or a
	// legitimate error (other than ERROR_BUFFER_OVERFLOW or
	// ERROR_INSUFFICIENT_BUFFER).
	//
	ulSize = 0;
	do
	{
		dwError = this->m_pfnGetIpForwardTable(pIPForwardTableBuffer, &ulSize, TRUE);
		if (dwError == ERROR_SUCCESS)
		{
			//
			// We succeeded, we should be set.  But make sure the size is
			// valid.
			//
			if (ulSize < sizeof(MIB_IPFORWARDTABLE))
			{
				DPFX(DPFPREP, 0, "Getting IP forward table succeeded but didn't return a valid buffer (%u < %u), returning \"no gateway\" indication for device 0x%p.",
					ulSize, sizeof(MIB_IPFORWARDTABLE), pDevice);
				fResult = FALSE;
				goto Exit;
			}

			break;
		}

		if ((dwError != ERROR_BUFFER_OVERFLOW) &&
			(dwError != ERROR_INSUFFICIENT_BUFFER))
		{
			DPFX(DPFPREP, 0, "Unable to get IP forward table (error = 0x%lx), returning \"no gateway\" indication for device 0x%p.",
				dwError, pDevice);
			fResult = FALSE;
			goto Exit;
		}

		//
		// We need more table space.  Make sure there are adapters for us to
		// use.
		//
		if (ulSize < sizeof(MIB_IPFORWARDTABLE))
		{
			DPFX(DPFPREP, 0, "Getting IP forward table didn't return any valid adapters (%u < %u), returning \"no gateway\" indication for device 0x%p.",
				ulSize, sizeof(MIB_IPFORWARDTABLE), pDevice);
			fResult = FALSE;
			goto Exit;
		}

		//
		// If we previously had a buffer, free it.
		//
		if (pIPForwardTableBuffer != NULL)
		{
			DNFree(pIPForwardTableBuffer);
		}

		//
		// Allocate the buffer.
		//
		pIPForwardTableBuffer = (PMIB_IPFORWARDTABLE) DNMalloc(ulSize);
		if (pIPForwardTableBuffer == NULL)
		{
			DPFX(DPFPREP, 0, "Unable to allocate memory for IP forward table, returning \"no gateway\" indication for device 0x%p.",
				pDevice);
			fResult = FALSE;
			goto Exit;
		}
	}
	while (TRUE);
	
	
	//
	// Now find the interface.  Note that we don't look it up as a destination
	// address.  Instead, we look for it as the interface to use for a 0.0.0.0
	// network destination.
	//
	// We're looking for a route entry:
	//
	//	Network Destination		Netmask		Gateway				Interface			Metric
	//	0.0.0.0					0.0.0.0		xxx.xxx.xxx.xxx		yyy.yyy.yyy.yyy		1
	//
	// We have yyy.yyy.yyy.yyy, we're trying to get xxx.xxx.xxx.xxx
	//
	pIPForwardRow = pIPForwardTableBuffer->table;
	for(dwTemp = 0; dwTemp < pIPForwardTableBuffer->dwNumEntries; dwTemp++)
	{
		//
		// Is this a 0.0.0.0 network destination?
		//
		if (pIPForwardRow->dwForwardDest == INADDR_ANY)
		{
			DNASSERT(pIPForwardRow->dwForwardMask == INADDR_ANY);


			//
			// Is this the right interface?
			//
			if (pIPForwardRow->dwForwardIfIndex == dwAdapterIndex)
			{
				if (pIPForwardRow->dwForwardNextHop == INADDR_ANY)
				{
					DPFX(DPFPREP, 8, "Found route table entry, but it didn't have a gateway (device = 0x%p).",
						pDevice);

					//
					// No gateway.
					//
#ifdef DBG
					pDevice->NoteNoGateway();
#endif // DBG
					fResult = FALSE;
				}
				else
				{
					//
					// Make sure the address doesn't match the local device.
					//
					if (pinaddr->S_un.S_addr == pDevice->GetLocalAddressV4())
					{
						DPFX(DPFPREP, 1, "Route table gateway for device 0x%p matches device's IP address %u.%u.%u.%u!  Forcing no gateway.",
							pDevice,
							pinaddr->S_un.S_un_b.s_b1,
							pinaddr->S_un.S_un_b.s_b2,
							pinaddr->S_un.S_un_b.s_b3,
							pinaddr->S_un.S_un_b.s_b4);

						//
						// Pretend there's no gateway, since the one we
						// received is bogus.
						//
#ifdef DBG
						pDevice->NoteNoGateway();
#endif // DBG
						fResult = FALSE;
					}
					else
					{
						pinaddr->S_un.S_addr = pIPForwardRow->dwForwardNextHop;

						DPFX(DPFPREP, 8, "Found route table entry, gateway = %u.%u.%u.%u (device = 0x%p).",
							pinaddr->S_un.S_un_b.s_b1,
							pinaddr->S_un.S_un_b.s_b2,
							pinaddr->S_un.S_un_b.s_b3,
							pinaddr->S_un.S_un_b.s_b4,
							pDevice);

						//
						// We found a gateway after all, fResult == TRUE.
						//
#ifdef DBG
						pDevice->NoteSecondaryDevice();
#endif // DBG
					}
				}

				//
				// We're done here.
				//
				goto Exit;
			}
		}

		//
		// Move to next row.
		//
		pIPForwardRow++;
	}

	
	//
	// If we got here, then we couldn't find an appropriate entry in the
	// routing table.
	//
	DPFX(DPFPREP, 1, "Did not find adapter in routing table, returning \"no gateway\" indication for device 0x%p.",
		pDevice);
#ifdef DBG
	pDevice->NoteNoGateway();
#endif // DBG
	fResult = FALSE;


Exit:

	if (pAdaptersBuffer != NULL)
	{
		DNFree(pAdaptersBuffer);
		pAdaptersBuffer = NULL;
	}

	if (pIPForwardTableBuffer != NULL)
	{
		DNFree(pIPForwardTableBuffer);
		pIPForwardTableBuffer = NULL;
	}

	return fResult;
} // CNATHelpPAST::GetAddressToReachGateway






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::IsAddressLocal"
//=============================================================================
// CNATHelpPAST::IsAddressLocal
//-----------------------------------------------------------------------------
//
// Description:    Returns TRUE if the given address is local to the given
//				device; that is, if the device can send to the address directly
//				without having to go through the gateway.
//
//				   Note that if IPHLPAPI is not available (Win95), this
//				function will make an educated guess using a reasonable subnet
//				mask.
//
// Arguments:
//	CDevice * pDevice				- Pointer to device to use.
//	SOCKADDR_IN * psaddrinAddress	- Address whose locality is in question.
//
// Returns: BOOL
//	TRUE	- Address is behind the same gateway as the device.
//	FALSE	- Address is not behind the same gateway as the device.
//=============================================================================
BOOL CNATHelpPAST::IsAddressLocal(CDevice * const pDevice,
								const SOCKADDR_IN * const psaddrinAddress)
{
	DWORD				dwError;
	BOOL				fResult;
	MIB_IPFORWARDROW	IPForwardRow;
	DWORD				dwSubnetMaskV4;


	//
	// If the address to query matches the device's local address exactly, then
	// of course it's local.
	//
	if (psaddrinAddress->sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4())
	{
		DPFX(DPFPREP, 6, "The address %u.%u.%u.%u matches device 0x%p's local address exactly.",
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			pDevice);
		fResult = TRUE;
		goto Exit;
	}

	//
	// If it's a multicast address, then it should not be considered local.
	//
	if (IS_CLASSD_IPV4_ADDRESS(psaddrinAddress->sin_addr.S_un.S_addr))
	{
		DPFX(DPFPREP, 6, "Address %u.%u.%u.%u is multicast, not considered local for device 0x%p.",
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			pDevice);
		fResult = FALSE;
		goto Exit;
	}


	//
	// If we didn't load the IP helper DLL, we will have to guess.
	//
	if (this->m_hIpHlpApiDLL == NULL)
	{
		goto EducatedGuess;
	}


	//
	// Figure out what IPHLPAPI says about how to get there.
	//
	
	ZeroMemory(&IPForwardRow, sizeof(IPForwardRow));

	dwError = this->m_pfnGetBestRoute(psaddrinAddress->sin_addr.S_un.S_addr,
									pDevice->GetLocalAddressV4(),
									&IPForwardRow);
	if (dwError != ERROR_SUCCESS)
	{
		DPFX(DPFPREP, 0, "Unable to get best route to %u.%u.%u.%u via device 0x%p (error = 0x%lx)!  Using subnet mask.",
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			pDevice,
			dwError);
		goto EducatedGuess;
	}


	//
	// Key off what IPHLPAPI returned.
	//
	switch (IPForwardRow.dwForwardType)
	{
		case 1:
		{
			//
			// Other.
			//
			DPFX(DPFPREP, 6, "The route from device 0x%p to %u.%u.%u.%u is unknown.",
				pDevice,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);
			fResult = FALSE;
			break;
		}

		case 2:
		{
			//
			// The route is invalid.
			//
			DPFX(DPFPREP, 6, "The route from device 0x%p to %u.%u.%u.%u is invalid.",
				pDevice,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);
			fResult = FALSE;
			break;
		}

		case 3:
		{
			//
			// The next hop is the final destination (local route).
			// Unfortunately, on multi-NIC machines querying an address
			// reachable by another device returns success... not sure why, but
			// if that's the case we need to further qualify this result.  We
			// do that by making sure the next hop address is actually the
			// device with which we're querying.
			//
			if (IPForwardRow.dwForwardNextHop == pDevice->GetLocalAddressV4())
			{
				DPFX(DPFPREP, 6, "Device 0x%p can reach %u.%u.%u.%u directly, it's local.",
					pDevice,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);

				fResult = TRUE;
			}
			else
			{
				DPFX(DPFPREP, 6, "Device 0x%p can reach %u.%u.%u.%u but it would be routed via another device (%u.%u.%u.%u).",
					pDevice,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
					((IN_ADDR*) (&IPForwardRow.dwForwardNextHop))->S_un.S_un_b.s_b1,
					((IN_ADDR*) (&IPForwardRow.dwForwardNextHop))->S_un.S_un_b.s_b2,
					((IN_ADDR*) (&IPForwardRow.dwForwardNextHop))->S_un.S_un_b.s_b3,
					((IN_ADDR*) (&IPForwardRow.dwForwardNextHop))->S_un.S_un_b.s_b4);

				fResult = FALSE;
			}
			break;
		}

		case 4:
		{
			//
			// The next hop is not the final destination (remote route).
			//
			DPFX(DPFPREP, 6, "Device 0x%p cannot reach %u.%u.%u.%u directly.",
				pDevice,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);
			fResult = FALSE;
			break;
		}

		default:
		{
			//
			// What?
			//
			DPFX(DPFPREP, 0, "Unexpected forward type %u for device 0x%p and address %u.%u.%u.%u!",
				IPForwardRow.dwForwardType, pDevice,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);
			fResult = FALSE;
			break;
		}
	}

	goto Exit;


EducatedGuess:


	//
	// This should be atomic, so don't worry about locking.
	//
	dwSubnetMaskV4 = g_dwSubnetMaskV4;

	if ((pDevice->GetLocalAddressV4() & dwSubnetMaskV4) == (psaddrinAddress->sin_addr.S_un.S_addr & dwSubnetMaskV4))
	{
		DPFX(DPFPREP, 4, "Didn't load \"iphlpapi.dll\", guessing that device 0x%p can reach %u.%u.%u.%u (using subnet mask %u.%u.%u.%u).",
			pDevice,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			((IN_ADDR*) (&dwSubnetMaskV4))->S_un.S_un_b.s_b1,
			((IN_ADDR*) (&dwSubnetMaskV4))->S_un.S_un_b.s_b2,
			((IN_ADDR*) (&dwSubnetMaskV4))->S_un.S_un_b.s_b3,
			((IN_ADDR*) (&dwSubnetMaskV4))->S_un.S_un_b.s_b4);
		fResult = TRUE;
	}
	else
	{
		DPFX(DPFPREP, 4, "Didn't load \"iphlpapi.dll\", guessing that device 0x%p cannot reach %u.%u.%u.%u (using subnet mask %u.%u.%u.%u).",
			pDevice,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			((IN_ADDR*) (&dwSubnetMaskV4))->S_un.S_un_b.s_b1,
			((IN_ADDR*) (&dwSubnetMaskV4))->S_un.S_un_b.s_b2,
			((IN_ADDR*) (&dwSubnetMaskV4))->S_un.S_un_b.s_b3,
			((IN_ADDR*) (&dwSubnetMaskV4))->S_un.S_un_b.s_b4);
		fResult = FALSE;
	}


Exit:

	return fResult;
} // CNATHelpPAST::IsAddressLocal





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::ClearDevicesPASTServer"
//=============================================================================
// CNATHelpPAST::ClearDevicesPASTServer
//-----------------------------------------------------------------------------
//
// Description:    Forcefully simulates de-registration with a PAST server
///				without actually going to the network.  This clears all bind
//				IDs, public addresses, and cached mappings for a given device's
//				local or remote server, and should only be called after the
//				server appears to have died.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device whose ports should be unbound.
//	BOOL fRemote		- TRUE if clearing remote PAST server, FALSE if
//							clearing local PAST server.
//
// Returns: None.
//=============================================================================
void CNATHelpPAST::ClearDevicesPASTServer(CDevice * const pDevice,
										const BOOL fRemote)
{
#ifdef DBG
	DNASSERT(pDevice->GetPASTClientID(fRemote) != 0);


	DPFX(DPFPREP, 1, "Clearing PAST server, device = 0x%p, remote = %i",
		pDevice, fRemote);

	pDevice->IncrementPASTServerFailures(fRemote);
	this->m_dwNumServerFailures++;
#endif // DBG


	if (! fRemote)
	{
		pDevice->NoteNoLocalPASTServer();
	}

	pDevice->SetPASTClientID(0, fRemote);

	this->ClearAllPASTServerRegisteredPorts(pDevice, fRemote);
	pDevice->NoteNoPASTPublicAddressAvailable(fRemote);
	this->RemoveAllPASTCachedMappings(pDevice, fRemote);


	//
	// Since there was a change in the network, go back to polling relatively
	// quickly.
	//
	this->ResetNextPollInterval();
} // CNATHelpPAST::ClearDevicesPASTServer




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::ClearAllPASTServerRegisteredPorts"
//=============================================================================
// CNATHelpPAST::ClearAllPASTServerRegisteredPorts
//-----------------------------------------------------------------------------
//
// Description:    Clears all bind IDs and public addresses for a given
//				device's local or remote PAST server.  This should only be
//				called after the PAST server dies because the registered ports
//				remain associated with the device.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device whose ports should be unbound.
//	BOOL fRemote		- TRUE if clearing remote server, FALSE if clearing
//							local server.
//
// Returns: None.
//=============================================================================
void CNATHelpPAST::ClearAllPASTServerRegisteredPorts(CDevice * const pDevice,
													const BOOL fRemote)
{
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;


	DPFX(DPFPREP, 7, "(0x%p) Parameters: (0x%p, %i)", this, pDevice, fRemote);

	pBilink = pDevice->m_blOwnedRegPorts.GetNext();
	while (pBilink != &pDevice->m_blOwnedRegPorts)
	{
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

		if (pRegisteredPort->GetPASTBindID(fRemote) != 0)
		{
			DNASSERT(pRegisteredPort->HasPASTPublicAddressesArray(fRemote));
			DNASSERT(! pRegisteredPort->IsPASTPortUnavailable(fRemote));

			if (pDevice->IsPASTPublicAddressAvailable(fRemote))
			{
				DPFX(DPFPREP, 1, "Registered port 0x%p losing %s PAST public address.",
					pRegisteredPort, ((fRemote) ? _T("remote") : _T("local")));

				//
				// Let the user know next time GetCaps is called.
				//
				this->m_dwFlags |= NATHELPPASTOBJ_ADDRESSESCHANGED;
			}
			else
			{
				DPFX(DPFPREP, 1, "Registered port 0x%p losing %s PAST binding, but it didn't have a public address.",
					pRegisteredPort, ((fRemote) ? _T("remote") : _T("local")));
			}

			pRegisteredPort->ClearPASTPublicAddresses(fRemote);
			pRegisteredPort->SetPASTBindID(0, fRemote);

			DNASSERT(this->m_dwNumLeases > 0);
			this->m_dwNumLeases--;

			DPFX(DPFPREP, 7, "%s PAST lease for 0x%p cleared, total num leases = %u.",
				((fRemote) ? _T("Remote") : _T("Local")), pRegisteredPort, this->m_dwNumLeases);
		}
		else
		{
			DNASSERT(! pRegisteredPort->HasPASTPublicAddressesArray(fRemote));


			//
			// Port no longer unavailable (if it had been).
			//
			pRegisteredPort->NoteNotPASTPortUnavailable(fRemote);
		}

		pBilink = pBilink->GetNext();
	}

	DPFX(DPFPREP, 7, "(0x%p) Leave", this);
} // CNATHelpPAST::ClearAllPASTServerRegisteredPorts




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::ExpireOldCachedMappings"
//=============================================================================
// CNATHelpPAST::ExpireOldCachedMappings
//-----------------------------------------------------------------------------
//
// Description:    Removes any cached mappings for any device which has
//				expired.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpPAST::ExpireOldCachedMappings(void)
{
	DWORD			dwCurrentTime;
	CBilink *		pBilinkDevice;
	CDevice *		pDevice;
	CBilink *		pCachedMaps;
	CBilink *		pBilinkCacheMap;
	CCacheMap *		pCacheMap;


	DPFX(DPFPREP, 7, "(0x%p) Enter", this);


	dwCurrentTime = timeGetTime();


	//
	// Check the PAST cached mappings.
	//
	pBilinkDevice = this->m_blDevices.GetNext();
	while (pBilinkDevice != &this->m_blDevices)
	{
		pDevice = DEVICE_FROM_BILINK(pBilinkDevice);


		//
		// Check the remote PAST server mappings.
		//
		pCachedMaps = pDevice->GetPASTCachedMaps(TRUE);
		pBilinkCacheMap = pCachedMaps->GetNext();
		while (pBilinkCacheMap != pCachedMaps)
		{
			pCacheMap = CACHEMAP_FROM_BILINK(pBilinkCacheMap);
			pBilinkCacheMap = pBilinkCacheMap->GetNext();

			if ((int) (pCacheMap->GetExpirationTime() - dwCurrentTime) < 0)
			{
				DPFX(DPFPREP, 5, "Remote PAST server cached mapping 0x%p has expired.", pCacheMap);

				pCacheMap->m_blList.RemoveFromList();
				delete pCacheMap;
			}
		}


		//
		// Check the local PAST server mappings.
		//
		pCachedMaps = pDevice->GetPASTCachedMaps(FALSE);
		pBilinkCacheMap = pCachedMaps->GetNext();
		while (pBilinkCacheMap != pCachedMaps)
		{
			pCacheMap = CACHEMAP_FROM_BILINK(pBilinkCacheMap);
			pBilinkCacheMap = pBilinkCacheMap->GetNext();

			if ((int) (pCacheMap->GetExpirationTime() - dwCurrentTime) < 0)
			{
				DPFX(DPFPREP, 5, "Local PAST server cached mapping 0x%p has expired.", pCacheMap);

				pCacheMap->m_blList.RemoveFromList();
				delete pCacheMap;
			}
		}

		pBilinkDevice = pBilinkDevice->GetNext();
	}


	DPFX(DPFPREP, 7, "(0x%p) Leave", this);
} // CNATHelpPAST::ExpireOldCachedMappings




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::RemoveAllPASTCachedMappings"
//=============================================================================
// CNATHelpPAST::RemoveAllPASTCachedMappings
//-----------------------------------------------------------------------------
//
// Description:    Removes all cached mappings for a given device's local or
//				remote PAST server.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device whose cache should be emptied.
//	BOOL fRemote		- TRUE if emptying remote server, FALSE if emptying
//							local server.
//
// Returns: None.
//=============================================================================
void CNATHelpPAST::RemoveAllPASTCachedMappings(CDevice * const pDevice,
												const BOOL fRemote)
{
	CBilink *		pCachedMaps;
	CBilink *		pBilink;
	CCacheMap *		pCacheMap;


	pCachedMaps = pDevice->GetPASTCachedMaps(fRemote);
	pBilink = pCachedMaps->GetNext();
	while (pBilink != pCachedMaps)
	{
		pCacheMap = CACHEMAP_FROM_BILINK(pBilink);
		pBilink = pBilink->GetNext();
			
		
		DPFX(DPFPREP, 5, "Removing cached mapping 0x%p.", pCacheMap);

		pCacheMap->m_blList.RemoveFromList();
		delete pCacheMap;
	}
} // CNATHelpPAST::RemoveAllPASTCachedMappings





#ifdef DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpPAST::DebugPrintCurrentStatus"
//=============================================================================
// CNATHelpPAST::DebugPrintCurrentStatus
//-----------------------------------------------------------------------------
//
// Description:    Prints all the devices and mappings to the debug log
//				routines.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpPAST::DebugPrintCurrentStatus(void)
{
	CBilink *			pBilinkDevice;
	CBilink *			pBilinkRegisteredPort;
	CDevice *			pDevice;
	CRegisteredPort *	pRegisteredPort;
	IN_ADDR				inaddrTemp;
	DWORD				dwTemp;
	SOCKADDR_IN *		pasaddrinPrivate;
	SOCKADDR_IN *		pasaddrinRemotePASTPublic;
	SOCKADDR_IN *		pasaddrinLocalPASTPublic;


	DPFX(DPFPREP, 3, "Object flags = 0x%08x", this->m_dwFlags);

	pBilinkDevice = this->m_blDevices.GetNext();
	while (pBilinkDevice != &this->m_blDevices)
	{
		pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
			
		inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();

		DPFX(DPFPREP, 3, "Device 0x%p (%u.%u.%u.%u):",
			pDevice,
			inaddrTemp.S_un.S_un_b.s_b1,
			inaddrTemp.S_un.S_un_b.s_b2,
			inaddrTemp.S_un.S_un_b.s_b3,
			inaddrTemp.S_un.S_un_b.s_b4);


		//
		// Print the gateway information.  We may not have detected it yet,
		// that's okay.
		//
		if (pDevice->IsPrimaryDevice())
		{
			DPFX(DPFPREP, 3, "     Primary device.");
		}
		else if (pDevice->IsSecondaryDevice())
		{
			DPFX(DPFPREP, 3, "     Secondary device.");
		}
		else if (pDevice->HasNoGateway())
		{
			DPFX(DPFPREP, 3, "     Has no gateway.");
		}
		else
		{
			DPFX(DPFPREP, 3, "     No gateway information known.");
		}


		if (pDevice->GetPASTClientID(TRUE) != 0)
		{
			inaddrTemp.S_un.S_addr = pDevice->GetRemotePASTServerAddressV4();

			DPFX(DPFPREP, 3, "     Remote ICS PAST server %u.%u.%u.%u, client ID is %u.",
				inaddrTemp.S_un.S_un_b.s_b1,
				inaddrTemp.S_un.S_un_b.s_b2,
				inaddrTemp.S_un.S_un_b.s_b3,
				inaddrTemp.S_un.S_un_b.s_b4,
				pDevice->GetPASTClientID(TRUE));
		}

		if (pDevice->HasLocalICSPASTServer())
		{
			DPFX(DPFPREP, 3, "     Local ICS PAST server, client ID is %u.",
				pDevice->GetPASTClientID(FALSE));
		}

		if (pDevice->HasLocalPFWOnlyPASTServer())
		{
			DPFX(DPFPREP, 3, "     Local PFW-only PAST server, client ID is %u.",
				pDevice->GetPASTClientID(FALSE));
		}



		if (pDevice->m_blOwnedRegPorts.IsEmpty())
		{
			DPFX(DPFPREP, 3, "     No registered port mappings.");
		}
		else
		{
			DPFX(DPFPREP, 3, "     Registered port mappings:");


			pBilinkRegisteredPort = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilinkRegisteredPort != &pDevice->m_blOwnedRegPorts)
			{
				pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegisteredPort);
					
				pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();


				if ((pDevice->GetPASTClientID(TRUE) != 0) &&
					(pDevice->IsPASTPublicAddressAvailable(TRUE)) &&
					(! pRegisteredPort->IsPASTPortUnavailable(TRUE)))
				{
					if (pRegisteredPort->HasPASTPublicAddressesArray(TRUE))
					{
						pasaddrinRemotePASTPublic = pRegisteredPort->GetPASTPublicAddressesArray(TRUE);
					}
					else
					{
						pasaddrinRemotePASTPublic = NULL;
					}
				}
				else
				{
					pasaddrinRemotePASTPublic = NULL;
				}

				if ((pDevice->GetPASTClientID(FALSE) != 0) &&
					(pDevice->IsPASTPublicAddressAvailable(FALSE)) &&
					(! pRegisteredPort->IsPASTPortUnavailable(FALSE)))
				{
					if (pRegisteredPort->HasPASTPublicAddressesArray(FALSE))
					{
						pasaddrinLocalPASTPublic = pRegisteredPort->GetPASTPublicAddressesArray(FALSE);
					}
					else
					{
						pasaddrinLocalPASTPublic = NULL;
					}
				}
				else
				{
					pasaddrinLocalPASTPublic = NULL;
				}


				DPFX(DPFPREP, 3, "          Registered port 0x%p:",
					pRegisteredPort);

				for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
				{
					//
					// Print private address.
					//
					DPFX(DPFPREP, 3, "               %u-\tPrivate     = %u.%u.%u.%u:%u",
						dwTemp,
						pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b1,
						pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b2,
						pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b3,
						pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b4,
						NTOHS(pasaddrinPrivate[dwTemp].sin_port));

					//
					// Print flags.
					//
					DPFX(DPFPREP, 3, "                \tFlags       = 0x%lx",
						pRegisteredPort->GetFlags());


					//
					// Print remote PAST information.
					//
					if (pasaddrinRemotePASTPublic != NULL)
					{
						DPFX(DPFPREP, 3, "                \tRemote PAST = %u.%u.%u.%u:%u, lease %u expires at %u",
							pasaddrinRemotePASTPublic[dwTemp].sin_addr.S_un.S_un_b.s_b1,
							pasaddrinRemotePASTPublic[dwTemp].sin_addr.S_un.S_un_b.s_b2,
							pasaddrinRemotePASTPublic[dwTemp].sin_addr.S_un.S_un_b.s_b3,
							pasaddrinRemotePASTPublic[dwTemp].sin_addr.S_un.S_un_b.s_b4,
							NTOHS(pasaddrinRemotePASTPublic[dwTemp].sin_port),
							pRegisteredPort->GetPASTBindID(TRUE),
							pRegisteredPort->GetPASTLeaseExpiration(TRUE));
					}
					else if (pRegisteredPort->GetPASTBindID(TRUE) != 0)
					{
						//
						// We should have caught address availability up above.
						//
						DNASSERT(! pDevice->IsPASTPublicAddressAvailable(TRUE));


						DPFX(DPFPREP, 3, "                \tRemote PAST = no public address (lease %u expires at %u)",
							pRegisteredPort->GetPASTBindID(TRUE),
							pRegisteredPort->GetPASTLeaseExpiration(TRUE));
					}
					else if (pRegisteredPort->IsPASTPortUnavailable(TRUE))
					{
						DPFX(DPFPREP, 3, "                \tRemote PAST = port unavailable");
					}
					else if (pDevice->GetPASTClientID(TRUE) != 0)
					{
						DPFX(DPFPREP, 3, "                \tRemote PAST = not registered");
					}
					else
					{
						//
						// No remote PAST server.
						//
					}


					//
					// Print local PAST information.
					//
					if (pasaddrinLocalPASTPublic != NULL)
					{
						DPFX(DPFPREP, 3, "                \tLocal PAST  = %u.%u.%u.%u:%u, lease %u expires at %u",
							pasaddrinLocalPASTPublic[dwTemp].sin_addr.S_un.S_un_b.s_b1,
							pasaddrinLocalPASTPublic[dwTemp].sin_addr.S_un.S_un_b.s_b2,
							pasaddrinLocalPASTPublic[dwTemp].sin_addr.S_un.S_un_b.s_b3,
							pasaddrinLocalPASTPublic[dwTemp].sin_addr.S_un.S_un_b.s_b4,
							NTOHS(pasaddrinLocalPASTPublic[dwTemp].sin_port),
							pRegisteredPort->GetPASTBindID(FALSE),
							pRegisteredPort->GetPASTLeaseExpiration(FALSE));
					}
					else if (pRegisteredPort->GetPASTBindID(FALSE) != 0)
					{
						//
						// We should have caught address availability up above.
						//
						DNASSERT(! pDevice->IsPASTPublicAddressAvailable(FALSE));


						DPFX(DPFPREP, 3, "                \tLocal PAST  = no public address (lease %u expires at %u)",
							pRegisteredPort->GetPASTBindID(FALSE),
							pRegisteredPort->GetPASTLeaseExpiration(FALSE));
					}
					else if (pRegisteredPort->IsPASTPortUnavailable(FALSE))
					{
						DPFX(DPFPREP, 3, "                \tLocal PAST  = port unavailable");
					}
					else if (pDevice->GetPASTClientID(TRUE) != 0)
					{
						DPFX(DPFPREP, 3, "                \tLocal PAST  = not registered");
					}
					else
					{
						//
						// No local PAST server.
						//
					}
				}

				pBilinkRegisteredPort = pBilinkRegisteredPort->GetNext();
			}
		}


		pBilinkDevice = pBilinkDevice->GetNext();
	}



	if (this->m_blUnownedPorts.IsEmpty())
	{
		DPFX(DPFPREP, 3, "No unowned registered port mappings.");
	}
	else
	{
		DPFX(DPFPREP, 3, "Unowned registered port mappings:");


		pBilinkRegisteredPort = this->m_blUnownedPorts.GetNext();
		while (pBilinkRegisteredPort != &this->m_blUnownedPorts)
		{
			pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegisteredPort);
				
			pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

			DNASSERT(pRegisteredPort->GetOwningDevice() == NULL);
			DNASSERT(! (pRegisteredPort->HasPASTPublicAddressesArray(TRUE)));
			DNASSERT(! (pRegisteredPort->HasPASTPublicAddressesArray(FALSE)));
			DNASSERT(pRegisteredPort->GetPASTBindID(TRUE) == 0);
			DNASSERT(pRegisteredPort->GetPASTBindID(FALSE) == 0);


			DPFX(DPFPREP, 3, "     Registered port 0x%p:", pRegisteredPort);

			for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
			{
				//
				// Print private address.
				//
				DPFX(DPFPREP, 3, "          %u-\tPrivate = %u.%u.%u.%u:%u",
					dwTemp,
					pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b1,
					pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b2,
					pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b3,
					pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b4,
					NTOHS(pasaddrinPrivate[dwTemp].sin_port));

				//
				// Print flags.
				//
				DPFX(DPFPREP, 3, "           \tFlags   = 0x%lx",
					pRegisteredPort->GetFlags());
			}

			pBilinkRegisteredPort = pBilinkRegisteredPort->GetNext();
		}
	}
} // CNATHelpPAST::DebugPrintCurrentStatus

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpastregport.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhpastregport.h
 *
 *  Content:	Header for registered port object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



//=============================================================================
// Object flags
//=============================================================================
#define REGPORTOBJ_TCP							DPNHREGISTERPORTS_TCP			// TCP ports instead of UDP
#define REGPORTOBJ_FIXEDPORTS					DPNHREGISTERPORTS_FIXEDPORTS	// the PAST server should use same port numbers on public interface
#define REGPORTOBJ_SHAREDPORTS					DPNHREGISTERPORTS_SHAREDPORTS	// the PAST server should allow these UDP fixed ports to be shared with other clients

#define REGPORTOBJ_PORTUNAVAILABLE_PAST_LOCAL	0x80000000						// the port is unavailable on the local PAST server
#define REGPORTOBJ_PORTUNAVAILABLE_PAST_REMOTE	0x40000000						// the port is unavailable on the remote PAST server




//=============================================================================
// Macros
//=============================================================================
#define REGPORT_FROM_GLOBAL_BILINK(b)	(CONTAINING_OBJECT(b, CRegisteredPort, m_blGlobalList))
#define REGPORT_FROM_DEVICE_BILINK(b)	(CONTAINING_OBJECT(b, CRegisteredPort, m_blDeviceList))




//=============================================================================
// Table of PAST address states
//=============================================================================
//
// PubAddrAvailFlag	= pDevice->IsPASTPublicAddressAvailable()
// ClientID			= pRegisteredPort->GetPASTClientID()
// BindID			= pRegisteredPort->GetPASTBindID()
// PortUnavailable	= pRegisteredPort->IsPASTPortUnavailable()
// HasPubAddrArray	= pRegisteredPort->HasPASTPublicAddressesArray() (which is debug only)
//
//									PubAddrAvailFlag	ClientID	BindID		PortUnavailable		HasPubAddrArray
// No server -						   FALSE			  0			 0			   FALSE			  FALSE
// Server but port unavailable -	   FALSE			  not 0		 0			   TRUE				  FALSE
// Server's pub addr is 0.0.0.0 -	   FALSE			  not 0		 not 0		   FALSE			  TRUE
// Server's pub addr is valid -		   TRUE				  not 0		 not 0		   FALSE			  TRUE
//





//=============================================================================
// Registered port object class
//=============================================================================
class CRegisteredPort
{
	public:
#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::CRegisteredPort"
		CRegisteredPort(const DWORD dwRequestedLeaseTime,
						const DWORD dwFlags)
		{
			this->m_blGlobalList.Initialize();
			this->m_blDeviceList.Initialize();

			this->m_Sig[0] = 'R';
			this->m_Sig[1] = 'E';
			this->m_Sig[2] = 'G';
			this->m_Sig[3] = 'P';

			this->m_pOwningDevice				= NULL;
			this->m_pasaddrinPrivateAddresses	= NULL;
			this->m_dwNumAddresses				= 0;
			this->m_dwRequestedLeaseTime		= dwRequestedLeaseTime;
			this->m_dwFlags						= dwFlags; // works because REGPORTOBJ_xxx == DPNHREGISTERPORTS_xxx.
			this->m_lUserRefs					= 0;

			this->m_dwLocalPASTServerBindID						= 0;
			this->m_dwLocalPASTServerLeaseExpiration			= 0;
			this->m_pasaddrinLocalPASTServerPublicAddresses		= NULL;

			this->m_dwRemotePASTServerBindID					= 0;
			this->m_dwRemotePASTServerLeaseExpiration			= 0;
			this->m_pasaddrinRemotePASTServerPublicAddresses	= NULL;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::~CRegisteredPort"
		~CRegisteredPort(void)
		{
			DNASSERT(this->m_blGlobalList.IsEmpty());
			DNASSERT(this->m_blDeviceList.IsEmpty());

			DNASSERT(this->m_lUserRefs == 0);
			DNASSERT(this->m_pasaddrinPrivateAddresses == NULL);

			DNASSERT(this->m_dwLocalPASTServerBindID == 0);
			DNASSERT(this->m_pasaddrinLocalPASTServerPublicAddresses == NULL);

			DNASSERT(this->m_dwRemotePASTServerBindID == 0);
			DNASSERT(this->m_pasaddrinRemotePASTServerPublicAddresses == NULL);


			//
			// For grins, change the signature before deleting the object.
			//
			this->m_Sig[3]	= 'p';
		};


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CRegisteredPort))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x50474552)	// 0x50 0x47 0x45 0x52 = 'PGER' = 'REGP' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};


		//
		// You must have global object lock to call this function.
		//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::MakeDeviceOwner"
		inline void MakeDeviceOwner(CDevice * const pDevice)
		{
			DNASSERT(pDevice != NULL);
			DNASSERT(this->m_pOwningDevice == NULL);

			this->m_pOwningDevice = pDevice;
			this->m_blDeviceList.InsertAfter(&pDevice->m_blOwnedRegPorts);
		};


		//
		// You must have global object lock to call this function.
		//
		inline CDevice * GetOwningDevice(void)		{ return this->m_pOwningDevice; };


		//
		// You must have global object lock to call this function.
		//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::ClearDeviceOwner"
		inline void ClearDeviceOwner(void)
		{
			DNASSERT(this->m_pOwningDevice != NULL);

			this->m_pOwningDevice = NULL;
			this->m_blDeviceList.RemoveFromList();
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::SetPrivateAddresses"
		HRESULT SetPrivateAddresses(const SOCKADDR_IN * const asaddrinPrivateAddresses,
									const DWORD dwNumAddresses)
		{
			DNASSERT((this->m_pasaddrinPrivateAddresses == NULL) && (this->m_dwNumAddresses == 0));

			this->m_pasaddrinPrivateAddresses = (SOCKADDR_IN *) DNMalloc(dwNumAddresses * sizeof(SOCKADDR_IN));
			if (this->m_pasaddrinPrivateAddresses == NULL)
			{
				return DPNHERR_OUTOFMEMORY;
			}

			CopyMemory(this->m_pasaddrinPrivateAddresses, asaddrinPrivateAddresses, dwNumAddresses * sizeof(SOCKADDR_IN));
			this->m_dwNumAddresses = dwNumAddresses;

			return DPNH_OK;
		}


		inline void AddUserRef(void)									{ this->m_lUserRefs++; };

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::DecUserRef"
		inline LONG DecUserRef(void)
		{
			DNASSERT(this->m_lUserRefs >= 0);
			this->m_lUserRefs--;
			return this->m_lUserRefs;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::ClearAllUserRefs"
		inline void ClearAllUserRefs(void)
		{
			DNASSERT(this->m_lUserRefs > 0);
			this->m_lUserRefs = 0;
		};

		inline SOCKADDR_IN * GetPrivateAddressesArray(void)				{ return this->m_pasaddrinPrivateAddresses; };
		inline DWORD GetNumAddresses(void) const								{ return this->m_dwNumAddresses; };
		inline DWORD GetRequestedLeaseTime(void) const						{ return this->m_dwRequestedLeaseTime; };
		inline BOOL IsTCP(void) const											{ return ((this->m_dwFlags & REGPORTOBJ_TCP) ? TRUE : FALSE); };
		inline BOOL IsFixedPort(void) const									{ return ((this->m_dwFlags & REGPORTOBJ_FIXEDPORTS) ? TRUE : FALSE); };
		inline BOOL IsSharedPort(void) const									{ return ((this->m_dwFlags & REGPORTOBJ_SHAREDPORTS) ? TRUE : FALSE); };

		inline DWORD GetAddressesSize(void)	const							{ return (this->GetNumAddresses() * sizeof(SOCKADDR_IN)); };


		inline void ClearPrivateAddresses(void)
		{
			if (this->m_pasaddrinPrivateAddresses != NULL)
			{
				DNFree(this->m_pasaddrinPrivateAddresses);
				this->m_pasaddrinPrivateAddresses = NULL;
			}
		};

		inline void UpdateRequestedLeaseTime(const DWORD dwRequestedLeaseTime)
		{
			this->m_dwRequestedLeaseTime = dwRequestedLeaseTime;
		};


		inline BOOL IsPASTPortUnavailable(const BOOL fRemote) const
		{
			if (fRemote)
			{
				return ((this->m_dwFlags & REGPORTOBJ_PORTUNAVAILABLE_PAST_REMOTE) ? TRUE : FALSE);
			}
			else
			{
				return ((this->m_dwFlags & REGPORTOBJ_PORTUNAVAILABLE_PAST_LOCAL) ? TRUE : FALSE);
			}
		};


		inline BOOL HasPASTPublicAddressesArray(const BOOL fRemote)
		{
			if (fRemote)
			{
				return ((this->m_pasaddrinRemotePASTServerPublicAddresses != NULL) ? TRUE : FALSE);
			}
			else
			{
				return ((this->m_pasaddrinLocalPASTServerPublicAddresses != NULL) ? TRUE : FALSE);
			}
		};


#ifdef DBG
		//
		// This is for debug printing only.
		//
		inline DWORD GetFlags(void) const		{ return this->m_dwFlags; };
#endif // DBG


#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::IsFirstPASTPublicV4AddressDifferent"
		inline BOOL IsFirstPASTPublicV4AddressDifferent(const DWORD dwAddressV4,
														const BOOL fRemote)
		{
			DNASSERT(this->HasPASTPublicAddressesArray(fRemote));

			if (fRemote)
			{
				return ((this->m_pasaddrinRemotePASTServerPublicAddresses[0].sin_addr.S_un.S_addr != dwAddressV4) ? TRUE : FALSE);
			}
			else
			{
				return ((this->m_pasaddrinLocalPASTServerPublicAddresses[0].sin_addr.S_un.S_addr != dwAddressV4) ? TRUE : FALSE);
			}
		};
		
		inline DWORD GetPASTBindID(const BOOL fRemote) const				{ return ((fRemote) ? this->m_dwRemotePASTServerBindID : this->m_dwLocalPASTServerBindID); };
		inline DWORD GetPASTLeaseExpiration(const BOOL fRemote) const		{ return ((fRemote) ? this->m_dwRemotePASTServerLeaseExpiration : this->m_dwLocalPASTServerLeaseExpiration); };


#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::CopyPASTPublicAddresses"
		inline void CopyPASTPublicAddresses(SOCKADDR_IN * aPublicAddresses,
											const BOOL fRemote)
		{
			DNASSERT(this->HasPASTPublicAddressesArray(fRemote));

			if (fRemote)
			{
				CopyMemory(aPublicAddresses, this->m_pasaddrinRemotePASTServerPublicAddresses, this->GetAddressesSize());
			}
			else
			{
				CopyMemory(aPublicAddresses, this->m_pasaddrinLocalPASTServerPublicAddresses, this->GetAddressesSize());
			}
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::NotePASTPortUnavailable"
		inline void NotePASTPortUnavailable(const BOOL fRemote)
		{
			if (fRemote)
			{
				DNASSERT(! (this->m_dwFlags & REGPORTOBJ_PORTUNAVAILABLE_PAST_REMOTE));
				this->m_dwFlags |= REGPORTOBJ_PORTUNAVAILABLE_PAST_REMOTE;
			}
			else
			{
				DNASSERT(! (this->m_dwFlags & REGPORTOBJ_PORTUNAVAILABLE_PAST_LOCAL));
				this->m_dwFlags |= REGPORTOBJ_PORTUNAVAILABLE_PAST_LOCAL;
			}
		};


		inline void NoteNotPASTPortUnavailable(const BOOL fRemote)
		{
			if (fRemote)
			{
				this->m_dwFlags &= ~REGPORTOBJ_PORTUNAVAILABLE_PAST_REMOTE;
			}
			else
			{
				this->m_dwFlags &= ~REGPORTOBJ_PORTUNAVAILABLE_PAST_LOCAL;
			}
		};


		inline void SetPASTBindID(const DWORD dwBindID,
								const BOOL fRemote)
		{
			if (fRemote)
			{
				this->m_dwRemotePASTServerBindID = dwBindID;
			}
			else
			{
				this->m_dwLocalPASTServerBindID = dwBindID;
			}
		};

		inline void SetPASTLeaseExpiration(const DWORD dwLeaseExpiration,
											const BOOL fRemote)
		{
			if (fRemote)
			{
				this->m_dwRemotePASTServerLeaseExpiration = dwLeaseExpiration;
			}
			else
			{
				this->m_dwLocalPASTServerLeaseExpiration = dwLeaseExpiration;
			}
		};

		inline void ClearPASTPublicAddresses(const BOOL fRemote)
		{
			if (fRemote)
			{
				if (this->m_pasaddrinRemotePASTServerPublicAddresses != NULL)
				{
					DNFree(this->m_pasaddrinRemotePASTServerPublicAddresses);
					this->m_pasaddrinRemotePASTServerPublicAddresses = NULL;
				}
			}
			else
			{
				if (this->m_pasaddrinLocalPASTServerPublicAddresses != NULL)
				{
					DNFree(this->m_pasaddrinLocalPASTServerPublicAddresses);
					this->m_pasaddrinLocalPASTServerPublicAddresses = NULL;
				}
			}
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::SetPASTPublicV4Addresses"
		inline HRESULT SetPASTPublicV4Addresses(const DWORD dwAddressV4,
												const WORD * const awPorts,
												const DWORD dwNumPorts,
												const BOOL fRemote)
		{
			DWORD	dwTemp;


			DNASSERT(! this->HasPASTPublicAddressesArray(fRemote));
			DNASSERT(dwNumPorts == this->GetNumAddresses());

			if (fRemote)
			{
				this->m_pasaddrinRemotePASTServerPublicAddresses = (SOCKADDR_IN*) DNMalloc(dwNumPorts * sizeof(SOCKADDR_IN));
				if (this->m_pasaddrinRemotePASTServerPublicAddresses == NULL)
				{
					return DPNHERR_OUTOFMEMORY;
				}

				for(dwTemp = 0; dwTemp < dwNumPorts; dwTemp++)
				{
					this->m_pasaddrinRemotePASTServerPublicAddresses[dwTemp].sin_family				= AF_INET;
					this->m_pasaddrinRemotePASTServerPublicAddresses[dwTemp].sin_addr.S_un.S_addr	= dwAddressV4;
					this->m_pasaddrinRemotePASTServerPublicAddresses[dwTemp].sin_port				= awPorts[dwTemp];
				}
			}
			else
			{
				this->m_pasaddrinLocalPASTServerPublicAddresses = (SOCKADDR_IN*) DNMalloc(dwNumPorts * sizeof(SOCKADDR_IN));
				if (this->m_pasaddrinLocalPASTServerPublicAddresses == NULL)
				{
					return DPNHERR_OUTOFMEMORY;
				}

				for(dwTemp = 0; dwTemp < dwNumPorts; dwTemp++)
				{
					this->m_pasaddrinLocalPASTServerPublicAddresses[dwTemp].sin_family				= AF_INET;
					this->m_pasaddrinLocalPASTServerPublicAddresses[dwTemp].sin_addr.S_un.S_addr	= dwAddressV4;
					this->m_pasaddrinLocalPASTServerPublicAddresses[dwTemp].sin_port				= awPorts[dwTemp];
				}
			}

			return DPNH_OK;
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::UpdatePASTPublicV4Addresses"
		inline void UpdatePASTPublicV4Addresses(const DWORD dwAddressV4,
												const BOOL fRemote)
		{
			DWORD	dwTemp;


			DNASSERT(this->HasPASTPublicAddressesArray(fRemote));

			if (fRemote)
			{

				for(dwTemp = 0; dwTemp < this->GetNumAddresses(); dwTemp++)
				{
					this->m_pasaddrinRemotePASTServerPublicAddresses[dwTemp].sin_addr.S_un.S_addr	= dwAddressV4;
				}
			}
			else
			{
				for(dwTemp = 0; dwTemp < this->GetNumAddresses(); dwTemp++)
				{
					this->m_pasaddrinLocalPASTServerPublicAddresses[dwTemp].sin_addr.S_un.S_addr	= dwAddressV4;
				}
			}
		};


		//
		// Debugging function only.
		//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::GetPASTPublicAddressesArray"
		inline SOCKADDR_IN * GetPASTPublicAddressesArray(const BOOL fRemote)
		{
			DNASSERT(this->HasPASTPublicAddressesArray(fRemote));

			if (fRemote)
			{
				return this->m_pasaddrinRemotePASTServerPublicAddresses;
			}
			else
			{
				return this->m_pasaddrinLocalPASTServerPublicAddresses;
			}
		};



		CBilink		m_blGlobalList;	// list of all the ports registered
		CBilink		m_blDeviceList;	// list of ports registered for a particular device

	
	private:
		//
		// Note that all values here are protected by the global CNATHelpPAST lock.
		//
		BYTE			m_Sig[4];						// debugging signature ('REGP')
		CDevice *		m_pOwningDevice;				// pointer to owning device object
		SOCKADDR_IN *	m_pasaddrinPrivateAddresses;	// array of private addresses registered by this object
		DWORD			m_dwNumAddresses;				// number of private (and public, if available) addresses in use by this object
		DWORD			m_dwRequestedLeaseTime;			// requested lease time for object
		DWORD			m_dwFlags;						// flags for this object
		LONG			m_lUserRefs;					// number of user references for this port mapping

		DWORD			m_dwLocalPASTServerBindID;					// ID assigned by local PAST server when mapping is bound
		DWORD			m_dwLocalPASTServerLeaseExpiration;			// time when lease expires on local PAST server
		SOCKADDR_IN *	m_pasaddrinLocalPASTServerPublicAddresses;	// array of public addresses local PAST server assigned for this mapping

		DWORD			m_dwRemotePASTServerBindID;					// ID assigned by remote PAST server when mapping is bound
		DWORD			m_dwRemotePASTServerLeaseExpiration;		// time when lease expires on remote PAST server
		SOCKADDR_IN *	m_pasaddrinRemotePASTServerPublicAddresses;	// array of public addresses remote PAST server assigned for this mapping
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpastlocals.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhpastlocals.h
 *
 *  Content:	Header for DPNHPAST global variables and functions found in
 *				dpnhpastdllmain.cpp.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



//=============================================================================
// Registry locations
//=============================================================================
#define REGKEY_COMPONENTSUBKEY			L"DPNHPAST"




///=============================================================================
// External defines
//=============================================================================
#define OVERRIDEMODE_DEFAULT		0	// leave settings alone
#define OVERRIDEMODE_FORCEON		1	// force it to be on, regardless of Initialize flags
#define OVERRIDEMODE_FORCEOFF		2	// force it to be off, regardless of Initialize flags




///=============================================================================
// External variable references
//=============================================================================
extern volatile LONG		g_lOutstandingInterfaceCount;

extern DNCRITICAL_SECTION	g_csGlobalsLock;
extern CBilink				g_blNATHelpPASTObjs;
extern DWORD				g_dwHoldRand;

extern DWORD				g_dwPASTICSMode;
extern DWORD				g_dwPASTPFWMode;
extern INT					g_iUnicastTTL;
extern DWORD				g_dwDefaultGatewayV4;
extern DWORD				g_dwSubnetMaskV4;
extern DWORD				g_dwNoActiveNotifyPollInterval;
extern DWORD				g_dwMinUpdateServerStatusInterval;
extern DWORD				g_dwPollIntervalBackoff;
extern DWORD				g_dwMaxPollInterval;
extern BOOL					g_fKeepPollingForRemoteGateway;
extern DWORD				g_dwReusePortTime;
extern DWORD				g_dwCacheLifeFound;
extern DWORD				g_dwCacheLifeNotFound;





//=============================================================================
// External function references
//=============================================================================
void ReadRegistrySettings(void);
DWORD GetGlobalRand(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\sources.inc ===
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dpnhpasti.h
PRECOMPILED_PCH=dpnhpasti.pch
PRECOMPILED_OBJ=dpnhpasti.obj

TARGETNAME=dpnhpast
TARGETTYPE=DYNLINK

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

DLLDEF=..\dpnhpast.def

INCLUDES=$(DXROOT)\inc; \
	$(NET_INC_PATH); \
	..\..\common; \
	..\..\inc; \
	..\

SOURCES=..\dpnhpast.rc \
	..\dpnhpastclassfac.cpp \
	..\dpnhpastdllmain.cpp \
	..\dpnhpastintfobj.cpp

TARGETLIBS=$(TARGETLIBS) \
	..\..\guids\$(PLAT_DIR)\$(O)\guids.lib \
	..\..\common\$(PLAT_DIR)\$(O)\common.lib

#	$(SDK_LIB_PATH)\kernel32.lib \
#	$(SDK_LIB_PATH)\user32.lib \
#	$(SDK_LIB_PATH)\winmm.lib \
#	$(SDK_LIB_PATH)\advapi32.lib \
#	$(SDK_LIB_PATH)\ole32.lib \
#	$(SDK_LIB_PATH)\oleaut32.lib \
#	$(SDK_LIB_PATH)\uuid.lib \
#	$(SDK_LIB_PATH)\msvcrt.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpastintfobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhpastintfobj.h
 *
 *  Content:	Header for DPNHPAST main interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



//=============================================================================
// Defines
//=============================================================================
#define NETWORKBYTEORDER_INADDR_LOOPBACK	0x0100007f




//=============================================================================
// Macros
//=============================================================================
#define NATHELPPAST_FROM_BILINK(b)		(CONTAINING_OBJECT(b, CNATHelpPAST, m_blList))



//=============================================================================
// Typedefs
//=============================================================================
class CNATHelpPAST;




//=============================================================================
// Object flags
//=============================================================================
#define NATHELPPASTOBJ_NOTCREATEDWITHCOM	0x0001	// object was created through non-COM DirectPlayNATHelpCreate function
#define NATHELPPASTOBJ_INITIALIZED			0x0002	// object has been initialized
#define NATHELPPASTOBJ_USEPASTICS			0x0004	// PAST can be used for ICS NAT traversal
#define NATHELPPASTOBJ_USEPASTPFW			0x0008	// PAST can be used for opening Personal Firewall
#define NATHELPPASTOBJ_WINSOCK1				0x0010	// only WinSock 1 functionality is available
#define NATHELPPASTOBJ_DEVICECHANGED		0x0020	// short lived flag that overrides min update server status interval when a device is added or removed
#define NATHELPPASTOBJ_ADDRESSESCHANGED		0x0040	// flag indicating that server status changed since the last time the user checked
#define NATHELPPASTOBJ_PORTREGISTERED		0x0080	// short lived flag that allows remote gateway check when a port has been registered




//=============================================================================
// Structures
//=============================================================================
typedef struct _PAST_RESPONSE_INFO
{
	CHAR	cVersion;
	CHAR	cMsgType;

	DWORD	dwClientID;
	DWORD	dwMsgID;
	DWORD	dwBindID;
	DWORD	dwLeaseTime;
	CHAR	cTunnelType;
	CHAR	cPASTMethod;
	DWORD	dwLocalAddressV4;
	CHAR	cNumLocalPorts;
	WORD	awLocalPorts[DPNH_MAX_SIMULTANEOUS_PORTS];
	DWORD	dwRemoteAddressV4;
	CHAR	cNumRemotePorts;
	WORD	awRemotePorts[DPNH_MAX_SIMULTANEOUS_PORTS];
	WORD	wError;
} PAST_RESPONSE_INFO, * PPAST_RESPONSE_INFO;





//=============================================================================
// WinSock function definitions left out by winsock2.h
//=============================================================================
typedef INT (WSAAPI * LPFN___WSAFDISSET)		(SOCKET, fd_set FAR *);



//=============================================================================
// IPHLPAPI function prototypes
//=============================================================================
typedef DWORD (WINAPI *PFN_GETADAPTERSINFO)		(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);
typedef DWORD (WINAPI *PFN_GETIPFORWARDTABLE)	(PMIB_IPFORWARDTABLE pIpForwardTable, PULONG pdwSize, BOOL bOrder);
typedef DWORD (WINAPI *PFN_GETBESTROUTE)		(DWORD dwDestAddr, DWORD dwSourceAddr, PMIB_IPFORWARDROW pBestRoute);




//=============================================================================
// Main interface object class
//=============================================================================
class CNATHelpPAST : public IDirectPlayNATHelp
{
	public:
		CNATHelpPAST(const BOOL fNotCreatedWithCOM);	// constructor
		~CNATHelpPAST(void);	// destructor


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

		STDMETHODIMP_(ULONG) AddRef(void);

		STDMETHODIMP_(ULONG) Release(void);


		STDMETHODIMP Initialize(const DWORD dwFlags);

		STDMETHODIMP Close(const DWORD dwFlags);

		STDMETHODIMP GetCaps(DPNHCAPS * const pdpnhcaps,
							const DWORD dwFlags);

		STDMETHODIMP RegisterPorts(const SOCKADDR * const aLocalAddresses,
									const DWORD dwAddressesSize,
									const DWORD dwNumAddresses,
									const DWORD dwLeaseTime,
									DPNHHANDLE * const phRegisteredPorts,
									const DWORD dwFlags);

		STDMETHODIMP GetRegisteredAddresses(const DPNHHANDLE hRegisteredPorts,
											SOCKADDR * const paPublicAddresses,
											DWORD * const pdwPublicAddressesSize,
											DWORD * const pdwAddressTypeFlags,
											DWORD * const pdwLeaseTimeRemaining,
											const DWORD dwFlags);

		STDMETHODIMP DeregisterPorts(const DPNHHANDLE hRegisteredPorts,
									const DWORD dwFlags);

		STDMETHODIMP QueryAddress(const SOCKADDR * const pSourceAddress,
								const SOCKADDR * const pQueryAddress,
								SOCKADDR * const pResponseAddress,
								const int iAddressesSize,
								const DWORD dwFlags);

		STDMETHODIMP SetAlertEvent(const HANDLE hEvent, const DWORD dwFlags);

		STDMETHODIMP SetAlertIOCompletionPort(const HANDLE hIOCompletionPort,
											const DWORD dwCompletionKey,
											const DWORD dwNumConcurrentThreads,
											const DWORD dwFlags);

		STDMETHODIMP ExtendRegisteredPortsLease(const DPNHHANDLE hRegisteredPorts,
												const DWORD dwLeaseTime,
												const DWORD dwFlags);


		HRESULT InitializeObject(void);

		void UninitializeObject(void);



		CBilink		m_blList;	// list of all the NATHelper instances in existence


	private:
		BYTE							m_Sig[4];							// debugging signature ('NATH')
		LONG							m_lRefCount;						// reference count for this object
		DWORD							m_dwFlags;							// flags for this object
		DNCRITICAL_SECTION				m_csLock;							// lock preventing simultaneous usage
		DWORD							m_dwLockThreadID;					// ID of thread currently holding the lock
		HANDLE							m_hAlertEvent;						// handle to alert event, if any
		HANDLE							m_hAlertIOCompletionPort;			// handle to alert I/O completion port, if any
		DWORD							m_dwAlertCompletionKey;				// alert completion key to use, if any

		CBilink							m_blDevices;						// list of all IP capable devices
		CBilink							m_blRegisteredPorts;				// list of all the ports registered (may or may not be mapped with a PAST server)
		CBilink							m_blUnownedPorts;					// list of all the registered ports which could not be associated with specific devices

		DWORD							m_dwLastUpdateServerStatusTime;		// last time the server status was updated
		DWORD							m_dwNextPollInterval;				// next GetCaps poll interval to use
		DWORD							m_dwNumLeases;						// number of registered ports which have successfully been leased
		DWORD							m_dwEarliestLeaseExpirationTime;	// time when first registered port lease expires, if there are any

		HMODULE							m_hIpHlpApiDLL;						// handle to iphlpapi.dll, if available
		PFN_GETADAPTERSINFO				m_pfnGetAdaptersInfo;				// pointer to GetAdaptersInfo function
		PFN_GETIPFORWARDTABLE			m_pfnGetIpForwardTable;				// pointer to GetIpForwardTable function
		PFN_GETBESTROUTE				m_pfnGetBestRoute;					// pointer to GetBestRoute function

		SOCKET							m_sIoctls;							// socket being used to submit Ioctls (WinSock2 only) and used for PAST address change checks
		WORD							m_wIoctlSocketPort;					// port of bound Ioctl socket, for PAST address change checks, in network byte order
		WSAOVERLAPPED *					m_polAddressListChange;				// pointer overlapped structure for address list change WSAIoctl call

		HMODULE							m_hWinSockDLL;						// handle to wsock32.dll or ws2_32.dll
		LPFN_WSASTARTUP					m_pfnWSAStartup;					// pointer to WSAStartup function
		LPFN_WSACLEANUP					m_pfnWSACleanup;					// pointer to WSACleanup function
		LPFN_WSAGETLASTERROR			m_pfnWSAGetLastError;				// pointer to WSAGetLastError function
		LPFN_SOCKET						m_pfnsocket;						// pointer to socket function
		LPFN_CLOSESOCKET				m_pfnclosesocket;					// pointer to closesocket function
		LPFN_BIND						m_pfnbind;							// pointer to bind function
		LPFN_SETSOCKOPT					m_pfnsetsockopt;					// pointer to setsockopt function
		LPFN_GETSOCKNAME				m_pfngetsockname;					// pointer to getsockname function
		LPFN_SELECT						m_pfnselect;						// pointer to select function
		LPFN___WSAFDISSET				m_pfn__WSAFDIsSet;					// pointer to __WSAFDIsSet function
		LPFN_RECVFROM					m_pfnrecvfrom;						// pointer to recvfrom function
		LPFN_SENDTO						m_pfnsendto;						// pointer to sendto function
		LPFN_GETHOSTNAME				m_pfngethostname;					// pointer to gethostname function
		LPFN_GETHOSTBYNAME				m_pfngethostbyname;					// pointer to gethostbyname function
		LPFN_INET_ADDR					m_pfninet_addr;						// pointer to inet_addr function
		LPFN_WSASOCKETA					m_pfnWSASocketA;					// pointer to WSASocket function
		LPFN_WSAIOCTL					m_pfnWSAIoctl;						// WinSock2 only, pointer to WSAIoctl function
		LPFN_WSAGETOVERLAPPEDRESULT		m_pfnWSAGetOverlappedResult;		// WinSock2 only, pointer to WSAGetOverlappedResult function
#ifdef DBG


		DWORD							m_dwNumDeviceAdds;					// how many times devices were added
		DWORD							m_dwNumDeviceRemoves;				// how many times devices were removed
		DWORD							m_dwNumServerFailures;				// how many times a UPnP gateway device or PAST server returned a failure or stopped responding and had to be removed
#endif // DBG



		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CNATHelpPAST))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x4854414E)	// 0x48 0x54 0x41 0x4E = 'HTAN' = 'NATH' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};

		inline void ResetNextPollInterval(void)
		{
			//
			// Reading this DWORD should be atomic, so no need to hold the
			// globals lock.
			//
			this->m_dwNextPollInterval = g_dwNoActiveNotifyPollInterval;
		};


		HRESULT TakeLock(void);

		void DropLock(void);

		HRESULT LoadWinSockFunctionPointers(void);

		HRESULT CheckForNewDevices(BOOL * const pfFoundNewDevices);

		HRESULT CheckForLocalPASTServerAndRegister(CDevice * const pDevice);

		void RemoveAllItems(void);

		CDevice * FindMatchingDevice(const SOCKADDR_IN * const psaddrinMatch,
									const BOOL fMatchRegPort);

		HRESULT RegisterWithLocalPASTServer(CDevice * const pDevice);

		HRESULT DeregisterWithPASTServer(CDevice * const pDevice,
										const BOOL fRemote);

		HRESULT ExtendAllExpiringLeases(void);

		HRESULT UpdateServerStatus(void);

		HRESULT AssignOrListenPASTPort(CRegisteredPort * const pRegisteredPort,
										const BOOL fRemote);

		HRESULT FreePASTPort(CRegisteredPort * const pRegisteredPort,
							const BOOL fRemote);

		HRESULT InternalPASTQueryAddress(CDevice * const pDevice,
										const SOCKADDR_IN * const psaddrinQueryAddress,
										SOCKADDR_IN * const psaddrinResponseAddress,
										const DWORD dwFlags,
										const BOOL fRemote);

		HRESULT ExtendPASTLease(CRegisteredPort * const pRegisteredPort,
								const BOOL fRemote);

		HRESULT UpdatePASTPublicAddressValidity(CDevice * const pDevice,
												const BOOL fRemote);

		HRESULT RegisterAllPortsWithPAST(CDevice * const pDevice,
										const BOOL fRemote);

		HRESULT RegisterPreviouslyUnownedPortsWithDevice(CDevice * const pDevice,
														const BOOL fWildcardToo);

		HRESULT ExchangeAndParsePAST(const SOCKET sSocket,
									const SOCKADDR * const psaddrServerAddress,
									const int iAddressesSize,
									const char * const pcRequestBuffer,
									const int iRequestBufferSize,
									const DWORD dwMsgID,
									DWORD * const ptuRetry,
									PAST_RESPONSE_INFO * const pRespInfo);

		HRESULT RegisterMultipleDevicesWithRemotePAST(CBilink * pSourceList,
													CDevice ** ppFirstDeviceWithRemoteServer);

		HRESULT ParsePASTMessage(const char * const pcMsg,
								const int iMsgSize,
								PAST_RESPONSE_INFO * const pRespInfo);

		HRESULT RequestLocalAddressListChangeNotification(void);

		SOCKET CreatePASTSocket(SOCKADDR_IN * const psaddrinAddress);

		BOOL GetAddressToReachGateway(CDevice * const pDevice,
									IN_ADDR * const pinaddr);

		BOOL IsAddressLocal(CDevice * const pDevice,
							const SOCKADDR_IN * const psaddrinAddress);

		void ClearDevicesPASTServer(CDevice * const pDevice,
									const BOOL fRemote);

		void ClearAllPASTServerRegisteredPorts(CDevice * const pDevice,
												const BOOL fRemote);

		void ExpireOldCachedMappings(void);

		static void RemoveAllPASTCachedMappings(CDevice * const pDevice,
										const BOOL fRemote);

#ifdef DBG
		void DebugPrintCurrentStatus(void);
#endif // DBG
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\pastmsgs.h ===
/***************************************************************************
 *
 *	Copyright (C) 1999 - 2001 Microsoft Corporation.	All Rights Reserved.
 *
 *	File:		pastmsgs.h
 *
 *	Content:	Messages for PAST (Protocol for Address Space Traversal).
 *
 *	History:
 *   Date        By          Reason
 *	========	========	=========
 *	12/07/99	AaronO		Original.
 *	03/17/00	JohnKan		Modified for DPlay8.
 *	02/05/01	VanceO		Moved to DPNATHLP.DLL.
 *  04/16/01	VanceO		Moved to DPNHPAST.DLL.
 *
 ***************************************************************************/




//=============================================================================
// Constant definitions
//=============================================================================

#define PAST_VERSION		1
#define PAST_HOST_PORT		2234

#define	PAST_ANY_ADDRESS	0
#define	PAST_ANY_PORT		0

#define PAST_MS_VENDOR_ID	734





//=============================================================================
// Parameter types
//=============================================================================

//
// Tunnel types
//
enum
{
	PAST_TUNNEL_RESERVED = 0,
	PAST_TUNNEL_IP_IP = 1,
	PAST_TUNNEL_GRE = 2, // PPTP
	PAST_TUNNEL_L2TP = 3,
	//PAST_TUNNEL_NONE = 4, // THIS IS NOT PART OF THE SPEC
};


//
// PAST methods
//
enum
{
	PAST_METHOD_RESERVED = 0,
	PAST_METHOD_RSA_IP = 1,
	PAST_METHOD_RSAP_IP = 2,
	PAST_METHOD_RSA_IP_IPSEC = 3,
	PAST_METHOD_RSAP_IP_IPSEC = 4,
};


//
// Flow types
//
enum
{
	PAST_FLOW_RESERVED = 0,
	PAST_FLOW_MACRO = 1,
	PAST_FLOW_MICRO = 2,
	PAST_FLOW_NONE = 3,
};


//
// Address types
//
enum
{
	PAST_ADDRESSTYPE_RESERVED = 0,
	PAST_ADDRESSTYPE_IPV4 = 1,			// 4 bytes
	PAST_ADDRESSTYPE_IPV4_NETMASK = 2,	// 4 bytes
	PAST_ADDRESSTYPE_IPV6 = 3,			// 16 bytes
	PAST_ADDRESSTYPE_IPV6_NETMASK = 4,	// 16 bytes
	PAST_ADDRESSTYPE_FQDN = 5,			// varies
};


//
// MS specific Vendor Codes
//
enum
{
	PAST_VC_MS_NO_TUNNEL = 1,
	PAST_VC_MS_TCP_PORT = 2,
	PAST_VC_MS_UDP_PORT = 3,
	PAST_VC_MS_SHARED_UDP_LISTENER = 4,
	PAST_VC_MS_QUERY_MAPPING = 5,
};





//=============================================================================
// Message IDs
//=============================================================================
enum
{
	PAST_MSGID_ERROR_RESPONSE = 1,
	PAST_MSGID_REGISTER_REQUEST = 2,
	PAST_MSGID_REGISTER_RESPONSE = 3,
	PAST_MSGID_DEREGISTER_REQUEST = 4,
	PAST_MSGID_DEREGISTER_RESPONSE = 5,
	PAST_MSGID_ASSIGN_REQUEST_RSA_IP = 6,
	PAST_MSGID_ASSIGN_RESPONSE_RSA_IP = 7,
	PAST_MSGID_ASSIGN_REQUEST_RSAP_IP = 8,
	PAST_MSGID_ASSIGN_RESPONSE_RSAP_IP = 9,
	PAST_MSGID_EXTEND_REQUEST = 10,
	PAST_MSGID_EXTEND_RESPONSE = 11,
	PAST_MSGID_FREE_REQUEST = 12,
	PAST_MSGID_FREE_RESPONSE = 13,
	PAST_MSGID_QUERY_REQUEST = 14,
	PAST_MSGID_QUERY_RESPONSE = 15,
	PAST_MSGID_DEALLOCATE = 16,
	PAST_MSGID_OK = 17,
	PAST_MSGID_LISTEN_REQUEST = 18,
	PAST_MSGID_LISTEN_RESPONSE = 19,
};



//=============================================================================
// Message parameters
//=============================================================================
enum
{
	PAST_PARAMID_ADDRESS = 1,
	PAST_PARAMID_PORTS = 2,
	PAST_PARAMID_LEASE = 3,
	PAST_PARAMID_CLIENTID = 4,
	PAST_PARAMID_BINDID = 5,
	PAST_PARAMID_MESSAGEID = 6,
	PAST_PARAMID_TUNNELTYPE = 7,
	PAST_PARAMID_PASTMETHOD = 8,
	PAST_PARAMID_ERROR = 9,
	PAST_PARAMID_FLOWPOLICY = 10,
	PAST_PARAMID_VENDOR = 11,
};


//=============================================================================
// Structures
//=============================================================================
#pragma pack(push,1)


typedef struct _PAST_PARAM
{
	CHAR	code;
	WORD	len;
} PAST_PARAM, *PPAST_PARAM;


typedef struct _PAST_PARAM_MESSAGEID
{
	CHAR	code;
	WORD	len;

	DWORD	msgid;	
} PAST_PARAM_MESSAGEID, *PPAST_PARAM_MESSAGEID;

typedef struct _PAST_PARAM_CLIENTID
{
	CHAR	code;
	WORD	len;

	DWORD	clientid;
} PAST_PARAM_CLIENTID, *PPAST_PARAM_CLIENTID;

typedef struct _PAST_PARAM_ADDRESS
{
	CHAR	code;
	WORD	len;

	CHAR	version;	// ADDRESSTYPE_IPV4 == 1 == v4
	DWORD	addr;
} PAST_PARAM_ADDRESS, *PPAST_PARAM_ADDRESS;

typedef struct _PAST_PARAM_PORTS
{
	CHAR	code;
	WORD	len;

	CHAR	nports;		// we only do 1 port at a time
	WORD	port;		// NOTE: they appear to be transferred in x86 byte order, contrary to the spec, which says network byte order
} PAST_PARAM_PORTS, *PPAST_PARAM_PORTS;

typedef struct _PAST_PARAM_LEASE
{
	CHAR	code;
	WORD	len;

	DWORD	leasetime;
} PAST_PARAM_LEASE, *PPAST_PARAM_LEASE;

typedef struct _PAST_PARAM_BINDID
{
	CHAR	code;
	WORD	len;

	DWORD	bindid;
} PAST_PARAM_BINDID, *PPAST_PARAM_BINDID;

typedef struct _PAST_PARAM_TUNNELTYPE
{
	CHAR	code;
	WORD	len;

	CHAR	tunneltype;
} PAST_PARAM_TUNNELTYPE, *PPAST_PARAM_TUNNELTYPE;


typedef struct _PAST_PARAM_MSVENDOR_CODE {
	CHAR	code;
	WORD	len;

	WORD	vendorid;
	WORD	option;
} PAST_PARAM_MSVENDOR_CODE, *PPAST_MSVENDOR_CODE;



//
// PAST Message templates
//
typedef struct _PAST_MSG
{
	CHAR	version;
	CHAR	msgtype;
} PAST_MSG, *PPAST_MSG;


typedef struct _PAST_MSG_REGISTER_REQUEST
{
	CHAR					version;
	CHAR					command;

	PAST_PARAM_MESSAGEID	msgid;
} PAST_MSG_REGISTER, *PPAST_MSG_REGISTER_REQUEST;

typedef struct _PAST_MSG_DEREGISTER_REQUEST
{
	CHAR					version;
	CHAR					command;

	PAST_PARAM_CLIENTID		clientid;
	PAST_PARAM_MESSAGEID	msgid;
} PAST_MSG_DEREGISTER_REQUEST, *PPAST_MSG_DEREGISTER_REQUEST;

typedef struct _PAST_MSG_ASSIGN_REQUEST_RSAP_IP
{
	CHAR						version;
	CHAR						command;

	PAST_PARAM_CLIENTID			clientid;
	PAST_PARAM_ADDRESS			laddress;	// local
	PAST_PARAM_PORTS			lport;
	PAST_PARAM_ADDRESS			raddress;	// remote
	PAST_PARAM_PORTS			rport;
	PAST_PARAM_LEASE			lease;
	PAST_PARAM_TUNNELTYPE		tunneltype;
	PAST_PARAM_MESSAGEID		msgid;

	PAST_PARAM_MSVENDOR_CODE	porttype;
	PAST_PARAM_MSVENDOR_CODE	tunneloptions;
} PAST_MSG_ASSIGN_REQUEST_RSAP_IP, *PPAST_MSG_ASSIGN_REQUEST_RSAP_IP;


typedef struct _PAST_MSG_LISTEN_REQUEST
{
	CHAR						version;
	CHAR						command;

	PAST_PARAM_CLIENTID			clientid;
	PAST_PARAM_ADDRESS			laddress;	// local
	PAST_PARAM_PORTS			lport;
	PAST_PARAM_ADDRESS			raddress;	// remote
	PAST_PARAM_PORTS			rport;
	PAST_PARAM_LEASE			lease;
	PAST_PARAM_TUNNELTYPE		tunneltype;
	PAST_PARAM_MESSAGEID		msgid;

	PAST_PARAM_MSVENDOR_CODE	porttype;
	PAST_PARAM_MSVENDOR_CODE	tunneloptions;
} PAST_MSG_LISTEN_REQUEST, *PPAST_MSG_LISTEN_REQUEST;


//
// This isn't a real message, it's the same thing as LISTEN, but with an
// extra vendor option.
//
typedef struct _PAST_MSG_LISTEN_REQUEST_SHARED
{
	CHAR						version;
	CHAR						command;

	PAST_PARAM_CLIENTID			clientid;
	PAST_PARAM_ADDRESS			laddress;	// local
	PAST_PARAM_PORTS			lport;
	PAST_PARAM_ADDRESS			raddress;	// remote
	PAST_PARAM_PORTS			rport;
	PAST_PARAM_LEASE			lease;
	PAST_PARAM_TUNNELTYPE		tunneltype;
	PAST_PARAM_MESSAGEID		msgid;

	PAST_PARAM_MSVENDOR_CODE	porttype;
	PAST_PARAM_MSVENDOR_CODE	tunneloptions;
	PAST_PARAM_MSVENDOR_CODE	listentype;
} PAST_MSG_LISTEN_REQUEST_SHARED, *PPAST_MSG_LISTEN_REQUEST_SHARED;

//
// Take advantage of fact that ASSIGN, LISTEN, SHAREDLISTEN look almost
// identical.
//
typedef struct _PAST_MSG_ASSIGNORLISTEN_REQUEST
{
	union
	{
		PAST_MSG_ASSIGN_REQUEST_RSAP_IP		assign;
		PAST_MSG_LISTEN_REQUEST				listen;
		PAST_MSG_LISTEN_REQUEST_SHARED		sharedlisten;
	};
} PAST_MSG_ASSIGNORLISTEN_REQUEST, *PPAST_MSG_ASSIGNORLISTEN_REQUEST;


typedef struct _PAST_MSG_EXTEND_REQUEST
{
	CHAR					version;
	CHAR					command;

	PAST_PARAM_CLIENTID		clientid;
	PAST_PARAM_BINDID		bindid;
	PAST_PARAM_LEASE		lease;
	PAST_PARAM_MESSAGEID	msgid;
} PAST_MSG_EXTEND_REQUEST, *PPAST_MSG_EXTEND_REQUEST;


typedef struct _PAST_MSG_FREE_REQUEST
{
	CHAR					version;
	CHAR					command;

	PAST_PARAM_CLIENTID		clientid;
	PAST_PARAM_BINDID		bindid;
	PAST_PARAM_MESSAGEID	msgid;	
} PAST_MSG_FREE_REQUEST, *PPAST_MSG_FREE_REQUEST;


typedef struct _PAST_MSG_QUERY_REQUEST_PORTS
{
	CHAR						version;
	CHAR						command;

	PAST_PARAM_CLIENTID			clientid;
	PAST_PARAM_ADDRESS			address;
	PAST_PARAM_PORTS			port;

	PAST_PARAM_MSVENDOR_CODE	porttype;
	PAST_PARAM_MSVENDOR_CODE	querytype;

	PAST_PARAM_MESSAGEID		msgid;
} PAST_MSG_QUERY_REQUEST_PORTS, *PPAST_MSG_QUERY_REQUEST_PORTS;

typedef struct _PAST_MSG_QUERY_REQUEST_ADDRONLY
{
	CHAR						version;
	CHAR						command;

	PAST_PARAM_CLIENTID			clientid;
	PAST_PARAM_ADDRESS			address;

	PAST_PARAM_MESSAGEID		msgid;
} PAST_MSG_QUERY_REQUEST_ADDRONLY, *PPAST_MSG_QUERY_REQUEST_ADDRONLY;


#pragma pack(pop)





//=============================================================================
// Errors
//=============================================================================
enum
{
	PASTERR_UNKNOWNERROR = 1,
	PASTERR_BADBINDID = 2,
	PASTERR_BADCLIENTID = 3,
	PASTERR_MISSINGPARAM = 4,
	PASTERR_DUPLICATEPARAM = 5,
	PASTERR_ILLEGALPARAM = 6,
	PASTERR_ILLEGALMESSAGE = 7,
	PASTERR_REGISTERFIRST = 8,
	PASTERR_BADMESSAGEID = 9,
	PASTERR_ALREADYREGISTERED = 10,
	PASTERR_ALREADYUNREGISTERED = 11,
	PASTERR_BADTUNNELTYPE = 12,
	PASTERR_ADDRUNAVAILABLE = 13,
	PASTERR_PORTUNAVAILABLE = 14,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpcachemap.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhupnpcachemap.h
 *
 *  Content:	Header for cached mapping object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



//=============================================================================
// Object flags
//=============================================================================
#define CACHEMAPOBJ_TCP					DPNHQUERYADDRESS_TCP						// a TCP port instead of UDP
#define CACHEMAPOBJ_NOTFOUND			DPNHQUERYADDRESS_CACHENOTFOUND				// the address was actually not found
#define CACHEMAPOBJ_PRIVATEBUTUNMAPPED	DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED	// the address is private, but was not mapped on the Internet gateway



//=============================================================================
// Macros
//=============================================================================
#define CACHEMAP_FROM_BILINK(b)		(CONTAINING_OBJECT(b, CCacheMap, m_blList))

//
// TCP queries need to match TCP mappings, (and UDP needs to match UDP).
//
#define QUERYFLAGSMASK(dwFlags)		(dwFlags & DPNHQUERYADDRESS_TCP)



//=============================================================================
// Forward declarations
//=============================================================================
class CCacheMap;




//=============================================================================
// Main interface object class
//=============================================================================
class CCacheMap
{
	public:
#undef DPF_MODNAME
#define DPF_MODNAME "CCacheMap::CCacheMap"
		CCacheMap(const SOCKADDR_IN * const psaddrinQueryAddress,
				const DWORD dwExpirationTime,
				const DWORD dwFlags)
		{
			this->m_blList.Initialize();

			this->m_Sig[0] = 'C';
			this->m_Sig[1] = 'M';
			this->m_Sig[2] = 'A';
			this->m_Sig[3] = 'P';
			this->m_dwQueryAddressV4	= psaddrinQueryAddress->sin_addr.S_un.S_addr;
			this->m_wQueryPort			= psaddrinQueryAddress->sin_port;
			this->m_dwFlags				= dwFlags; // works because CACHEMAPOBJ_xxx == DPNHQUERYADDRESS_xxx.
			this->m_dwExpirationTime	= dwExpirationTime;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CCacheMap::~CCacheMap"
		~CCacheMap(void)
		{
			DNASSERT(this->m_blList.IsEmpty());
		};

		inline BOOL DoesMatchQuery(const SOCKADDR_IN * const psaddrinQueryAddress,
									const DWORD dwFlags) const
		{
			//
			// Is this even the right address?
			//
			if ((this->m_dwQueryAddressV4 != psaddrinQueryAddress->sin_addr.S_un.S_addr) ||
				(this->m_wQueryPort != psaddrinQueryAddress->sin_port))
			{
				return FALSE;
			}

			//
			// Of the ones that matter (QUERYFLAGSMASK), make sure all
			// required flags are present, and all flags that aren't
			// required are not present.
			// Remember CACHEMAPOBJ_xxx == DPNHQUERYADDRESS_xxx.
			//
			return ((QUERYFLAGSMASK(this->m_dwFlags) == QUERYFLAGSMASK(dwFlags)) ? TRUE : FALSE);
		};

		inline BOOL IsNotFound(void) const					{ return ((this->m_dwFlags & CACHEMAPOBJ_NOTFOUND) ? TRUE : FALSE); };
		inline BOOL IsPrivateButUnmapped(void) const			{ return ((this->m_dwFlags & CACHEMAPOBJ_PRIVATEBUTUNMAPPED) ? TRUE : FALSE); };

		inline void GetResponseAddressV4(SOCKADDR_IN * const psaddrinAddress) const
		{
			ZeroMemory(psaddrinAddress, sizeof(*psaddrinAddress));
			psaddrinAddress->sin_family				= AF_INET;
			psaddrinAddress->sin_addr.S_un.S_addr	= this->m_dwResponseAddressV4;
			psaddrinAddress->sin_port				= this->m_wResponsePort;
		};

		inline DWORD GetExpirationTime(void) const			{ return this->m_dwExpirationTime; };

		inline void SetResponseAddressV4(const DWORD dwAddressV4,
										const WORD wPort)
		{
			this->m_dwResponseAddressV4	= dwAddressV4;
			this->m_wResponsePort		= wPort;
		};


		CBilink		m_blList;		// list of all the mappings cached

	
	private:
		BYTE	m_Sig[4];				// debugging signature ('CMAP')
		DWORD	m_dwFlags;				// flags for this object

		DWORD	m_dwQueryAddressV4;		// IPv4 address searched
		WORD	m_wQueryPort;			// IPv4 port searched
		DWORD	m_dwResponseAddressV4;	// IPv4 address mapping corresponding to query
		WORD	m_wResponsePort;		// IPv4 port mapping corresponding to query
		DWORD	m_dwExpirationTime;		// time when this cached mapping expires
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpi.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhupnpi.h
 *
 *  Content:	DPNHUPNP master internal header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/

#ifndef __DPNHUPNPI_H__
#define __DPNHUPNPI_H__


//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//

#ifdef WINCE

#include <winsock.h>
#include <windows.h>
#include <ole2.h>
#include <wincrypt.h>	// for random numbers
#include <mmsystem.h>   // NT BUILD requires this for timeGetTime
#include <tchar.h>

#else // ! WINCE

#define INCL_WINSOCK_API_TYPEDEFS 1
#define _WIN32_DCOM // so we can use CoSetProxyBlanket and CoInitializeEx.  requires DCOM95 on Win95

#include <winsock2.h>
#include <ws2tcpip.h>

#include <windows.h>
#include <ole2.h>
#include <wincrypt.h>	// for random numbers
#include <mmsystem.h>   // NT BUILD requires this for timeGetTime
#include <tchar.h>

#include <iphlpapi.h>
#include <upnp.h>
#include <netcon.h>
#include <ras.h>

// 
// Net published includes
//
#include <hnetcfg.h>

#endif // ! WINCE



// 
// DirectPlay public includes
//
#include "dpnathlp.h"


// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"
#include "classbilink.h"
#include "creg.h"
#include "createin.h"
#include "strutils.h"


// 
// DirectPlayNATHelp private includes
//

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_NATHELP

#include "dpnhupnplocals.h"
#include "dpnhupnpdevice.h"
#include "dpnhupnpregport.h"
#include "dpnhupnpcachemap.h"
#include "upnpmsgs.h"
#include "upnpdevice.h"
#include "dpnhupnpintfobj.h"




#endif // __DPNHUPNPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpdevice.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhupnpdevice.h
 *
 *  Content:	Header for device object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/




//=============================================================================
// Object flags
//=============================================================================
#ifndef DPNBUILD_NOHNETFWAPI
#define DEVICE_CHECKEDFORHNETFIREWALL					0x0001	// the check for a local HomeNet firewall has been performed for the device at least once
#define DEVICE_HNETFIREWALLED							0x0002	// the device is firewalled, and can be controlled with the HomeNet APIs
#define DEVICE_UPNPDISCOVERYSOCKETMAPPEDONHNETFIREWALL	0x0004	// the UPnP discovery socket for this device was mapped on the firewall
#endif // ! DPNBUILD_NOHNETFWAPI
#define DEVICE_PERFORMINGREMOTEUPNPDISCOVERY			0x0008	// the check for a remote UPnP gateway device is being performed
#define DEVICE_PERFORMINGLOCALUPNPDISCOVERY				0x0010	// the check for a local UPnP gateway device is being performed
#define DEVICE_GOTREMOTEUPNPDISCOVERYCONNRESET			0x0020	// the check for a remote UPnP gateway device generated a WSAECONNRESET error
#define DEVICE_GOTLOCALUPNPDISCOVERYCONNRESET			0x0040	// the check for a local UPnP gateway device generated a WSAECONNRESET error
#ifdef DBG
#ifndef DPNBUILD_NOWINSOCK2
   #define DEVICE_PRIMARY								0x0080	// this device appears to be the primary adapter with which its gateway should be reached
   #define DEVICE_SECONDARY								0x0100	// this device appears to be a secondary adapter on a shared network
   #define DEVICE_NOGATEWAY								0x0200	// this device does not currently have a gateway
#endif // ! DPNBUILD_NOWINSOCK2
#endif // DBG



//=============================================================================
// Macros
//=============================================================================
#define DEVICE_FROM_BILINK(b)		(CONTAINING_OBJECT(b, CDevice, m_blList))
#define DEVICE_FROM_TEMP_BILINK(b)	(CONTAINING_OBJECT(b, CDevice, m_blTempList))



//=============================================================================
// Typedefs
//=============================================================================
class CDevice;
class CUPnPDevice;




//=============================================================================
// Device object class
//=============================================================================
class CDevice
{
	public:
#undef DPF_MODNAME
#define DPF_MODNAME "CDevice::CDevice"
		CDevice(const DWORD dwLocalAddressV4)
		{
			this->m_blList.Initialize();
			this->m_blTempList.Initialize();
			this->m_blOwnedRegPorts.Initialize();

			this->m_Sig[0] = 'D';
			this->m_Sig[1] = 'E';
			this->m_Sig[2] = 'V';
			this->m_Sig[3] = 'I';

			this->m_dwFlags						= 0;
			this->m_dwLocalAddressV4			= dwLocalAddressV4;
			this->m_wUPnPDiscoverySocketPort	= 0;
			this->m_sUPnPDiscoverySocket		= INVALID_SOCKET;
			this->m_pUPnPDevice					= NULL;
			this->m_dwFirstUPnPDiscoveryTime	= 0;

#ifdef DBG
			this->m_dwNumUPnPDeviceFailures		= 0;
#endif // DBG
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDevice::~CDevice"
		~CDevice(void)
		{
#ifdef DBG
			DPFX(DPFPREP, 8, "(0x%p) NumUPnPDeviceFailures = %u",
				this, this->m_dwNumUPnPDeviceFailures);


			DNASSERT(this->m_blList.IsEmpty());
			DNASSERT(this->m_blTempList.IsEmpty());
			DNASSERT(this->m_blOwnedRegPorts.IsEmpty());

#ifndef DPNBUILD_NOHNETFWAPI
			DNASSERT(! (this->m_dwFlags & DEVICE_UPNPDISCOVERYSOCKETMAPPEDONHNETFIREWALL));
#endif // ! DPNBUILD_NOHNETFWAPI
			DNASSERT(this->m_sUPnPDiscoverySocket == INVALID_SOCKET);
			DNASSERT(this->m_pUPnPDevice == NULL);
#endif // DBG
		};


#ifndef DPNBUILD_NOHNETFWAPI
		inline BOOL HasCheckedForFirewallAvailability(void) const			{ return ((this->m_dwFlags & DEVICE_CHECKEDFORHNETFIREWALL) ? TRUE : FALSE); };
		inline BOOL IsHNetFirewalled(void) const							{ return ((this->m_dwFlags & DEVICE_HNETFIREWALLED) ? TRUE : FALSE); };
		inline BOOL IsUPnPDiscoverySocketMappedOnHNetFirewall(void) const	{ return ((this->m_dwFlags & DEVICE_UPNPDISCOVERYSOCKETMAPPEDONHNETFIREWALL) ? TRUE : FALSE); };
#endif // ! DPNBUILD_NOHNETFWAPI
		inline BOOL IsOKToPerformRemoteUPnPDiscovery(void) const			{ return (((this->m_dwFlags & DEVICE_PERFORMINGREMOTEUPNPDISCOVERY) && (! (this->m_dwFlags & DEVICE_GOTREMOTEUPNPDISCOVERYCONNRESET)))? TRUE : FALSE); };
		inline BOOL IsOKToPerformLocalUPnPDiscovery(void) const				{ return (((this->m_dwFlags & DEVICE_PERFORMINGLOCALUPNPDISCOVERY) && (! (this->m_dwFlags & DEVICE_GOTLOCALUPNPDISCOVERYCONNRESET)))? TRUE : FALSE); };

		inline BOOL GotRemoteUPnPDiscoveryConnReset(void) const				{ return ((this->m_dwFlags & DEVICE_GOTREMOTEUPNPDISCOVERYCONNRESET) ? TRUE : FALSE); };
		inline BOOL GotLocalUPnPDiscoveryConnReset(void) const				{ return ((this->m_dwFlags & DEVICE_GOTLOCALUPNPDISCOVERYCONNRESET) ? TRUE : FALSE); };
#ifdef DBG
		inline BOOL IsPerformingRemoteUPnPDiscovery(void) const				{ return ((this->m_dwFlags & DEVICE_PERFORMINGREMOTEUPNPDISCOVERY) ? TRUE : FALSE); };
		inline BOOL IsPerformingLocalUPnPDiscovery(void) const				{ return ((this->m_dwFlags & DEVICE_PERFORMINGLOCALUPNPDISCOVERY) ? TRUE : FALSE); };

#ifndef DPNBUILD_NOWINSOCK2
		inline BOOL IsPrimaryDevice(void) const								{ return ((this->m_dwFlags & DEVICE_PRIMARY) ? TRUE : FALSE); };
		inline BOOL IsSecondaryDevice(void) const							{ return ((this->m_dwFlags & DEVICE_SECONDARY) ? TRUE : FALSE); };
		inline BOOL HasNoGateway(void) const								{ return ((this->m_dwFlags & DEVICE_NOGATEWAY) ? TRUE : FALSE); };
#endif // ! DPNBUILD_NOWINSOCK2
#endif // DBG


		inline DWORD GetLocalAddressV4(void) const				{ return this->m_dwLocalAddressV4; };

		inline WORD GetUPnPDiscoverySocketPort(void) const		{ return this->m_wUPnPDiscoverySocketPort; };

		inline SOCKET GetUPnPDiscoverySocket(void) const		{ return this->m_sUPnPDiscoverySocket; };

		//
		// This does not add a reference (when not NULL)!
		//
		inline CUPnPDevice * GetUPnPDevice(void)				{ return this->m_pUPnPDevice; };

		inline DWORD GetFirstUPnPDiscoveryTime(void) const		{ return this->m_dwFirstUPnPDiscoveryTime; };


#ifndef DPNBUILD_NOHNETFWAPI
		inline void NoteCheckedForFirewallAvailability(void)	{ this->m_dwFlags |= DEVICE_CHECKEDFORHNETFIREWALL; };

#undef DPF_MODNAME
#define DPF_MODNAME "CDevice::NoteHNetFirewalled"
		inline void NoteHNetFirewalled(void)
		{
			DNASSERT(! (this->m_dwFlags & DEVICE_HNETFIREWALLED));
			this->m_dwFlags |= DEVICE_HNETFIREWALLED;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDevice::NoteUPnPDiscoverySocketMappedOnHNetFirewall"
		inline void NoteUPnPDiscoverySocketMappedOnHNetFirewall(void)
		{
			DNASSERT(! (this->m_dwFlags & DEVICE_UPNPDISCOVERYSOCKETMAPPEDONHNETFIREWALL));
			this->m_dwFlags |= DEVICE_UPNPDISCOVERYSOCKETMAPPEDONHNETFIREWALL;
		};
#endif // ! DPNBUILD_NOHNETFWAPI

		inline void NotePerformingRemoteUPnPDiscovery(void)					{ this->m_dwFlags |= DEVICE_PERFORMINGREMOTEUPNPDISCOVERY; };
		inline void NotePerformingLocalUPnPDiscovery(void)					{ this->m_dwFlags |= DEVICE_PERFORMINGLOCALUPNPDISCOVERY; };
		inline void NoteGotRemoteUPnPDiscoveryConnReset(void)				{ this->m_dwFlags |= DEVICE_GOTREMOTEUPNPDISCOVERYCONNRESET; };
		inline void NoteGotLocalUPnPDiscoveryConnReset(void)				{ this->m_dwFlags |= DEVICE_GOTLOCALUPNPDISCOVERYCONNRESET; };

#ifndef DPNBUILD_NOHNETFWAPI
		inline void NoteNotHNetFirewalled(void)								{ this->m_dwFlags &= ~DEVICE_HNETFIREWALLED; };
		inline void NoteNotUPnPDiscoverySocketMappedOnHNetFirewall(void)	{ this->m_dwFlags &= ~DEVICE_UPNPDISCOVERYSOCKETMAPPEDONHNETFIREWALL; };
#endif // ! DPNBUILD_NOHNETFWAPI
		inline void NoteNotPerformingRemoteUPnPDiscovery(void)				{ this->m_dwFlags &= ~DEVICE_PERFORMINGREMOTEUPNPDISCOVERY; };
		inline void NoteNotPerformingLocalUPnPDiscovery(void)				{ this->m_dwFlags &= ~DEVICE_PERFORMINGLOCALUPNPDISCOVERY; };
		inline void NoteNotGotRemoteUPnPDiscoveryConnReset(void)			{ this->m_dwFlags &= ~DEVICE_GOTREMOTEUPNPDISCOVERYCONNRESET; };
		inline void NoteNotGotLocalUPnPDiscoveryConnReset(void)				{ this->m_dwFlags &= ~DEVICE_GOTLOCALUPNPDISCOVERYCONNRESET; };

#ifdef DBG
#ifndef DPNBUILD_NOWINSOCK2
		inline void NotePrimaryDevice(void)		{ this->m_dwFlags |= DEVICE_PRIMARY; };
		inline void NoteSecondaryDevice(void)	{ this->m_dwFlags |= DEVICE_SECONDARY; };
		inline void NoteNoGateway(void)			{ this->m_dwFlags |= DEVICE_NOGATEWAY; };

		inline void ClearGatewayFlags(void)		{ this->m_dwFlags &= ~(DEVICE_PRIMARY | DEVICE_SECONDARY | DEVICE_NOGATEWAY); };
#endif // ! DPNBUILD_NOWINSOCK2
#endif // DBG

		inline void SetUPnPDiscoverySocketPort(const WORD wPort)			{ this->m_wUPnPDiscoverySocketPort = wPort; };
		inline void SetUPnPDiscoverySocket(const SOCKET sSocket)			{ this->m_sUPnPDiscoverySocket = sSocket; };
		inline void SetUPnPDevice(CUPnPDevice * const pUPnPDevice)			{ this->m_pUPnPDevice = pUPnPDevice; };
		inline void SetFirstUPnPDiscoveryTime(const DWORD dwTime)			{ this->m_dwFirstUPnPDiscoveryTime = dwTime; };

#ifdef DBG
		inline void IncrementUPnPDeviceFailures(void)						{ this->m_dwNumUPnPDeviceFailures++; };
#endif // DBG




		CBilink		m_blList;			// list of all the available devices
		CBilink		m_blTempList;		// temporary list of all the available devices
		CBilink		m_blOwnedRegPorts;	// list of all the ports registered using this device

	
	private:
		//
		// Note that all values here are protected by the global CNATHelpUPnP lock.
		//
		BYTE			m_Sig[4];						// debugging signature ('DEVI')
		DWORD			m_dwFlags;						// flags describing this object
		DWORD			m_dwLocalAddressV4;				// address this object represents
		WORD			m_wUPnPDiscoverySocketPort;		// port being used by UPnP discovery socket
		SOCKET			m_sUPnPDiscoverySocket;			// socket opened for UPnP discovery communication on this device
		CUPnPDevice *	m_pUPnPDevice;					// pointer to UPnP Internet gateway for this device, if any
		DWORD			m_dwFirstUPnPDiscoveryTime;		// the time we first sent UPnP discovery traffic from this particular port, locally or remotely

#ifdef DBG
		DWORD			m_dwNumUPnPDeviceFailures;		// how many times a UPnP device returned an error or stopped responding and had to be cleared
#endif // DBG
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpdllmain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnhupnpdllmain.cpp
 *
 *  Content:	DPNHUPNP DLL entry points.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



#include "dpnhupnpi.h"





//=============================================================================
// External globals
//=============================================================================
volatile LONG		g_lOutstandingInterfaceCount = 0;			// number of outstanding interfaces

DNCRITICAL_SECTION	g_csGlobalsLock;							// lock protecting all of the following globals
CBilink				g_blNATHelpUPnPObjs;						// bilink of all the NATHelpUPnP interface objects
DWORD				g_dwHoldRand;								// current random number sequence

DWORD				g_dwUPnPMode;								// whether using UPnP is enabled or not
#ifndef DPNBUILD_NOHNETFWAPI
DWORD				g_dwHNetFWAPIMode;							// whether using HomeNet firewall API is enabled or not
#endif // ! DPNBUILD_NOHNETFWAPI
DWORD				g_dwSubnetMaskV4 = 0x00FFFFFF;				// = 0xFFFFFF00 in Intel order = 255.255.255.0, a class C network
DWORD				g_dwNoActiveNotifyPollInterval = 25000;		// start by polling every 25 seconds
DWORD				g_dwMinUpdateServerStatusInterval = 1000;	// don't hit the network more often than every 1 second
BOOL				g_fNoAsymmetricMappings = FALSE;			// whether asymmetric mappings can be tried or not
BOOL				g_fUseLeaseDurations = FALSE;				// whether non-INFINITE lease durations for NAT mappings can be tried or not
INT					g_iUnicastTTL = 1;							// unicast TTL value, or 0 to use default set by OS; normally we use 1
INT					g_iMulticastTTL = 1;						// multicast TTL value, or 0 to use default set by OS; normally we use 1
DWORD				g_dwUPnPAnnounceResponseWaitTime = 2500;	// how long to allow for UPnP device announcement responses to arrive in ms
DWORD				g_dwUPnPConnectTimeout = 15;				// how long to wait to reconnect to the UPnP device in seconds (default is 15, much shorter than standard TCP/IP timeout)
DWORD				g_dwUPnPResponseTimeout = 5000;				// how long to wait for a response message from the UPnP device to arrive in ms once the TCP/IP connection is established
#ifndef DPNBUILD_NOHNETFWAPI
BOOL				g_fMapUPnPDiscoverySocket = FALSE;			// whether the UPnP discovery socket should be mapped or not
#endif // ! DPNBUILD_NOHNETFWAPI
BOOL				g_fUseMulticastUPnPDiscovery = FALSE;		// whether to multicast UPnP discovery messages instead of the default directed sends to the gateway
DWORD				g_dwDefaultGatewayV4 = INADDR_BROADCAST;	// fallback to broadcasting UPnP discovery messages when detecting the gateway fails
DWORD				g_dwPollIntervalBackoff = 30000;			// backoff an additional 0 to 30 seconds if no network changes occur
DWORD				g_dwMaxPollInterval = 300000;				// don't go more than 5 minutes without polling
BOOL				g_fKeepPollingForRemoteGateway = FALSE;		// whether to continue to search for new Internet gateway devices if none were found during startup
DWORD				g_dwReusePortTime = 60000;					// how long to keep using the same port for polling remote Internet gateway devices (default is 1 minute)
DWORD				g_dwCacheLifeFound = 30000;					// how long to cache QueryAddress results where the address was found
DWORD				g_dwCacheLifeNotFound = 30000;				// how long to cache QueryAddress results where the address was not found
#ifdef DBG
WCHAR				g_wszUPnPTransactionLog[256] = L"";			// log file location, or empty string if none
#endif // DBG




//=============================================================================
// Defines
//=============================================================================
#define REGKEY_VALUE_GUID							L"Guid"
#define REGKEY_VALUE_DIRECTPLAY8PRIORITY			L"DirectPlay8Priority"
#define REGKEY_VALUE_DIRECTPLAY8INITFLAGS			L"DirectPlay8InitFlags"
#define REGKEY_VALUE_UPNPMODE						L"UPnPMode"
#ifndef DPNBUILD_NOHNETFWAPI
#define REGKEY_VALUE_HNETFWAPIMODE					L"HNetFWAPIMode"
#endif // ! DPNBUILD_NOHNETFWAPI
#define REGKEY_VALUE_SUBNETMASKV4					L"SubnetMaskV4"
#define REGKEY_VALUE_NOACTIVENOTIFYPOLLINTERVAL		L"NoActiveNotifyPollInterval"
#define REGKEY_VALUE_MINUPDATESERVERSTATUSINTERVAL	L"MinUpdateServerStatusInterval"
#define REGKEY_VALUE_NOASYMMETRICMAPPINGS			L"NoAsymmetricMappings"
#define REGKEY_VALUE_USELEASEDURATIONS				L"UseLeaseDurations"
#define REGKEY_VALUE_UNICASTTTL						L"UnicastTTL"
#define REGKEY_VALUE_MULTICASTTTL					L"MulticastTTL"
#define REGKEY_VALUE_UPNPANNOUNCERESPONSEWAITTIME	L"UPnPAnnounceResponseWaitTime"
#define REGKEY_VALUE_UPNPCONNECTTIMEOUT				L"UPnPConnectTimeout"
#define REGKEY_VALUE_UPNPRESPONSETIMEOUT			L"UPnPResponseTimeout"
#ifndef DPNBUILD_NOHNETFWAPI
#define REGKEY_VALUE_MAPUPNPDISCOVERYSOCKET			L"MapUPnPDiscoverySocket"
#endif // ! DPNBUILD_NOHNETFWAPI
#define REGKEY_VALUE_USEMULTICASTUPNPDISCOVERY		L"UseMulticastUPnPDiscovery"
#define REGKEY_VALUE_DEFAULTGATEWAYV4				L"GatewayV4"
#define REGKEY_VALUE_POLLINTERVALBACKOFF			L"PollIntervalBackoff"
#define REGKEY_VALUE_MAXPOLLINTERVAL				L"MaxPollInterval"
#define REGKEY_VALUE_KEEPPOLLINGFORREMOTEGATEWAY	L"KeepPollingForRemoteGateway"
#define REGKEY_VALUE_REUSEPORTTIME					L"ReusePortTime"
#define REGKEY_VALUE_CACHELIFEFOUND					L"CacheLifeFound"
#define REGKEY_VALUE_CACHELIFENOTFOUND				L"CacheLifeNotFound"
#ifdef DBG
#define REGKEY_VALUE_UPNPTRANSACTIONLOG				L"UPnPTransactionLog"
#endif // DBG


#define DEFAULT_DIRECTPLAY8PRIORITY					1
#define DEFAULT_DIRECTPLAY8INITFLAGS				0






//=============================================================================
// Local prototypes
//=============================================================================
BOOL InitializeProcessGlobals(void);
void CleanupProcessGlobals(void);
void InitializeGlobalRand(const DWORD dwSeed);





#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"
//=============================================================================
// DllMain
//-----------------------------------------------------------------------------
//
// Description: DLL entry point.
//
// Arguments:
//	HANDLE hDllInst		- Handle to this DLL module instance.
//	DWORD dwReason		- Reason for calling this function.
//	LPVOID lpvReserved	- Reserved.
//
// Returns: TRUE if all goes well, FALSE otherwise.
//=============================================================================
BOOL WINAPI DllMain(HANDLE hDllInst,
					DWORD dwReason,
					LPVOID lpvReserved)
{
	BOOL	fResult = TRUE;

	
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			DPFX(DPFPREP, 2, "====> ENTER: DLLMAIN(%p): Process Attach: %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId());

			//
			// Ignore thread attach/detach messages.
			//
			DisableThreadLibraryCalls((HMODULE) hDllInst);

			//
			// Attempt to initialize the OS abstraction layer.
			//
			if (DNOSIndirectionInit(0))
			{
				//
				// Attempt to initialize process-global items.
				//
				if (! InitializeProcessGlobals())
				{
					DPFX(DPFPREP, 0, "Failed to initialize globals!");
					DNOSIndirectionDeinit();
					fResult = FALSE;
				}
			}
			else
			{
				DPFX(DPFPREP, 0, "Failed to initialize OS indirection layer!");
				fResult = FALSE;
			}
		
			break;
		}

		case DLL_THREAD_ATTACH:
		{
			//
			// Ignore.
			//
			break;
		}

		case DLL_THREAD_DETACH:
		{
			//
			// Ignore.
			//
			break;
		}

		case DLL_PROCESS_DETACH:
		{
			DPFX(DPFPREP, 2, "====> EXIT: DLLMAIN(%p): Process Detach %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId());

			CleanupProcessGlobals();

			DNOSIndirectionDeinit();
			
			break;
		}

		default:
		{
			DNASSERT(FALSE);
			break;
		}
	}

	return fResult;
} // DllMain




#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
//=============================================================================
// DllRegisterServer
//-----------------------------------------------------------------------------
//
// Description: Registers the DirectPlay NAT Helper UPnP COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully unregistered DirectPlay NAT Helper UPnP.
//	E_FAIL	- Failed unregistering DirectPlay NAT Helper UPnP.
//=============================================================================
HRESULT WINAPI DllRegisterServer(void)
{
	CRegistry	RegObject;


	//
	// Register this COM object CLSID.
	//
	if (! CRegistry::Register(L"DirectPlayNATHelperUPnP.1",
							L"DirectPlay NAT Helper UPnP Object",
							L"dpnhupnp.dll",
							&CLSID_DirectPlayNATHelpUPnP,
							L"DirectPlayNATHelperUPnP"))
	{
		DPFX(DPFPREP, 0, "Could not register DirectPlay NAT Helper UPnP object!");
		return E_FAIL;
	}


	//
	// Write this object's GUID and DirectPlay8 availability to the registry.
	//

	if (! RegObject.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY, FALSE, TRUE))
	{
		DPFX(DPFPREP, 0, "Couldn't create DirectPlay NAT Helper UPnP key!");
		return E_FAIL;
	}

	if (! RegObject.WriteGUID(REGKEY_VALUE_GUID, CLSID_DirectPlayNATHelpUPnP))
	{
		DPFX(DPFPREP, 0, "Couldn't write GUID to registry!");
		return E_FAIL;
	}

	if (! RegObject.WriteDWORD(REGKEY_VALUE_DIRECTPLAY8PRIORITY, DEFAULT_DIRECTPLAY8PRIORITY))
	{
		DPFX(DPFPREP, 0, "Couldn't write DirectPlay8 priority to registry!");
		return E_FAIL;
	}

	if (! RegObject.WriteDWORD(REGKEY_VALUE_DIRECTPLAY8INITFLAGS, DEFAULT_DIRECTPLAY8INITFLAGS))
	{
		DPFX(DPFPREP, 0, "Couldn't write DirectPlay8 init flags to registry!");
		return E_FAIL;
	}

	RegObject.Close();



#ifndef DPNBUILD_NOHNETFWAPI
	//
	// Create the active firewall mappings storage subkey.
	//

	if (! RegObject.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVEFIREWALLMAPPINGS, FALSE, TRUE))
	{
		DPFX(DPFPREP, 0, "Couldn't create DirectPlay NAT Helper active firewall mappings key!  Continuing.");
	}
	else
	{
//
// We don't need to grant access to everyone for the active firewall mappings
// because currently you need to be an administrator to add or remove mappings
// via the HomeNet API anyway.
//
#if 0
#ifdef WINNT
		//
		// If we're on NT, set the key security to allow everyone full access
		// (except WRITE_DAC and WRITE_OWNER).
		//
		if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
		{
			if (! RegObject.GrantAllAccessSecurityPermissions())
			{
				DPFX(DPFPREP, 0, "Failed granting all-access permissions to active firewall mappings key!  Continuing.");
			}
		}
#endif // WINNT
#endif

		RegObject.Close();
	}
#endif // ! DPNBUILD_NOHNETFWAPI



	//
	// Create the active NAT mappings storage subkey.
	//

	if (! RegObject.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVENATMAPPINGS, FALSE, TRUE))
	{
		DPFX(DPFPREP, 0, "Couldn't create DirectPlay NAT Helper active NAT mappings key!  Continuing.");
	}
	else
	{
#ifdef WINNT
		//
		// If we're on NT, set the key security to allow everyone full access
		// (except WRITE_DAC and WRITE_OWNER).
		// Since anyone can create or delete a NAT mapping already, there's no
		// point in securing the registry entries that exist solely for crash
		// cleanup.
		//
		if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
		{
			if (! RegObject.GrantAllAccessSecurityPermissions())
			{
				DPFX(DPFPREP, 0, "Failed granting all-access permissions to active NAT mappings key!  Continuing.");
			}
		}
#endif

		RegObject.Close();
	}


	return S_OK;
} // DllRegisterServer





#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
//=============================================================================
// DllUnregisterServer
//-----------------------------------------------------------------------------
//
// Description: Unregisters the DirectPlay NAT Helper UPnP COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully unregistered DirectPlay NAT Helper UPnP.
//	E_FAIL	- Failed unregistering DirectPlay NAT Helper UPnP.
//=============================================================================
STDAPI DllUnregisterServer(void)
{
	CRegistry	RegObject;


	//
	// Unregister the class.
	//
	if (! CRegistry::UnRegister(&CLSID_DirectPlayNATHelpUPnP))
	{
		DPFX(DPFPREP, 0, "Failed to unregister DirectPlay NAT Helper UPnP object!");
		return E_FAIL;
	}


	//
	// Try removing all the subitems we registered.
	//

	if (! RegObject.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY, FALSE, FALSE))
	{
		DPFX(DPFPREP, 0, "Couldn't open DirectPlay NAT Helper key!  Ignoring.");
	}
	else
	{
#ifndef DPNBUILD_NOHNETFWAPI
		if (! RegObject.DeleteSubKey(REGKEY_ACTIVEFIREWALLMAPPINGS))
		{
			DPFX(DPFPREP, 0, "Couldn't delete DirectPlay NAT Helper active firewall mappings key, there may still be subitems!  Ignoring.");
		}
#endif // ! DPNBUILD_NOHNETFWAPI

		if (! RegObject.DeleteSubKey(REGKEY_ACTIVENATMAPPINGS))
		{
			DPFX(DPFPREP, 0, "Couldn't delete DirectPlay NAT Helper active NAT mappings key, there may still be subitems!  Ignoring.");
		}

		if (! RegObject.DeleteValue(REGKEY_VALUE_GUID))
		{
			DPFX(DPFPREP, 0, "Couldn't delete GUID registry value!  Ignoring.");
		}

		if (! RegObject.DeleteValue(REGKEY_VALUE_DIRECTPLAY8PRIORITY))
		{
			DPFX(DPFPREP, 0, "Couldn't delete DirectPlay8 priority registry value!  Ignoring.");
		}

		if (! RegObject.DeleteValue(REGKEY_VALUE_DIRECTPLAY8INITFLAGS))
		{
			DPFX(DPFPREP, 0, "Couldn't delete DirectPlay8 init flags registry value!  Ignoring.");
		}

		RegObject.Close();
	}

	return S_OK;
} // DllUnregisterServer

#endif // !DPNBUILD_NOCOMREGISTER


#ifndef WINCE

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayNATHelpCreate"
//=============================================================================
// DirectPlayNATHelpCreate
//-----------------------------------------------------------------------------
//
// Description: Creates an IDirectPlayNATHelp interface object.
//
// Arguments:
//	GUID * pIID				- Pointer to IDirectPlayNATHelp interface GUID.
//	void ** ppvInterface	- Place to store pointer to interface object
//								created.
//
// Returns: HRESULT
//	DPNH_OK					- Creating the object was successful.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	DPNHERR_OUTOFMEMORY		- Not enough memory to create the object.
//	E_NOINTERFACE			- The requested interface was invalid.
//=============================================================================
HRESULT WINAPI DirectPlayNATHelpCreate(const GUID * pIID, void ** ppvInterface)
{
	HRESULT			hr;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pIID, ppvInterface);

	hr = DoCreateInstance(NULL,							// no class factory object necessary
						NULL,							// ?
						CLSID_DirectPlayNATHelpUPnP,	// DirectPlayNATHelp class
						(*pIID),						// requested interface
						ppvInterface);					// place to store interface

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
} // DirectPlayNATHelpCreate

#endif // !WINCE





#undef DPF_MODNAME
#define DPF_MODNAME "InitializeProcessGlobals"
//=============================================================================
// InitializeProcessGlobals
//-----------------------------------------------------------------------------
//
// Description: Initialize global items needed for the DLL to operate.
//
// Arguments: None.
//
// Returns: TRUE if successful, FALSE if an error occurred.
//=============================================================================
BOOL InitializeProcessGlobals(void)
{
	BOOL	fReturn = TRUE;


	if (! DNInitializeCriticalSection(&g_csGlobalsLock))
	{
		fReturn = FALSE;
	}

	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&g_csGlobalsLock, 0);


	g_blNATHelpUPnPObjs.Initialize();


	//
	// Seed the random number generator with the current time.
	//
	InitializeGlobalRand(GETTIMESTAMP());


	return fReturn;
} // InitializeProcessGlobals




#undef DPF_MODNAME
#define DPF_MODNAME "CleanupProcessGlobals"
//=============================================================================
// CleanupProcessGlobals
//-----------------------------------------------------------------------------
//
// Description: Releases global items used by DLL.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CleanupProcessGlobals(void)
{
	CBilink *		pBilink;
	CNATHelpUPnP *	pNATHelpUPnP;


	if (! g_blNATHelpUPnPObjs.IsEmpty())
	{
		//
		// This assert is far more descriptive than hitting one of those in the
		// cleanup code that complain about flags incorrectly being set.
		//
		DNASSERT(! "DPNHUPNP.DLL unloading without all objects having been released!  The caller's DirectPlayNATHelpUPnP cleanup code needs to be fixed!");


		//
		// Force close all the objects still outstanding.
		//
		pBilink = g_blNATHelpUPnPObjs.GetNext();
		while (pBilink != &g_blNATHelpUPnPObjs)
		{
			DNASSERT(! pBilink->IsEmpty());
			pNATHelpUPnP = NATHELPUPNP_FROM_BILINK(pBilink);
			pBilink = pBilink->GetNext();


			DPFX(DPFPREP, 0, "Forcefully releasing object 0x%p!", pNATHelpUPnP);

			pNATHelpUPnP->Close(0); // ignore error
			

			//
			// Forcefully remove it from the list and delete it instead of
			// using pNATHelpUPnP->Release().
			//
			pNATHelpUPnP->m_blList.RemoveFromList();
			pNATHelpUPnP->UninitializeObject();
			delete pNATHelpUPnP;
		}
	}

	DNDeleteCriticalSection(&g_csGlobalsLock);
} // CleanupProcessGlobals




#undef DPF_MODNAME
#define DPF_MODNAME "ReadRegistrySettings"
//=============================================================================
// ReadRegistrySettings
//-----------------------------------------------------------------------------
//
// Description: Reads registry settings to override behavior of this DLL and to
//				turn on some debugging features.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void ReadRegistrySettings(void)
{
	CRegistry	RegObject;
	DWORD		dwNewValue;
	BOOL		fNewValue;
#ifdef DBG
	DWORD		dwLength;
#endif // DBG


	//
	// Try opening the registry key.
	//
	if (RegObject.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY) != FALSE)
	{
		//
		// Lock out other interfaces from modifying the globals simultaneously.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);


		//
		// If we successfully read a new mode, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_UPNPMODE, &dwNewValue))
		{
			g_dwUPnPMode = dwNewValue;
			DPFX(DPFPREP, 1, "Using UPnP mode %u.", g_dwUPnPMode);
		}


#ifndef DPNBUILD_NOHNETFWAPI
		//
		// If we successfully read a new mode, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_HNETFWAPIMODE, &dwNewValue))
		{
			g_dwUPnPMode = dwNewValue;
			DPFX(DPFPREP, 1, "Using HNet FW API mode %u.", g_dwHNetFWAPIMode);
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		//
		// If we successfully read a new mask, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_SUBNETMASKV4, &dwNewValue))
		{
			g_dwSubnetMaskV4 = dwNewValue;
			DPFX(DPFPREP, 1, "Using subnet mask 0x%08lx.", g_dwSubnetMaskV4);
		}


		//
		// If we successfully read a new interval, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_NOACTIVENOTIFYPOLLINTERVAL, &dwNewValue))
		{
			g_dwNoActiveNotifyPollInterval = dwNewValue;
			DPFX(DPFPREP, 1, "Using no-active-notify recommended poll interval %u ms.", g_dwNoActiveNotifyPollInterval);
		}


		//
		// If we successfully read a new interval, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_MINUPDATESERVERSTATUSINTERVAL, &dwNewValue))
		{
			g_dwMinUpdateServerStatusInterval = dwNewValue;
			DPFX(DPFPREP, 1, "Using minimum update-server-status interval %u ms.", g_dwMinUpdateServerStatusInterval);
		}


		//
		// If we successfully read a new boolean, save it.
		//
		if (RegObject.ReadBOOL(REGKEY_VALUE_NOASYMMETRICMAPPINGS, &fNewValue))
		{
			g_fNoAsymmetricMappings = fNewValue;
			if (g_fNoAsymmetricMappings)
			{
				DPFX(DPFPREP, 1, "Never using asymmetric port mappings.");
			}
			else
			{
				//
				// This is actually default behavior, but print out a statement
				// anyway.
				//
				DPFX(DPFPREP, 1, "Asymmetric port mappings allowed by registry key.");
			}
		}


		//
		// If we successfully read a new boolean, save it.
		//
		if (RegObject.ReadBOOL(REGKEY_VALUE_USELEASEDURATIONS, &fNewValue))
		{
			g_fUseLeaseDurations = fNewValue;
			if (g_fUseLeaseDurations)
			{
				DPFX(DPFPREP, 1, "Attempting to use non-INFINITE lease durations.");
			}
			else
			{
				//
				// This is actually default behavior, but print out a statement
				// anyway.
				//
				DPFX(DPFPREP, 1, "Non-INFINITE lease durations specifically prevented by registry key.");
			}
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_UNICASTTTL, &dwNewValue))
		{
			g_iUnicastTTL = dwNewValue;
			if (g_iUnicastTTL != 0)
			{
				DPFX(DPFPREP, 1, "Using unicast TTL of %i.", g_iUnicastTTL);
			}
			else
			{
				DPFX(DPFPREP, 1, "Using OS default unicast TTL.");
			}
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_MULTICASTTTL, &dwNewValue))
		{
			g_iMulticastTTL = dwNewValue;
			if (g_iMulticastTTL != 0)
			{
				DPFX(DPFPREP, 1, "Using multicast TTL of %i.", g_iMulticastTTL);
			}
			else
			{
				DPFX(DPFPREP, 1, "Using OS default multicast TTL.");
			}
		}


		//
		// If we successfully read a new timeout, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_UPNPANNOUNCERESPONSEWAITTIME, &dwNewValue))
		{
			g_dwUPnPAnnounceResponseWaitTime = dwNewValue;
			DPFX(DPFPREP, 1, "Using UPnP announce response wait time of %u ms.", g_dwUPnPAnnounceResponseWaitTime);
		}


		//
		// If we successfully read a new timeout, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_UPNPCONNECTTIMEOUT, &dwNewValue))
		{
			g_dwUPnPConnectTimeout = dwNewValue;
			DPFX(DPFPREP, 1, "Using UPnP connect timeout of %u seconds.", g_dwUPnPConnectTimeout);
		}


		//
		// If we successfully read a new timeout, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_UPNPRESPONSETIMEOUT, &dwNewValue))
		{
			g_dwUPnPResponseTimeout = dwNewValue;
			DPFX(DPFPREP, 1, "Using UPnP response timeout of %u ms.", g_dwUPnPResponseTimeout);
		}


#ifndef DPNBUILD_NOHNETFWAPI
		//
		// If we successfully read a new boolean, save it.
		//
		if (RegObject.ReadBOOL(REGKEY_VALUE_MAPUPNPDISCOVERYSOCKET, &fNewValue))
		{
			g_fMapUPnPDiscoverySocket = fNewValue;
			if (g_fMapUPnPDiscoverySocket)
			{
				DPFX(DPFPREP, 1, "Mapping UPnP discovery socket on local firewall.");
			}
			else
			{
				//
				// This is actually default behavior, but print out a statement
				// anyway.
				//
				DPFX(DPFPREP, 1, "UPnP discovery socket mapping is disallowed by registry key.");
			}
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		//
		// If we successfully read a new boolean, save it.
		//
		if (RegObject.ReadBOOL(REGKEY_VALUE_USEMULTICASTUPNPDISCOVERY, &fNewValue))
		{
			g_fUseMulticastUPnPDiscovery = fNewValue;
			if (g_fUseMulticastUPnPDiscovery)
			{
				DPFX(DPFPREP, 1, "Using multicast UPnP discovery messages.");
			}
			else
			{
				//
				// This is actually default behavior, but print out a statement
				// anyway.
				//
				DPFX(DPFPREP, 1, "Multicasted UPnP discovery is disallowed by registry key.");
			}
		}


		//
		// If we successfully read a new default gateway, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_DEFAULTGATEWAYV4, &dwNewValue))
		{
			g_dwDefaultGatewayV4 = dwNewValue;
			DPFX(DPFPREP, 1, "Using default gateway 0x%08lx.", g_dwDefaultGatewayV4);
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_POLLINTERVALBACKOFF, &dwNewValue))
		{
			if (dwNewValue != 0)
			{
				g_dwPollIntervalBackoff = dwNewValue;
				DPFX(DPFPREP, 1, "Using poll interval backoff between 0 and %u ms.",
					g_dwPollIntervalBackoff);
			}
			else
			{
				DPFX(DPFPREP, 0, "Ignoring invalid poll interval backoff setting, using default between 0 and %u ms!",
					g_dwPollIntervalBackoff);
			}
		}


		//
		// If we successfully read a new interval, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_MAXPOLLINTERVAL, &dwNewValue))
		{
			//
			// Make sure the value is greater than the starting value.
			//
			if (dwNewValue >= g_dwNoActiveNotifyPollInterval)
			{
				g_dwMaxPollInterval = dwNewValue;
				DPFX(DPFPREP, 1, "Using max poll interval of %u ms.",
					g_dwMaxPollInterval);
			}
			else
			{
				g_dwMaxPollInterval = g_dwNoActiveNotifyPollInterval;
				DPFX(DPFPREP, 0, "Ignoring max poll interval of %u ms, the starting value is %u ms.",
					g_dwMaxPollInterval);
			}
		}
		else
		{
			//
			// Make sure the max poll interval default value is greater than
			// the starting value because we may have read in a new
			// g_dwNoActiveNotifyPollInterval that makes the default
			// g_dwMaxPollInterval invalid.
			//
			if (g_dwMaxPollInterval < g_dwNoActiveNotifyPollInterval)
			{
				g_dwMaxPollInterval = g_dwNoActiveNotifyPollInterval;
				DPFX(DPFPREP, 0, "Resetting max poll interval to %u ms so as to meet starting value.",
					g_dwMaxPollInterval);
			}
		}


		//
		// If we successfully read a new boolean, save it.
		//
		if (RegObject.ReadBOOL(REGKEY_VALUE_KEEPPOLLINGFORREMOTEGATEWAY, &fNewValue))
		{
			g_fKeepPollingForRemoteGateway = fNewValue;
			if (g_fKeepPollingForRemoteGateway)
			{
				DPFX(DPFPREP, 1, "Will continue to poll for remote gateways.");
			}
			else
			{
				//
				// This is actually default behavior, but print out a statement
				// anyway.
				//
				DPFX(DPFPREP, 1, "Continually polling for remote gateways is disallowed by registry key.");
			}
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_REUSEPORTTIME, &dwNewValue))
		{
			g_dwReusePortTime = dwNewValue;
			DPFX(DPFPREP, 1, "Reusing remote gateway discovery ports for %u ms.",
				g_dwReusePortTime);
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_CACHELIFEFOUND, &dwNewValue))
		{
			g_dwCacheLifeFound = dwNewValue;
			DPFX(DPFPREP, 1, "Caching found addresses for %u ms.",
				g_dwCacheLifeFound);
		}


		//
		// If we successfully read a new value, save it.
		//
		if (RegObject.ReadDWORD(REGKEY_VALUE_CACHELIFENOTFOUND, &dwNewValue))
		{
			g_dwCacheLifeNotFound = dwNewValue;
			DPFX(DPFPREP, 1, "Caching not-found addresses for %u ms.",
				g_dwCacheLifeNotFound);
		}


#ifdef DBG
		//
		// If we successfully read a log string, print that out.
		//
		dwLength = sizeof(g_wszUPnPTransactionLog) / sizeof(WCHAR);

		if (RegObject.ReadString(REGKEY_VALUE_UPNPTRANSACTIONLOG,
								g_wszUPnPTransactionLog,
								&dwLength))
		{
			DPFX(DPFPREP, 1, "Using UPnP transaction log \"%ls\".", g_wszUPnPTransactionLog);
		}
#endif // DBG



		//
		// Okay, we're done.  Drop the lock.
		//
		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Done reading registry.
		//
		RegObject.Close();
	}
} // ReadRegistrySettings






#ifndef WINCE


#undef DPF_MODNAME
#define DPF_MODNAME "SetDefaultProxyBlanket"
//=============================================================================
// SetDefaultProxyBlanket
//-----------------------------------------------------------------------------
//
// Description:    Taken from the HomeNet config utils.
//
//				   This sets the standard COM security settings on the proxy
//				for an object.  Even if the CoSetProxyBlanket calls fail, pUnk
//				remains in a usable state. Failure is expected in certain
//				contexts, such as when, for example, we're being called within
//				the desired process where we have direct pointers to the
//				objects instead of going through a proxy.
//
//				   COM is assumed to have been initialized.
//
// Arguments:
//	IUnknown * pUnk			- The object on which to set the proxy blanket.
//	char * szObjectName		- (debug only) The name of the object.
//
// Returns: None.
//=============================================================================
#ifdef DBG
void SetDefaultProxyBlanket(IUnknown * pUnk, const char * const szObjectName)
#else // ! DBG
void SetDefaultProxyBlanket(IUnknown * pUnk)
#endif // ! DBG
{
	HRESULT		hr;
	//IUnknown *	pUnkSet = NULL;


	hr = CoSetProxyBlanket(pUnk,
							RPC_C_AUTHN_WINNT,				// use NT default security
							RPC_C_AUTHN_NONE,				// use NT default authentication
							NULL,							// must be NULL if default
							RPC_C_AUTHN_LEVEL_CALL,			// call level authentication
							RPC_C_IMP_LEVEL_IMPERSONATE,
							NULL,							// use process token
							EOAC_NONE);
	if (SUCCEEDED(hr))
	{
		/*
		hr = pUnk->QueryInterface(&pUnkSet);
		if (SUCCEEDED(hr))
		{

			hr = CoSetProxyBlanket(pUnk,
									RPC_C_AUTHN_WINNT,				// use NT default security
									RPC_C_AUTHN_NONE,				// use NT default authentication
									NULL,							// must be NULL if default
									RPC_C_AUTHN_LEVEL_CALL,			// call level authentication
									RPC_C_IMP_LEVEL_IMPERSONATE,
									NULL,							// use process token
									EOAC_NONE);
			if (SUCCEEDED(hr))
			{
				//
				// This is what we want.
				//
			}
			else
			{
				DPFX(DPFPREP, 1, "Couldn't set security blanket (2) on %hs object 0x%p (err = 0x%lx)!  Continuing.",
					szObjectName, pUnk, hr);
			}

			pUnkSet->Release();
			pUnkSet = NULL;
		}
		else
		{
			DPFX(DPFPREP, 1, "Couldn't query for IUnknown interface on %hs object 0x%p (err = 0x%lx)!  Continuing.",
				szObjectName, pUnk, hr);
		}
		*/
	}
	else
	{
		DPFX(DPFPREP, 1, "Couldn't set security blanket (1) on %hs object 0x%p (err = 0x%lx)!  Continuing.",
			szObjectName, pUnk, hr);
	}
} // SetDefaultProxyBlanket

#endif // ! WINCE





#undef DPF_MODNAME
#define DPF_MODNAME "InitializeGlobalRand"
//=============================================================================
// InitializeGlobalRand
//-----------------------------------------------------------------------------
//
// Description:   Initializes the fallback global psuedo-random number
//				generator, using the given seed value.
//
// Arguments:
//	DWORD dwSeed	- Seed to use.
//
// Returns: None.
//=============================================================================
void InitializeGlobalRand(const DWORD dwSeed)
{
	//
	// We don't need to hold a lock, since this should only be done once,
	// during initialization time.
	//
	g_dwHoldRand = dwSeed;
} // InitializeGlobalRand





#undef DPF_MODNAME
#define DPF_MODNAME "GetGlobalRand"
//=============================================================================
// GetGlobalRand
//-----------------------------------------------------------------------------
//
// Description:   Generates a pseudo-random DWORD.
//
// Arguments: None.
//
// Returns: Pseudo-random number.
//=============================================================================
DWORD GetGlobalRand(void)
{
	HCRYPTPROV	hCryptProv;
	DWORD		dwResult;
	WORD		wResult1;
	WORD		wResult2;
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	if (CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
	{
		if (CryptGenRandom(hCryptProv, sizeof(dwResult), (BYTE*) (&dwResult)))
		{
			CryptReleaseContext(hCryptProv, 0);
			return dwResult;
		}
#ifdef DBG
		else
		{
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Crypto couldn't generate random number (err = %u)!",
				dwError);
		}
#endif // DBG

		CryptReleaseContext(hCryptProv, 0);
	}
#ifdef DBG
	else
	{
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't acquire crypto provider context (err = %u)!",
			dwError);
	}
#endif // DBG


	//
	// We couldn't use the crypto API to generate a random number, so make
	// our own based off the C run time source.
	//

	DNEnterCriticalSection(&g_csGlobalsLock);

	g_dwHoldRand = ((g_dwHoldRand * 214013L + 2531011L) >> 16) & 0x7fff;
	wResult1 = (WORD) g_dwHoldRand;
	g_dwHoldRand = ((g_dwHoldRand * 214013L + 2531011L) >> 16) & 0x7fff;
	wResult2 = (WORD) g_dwHoldRand;

	DNLeaveCriticalSection(&g_csGlobalsLock);

	return MAKELONG(wResult1, wResult2);
} // GetGlobalRand




#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"
//=============================================================================
// DoCreateInstance
//-----------------------------------------------------------------------------
//
// Description: Creates an instance of an interface.  Required by the general
//				purpose class factory functions.
//
// Arguments:
//	LPCLASSFACTORY This		- Pointer to class factory.
//	LPUNKNOWN pUnkOuter		- Pointer to unknown interface.
//	REFCLSID rclsid			- Reference of GUID of desired interface.
//	REFIID riid				- Reference to another GUID?
//	LPVOID * ppvObj			- Pointer to pointer to interface.
//
// Returns: HRESULT
//=============================================================================
HRESULT DoCreateInstance(LPCLASSFACTORY This,
						LPUNKNOWN pUnkOuter,
						REFCLSID rclsid,
						REFIID riid,
						LPVOID * ppvObj)
{
	HRESULT			hr;
	BOOL			fNotCreatedWithCOM;
	CNATHelpUPnP *	pNATHelpUPnP = NULL;


	DNASSERT(ppvObj != NULL);


	if (! IsEqualCLSID(rclsid, CLSID_DirectPlayNATHelpUPnP))
	{
		//
		// This shouldn't happen if they called IClassFactory::CreateObject
		// correctly.
		//
		DNASSERT(FALSE);

		//
		// Return an error.
		//
		hr = E_UNEXPECTED;
		goto Failure;
	}


	//
	// If the class factory pointer is NULL, then we were called by the
	// DirectPlayNATHelpCreate function.
	//
	if (This == NULL)
	{
		fNotCreatedWithCOM = TRUE;
	}
	else
	{
		fNotCreatedWithCOM = FALSE;
	}


	//
	// Create the object instance.
	//
	pNATHelpUPnP = new CNATHelpUPnP(fNotCreatedWithCOM);
	if (pNATHelpUPnP == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Initialize the base object (which might fail).
	//
	hr = pNATHelpUPnP->InitializeObject();
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize object!");
		delete pNATHelpUPnP;
		pNATHelpUPnP = NULL;
		goto Failure;
	}


	//
	// Add it to the global list.
	//
	DNEnterCriticalSection(&g_csGlobalsLock);

	pNATHelpUPnP->m_blList.InsertBefore(&g_blNATHelpUPnPObjs);
	
	g_lOutstandingInterfaceCount++;	// update count so DllCanUnloadNow works correctly

	DNLeaveCriticalSection(&g_csGlobalsLock);


	//
	// Get the right interface for the caller and bump the refcount.
	//
	hr = pNATHelpUPnP->QueryInterface(riid, ppvObj);
	if (hr != S_OK)
	{
		goto Failure;
	}


Exit:

	//
	// Release the local reference to the object.  If this function was
	// successful, there's still a reference in ppvObj.
	//
	if (pNATHelpUPnP != NULL)
	{
		pNATHelpUPnP->Release();
		pNATHelpUPnP = NULL;
	}

	return hr;


Failure:

	//
	// Make sure we don't hand back a pointer.
	//
	(*ppvObj) = NULL;

	goto Exit;
} // DoCreateInstance




#undef DPF_MODNAME
#define DPF_MODNAME "IsClassImplemented"
//=============================================================================
// IsClassImplemented
//-----------------------------------------------------------------------------
//
// Description: Determine if a class is implemented in this DLL.  Required by
//				the general purpose class factory functions.
//
// Arguments:
//	REFCLSID rclsid		- Reference to class GUID.
//
// Returns: BOOL
//	TRUE	 - This DLL implements the class.
//	FALSE	 - This DLL doesn't implement the class.
//=============================================================================
BOOL IsClassImplemented(REFCLSID rclsid)
{
	return (IsEqualCLSID(rclsid, CLSID_DirectPlayNATHelpUPnP));
} // IsClassImplemented
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpclassfac.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnhupnpclassfac.cpp
 *
 *  Content:	a generic class factory.
 *
 *
 *	This is a generic C++ class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instance of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *	10/13/98  jwo		Created it.
 *	04/08/01  vanceo	Converted to C++.
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/


#include "dpnhupnpi.h"



#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// class factory class definition
//
typedef class GPClassFactory:public IClassFactory
{
	public:
		GPClassFactory(const CLSID * pclsid)	{ m_dwRefCnt = 0; memcpy(&m_clsid, pclsid, sizeof(CLSID)); };
		~GPClassFactory(void)				{};


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);
		STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
		STDMETHODIMP LockServer(BOOL fLock);


	private:
		DWORD		m_dwRefCnt;
		CLSID		m_clsid;
} GPCLASSFACTORY, *LPGPCLASSFACTORY;


//
// function prototype for CoLockObjectExternal()
//
typedef	HRESULT (WINAPI * PCOLOCKOBJECTEXTERNAL)(LPUNKNOWN, BOOL, BOOL );

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// count of outstanding COM interfaces, defined in dpnathlpdllmain.cpp
//
extern volatile LONG	g_lOutstandingInterfaceCount;



//**********************************************************************
// Function prototypes
//**********************************************************************


//**********************************************************************
// Function definitions
//**********************************************************************




/*
 * GPClassFactory::QueryInterface
 */
STDMETHODIMP GPClassFactory::QueryInterface(
											REFIID riid,
											LPVOID *ppvObj )
{
	HRESULT hr;

    *ppvObj = NULL;


    if( IsEqualIID(riid, IID_IClassFactory) ||
                    IsEqualIID(riid, IID_IUnknown))
    {
        this->m_dwRefCnt++;
        *ppvObj = this;
		hr = S_OK;
    }
    else
    {
		hr = E_NOINTERFACE;
    }


	return hr;

} /* GPClassFactory::QueryInterface */


/*
 * GPClassFactory::AddRef
 */
STDMETHODIMP_(ULONG) GPClassFactory::AddRef( void )
{
    this->m_dwRefCnt++;
    return this->m_dwRefCnt;
} /* GPClassFactory::AddRef */



/*
 * GPClassFactory::Release
 */
STDMETHODIMP_(ULONG) GPClassFactory::Release( void )
{
    this->m_dwRefCnt--;

    if( this->m_dwRefCnt != 0 )
    {
        return this->m_dwRefCnt;
    }

    delete this;
    return 0;

} /* GPClassFactory::Release */




/*
 * GPClassFactory::CreateInstance
 *
 * Creates an instance of the object
 */
STDMETHODIMP GPClassFactory::CreateInstance(
											LPUNKNOWN pUnkOuter,
											REFIID riid,
    										LPVOID *ppvObj
											)
{
    HRESULT					hr = S_OK;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(this, pUnkOuter, this->m_clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* GPClassFactory::CreateInstance */



/*
 * GPClassFactory::LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP GPClassFactory::LockServer(
                BOOL fLock
				)
{
    HRESULT		hr;
    HINSTANCE	hdll;


    /*
     * call CoLockObjectExternal
     */
    hr = E_UNEXPECTED;
    hdll = LoadLibrary( _T("OLE32.DLL") );
    if( hdll != NULL )
    {
        PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;


		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, _TWINCE("CoLockObjectExternal") ) );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
        }
        else
        {
        }
    }
    else
    {
    }

	return hr;

} /* GPClassFactory::LockServer */



/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
EXP STDAPI  DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
    HRESULT		hr;

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
//	you must implement GetClassID() for your specific COM object
	if (!IsClassImplemented(rclsid))
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, IID_IUnknown ) &&
	    !IsEqualIID( riid, IID_IClassFactory ) )
    {
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = new GPClassFactory(&rclsid);
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

    hr = pcf->QueryInterface( riid, ppvObj );
    if( FAILED( hr ) )
    {
        delete pcf;
        *ppvObj = NULL;
    }
    else
    {
    }

    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
EXP STDAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

	
	if ( g_lOutstandingInterfaceCount == 0 )
	{
		hr = S_OK;
	}

    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpintfobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnhupnpintfobj.cpp
 *
 *  Content:	DPNHUPNP main interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



#include "dpnhupnpi.h"





//=============================================================================
// Definitions
//=============================================================================
#define ACTIVE_MAPPING_VERSION							2					// version identifier for active mapping registry data

#define MAX_LONG_LOCK_WAITING_THREADS					0xFFFF				// that's a lot of simultaneous threads!

#define UPNP_SEARCH_MESSAGE_INTERVAL					499					// how often discovery multicast messages should be sent, in case of packet loss (note Win9x errata for values 500-1000ms)

#define UPNP_DGRAM_RECV_BUFFER_SIZE						1500
#define UPNP_STREAM_RECV_BUFFER_INITIAL_SIZE			(4 * 1024)			// 4 K, must be less than MAX_RECEIVE_BUFFER_SIZE

#define MAX_UPNP_HEADER_LENGTH							UPNP_STREAM_RECV_BUFFER_INITIAL_SIZE

#define LEASE_RENEW_TIME								120000				// renew if less than 2 minutes remaining

#define FAKE_PORT_LEASE_TIME							300000				// 5 minutes

#define IOCOMPLETE_WAIT_INTERVAL						100					// 100 ms between attempts
#define MAX_NUM_IOCOMPLETE_WAITS						10					// wait at most 1 second

#define MAX_NUM_HOMENETUNMAP_ATTEMPTS					3					// 3 tries
#define HOMENETUNMAP_SLEEP_FACTOR						10					// 10 ms, 20 ms, 30 ms


#define MAX_UPNP_MAPPING_DESCRIPTION_SIZE				256					// 255 characters + NULL termination

#define MAX_INSTANCENAMEDOBJECT_SIZE					64
#define INSTANCENAMEDOBJECT_FORMATSTRING				_T("DPNHUPnP Instance %u")

#define GUID_STRING_LENGTH								42					// maximum length of "{xxx...}" guid string, without NULL termination


#define PORTMAPPINGPROTOCOL_TCP							6
#define PORTMAPPINGPROTOCOL_UDP							17

#define MAX_RESERVED_PORT								1024

#define MAX_NUM_INSTANCE_EVENT_ATTEMPTS					5
#define MAX_NUM_RANDOM_PORT_TRIES						5

#ifdef DBG
#define MAX_TRANSACTION_LOG_SIZE						(5 * 1024 * 1024)	// 5 MB
#endif // DBG





#ifndef DPNBUILD_NOWINSOCK2
//=============================================================================
// WinSock 1 version of IP options
//=============================================================================
#define IP_MULTICAST_IF_WINSOCK1	2
#define IP_MULTICAST_TTL_WINSOCK1	3
#define IP_TTL_WINSOCK1				7
#endif // ! DPNBUILD_NOWINSOCK2




//=============================================================================
// Macros
//=============================================================================
//#ifdef _X86
#define IS_CLASSD_IPV4_ADDRESS(dwAddr)	(( (*((BYTE*) &(dwAddr))) & 0xF0) == 0xE0)	// 1110 high bits or 224.0.0.0 - 239.255.255.255 multicast address, in network byte order
#define NTOHS(x)						( (((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00) )
#define HTONS(x)						NTOHS(x)
//#endif _X86




//=============================================================================
// HTTP/SSDP/SOAP/UPnP header strings (from upnpmsgs.h)
//=============================================================================
const char *	c_szResponseHeaders[] =
{
	//
	// Headers used in discovery response
	//
	"CACHE-CONTROL",
	"DATE",
	"EXT",
	"LOCATION",
	"SERVER",
	"ST",
	"USN",

	//
	// Additional headers used in description response
	//
	"CONTENT-LANGUAGE",
	"CONTENT-LENGTH",
	"CONTENT-TYPE",
	"TRANSFER-ENCODING",

	//
	// Other known headers
	//
	"HOST",
	"NT",
	"NTS",
	"MAN",
	"MX",
	"AL",
	"CALLBACK",
	"TIMEOUT",
	"SCOPE",
	"SID",
	"SEQ",
};






//=============================================================================
// Pre-built UPnP message strings (from upnpmsgs.h)
//=============================================================================

const char		c_szUPnPMsg_Discover_Service_WANIPConnection[] = "M-SEARCH * " HTTP_VERSION EOL
																"HOST: " UPNP_DISCOVERY_MULTICAST_ADDRESS ":" UPNP_PORT_A EOL
																"MAN: \"ssdp:discover\"" EOL
																"MX: 2" EOL
																"ST: " URI_SERVICE_WANIPCONNECTION_A EOL
																EOL;

const char		c_szUPnPMsg_Discover_Service_WANPPPConnection[] = "M-SEARCH * " HTTP_VERSION EOL
																"HOST: " UPNP_DISCOVERY_MULTICAST_ADDRESS ":" UPNP_PORT_A EOL
																"MAN: \"ssdp:discover\"" EOL
																"MX: 2" EOL
																"ST: " URI_SERVICE_WANPPPCONNECTION_A EOL
																EOL;


//
// The disclaimer:
//
// A UPnP device may implement both the WANIPConnection and WANPPPConnection
// services.  We do not have any fancy logic to pick one, we just use the first
// device that responds to our discovery requests, and use the first matching
// service we encounter in the device description XML.
//
// Additionally, future UPnP devices may wish to present multiple device or
// service instances with the intention that one client gets control of the
// entire instance (additional clients would need to use a different instance).
// It's not clear to me what a UPnP device (or client, for that matter) would
// really gain by having such a setup.  I imagine a new error code would have
// to be returned whenever a client tried to control an instance that another
// client already owned (don't ask me how it would know that, by picking the
// first user or selectively responding to discovery requests, I guess).
// Regardless, we do not currently support that.  As noted above, we pick the
// first instance and run with it. 
//


//
// Topmost <?xml> tag is considered optional for all XML and is ignored.
//


//
// This solution assumes InternetGatewayDevice (not WANDevice or
// WANConnectionDevice) will be the topmost item in the response.  This is based
// on the following UPnP spec excerpt:
//
//	"Note that a single physical device may include multiple logical devices.
//	 Multiple logical devices can be modeled as a single root device with
//	 embedded devices (and services) or as multiple root devices (perhaps with
//	 no embedded devices). In the former case, there is one UPnP device
//	 description for the root device, and that device description contains a
//	 description for all embedded devices. In the latter case, there are
//	 multiple UPnP device descriptions, one for each root device."
//
const char *	c_szElementStack_service[] =
{
	"root",
	"device",		// InternetGatewayDevice
	"deviceList",
	"device",		// WANDevice
	"deviceList",
	"device",		// WANConnectionDevice
	"serviceList",
	"service"
};



/*
const char *	c_szElementStack_QueryStateVariableResponse[] =
{
	"Envelope",
	"Body",
	CONTROL_QUERYSTATEVARIABLE_A CONTROL_RESPONSESUFFIX_A
};
*/
const char *	c_szElementStack_GetExternalIPAddressResponse[] =
{
	"Envelope",
	"Body",
	ACTION_GETEXTERNALIPADDRESS_A CONTROL_RESPONSESUFFIX_A
};

const char *	c_szElementStack_AddPortMappingResponse[] =
{
	"Envelope",
	"Body",
	ACTION_ADDPORTMAPPING_A CONTROL_RESPONSESUFFIX_A
};

const char *	c_szElementStack_GetSpecificPortMappingEntryResponse[] =
{
	"Envelope",
	"Body",
	ACTION_GETSPECIFICPORTMAPPINGENTRY_A CONTROL_RESPONSESUFFIX_A
};

const char *	c_szElementStack_DeletePortMappingResponse[] =
{
	"Envelope",
	"Body",
	ACTION_DELETEPORTMAPPING_A CONTROL_RESPONSESUFFIX_A
};


const char *	c_szElementStack_ControlResponseFailure[] =
{
	"Envelope",
	"Body",
	"Fault",
	"detail",
	"UPnPError"
};




#ifdef WINNT
//=============================================================================
// Related UPnP services
//=============================================================================
TCHAR *		c_tszUPnPServices[] =
{
	_T("SSDPSRV"),	// SSDP Discovery Service
	_T("UPNPHOST"),	// Universal Plug and Play Device Host - we key off this even though it's for device hosts instead of control points
};
#endif // WINNT





//=============================================================================
// Local structures
//=============================================================================
typedef struct _CONTROLRESPONSEPARSECONTEXT
{
	CONTROLRESPONSETYPE			ControlResponseType;	// type of control response expected
	CUPnPDevice *				pUPnPDevice;			// pointer to UPnP device being used
	DWORD						dwHTTPResponseCode;		// HTTP response code for this message
	PUPNP_CONTROLRESPONSE_INFO	pControlResponseInfo;	// place to info returned in control response
} CONTROLRESPONSEPARSECONTEXT, * PCONTROLRESPONSEPARSECONTEXT;

typedef struct _DPNHACTIVEFIREWALLMAPPING
{
	DWORD	dwVersion;		// version identifier for this mapping
	DWORD	dwInstanceKey;	// key identifying DPNHUPNP instance that created this mapping
	DWORD	dwFlags;		// flags describing port being registered
	DWORD	dwAddressV4;	// address being mapped
	WORD	wPort;			// port being mapped
} DPNHACTIVEFIREWALLMAPPING, * PDPNHACTIVEFIREWALLMAPPING;

typedef struct _DPNHACTIVENATMAPPING
{
	DWORD	dwVersion;				// version identifier for this mapping
	DWORD	dwInstanceKey;			// key identifying DPNHUPNP instance that created this mapping
	DWORD	dwUPnPDeviceID;			// identifier for particular UPnP device corresponding to this mapping (meaningful only to owning instance)
	DWORD	dwFlags;				// flags describing port being registered
	DWORD	dwInternalAddressV4;	// internal client address being mapped
	WORD	wInternalPort;			// internal client port being mapped
	DWORD	dwExternalAddressV4;	// external public address that was mapped
	WORD	wExternalPort;			// external public port that was mapped
} DPNHACTIVENATMAPPING, * PDPNHACTIVENATMAPPING;






//=============================================================================
// Local functions
//=============================================================================
VOID strtrim(CHAR ** pszStr);

#ifdef WINCE
void GetExeName(WCHAR * wszPath);
#endif // WINCE





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CNATHelpUPnP"
//=============================================================================
// CNATHelpUPnP constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CNATHelpUPnP object.
//
// Arguments:
//	BOOL fNotCreatedWithCOM		- TRUE if this object is being instantiated
//									without COM, FALSE if it is through COM.
//
// Returns: None (the object).
//=============================================================================
CNATHelpUPnP::CNATHelpUPnP(const BOOL fNotCreatedWithCOM)
{
	this->m_blList.Initialize();


	this->m_Sig[0]	= 'N';
	this->m_Sig[1]	= 'A';
	this->m_Sig[2]	= 'T';
	this->m_Sig[3]	= 'H';

	this->m_lRefCount						= 1; // someone must have a pointer to this object

	if (fNotCreatedWithCOM)
	{
		this->m_dwFlags						= NATHELPUPNPOBJ_NOTCREATEDWITHCOM;
	}
	else
	{
		this->m_dwFlags						= 0;
	}

	this->m_hLongLockSemaphore				= NULL;
	this->m_lNumLongLockWaitingThreads		= 0;
	this->m_dwLockThreadID					= 0;
#ifndef DPNBUILD_NOWINSOCK2
	this->m_hAlertEvent						= NULL;
	this->m_hAlertIOCompletionPort			= NULL;
	this->m_dwAlertCompletionKey			= 0;
#endif // ! DPNBUILD_NOWINSOCK2

	this->m_blDevices.Initialize();
	this->m_blRegisteredPorts.Initialize();
	this->m_blUnownedPorts.Initialize();

	this->m_dwLastUpdateServerStatusTime	= 0;
	this->m_dwNextPollInterval				= 0;
	this->m_dwNumLeases						= 0;
	this->m_dwEarliestLeaseExpirationTime	= 0;

	this->m_blUPnPDevices.Initialize();
	this->m_dwInstanceKey					= 0;
	this->m_dwCurrentUPnPDeviceID			= 0;
	this->m_hMappingStillActiveNamedObject	= NULL;

#ifndef DPNBUILD_NOWINSOCK2
	this->m_hIpHlpApiDLL					= NULL;
	this->m_pfnGetAdaptersInfo				= NULL;
	this->m_pfnGetIpForwardTable			= NULL;
	this->m_pfnGetBestRoute					= NULL;

	this->m_hRasApi32DLL					= NULL;
	this->m_pfnRasGetEntryHrasconnW			= NULL;
	this->m_pfnRasGetProjectionInfo			= NULL;

	this->m_sIoctls							= INVALID_SOCKET;
	this->m_polAddressListChange			= NULL;
#endif // ! DPNBUILD_NOWINSOCK2

	this->m_hWinSockDLL						= NULL;
	this->m_pfnWSAStartup					= NULL;
	this->m_pfnWSACleanup					= NULL;
	this->m_pfnWSAGetLastError				= NULL;
	this->m_pfnsocket						= NULL;
	this->m_pfnclosesocket					= NULL;
	this->m_pfnbind							= NULL;
	this->m_pfnsetsockopt					= NULL;
	this->m_pfngetsockname					= NULL;
	this->m_pfnselect						= NULL;
	this->m_pfn__WSAFDIsSet					= NULL;
	this->m_pfnrecvfrom						= NULL;
	this->m_pfnsendto						= NULL;
	this->m_pfngethostname					= NULL;
	this->m_pfngethostbyname				= NULL;
	this->m_pfninet_addr					= NULL;
#ifndef DPNBUILD_NOWINSOCK2
	this->m_pfnWSASocketA					= NULL;
	this->m_pfnWSAIoctl						= NULL;
	this->m_pfnWSAGetOverlappedResult		= NULL;
#endif // ! DPNBUILD_NOWINSOCK2
	this->m_pfnioctlsocket					= NULL;
	this->m_pfnconnect						= NULL;
	this->m_pfnshutdown						= NULL;
	this->m_pfnsend							= NULL;
	this->m_pfnrecv							= NULL;
#ifdef DBG
	this->m_pfngetsockopt					= NULL;

	this->m_dwNumDeviceAdds					= 0;
	this->m_dwNumDeviceRemoves				= 0;
	this->m_dwNumServerFailures				= 0;
#endif // DBG
} // CNATHelpUPnP::CNATHelpUPnP






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::~CNATHelpUPnP"
//=============================================================================
// CNATHelpUPnP destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CNATHelpUPnP object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CNATHelpUPnP::~CNATHelpUPnP(void)
{
	DPFX(DPFPREP, 8, "(0x%p) NumDeviceAdds = %u, NumDeviceRemoves = %u, NumServerFailures = %u",
		this, this->m_dwNumDeviceAdds, this->m_dwNumDeviceRemoves,
		this->m_dwNumServerFailures);


	DNASSERT(this->m_blList.IsEmpty());


	DNASSERT(this->m_lRefCount == 0);
	DNASSERT((this->m_dwFlags & ~NATHELPUPNPOBJ_NOTCREATEDWITHCOM) == 0);

	DNASSERT(this->m_hLongLockSemaphore == NULL);
	DNASSERT(this->m_lNumLongLockWaitingThreads == 0);
	DNASSERT(this->m_dwLockThreadID == 0);
#ifndef DPNBUILD_NOWINSOCK2
	DNASSERT(this->m_hAlertEvent == NULL);
	DNASSERT(this->m_hAlertIOCompletionPort == NULL);
#endif // ! DPNBUILD_NOWINSOCK2

	DNASSERT(this->m_blDevices.IsEmpty());
	DNASSERT(this->m_blRegisteredPorts.IsEmpty());
	DNASSERT(this->m_blUnownedPorts.IsEmpty());

	DNASSERT(this->m_dwNumLeases == 0);

	DNASSERT(this->m_blUPnPDevices.IsEmpty());
	DNASSERT(this->m_hMappingStillActiveNamedObject == NULL);

#ifndef DPNBUILD_NOWINSOCK2
	DNASSERT(this->m_hIpHlpApiDLL == NULL);
	DNASSERT(this->m_hRasApi32DLL == NULL);
	DNASSERT(this->m_hWinSockDLL == NULL);

	DNASSERT(this->m_sIoctls == INVALID_SOCKET);
	DNASSERT(this->m_polAddressListChange == NULL);
#endif // ! DPNBUILD_NOWINSOCK2


	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 'h';
} // CNATHelpUPnP::~CNATHelpUPnP




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::QueryInterface"
//=============================================================================
// CNATHelpUPnP::QueryInterface
//-----------------------------------------------------------------------------
//
// Description: Retrieves a new reference for an interfaces supported by this
//				CNATHelpUPnP object.
//
// Arguments:
//	REFIID riid			- Reference to interface ID GUID.
//	LPVOID * ppvObj		- Place to store pointer to object.
//
// Returns: HRESULT
//	S_OK					- Returning a valid interface pointer.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	E_NOINTERFACE			- Invalid interface was specified.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = DPNH_OK;


	DPFX(DPFPREP, 3, "(0x%p) Parameters: (REFIID, 0x%p)", this, ppvObj);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid NATHelper object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDirectPlayNATHelp)))
	{
		DPFX(DPFPREP, 0, "Unsupported interface!");
		hr = E_NOINTERFACE;
		goto Failure;
	}

	if ((ppvObj == NULL) ||
		(IsBadWritePtr(ppvObj, sizeof(void*))))
	{
		DPFX(DPFPREP, 0, "Invalid interface pointer specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}


	//
	// Add a reference, and return the interface pointer (which is actually
	// just the object pointer, they line up because CNATHelpUPnP inherits from
	// the interface declaration).
	//
	this->AddRef();
	(*ppvObj) = this;


Exit:

	DPFX(DPFPREP, 3, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::AddRef"
//=============================================================================
// CNATHelpUPnP::AddRef
//-----------------------------------------------------------------------------
//
// Description: Adds a reference to this CNATHelpUPnP object.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CNATHelpUPnP::AddRef(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());


	//
	// There must be at least 1 reference to this object, since someone is
	// calling AddRef.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedIncrement(&this->m_lRefCount);

	DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);

	return lRefCount;
} // CNATHelpUPnP::AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::Release"
//=============================================================================
// CNATHelpUPnP::Release
//-----------------------------------------------------------------------------
//
// Description: Removes a reference to this CNATHelpUPnP object.  When the
//				refcount reaches 0, this object is destroyed.
//				You must NULL out your pointer to this object after calling
//				this function.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CNATHelpUPnP::Release(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());

	//
	// There must be at least 1 reference to this object, since someone is
	// calling Release.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedDecrement(&this->m_lRefCount);

	//
	// Was that the last reference?  If so, we're going to destroy this object.
	//
	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount hit 0, destroying object.", this);

		//
		// First pull it off the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		this->m_blList.RemoveFromList();

		DNASSERT(g_lOutstandingInterfaceCount > 0);
		g_lOutstandingInterfaceCount--;	// update count so DLL can unload now works correctly
		
		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Make sure it's closed.
		//
		if (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED)
		{
			//
			// Assert so that the user can fix his/her broken code!
			//
			DNASSERT(! "DirectPlayNATHelpUPNP object being released without calling Close first!");

			//
			// Then go ahead and do the right thing.  Ignore error, we can't do
			// much about it.
			//
			this->Close(0);
		}


		//
		// Then uninitialize the object.
		//
		this->UninitializeObject();

		//
		// Finally delete this (!) object.
		//
		delete this;
	}
	else
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);
	}

	return lRefCount;
} // CNATHelpUPnP::Release




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::Initialize"
//=============================================================================
// CNATHelpUPnP::Initialize
//-----------------------------------------------------------------------------
//
// Description:    Prepares the object for use.  No attempt is made to contact
//				any Internet gateway servers at this time.  The user should
//				call GetCaps with the DPNHGETCAPS_UPDATESERVERSTATUS flag to
//				search for a server.
//
//				   Initialize must be called before using any other function,
//				and must be balanced with a call to Close.  Initialize can only
//				be called once unless Close returns it to the uninitialized
//				state.
//
//				   One of DPNHINITIALIZE_DISABLEREMOTENATSUPPORT or
//				DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT may be specified,
//				but not both.
//
// Arguments:
//	DWORD dwFlags	- Flags to use when initializing.
//
// Returns: HRESULT
//	DPNH_OK						- Initialization was successful.
//	DPNHERR_ALREADYINITIALIZED	- Initialize has already been called.
//	DPNHERR_GENERIC				- An error occurred while initializing.
//	DPNHERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT		- The interface object is invalid.
//	DPNHERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNHERR_OUTOFMEMORY			- There is not enough memory to initialize.
//	DPNHERR_REENTRANT			- The interface has been re-entered on the same
//									thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::Initialize(const DWORD dwFlags)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	BOOL						fSetFlags = FALSE;
#ifndef WINCE
	OSVERSIONINFO				osvi;
#endif // ! WINCE
	BOOL						fWinSockStarted = FALSE;
	WSADATA						wsadata;
	int							iError;
#ifndef DPNBUILD_NOWINSOCK2
	SOCKADDR_IN					saddrinTemp;
#endif // ! DPNBUILD_NOWINSOCK2
	TCHAR						tszObjectName[MAX_INSTANCENAMEDOBJECT_SIZE];
	PSECURITY_ATTRIBUTES		pSecurityAttributes;
	DWORD						dwTry;
#ifdef WINNT
	SID_IDENTIFIER_AUTHORITY	SidIdentifierAuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;
	PSID						pSid = NULL;
	DWORD						dwAclLength;
	ACL *						pAcl = NULL;
	BYTE						abSecurityDescriptorBuffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
	SECURITY_ATTRIBUTES			SecurityAttributes;
#endif // WINNT
#ifdef DBG
	DWORD						dwError;
#endif // DBG


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%lx)", this, dwFlags);


#ifndef WINCE
	//
	// Print info about the current build. 
	//
#ifdef WINNT
	DPFX(DPFPREP, 7, "Build type = NT, platform = %s",
		((DNGetOSType() == VER_PLATFORM_WIN32_NT) ? _T("NT") : _T("9x")));
#else // ! WINNT
	DPFX(DPFPREP, 7, "Build type = 9x, platform = %s, filedate = %s",
		((DNGetOSType() == VER_PLATFORM_WIN32_NT) ? _T("NT") : _T("9x")));
#endif // ! WINNT
#endif // ! WINCE


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}


	//
	// Validate the parameters.
	//

	if (dwFlags & ~(DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT))
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}

	//
	// Both flags cannot be specified at the same time.  If the caller doesn't
	// want any NAT functionality, why use this object all?
	//
	if ((dwFlags & (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)) == (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT))
	{
		DPFX(DPFPREP, 0, "Either DISABLEGATEWAYSUPPORT flag or DISABLELOCALFIREWALLSUPPORT flag can be used, but not both!");
		hr = DPNHERR_INVALIDFLAGS;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if ((this->m_dwFlags & ~NATHELPUPNPOBJ_NOTCREATEDWITHCOM) != 0)
	{
		DPFX(DPFPREP, 0, "Object already initialized!");
		hr = DPNHERR_ALREADYINITIALIZED;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}


	//
	// Read in the manual override settings from the registry
	//
	ReadRegistrySettings();


	//
	// We're not completely initialized yet, but set the flag(s) now.
	//
	this->m_dwFlags |= NATHELPUPNPOBJ_INITIALIZED;
	fSetFlags = TRUE;


	//
	// Store the user's settings.
	//

	if (dwFlags & DPNHINITIALIZE_DISABLEGATEWAYSUPPORT)
	{
		DPFX(DPFPREP, 1, "User requested that Internet gateways not be supported.");
	}
	else
	{
		this->m_dwFlags |= NATHELPUPNPOBJ_USEUPNP;
	}

#ifndef DPNBUILD_NOHNETFWAPI
	if (dwFlags & DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)
	{
		DPFX(DPFPREP, 1, "User requested that local firewalls not be supported.");
	}
	else
	{
		this->m_dwFlags |= NATHELPUPNPOBJ_USEHNETFWAPI;
	}
#endif // ! DPNBUILD_NOHNETFWAPI


	switch (g_dwUPnPMode)
	{
		case OVERRIDEMODE_FORCEON:
		{
			//
			// Force UPnP on.
			//
			DPFX(DPFPREP, 1, "Forcing UPnP support on.");
			this->m_dwFlags |= NATHELPUPNPOBJ_USEUPNP;
			break;
		}

		case OVERRIDEMODE_FORCEOFF:
		{
			//
			// Force UPnP off.
			//
			DPFX(DPFPREP, 1, "Forcing UPnP support off.");
			this->m_dwFlags &= ~NATHELPUPNPOBJ_USEUPNP;
			break;
		}

		default:
		{
			//
			// Leave UPnP settings as they were set by the application.
			//
#ifdef WINNT
			//
			// But if UPnP related service(s) are disabled, we'll take that as
			// our cue to not use UPnP NAT traversal even though we don't
			// actually use those services.  We assume the user wanted to
			// squelch all SSDP/UPnP activity.  It can still be forced back on
			// with a reg key, though, as indicated by the other switch cases.
			//
			if (this->IsUPnPServiceDisabled())
			{
				DPFX(DPFPREP, 1, "Not using UPnP because a related service was disabled.");
				this->m_dwFlags &= ~NATHELPUPNPOBJ_USEUPNP;
			}
#endif // WINNT
			break;
		}
	}

#ifndef DPNBUILD_NOHNETFWAPI
	switch (g_dwHNetFWAPIMode)
	{
		case OVERRIDEMODE_FORCEON:
		{
			//
			// Force HNet firewall API on.
			//
			DPFX(DPFPREP, 1, "Forcing HNet firewall API support on.");
			this->m_dwFlags |= NATHELPUPNPOBJ_USEHNETFWAPI;
			break;
		}

		case OVERRIDEMODE_FORCEOFF:
		{
			//
			// Force HNet firewall API off.
			//
			DPFX(DPFPREP, 1, "Forcing HNet firewall API support off.");
			this->m_dwFlags &= ~NATHELPUPNPOBJ_USEHNETFWAPI;
			break;
		}

		default:
		{
			//
			// Leave HNet firewall API settings alone.
			//
			break;
		}
	}
#endif // ! DPNBUILD_NOHNETFWAPI


#ifndef WINCE
	//
	// Determine whether we're on a Win2K or higher NT OS, and if so, use the
	// "Global\\" prefix for named kernel objects so we can have Terminal
	// Server and Fast User Switching support.
	//
	ZeroMemory(&osvi, sizeof(osvi));
	osvi.dwOSVersionInfoSize = sizeof(osvi);
	if (GetVersionEx(&osvi))
	{
		if ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
			(osvi.dwMajorVersion >= 5))
		{
			DPFX(DPFPREP, 8, "Running Win2K or higher NT OS, using \"Global\\\" prefix.");
			this->m_dwFlags |= NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX;
		}
#ifdef DBG
		else
		{
			DPFX(DPFPREP, 8, "Not on NT, or its pre-Win2K, not using \"Global\\\" prefix.");
		}
#endif // DBG
	}
#ifdef DBG
else
	{
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't get OS version information (err = %u)!  Not using \"Global\\\" prefix.",
			dwError);
	}
#endif // DBG
#endif // ! WINCE


#ifdef DPNBUILD_NOWINSOCK2
#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)
	this->m_hWinSockDLL = LoadLibrary( _T("winsock.dll") );
#else // ! WINCE
	this->m_hWinSockDLL = LoadLibrary( _T("wsock32.dll") );
#endif // ! WINCE
	if (this->m_hWinSockDLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't load WinSock 1 DLL (err = 0x%lx)!.",
			dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}
#else // ! DPNBUILD_NOWINSOCK2
	//
	// Try loading the IP helper DLL.
	//
	this->m_hIpHlpApiDLL = LoadLibrary( _T("iphlpapi.dll") );
	if (this->m_hIpHlpApiDLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Unable to load \"iphlpapi.dll\" (error = 0x%lx).",
			dwError);
#endif // DBG

		//
		// That's not fatal, we can still function.
		//
	}
	else
	{
		//
		// Load the functions we'll use.
		//

		this->m_pfnGetAdaptersInfo = (PFN_GETADAPTERSINFO) GetProcAddress(this->m_hIpHlpApiDLL,
																		_TWINCE("GetAdaptersInfo"));
		if (this->m_pfnGetAdaptersInfo == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Unable to get \"GetAdaptersInfo\" function (error = 0x%lx)!",
				dwError);
#endif // DBG
			goto Exit;
		}

		this->m_pfnGetIpForwardTable = (PFN_GETIPFORWARDTABLE) GetProcAddress(this->m_hIpHlpApiDLL,
																			_TWINCE("GetIpForwardTable"));
		if (this->m_pfnGetIpForwardTable == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Unable to get \"GetIpForwardTable\" function (error = 0x%lx)!",
				dwError);
#endif // DBG
			goto Exit;
		}

		this->m_pfnGetBestRoute = (PFN_GETBESTROUTE) GetProcAddress(this->m_hIpHlpApiDLL,
																	_TWINCE("GetBestRoute"));
		if (this->m_pfnGetBestRoute == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Unable to get \"GetBestRoute\" function (error = 0x%lx)!",
				dwError);
#endif // DBG
			goto Exit;
		}
	}



	//
	// Try loading the RAS API DLL.
	//
	this->m_hRasApi32DLL = LoadLibrary( _T("rasapi32.dll") );
	if (this->m_hRasApi32DLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Unable to load \"rasapi32.dll\" (error = 0x%lx).",
			dwError);
#endif // DBG

		//
		// That's not fatal, we can still function.
		//
	}
	else
	{
		//
		// Load the functions we'll use.
		//

		this->m_pfnRasGetEntryHrasconnW = (PFN_RASGETENTRYHRASCONNW) GetProcAddress(this->m_hRasApi32DLL,
																					_TWINCE("RasGetEntryHrasconnW"));
		if (this->m_pfnRasGetEntryHrasconnW == NULL)
		{
			//
			// This function does not exist on non-NT platforms.  That's fine,
			// just dump the DLL handle so we don't try to use it.
			//
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 1, "Unable to get \"RasGetEntryHrasconnW\" function (error = 0x%lx), forgetting RAS DLL.",
				dwError);
#endif // DBG

			FreeLibrary(this->m_hRasApi32DLL);
			this->m_hRasApi32DLL = NULL;
		}
		else
		{
			this->m_pfnRasGetProjectionInfo = (PFN_RASGETPROJECTIONINFO) GetProcAddress(this->m_hRasApi32DLL,
#ifdef UNICODE
																						_TWINCE("RasGetProjectionInfoW"));
#else // ! UNICODE
																						_TWINCE("RasGetProjectionInfoA"));
#endif // ! UNICODE
			if (this->m_pfnRasGetProjectionInfo == NULL)
			{
#ifdef DBG
				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Unable to get \"RasGetProjectionInfoA/W\" function (error = 0x%lx)!",
					dwError);
#endif // DBG
				goto Exit;
			}
		}
	}


	//
	// Load WinSock because we may be using our private UPnP implementation, or
	// we just need to get the devices.
	//
	this->m_hWinSockDLL = LoadLibrary( _T("ws2_32.dll") );
	if (this->m_hWinSockDLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Couldn't load \"ws2_32.dll\" (err = 0x%lx), resorting to WinSock 1 functionality.",
			dwError);
#endif // DBG

		this->m_hWinSockDLL = LoadLibrary( _T("wsock32.dll") );
		if (this->m_hWinSockDLL == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't load \"wsock32.dll\" either (err = 0x%lx)!.",
				dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		//
		// Remember that we had to resort to WinSock 1.
		//
		this->m_dwFlags |= NATHELPUPNPOBJ_WINSOCK1;
	}
	else
	{
		DPFX(DPFPREP, 1, "Loaded \"ws2_32.dll\", using WinSock 2 functionality.");
	}
#endif // DPNBUILD_NOWINSOCK2


	//
	// Load pointers to all the functions we use in WinSock.
	//
	hr = this->LoadWinSockFunctionPointers();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't load WinSock function pointers!");
		goto Failure;
	}


	//
	// Fire up WinSock.  Request 2.2 if we can.  For the most part we only use
	// version 1.1 capabilities and interfaces anyway.  The only exceptions are
	// using the event or I/O completion port handles for notification.
	//
	ZeroMemory(&wsadata, sizeof(wsadata));

#ifndef DPNBUILD_NOWINSOCK2
	if (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1)
	{
#endif // ! DPNBUILD_NOWINSOCK2
		iError = this->m_pfnWSAStartup(MAKEWORD(1, 1), &wsadata);
#ifndef DPNBUILD_NOWINSOCK2
	}
	else
	{
		iError = this->m_pfnWSAStartup(MAKEWORD(2, 2), &wsadata);
	}
#endif // ! DPNBUILD_NOWINSOCK2
	if (iError != 0)
	{
		DPFX(DPFPREP, 0, "Couldn't startup WinSock (error = %i)!", iError);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	fWinSockStarted = TRUE;

	DPFX(DPFPREP, 4, "Initialized WinSock version %u.%u.",
		LOBYTE(wsadata.wVersion), HIBYTE(wsadata.wVersion));



#ifndef DPNBUILD_NOWINSOCK2
	//
	// Try creating a UDP socket for use with WSAIoctl.  Do this even if we're
	// WinSock 1 and can't use WSAIoctl socket.  This allows us to make sure
	// TCP/IP is installed and working.
	//

	this->m_sIoctls = this->m_pfnsocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (this->m_sIoctls == INVALID_SOCKET)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't create Ioctl socket, error = %u!", dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Try binding the socket.  This is a continuation of the validation.
	//
	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family				= AF_INET;
	//saddrinTemp.sin_addr.S_un.S_addr	= INADDR_ANY;
	//saddrinTemp.sin_port				= 0;

	if (this->m_pfnbind(this->m_sIoctls,
						(SOCKADDR *) (&saddrinTemp),
						sizeof(saddrinTemp)) != 0)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't bind the Ioctl socket to arbitrary port on any interface, error = %u!",
			dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}
#endif // ! DPNBUILD_NOWINSOCK2


	//
	// Build appropriate access control structures.  On NT, we want to allow
	// read access to everyone.  On other platforms, security is ignored.
	//
#ifdef WINNT
	if (! AllocateAndInitializeSid(&SidIdentifierAuthorityWorld,
									1,
									SECURITY_WORLD_RID,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									&pSid))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't allocate and initialize SID, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	dwAclLength = sizeof(ACL)
					+ sizeof(ACCESS_ALLOWED_ACE)
					- sizeof(DWORD)					// subtract out sizeof(ACCESS_ALLOWED_ACE.SidStart)
					+ GetLengthSid(pSid);

	pAcl = (ACL*) DNMalloc(dwAclLength);
	if (pAcl == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	if (! InitializeAcl(pAcl, dwAclLength, ACL_REVISION))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't initialize ACL, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if (! AddAccessAllowedAce(pAcl, ACL_REVISION, SYNCHRONIZE, pSid))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't add access allowed ACE, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if (! InitializeSecurityDescriptor((PSECURITY_DESCRIPTOR) abSecurityDescriptorBuffer,
										SECURITY_DESCRIPTOR_REVISION))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't initialize security descriptor, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if (! SetSecurityDescriptorDacl((PSECURITY_DESCRIPTOR) abSecurityDescriptorBuffer,
									TRUE,
									pAcl,
									FALSE))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't set security descriptor DACL, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	SecurityAttributes.nLength					= sizeof(SecurityAttributes);
	SecurityAttributes.lpSecurityDescriptor		= abSecurityDescriptorBuffer;
	SecurityAttributes.bInheritHandle			= FALSE;

	pSecurityAttributes = &SecurityAttributes;
#else // ! WINNT
	pSecurityAttributes = NULL;
#endif // ! WINNT


	//
	// Use a random number for the instance key and event.  We use this to let
	// other instances know that we're alive to avoid the crash-cleanup code.
	// Try to create the named event a couple times before giving up.
	//
	dwTry = 0;
	do
	{
		this->m_dwInstanceKey = GetGlobalRand();
		DPFX(DPFPREP, 2, "Using crash cleanup key %u.", this->m_dwInstanceKey);

#ifndef WINCE
		if (this->m_dwFlags & NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX)
		{
			wsprintf(tszObjectName, _T("Global\\") INSTANCENAMEDOBJECT_FORMATSTRING, this->m_dwInstanceKey);
			this->m_hMappingStillActiveNamedObject = DNCreateEvent(pSecurityAttributes, FALSE, FALSE, tszObjectName);
		}
		else
#endif // ! WINCE
		{
			wsprintf(tszObjectName, INSTANCENAMEDOBJECT_FORMATSTRING, this->m_dwInstanceKey);
			this->m_hMappingStillActiveNamedObject = DNCreateEvent(pSecurityAttributes, FALSE, FALSE, tszObjectName);
		}

		if (this->m_hMappingStillActiveNamedObject == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't create mapping-still-active named object, error = %u!", dwError);
#endif // DBG

			dwTry++;
			if (dwTry >= MAX_NUM_INSTANCE_EVENT_ATTEMPTS)
			{
				hr = DPNHERR_GENERIC;
				goto Failure;
			}

			//
			// Continue...
			//
		}
	}
	while (this->m_hMappingStillActiveNamedObject == NULL);

#ifdef WINNT
	DNFree(pAcl);
	pAcl = NULL;

	FreeSid(pSid);
	pSid = NULL;
#endif // WINNT


	//
	// Build the list of IP capable devices.
	//
	hr = this->CheckForNewDevices(NULL);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't build device list!");
		goto Failure;
	}


	//
	// We could technically try to contact UPnP devices right now, but we don't
	// because it's a slow blocking operation, and users have to call GetCaps
	// at least once anyway.
	//


Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (this->m_hMappingStillActiveNamedObject != NULL)
	{
		DNCloseHandle(this->m_hMappingStillActiveNamedObject);
		this->m_hMappingStillActiveNamedObject = NULL;
	}

#ifdef WINNT
	if (pAcl != NULL)
	{
		DNFree(pAcl);
		pAcl = NULL;
	}

	if (pSid != NULL)
	{
		FreeSid(pSid);
		pSid = NULL;
	}
#endif // WINNT

	this->RemoveAllItems();

#ifndef DPNBUILD_NOWINSOCK2
	if (this->m_sIoctls != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(this->m_sIoctls);	// ignore error
		this->m_sIoctls = INVALID_SOCKET;
	}
#endif // ! DPNBUILD_NOWINSOCK2

	if (fWinSockStarted)
	{
		this->m_pfnWSACleanup(); // ignore error
	}

#ifndef DPNBUILD_NOWINSOCK2
	if (this->m_hWinSockDLL != NULL)
	{
		this->m_pfnWSAStartup				= NULL;
		this->m_pfnWSACleanup				= NULL;
		this->m_pfnWSAGetLastError			= NULL;
		this->m_pfnsocket					= NULL;
		this->m_pfnclosesocket				= NULL;
		this->m_pfnbind						= NULL;
		this->m_pfnsetsockopt				= NULL;
		this->m_pfngetsockname				= NULL;
		this->m_pfnselect					= NULL;
		this->m_pfn__WSAFDIsSet				= NULL;
		this->m_pfnrecvfrom					= NULL;
		this->m_pfnsendto					= NULL;
		this->m_pfngethostname				= NULL;
		this->m_pfngethostbyname			= NULL;
		this->m_pfninet_addr				= NULL;
		this->m_pfnWSASocketA				= NULL;
		this->m_pfnWSAIoctl					= NULL;
		this->m_pfnWSAGetOverlappedResult	= NULL;
		this->m_pfnioctlsocket				= NULL;
		this->m_pfnconnect					= NULL;
		this->m_pfnshutdown					= NULL;
		this->m_pfnsend						= NULL;
		this->m_pfnrecv						= NULL;
#ifdef DBG
		this->m_pfngetsockopt				= NULL;
#endif // DBG


		this->m_dwFlags &= ~NATHELPUPNPOBJ_WINSOCK1;

		FreeLibrary(this->m_hWinSockDLL);
		this->m_hWinSockDLL = NULL;
	}

	if (this->m_hRasApi32DLL != NULL)
	{
		this->m_pfnRasGetEntryHrasconnW		= NULL;
		this->m_pfnRasGetProjectionInfo		= NULL;

		FreeLibrary(this->m_hRasApi32DLL);
		this->m_hRasApi32DLL = NULL;
	}

	if (this->m_hIpHlpApiDLL != NULL)
	{
		this->m_pfnGetAdaptersInfo			= NULL;
		this->m_pfnGetIpForwardTable		= NULL;
		this->m_pfnGetBestRoute				= NULL;

		FreeLibrary(this->m_hIpHlpApiDLL);
		this->m_hIpHlpApiDLL = NULL;
	}
#endif // ! DPNBUILD_NOWINSOCK2

	if (fSetFlags)
	{
		this->m_dwFlags &= ~(NATHELPUPNPOBJ_INITIALIZED |
							NATHELPUPNPOBJ_USEUPNP |
#ifndef DPNBUILD_NOHNETFWAPI
							NATHELPUPNPOBJ_USEHNETFWAPI |
#endif // ! DPNBUILD_NOHNETFWAPI
#ifdef WINCE
							NATHELPUPNPOBJ_DEVICECHANGED);
#else // ! WINCE
							NATHELPUPNPOBJ_DEVICECHANGED |
							NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX);
#endif // ! WINCE
	}

	goto Exit;
} // CNATHelpUPnP::Initialize






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::Close"
//=============================================================================
// CNATHelpUPnP::Close
//-----------------------------------------------------------------------------
//
// Description:    Shuts down and de-registers this application with any
//				Internet gateway servers.  All port assignments are implicitly
//				freed as a result of this operation.
//
//				   This must balance a successful call to Initialize.
//
// Arguments:
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- Closing the helper API was successful.
//	DPNHERR_GENERIC			- An error occurred while closing.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory to close.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::Close(const DWORD dwFlags)
{
	HRESULT		hr;
	BOOL		fHaveLock = FALSE;
	int			iError;
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%lx)", this, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// We need to actively deregister any devices which are registered with
	// Internet gateways.
	//
	this->RemoveAllItems();


	//
	// Close the named object since this process is going away.
	//
	if (this->m_hMappingStillActiveNamedObject != NULL)
	{
		DNCloseHandle(this->m_hMappingStillActiveNamedObject);
		this->m_hMappingStillActiveNamedObject = NULL;
	}


#ifndef DPNBUILD_NOWINSOCK2
	//
	// Close the Ioctl socket.
	//
	DNASSERT(this->m_sIoctls != INVALID_SOCKET);
	this->m_pfnclosesocket(this->m_sIoctls);	// ignore error
	this->m_sIoctls = INVALID_SOCKET;



	//
	// If we submitted overlapped I/O, see if it got cancelled.
	//
	if (this->m_polAddressListChange != NULL)
	{
		OSVERSIONINFO		osvi;
		OSVERSIONINFOEX		osvix;
		BOOL				fCanWait;
		DWORD				dwAttempt;


		ZeroMemory(&osvi, sizeof(osvi));
		osvi.dwOSVersionInfoSize = sizeof(osvi);

		if (GetVersionEx(&osvi))
		{
			//
			// Any platform but Win2K Gold, Win2K + SP1, or Win2K + SP2 can
			// just go ahead and wait for the I/O to complete.
			//
			if ((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
				(osvi.dwMajorVersion > 5) ||
				(osvi.dwMinorVersion > 0))
			{
				DPFX(DPFPREP, 3, "Windows %s version %u.%u detected, waiting for address list change Ioctl to complete.",
					((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) ? _T("9x") : _T("NT")),
					osvi.dwMajorVersion, osvi.dwMinorVersion);

				fCanWait = TRUE;
			}
			else
			{
				//
				// Win2K versions < SP3 have a bug where the I/O is not always
				// cancelled by closing the socket.  We can't wait for the
				// completion, sometimes it doesn't happen.
				//

				fCanWait = FALSE;

				ZeroMemory(&osvix, sizeof(osvix));
				osvix.dwOSVersionInfoSize = sizeof(osvix);

				if (GetVersionEx((LPOSVERSIONINFO) (&osvix)))
				{
					//
					// If SP3 or later is applied, we know it's fixed.
					//
					if (osvix.wServicePackMajor >= 3)
					{
						DPFX(DPFPREP, 3, "Windows 2000 Service Pack %u detected, waiting for address list change Ioctl to complete.",
							osvix.wServicePackMajor);
						fCanWait = TRUE;
					}
#ifdef DBG
					else
					{
						if (osvix.wServicePackMajor == 0)
						{
							DPFX(DPFPREP, 2, "Windows 2000 Gold detected, not waiting for address list change Ioctl to complete.");
						}
						else
						{
							DPFX(DPFPREP, 2, "Windows 2000 Service Pack %u detected, not waiting for address list change Ioctl to complete.",
								osvix.wServicePackMajor);
						}
					}
#endif // DBG
				}
#ifdef DBG
				else
				{
					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Couldn't get extended OS version information (err = %u)!  Assuming not Win2K < SP3.",
						dwError);
				}
#endif // DBG
			}


			//
			// Wait, if we can.  Otherwise, leak the memory.
			//
			if (fCanWait)
			{
				//
				// Keep looping until I/O completes.  We will give up after a
				// while to prevent hangs.
				//
				dwAttempt = 0;
				while (! HasOverlappedIoCompleted(this->m_polAddressListChange))
				{
					DPFX(DPFPREP, 2, "Waiting %u ms for address list change Ioctl to complete.",
						IOCOMPLETE_WAIT_INTERVAL);

					//
					// Give the OS some time to complete it.
					//
					Sleep(IOCOMPLETE_WAIT_INTERVAL);

					dwAttempt++;

					if (dwAttempt >= MAX_NUM_IOCOMPLETE_WAITS)
					{
						break;
					}
				}
			}
			else
			{
				//
				// Just leak the memory.  See above notes and debug print
				// statements
				//
			}
		}
#ifdef DBG
		else
		{
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't get OS version information (err = %u)!  Assuming not Win2K < SP3.",
				dwError);
		}
#endif // DBG


		//
		// We've either freed the memory or committed to leaking the object.
		//
		if (HasOverlappedIoCompleted(this->m_polAddressListChange))
		{
			//
			// We didn't allocate it through DNMalloc, use the matching free
			// function.
			//
			HeapFree(GetProcessHeap(), 0, this->m_polAddressListChange);
		}
		else
		{
			DPFX(DPFPREP, 1, "Overlapped address list change Ioctl has not completed yet, leaking %u byte overlapped structure at 0x%p.",
				sizeof(WSAOVERLAPPED), this->m_polAddressListChange);
		}

		this->m_polAddressListChange = NULL;
	}
#endif // ! DPNBUILD_NOWINSOCK2



	//
	// Cleanup WinSock.
	//
	iError = this->m_pfnWSACleanup();
	if (iError != 0)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't cleanup WinSock (error = %u)!", dwError);
#endif // DBG

		//
		// Continue anyway, so we can finish cleaning up the object.
		//
	}


	//
	// Unload the library.
	//

	this->m_pfnWSAStartup				= NULL;
	this->m_pfnWSACleanup				= NULL;
	this->m_pfnWSAGetLastError			= NULL;
	this->m_pfnsocket					= NULL;
	this->m_pfnclosesocket				= NULL;
	this->m_pfnbind						= NULL;
	this->m_pfnsetsockopt				= NULL;
	this->m_pfngetsockname				= NULL;
	this->m_pfnselect					= NULL;
	this->m_pfn__WSAFDIsSet				= NULL;
	this->m_pfnrecvfrom					= NULL;
	this->m_pfnsendto					= NULL;
	this->m_pfngethostname				= NULL;
	this->m_pfngethostbyname			= NULL;
	this->m_pfninet_addr				= NULL;
#ifndef DPNBUILD_NOWINSOCK2
	this->m_pfnWSASocketA				= NULL;
	this->m_pfnWSAIoctl					= NULL;
	this->m_pfnWSAGetOverlappedResult	= NULL;
#endif // ! DPNBUILD_NOWINSOCK2
	this->m_pfnioctlsocket				= NULL;
	this->m_pfnconnect					= NULL;
	this->m_pfnshutdown					= NULL;
	this->m_pfnsend						= NULL;
	this->m_pfnrecv						= NULL;
#ifdef DBG
	this->m_pfngetsockopt				= NULL;
#endif // DBG


	FreeLibrary(this->m_hWinSockDLL);
	this->m_hWinSockDLL = NULL;


#ifndef DPNBUILD_NOWINSOCK2
	//
	// If we loaded RASAPI32.DLL, unload it.
	//
	if (this->m_hRasApi32DLL != NULL)
	{
		this->m_pfnRasGetEntryHrasconnW		= NULL;
		this->m_pfnRasGetProjectionInfo		= NULL;

		FreeLibrary(this->m_hRasApi32DLL);
		this->m_hRasApi32DLL = NULL;
	}


	//
	// If we loaded IPHLPAPI.DLL, unload it.
	//
	if (this->m_hIpHlpApiDLL != NULL)
	{
		this->m_pfnGetAdaptersInfo			= NULL;
		this->m_pfnGetIpForwardTable		= NULL;
		this->m_pfnGetBestRoute				= NULL;

		FreeLibrary(this->m_hIpHlpApiDLL);
		this->m_hIpHlpApiDLL = NULL;
	}


	//
	// If there was an alert event, we're done with it.
	//
	if (this->m_hAlertEvent != NULL)
	{
		CloseHandle(this->m_hAlertEvent);
		this->m_hAlertEvent = NULL;
	}

	//
	// If there was an alert I/O completion port, we're done with it.
	//
	if (this->m_hAlertIOCompletionPort != NULL)
	{
		CloseHandle(this->m_hAlertIOCompletionPort);
		this->m_hAlertIOCompletionPort = NULL;
	}
#endif // ! DPNBUILD_NOWINSOCK2


	//
	// Turn off flags which should reset it back to 0 or just the
	// NOTCREATEDWITHCOM flag.
	//
	this->m_dwFlags &= ~(NATHELPUPNPOBJ_INITIALIZED |
						NATHELPUPNPOBJ_USEUPNP |
#ifndef DPNBUILD_NOHNETFWAPI
						NATHELPUPNPOBJ_USEHNETFWAPI |
#endif // ! DPNBUILD_NOHNETFWAPI
#ifndef DPNBUILD_NOWINSOCK2
						NATHELPUPNPOBJ_WINSOCK1 |
#endif // ! DPNBUILD_NOWINSOCK2
						NATHELPUPNPOBJ_DEVICECHANGED |
						NATHELPUPNPOBJ_ADDRESSESCHANGED |
#ifdef WINCE
						NATHELPUPNPOBJ_PORTREGISTERED);
#else // ! WINCE
						NATHELPUPNPOBJ_PORTREGISTERED |
						NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX);
#endif // ! WINCE
	DNASSERT((this->m_dwFlags & ~NATHELPUPNPOBJ_NOTCREATEDWITHCOM) == 0);


	this->DropLock();
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::Close





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetCaps"
//=============================================================================
// CNATHelpUPnP::GetCaps
//-----------------------------------------------------------------------------
//
// Description:    Retrieves the capabilities of the Internet gateway server(s)
//				and information on leased ports.  This function should be
//				called periodically with the DPNHGETCAPS_UPDATESERVERSTATUS
//				flag to automatically extend port leases that are about to
//				expire (that are in last 2 minutes of their lease).
//
//				   The DPNHGETCAPS_UPDATESERVERSTATUS flag also causes
//				detection of changes in the servers' status since the last
//				similar call to GetCaps.  If a new server becomes available, an
//				existing one became unavailable, or a server's public address
//				changed in a way that affects an existing registered port
//				mapping, then DPNHSUCCESS_ADDRESSESCHANGED is returned instead
//				of DPNH_OK.  The user should then update its port binding
//				information via GetRegisteredAddresses.
//
//				   When DPNHGETCAPS_UPDATESERVERSTATUS is specified, this
//				function may block for a short period of time while attempts
//				are made to communicate with the server(s).
//
//				   GetCaps must be called with the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag at least once prior to
//				using the GetRegisteredAddresses or QueryAddress methods.
//
// Arguments:
//	DPNHCAPS * pdpnhcaps	- Pointer to structure to be filled with the NAT
//								helper's current capabilities.  The dwSize
//								field of the structure must be filled in before
//								calling GetCaps.
//	DWORD dwFlags			- Flags to use when retrieving capabilities
//								(DPNHGETCAPS_xxx).
//
// Returns: HRESULT
//	DPNH_OK							- Determining capabilities was successful.
//										Address status has not changed.
//	DPNHSUCCESS_ADDRESSESCHANGED	- One or more of the registered port
//										mappings' addresses changed, retrieve
//										updated mappings with
//										GetRegisteredAddress.
//	DPNHERR_GENERIC					- An error occurred while determining
//										capabilities.
//	DPNHERR_INVALIDFLAGS			- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT			- The interface object is invalid.
//	DPNHERR_INVALIDPARAM			- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER			- An invalid pointer was specified.
//	DPNHERR_NOTINITIALIZED			- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY				- There is not enough memory to get
//										capabilities.
//	DPNHERR_REENTRANT				- The interface has been re-entered on the
//										same thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::GetCaps(DPNHCAPS * const pdpnhcaps,
									const DWORD dwFlags)
{
	HRESULT				hr;
	BOOL				fHaveLock = FALSE;
	DWORD				dwCurrentTime;
	DWORD				dwLeaseTimeRemaining;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;
	CUPnPDevice *		pUPnPDevice = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx)",
		this, pdpnhcaps, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((pdpnhcaps == NULL) ||
		(IsBadWritePtr(pdpnhcaps, sizeof(DPNHCAPS))))
	{
		DPFX(DPFPREP, 0, "Invalid caps structure pointer specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pdpnhcaps->dwSize != sizeof(DPNHCAPS))
	{
		DPFX(DPFPREP, 0, "Invalid caps structure specified, dwSize must be %u!",
			sizeof(DPNHCAPS));
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags & ~DPNHGETCAPS_UPDATESERVERSTATUS)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// Fill in the base caps structure.
	//

	pdpnhcaps->dwFlags = 0;

	pdpnhcaps->dwNumRegisteredPorts = 0;

	pdpnhcaps->dwMinLeaseTimeRemaining = -1;

	//
	// pdpnhcaps->dwRecommendedGetCapsInterval is initialized below
	//


	if (dwFlags & DPNHGETCAPS_UPDATESERVERSTATUS)
	{
		//
		// Remove any cached mappings that have expired.
		//
		this->ExpireOldCachedMappings();


		//
		// Extend leases, if necessary.
		//
		hr = this->ExtendAllExpiringLeases();
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Extending all expiring leases failed!");
			goto Failure;
		}


		//
		// Check for any new devices.
		//
		hr = this->CheckForNewDevices(NULL);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Checking for new devices failed!");
			goto Failure;
		}


		//
		// Check for possible changes in any server's status.  The
		// ADDRESSESCHANGED flag will be set on this object if there were
		// changes that affected existing port mappings.
		//
		hr = this->UpdateServerStatus();
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Updating servers' status failed!");
			goto Failure;
		}


		//
		// Okay, so if things are different, alert the caller.
		//
		if (this->m_dwFlags & NATHELPUPNPOBJ_ADDRESSESCHANGED)
		{
			hr = DPNHSUCCESS_ADDRESSESCHANGED;
			this->m_dwFlags &= ~NATHELPUPNPOBJ_ADDRESSESCHANGED;
		}


#ifdef DBG
		//
		// This flag should have been turned off by now if it ever got turned
		// on.
		//
		DNASSERT(! (this->m_dwFlags & NATHELPUPNPOBJ_DEVICECHANGED));


		//
		// Print the current device and mapping status for debugging purposes.
		//
		this->DebugPrintCurrentStatus();
#endif // DBG
	}
	else
	{
		//
		// Not extending expiring leases or updating server status.
		//
	}


	//
	// Loop through all the devices, getting their gateway capabilities.
	//
	pBilink = this->m_blDevices.GetNext();
	while (pBilink != (&this->m_blDevices))
	{
		DNASSERT(! pBilink->IsEmpty());
		pDevice = DEVICE_FROM_BILINK(pBilink);

#ifndef DPNBUILD_NOHNETFWAPI
		if (pDevice->IsHNetFirewalled())
		{
			//
			// The firewall does not actively notify you of it going down.
			//
			pdpnhcaps->dwFlags |= DPNHCAPSFLAG_LOCALFIREWALLPRESENT | DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE | DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY;
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		pUPnPDevice = pDevice->GetUPnPDevice();
		if (pUPnPDevice != NULL)
		{
			DNASSERT(pUPnPDevice->IsReady());

			pdpnhcaps->dwFlags |= DPNHCAPSFLAG_GATEWAYPRESENT;

			if (pUPnPDevice->IsLocal())
			{
				pdpnhcaps->dwFlags |= DPNHCAPSFLAG_GATEWAYISLOCAL;
			}

			if (pUPnPDevice->GetExternalIPAddressV4() != 0)
			{
				pdpnhcaps->dwFlags |= DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE;
			}

			//
			// The custom UPnP stack currently does not support active
			// notification...
			//
			pdpnhcaps->dwFlags |= DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY;
		}

		pBilink = pBilink->GetNext();
	}


	//
	// Loop through all registered ports, counting them.
	// We have the appropriate lock.
	//
	pBilink = this->m_blRegisteredPorts.GetNext();
	dwCurrentTime = GETTIMESTAMP();

	while (pBilink != (&this->m_blRegisteredPorts))
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

		//
		// Count these registered addresses toward the total.
		//
		pdpnhcaps->dwNumRegisteredPorts += pRegisteredPort->GetNumAddresses();


		pDevice = pRegisteredPort->GetOwningDevice();
		if (pDevice != NULL)
		{
			DNASSERT(! (pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts)));

			//
			// If they're registered with any UPnP devices using a non-
			// permanent lease, calculate the minimum lease time remaining.
			//

			if ((pRegisteredPort->HasUPnPPublicAddresses()) &&
				(! pRegisteredPort->HasPermanentUPnPLease()))
			{
				dwLeaseTimeRemaining = pRegisteredPort->GetUPnPLeaseExpiration() - dwCurrentTime;
				if (dwLeaseTimeRemaining < pdpnhcaps->dwMinLeaseTimeRemaining)
				{
					//
					// Temporarily store how much time remains.
					//
					pdpnhcaps->dwMinLeaseTimeRemaining = dwLeaseTimeRemaining;
				}
			}
		}
		else
		{
			DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
		}

		pBilink = pBilink->GetNext();
	}


	//
	// There are different default recommended GetCaps intervals depending on
	// whether there's a server present, and whether it supports active address
	// change notification (that we can alert on) or not.
	//
	// If there are any leases which need to be renewed before that default
	// time, the recommendation will be shortened appropriately.
	//

	//
	// If GetCaps hasn't been called with UPDATESERVERSTATUS yet, recommend an
	// immediate check.
	//
	if (this->m_dwLastUpdateServerStatusTime == 0)
	{
		DPFX(DPFPREP, 1, "Server status has not been updated yet, recommending immediate GetCaps.");

		//
		// Drop the lock, we're done here.
		//
		this->DropLock();
		fHaveLock = FALSE;

		goto Exit;
	}


	//
	// In an ideal world, we could get notified of changes and we would never
	// have to poll.  Unfortunately that isn't the case.  We need to recommend
	// a relatively short poll interval.
	//
	// Start by figuring out how long it's been since the last server update.
	// This calculation really should not go negative.  If it does, it means
	// the caller hasn't updated the server status in ages anyway, so we should
	// recommend immediate GetCaps.
	//
	// Otherwise if the 'port registered' flag is still set at this point, then
	// the user must have called GetCaps previously, then RegisterPorts, then
	// made this second GetCaps call before g_dwMinUpdateServerStatusInterval
	// elapsed.  Recommend that the user call us again as soon as the minimum
	// update interval does elapse.
	//
	// In all other cases, generate a recommendation based on the current
	// backed off poll interval.
	//
	dwCurrentTime = dwCurrentTime - this->m_dwLastUpdateServerStatusTime;

	if ((int) dwCurrentTime < 0)
	{
		DPFX(DPFPREP, 1, "Server status was last updated a really long time ago (%u ms), recommending immediate GetCaps.",
			dwCurrentTime);
		pdpnhcaps->dwRecommendedGetCapsInterval = 0;
	}
	else if (this->m_dwFlags & NATHELPUPNPOBJ_PORTREGISTERED)
	{
		DPFX(DPFPREP, 1, "Didn't handle new port registration because server was last updated %u ms ago, (poll interval staying at %u ms).",
			dwCurrentTime, this->m_dwNextPollInterval);

		pdpnhcaps->dwRecommendedGetCapsInterval = g_dwMinUpdateServerStatusInterval - dwCurrentTime;
		if ((int) pdpnhcaps->dwRecommendedGetCapsInterval < 0)
		{
			pdpnhcaps->dwRecommendedGetCapsInterval = 0;
		}
	}
	else
	{
		DPFX(DPFPREP, 7, "Server was last updated %u ms ago, current poll interval is %u ms.",
			dwCurrentTime, this->m_dwNextPollInterval);

		//
		// Calculate a new recommended interval based on the current value, and
		// backoff that interval if necessary.
		//
		pdpnhcaps->dwRecommendedGetCapsInterval = this->m_dwNextPollInterval - dwCurrentTime;
		this->m_dwNextPollInterval += GetGlobalRand() % g_dwPollIntervalBackoff;
		if (this->m_dwNextPollInterval > g_dwMaxPollInterval)
		{
			this->m_dwNextPollInterval = g_dwMaxPollInterval;
			DPFX(DPFPREP, 3, "Capping next poll interval at %u ms.",
				this->m_dwNextPollInterval);
		}
		else
		{
			DPFX(DPFPREP, 8, "Next poll interval will be %u ms.",
				this->m_dwNextPollInterval);
		}


		//
		// If that time went negative, then it implies that the interval has
		// already elapsed.  Recommend immediate GetCaps.
		//
		if (((int) pdpnhcaps->dwRecommendedGetCapsInterval) < 0)
		{
			DPFX(DPFPREP, 1, "Recommended interval already elapsed (%i ms), suggesting immediate GetCaps.",
				((int) pdpnhcaps->dwRecommendedGetCapsInterval));
			pdpnhcaps->dwRecommendedGetCapsInterval = 0;
		}
	}


	this->DropLock();
	fHaveLock = FALSE;


	//
	// If there is a non-INFINITE lease time remaining, see if that affects the
	// GetCaps interval.
	//
	if (pdpnhcaps->dwMinLeaseTimeRemaining != -1)
	{
		//
		// If there are leases that need to be refreshed before the default
		// recommendation, then use those instead.
		//
		if (pdpnhcaps->dwMinLeaseTimeRemaining < LEASE_RENEW_TIME)
		{
			DPFX(DPFPREP, 1, "Lease needs renewing right away (min %u < %u ms), recommending immediate GetCaps.",
				pdpnhcaps->dwMinLeaseTimeRemaining, LEASE_RENEW_TIME);

			pdpnhcaps->dwRecommendedGetCapsInterval = 0;
		}
		else
		{
			//
			// Either pick the time when the lease should be renewed or leave
			// it as the recommended time, whichever is shorter.
			//
			if ((pdpnhcaps->dwMinLeaseTimeRemaining - LEASE_RENEW_TIME) < pdpnhcaps->dwRecommendedGetCapsInterval)
			{
				pdpnhcaps->dwRecommendedGetCapsInterval = pdpnhcaps->dwMinLeaseTimeRemaining - LEASE_RENEW_TIME;
			}
		}
	}


	DPFX(DPFPREP, 7, "GetCaps flags = 0x%lx, num registered ports = %u, min lease time remaining = %i, recommended interval = %i.",
		pdpnhcaps->dwFlags,
		pdpnhcaps->dwNumRegisteredPorts,
		((int) pdpnhcaps->dwMinLeaseTimeRemaining),
		((int) pdpnhcaps->dwRecommendedGetCapsInterval));


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::GetCaps





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::RegisterPorts"
//=============================================================================
// CNATHelpUPnP::RegisterPorts
//-----------------------------------------------------------------------------
//
// Description:    Asks for public realm port(s) that are aliases for the local
//				port(s) on this private realm node.  If a server is available,
//				all traffic directed to the gateway on the public side at the
//				allocated public ports-- which the gateway provides and
//				specifies in the response-- will be directed to the specified
//				local ports.  If the DPNHREGISTERPORTS_FIXEDPORTS flag is not
//				specified, the ports assigned on the public interface are
//				arbitrary (i.e. may not be the same as those in awLocalPort).
//				The address and ports actually allocated can be retrieved by
//				calling GetRegisteredAddresses.
//
//				   The address component for every SOCKADDR structure in the
//				array must be the same.  A separate RegisterPorts call is
//				required to register multiple ports that are not using the same
//				interface.  The address can be INADDR_ANY, in which case the
//				"best" server will be used.  If multiple servers are available
//				via different adapters, an adapter with an Internet gateway is
//				selected.  If no adapters have Internet gateways, the first
//				adapter with a local firewall is selected.  If neither are
//				available, then the first one where either a gateway or a
//				firewall becomes available will be automatically selected.
//				Once one of the adapters has been assigned, it cannot be
//				changed.  Since the server chosen by this method may not be
//				optimal for a particular application, it is recommended that
//				individual addresses be registered instead of INADDR_ANY.
//
//				   If the address in aLocalAddresses is not one of those
//				available to the local machine, the registration will still
//				succeed.  If an adapter with that address becomes available,
//				the port mapping will automatically be applied, and it will
//				gain a public mapping with any server available to that
//				adapter.  If the address was originally available but the
//				network adapter is subsequently removed from the system, any
//				public address mapping is lost.  It will be automatically
//				regained if the local address becomes available again.  It is
//				recommended that the caller detect local address changes
//				independently and de-register/re-register mappings per adapter
//				as appropriate for maximum control.
//
//				   If the DPNHREGISTERPORTS_SHAREDPORTS flag is used, the
//				server will allow other NAT clients to register it as well.
//				Any UDP traffic received on the public interface will be
//				forwarded to all clients registered.  This requires the
//				DPNHREGISTERPORTS_FIXEDPORTS flag and cannot be used with
//				DPNHREGISTERPORTS_TCP.
//
//				   The user should specify a requested lease time that the
//				server will attempt to honor.  The actual time remaining can be
//				can be retrieved by calling GetRegisteredAddresses.
//
//				   Note that if a server is not available, this function will
//				still succeed. GetRegisteredAddresses will return
//				DPNHERR_NOMAPPING for the handle returned in phRegisteredPorts
//				in that case.  If the server arrives later during the session,
//				calling GetCaps periodically can detect this and automatically
//				map previously registered ports.  Use GetRegisteredAddresses to
//				retrieve the newly mapped address when that occurs.
//
//				   Only 16 ports may be registered at a time, but RegisterPorts
//				may be called as many times as desired.
//
//				   The same array of addresses may be registered more than
//				once.  Each DPNHHANDLE returned must be released with
//				DeregisterPorts or Close.  If an individual address was
//				previously registered but in a different array or a different
//				order in the array, then the DPNHERR_PORTALREADYREGISTERED
//				error code is returned.
//
// Arguments:
//	SOCKADDR * aLocalAddresses		- Array of local address and port tuples
//										for which remote ports are requested.
//	DWORD dwAddressesSize			- Size of entire local addresses array.
//	DWORD dwNumAddresses			- Number of SOCKADDR structures in local
//										addresses array.
//	DWORD dwLeaseTime				- Requested time, in milliseconds, to lease
//										the ports.  As long as GetCaps is
//										called before this time has expired,
//										the lease will automatically be
//										renewed.
//	DPNHHANDLE * phRegisteredPorts	- Place to store an identifier for this
//										binding which can later be used to
//										query or release the binding.
//	DWORD dwFlags					- Flags to use when registering the port
//										(DPNHREGISTERPORTS_xxx).
//
// Returns: HRESULT
//	DPNH_OK							- The ports were successfully registered
//										(although no public address may be
//										available yet).
//	DPNHERR_GENERIC					- An error occurred that prevented
//										registration of the requested ports.
//	DPNHERR_INVALIDFLAGS			- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT			- The interface object is invalid.
//	DPNHERR_INVALIDPARAM			- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER			- An invalid pointer was specified.
//	DPNHERR_NOTINITIALIZED			- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY				- There is not enough memory to register
//										the ports.
//	DPNHERR_PORTALREADYREGISTERED	- At least one of the ports has already
//										been registered in a different address
//										array or order.
//	DPNHERR_REENTRANT				- The interface has been re-entered on the
//										same thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::RegisterPorts(const SOCKADDR * const aLocalAddresses,
										const DWORD dwAddressesSize,
										const DWORD dwNumAddresses,
										const DWORD dwLeaseTime,
										DPNHHANDLE * const phRegisteredPorts,
										const DWORD dwFlags)
{
	HRESULT				hr;
	ULONG				ulFirstAddress;
	DWORD				dwTemp;
	DWORD				dwMatch;
	BOOL				fHaveLock = FALSE;
	CRegisteredPort *	pRegisteredPort = NULL;
	CDevice *			pDevice = NULL;
	CBilink *			pBilink;
	SOCKADDR_IN *		pasaddrinTemp;
	CUPnPDevice *		pUPnPDevice = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, %u, %u, %u, 0x%p, 0x%lx)",
		this, aLocalAddresses, dwAddressesSize, dwNumAddresses, dwLeaseTime,
		phRegisteredPorts, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (aLocalAddresses == NULL)
	{
		DPFX(DPFPREP, 0, "Local addresses array cannot be NULL!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwNumAddresses == 0)
	{
		DPFX(DPFPREP, 0, "Number of addresses cannot be 0!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwAddressesSize != (dwNumAddresses * sizeof(SOCKADDR)))
	{
		DPFX(DPFPREP, 0, "Addresses array size invalid!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (IsBadReadPtr(aLocalAddresses, dwAddressesSize))
	{
		DPFX(DPFPREP, 0, "Local addresses array buffer is invalid!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwNumAddresses > DPNH_MAX_SIMULTANEOUS_PORTS)
	{
		DPFX(DPFPREP, 0, "Only %u ports may be registered at a time!", DPNH_MAX_SIMULTANEOUS_PORTS);
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) aLocalAddresses)->sin_family != AF_INET)
	{
		DPFX(DPFPREP, 0, "First address in array is not AF_INET, only IPv4 addresses are supported!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_addr == INADDR_BROADCAST)
	{
		DPFX(DPFPREP, 0, "First address cannot be broadcast address!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) aLocalAddresses)->sin_port == 0)
	{
		DPFX(DPFPREP, 0, "First port in array is 0, a valid port must be specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	ulFirstAddress = ((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_addr;

	for(dwTemp = 1; dwTemp < dwNumAddresses; dwTemp++)
	{
		//
		// Make sure this address family type is supported.
		//
		if (((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_family != AF_INET)
		{
			DPFX(DPFPREP, 0, "Address at array index %u is not AF_INET, all items in the array must be the same IPv4 address!",
				dwTemp);
			hr = DPNHERR_INVALIDPARAM;
			goto Failure;
		}

		//
		// If this address doesn't match the first, then the caller broke the
		// rules.
		//
		if (((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_addr != ulFirstAddress)
		{
			//
			// Don't use inet_ntoa because we may not be initialized yet.
			//
			DPFX(DPFPREP, 0, "Address %u.%u.%u.%u at array index %u differs from the first, all addresses in the array must match!",
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b1,
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b2,
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b3,
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b4,
				dwTemp);
			hr = DPNHERR_INVALIDPARAM;
			goto Failure;
		}

		//
		// Make sure this port isn't 0 either.
		//
		if (((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_port == 0)
		{
			DPFX(DPFPREP, 0, "Port at array index %u is 0, valid ports must be specified!", dwTemp);
			hr = DPNHERR_INVALIDPARAM;
			goto Failure;
		}
	}

	if (dwLeaseTime == 0)
	{
		DPFX(DPFPREP, 0, "Invalid lease time specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if ((phRegisteredPorts == NULL) ||
		(IsBadWritePtr(phRegisteredPorts, sizeof(DPNHHANDLE))))
	{
		DPFX(DPFPREP, 0, "Invalid port mapping handle pointer specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwFlags & ~(DPNHREGISTERPORTS_TCP | DPNHREGISTERPORTS_FIXEDPORTS | DPNHREGISTERPORTS_SHAREDPORTS))
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}

	if (dwFlags & DPNHREGISTERPORTS_SHAREDPORTS)
	{
		//
		// SHAREDPORTS cannot be used with TCP and requires a FIXEDPORTS.
		//
		if ((dwFlags & DPNHREGISTERPORTS_TCP) || (! (dwFlags & DPNHREGISTERPORTS_FIXEDPORTS)))
		{
			DPFX(DPFPREP, 0, "SHAREDPORTS flag requires FIXEDPORTS flag and cannot be used with TCP flag!");
			hr = DPNHERR_INVALIDFLAGS;
			goto Failure;
		}
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}



	//
	// Loop through all existing registered port mappings and look for this
	// array of ports.
	//
	pBilink = this->m_blRegisteredPorts.GetNext();
	while (pBilink != &this->m_blRegisteredPorts)
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

		//
		// Don't bother looking at addresses of the wrong type or at arrays of
		// the wrong size.
		//
		if (((pRegisteredPort->IsTCP() && (dwFlags & DPNHREGISTERPORTS_TCP)) ||
			((! pRegisteredPort->IsTCP()) && (! (dwFlags & DPNHREGISTERPORTS_TCP)))) &&
			(pRegisteredPort->GetNumAddresses() == dwNumAddresses))
		{
			pasaddrinTemp = pRegisteredPort->GetPrivateAddressesArray();
			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				//
				// If the addresses don't match, stop looping.
				//
				if ((pasaddrinTemp[dwTemp].sin_port != ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_port) ||
					(pasaddrinTemp[dwTemp].sin_addr.S_un.S_addr != ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_addr))
				{
					break;
				}
			}


			//
			// If all the addresses matched, then this item was already
			// registered.
			//
			if (dwTemp >= dwNumAddresses)
			{
				DPFX(DPFPREP, 1, "Array of %u addresses was already registered, returning existing mapping 0x%p.",
					dwNumAddresses, pRegisteredPort);
				goto ReturnUserHandle;
			}

			DPFX(DPFPREP, 7, "Existing mapping 0x%p does not match all %u addresses.",
				pRegisteredPort, dwNumAddresses);
		}
		else
		{
			//
			// Existing mapping isn't same type or doesn't have same number of
			// items in array.
			//
		}

		pBilink = pBilink->GetNext();
	}


	//
	// If we're here, none of the existing mappings match.  Loop through each
	// of the ports and make sure they aren't already registered inside some
	// other mapping.
	//
	for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
	{
		pBilink = this->m_blRegisteredPorts.GetNext();
		while (pBilink != &this->m_blRegisteredPorts)
		{
			DNASSERT(! pBilink->IsEmpty());
			pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

			pasaddrinTemp = pRegisteredPort->GetPrivateAddressesArray();
			for(dwMatch = 0; dwMatch < pRegisteredPort->GetNumAddresses(); dwMatch++)
			{
				//
				// If the addresses match, then we can't map these ports.
				//
				if ((pasaddrinTemp[dwMatch].sin_port == ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_port) &&
					(pasaddrinTemp[dwMatch].sin_addr.S_un.S_addr == ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_addr))
				{
					DPFX(DPFPREP, 0, "Existing mapping 0x%p already registered the address %u.%u.%u.%u:%u!",
						pRegisteredPort,
						pasaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b1,
						pasaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b2,
						pasaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b3,
						pasaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b4,
						NTOHS(pasaddrinTemp[dwMatch].sin_port));

					//
					// Clear the pointer so we don't delete the object.
					//
					pRegisteredPort = NULL;

					hr = DPNHERR_PORTALREADYREGISTERED;
					goto Failure;
				}
			}

			pBilink = pBilink->GetNext();
		}
	}


	//
	// If we're here the ports are all unique.  Create a new mapping object
	// we'll use to refer to the binding.
	//
	pRegisteredPort = new CRegisteredPort(dwLeaseTime, dwFlags);
	if (pRegisteredPort == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	hr = pRegisteredPort->SetPrivateAddresses((SOCKADDR_IN*) aLocalAddresses, dwNumAddresses);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't store private addresses array!");
		goto Failure;
	}


	//
	// Find the device that matches the given addresses.
	//
	// The first entry of aLocalAddresses is representative of all entries since
	// they should all share the same address.
	//
	// Since there won't be an existing registered port for this address, don't
	// bother looking through them for a matching address.
	//
	pDevice = this->FindMatchingDevice((SOCKADDR_IN*) (&aLocalAddresses[0]),
										FALSE);
	if (pDevice == NULL)
	{
		DPFX(DPFPREP, 1, "No device for given address (%u.%u.%u.%u), storing 0x%p in unowned list.",
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b4,
			pRegisteredPort);

		pRegisteredPort->m_blDeviceList.InsertBefore(&this->m_blUnownedPorts);
	}
	else
	{
		pRegisteredPort->MakeDeviceOwner(pDevice);


#ifndef DPNBUILD_NOHNETFWAPI
		//
		// Start by mapping with the local firewall, if there is one.
		//
		if (pDevice->IsHNetFirewalled())
		{
			hr = this->CheckForLocalHNetFirewallAndMapPorts(pDevice,
															pRegisteredPort);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't check for local HNet firewall and map ports (err = 0x%lx)!  Continuing.",
					hr);
				DNASSERT(! pDevice->IsHNetFirewalled());
				hr = DPNH_OK;
			}
		}
		else
		{
			//
			// No local HomeNet firewall (last time we checked).
			//
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		//
		// Map the ports on the UPnP device, if there is one.
		//
		pUPnPDevice = pDevice->GetUPnPDevice();
		if (pUPnPDevice != NULL)
		{
			//
			// GetUPnPDevice did not add a reference to pUPnPDevice for us.
			//
			pUPnPDevice->AddRef();


			DNASSERT(pUPnPDevice->IsReady());

			//
			// Actually map the ports.
			//
			hr = this->MapPortsOnUPnPDevice(pUPnPDevice, pRegisteredPort);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't map ports on UPnP device 0x%p (0x%lx)!  Ignoring.",
					pUPnPDevice, hr);

				//
				// It may have been cleared already, but doing it twice
				// shouldn't be harmful.
				//
				this->ClearDevicesUPnPDevice(pRegisteredPort->GetOwningDevice());

				hr = DPNH_OK;
			}

			pUPnPDevice->DecRef();
			pUPnPDevice = NULL;
		}
		else
		{
			//
			// No UPnP device.
			//
		}
	}


	//
	// Save the mapping in the global list (we have the lock).
	//
	pRegisteredPort->m_blGlobalList.InsertBefore(&this->m_blRegisteredPorts);


ReturnUserHandle:

	//
	// Remember that a port has been registered.
	//
	this->m_dwFlags |= NATHELPUPNPOBJ_PORTREGISTERED;

	//
	// We're about to give the port to the user.
	//
	pRegisteredPort->AddUserRef();

	//
	// We're going to give the user a direct pointer to the object (disguised
	// as an opaque DPNHHANDLE, of course).
	//
	(*phRegisteredPorts) = (DPNHHANDLE) pRegisteredPort;


	this->DropLock();
	fHaveLock = FALSE;


	DPFX(DPFPREP, 5, "Returning registered port 0x%p (first private address = %u.%u.%u.%u:%u).",
		pRegisteredPort,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b1,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b2,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b3,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b4,
		NTOHS(((SOCKADDR_IN*) aLocalAddresses)[0].sin_port));


	hr = DPNH_OK;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pUPnPDevice != NULL)
	{
		pUPnPDevice->DecRef();
	}

	if (pRegisteredPort != NULL)
	{
#ifndef DPNBUILD_NOHNETFWAPI
		if (pRegisteredPort->IsMappedOnHNetFirewall())
		{
			HRESULT		temphr;


			//
			// Unmap the port.
			//
			// Don't bother alerting user about address change.  It would have
			// already been taken care of if this was due to a fatal error, and
			// there would be no perceived changed if not.
			//
			temphr = this->UnmapPortOnLocalHNetFirewall(pRegisteredPort, TRUE, FALSE);
			if (temphr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Failed unmapping registered port 0x%p on local HomeNet firewall (err = 0x%lx)!  Ignoring.",
					pRegisteredPort, temphr);

				pRegisteredPort->NoteNotMappedOnHNetFirewall();
				pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
			}
		}
#endif // ! DPNBUILD_NOHNETFWAPI

		if (pDevice != NULL)
		{
			pRegisteredPort->ClearDeviceOwner();
		}

		pRegisteredPort->ClearPrivateAddresses();
		delete pRegisteredPort;
	}

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::RegisterPorts






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetRegisteredAddresses"
//=============================================================================
// CNATHelpUPnP::GetRegisteredAddresses
//-----------------------------------------------------------------------------
//
// Description:    Returns the current public address mappings for a given
//				registered port group.  If there are no servers currently
//				available, then DPNHERR_SERVERNOTAVAILABLE is returned.  If the
//				servers' public interfaces are not currently valid, then
//				DPNHERR_NOMAPPING is returned, but appropriate values will
//				still be placed in pdwAddressTypeFlags and
//				pdwLeaseTimeRemaining.
//
//				   If the mapping was registered with the
//				DPNHREGISTERPORTS_FIXEDPORTS flag, but at least one port is
//				already in use on the gateway, then DPNHERR_PORTUNAVAILABLE is
//				returned and appropriate flags will still be placed in
//				pdwAddressTypeFlags.
//
//				   If the local machine has a cooperative firewall installed,
//				the requested port is opened locally on the firewall before
//				being mapped on the Internet gateway.  Normally this function
//				returns the public address on the Internet gateway address when
//				both are present.  Since some firewalls remap the port number
//				when opening non-fixed ports, the
//				DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY allows the
//				caller to retrieve the locally remapped address, even if there
//				is a mapping on an Internet gateway.
//
//				   Some gateway devices do not natively support ports that are
//				not fixed, and may generate the DPNHERR_PORTUNAVAILABLE return
//				code even when the DPNHREGISTERPORTS_FIXEDPORTS flag was not
//				specified.  The caller should de-register the port mapping
//				handle, rebind the application to different ports, and call
//				RegisterPorts again.
//
//				   If the buffer indicated by paPublicAddresses is too small,
//				then the size required is returned in pdwPublicAddressesSize
//				and DPNHERR_BUFFERTOOSMALL is returned.  Otherwise the number of
//				bytes written is returned in pdwPublicAddressesSize.
//
//				   Even though the addresses are returned as individual
//				SOCKADDRs, all ports registered at the same time will share the
//				same public address.  Only the port components will vary.
//
//				   All buffers are optional and may be NULL, but if
//				paPublicAddresses is specified, it must be accompanied by an
//				appropriate size in pdwPublicAddressesSize.
//
//				   If GetCaps has not been previously called with the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag at least once, then the
//				error code DPNHERR_UPDATESERVERSTATUS is returned.
//
// Arguments:
//	DPNHHANDLE hRegisteredPorts		- Handle for a specific binding returned by
//										RegisterPorts.
//	SOCKADDR * paPublicAddresses	- Buffer to return assigned public realm
//										address, or NULL if not desired.
//	DWORD * pdwPublicAddressesSize	- Pointer to size of paPublicAddresses
//										buffer, or place to store size
//										required/written.  Cannot be NULL if
//										paPublicAddresses is not NULL.
//	DWORD * pdwAddressTypeFlags		- Place to store flags describing the
//										address types returned, or NULL if not
//										desired.
//	DWORD * pdwLeaseTimeRemaining	- Place to store approximate number of
//										milliseconds remaining in the port
//										lease, or NULL if not desired.  Call
//										GetCaps to automatically extend leases
//										about to expire.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK						- Information on the port mapping was found and
//									the addresses were stored in
//									paPublicAddresses.
//	DPNHERR_BUFFERTOOSMALL		- There was not enough room in the buffer to
//									store the addresses. 
//	DPNHERR_GENERIC				- An error occurred while retrieving the
//									requested port mapping.
//	DPNHERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT		- The interface object is invalid.
//	DPNHERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER		- An invalid pointer was specified.
//	DPNHERR_NOMAPPING			- The server(s) do not have valid public
//									interfaces.
//	DPNHERR_NOTINITIALIZED		- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY			- There is not enough memory to get the
//									addresses.
//	DPNHERR_PORTUNAVAILABLE		- At least one of the ports is not available on
//									the server.
//	DPNHERR_REENTRANT			- The interface has been re-entered on the same
//									thread.
//	DPNHERR_SERVERNOTAVAILABLE	- No servers are currently present.
//	DPNHERR_UPDATESERVERSTATUS	- GetCaps has not been called with the
//									DPNHGETCAPS_UPDATESERVERSTATUS flag yet.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::GetRegisteredAddresses(const DPNHHANDLE hRegisteredPorts,
												SOCKADDR * const paPublicAddresses,
												DWORD * const pdwPublicAddressesSize,
												DWORD * const pdwAddressTypeFlags,
												DWORD * const pdwLeaseTimeRemaining,
												const DWORD dwFlags)
{
	HRESULT				hr;
	CRegisteredPort *	pRegisteredPort;
	BOOL				fHaveLock = FALSE;
	BOOL				fRegisteredWithServer = FALSE;
	BOOL				fFoundValidMapping = FALSE;
	BOOL				fPortIsUnavailable = FALSE;
	DWORD				dwSizeRequired;
	DWORD				dwAddressTypeFlags;
	DWORD				dwCurrentTime;
	//DWORD				dwTempLeaseTimeRemaining;
	DWORD				dwLeaseTimeRemaining = -1;
	CDevice *			pDevice;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, 0x%p, 0x%p, 0x%lx)",
		this, hRegisteredPorts, paPublicAddresses, pdwPublicAddressesSize,
		pdwAddressTypeFlags, pdwLeaseTimeRemaining, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	pRegisteredPort = (CRegisteredPort*) hRegisteredPorts;
	if (! pRegisteredPort->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid registered port mapping handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (paPublicAddresses != NULL)
	{
		if ((pdwPublicAddressesSize == NULL) ||
			(IsBadWritePtr(pdwPublicAddressesSize, sizeof(DWORD))))
		{
			DPFX(DPFPREP, 0, "When specifying a public addresses buffer, a valid size must be given!");
			hr = DPNHERR_INVALIDPOINTER;
			goto Failure;
		}

		if (IsBadWritePtr(paPublicAddresses, (*pdwPublicAddressesSize)))
		{
			DPFX(DPFPREP, 0, "The public addresses buffer is invalid!");
			hr = DPNHERR_INVALIDPOINTER;
			goto Failure;
		}
	}
	else
	{
		if ((pdwPublicAddressesSize != NULL) &&
			(IsBadWritePtr(pdwPublicAddressesSize, sizeof(DWORD))))
		{
			DPFX(DPFPREP, 0, "Invalid pointer for size of public addresses buffer!");
			hr = DPNHERR_INVALIDPOINTER;
			goto Failure;
		}
	}

	if ((pdwAddressTypeFlags != NULL) &&
		(IsBadWritePtr(pdwAddressTypeFlags, sizeof(DWORD))))
	{
		DPFX(DPFPREP, 0, "Invalid pointer for address type flags!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if ((pdwLeaseTimeRemaining != NULL) &&
		(IsBadWritePtr(pdwLeaseTimeRemaining, sizeof(DWORD))))
	{
		DPFX(DPFPREP, 0, "Invalid pointer for lease time remaining!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwFlags & ~DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}



	//
	// Start the flags off with the information regarding TCP vs. UDP.
	//
	if (pRegisteredPort->IsTCP())
	{
		dwAddressTypeFlags = DPNHADDRESSTYPE_TCP;
	}
	else
	{
		dwAddressTypeFlags = 0;
	}


	//
	// Add in other flags we know already.
	//

	if (pRegisteredPort->IsFixedPort())
	{
		dwAddressTypeFlags |= DPNHADDRESSTYPE_FIXEDPORTS;
	}

	if (pRegisteredPort->IsSharedPort())
	{
		dwAddressTypeFlags |= DPNHADDRESSTYPE_SHAREDPORTS;
	}




	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwLastUpdateServerStatusTime == 0)
	{
		DPFX(DPFPREP, 0, "GetCaps has not been called with UPDATESERVERSTATUS flag yet!");
		hr = DPNHERR_UPDATESERVERSTATUS;
		goto Failure;
	}


	//
	// Get a shortcut pointer to the device (may not exist).
	//
	pDevice = pRegisteredPort->GetOwningDevice();


	//
	// Get the current time for both the remote and local lease
	// calculations.
	//
	dwCurrentTime = GETTIMESTAMP();


	if (! (dwFlags & DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY))
	{
		CUPnPDevice *	pUPnPDevice;


		//
		// First check for a mapping on the UPnP device.
		//
		if (pRegisteredPort->HasUPnPPublicAddresses())
		{
			DNASSERT(pDevice != NULL);

			pUPnPDevice = pDevice->GetUPnPDevice();
			DNASSERT(pUPnPDevice != NULL);

			fRegisteredWithServer = TRUE;

			//
			// Make sure the UPnP device currently has a valid external
			// address.  If so, hand the mapping out.
			//
			if (pUPnPDevice->GetExternalIPAddressV4() != 0)
			{
				if (pdwPublicAddressesSize != NULL)
				{
					dwSizeRequired = pRegisteredPort->GetAddressesSize();

					if ((paPublicAddresses == NULL) ||
						(dwSizeRequired > (*pdwPublicAddressesSize)))
					{
						//
						// Not enough room in buffer, return the size required
						// and the BUFFERTOOSMALL error code.
						//
						(*pdwPublicAddressesSize) = dwSizeRequired;
						hr = DPNHERR_BUFFERTOOSMALL;
					}
					else
					{
						//
						// Buffer was large enough, return the size written.
						//
						(*pdwPublicAddressesSize) = dwSizeRequired;
						pRegisteredPort->CopyUPnPPublicAddresses((SOCKADDR_IN*) paPublicAddresses);
					}
				}
				else
				{
					//
					// Not using address buffer.
					//
				}

				fFoundValidMapping = TRUE;
			}
			else
			{
				DPFX(DPFPREP, 8, "The UPnP Internet Gateway Device does not currently have a valid public address.");
			}

			//
			// Add in the flag indicating that there's a UPnP device.
			//
			dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAY;

			//
			// See if the UPnP device is local.
			//
			if (pUPnPDevice->IsLocal())
			{
				dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAYISLOCAL;
			}

			//
			// Get the relative UPnP lease time remaining, if it's not
			// permanent.
			//
			if (! pRegisteredPort->HasPermanentUPnPLease())
			{
				dwLeaseTimeRemaining = pRegisteredPort->GetUPnPLeaseExpiration() - dwCurrentTime;

				if (((int) dwLeaseTimeRemaining) < 0)
				{
					DPFX(DPFPREP, 1, "Registered port mapping's UPnP lease has already expired, returning 0 for lease time remaining.");
					dwLeaseTimeRemaining = 0;
				}
			}
		}
		else if (pRegisteredPort->IsUPnPPortUnavailable())
		{
			DNASSERT(pDevice != NULL);

			pUPnPDevice = pDevice->GetUPnPDevice();
			DNASSERT(pUPnPDevice != NULL);

			fRegisteredWithServer = TRUE;
			fPortIsUnavailable = TRUE;

			DPFX(DPFPREP, 8, "The UPnP device indicates the port(s) are unavailable.");

			//
			// Add in the flag indicating that there's a UPnP device.
			//
			dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAY;

			//
			// See if the UPnP device is local.
			//
			if (pUPnPDevice->IsLocal())
			{
				dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAYISLOCAL;
			}
		}
	}
	else
	{
		//
		// We're not allowed to return the UPnP mapping.
		//
		DPFX(DPFPREP, 8, "Ignoring any Internet gateway mappings, LOCALFIREWALLREMAPONLY was specified.");
	}


#ifndef DPNBUILD_NOHNETFWAPI
	//
	// Finally, check for a mapping on a local firewall.
	//
	if (pRegisteredPort->IsMappedOnHNetFirewall())
	{
		DNASSERT(pDevice != NULL);
		DNASSERT(pDevice->IsHNetFirewalled());


		fRegisteredWithServer = TRUE;


		//
		// If we didn't already get a remote mapping, return this local one.
		//
		if (! fFoundValidMapping)
		{
			if (pdwPublicAddressesSize != NULL)
			{
				dwSizeRequired = pRegisteredPort->GetAddressesSize();

				if ((paPublicAddresses == NULL) ||
					(dwSizeRequired > (*pdwPublicAddressesSize)))
				{
					//
					// Not enough room in buffer, return the size required
					// and the BUFFERTOOSMALL error code.
					//
					(*pdwPublicAddressesSize) = dwSizeRequired;
					hr = DPNHERR_BUFFERTOOSMALL;
				}
				else
				{
					SOCKADDR_IN *	pasaddrinPrivate;
					DWORD			dwTemp;


					//
					// Buffer was large enough, return the size written.
					//
					(*pdwPublicAddressesSize) = dwSizeRequired;

					//
					// Note that the addresses mapped on the firewall are the
					// same as the private addresses.
					//
					pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

					DNASSERT(pasaddrinPrivate != NULL);

					memcpy(paPublicAddresses, pasaddrinPrivate, dwSizeRequired);


					//
					// However, we don't want to ever return 0.0.0.0, so make
					// sure they get the device address.
					//
					if (pasaddrinPrivate[0].sin_addr.S_un.S_addr == INADDR_ANY)
					{
						for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
						{
							((SOCKADDR_IN*) paPublicAddresses)[dwTemp].sin_addr.S_un.S_addr = pDevice->GetLocalAddressV4();
						}

						DPFX(DPFPREP, 7, "Returning device address %u.%u.%u.%u instead of INADDR_ANY for firewalled port mapping 0x%p.",
							((SOCKADDR_IN*) paPublicAddresses)[0].sin_addr.S_un.S_un_b.s_b1,
							((SOCKADDR_IN*) paPublicAddresses)[0].sin_addr.S_un.S_un_b.s_b2,
							((SOCKADDR_IN*) paPublicAddresses)[0].sin_addr.S_un.S_un_b.s_b3,
							((SOCKADDR_IN*) paPublicAddresses)[0].sin_addr.S_un.S_un_b.s_b4,
							pRegisteredPort);
					}
				}
			}
			else
			{
				//
				// Not using address buffer.
				//
			}

			fFoundValidMapping = TRUE;
		}
		else
		{
			DPFX(DPFPREP, 6, "Ignoring local HomeNet firewall mapping due to UPnP mapping.");
		}


		//
		// Add in the flag indicating the local firewall.
		//
		dwAddressTypeFlags |= DPNHADDRESSTYPE_LOCALFIREWALL;


		//
		// The firewall API does not allow for lease times.
		//
	}
	else
	{
		if (pRegisteredPort->IsHNetFirewallPortUnavailable())
		{
			DNASSERT(pDevice != NULL);
			DNASSERT(pDevice->IsHNetFirewalled());


			fRegisteredWithServer = TRUE;
			fPortIsUnavailable = TRUE;

			DPFX(DPFPREP, 8, "The local HomeNet firewall indicates the port(s) are unavailable.");


			//
			// Add in the flag indicating the local firewall.
			//
			dwAddressTypeFlags |= DPNHADDRESSTYPE_LOCALFIREWALL;
		}
#ifdef DBG
		else
		{
			//
			// No local firewall or it's an unowned port.
			//
			if (pDevice != NULL)
			{
				DNASSERT(! pDevice->IsHNetFirewalled());
			}
			else
			{
				DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
			}
		}
#endif // DBG
	}
#endif // ! DPNBUILD_NOHNETFWAPI
	

	this->DropLock();
	fHaveLock = FALSE;


	if (fRegisteredWithServer)
	{
		DNASSERT(dwAddressTypeFlags & (DPNHADDRESSTYPE_LOCALFIREWALL | DPNHADDRESSTYPE_GATEWAY));


		if (! fFoundValidMapping)
		{
			if (fPortIsUnavailable)
			{
				//
				// The servers indicated that the ports were already in use.
				// Return PORTUNAVAILABLE.
				//
				DPFX(DPFPREP, 1, "The Internet gateway(s) could not map the port, returning PORTUNAVAILABLE.");
				hr = DPNHERR_PORTUNAVAILABLE;
			}
			else
			{
				//
				// The servers didn't have public addresses.  Return NOMAPPING.
				//
				DPFX(DPFPREP, 1, "The Internet gateway(s) did not offer valid public addresses, returning NOMAPPING.");
				hr = DPNHERR_NOMAPPING;
			}
		}
		else
		{
			//
			// One of the servers had a public address.
			//
			DNASSERT((hr == DPNH_OK) || (hr == DPNHERR_BUFFERTOOSMALL));
		}
	}
	else
	{
		//
		// The ports aren't registered, because there aren't any gateways.
		// Return SERVERNOTAVAILABLE.
		//
		DPFX(DPFPREP, 1, "No Internet gateways, returning SERVERNOTAVAILABLE.");
		hr = DPNHERR_SERVERNOTAVAILABLE;
	}


	//
	// If the caller wants information on the type of these addresses, return
	// the flags we detected.
	//
	if (pdwAddressTypeFlags != NULL)
	{
		(*pdwAddressTypeFlags) = dwAddressTypeFlags;
	}


	//
	// Return the minimum lease time remaining that we already calculated, if
	// the caller wants it.
	//
	if (pdwLeaseTimeRemaining != NULL)
	{
		(*pdwLeaseTimeRemaining) = dwLeaseTimeRemaining;
	}


#ifdef DBG
	//
	// If the port is unavailable or there aren't any servers, we better not
	// have a lease time.
	//
	if ((hr == DPNHERR_PORTUNAVAILABLE) ||
		(hr == DPNHERR_SERVERNOTAVAILABLE))
	{
		DNASSERT(dwLeaseTimeRemaining == -1);
	}


	//
	// If there aren't any servers, we better not have server flags.
	//
	if (hr == DPNHERR_SERVERNOTAVAILABLE)
	{
		DNASSERT(! (dwAddressTypeFlags & (DPNHADDRESSTYPE_LOCALFIREWALL | DPNHADDRESSTYPE_GATEWAY)));
	}
#endif // DBG


	DPFX(DPFPREP, 5, "Registered port 0x%p addr type flags = 0x%lx, lease time remaining = %i.",
		pRegisteredPort, dwAddressTypeFlags, (int) dwLeaseTimeRemaining);


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::GetRegisteredAddresses





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::DeregisterPorts"
//=============================================================================
// CNATHelpUPnP::DeregisterPorts
//-----------------------------------------------------------------------------
//
// Description:    Removes the lease record for the port group and informs the
//				Internet gateway server that the binding is no longer needed.
//				The port mapping handle must not be used after de-registering
//				it.
//
// Arguments:
//	DPNHHANDLE hRegisteredPorts		- Handle for a specific binding returned by
//										RegisterPorts.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The binding was successfully released.
//	DPNHERR_GENERIC			- An error occurred that prevented the
//								de-registration of the ports.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory to de-register.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::DeregisterPorts(const DPNHHANDLE hRegisteredPorts,
											const DWORD dwFlags)
{
	HRESULT				hr;
	CRegisteredPort *	pRegisteredPort;
	BOOL				fHaveLock = FALSE;
	LONG				lResult;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx)",
		this, hRegisteredPorts, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	pRegisteredPort = (CRegisteredPort*) hRegisteredPorts;
	if (! pRegisteredPort->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid registered port mapping handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// If this isn't the last user reference on the registered port, don't
	// unmap it yet.
	//
	lResult = pRegisteredPort->DecUserRef();
	if (lResult != 0)
	{
		DPFX(DPFPREP, 1, "Still %i references left on registered port 0x%p, not unmapping.",
			lResult, pRegisteredPort);
		goto Exit;
	}


	//
	// First unmap from UPnP device, if necessary.
	//
	if (pRegisteredPort->HasUPnPPublicAddresses())
	{
		hr = this->UnmapUPnPPort(pRegisteredPort,
								pRegisteredPort->GetNumAddresses(),	// free all ports
								TRUE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't delete port mapping with UPnP device (0x%lx)!  Ignoring.", hr);

			//
			// We'll treat this as non-fatal, but we have to dump the device.
			//
			this->ClearDevicesUPnPDevice(pRegisteredPort->GetOwningDevice());
			hr = DPNH_OK;
		}
	}


#ifndef DPNBUILD_NOHNETFWAPI
	//
	// Then unmap from the local firewall, if necessary.
	//
	if (pRegisteredPort->IsMappedOnHNetFirewall())
	{
		//
		// Unmap the port.
		//
		// Don't bother alerting user about address change, this is normal
		// operation.
		//
		hr = this->UnmapPortOnLocalHNetFirewall(pRegisteredPort, TRUE, FALSE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed unmapping registered port 0x%p on local HomeNet firewall (err = 0x%lx)!  Ignoring.",
				pRegisteredPort, hr);

			pRegisteredPort->NoteNotMappedOnHNetFirewall();
			pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

			hr = DPNH_OK;
		}
	}
#endif // ! DPNBUILD_NOHNETFWAPI


	//
	// Pull the item out of the lists.
	// We have the appropriate lock.
	//

	DNASSERT(pRegisteredPort->m_blGlobalList.IsListMember(&this->m_blRegisteredPorts));
	pRegisteredPort->m_blGlobalList.RemoveFromList();

	if (pRegisteredPort->GetOwningDevice() != NULL)
	{
		DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&((pRegisteredPort->GetOwningDevice())->m_blOwnedRegPorts)));
		pRegisteredPort->ClearDeviceOwner();
	}
	else
	{
		DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
		pRegisteredPort->m_blDeviceList.RemoveFromList();
	}

	pRegisteredPort->ClearPrivateAddresses();
	delete pRegisteredPort;


Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::DeregisterPorts





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::QueryAddress"
//=============================================================================
// CNATHelpUPnP::QueryAddress
//-----------------------------------------------------------------------------
//
// Description:    Some Internet gateways do not loopback if an attempt is made
//				to connect to an address behind (on the same private side of)
//				the public interface.  QueryAddress is used to determine a
//				possible private alias for a given public address.
//
//				   In most cases, this function is called prior to connecting
//				to a new address.  pSourceAddress should contain the address of
//				the socket that will perform the connect.  Similar to
//				RegisterPorts, the address may be INADDR_ANY, in which case the
//				"best" server will be used.  Since the server chosen may not be
//				optimal for a particular application, it is recommended that a
//				specific network interface be used instead of INADDR_ANY, when
//				possible.
//
//				   If no mapping for that address has been made by the gateway,
//				the error code DPNHERR_NOMAPPING is returned.  When the
//				DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED flag is used, an
//				extra effort is made to determine whether the address is behind
//				the same Internet gateway without being mapped on the gateway.
//				If that is the case, DPNHERR_NOMAPPINGBUTPRIVATE is returned.
//				DPNHERR_NOMAPPING is still returned for addresses that are
//				neither mapped nor private.
//
//				   pQueryAddress may not be INADDR_ANY or INADDR_BROADCAST.
//				The port component may be zero if and only if the
//				DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED flag is used.  If
//				the port is zero, a specific mapping cannot be verified, and
//				only the DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED aspect of
//				the address is tested.
//
//				   The resulting address (or lack thereof) can be cached for
//				quick future retrieval using the DPNHQUERYADDRESS_CACHEFOUND
//				and DPNHQUERYADDRESS_CACHENOTFOUND flags.  The cached mappings
//				will expire in 1 minute, or whenever the server's address
//				changes.
//
//				   If the given source address is not currently connected to an
//				Internet gateway, then the error DPNHERR_SERVERNOTAVAILABLE is
//				returned.
//
//				   If GetCaps has not been previously called with the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag at least once, then the
//				error code DPNHERR_UPDATESERVERSTATUS is returned.
//
// Arguments:
//	SOCKADDR * pSourceAddress	- Address for network interface that is using
//									the address in question.
//	SOCKADDR * pQueryAddress	- Address to look up.
//	SOCKADDR * pResponseAddress	- Place to store public address, if one exists.
//	int iAddressesSize			- Size of the SOCKADDR structure used for the
//									pSourceAddress, pQueryAddress and
//									pResponseAddress buffers.
//	DWORD dwFlags				- Flags to use when querying
//									(DPNHQUERYADDRESS_xxx).
//
// Returns: HRESULT
//	DPNH_OK						- The address was found and its mapping was
//									stored in pResponseAddress.
//	DPNHERR_GENERIC				- An error occurred that prevented mapping the
//									requested address.
//	DPNHERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT		- The interface object is invalid.
//	DPNHERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER		- An invalid pointer was specified.
//	DPNHERR_NOMAPPING			- The server indicated that no mapping for the
//									requested address was found.
//	DPNHERR_NOMAPPINGBUTPRIVATE	- The server indicated that no mapping was
//									found, but it is a private address.
//	DPNHERR_NOTINITIALIZED		- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY			- There is not enough memory to query.
//	DPNHERR_REENTRANT			- The interface has been re-entered on the same
//									thread.
//	DPNHERR_SERVERNOTAVAILABLE	- There are no servers to query.
//	DPNHERR_UPDATESERVERSTATUS	- GetCaps has not been called with the
//									DPNHGETCAPS_UPDATESERVERSTATUS flag yet.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::QueryAddress(const SOCKADDR * const pSourceAddress,
										const SOCKADDR * const pQueryAddress,
										SOCKADDR * const pResponseAddress,
										const int iAddressesSize,
										const DWORD dwFlags)
{
	HRESULT			hr;
	BOOL			fHaveLock = FALSE;
	CDevice *		pDevice;
	SOCKADDR_IN *	psaddrinNextServerQueryAddress = NULL;
	CUPnPDevice *	pUPnPDevice = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, %i, 0x%lx)",
		this, pSourceAddress, pQueryAddress, pResponseAddress, iAddressesSize,
		dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (pSourceAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid source address specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pQueryAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid query address specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pResponseAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid response address specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (iAddressesSize < sizeof(SOCKADDR_IN))
	{
		DPFX(DPFPREP, 0, "The address buffers must be at least %i bytes!",
			sizeof(SOCKADDR_IN));
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (IsBadReadPtr(pSourceAddress, sizeof(SOCKADDR_IN)))
	{
		DPFX(DPFPREP, 0, "Invalid source address buffer used!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (IsBadReadPtr(pQueryAddress, sizeof(SOCKADDR_IN)))
	{
		DPFX(DPFPREP, 0, "Invalid query address buffer used!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (IsBadWritePtr(pResponseAddress, sizeof(SOCKADDR_IN)))
	{
		DPFX(DPFPREP, 0, "Invalid response address buffer used!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if ((((SOCKADDR_IN*) pSourceAddress)->sin_family != AF_INET) ||
		(((SOCKADDR_IN*) pQueryAddress)->sin_family != AF_INET))
	{
		DPFX(DPFPREP, 0, "Source or query address is not AF_INET, only IPv4 addresses are supported!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_addr == INADDR_BROADCAST)
	{
		DPFX(DPFPREP, 0, "Source address cannot be broadcast address!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if ((((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_addr == INADDR_ANY) ||
		(((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_addr == INADDR_BROADCAST))
	{
		//
		// Don't use inet_ntoa because we may not be initialized yet.
		//
		DPFX(DPFPREP, 0, "Query address (%u.%u.%u.%u) is invalid, cannot be zero or broadcast!",
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b4);
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags & ~(DPNHQUERYADDRESS_TCP | DPNHQUERYADDRESS_CACHEFOUND | DPNHQUERYADDRESS_CACHENOTFOUND | DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED))
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}

	if ((((SOCKADDR_IN*) pQueryAddress)->sin_port == 0) &&
		(! (dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED)))
	{
		DPFX(DPFPREP, 0, "Query address port cannot be zero unless CHECKFORPRIVATEBUTUNMAPPED is specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwLastUpdateServerStatusTime == 0)
	{
		DPFX(DPFPREP, 0, "GetCaps has not been called with UPDATESERVERSTATUS flag yet!");
		hr = DPNHERR_UPDATESERVERSTATUS;
		goto Failure;
	}


	pDevice = this->FindMatchingDevice((SOCKADDR_IN*) pSourceAddress, TRUE);
	if (pDevice == NULL)
	{
		DPFX(DPFPREP, 1, "Couldn't determine owning device for source %u.%u.%u.%u, returning SERVERNOTAVAILABLE for query %u.%u.%u.%u:%u.",
			((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_un_b.s_b4,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b4,
			NTOHS(((SOCKADDR_IN*) pQueryAddress)->sin_port));
		hr = DPNHERR_SERVERNOTAVAILABLE;
		goto Exit;
	}



	//
	// Assume no servers are available.  This will get overridden as
	// appropriate.
	//
	hr = DPNHERR_SERVERNOTAVAILABLE;


	//
	// Start by querying the address passed in.
	//
	psaddrinNextServerQueryAddress = (SOCKADDR_IN*) pQueryAddress;


	//
	// If the port is zero, then we can't actually lookup a mapping.  Just do
	// the address locality check.
	//
	if (psaddrinNextServerQueryAddress->sin_port == 0)
	{
		//
		// We should have caught this in parameter validation above, but I'm
		// being paranoid.
		//
		DNASSERT(dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED);


		//
		// We don't cache these results, since there's no server (and thus, no
		// network traffic) associated with it.  No need to look anything up.
		//


		//
		// If there aren't any Internet gateways, then no need to check.
		//
#ifdef DPNBUILD_NOHNETFWAPI
		if (pDevice->GetUPnPDevice() == NULL)
#else // ! DPNBUILD_NOHNETFWAPI
		if ((pDevice->GetUPnPDevice() == NULL) &&
			(! pDevice->IsHNetFirewalled()))
#endif // ! DPNBUILD_NOHNETFWAPI
		{
			DPFX(DPFPREP, 5, "No port queried and there aren't any gateways, returning SERVERNOTAVAILABLE.");
			hr = DPNHERR_SERVERNOTAVAILABLE;
		}
		else
		{
			//
			// There is an Internet gateway of some kind, our locality check
			// would be meaningful.
			//
			if (this->IsAddressLocal(pDevice, psaddrinNextServerQueryAddress))
			{
				DPFX(DPFPREP, 5, "No port queried, but address appears to be local, returning NOMAPPINGBUTPRIVATE.");
				hr = DPNHERR_NOMAPPINGBUTPRIVATE;
			}
			else
			{
				DPFX(DPFPREP, 5, "No port queried and address does not appear to be local, returning NOMAPPING.");
				hr = DPNHERR_NOMAPPING;
			}
		}


		//
		// We've done all we can do.
		//
		goto Exit;
	}


	//
	// Query the UPnP gateway, if there is one.
	//
	pUPnPDevice = pDevice->GetUPnPDevice();
	if (pUPnPDevice != NULL)
	{
		//
		// GetUPnPDevice did not add a reference to pUPnPDevice for us.
		//
		pUPnPDevice->AddRef();


		DNASSERT(pUPnPDevice->IsReady());


		//
		// Actually query the device.
		//
		hr = this->InternalUPnPQueryAddress(pUPnPDevice,
											psaddrinNextServerQueryAddress,
											(SOCKADDR_IN*) pResponseAddress,
											dwFlags);
		switch (hr)
		{
			case DPNH_OK:
			{
				//
				// There was a mapping.
				//
				//psaddrinNextServerQueryAddress = (SOCKADDR_IN*) pResponseAddress;
				break;
			}

			case DPNHERR_NOMAPPING:
			{
				//
				// There's no mapping.
				//
				break;
			}

			case DPNHERR_NOMAPPINGBUTPRIVATE:
			{
				//
				// There's no mapping although the address is private.
				//
				break;
			}

			case DPNHERR_SERVERNOTRESPONDING:
			{
				//
				// The device stopped responding, so we should get rid of it.
				//

				DPFX(DPFPREP, 1, "UPnP device stopped responding while querying port mapping, removing it.");

				this->ClearDevicesUPnPDevice(pDevice);


				//
				// We also set the return code back to SERVERNOTAVAILABLE.
				//
				hr = DPNHERR_SERVERNOTAVAILABLE;

				//
				// Continue through to querying the HomeNet firewall.
				//
				break;
			}

			default:
			{
				DPFX(DPFPREP, 0, "Querying UPnP device for port mapping failed!");
				goto Failure;
				break;
			}
		}

		pUPnPDevice->DecRef();
		pUPnPDevice = NULL;
	}
	else
	{
		//
		// No UPnP device.
		//
	}


#ifndef DPNBUILD_NOHNETFWAPI
	//
	// If there's a HomeNet firewall and we didn't already get a UPnP result,
	// take the easy way out and return NOMAPPING instead of going through the
	// trouble of looking up the mapping and returning success only if it maps
	// to a local address.
	//
	// Note: we may want to look it up, but right now I'm not seeing any
	// benefit to implementing that code.
	//
	if ((pDevice->IsHNetFirewalled()) && (hr == DPNHERR_SERVERNOTAVAILABLE))
	{
		DPFX(DPFPREP, 7, "Device is HomeNet firewalled, and no UPnP result obtained, returning NOMAPPING.");
		hr = DPNHERR_NOMAPPING;
	}
#endif // ! DPNBUILD_NOHNETFWAPI


	//
	// If we got here with hr still set to SERVERNOTAVAILABLE, that means
	// there weren't any servers.  The error code is appropriate, leave it
	// alone.
	//
#ifdef DBG
	if (hr == DPNHERR_SERVERNOTAVAILABLE)
	{
		DPFX(DPFPREP, 1, "No Internet gateways, unable to query port mapping.");
	}
#endif // DBG
	



Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pUPnPDevice != NULL)
	{
		pUPnPDevice->DecRef();
	}

	goto Exit;
} // CNATHelpUPnP::QueryAddress





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SetAlertEvent"
//=============================================================================
// CNATHelpUPnP::SetAlertEvent
//-----------------------------------------------------------------------------
//
// Description:    This function allows the user to specify an event that will
//				be set when some maintenance needs to be performed.  The user
//				should call GetCaps using the DPNHGETCAPS_UPDATESERVERSTATUS
//				flag when the event is signalled.
//
//				   This function is not available on Windows 95 without WinSock
//				2, may only be called once, and cannot be used after
//				SetAlertIOCompletionPort is called.
//
//					Note that the event is used in addition to the regular
//				polling of GetCaps, it simply allows the polling to be less
//				frequent.
//
// Arguments:
//	HANDLE hEvent	- Handle to event to signal when GetCaps is to be called.
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The event was successfully registered.
//	DPNHERR_GENERIC			- An error occurred that prevented registering the
//								event.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::SetAlertEvent(const HANDLE hEvent,
										const DWORD dwFlags)
{
#ifdef DPNBUILD_NOWINSOCK2
	DPFX(DPFPREP, 0, "Cannot set alert event (0x%p)!", hEvent);
	return E_NOTIMPL;
#else // ! DPNBUILD_NOWINSOCK2
	HRESULT		hr;
	BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx)", this, hEvent, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (hEvent == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid event handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1)
	{
		DPFX(DPFPREP, 0, "Cannot use alert mechanism on WinSock 1!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if ((this->m_hAlertEvent != NULL) || (this->m_hAlertIOCompletionPort != NULL))
	{
		DPFX(DPFPREP, 0, "An alert event or I/O completion port has already been set!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Now save the event handle.
	//
	if (! DuplicateHandle(GetCurrentProcess(),
						hEvent,
						GetCurrentProcess(),
						&this->m_hAlertEvent,
						0,
						FALSE,
						DUPLICATE_SAME_ACCESS))
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't duplicate event (error = %u)!", dwError);
#endif // DBG

		DNASSERT(this->m_hAlertEvent == NULL);

		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}


	//
	// Create overlapped structure.  Don't allocate it through DNMalloc,
	// because we may have to leak it on purpose.  We don't want those memory
	// allocation asserts firing in that case.
	//
	this->m_polAddressListChange = (WSAOVERLAPPED*) HeapAlloc(GetProcessHeap(),
															HEAP_ZERO_MEMORY,
															sizeof(WSAOVERLAPPED));
	if (this->m_polAddressListChange == NULL)
	{
		//
		// Close the alert handle we set.
		//
		CloseHandle(this->m_hAlertEvent);
		this->m_hAlertEvent = NULL;

		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Save the event in the address list change overlapped structure.
	//
	this->m_polAddressListChange->hEvent = this->m_hAlertEvent;


	//
	// Start getting notified of local address changes.
	//
	hr = this->RequestLocalAddressListChangeNotification();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");

		//
		// Free the memory we allocated.
		//
		HeapFree(GetProcessHeap(), 0, this->m_polAddressListChange);
		this->m_polAddressListChange = NULL;

		//
		// Close the alert handle we set.
		//
		CloseHandle(this->m_hAlertEvent);
		this->m_hAlertEvent = NULL;

		goto Failure;
	}


Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
#endif // ! DPNBUILD_NOWINSOCK2
} // CNATHelpUPnP::SetAlertEvent






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SetAlertIOCompletionPort"
//=============================================================================
// CNATHelpUPnP::SetAlertIOCompletionPort
//-----------------------------------------------------------------------------
//
// Description:    This function allows the user to specify an I/O completion
//				port that will receive notification when some maintenance needs
//				to be performed.  The user should call GetCaps using the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag when the packet with the
//				given completion key is dequeued.
//
//				   This function is only available on Windows NT, may only be
//				called once, and cannot be used after SetAlertEvent is called.
//
//					Note that the completion port is used in addition to the
//				regular polling of GetCaps, it simply allows the polling to be
//				less frequent.
//
// Arguments:
//	HANDLE hIOCompletionPort		- Handle to I/O completion port which will
//										be used to signal when GetCaps is to be
//										called.
//	DWORD dwCompletionKey			- Key to use when indicating I/O
//										completion.
//	DWORD dwNumConcurrentThreads	- Number of concurrent threads allowed to
//										process, or zero for default.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The I/O completion port was successfully
//								registered.
//	DPNHERR_GENERIC			- An error occurred that prevented registering the
//								I/O completion port.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::SetAlertIOCompletionPort(const HANDLE hIOCompletionPort,
													const DWORD dwCompletionKey,
													const DWORD dwNumConcurrentThreads,
													const DWORD dwFlags)
{
#ifdef DPNBUILD_NOWINSOCK2
	DPFX(DPFPREP, 0, "Cannot set alert I/O completion port (0x%p, %u, %u)!",
		hIOCompletionPort, dwCompletionKey, dwNumConcurrentThreads);
	return E_NOTIMPL;
#else // ! DPNBUILD_NOWINSOCK2
	HRESULT		hr;
	BOOL		fHaveLock = FALSE;
	HANDLE		hIOCompletionPortResult;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx, %u, 0x%lx)",
		this, hIOCompletionPort, dwCompletionKey, dwNumConcurrentThreads, dwFlags);



	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (hIOCompletionPort == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid I/O completion port handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1)
	{
		DPFX(DPFPREP, 0, "Cannot use alert mechanism on WinSock 1!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if ((this->m_hAlertEvent != NULL) || (this->m_hAlertIOCompletionPort != NULL))
	{
		DPFX(DPFPREP, 0, "An alert event or I/O completion port has already been set!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Now save the I/O completion port handle.
	//
	if (! DuplicateHandle(GetCurrentProcess(),
						hIOCompletionPort,
						GetCurrentProcess(),
						&this->m_hAlertIOCompletionPort,
						0,
						FALSE,
						DUPLICATE_SAME_ACCESS))
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't duplicate I/O completion port (error = %u)!", dwError);
#endif // DBG

		DNASSERT(this->m_hAlertIOCompletionPort == NULL);

		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	this->m_dwAlertCompletionKey = dwCompletionKey;


	//
	// Associate our Ioctl socket with this IO completion port.
	//
	DNASSERT(this->m_sIoctls != INVALID_SOCKET);
	hIOCompletionPortResult = CreateIoCompletionPort((HANDLE) this->m_sIoctls,
													this->m_hAlertIOCompletionPort,
													dwCompletionKey,
													dwNumConcurrentThreads);
	if (hIOCompletionPortResult == NULL)
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't associate I/O completion port with Ioctl socket (error = %u)!", dwError);
#endif // DBG

		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	//
	// We should have just gotten the same I/O completion port back.
	//
	DNASSERT(hIOCompletionPortResult == this->m_hAlertIOCompletionPort);


	//
	// Create overlapped structure.  Don't allocate it through DNMalloc,
	// because we may have to leak it on purpose.  We don't want those memory
	// allocation asserts firing in that case.
	//
	this->m_polAddressListChange = (WSAOVERLAPPED*) HeapAlloc(GetProcessHeap(),
															HEAP_ZERO_MEMORY,
															sizeof(WSAOVERLAPPED));
	if (this->m_polAddressListChange == NULL)
	{
		//
		// Close the alert IOCP we set.
		//
		CloseHandle(this->m_hAlertIOCompletionPort);
		this->m_hAlertIOCompletionPort = NULL;

		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Start getting notified of local address changes.
	//
	hr = this->RequestLocalAddressListChangeNotification();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");

		//
		// Free the memory we allocated.
		//
		HeapFree(GetProcessHeap(), 0, this->m_polAddressListChange);
		this->m_polAddressListChange = NULL;

		//
		// Close the alert IOCP we set.
		//
		CloseHandle(this->m_hAlertIOCompletionPort);
		this->m_hAlertIOCompletionPort = NULL;

		goto Failure;
	}



Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
#endif // ! DPNBUILD_NOWINSOCK2
} // CNATHelpUPnP::SetAlertIOCompletionPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ExtendRegisteredPortsLease"
//=============================================================================
// CNATHelpUPnP::ExtendRegisteredPortsLease
//-----------------------------------------------------------------------------
//
// Description:    Manually extends the lease of the given registered port
//				mapping by the requested time.  The periodic calling of GetCaps
//				can take care of this for the user, this function is only
//				necessary to change the lease extension time or for finer
//				control of individual mappings.
//
//				   The user should specify a requested lease extension time
//				that the server will attempt to honor.  It will be added to any
//				time remaining in the existing lease, and the new total can be
//				retrieved by calling GetRegisteredAddresses.
//
// Arguments:
//	DPNHHANDLE hRegisteredPorts		- Handle for a specific binding returned by
//										RegisterPorts.
//	DWORD dwLeaseTime				- Requested time, in milliseconds, to
//										extend the lease.  If 0, the previous
//										requested lease time is used.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The lease was successfully extended.
//	DPNHERR_GENERIC			- An error occurred that prevented the extending
//								the lease.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory to extend the lease.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::ExtendRegisteredPortsLease(const DPNHHANDLE hRegisteredPorts,
													const DWORD dwLeaseTime,
													const DWORD dwFlags)
{
	HRESULT				hr;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;
	BOOL				fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, %u, 0x%lx)",
		this, hRegisteredPorts, dwLeaseTime, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	pRegisteredPort = (CRegisteredPort*) hRegisteredPorts;
	if (! pRegisteredPort->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid registered port mapping handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// If they wanted to change the lease time, update it.
	//
	if (dwLeaseTime != 0)
	{
		pRegisteredPort->UpdateRequestedLeaseTime(dwLeaseTime);
	}

	
	pDevice = pRegisteredPort->GetOwningDevice();


	//
	// If the port is registered with the UPnP device, extend that lease.
	//
	if (pRegisteredPort->HasUPnPPublicAddresses())
	{
		DNASSERT(pDevice != NULL);


		hr = this->ExtendUPnPLease(pRegisteredPort);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't extend port mapping lease on UPnP device (0x%lx)!  Ignoring.", hr);

			//
			// We'll treat this as non-fatal, but we have to dump the
			// server.  This may have already been done, but doing it
			// twice shouldn't be harmful.
			//
			this->ClearDevicesUPnPDevice(pDevice);
			hr = DPNH_OK;
		}
	}
	else
	{
		DPFX(DPFPREP, 2, "Port mapping not registered with UPnP gateway device.");
	}


	//
	// Firewall mappings never have lease times to extend.
	//


	this->DropLock();
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::ExtendRegisteredPortsLease






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::InitializeObject"
//=============================================================================
// CNATHelpUPnP::InitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Sets up the object for use like the constructor, but may
//				fail with OUTOFMEMORY.  Should only be called by class factory
//				creation routine.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK			- Initialization was successful.
//	E_OUTOFMEMORY	- There is not enough memory to initialize.
//=============================================================================
HRESULT CNATHelpUPnP::InitializeObject(void)
{
	HRESULT		hr;
	BOOL		fInittedCriticalSection = FALSE;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);

	DNASSERT(this->IsValidObject());


	//
	// Create the lock.
	// 

	if (! DNInitializeCriticalSection(&this->m_csLock))
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	fInittedCriticalSection = TRUE;


	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);


	this->m_hLongLockSemaphore = DNCreateSemaphore(NULL,
													0,
													MAX_LONG_LOCK_WAITING_THREADS,
													NULL);
	if (this->m_hLongLockSemaphore == NULL)
	{
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	hr = S_OK;

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fInittedCriticalSection)
	{
		DNDeleteCriticalSection(&this->m_csLock);
		fInittedCriticalSection = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::InitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::UninitializeObject"
//=============================================================================
// CNATHelpUPnP::UninitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the object like the destructor, mostly to balance
//				InitializeObject.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::UninitializeObject(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->IsValidObject());


	DNCloseHandle(this->m_hLongLockSemaphore);
	this->m_hLongLockSemaphore = NULL;

	DNDeleteCriticalSection(&this->m_csLock);


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CNATHelpUPnP::UninitializeObject





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::TakeLock"
//=============================================================================
// CNATHelpUPnP::TakeLock
//-----------------------------------------------------------------------------
//
// Description:    Takes the main object lock.  If some other thread is already
//				holding the long lock, we wait for that first.
//
// Arguments: None.
//
// Returns: DPNH_OK if lock was taken successfully, DPNHERR_REENTRANT if lock
//			was re-entered.
//=============================================================================
HRESULT CNATHelpUPnP::TakeLock(void)
{
	HRESULT		hr = DPNH_OK;
#ifdef DBG
	DWORD		dwStartTime;


	dwStartTime = GETTIMESTAMP();
#endif // DBG


	DNEnterCriticalSection(&this->m_csLock);


	//
	// If this same thread is already holding the lock, then bail.
	//
	if (this->m_dwLockThreadID == GetCurrentThreadId())
	{
		DPFX(DPFPREP, 0, "Thread re-entering!");
		goto Failure;
	}

	
	//
	// If someone is holding the long lock, we need to wait for that.  Of
	// course another thread could come in and take the long lock after the
	// first one drops it and before we can take the main one.  This algorithm
	// does not attempt to be fair in this case.  Theoretically we could wait
	// forever if this continued to occur.  That shouldn't happen in the real
	// world.
	// This whole mess of code is a huge... uh... workaround for stress hits
	// involving critical section timeouts.
	//
	while (this->m_dwFlags & NATHELPUPNPOBJ_LONGLOCK)
	{
		DNASSERT(this->m_lNumLongLockWaitingThreads >= 0);
		this->m_lNumLongLockWaitingThreads++;

		//
		// We need to keep looping until we do get the lock.
		//
		DNLeaveCriticalSection(&this->m_csLock);


		DPFX(DPFPREP, 3, "Waiting for long lock to be released.");

		DNWaitForSingleObject(this->m_hLongLockSemaphore, INFINITE);


		DNEnterCriticalSection(&this->m_csLock);


		//
		// If this same thread is already holding the lock, then bail.
		//
		if (this->m_dwLockThreadID == GetCurrentThreadId())
		{
			DPFX(DPFPREP, 0, "Thread re-entering after waiting for long lock!");
			goto Failure;
		}
	}


#ifdef DBG
	DPFX(DPFPREP, 8, "Took main object lock, elapsed time = %u ms.",
		(GETTIMESTAMP() - dwStartTime));
#endif // DBG

	//
	// Save this thread's ID so we know who's holding the lock.
	//
	this->m_dwLockThreadID = GetCurrentThreadId();


Exit:

	return hr;


Failure:

	//
	// We're reentering.  Drop the lock and return the failure.
	//
	DNLeaveCriticalSection(&this->m_csLock);

	hr = DPNHERR_REENTRANT;

	goto Exit;
} // CNATHelpUPnP::TakeLock




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::DropLock"
//=============================================================================
// CNATHelpUPnP::DropLock
//-----------------------------------------------------------------------------
//
// Description:    Drops the main object lock.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::DropLock(void)
{
	DNASSERT(! (this->m_dwFlags & NATHELPUPNPOBJ_LONGLOCK));
	DNASSERT(this->m_lNumLongLockWaitingThreads == 0);
	DNASSERT(this->m_dwLockThreadID == GetCurrentThreadId());

	this->m_dwLockThreadID = 0;
	DNLeaveCriticalSection(&this->m_csLock);

	DPFX(DPFPREP, 8, "Dropped main object lock.");
} // CNATHelpUPnP::DropLock




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SwitchToLongLock"
//=============================================================================
// CNATHelpUPnP::SwitchToLongLock
//-----------------------------------------------------------------------------
//
// Description:    Switches from holding the main object lock to holding the
//				long lock.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::SwitchToLongLock(void)
{
	AssertCriticalSectionIsTakenByThisThread(&this->m_csLock, TRUE);
	DNASSERT(! (this->m_dwFlags & NATHELPUPNPOBJ_LONGLOCK));
	DNASSERT(this->m_lNumLongLockWaitingThreads == 0);


	DPFX(DPFPREP, 8, "Switching to long lock.");


	this->m_dwFlags |= NATHELPUPNPOBJ_LONGLOCK;

	DNLeaveCriticalSection(&this->m_csLock);
} // CNATHelpUPnP::SwitchToLongLock




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SwitchFromLongLock"
//=============================================================================
// CNATHelpUPnP::SwitchFromLongLock
//-----------------------------------------------------------------------------
//
// Description:    Switches from holding the long lock back to holding the main
//				object lock.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::SwitchFromLongLock(void)
{
	DNEnterCriticalSection(&this->m_csLock);

	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_LONGLOCK);
	this->m_dwFlags &= ~NATHELPUPNPOBJ_LONGLOCK;


	DPFX(DPFPREP, 8, "Switching from long lock, alerting %i threads.",
		this->m_lNumLongLockWaitingThreads);


	//
	// This is non-optimal in that we release the semaphore but the waiting
	// threads still won't actually be able to do anything since we now hold
	// the main lock.
	//
	DNASSERT(this->m_lNumLongLockWaitingThreads >= 0);
	DNReleaseSemaphore(this->m_hLongLockSemaphore,
						this->m_lNumLongLockWaitingThreads,
						NULL);

	this->m_lNumLongLockWaitingThreads = 0;
} // CNATHelpUPnP::SwitchFromLongLock






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::LoadWinSockFunctionPointers"
//=============================================================================
// CNATHelpUPnP::LoadWinSockFunctionPointers
//-----------------------------------------------------------------------------
//
// Description:    Loads pointers to all the functions that we use in WinSock.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK			- Loading was successful.
//	DPNHERR_GENERIC	- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::LoadWinSockFunctionPointers(void)
{
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#ifdef DBG

#define PRINTERRORIFDEBUG(name)						\
	{\
		dwError = GetLastError();\
		DPFX(DPFPREP, 0, "Couldn't get \"%hs\" function!  0x%lx", name, dwError);\
	}

#else // ! DBG

#define PRINTERRORIFDEBUG(name)

#endif // ! DBG


#define LOADWINSOCKFUNCTION(var, proctype, name)	\
	{\
		var = (##proctype) GetProcAddress(this->m_hWinSockDLL, _TWINCE(name));\
		if (var == NULL)\
		{\
			PRINTERRORIFDEBUG(name);\
			hr = DPNHERR_GENERIC;\
			goto Failure;\
		}\
	}

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	HRESULT		hr = DPNH_OK;
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	LOADWINSOCKFUNCTION(this->m_pfnWSAStartup,				LPFN_WSASTARTUP,				"WSAStartup");
	LOADWINSOCKFUNCTION(this->m_pfnWSACleanup,				LPFN_WSACLEANUP,				"WSACleanup");
#ifdef WINCE
	this->m_pfnWSAGetLastError = (LPFN_WSAGETLASTERROR) GetLastError;
#else // ! WINCE
	LOADWINSOCKFUNCTION(this->m_pfnWSAGetLastError,			LPFN_WSAGETLASTERROR,			"WSAGetLastError");
#endif // ! WINCE
	LOADWINSOCKFUNCTION(this->m_pfnsocket,					LPFN_SOCKET,					"socket");
	LOADWINSOCKFUNCTION(this->m_pfnclosesocket,				LPFN_CLOSESOCKET,				"closesocket");
	LOADWINSOCKFUNCTION(this->m_pfnbind,					LPFN_BIND,						"bind");
	LOADWINSOCKFUNCTION(this->m_pfnsetsockopt,				LPFN_SETSOCKOPT,				"setsockopt");
	LOADWINSOCKFUNCTION(this->m_pfngetsockname,				LPFN_GETSOCKNAME,				"getsockname");
	LOADWINSOCKFUNCTION(this->m_pfnselect,					LPFN_SELECT,					"select");
	LOADWINSOCKFUNCTION(this->m_pfn__WSAFDIsSet,			LPFN___WSAFDISSET,				"__WSAFDIsSet");
	LOADWINSOCKFUNCTION(this->m_pfnrecvfrom,				LPFN_RECVFROM,					"recvfrom");
	LOADWINSOCKFUNCTION(this->m_pfnsendto,					LPFN_SENDTO,					"sendto");
	LOADWINSOCKFUNCTION(this->m_pfngethostname,				LPFN_GETHOSTNAME,				"gethostname");
	LOADWINSOCKFUNCTION(this->m_pfngethostbyname,			LPFN_GETHOSTBYNAME,				"gethostbyname");
	LOADWINSOCKFUNCTION(this->m_pfninet_addr,				LPFN_INET_ADDR,					"inet_addr");

#ifndef DPNBUILD_NOWINSOCK2
	if (! (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1))
	{
		LOADWINSOCKFUNCTION(this->m_pfnWSASocketA,				LPFN_WSASOCKETA,				"WSASocketA");
		LOADWINSOCKFUNCTION(this->m_pfnWSAIoctl,				LPFN_WSAIOCTL,					"WSAIoctl");
		LOADWINSOCKFUNCTION(this->m_pfnWSAGetOverlappedResult,	LPFN_WSAGETOVERLAPPEDRESULT,	"WSAGetOverlappedResult");
	}
#endif // ! DPNBUILD_NOWINSOCK2

	LOADWINSOCKFUNCTION(this->m_pfnioctlsocket,				LPFN_IOCTLSOCKET,				"ioctlsocket");
	LOADWINSOCKFUNCTION(this->m_pfnconnect,					LPFN_CONNECT,					"connect");
	LOADWINSOCKFUNCTION(this->m_pfnshutdown,				LPFN_SHUTDOWN,					"shutdown");
	LOADWINSOCKFUNCTION(this->m_pfnsend,					LPFN_SEND,						"send");
	LOADWINSOCKFUNCTION(this->m_pfnrecv,					LPFN_RECV,						"recv");

#ifdef DBG
	LOADWINSOCKFUNCTION(this->m_pfngetsockopt,				LPFN_GETSOCKOPT,				"getsockopt");
#endif // DBG


Exit:

	return hr;


Failure:

	hr = DPNHERR_GENERIC;

	goto Exit;
} // CNATHelpUPnP::LoadWinSockFunctionPointers






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CheckForNewDevices"
//=============================================================================
// CNATHelpUPnP::CheckForNewDevices
//-----------------------------------------------------------------------------
//
// Description:    Detects new IP capable devices that have been added and
//				removes old ones no longer available.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	BOOL * pfFoundNewDevices	Pointer to boolean to set to TRUE if new
//								devices were added, or NULL if don't care.
//
// Returns: HRESULT
//	DPNH_OK				- The check was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CheckForNewDevices(BOOL * const pfFoundNewDevices)
{
	HRESULT				hr = DPNH_OK;
#if ((defined(DBG)) || (! defined(DPNBUILD_NOWINSOCK2)))
	DWORD				dwError;
#endif // DBG or ! DPNBUILD_NOWINSOCK2
#ifndef DPNBUILD_NOWINSOCK2
	int					iReturn;
#endif // ! DPNBUILD_NOWINSOCK2
	char				szName[1000];
	PHOSTENT			phostent;
	IN_ADDR **			ppinaddr;
	DWORD				dwAddressesSize = 0;
	DWORD				dwNumAddresses = 0;
	IN_ADDR *			painaddrAddresses = NULL;
	CBilink *			pBilinkDevice;
	CDevice *			pDevice = NULL; // NULL it for PREfix, even though fDeviceCreated guards it
	BOOL				fDeviceCreated = FALSE;
	BOOL				fFound;
	CBilink *			pBilinkRegPort;
	CRegisteredPort *	pRegisteredPort;
	SOCKET				sTemp = INVALID_SOCKET;
	SOCKADDR_IN			saddrinTemp;
	DWORD				dwTemp;
#ifndef DPNBUILD_NOWINSOCK2
	SOCKET_ADDRESS *	paSocketAddresses;
#endif // ! DPNBUILD_NOWINSOCK2



	DPFX(DPFPREP, 5, "(0x%p) Parameters (0x%p)", this, pfFoundNewDevices);


#ifndef DPNBUILD_NOWINSOCK2
	//
	// Handle any address list change Ioctl completions that may have gotten us
	// here.
	//
	if ((this->m_hAlertEvent != NULL) ||
		(this->m_hAlertIOCompletionPort != NULL))
	{
		DNASSERT(this->m_sIoctls != INVALID_SOCKET);
		DNASSERT(this->m_polAddressListChange != NULL);

		if (this->m_pfnWSAGetOverlappedResult(this->m_sIoctls,					//
												this->m_polAddressListChange,	//
												&dwTemp,						// ignore bytes transferred
												FALSE,							// don't wait
												&dwTemp))						// ignore flags
		{
			DPFX(DPFPREP, 1, "Received address list change notification.");
			

			//
			// Overlapped result completed.  Reissue it.
			//
			hr = this->RequestLocalAddressListChangeNotification();
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");
				goto Failure;
			}
		}
		else
		{
			//
			// Figure out what error it was.
			//
			dwError = this->m_pfnWSAGetLastError();
			switch (dwError)
			{
				case WSA_IO_INCOMPLETE:
				{
					//
					// It hasn't completed yet.
					//
					break;
				}

				case ERROR_OPERATION_ABORTED:
				{
					//
					// The thread that we originally submitted the Ioctl on
					// went away and so the OS kindly cancelled the operation
					// on us.  How nice.  Well, let's try resubmitting it.
					//

					DPFX(DPFPREP, 1, "Thread that submitted previous address list change notification went away, rerequesting.");
					
					hr = this->RequestLocalAddressListChangeNotification();
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");
						goto Failure;
					}
					break;
				}
			
				default:
				{
					DPFX(DPFPREP, 0, "Couldn't get overlapped result, error = %u!  Ignoring.", dwError);
					break;
				}
			} // end switch (on error)
		}
	}


	//
	// If we're on WinSock 2, let's try getting the address list with
	// an Ioctl.
	//
	if (! (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1))
	{
		DNASSERT(this->m_sIoctls != INVALID_SOCKET);
		DNASSERT(this->m_pfnWSAIoctl != NULL);

		//
		// Keep trying to get the address list until we have a large enough
		// buffer.  We use the IN_ADDR array pointer simply because it's
		// already there.  We know that IN_ADDRs are smaller than
		// SOCKET_ADDRESSes, so we can reuse the same buffer.
		//
		do
		{
			iReturn = this->m_pfnWSAIoctl(this->m_sIoctls,			// use the special Ioctl socket
										SIO_ADDRESS_LIST_QUERY,		//
										NULL,						// no input data
										0,							// no input data
										painaddrAddresses,			// output buffer
										dwAddressesSize,			// output buffer size
										&dwTemp,					// bytes needed
										NULL,						// no overlapped structure
										NULL);						// no completion routine

			if (iReturn != 0)
			{
				dwError = this->m_pfnWSAGetLastError();

				//
				// Free the previous buffer, no matter what error it was.
				//
				if (painaddrAddresses != NULL)
				{
					DNFree(painaddrAddresses);
					painaddrAddresses = NULL;
				}
				
				if (dwError != WSAEFAULT)
				{
					DPFX(DPFPREP, 1, "Retrieving address list failed (err = %u), trying WinSock 1 method.", dwError);

					//
					// We'll try the old-fashioned WinSock 1 way.
					//
					break;
				}


				//
				// Be absolutely sure WinSock isn't causing us trouble.
				//
				if (dwTemp < sizeof(SOCKET_ADDRESS_LIST))
				{
					DPFX(DPFPREP, 0, "Received an invalid buffer size (%u < %u)!",
						dwTemp, sizeof(SOCKET_ADDRESS_LIST));

					//
					// We'll try the old-fashioned WinSock 1 way.
					//
					break;
				}


				//
				// The buffer wasn't large enough.  Try again.
				//
				painaddrAddresses = (IN_ADDR*) DNMalloc(dwTemp);
				if (painaddrAddresses == NULL)
				{
					hr = DPNHERR_OUTOFMEMORY;
					goto Failure;
				}

				dwAddressesSize = dwTemp;
			}
			else
			{
				//
				// Success!  We're going to being sneaky and reuse the buffer.
				// We know that the SOCKET_ADDRESS_LIST returned will be larger
				// than an array of IN_ADDRs, so we can save a malloc.
				//
				// But first, be absolutely sure WinSock isn't causing us
				// trouble.
				//

				if (painaddrAddresses == NULL)
				{
					DPFX(DPFPREP, 0, "WinSock returned success with a NULL buffer!");

					//
					// We'll try the old-fashioned WinSock 1 way.
					//
					break;
				}

				dwNumAddresses = ((SOCKET_ADDRESS_LIST*) painaddrAddresses)->iAddressCount;
				dwAddressesSize = 0;


				//
				// Make sure there are addresses. 
				//
				if (dwNumAddresses > 0)
				{
					DPFX(DPFPREP, 7, "WinSock 2 Ioctl returned %u addresses:", dwNumAddresses);

					paSocketAddresses = ((SOCKET_ADDRESS_LIST*) painaddrAddresses)->Address;
					for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
					{
						DNASSERT(paSocketAddresses[dwTemp].iSockaddrLength == sizeof(SOCKADDR_IN));
						DNASSERT(paSocketAddresses[dwTemp].lpSockaddr != NULL);
						DNASSERT(paSocketAddresses[dwTemp].lpSockaddr->sa_family == AF_INET);

						//
						// Ignore 0.0.0.0 addresses.
						//
						if (((SOCKADDR_IN*) (paSocketAddresses[dwTemp].lpSockaddr))->sin_addr.S_un.S_addr != INADDR_NONE)
						{
							//
							// Move the IN_ADDR component of this address
							// toward the front of the buffer, into it's
							// correct place in the array.
							//
							painaddrAddresses[dwTemp].S_un.S_addr = ((SOCKADDR_IN*) (paSocketAddresses[dwTemp].lpSockaddr))->sin_addr.S_un.S_addr;

							DPFX(DPFPREP, 7, "\t%u- %u.%u.%u.%u",
								dwTemp,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b1,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b2,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b3,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b4);
						}
						else
						{
							DPFX(DPFPREP, 1, "\t%u- Ignoring 0.0.0.0 address.", dwTemp);
							dwAddressesSize++;

							//
							// The code should handle this fine, but why is
							// WinSock doing this to us?
							//
							DNASSERT(FALSE);
						}
					}

					//
					// Subtract out any invalid addresses that we skipped.
					//
					dwNumAddresses -= dwAddressesSize;
					if (dwNumAddresses == 0)
					{
						DPFX(DPFPREP, 1, "WinSock 2 reported only invalid addresses, hoping WinSock 1 method picks up the loopback address.");

						DNFree(painaddrAddresses);
						painaddrAddresses = NULL;
					}
				}
				else
				{
					DPFX(DPFPREP, 1, "WinSock 2 Ioctl did not report any valid addresses, hoping WinSock 1 method picks up the loopback address.");

					DNFree(painaddrAddresses);
					painaddrAddresses = NULL;
				}

				//
				// Get out of the loop.
				//
				break;
			}
		}
		while (TRUE);
	}


	//
	// Get the list of all available addresses from the WinSock 1 API if we
	// don't already have them.
	//
	if (painaddrAddresses == NULL)
#endif // ! DPNBUILD_NOWINSOCK2
	{
		if (this->m_pfngethostname(szName, 1000) != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't get host name, error = %u!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		phostent = this->m_pfngethostbyname(szName);
		if (phostent == NULL)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't retrieve addresses, error = %u!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		//
		// WinSock says that you need to copy this data before you make any
		// other API calls.  So first we count the number of entries we need to
		// copy.
		//
		ppinaddr = (IN_ADDR**) phostent->h_addr_list;
		while ((*ppinaddr) != NULL)
		{
			//
			// Ignore 0.0.0.0 addresses.
			//
			if ((*ppinaddr)->S_un.S_addr != INADDR_NONE)
			{
				dwNumAddresses++;
			}
			else
			{
				DPFX(DPFPREP, 1, "Ignoring 0.0.0.0 address.");

				//
				// The code should handle this fine, but why is WinSock doing
				// this to us?
				//
				DNASSERT(FALSE);
			}

			ppinaddr++;
		}


		//
		// If there aren't any addresses, we must fail.  WinSock 1 ought to
		// report the loopback address at least.
		//
		if (dwNumAddresses == 0)
		{
			DPFX(DPFPREP, 0, "WinSock 1 did not report any valid addresses!");
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		DPFX(DPFPREP, 7, "WinSock 1 method returned %u valid addresses:", dwNumAddresses);

		painaddrAddresses = (IN_ADDR*) DNMalloc(dwNumAddresses * sizeof(IN_ADDR));
		if (painaddrAddresses == NULL)
		{
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}

		//
		// Now copy all the addresses.
		//
		ppinaddr = (IN_ADDR**) phostent->h_addr_list;
		
		dwTemp = 0;
		while ((*ppinaddr) != NULL)
		{
			//
			// Ignore 0.0.0.0 addresses again.
			//
			if ((*ppinaddr)->S_un.S_addr != INADDR_NONE)
			{
				painaddrAddresses[dwTemp].S_un.S_addr = (*ppinaddr)->S_un.S_addr;
				
				DPFX(DPFPREP, 7, "\t%u- %u.%u.%u.%u",
					dwTemp,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b1,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b2,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b3,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b4);

				dwTemp++;
			}

			ppinaddr++;
		}
				
		DNASSERT(dwTemp == dwNumAddresses);
	}
	/*
	else
	{
		//
		// Already have addresses array.
		//
	}
	*/


	//
	// Make sure that all of the devices we currently know about are still
	// around.
	//
	pBilinkDevice = this->m_blDevices.GetNext();
	while (pBilinkDevice != &this->m_blDevices)
	{
		DNASSERT(! pBilinkDevice->IsEmpty());
		pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
		pBilinkDevice = pBilinkDevice->GetNext();

		fFound = FALSE;
		for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
		{
			if (painaddrAddresses[dwTemp].S_un.S_addr == pDevice->GetLocalAddressV4())
			{
				fFound = TRUE;
				break;
			}
		}

		if (fFound)
		{
			//
			// It may be time for this device to use a different port...
			//
			dwTemp = pDevice->GetFirstUPnPDiscoveryTime();
			if ((dwTemp != 0) && ((GETTIMESTAMP() - dwTemp) > g_dwReusePortTime))
			{
				ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
				saddrinTemp.sin_family				= AF_INET;
				saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();

				sTemp = this->CreateSocket(&saddrinTemp, SOCK_DGRAM, IPPROTO_UDP);
				if (sTemp != INVALID_SOCKET)
				{
					//
					// Sanity check that we didn't lose the device address.
					//
					DNASSERT(saddrinTemp.sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4());

					DPFX(DPFPREP, 4, "Device 0x%p UPnP discovery socket 0x%p (%u.%u.%u.%u:%u) created to replace port %u.",
						pDevice,
						sTemp,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
						NTOHS(saddrinTemp.sin_port),
						NTOHS(pDevice->GetUPnPDiscoverySocketPort()));

#ifndef DPNBUILD_NOHNETFWAPI
					//
					// If we used the HomeNet firewall API to open a hole for UPnP
					// discovery multicasts, close it.
					//
					if (pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall())
					{
						hr = this->CloseDevicesUPnPDiscoveryPort(pDevice, NULL);
						if (hr != DPNH_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't close device 0x%p's previous UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring.",
								pDevice, hr);

							//
							// Continue...
							//
							pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();
							hr = DPNH_OK;
						}
					}
#endif // ! DPNBUILD_NOHNETFWAPI

					pDevice->SetUPnPDiscoverySocketPort(saddrinTemp.sin_port);
					pDevice->SetFirstUPnPDiscoveryTime(0);

					//
					// Close the existing socket.
					//
					this->m_pfnclosesocket(pDevice->GetUPnPDiscoverySocket());

					//
					// Transfer ownership of the new socket to the device.
					//
					pDevice->SetUPnPDiscoverySocket(sTemp);
					sTemp = INVALID_SOCKET;

					DPFX(DPFPREP, 8, "Device 0x%p got re-assigned UPnP socket 0x%p.",
						pDevice, pDevice->GetUPnPDiscoverySocket());

					//
					// We'll let the normal "check for firewall" code detect
					// the fact that the discovery socket is not mapped on the
					// firewall and try to do so there (if it even needs to be
					// mapped).  See UpdateServerStatus.
					//
				}
				else
				{
					DPFX(DPFPREP, 0, "Couldn't create a replacement UPnP discovery socket for device 0x%p!  Using existing port %u.",
						pDevice, NTOHS(pDevice->GetUPnPDiscoverySocketPort()));
				}
			}
		}
		else
		{
			//
			// Didn't find this device in the returned list, forget about
			// it.
			//
#ifdef DBG
			{
				IN_ADDR		inaddrTemp;


				inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();
				DPFX(DPFPREP, 1, "Device 0x%p no longer exists, removing (address was %u.%u.%u.%u).",
					pDevice,
					inaddrTemp.S_un.S_un_b.s_b1,
					inaddrTemp.S_un.S_un_b.s_b2,
					inaddrTemp.S_un.S_un_b.s_b3,
					inaddrTemp.S_un.S_un_b.s_b4);
			}

			this->m_dwNumDeviceRemoves++;
#endif // DBG


			//
			// Override the minimum UpdateServerStatus interval so that we can
			// get information on any local public address changes due to the
			// possible loss of a server on this interface.
			//
			this->m_dwFlags |= NATHELPUPNPOBJ_DEVICECHANGED;

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();


			//
			// Forcefully mark the UPnP gateway device as disconnected.
			//
			if (pDevice->GetUPnPDevice() != NULL)
			{
				this->ClearDevicesUPnPDevice(pDevice);
			}
			

			//
			// Mark all ports that were registered to this device as unowned
			// by putting them into the wildcard list.  First unmap them from
			// the firewall.
			//
			pBilinkRegPort = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilinkRegPort != &pDevice->m_blOwnedRegPorts)
			{
				DNASSERT(! pBilinkRegPort->IsEmpty());
				pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegPort);
				pBilinkRegPort = pBilinkRegPort->GetNext();

				DPFX(DPFPREP, 1, "Registered port 0x%p's device went away, marking as unowned.",
					pRegisteredPort);


#ifndef DPNBUILD_NOHNETFWAPI
				//
				// Even though the device is gone, we can still remove the
				// firewall mapping.
				//
				if (pRegisteredPort->IsMappedOnHNetFirewall())
				{
					//
					// Unmap the port.
					//
					// Alert the user since this is unexpected.
					//
					hr = this->UnmapPortOnLocalHNetFirewall(pRegisteredPort,
															TRUE,
															TRUE);
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't unmap registered port 0x%p from device 0x%p's firewall (err = 0x%lx)!  Ignoring.",
							pRegisteredPort, pDevice, hr);

						pRegisteredPort->NoteNotMappedOnHNetFirewall();
						pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

						//
						// Continue anyway.
						//
						hr = DPNH_OK;
					}
				}
				
				pRegisteredPort->NoteNotHNetFirewallPortUnavailable();
#endif // ! DPNBUILD_NOHNETFWAPI

				DNASSERT(! pRegisteredPort->HasUPnPPublicAddresses());
				DNASSERT(! pRegisteredPort->IsUPnPPortUnavailable());

				pRegisteredPort->ClearDeviceOwner();
				pRegisteredPort->m_blDeviceList.RemoveFromList();
				pRegisteredPort->m_blDeviceList.InsertBefore(&this->m_blUnownedPorts);

				//
				// The user doesn't directly need to be informed.  If the ports
				// previously had public addresses, the ADDRESSESCHANGED flag
				// would have already been set by ClearDevicesUPnPDevice. If
				// they didn't have ports with public addresses, then the user
				// won't see any difference and thus ADDRESSESCHANGED wouldn't
				// need to be set.
				//
			}


#ifndef DPNBUILD_NOHNETFWAPI
			//
			// If we used the HomeNet firewall API to open a hole for UPnP
			// discovery multicasts, close it.
			//
			if (pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall())
			{
				hr = this->CloseDevicesUPnPDiscoveryPort(pDevice, NULL);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't close device 0x%p's UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring.",
						pDevice, hr);

					//
					// Continue...
					//
					pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();
					hr = DPNH_OK;
				}
			}
#endif // ! DPNBUILD_NOHNETFWAPI


			pDevice->m_blList.RemoveFromList();


			//
			// Close the socket, if we had one.
			//
			if (this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP)
			{
				this->m_pfnclosesocket(pDevice->GetUPnPDiscoverySocket());
				pDevice->SetUPnPDiscoverySocket(INVALID_SOCKET);
			}

			delete pDevice;
		}
	}


	//
	// Search for all returned devices in our existing list, and add new
	// entries for each one that we didn't already know about.
	//
	for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
	{
		fFound = FALSE;

		pBilinkDevice = this->m_blDevices.GetNext();
		while (pBilinkDevice != &this->m_blDevices)
		{
			DNASSERT(! pBilinkDevice->IsEmpty());
			pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
			pBilinkDevice = pBilinkDevice->GetNext();

			if (pDevice->GetLocalAddressV4() == painaddrAddresses[dwTemp].S_un.S_addr)
			{
				fFound = TRUE;
				break;
			}
		}

		if (! fFound)
		{
			//
			// We didn't know about this device.  Create a new object.
			//
			pDevice = new CDevice(painaddrAddresses[dwTemp].S_un.S_addr);
			if (pDevice == NULL)
			{
				hr = DPNHERR_OUTOFMEMORY;
				goto Failure;
			}

			fDeviceCreated = TRUE;


#ifdef DBG
			DPFX(DPFPREP, 1, "Found new device %u.%u.%u.%u, (object = 0x%p).",
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b1,
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b2,
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b3,
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b4,
				pDevice);

			this->m_dwNumDeviceAdds++;
#endif // DBG


			//
			// Override the minimum UpdateServerStatus interval so that we can
			// get information on this new device.
			//
			this->m_dwFlags |= NATHELPUPNPOBJ_DEVICECHANGED;

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();


			//
			// Create the UPnP discovery socket, if we're allowed.
			//
			if (this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP)
			{
				ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
				saddrinTemp.sin_family				= AF_INET;
				saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();

				sTemp = this->CreateSocket(&saddrinTemp, SOCK_DGRAM, IPPROTO_UDP);
				if (sTemp == INVALID_SOCKET)
				{
					DPFX(DPFPREP, 0, "Couldn't create a UPnP discovery socket!  Ignoring address (and destroying device 0x%p).",
						pDevice);

					//
					// Get rid of the device.
					//
					delete pDevice;
					pDevice = NULL;


					//
					// Forget about device in case of failure later.
					//
					fDeviceCreated = FALSE;


					//
					// Move to next address.
					//
					continue;
				}

				//
				// Sanity check that we didn't lose the device address.
				//
				DNASSERT(saddrinTemp.sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4());

				DPFX(DPFPREP, 4, "Device 0x%p UPnP discovery socket 0x%p (%u.%u.%u.%u:%u) created.",
					pDevice,
					sTemp,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
					NTOHS(saddrinTemp.sin_port));

				pDevice->SetUPnPDiscoverySocketPort(saddrinTemp.sin_port);

				//
				// Transfer ownership of the socket to the device.
				//
				pDevice->SetUPnPDiscoverySocket(sTemp);
				sTemp = INVALID_SOCKET;

				DPFX(DPFPREP, 8, "Device 0x%p got assigned UPnP socket 0x%p.",
					pDevice, pDevice->GetUPnPDiscoverySocket());
			}


#ifndef DPNBUILD_NOHNETFWAPI
			if (this->m_dwFlags & NATHELPUPNPOBJ_USEHNETFWAPI)
			{
				//
				// Check if the local firewall is enabled.
				//
				hr = this->CheckForLocalHNetFirewallAndMapPorts(pDevice, NULL);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't check for local HNet firewall and map ports (err = 0x%lx)!  Continuing.",
						hr);
					DNASSERT(! pDevice->IsHNetFirewalled());
					hr = DPNH_OK;
				}
			}
			else
			{
				//
				// Not using firewall traversal.
				//
			}
#endif // ! DPNBUILD_NOHNETFWAPI


			//
			// Add the device to our known list.
			//
			pDevice->m_blList.InsertBefore(&this->m_blDevices);


			//
			// Inform the caller if they care.
			//
			if (pfFoundNewDevices != NULL)
			{
				(*pfFoundNewDevices) = TRUE;
			}


			//
			// Forget about device in case of failure later.
			//
			fDeviceCreated = FALSE;
		}
	}


	//
	// If we got some very weird failures and ended up here without any
	// devices, complain to management (or the caller of this function, that's
	// probably more convenient).
	//
	if (this->m_blDevices.IsEmpty())
	{
		DPFX(DPFPREP, 0, "No usable devices, cannot proceed!", 0);
		DNASSERTX(! "No usable devices!", 2);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


Exit:

	if (painaddrAddresses != NULL)
	{
		DNFree(painaddrAddresses);
		painaddrAddresses = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (sTemp != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(sTemp);
		sTemp = INVALID_SOCKET;
	}

	if (fDeviceCreated)
	{
		delete pDevice;
	}

	goto Exit;
} // CNATHelpUPnP::CheckForNewDevices




#ifndef DPNBUILD_NOHNETFWAPI



#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CheckForLocalHNetFirewallAndMapPorts"
//=============================================================================
// CNATHelpUPnP::CheckForLocalHNetFirewallAndMapPorts
//-----------------------------------------------------------------------------
//
// Description:    Looks for a local HomeNet API aware firewall, and ensures
//				there are mappings for each of the device's registered ports,
//				if a firewall is found.
//
//				   If any registered port (except pDontAlertRegisteredPort if
//				not NULL) gets mapped, then it will trigger an address update
//				alert the next time the user calls GetCaps.
//
//				   The main object lock is assumed to be held.  It will be
//				converted into the long lock for the duration of this function.
//
// Arguments:
//	CDevice * pDevice							- Pointer to device to check.
//	CRegisteredPort * pDontAlertRegisteredPort	- Pointer to registered port
//													that should not trigger an
//													address update alert, or
//													NULL.
//
// Returns: HRESULT
//	DPNH_OK				- Search completed successfully.  There may or may not
//							be a firewall.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CheckForLocalHNetFirewallAndMapPorts(CDevice * const pDevice,
														CRegisteredPort * const pDontAlertRegisteredPort)
{
	HRESULT				hr = DPNH_OK;
	BOOL				fSwitchedToLongLock = FALSE;
	BOOL				fUninitializeCOM = FALSE;
	IHNetCfgMgr *		pHNetCfgMgr = NULL;
	IHNetConnection *	pHNetConnection = NULL;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pDevice, pDontAlertRegisteredPort);


	//
	// If this is the loopback address, don't bother trying to map anything.
	//
	if (pDevice->GetLocalAddressV4() == NETWORKBYTEORDER_INADDR_LOOPBACK)
	{
		DPFX(DPFPREP, 7, "No firewall behavior necessary with loopback device 0x%p.",
			pDevice);
		goto Exit;
	}
	

	//
	// If we don't have IPHLPAPI or RASAPI32, we can't do anything (and
	// shouldn't need to).
	//
	if ((this->m_hIpHlpApiDLL == NULL) || (this->m_hRasApi32DLL == NULL))
	{
		DPFX(DPFPREP, 7, "Didn't load IPHLPAPI and/or RASAPI32, not getting HNet interfaces for device 0x%p.",
			pDevice);
		goto Exit;
	}


	//
	// Using the HomeNet API (particularly the out-of-proc COM calls) during
	// stress is really, really, painfully slow.  Since we have one global lock
	// the controls everything, other threads may be sitting for an equally
	// long time... so long, in fact, that the critical section timeout fires
	// and we get a false stress hit.  So we have a sneaky workaround to
	// prevent that from happening while still maintaining ownership of the
	// object.
	//
	this->SwitchToLongLock();
	fSwitchedToLongLock = TRUE;


	//
	// Try to initialize COM if we weren't instantiated through COM.  It may
	// have already been initialized in a different mode, which is okay.  As
	// long as it has been initialized somehow, we're fine.
	//
	if (this->m_dwFlags & NATHELPUPNPOBJ_NOTCREATEDWITHCOM)
	{
		hr = CoInitializeEx(NULL, (COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE));
		switch (hr)
		{
			case S_OK:
			{
				//
				// Success, that's good.  Cleanup when we're done.
				//
				DPFX(DPFPREP, 8, "Successfully initialized COM.");
				fUninitializeCOM = TRUE;
				break;
			}

			case S_FALSE:
			{
				//
				// Someone else already initialized COM, but that's okay.
				// Cleanup when we're done.
				//
				DPFX(DPFPREP, 8, "Initialized COM (again).");
				fUninitializeCOM = TRUE;
				break;
			}

			case RPC_E_CHANGED_MODE:
			{
				//
				// Someone else already initialized COM in a different mode.
				// It should be okay, but we don't have to balance the CoInit
				// call with a CoUninit.
				//
				DPFX(DPFPREP, 8, "Didn't initialize COM, already initialized in a different mode.");
				break;
			}

			default:
			{
				//
				// Hmm, something else is going on.  We can't handle that.
				//
				DPFX(DPFPREP, 0, "Initializing COM failed (err = 0x%lx)!", hr);
				goto Failure;
				break;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 8, "Object was instantiated through COM, no need to initialize COM.");
	}


	//
	// Try creating the main HNet manager object.
	//
	hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, CLSCTX_INPROC_SERVER,
						IID_IHNetCfgMgr, (PVOID*) (&pHNetCfgMgr));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 1, "Couldn't create IHNetCfgMgr interface for device 0x%p (err = 0x%lx), assuming firewall control interface unavailable.",
			pDevice, hr);
		hr = DPNH_OK;
		goto Exit;
	}


	//
	// We created the IHNetCfgMgr object as in-proc, so there's no proxy that
	// requires security settings.
	//
	//SETDEFAULTPROXYBLANKET(pHNetCfgMgr);



	//
	// Get the HNetConnection object for this device.
	//
	hr = this->GetIHNetConnectionForDeviceIfFirewalled(pDevice,
														pHNetCfgMgr,
														&pHNetConnection);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 1, "Couldn't get IHNetConnection interface for device 0x%p (err = 0x%lx), assuming firewall not enabled.",
			pDevice, hr);


		//
		// If the device was previously firewalled, we need to clear our info.
		//
		if (pDevice->IsHNetFirewalled())
		{
			DPFX(DPFPREP, 2, "Firewall is no longer enabled for device 0x%p.",
				pDevice);

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();


			DNASSERT(pDevice->HasCheckedForFirewallAvailability());


			pBilink = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilink != &pDevice->m_blOwnedRegPorts)
			{
				DNASSERT(! pBilink->IsEmpty());
				pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

				//
				// Unmap items mapped on the firewall.
				//
				if (pRegisteredPort->IsMappedOnHNetFirewall())
				{
					DPFX(DPFPREP, 1, "Unmapping registered port 0x%p from device 0x%p's disappearing firewall.",
						pRegisteredPort, pDevice);


					hr = this->UnmapPortOnLocalHNetFirewallInternal(pRegisteredPort,
																	TRUE,
																	pHNetCfgMgr);
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't unmap registered port 0x%p from device 0x%p's firewall (err = 0x%lx)!  Ignoring.",
							pRegisteredPort, pDevice, hr);

						pRegisteredPort->NoteNotMappedOnHNetFirewall();
						pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

						//
						// Continue anyway.
						//
						hr = DPNH_OK;
					}


					//
					// Alert the user.
					//
					this->m_dwFlags |= NATHELPUPNPOBJ_ADDRESSESCHANGED;
				}
				else
				{
					DPFX(DPFPREP, 1, "Registered port 0x%p was not mapped on device 0x%p's disappearing firewall, assuming being called within RegisterPorts.",
						pRegisteredPort, pDevice);
				}


				//
				// Go to next port.
				//
				pBilink = pBilink->GetNext();
			}


			//
			// If we used the HomeNet firewall API to open a hole for UPnP
			// discovery multicasts, unmap that, too.
			//
			if (pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall())
			{
				DPFX(DPFPREP, 0, "Device 0x%p's UPnP discovery socket's forcefully unmapped from disappearing firewall.",
					pDevice);

				hr = this->CloseDevicesUPnPDiscoveryPort(pDevice, pHNetCfgMgr);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't close device 0x%p's UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring.",
						pDevice, hr);

					//
					// Continue...
					//
					pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();
					hr = DPNH_OK;
				}
			}


			//
			// Turn off the flag now that all registered ports have been
			// removed.
			//
			pDevice->NoteNotHNetFirewalled();
		}
		else
		{
			if (! pDevice->HasCheckedForFirewallAvailability())
			{
				//
				// The firewall is not enabled.
				//

				DPFX(DPFPREP, 2, "Firewall is not enabled for device 0x%p.",
					pDevice);

				pDevice->NoteCheckedForFirewallAvailability();


				//
				// Since it is possible to remove mappings even without the
				// firewall enabled, we can be courteous and unmap any stale
				// entries left by previous app crashes when the firewall was
				// still enabled.
				//

				//
				// Pretend that it currently had been firewalled.
				//
				pDevice->NoteHNetFirewalled();


				//
				// Cleanup the mappings.
				//
				hr = this->CleanupInactiveFirewallMappings(pDevice, pHNetCfgMgr);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Failed cleaning up inactive firewall mappings with device 0x%p (firewall not initially enabled)!",
						pDevice);
					goto Failure;
				}


				//
				// Turn off the flag we temporarily enabled while clearing
				// the mappings.
				//
				pDevice->NoteNotHNetFirewalled();
			}
			else
			{
				//
				// The firewall is still not enabled.
				//
				DPFX(DPFPREP, 2, "Firewall is still not enabled for device 0x%p.",
					pDevice);
			}
		}
		
		hr = DPNH_OK;
		goto Exit;
	}


	//
	// If firewalling is enabled now, and wasn't before, we need to map all the
	// existing ports.  If it had been, we're fine.
	//
	if (! pDevice->IsHNetFirewalled())
	{
		DPFX(DPFPREP, 2, "Firewall is now enabled for device 0x%p.",
			pDevice);

		pDevice->NoteCheckedForFirewallAvailability();
		pDevice->NoteHNetFirewalled();

		//
		// Since there was a change in the network, go back to polling
		// relatively quickly.
		//
		this->ResetNextPollInterval();


		//
		// If we're allowed, we need to try opening a hole so that we can
		// receive responses from device discovery multicasts.  We'll
		// ignore failures, since this is only to support the funky case of
		// enabling firewall behind a NAT.
		//
		if ((g_fMapUPnPDiscoverySocket) &&
			(pDevice->GetLocalAddressV4() != NETWORKBYTEORDER_INADDR_LOOPBACK) &&
			(this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP))
		{
			hr = this->OpenDevicesUPnPDiscoveryPort(pDevice,
													pHNetCfgMgr,
													pHNetConnection);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't open device 0x%p's UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring, NAT may be undetectable.",
					pDevice, hr);
				hr = DPNH_OK;

				//
				// Continue...
				//
			}
		}
		else
		{
			DPFX(DPFPREP, 3, "Not opening device 0x%p's UPnP discovery port (domap = %i, loopback = %i, upnp = %i).",
				pDevice,
				g_fMapUPnPDiscoverySocket,
				((pDevice->GetLocalAddressV4() != NETWORKBYTEORDER_INADDR_LOOPBACK) ? FALSE : TRUE),
				((this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP) ? TRUE : FALSE));
		}


		//
		// Try to remove any mappings that were not freed earlier because
		// we crashed.
		//
		hr = this->CleanupInactiveFirewallMappings(pDevice, pHNetCfgMgr);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed cleaning up inactive firewall mappings with device 0x%p's new firewall!",
				pDevice);
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 2, "Firewall is still enabled for device 0x%p.",
			pDevice);

		DNASSERT(pDevice->HasCheckedForFirewallAvailability());

		//
		// Try to map the discovery socket if it hasn't been (and we're allowed
		// & supposed to).
		//
		if ((g_fMapUPnPDiscoverySocket) &&
			(! pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall()) &&
			(pDevice->GetLocalAddressV4() != NETWORKBYTEORDER_INADDR_LOOPBACK) &&
			(this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP))
		{
			hr = this->OpenDevicesUPnPDiscoveryPort(pDevice,
													pHNetCfgMgr,
													pHNetConnection);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't open device 0x%p's UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring, NAT may be undetectable.",
					pDevice, hr);
				hr = DPNH_OK;

				//
				// Continue...
				//
			}
		}
		else
		{
			DPFX(DPFPREP, 3, "Not opening device 0x%p's UPnP discovery port (domap = %i, already = %i, loopback = %i, upnp = %i).",
				pDevice,
				g_fMapUPnPDiscoverySocket,
				pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall(),
				((pDevice->GetLocalAddressV4() != NETWORKBYTEORDER_INADDR_LOOPBACK) ? FALSE : TRUE),
				((this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP) ? TRUE : FALSE));
		}
	}


	//
	// Map all the ports that haven't been yet.
	//
	hr = this->MapUnmappedPortsOnLocalHNetFirewall(pDevice,
													pHNetCfgMgr,
													pHNetConnection,
													pDontAlertRegisteredPort);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't map ports on device 0x%p's new firewall (err = 0x%lx)!",
			pDevice, hr);
		goto Failure;
	}


	DNASSERT(hr == DPNH_OK);


Exit:

	if (pHNetConnection != NULL)
	{
		pHNetConnection->Release();
		pHNetConnection = NULL;
	}

	if (pHNetCfgMgr != NULL)
	{
		pHNetCfgMgr->Release();
		pHNetCfgMgr = NULL;
	}

	if (fUninitializeCOM)
	{
		DPFX(DPFPREP, 8, "Uninitializing COM.");
		CoUninitialize();
		fUninitializeCOM = FALSE;
	}

	if (fSwitchedToLongLock)
	{
		this->SwitchFromLongLock();
		fSwitchedToLongLock = FALSE;
	}


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// Ensure that the device is not considered to be firewalled.
	//
	pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();
	pDevice->NoteNotHNetFirewalled();


	//
	// Make sure no registered ports are marked as firewalled either.
	//
	pBilink = pDevice->m_blOwnedRegPorts.GetNext();
	while (pBilink != &pDevice->m_blOwnedRegPorts)
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

		if (pRegisteredPort->IsMappedOnHNetFirewall())
		{
			DPFX(DPFPREP, 1, "Registered port 0x%p forcefully marked as not mapped on HomeNet firewall.",
				pRegisteredPort);

			pRegisteredPort->NoteNotMappedOnHNetFirewall();
			pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
		}

		pBilink = pBilink->GetNext();
	}

	goto Exit;
} // CNATHelpUPnP::CheckForLocalHNetFirewallAndMapPorts






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetIHNetConnectionForDeviceIfFirewalled"
//=============================================================================
// CNATHelpUPnP::GetIHNetConnectionForDeviceIfFirewalled
//-----------------------------------------------------------------------------
//
// Description:    Returns an IHNetConnection interface for the given device.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice						- Pointer to device whose
//												IHNetConnection interface
//												should be retrieved.
//	IHNetCfgMgr * pHNetCfgMgr				- IHNetCfgMgr interface to use.
//	IHNetConnection ** ppHNetConnection		- Place to store IHetConnection
//												interface retrieved.
//
// Returns: HRESULT
//	DPNH_OK				- Interface retrieved successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::GetIHNetConnectionForDeviceIfFirewalled(CDevice * const pDevice,
															IHNetCfgMgr * const pHNetCfgMgr,
															IHNetConnection ** const ppHNetConnection)
{
	HRESULT								hr;
	DWORD								dwError;
	IHNetFirewallSettings *				pHNetFirewallSettings = NULL;
	IEnumHNetFirewalledConnections *	pEnumHNetFirewalledConnections = NULL;
	IHNetFirewalledConnection *			pHNetFirewalledConnection = NULL;
	ULONG								ulNumFound;
	IHNetConnection *					pHNetConnection = NULL;
	HNET_CONN_PROPERTIES *				pHNetConnProperties;
	BOOL								fLanConnection;
	IN_ADDR								inaddrTemp;
	TCHAR								tszDeviceIPAddress[16];	// "nnn.nnn.nnn.nnn" + NULL termination
	BOOL								fHaveDeviceGUID = FALSE;
	TCHAR								tszGuidDevice[GUID_STRING_LENGTH + 1];	// include NULL termination
	TCHAR								tszGuidHNetConnection[GUID_STRING_LENGTH + 1];	// include NULL termination
	GUID *								pguidHNetConnection = NULL;
	WCHAR *								pwszPhonebookPath = NULL;
	WCHAR *								pwszName = NULL;
	HRASCONN							hrasconn;
	RASPPPIP							raspppip;
	DWORD								dwSize;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p)",
		this, pDevice, pHNetCfgMgr, ppHNetConnection);


	//
	// Convert the IP address right away.  We use it frequently so there's no
	// sense in continually regenerating it.
	//
	inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();
	wsprintf(tszDeviceIPAddress, _T("%u.%u.%u.%u"),
			inaddrTemp.S_un.S_un_b.s_b1,
			inaddrTemp.S_un.S_un_b.s_b2,
			inaddrTemp.S_un.S_un_b.s_b3,
			inaddrTemp.S_un.S_un_b.s_b4);


	//
	// Here is what we're going to do in this function:
	//
	//	IHNetCfgMgr::QueryInterface for IHNetFirewallSettings
	//	IHNetFirewallSettings::EnumFirewalledConnections
	//		IHNetFirewalledConnection::QueryInterface for IHNetConnection
	//		get the IHNetConnection's HNET_CONN_PROPERTIES
	//		if HNET_CONN_PROPERTIES.fLanConnection
	//			IHNetConnection::GetGuid()
	//			if GUID matches IPHLPAPI GUID
	//					We've got the one we want, we're done
	//			else
	//				Keep looping
	//		else
	//			IHNetConnection::GetRasPhonebookPath and IHNetConnection::GetName to pass into RasGetEntryHrasconnW as pszPhonebook and pszEntry, respectively
	//			if got HRASCONN
	//				RasGetProjectionInfo
	//				if IP matches the IP we're looking for
	//					We've got the one we want, we're done
	//				else
	//					Keep looping
	//			else
	//				RAS entry is not dialed, keep looping
	//	if didn't find object
	//		it's not firewalled
	//


	//
	// Get the firewall settings object.
	//
	hr = pHNetCfgMgr->QueryInterface(IID_IHNetFirewallSettings,
									(PVOID*) (&pHNetFirewallSettings));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't query for IHNetFirewallSettings interface (err = 0x%lx)!",
			hr);
		goto Failure;
	}


	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pHNetFirewallSettings);


	//
	// Get the firewalled connections enumeration via IHNetFirewallSettings.
	//
	hr = pHNetFirewallSettings->EnumFirewalledConnections(&pEnumHNetFirewalledConnections);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't query for IHNetFirewallSettings interface (err = 0x%lx)!",
			hr);

		//
		// Make sure we don't try to release a bogus pointer in case it got
		// set.
		//
		pEnumHNetFirewalledConnections = NULL;

		goto Failure;
	}


	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pEnumHNetFirewalledConnections);


	//
	// Don't need the IHNetFirewallSettings interface anymore.
	//
	pHNetFirewallSettings->Release();
	pHNetFirewallSettings = NULL;


	//
	// Keep looping until we find the item or run out of items.
	//
	do
	{
		hr = pEnumHNetFirewalledConnections->Next(1,
												&pHNetFirewalledConnection,
												&ulNumFound);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "Couldn't get next connection (err = 0x%lx)!",
				hr);
			goto Failure;
		}


		//
		// If there aren't any more items, bail.
		//
		if (ulNumFound == 0)
		{
			//
			// pEnumHNetFirewalledConnections->Next might have returned
			// S_FALSE.
			//
			hr = DPNH_OK;
			break;
		}


		//
		// The HNetxxx objects appear to not be proxied...
		//
		//SETDEFAULTPROXYBLANKET(pHNetFirewalledConnection);


		//
		// Get the IHNetConnection interface.
		//
		hr = pHNetFirewalledConnection->QueryInterface(IID_IHNetConnection,
														(PVOID*) (&pHNetConnection));
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't query for IHNetConnection interface (err = 0x%lx)!",
				hr);
			goto Failure;
		}


		//
		// The HNetxxx objects appear to not be proxied...
		//
		//SETDEFAULTPROXYBLANKET(pHNetConnection);


		//
		// We don't need the firewalled connection object anymore.
		//
		pHNetFirewalledConnection->Release();
		pHNetFirewalledConnection = NULL;


		//
		// Get the internal properties for this adapter.
		//
		hr = pHNetConnection->GetProperties(&pHNetConnProperties);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't get home net connection properties (err = 0x%lx)!",
				hr);
			goto Failure;
		}

		//
		// Be somewhat picky about whether adapters returned by
		// IEnumHNetFirewalledConnections actually be firewalled.
		//
		DNASSERTX(pHNetConnProperties->fFirewalled, 2);


		fLanConnection = pHNetConnProperties->fLanConnection;


		//
		// Free the properties buffer.
		//
		CoTaskMemFree(pHNetConnProperties);
		//pHNetConnProperties = NULL;


		//
		// Now if it's a LAN connection, see if the GUID matches the one
		// returned by IPHLPAPI.
		// If it's a RAS connection, see if this phonebook entry is dialed and
		// has the right IP address.
		//
		if (fLanConnection)
		{
			//
			// LAN case.  If we haven't already retrieved the device's GUID, do
			// so now.
			//
			if (! fHaveDeviceGUID)
			{
				hr = this->GetIPAddressGuidString(tszDeviceIPAddress, tszGuidDevice);
				if (hr != S_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't get device 0x%p's GUID (err = 0x%lx)!",
						hr);
					goto Failure;
				}

				fHaveDeviceGUID = TRUE;
			}


			//
			// Get the HNetConnection object's GUID.
			//
			hr = pHNetConnection->GetGuid(&pguidHNetConnection);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get HNetConnection 0x%p's GUID (err = 0x%lx)!",
					pHNetConnection, hr);
				goto Failure;
			}


			//
			// Convert the GUID into a string.
			//
			wsprintf(tszGuidHNetConnection,
					_T("{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}"),
					pguidHNetConnection->Data1,
					pguidHNetConnection->Data2,
					pguidHNetConnection->Data3,
					pguidHNetConnection->Data4[0],
					pguidHNetConnection->Data4[1],
					pguidHNetConnection->Data4[2],
					pguidHNetConnection->Data4[3],
					pguidHNetConnection->Data4[4],
					pguidHNetConnection->Data4[5],
					pguidHNetConnection->Data4[6],
					pguidHNetConnection->Data4[7]);


			CoTaskMemFree(pguidHNetConnection);
			pguidHNetConnection = NULL;


#ifdef DBG
			//
			// Attempt to get the HNetConnection object's name for debugging
			// purposes.
			//
			hr = pHNetConnection->GetName(&pwszName);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get HNetConnection 0x%p name (err = 0x%lx)!",
					pHNetConnection, hr);
				goto Failure;
			}
#endif // DBG


			//
			// See if we found the object we need.
			//
			if (_tcsicmp(tszGuidHNetConnection, tszGuidDevice) == 0)
			{
				DPFX(DPFPREP, 7, "Matched IHNetConnection object 0x%p \"%ls\" to device 0x%p (LAN GUID %s).",
					pHNetConnection, pwszName, pDevice, tszGuidHNetConnection);

				//
				// Transfer reference to caller.
				//
				(*ppHNetConnection) = pHNetConnection;
				pHNetConnection = NULL;

#ifdef DBG
				CoTaskMemFree(pwszName);
				pwszName = NULL;
#endif // DBG

				//
				// We're done here.
				//
				hr = DPNH_OK;
				goto Exit;
			}

			
			DPFX(DPFPREP, 7, "Non-matching IHNetConnection 0x%p \"%ls\"",
				pHNetConnection, pwszName);
			DPFX(DPFPREP, 7, "\t(LAN GUID %s <> %s).",
				tszGuidHNetConnection, tszGuidDevice);

#ifdef DBG
			CoTaskMemFree(pwszName);
			pwszName = NULL;
#endif // DBG
		}
		else
		{
			//
			// RAS case.
			//
			DNASSERT(this->m_hRasApi32DLL != NULL);

			
			//
			// Get the HNetConnection object's phonebook path.
			//
			hr = pHNetConnection->GetRasPhonebookPath(&pwszPhonebookPath);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get HNetConnection's RAS phonebook path (err = 0x%lx)!",
					hr);
				goto Failure;
			}


			//
			// Get the HNetConnection object's name.
			//
			hr = pHNetConnection->GetName(&pwszName);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get HNetConnection's name (err = 0x%lx)!",
					hr);
				goto Failure;
			}


			//
			// Look for an active RAS connection from that phonebook with that
			// name.
			//
			dwError = this->m_pfnRasGetEntryHrasconnW(pwszPhonebookPath, pwszName, &hrasconn);
			if (dwError != 0)
			{
				//
				// It's probably ERROR_NO_CONNECTION (668).
				//
				DPFX(DPFPREP, 1, "Couldn't get entry's active RAS connection (err = %u), assuming not dialed",
					dwError);
				DPFX(DPFPREP, 1, "\tname \"%ls\", phonebook \"%ls\".",
					pwszName, pwszPhonebookPath);
			}
			else
			{
				//
				// Get the IP address.
				//

				ZeroMemory(&raspppip, sizeof(raspppip));
				raspppip.dwSize = sizeof(raspppip);
				dwSize = sizeof(raspppip);

				dwError = this->m_pfnRasGetProjectionInfo(hrasconn, RASP_PppIp, &raspppip, &dwSize);
				if (dwError != 0)
				{
					DPFX(DPFPREP, 0, "Couldn't get RAS connection's IP information (err = %u)!",
						dwError);
					hr = DPNHERR_GENERIC;
					goto Failure;
				}


				//
				// See if we found the object we need.
				//
				if (_tcsicmp(raspppip.szIpAddress, tszDeviceIPAddress) == 0)
				{
					DPFX(DPFPREP, 7, "Matched IHNetConnection object 0x%p to device 0x%p (RAS IP %s)",
						pHNetConnection, pDevice, raspppip.szIpAddress);
					DPFX(DPFPREP, 7, "\tname \"%ls\", phonebook \"%ls\".",
						pwszName, pwszPhonebookPath);

					//
					// Transfer reference to caller.
					//
					(*ppHNetConnection) = pHNetConnection;
					pHNetConnection = NULL;

					//
					// We're done here.
					//
					hr = DPNH_OK;
					goto Exit;
				}

				
				DPFX(DPFPREP, 7, "Non-matching IHNetConnection 0x%p (RAS IP %s != %s)",
					pHNetConnection, raspppip.szIpAddress, tszDeviceIPAddress);
				DPFX(DPFPREP, 7, "\tname \"%ls\", phonebook \"%ls\").",
					pwszName, pwszPhonebookPath);
			}


			CoTaskMemFree(pwszPhonebookPath);
			pwszPhonebookPath = NULL;

			CoTaskMemFree(pwszName);
			pwszName = NULL;
		}


		//
		// If we're here, we pHNetConnection is not the one we're looking for.
		//
		pHNetConnection->Release();
		pHNetConnection = NULL;
	}
	while (TRUE);


	//
	// If we're here, then we didn't find a matching firewall connection.
	//
	DPFX(DPFPREP, 3, "Didn't find device 0x%p in list of firewalled connections.",
		pDevice);
	hr = DPNHERR_GENERIC;


Exit:

	if (pEnumHNetFirewalledConnections != NULL)
	{
		pEnumHNetFirewalledConnections->Release();
		pEnumHNetFirewalledConnections = NULL;
	}

	DPFX(DPFPREP, 6, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pwszName != NULL)
	{
		CoTaskMemFree(pwszName);
		pwszName = NULL;
	}
	
	if (pwszPhonebookPath == NULL)
	{
		CoTaskMemFree(pwszPhonebookPath);
		pwszPhonebookPath = NULL;
	}

	if (pHNetConnection != NULL)
	{
		pHNetConnection->Release();
		pHNetConnection = NULL;
	}

	if (pHNetFirewalledConnection != NULL)
	{
		pHNetFirewalledConnection->Release();
		pHNetFirewalledConnection = NULL;
	}

	if (pHNetFirewallSettings != NULL)
	{
		pHNetFirewallSettings->Release();
		pHNetFirewallSettings = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::GetIHNetConnectionForDeviceIfFirewalled





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetIPAddressGuidString"
//=============================================================================
// CNATHelpUPnP::GetIPAddressGuidString
//-----------------------------------------------------------------------------
//
// Description:    Retrieves the IPHLPAPI assigned GUID (in string format) for
//				the given IP address string.  ptszGuidString must be able to
//				hold GUID_STRING_LENGTH + 1 characters.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	TCHAR * tszDeviceIPAddress	- IP address string to lookup.
//	TCHAR * ptszGuidString		- Place to store device's GUID string.
//
// Returns: HRESULT
//	DPNH_OK				- Interface retrieved successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::GetIPAddressGuidString(const TCHAR * const tszDeviceIPAddress,
											TCHAR * const ptszGuidString)
{
	HRESULT				hr = DPNH_OK;
	DWORD				dwError;
	PIP_ADAPTER_INFO	pAdaptersBuffer = NULL;
	ULONG				ulSize;
	PIP_ADAPTER_INFO	pAdapterInfo;
	PIP_ADDR_STRING		pIPAddrString;
	char *				pszAdapterGuid = NULL;
#ifdef UNICODE
	char				szDeviceIPAddress[16];	// "nnn.nnn.nnn.nnn" + NULL termination
#endif // UNICODE
#ifdef DBG
	char				szIPList[256];
	char *				pszCurrentIP;
#endif // DBG


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (\"%s\", 0x%p)",
		this, tszDeviceIPAddress, ptszGuidString);


	DNASSERT(this->m_hIpHlpApiDLL != NULL);


	//
	// Keep trying to get the list of adapters until we get ERROR_SUCCESS or a
	// legitimate error (other than ERROR_BUFFER_OVERFLOW or
	// ERROR_INSUFFICIENT_BUFFER).
	//
	ulSize = 0;
	do
	{
		dwError = this->m_pfnGetAdaptersInfo(pAdaptersBuffer, &ulSize);
		if (dwError == ERROR_SUCCESS)
		{
			//
			// We succeeded, we should be set.  But make sure there are
			// adapters for us to use.
			//
			if (ulSize < sizeof(IP_ADAPTER_INFO))
			{
				DPFX(DPFPREP, 0, "Getting adapters info succeeded but didn't return any valid adapters (%u < %u)!",
					ulSize, sizeof(IP_ADAPTER_INFO));
				hr = DPNHERR_GENERIC;
				goto Failure;
			}

			break;
		}

		if ((dwError != ERROR_BUFFER_OVERFLOW) &&
			(dwError != ERROR_INSUFFICIENT_BUFFER))
		{
			DPFX(DPFPREP, 0, "Unable to get adapters info (error = 0x%lx)!",
				dwError);
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		//
		// We need more adapter space.  Make sure there are adapters for us to
		// use.
		//
		if (ulSize < sizeof(IP_ADAPTER_INFO))
		{
			DPFX(DPFPREP, 0, "Getting adapters info didn't return any valid adapters (%u < %u)!",
				ulSize, sizeof(IP_ADAPTER_INFO));
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		//
		// If we previously had a buffer, free it.
		//
		if (pAdaptersBuffer != NULL)
		{
			DNFree(pAdaptersBuffer);
		}

		//
		// Allocate the buffer.
		//
		pAdaptersBuffer = (PIP_ADAPTER_INFO) DNMalloc(ulSize);
		if (pAdaptersBuffer == NULL)
		{
			DPFX(DPFPREP, 0, "Unable to allocate memory for adapters info!");
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}
	}
	while (TRUE);


#ifdef UNICODE
	STR_jkWideToAnsi(szDeviceIPAddress,
					tszDeviceIPAddress,
					16);
	szDeviceIPAddress[15] = 0; // ensure it's NULL terminated
#endif // UNICODE


	//
	// Now find the device in the adapter list returned.  Loop through all
	// adapters.
	//
	pAdapterInfo = pAdaptersBuffer;
	while (pAdapterInfo != NULL)
	{
#ifdef DBG
		//
		// Initialize IP address list string.
		//
		szIPList[0] = '\0';
		pszCurrentIP = szIPList;
#endif // DBG

		//
		// Loop through all addresses for this adapter looking for the one for
		// the device we have bound.
		//
		pIPAddrString = &pAdapterInfo->IpAddressList;
		while (pIPAddrString != NULL)
		{
#ifdef DBG
			int		iStrLen;


			//
			// Copy the IP address string (if there's enough room), then tack
			// on a space and NULL terminator.
			//
			iStrLen = strlen(pIPAddrString->IpAddress.String);
			if ((pszCurrentIP + iStrLen + 2) < (szIPList + sizeof(szIPList)))
			{
				memcpy(pszCurrentIP, pIPAddrString->IpAddress.String, iStrLen);
				pszCurrentIP += iStrLen;
				(*pszCurrentIP) = ' ';
				pszCurrentIP++;
				(*pszCurrentIP) = '\0';
				pszCurrentIP++;
			}
#endif // DBG

#ifdef UNICODE
			if (strcmp(pIPAddrString->IpAddress.String, szDeviceIPAddress) == 0)
#else // ! UNICODE
			if (strcmp(pIPAddrString->IpAddress.String, tszDeviceIPAddress) == 0)
#endif // ! UNICODE
			{
				DPFX(DPFPREP, 8, "Found %s under adapter index %u (\"%hs\").",
					tszDeviceIPAddress, pAdapterInfo->Index, pAdapterInfo->Description);

				DNASSERT(pszAdapterGuid == NULL);
				pszAdapterGuid = pAdapterInfo->AdapterName;


				//
				// Drop out of the loop in retail, keep going in debug.
				//
#ifndef DBG
				break;
#endif // ! DBG
			}

			pIPAddrString = pIPAddrString->Next;
		}


		//
		// Drop out of the loop in retail, print this entry and keep going in
		// debug.
		//
#ifdef DBG
		DPFX(DPFPREP, 7, "Adapter index %u IPs = %hs, %hs, \"%hs\".",
			pAdapterInfo->Index,
			szIPList,
			pAdapterInfo->AdapterName,
			pAdapterInfo->Description);
#else // ! DBG
		if (pszAdapterGuid != NULL)
		{
			break;
		}
#endif // ! DBG

		pAdapterInfo = pAdapterInfo->Next;
	}


	//
	// pszAdapterGuid will be NULL if we never found the device.
	//
	if (pszAdapterGuid == NULL)
	{
		DPFX(DPFPREP, 0, "Did not find adapter with matching address for address %s!",
			tszDeviceIPAddress);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Copy the adapter GUID string to the buffer supplied.
	//
#ifdef UNICODE
	STR_jkAnsiToWide(ptszGuidString,
					pszAdapterGuid,
					(GUID_STRING_LENGTH + 1));
#else // ! UNICODE
	strncpy(ptszGuidString, pszAdapterGuid, (GUID_STRING_LENGTH + 1));
#endif // ! UNICODE
	ptszGuidString[GUID_STRING_LENGTH] = 0;	// ensure it's NULL terminated


Exit:

	if (pAdaptersBuffer != NULL)
	{
		DNFree(pAdaptersBuffer);
		pAdaptersBuffer = NULL;
	}

	DPFX(DPFPREP, 6, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::GetIPAddressGuidString





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::OpenDevicesUPnPDiscoveryPort"
//=============================================================================
// CNATHelpUPnP::OpenDevicesUPnPDiscoveryPort
//-----------------------------------------------------------------------------
//
// Description:    Maps the UPnP discovery socket's port if a firewall is
//				found.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice					- Pointer to device whose port should
//											be opened.
//	IHNetCfgMgr * pHNetCfgMgr			- Pointer to IHNetCfgMgr interface to
//											use.
//	IHNetConnection * pHNetConnection	- Pointer to IHNetConnection interface
//											for the given device.
//
// Returns: HRESULT
//	DPNH_OK				- Mapping completed successfully.  There may or may not
//							be a firewall.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::OpenDevicesUPnPDiscoveryPort(CDevice * const pDevice,
													IHNetCfgMgr * const pHNetCfgMgr,
													IHNetConnection * const pHNetConnection)
{
	HRESULT				hr = DPNH_OK;
	CRegisteredPort *	pRegisteredPort = NULL;
	SOCKADDR_IN			saddrinTemp;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p)",
		this, pDevice, pHNetCfgMgr, pHNetConnection);


	DNASSERT(pDevice->IsHNetFirewalled());



	//
	// Create a fake UDP registered port to map.
	//
	pRegisteredPort = new CRegisteredPort(0, 0);
	if (pRegisteredPort == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	pRegisteredPort->MakeDeviceOwner(pDevice);


	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family				= AF_INET;
	saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
	saddrinTemp.sin_port				= pDevice->GetUPnPDiscoverySocketPort();
	DNASSERT(saddrinTemp.sin_port != 0);

	hr = pRegisteredPort->SetPrivateAddresses(&saddrinTemp, 1);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set registered port 0x%p's private addresses (err = 0x%lx)!",
			pRegisteredPort, hr);
		goto Failure;
	}


	//
	// Map the port.
	//
	hr = this->MapPortOnLocalHNetFirewall(pRegisteredPort,
										pHNetCfgMgr,
										pHNetConnection,
										FALSE);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't map UPnP discovery socket port (temp regport = 0x%p) on device 0x%p's initial firewall (err = 0x%lx)!",
			pRegisteredPort, pDevice, hr);
		goto Failure;
	}


	//
	// If the port was unavailable, we have to give up on supporting the
	// scenario (firewall enabled behind a NAT).  Otherwise, remember the fact
	// that we mapped the port, and then delete the registered port object.  We
	// will unmap it when we shut down the device.
	//
	if (! pRegisteredPort->IsHNetFirewallPortUnavailable())
	{
		DPFX(DPFPREP, 3, "Mapped UPnP discovery socket for device 0x%p on firewall (removing temp regport 0x%p).",
			pDevice, pRegisteredPort);


		pDevice->NoteUPnPDiscoverySocketMappedOnHNetFirewall();

		//
		// Clear this to prevent an assert.
		//
		pRegisteredPort->NoteNotMappedOnHNetFirewall();
		pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
	}
	else
	{
		DPFX(DPFPREP, 1, "Could not map UPnP discovery socket on firewall for device 0x%p, unable to support an upstream NAT.",
			pDevice);
	}

	pRegisteredPort->ClearPrivateAddresses();
	pRegisteredPort->ClearDeviceOwner();


	//
	// Delete the item.
	//
	delete pRegisteredPort;
	pRegisteredPort = NULL;


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pRegisteredPort != NULL)
	{
		//
		// Clear any settings that might cause an assert.
		//
		pRegisteredPort->NoteNotMappedOnHNetFirewall();
		pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
		pRegisteredPort->ClearPrivateAddresses();
		pRegisteredPort->ClearDeviceOwner();


		//
		// Delete the item.
		//
		delete pRegisteredPort;
		pRegisteredPort = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::OpenDevicesUPnPDiscoveryPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CloseDevicesUPnPDiscoveryPort"
//=============================================================================
// CNATHelpUPnP::CloseDevicesUPnPDiscoveryPort
//-----------------------------------------------------------------------------
//
// Description:    Unmaps the UPnP discovery socket's port from the firewall.
//				pHNetCfgMgr can be NULL if it has not previously been obtained.
//
//				   COM is assumed to have been initialized if pHNetCfgMgr is
//				not NULL.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice			- Pointer to device whose port should be
//									close.
//	IHNetCfgMgr * pHNetCfgMgr	- Pointer to IHNetCfgMgr interface to use, or
//									NULL if not previously obtained.
//
// Returns: HRESULT
//	DPNH_OK				- Unmapping completed successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CloseDevicesUPnPDiscoveryPort(CDevice * const pDevice,
													IHNetCfgMgr * const pHNetCfgMgr)
{
	HRESULT				hr = DPNH_OK;
	CRegisteredPort *	pRegisteredPort = NULL;
	SOCKADDR_IN			saddrinTemp;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pDevice, pHNetCfgMgr);


	//
	// Create a fake UDP registered port to unmap.
	//
	pRegisteredPort = new CRegisteredPort(0, 0);
	if (pRegisteredPort == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	pRegisteredPort->MakeDeviceOwner(pDevice);
	pRegisteredPort->NoteMappedOnHNetFirewall();


	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family				= AF_INET;
	saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
	saddrinTemp.sin_port				= pDevice->GetUPnPDiscoverySocketPort();
	DNASSERT(saddrinTemp.sin_port != 0);

	hr = pRegisteredPort->SetPrivateAddresses(&saddrinTemp, 1);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set registered port 0x%p's private addresses (err = 0x%lx)!",
			pRegisteredPort, hr);
		goto Failure;
	}


	//
	// Unmap the port using the internal method if possible.
	//
	if (pHNetCfgMgr != NULL)
	{
		hr = this->UnmapPortOnLocalHNetFirewallInternal(pRegisteredPort, TRUE, pHNetCfgMgr);
	}
	else
	{
		//
		// Don't alert the user since he/she doesn't know about this port.
		//
		hr = this->UnmapPortOnLocalHNetFirewall(pRegisteredPort, TRUE, FALSE);
	}
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't unmap UPnP discovery socket port (temp regport = 0x%p) on device 0x%p's firewall (err = 0x%lx)!",
			pRegisteredPort, pDevice, hr);
		goto Failure;
	}


	//
	// Destroy the registered port object (note that the port mapping still
	// exists).  We will unmap when we shut down the device.
	//
	pRegisteredPort->ClearPrivateAddresses();
	pRegisteredPort->ClearDeviceOwner();


	//
	// Delete the item.
	//
	delete pRegisteredPort;
	pRegisteredPort = NULL;


	pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pRegisteredPort != NULL)
	{
		//
		// Clear any settings that might cause an assert.
		//
		pRegisteredPort->NoteNotMappedOnHNetFirewall();
		pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
		pRegisteredPort->ClearPrivateAddresses();
		pRegisteredPort->ClearDeviceOwner();


		//
		// Delete the item.
		//
		delete pRegisteredPort;
		pRegisteredPort = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::CloseDevicesUPnPDiscoveryPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::MapUnmappedPortsOnLocalHNetFirewall"
//=============================================================================
// CNATHelpUPnP::MapUnmappedPortsOnLocalHNetFirewall
//-----------------------------------------------------------------------------
//
// Description:    Maps any ports associated with the given device that have
//				not been mapped with the local firewall yet.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice							- Device with (new) firewall.
//	IHNetCfgMgr * pHNetCfgMgr					- Pointer to IHNetCfgMgr
//													interface to use.
//	IHNetConnection * pHNetConnection			- Pointer to IHNetConnection
//													interface for the given
//													device.
//	CRegisteredPort * pDontAlertRegisteredPort	- Pointer to registered port
//													that should not trigger an
//													address update alert, or
//													NULL.
//
// Returns: HRESULT
//	DPNH_OK				- Mapping completed successfully.  Note that the ports
//							may be marked as unavailable.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::MapUnmappedPortsOnLocalHNetFirewall(CDevice * const pDevice,
														IHNetCfgMgr * const pHNetCfgMgr,
														IHNetConnection * const pHNetConnection,
														CRegisteredPort * const pDontAlertRegisteredPort)
{
	HRESULT				hr = DPNH_OK;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, 0x%p)",
		this, pDevice, pHNetCfgMgr, pHNetConnection, pDontAlertRegisteredPort);


	DNASSERT(pDevice->IsHNetFirewalled());



	//
	// Loop through all the registered ports associated with the device.
	//
	pBilink = pDevice->m_blOwnedRegPorts.GetNext();
	while (pBilink != &pDevice->m_blOwnedRegPorts)
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);
		pBilink = pBilink->GetNext();


		//
		// If this port has already been mapped, we can skip it.
		//
		if (pRegisteredPort->IsMappedOnHNetFirewall())
		{
			DPFX(DPFPREP, 7, "Registered port 0x%p has already been mapped on the firewall for device 0x%p.",
				pRegisteredPort, pDevice);
			continue;
		}


		//
		// If this port has already been determined to be unavailable, we can
		// skip it.
		//
		if (pRegisteredPort->IsHNetFirewallPortUnavailable())
		{
			DPFX(DPFPREP, 7, "Registered port 0x%p has already been determined to be unavailable on the firewall for device 0x%p.",
				pRegisteredPort, pDevice);
			continue;
		}


		DPFX(DPFPREP, 3, "Mapping registered port 0x%p on firewall for device 0x%p.",
			pRegisteredPort, pDevice);
		

		hr = this->MapPortOnLocalHNetFirewall(pRegisteredPort,
											pHNetCfgMgr,
											pHNetConnection,
											((pRegisteredPort == pDontAlertRegisteredPort) ? FALSE : TRUE));
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 7, "Failed mapping registered port 0x%p on firewall for device 0x%p.",
				pRegisteredPort, pDevice);
			goto Failure;
		}


		//
		// Go to next registered port.
		//
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::MapUnmappedPortsOnLocalHNetFirewall





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::MapPortOnLocalHNetFirewall"
//=============================================================================
// CNATHelpUPnP::MapPortOnLocalHNetFirewall
//-----------------------------------------------------------------------------
//
// Description:    Maps the given port with the corresponding firewall.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Port to map.
//	IHNetCfgMgr * pHNetCfgMgr			- Pointer to IHNetCfgMgr interface to
//											use.
//	IHNetConnection * pHNetConnection	- Pointer to IHNetConnection interface
//											for the given device.
//	BOOL fNoteAddressChange				- Whether to alert the user of the
//											address change or not.
//
// Returns: HRESULT
//	DPNH_OK				- Mapping completed successfully.  Note that the ports
//							may be marked as unavailable.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::MapPortOnLocalHNetFirewall(CRegisteredPort * const pRegisteredPort,
												IHNetCfgMgr * const pHNetCfgMgr,
												IHNetConnection * const pHNetConnection,
												const BOOL fNoteAddressChange)
{
	HRESULT								hr = DPNH_OK;
	CDevice *							pDevice;
	SOCKADDR_IN *						pasaddrinPrivate;
	UCHAR								ucProtocolToMatch;
	ULONG								ulNumFound;
	BOOLEAN								fTemp;
	IHNetProtocolSettings *				pHNetProtocolSettings = NULL;
	IEnumHNetPortMappingProtocols *		pEnumHNetPortMappingProtocols = NULL;
	IHNetPortMappingProtocol **			papHNetPortMappingProtocol = NULL;
	DWORD								dwTemp;
	BOOL								fCreatedCurrentPortMappingProtocol = FALSE;
	IHNetPortMappingBinding *			pHNetPortMappingBinding = NULL;
	DWORD								dwTargetAddressV4;
	WORD								wPort;
	UCHAR								ucProtocol;
	DWORD								dwDescriptionLength;
	TCHAR								tszPort[32];
	CRegistry							RegObject;
	WCHAR								wszDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	DPNHACTIVEFIREWALLMAPPING			dpnhafm;
	BOOLEAN								fBuiltIn = FALSE;
	WCHAR *								pwszPortMappingProtocolName = NULL;
#ifdef UNICODE
	TCHAR *								ptszDescription = wszDescription;
#else // ! UNICODE
	char								szDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	TCHAR *								ptszDescription = szDescription;
#endif // ! UNICODE


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, %i)",
		this, pRegisteredPort, pHNetCfgMgr, pHNetConnection, fNoteAddressChange);


	DNASSERT(! pRegisteredPort->IsMappedOnHNetFirewall());
	DNASSERT(! pRegisteredPort->IsHNetFirewallPortUnavailable());


	pDevice = pRegisteredPort->GetOwningDevice();
	DNASSERT(pDevice != NULL);
	DNASSERT(pDevice->IsHNetFirewalled());


	//
	// Get a protocol settings interface.
	//
	hr = pHNetCfgMgr->QueryInterface(IID_IHNetProtocolSettings,
									(PVOID*) (&pHNetProtocolSettings));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't get IHNetProtocolSettings interface from IHNetCfgMgr 0x%p (err = 0x%lx)!",
			pHNetCfgMgr, hr);
		goto Failure;
	}

	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pHNetProtocolSettings);


	//
	// Get ready to enumerate the existing mappings.
	//

	hr = pHNetProtocolSettings->EnumPortMappingProtocols(&pEnumHNetPortMappingProtocols);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't enumerate port mapping protocols (err = 0x%lx)!",
			hr);
		goto Failure;
	}

	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pEnumHNetPortMappingProtocols);


	//
	// Allocate an array to keep track of previous ports in case of failure.
	//
	papHNetPortMappingProtocol = (IHNetPortMappingProtocol**) DNMalloc(DPNH_MAX_SIMULTANEOUS_PORTS * sizeof(IHNetPortMappingProtocol*));
	if (papHNetPortMappingProtocol == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}



	pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

	if (pRegisteredPort->IsTCP())
	{
		ucProtocolToMatch = PORTMAPPINGPROTOCOL_TCP;
	}
	else
	{
		ucProtocolToMatch = PORTMAPPINGPROTOCOL_UDP;
	}


	//
	// Map each individual address associated with the port.
	//
	for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
	{
		DNASSERT(pasaddrinPrivate[dwTemp].sin_port != 0);


		//
		// Loop until we find a duplicate item or run out of items.
		//
		do
		{
			hr = pEnumHNetPortMappingProtocols->Next(1,
													&papHNetPortMappingProtocol[dwTemp],
													&ulNumFound);
			if (FAILED(hr))
			{
				DPFX(DPFPREP, 0, "Couldn't get next port mapping protocol (err = 0x%lx)!",
					hr);
				goto Failure;
			}


			//
			// If there aren't any more items, bail.
			//
			if (ulNumFound == 0)
			{
				//
				// pEnumHNetPortMappingProtocols->Next might have returned
				// S_FALSE.
				//
				hr = DPNH_OK;
				break;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(papHNetPortMappingProtocol[dwTemp]);


			//
			// Get the port.
			//
			hr = papHNetPortMappingProtocol[dwTemp]->GetPort(&wPort);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get port mapping protocol 0x%p's port (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);

				DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetPort!"), 2);

				goto Failure;
			}


			//
			// Get the protocol.
			//
			hr = papHNetPortMappingProtocol[dwTemp]->GetIPProtocol(&ucProtocol);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get port mapping protocol 0x%p's IP protocol (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);

				DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetIPProtocol!"), 2);

				goto Failure;
			}


#ifdef DBG
			hr = papHNetPortMappingProtocol[dwTemp]->GetName(&pwszPortMappingProtocolName);
			if (hr == S_OK)
			{
				DPFX(DPFPREP, 7, "Found %s port mapping protocol 0x%p (\"%ls\") for port %u.",
					(((wPort == pasaddrinPrivate[dwTemp].sin_port) && (ucProtocol == ucProtocolToMatch)) ? _T("matching") : _T("non-matching")),
					papHNetPortMappingProtocol[dwTemp],
					pwszPortMappingProtocolName,
					NTOHS(wPort));

				CoTaskMemFree(pwszPortMappingProtocolName);
				pwszPortMappingProtocolName = NULL;
			}
			else
			{
				DPFX(DPFPREP, 7, "Found %s port mapping protocol 0x%p for port %u, (unable to retrieve name, err = %0lx).",
					(((wPort == pasaddrinPrivate[dwTemp].sin_port) && (ucProtocol == ucProtocolToMatch)) ? _T("matching") : _T("non-matching")),
					NTOHS(wPort),
					papHNetPortMappingProtocol[dwTemp],
					hr);
			}
#endif // DBG

			//
			// See if we found the object we need.
			//
			if ((wPort == pasaddrinPrivate[dwTemp].sin_port) &&
				(ucProtocol == ucProtocolToMatch))
			{
				break;
			}


			//
			// Get ready for the next object.
			//
			papHNetPortMappingProtocol[dwTemp]->Release();
			papHNetPortMappingProtocol[dwTemp] = NULL;
		}
		while (TRUE);


		//
		// Generate a description for this mapping.  The format is:
		//
		//     [executable_name] nnnnn {"TCP" | "UDP"}
		//
		// unless it's shared, in which case it's
		//
		//     [executable_name] (255.255.255.255:nnnnn) nnnnn {"TCP" | "UDP"}
		//
		// That way nothing needs to be localized.
		//

		wsprintf(tszPort, _T("%u"),
				NTOHS(pasaddrinPrivate[dwTemp].sin_port));

		dwDescriptionLength = GetModuleFileName(NULL,
												ptszDescription,
												(MAX_UPNP_MAPPING_DESCRIPTION_SIZE - 1));
		if (dwDescriptionLength != 0)
		{
			//
			// Be paranoid and make sure the description string is valid.
			//
			ptszDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE - 1] = 0;

			//
			// Get just the executable name from the path.
			//
#ifdef WINCE
			GetExeName(ptszDescription);
#else // ! WINCE
#ifdef UNICODE
			_wsplitpath(ptszDescription, NULL, NULL, ptszDescription, NULL);
#else // ! UNICODE
			_splitpath(ptszDescription, NULL, NULL, ptszDescription, NULL);
#endif // ! UNICODE
#endif // ! WINCE


			if (pRegisteredPort->IsSharedPort())
			{
				dwDescriptionLength = _tcslen(ptszDescription)		// executable name
									+ strlen(" (255.255.255.255:")	// " (255.255.255.255:"
									+ _tcslen(tszPort)				// port
									+ strlen(") ")					// ") "
									+ _tcslen(tszPort)				// port
									+ 4;							// " TCP" | " UDP"
			}
			else
			{
				dwDescriptionLength = _tcslen(ptszDescription)	// executable name
									+ 1							// " "
									+_tcslen(tszPort)			// port
									+ 4;						// " TCP" | " UDP"
			}

			//
			// Make sure the long string will fit.  If not, use the
			// abbreviated version.
			//
			if (dwDescriptionLength > MAX_UPNP_MAPPING_DESCRIPTION_SIZE)
			{
				dwDescriptionLength = 0;
			}
		}

		if (dwDescriptionLength == 0)
		{
			//
			// Use the abbreviated version we know will fit.
			//
			if (pRegisteredPort->IsSharedPort())
			{
				wsprintf(ptszDescription,
						_T("(255.255.255.255:%s) %s %s"),
						tszPort,
						tszPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}
			else
			{
				wsprintf(ptszDescription,
						_T("%s %s"),
						tszPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}
		}
		else
		{
			//
			// There's enough room, tack on the rest of the description.
			//
			if (pRegisteredPort->IsSharedPort())
			{
				wsprintf((ptszDescription + _tcslen(ptszDescription)),
						_T(" (255.255.255.255:%s) %s %s"),
						tszPort,
						tszPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}
			else
			{
				wsprintf((ptszDescription + _tcslen(ptszDescription)),
						_T(" %s %s"),
						tszPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}
		}

#ifndef UNICODE
		dwDescriptionLength = MAX_UPNP_MAPPING_DESCRIPTION_SIZE;
		hr = STR_AnsiToWide(szDescription, -1, wszDescription, &dwDescriptionLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert NAT mapping description to Unicode (err = 0x%lx)!",
				hr);
			goto Failure;
		}
#endif // ! UNICODE



		//
		// If there wasn't a port mapping already, create it.  Otherwise make
		// sure it's not already in use by some other client.
		//
		if (papHNetPortMappingProtocol[dwTemp] == NULL)
		{
			DPFX(DPFPREP, 7, "Creating new port mapping protocol \"%ls\".",
				wszDescription);


			//
			// Create a new port mapping protocol.
			//
			DPFX(DPFPREP, 9, "++ pHNetProtocolSettings(0x%p)->CreatePortMappingProtocol(\"%ls\", %u, 0x%lx, 0x%p)", pHNetProtocolSettings, wszDescription, ucProtocolToMatch, pasaddrinPrivate[dwTemp].sin_port, &papHNetPortMappingProtocol[dwTemp]);
			hr = pHNetProtocolSettings->CreatePortMappingProtocol(wszDescription,
																ucProtocolToMatch,
																pasaddrinPrivate[dwTemp].sin_port,
																&papHNetPortMappingProtocol[dwTemp]);
			DPFX(DPFPREP, 9, "-- pHNetProtocolSettings(0x%p)->CreatePortMappingProtocol = 0x%lx", pHNetProtocolSettings, hr);
			if (hr != S_OK)
			{
				//
				// This might be WBEM_E_ACCESSDENIED (0x80041003), which means
				// the current user doesn't have permissions to open holes in
				// the firewall.
				//

				DPFX(DPFPREP, 0, "Couldn't create new port mapping protocol (err = 0x%lx)!",
					hr);

				goto Failure;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(papHNetPortMappingProtocol[dwTemp]);


			fCreatedCurrentPortMappingProtocol = TRUE;



			//
			// Retrieve its binding.
			//
			DPFX(DPFPREP, 9, "++ pHNetConnection(0x%p)->GetBindingForPortMappingProtocol(0x%p, 0x%p)", pHNetConnection, papHNetPortMappingProtocol[dwTemp], &pHNetPortMappingBinding);
			hr = pHNetConnection->GetBindingForPortMappingProtocol(papHNetPortMappingProtocol[dwTemp],
																&pHNetPortMappingBinding);
			DPFX(DPFPREP, 9, "-- pHNetConnection(0x%p)->GetBindingForPortMappingProtocol = 0x%lx", pHNetConnection, hr);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get binding for port mapping protocol 0x%p (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);
				goto Failure;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(pHNetPortMappingBinding);


			//
			// Make sure it refers to the local device (or the broadcast
			// address, if shared).  Although shared ports are a strange
			// concept on a firewall, Microsoft's firewall implementation
			// shares mappings with the NAT, so we'd rather be safe than sorry.
			// Mapping it to the broadcast address makes it behave the same if
			// the firewalled adapter also happens to be shared.
			//
			if (pRegisteredPort->IsSharedPort())
			{
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress((broadcast) 0x%lx)", pHNetPortMappingBinding, INADDR_BROADCAST);
				hr = pHNetPortMappingBinding->SetTargetComputerAddress(INADDR_BROADCAST);
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			}
			else
			{
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress(0x%lx)", pHNetPortMappingBinding, pDevice->GetLocalAddressV4());
				hr = pHNetPortMappingBinding->SetTargetComputerAddress(pDevice->GetLocalAddressV4());
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			}
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't set binding 0x%p's target computer address (err = 0x%lx)!",
					pHNetPortMappingBinding, hr);
				goto Failure;
			}
		}
		else
		{
			//
			// Retrieve the existing binding.
			//
			DPFX(DPFPREP, 9, "++ pHNetConnection(0x%p)->GetBindingForPortMappingProtocol(0x%p, 0x%p)", pHNetConnection, papHNetPortMappingProtocol[dwTemp], &pHNetPortMappingBinding);
			hr = pHNetConnection->GetBindingForPortMappingProtocol(papHNetPortMappingProtocol[dwTemp],
																&pHNetPortMappingBinding);
			DPFX(DPFPREP, 9, "-- pHNetConnection(0x%p)->GetBindingForPortMappingProtocol = 0x%lx", pHNetConnection, hr);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get binding for port mapping protocol 0x%p (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);
				goto Failure;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(pHNetPortMappingBinding);


			//
			// Find out where this mapping goes.
			//
			DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->GetTargetComputerAddress(0x%p)", pHNetPortMappingBinding, &dwTargetAddressV4);
			hr = pHNetPortMappingBinding->GetTargetComputerAddress(&dwTargetAddressV4);
			DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->GetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get binding 0x%p's target computer address (err = 0x%lx)!",
					pHNetPortMappingBinding, hr);
				goto Failure;
			}


			//
			// If it's not for the local device, we may have to leave it alone.
			//
			if ((dwTargetAddressV4 != pDevice->GetLocalAddressV4()) &&
				((! pRegisteredPort->IsSharedPort()) ||
				(dwTargetAddressV4 != INADDR_BROADCAST)))
			{
				//
				// Find out if it's turned on.
				//
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->GetEnabled(0x%p)", pHNetPortMappingBinding, &fTemp);
				hr = pHNetPortMappingBinding->GetEnabled(&fTemp);
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->GetEnabled = 0x%lx", pHNetPortMappingBinding, hr);
				if (hr != S_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't get binding 0x%p's target computer address (err = 0x%lx)!",
						pHNetPortMappingBinding, hr);
					goto Failure;
				}


				//
				// If it's currently active, it's better to be safe than sorry.
				// Don't attempt to replace it.
				//
				if (fTemp)
				{
					DPFX(DPFPREP, 1, "Existing active binding points to different target %u.%u.%u.%u, can't reuse for device 0x%p.",
						((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b1,
						((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b2,
						((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b3,
						((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b4,
						pDevice);
					
					//
					// Mark this port as unavailable.
					//
					pRegisteredPort->NoteHNetFirewallPortUnavailable();


					//
					// Cleanup this port mapping.
					//

					pHNetPortMappingBinding->Release();
					pHNetPortMappingBinding = NULL;

					papHNetPortMappingProtocol[dwTemp]->Release();
					papHNetPortMappingProtocol[dwTemp] = NULL;


					//
					// Reset for next port.
					//
					DPFX(DPFPREP, 9, "++ pEnumHNetPortMappingProtocols(0x%p)->Reset()", pEnumHNetPortMappingProtocols);
					hr = pEnumHNetPortMappingProtocols->Reset();
					DPFX(DPFPREP, 9, "-- pEnumHNetPortMappingProtocols(0x%p)->Reset = 0x%lx", pEnumHNetPortMappingProtocols, hr);
					if (hr != S_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't reset port mapping protocol enumeration 0x%p (err = 0x%lx)!",
							pEnumHNetPortMappingProtocols, hr);
						goto Failure;
					}


					//
					// Get out of the loop.
					//
					break;
				}


				//
				// It's inactive.
				//
				DPFX(DPFPREP, 7, "Modifying inactive port mapping protocol (target was %u.%u.%u.%u) for device 0x%p (new name = \"%ls\").",
					((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b1,
					((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b2,
					((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b3,
					((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b4,
					pDevice,
					wszDescription);
			}
			else
			{
				//
				// It matches the local device, or we're mapping a shared port
				// and the mapping pointed to the broadcast address.
				// Assume it's okay to replace.
				//
				DPFX(DPFPREP, 7, "Modifying existing port mapping protocol (device = 0x%p, new name = \"%ls\" unless built-in).",
					pDevice,
					wszDescription);
			}


			//
			// Otherwise, it's safe to change it.
			//


			//
			// Make sure it refers to the local device (or the broadcast
			// address, if shared).  Although shared ports are a strange
			// concept on a firewall, Microsoft's firewall implementation
			// shares mappings with the NAT, so we'd rather be safe than sorry.
			// Mapping it to the broadcast address makes it behave the same if
			// the firewalled adapter also happens to be shared.
			//
			if (pRegisteredPort->IsSharedPort())
			{
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress((broadcast) 0x%lx)", pHNetPortMappingBinding, INADDR_BROADCAST);
				hr = pHNetPortMappingBinding->SetTargetComputerAddress(INADDR_BROADCAST);
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			}
			else
			{
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress(0x%lx)", pHNetPortMappingBinding, pDevice->GetLocalAddressV4());
				hr = pHNetPortMappingBinding->SetTargetComputerAddress(pDevice->GetLocalAddressV4());
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			}

			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't set binding 0x%p's target computer address (err = 0x%lx)!",
					pHNetPortMappingBinding, hr);
				goto Failure;
			}


			//
			// See if this protocol is built-in.
			//
			DPFX(DPFPREP, 9, "++ papHNetPortMappingProtocol[%u](0x%p)->GetBuiltIn(0x%p)", dwTemp, papHNetPortMappingProtocol[dwTemp], &fBuiltIn);
			hr = papHNetPortMappingProtocol[dwTemp]->GetBuiltIn(&fBuiltIn);
			DPFX(DPFPREP, 9, "-- papHNetPortMappingProtocol[%u](0x%p)->GetBuiltIn = 0x%lx", dwTemp, papHNetPortMappingProtocol[dwTemp], hr);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get protocol 0x%p's built-in status (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);
				goto Failure;
			}


			//
			// If it's not built-in, we can change the name.
			//
			if (! fBuiltIn)
			{
				//
				// Update the description.
				//
				DPFX(DPFPREP, 9, "++ papHNetPortMappingProtocol[%u](0x%p)->SetName(\"%ls\")", dwTemp, papHNetPortMappingProtocol[dwTemp], wszDescription);
				hr = papHNetPortMappingProtocol[dwTemp]->SetName(wszDescription);
				DPFX(DPFPREP, 9, "-- papHNetPortMappingProtocol[%u](0x%p)->SetName = 0x%lx", dwTemp, papHNetPortMappingProtocol[dwTemp], hr);
				if (hr != S_OK)
				{
					//
					// This might be WBEM_E_ACCESSDENIED (0x80041003), which
					// means the current user doesn't truly have permissions to
					// open holes in the firewall (even though the
					// SetTargetComputerAddress call above succeeded).
					//

					DPFX(DPFPREP, 0, "Couldn't rename existing port mapping protocol 0x%p (err = 0x%lx)!",
						papHNetPortMappingProtocol[dwTemp], hr);
					goto Failure;
				}
			}
			else
			{
				pRegisteredPort->NoteHNetFirewallMappingBuiltIn();


				DPFX(DPFPREP, 9, "++ papHNetPortMappingProtocol[%u](0x%p)->GetName(0x%p)", dwTemp, papHNetPortMappingProtocol[dwTemp], &pwszPortMappingProtocolName);
				hr = papHNetPortMappingProtocol[dwTemp]->GetName(&pwszPortMappingProtocolName);
				DPFX(DPFPREP, 9, "-- papHNetPortMappingProtocol[%u](0x%p)->GetName = 0x%lx", dwTemp, papHNetPortMappingProtocol[dwTemp], hr);
				if (hr != S_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't get built-in port mapping protocol 0x%p's name (err = 0x%lx)!",
						papHNetPortMappingProtocol[dwTemp], hr);
					goto Failure;
				}


				DPFX(DPFPREP, 1, "Re-using built in port mapping protocol \"%ls\" (can't rename to \"%ls\").",
					pwszPortMappingProtocolName, wszDescription);
			}
		} // end else (found port mapping protocol)


		//
		// Enable the binding.
		//
		DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetEnabled(TRUE)", pHNetPortMappingBinding);
		hr = pHNetPortMappingBinding->SetEnabled(TRUE);
		DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetEnabled = 0x%lx", pHNetPortMappingBinding, hr);
		if (hr != S_OK)
		{
			//
			// This might be WBEM_E_ACCESSDENIED (0x80041003), which means the
			// current user doesn't truly have permissions to open holes in the
			// firewall (even though the SetTargetComputerAddress call above
			// succeeded).
			//

			DPFX(DPFPREP, 0, "Couldn't enable binding 0x%p (err = 0x%lx)!",
				pHNetPortMappingBinding, hr);
			goto Failure;
		}


		//
		// Remember this firewall mapping, in case we crash before cleaning it
		// up in this session.  That we can clean it up next time we launch.
		// Don't do this if the port is shared, since we can't tell when it's
		// no longer in use.
		//
		if (! pRegisteredPort->IsSharedPort())
		{
			if (fBuiltIn)
			{
				DPFX(DPFPREP, 7, "Remembering built-in firewall mapping \"%ls\" (a.k.a. \"%ls\") in case of crash.",
					pwszPortMappingProtocolName, wszDescription);
			}
			else
			{
				DPFX(DPFPREP, 7, "Remembering regular firewall mapping \"%ls\" in case of crash.",
					wszDescription);
			}

			if (! RegObject.Open(HKEY_LOCAL_MACHINE,
								DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVEFIREWALLMAPPINGS,
								FALSE,
								TRUE,
								TRUE,
								DPN_KEY_ALL_ACCESS))
			{
				DPFX(DPFPREP, 0, "Couldn't open active firewall mapping key, unable to save in case of crash!");
			}
			else
			{
				DNASSERT(this->m_dwInstanceKey != 0);


				ZeroMemory(&dpnhafm, sizeof(dpnhafm));
				dpnhafm.dwVersion		= ACTIVE_MAPPING_VERSION;
				dpnhafm.dwInstanceKey	= this->m_dwInstanceKey;
				dpnhafm.dwFlags			= pRegisteredPort->GetFlags();
				dpnhafm.dwAddressV4		= pDevice->GetLocalAddressV4();
				dpnhafm.wPort			= pasaddrinPrivate[dwTemp].sin_port;


				//
				// If it's built-in, use its existing name since it couldn't be
				// renamed.  This allows the unmapping code to find it in the
				// registry again.  See UnmapPortOnLocalHNetFirewallInternal.
				//
				RegObject.WriteBlob(((fBuiltIn) ? pwszPortMappingProtocolName : wszDescription),
									(LPBYTE) (&dpnhafm),
									sizeof(dpnhafm));

				RegObject.Close();
			}
		}
		else
		{
			DPFX(DPFPREP, 7, "Not remembering shared port firewall mapping \"%ls\".",
				wszDescription);
		}


		//
		// Cleanup from this port mapping, and get ready for the next one.
		//

		if (fBuiltIn)
		{
			CoTaskMemFree(pwszPortMappingProtocolName);
			pwszPortMappingProtocolName = NULL;
		}

		pHNetPortMappingBinding->Release();
		pHNetPortMappingBinding = NULL;


		fCreatedCurrentPortMappingProtocol = FALSE;


		hr = pEnumHNetPortMappingProtocols->Reset();
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't reset port mapping protocol enumeration 0x%p (err = 0x%lx)!",
				pEnumHNetPortMappingProtocols, hr);
			goto Failure;
		}


		//
		// Alert the user to the change the next time GetCaps is called, if
		// requested.
		//
		if (fNoteAddressChange)
		{
			DPFX(DPFPREP, 8, "Noting that addresses changed (for registered port 0x%p).",
				pRegisteredPort);
			this->m_dwFlags |= NATHELPUPNPOBJ_ADDRESSESCHANGED;
		}


		//
		// Go on to the next port.
		//
	}


	//
	// dwTemp == pRegisteredPort->GetNumAddresses() if everything succeeded, or
	// or the index of the item that was unavailable if not.
	//

	//
	// Free all the port mapping protocol objects.  If we successfully bound
	// all of them, that's all we need to do.  If the port was unavailable, we
	// have to unmap any ports that were successful up to the one that failed.
	//
	while (dwTemp > 0)
	{
		dwTemp--;

		//
		// If we failed to map all ports, delete this previous mapping.
		//
		if (pRegisteredPort->IsHNetFirewallPortUnavailable())
		{
			papHNetPortMappingProtocol[dwTemp]->Delete();	// ignore error
		}

		//
		// Free the object.
		// 
		papHNetPortMappingProtocol[dwTemp]->Release();
		papHNetPortMappingProtocol[dwTemp] = NULL;
	}


	//
	// If we succeeded, mark the registered port as mapped.
	//
	if (! pRegisteredPort->IsHNetFirewallPortUnavailable())
	{
		pRegisteredPort->NoteMappedOnHNetFirewall();
	}



	DNFree(papHNetPortMappingProtocol);
	papHNetPortMappingProtocol = NULL;


	DNASSERT(hr == DPNH_OK);


Exit:

	if (pEnumHNetPortMappingProtocols != NULL)
	{
		pEnumHNetPortMappingProtocols->Release();
		pEnumHNetPortMappingProtocols = NULL;
	}

	if (pHNetProtocolSettings != NULL)
	{
		pHNetProtocolSettings->Release();
		pHNetProtocolSettings = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pwszPortMappingProtocolName != NULL)
	{
		CoTaskMemFree(pwszPortMappingProtocolName);
		pwszPortMappingProtocolName = NULL;
	}

	//
	// If we have an array, then we need to clean it up.  dwTemp will still
	// hold the index of the item we were working on.
	//
	if (papHNetPortMappingProtocol != NULL)
	{
		//
		// Delete the one we were working on, if we created it.
		//
		if (papHNetPortMappingProtocol[dwTemp] != NULL)
		{
			if (fCreatedCurrentPortMappingProtocol)
			{
				papHNetPortMappingProtocol[dwTemp]->Delete();	// ignore error
			}

			papHNetPortMappingProtocol[dwTemp]->Release();
			papHNetPortMappingProtocol[dwTemp] = NULL;
		}


		//
		// Delete all the mappings we successfully made up to the last one.
		//
		while (dwTemp > 0)
		{
			dwTemp--;


			DNASSERT(papHNetPortMappingProtocol[dwTemp] != NULL);

			papHNetPortMappingProtocol[dwTemp]->Delete();	// ignore error

			papHNetPortMappingProtocol[dwTemp]->Release();
			papHNetPortMappingProtocol[dwTemp] = NULL;
		}

		DNFree(papHNetPortMappingProtocol);
		papHNetPortMappingProtocol = NULL;
	}

	if (pHNetPortMappingBinding != NULL)
	{
		pHNetPortMappingBinding->Release();
		pHNetPortMappingBinding = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::MapPortOnLocalHNetFirewall





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::UnmapPortOnLocalHNetFirewall"
//=============================================================================
// CNATHelpUPnP::UnmapPortOnLocalHNetFirewall
//-----------------------------------------------------------------------------
//
// Description:    Removes the mappings for the given ports from the local
//				firewall.
//
//				   The main object lock is assumed to be held.  It will be
//				converted into the long lock for the duration of this function.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Pointer to port to be opened on the
//											firewall.
//	BOOL fNeedToDeleteRegValue			- Whether the corresponding crash
//											recovery registry value needs to
//											be deleted as well.
//	BOOL fNoteAddressChange				- Whether to alert the user of the
//											address change or not.
//
// Returns: HRESULT
//	DPNH_OK				- Unmapping completed successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::UnmapPortOnLocalHNetFirewall(CRegisteredPort * const pRegisteredPort,
												const BOOL fNeedToDeleteRegValue,
												const BOOL fNoteAddressChange)
{
	HRESULT			hr = DPNH_OK;
	BOOL			fSwitchedToLongLock = FALSE;
	BOOL			fUninitializeCOM = FALSE;
	IHNetCfgMgr *	pHNetCfgMgr = NULL;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i, %i)",
		this, pRegisteredPort, fNeedToDeleteRegValue, fNoteAddressChange);


	DNASSERT(pRegisteredPort->IsMappedOnHNetFirewall());



	//
	// If the port is shared, leave it mapped since we can't tell when the
	// last person using it is done with it.
	//
	if (pRegisteredPort->IsSharedPort())
	{
		DPFX(DPFPREP, 2, "Leaving shared registered port 0x%p mapped.",
			pRegisteredPort);

		//
		// Pretend like we unmapped it, though.
		//
		pRegisteredPort->NoteNotMappedOnHNetFirewall();
		pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

		goto Exit;
	}


	//
	// Using the HomeNet API (particularly the out-of-proc COM calls) during
	// stress is really, really, painfully slow.  Since we have one global lock
	// the controls everything, other threads may be sitting for an equally
	// long time... so long, in fact, that the critical section timeout fires
	// and we get a false stress hit.  So we have a sneaky workaround to
	// prevent that from happening while still maintaining ownership of the
	// object.
	//
	this->SwitchToLongLock();
	fSwitchedToLongLock = TRUE;


	//
	// Try to initialize COM if we weren't instantiated through COM.  It may
	// have already been initialized in a different mode, which is okay.  As
	// long as it has been initialized somehow, we're fine.
	//
	if (this->m_dwFlags & NATHELPUPNPOBJ_NOTCREATEDWITHCOM)
	{
		hr = CoInitializeEx(NULL, (COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE));
		switch (hr)
		{
			case S_OK:
			{
				//
				// Success, that's good.  Cleanup when we're done.
				//
				DPFX(DPFPREP, 8, "Successfully initialized COM.");
				fUninitializeCOM = TRUE;
				break;
			}

			case S_FALSE:
			{
				//
				// Someone else already initialized COM, but that's okay.
				// Cleanup when we're done.
				//
				DPFX(DPFPREP, 8, "Initialized COM (again).");
				fUninitializeCOM = TRUE;
				break;
			}

			case RPC_E_CHANGED_MODE:
			{
				//
				// Someone else already initialized COM in a different mode.
				// It should be okay, but we don't have to balance the CoInit
				// call with a CoUninit.
				//
				DPFX(DPFPREP, 8, "Didn't initialize COM, already initialized in a different mode.");
				break;
			}

			default:
			{
				//
				// Hmm, something else is going on.  We can't handle that.
				//
				DPFX(DPFPREP, 0, "Initializing COM failed (err = 0x%lx)!", hr);
				goto Failure;
				break;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 8, "Object was instantiated through COM, no need to initialize COM.");
	}


	//
	// Create the main HNet manager object.
	//
	hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, CLSCTX_INPROC_SERVER,
						IID_IHNetCfgMgr, (PVOID*) (&pHNetCfgMgr));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 1, "Couldn't create IHNetCfgMgr interface (err = 0x%lx)!",
			hr);
		goto Failure;
	}


	//
	// We created the IHNetCfgMgr object as in-proc, so there's no proxy that
	// requires security settings.
	//
	//SETDEFAULTPROXYBLANKET(pHNetCfgMgr);


	//
	// Actually unmap the port(s).
	//
	hr = this->UnmapPortOnLocalHNetFirewallInternal(pRegisteredPort,
													fNeedToDeleteRegValue,
													pHNetCfgMgr);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't unmap ports from local HNet firewall (err = 0x%lx)!",
			hr);
		goto Failure;
	}

	
	//
	// Alert the user to the change the next time GetCaps is called, if requested.
	//
	if (fNoteAddressChange)
	{
		DPFX(DPFPREP, 8, "Noting that addresses changed (for registered port 0x%p).",
			pRegisteredPort);
		this->m_dwFlags |= NATHELPUPNPOBJ_ADDRESSESCHANGED;
	}



Exit:

	if (pHNetCfgMgr != NULL)
	{
		pHNetCfgMgr->Release();
		pHNetCfgMgr = NULL;
	}

	if (fUninitializeCOM)
	{
		DPFX(DPFPREP, 8, "Uninitializing COM.");
		CoUninitialize();
		fUninitializeCOM = FALSE;
	}

	if (fSwitchedToLongLock)
	{
		this->SwitchFromLongLock();
		fSwitchedToLongLock = FALSE;
	}


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::UnmapPortOnLocalHNetFirewall





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::UnmapPortOnLocalHNetFirewallInternal"
//=============================================================================
// CNATHelpUPnP::UnmapPortOnLocalHNetFirewallInternal
//-----------------------------------------------------------------------------
//
// Description:    Removes the mappings for the given ports from the local
//				firewall.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Pointer to port to be opened on the
//											firewall.
//	BOOL fNeedToDeleteRegValue			- Whether the corresponding crash
//											recovery registry value needs to
//											be deleted as well.
//	IHNetCfgMgr * pHNetCfgMgr			- Pointer to IHNetCfgMgr interface to
//											use.
//
// Returns: HRESULT
//	DPNH_OK				- Unmapping completed successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::UnmapPortOnLocalHNetFirewallInternal(CRegisteredPort * const pRegisteredPort,
															const BOOL fNeedToDeleteRegValue,
															IHNetCfgMgr * const pHNetCfgMgr)
{
	HRESULT								hr = DPNH_OK;
	CDevice *							pDevice;
	DWORD								dwAttempts = 0;
	IHNetProtocolSettings *				pHNetProtocolSettings = NULL;
	IEnumHNetPortMappingProtocols *		pEnumHNetPortMappingProtocols = NULL;
	SOCKADDR_IN *						pasaddrinPrivate;
	UCHAR								ucProtocolToMatch;
	IHNetPortMappingProtocol *			pHNetPortMappingProtocol = NULL;
	DWORD								dwStartingPort = 0;
	DWORD								dwTemp;
	ULONG								ulNumFound;
	WORD								wPort;
	UCHAR								ucProtocol;
	WCHAR *								pwszName = NULL;
	BOOLEAN								fBuiltIn;
	CRegistry							RegObject;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i, 0x%p)",
		this, pRegisteredPort, fNeedToDeleteRegValue, pHNetCfgMgr);


	DNASSERT(pRegisteredPort->IsMappedOnHNetFirewall());


	pDevice = pRegisteredPort->GetOwningDevice();
	DNASSERT(pDevice != NULL);
	DNASSERT(pDevice->IsHNetFirewalled());


	DNASSERT(this->m_hIpHlpApiDLL != NULL);



Restart:


	//
	// Get a protocol settings interface.
	//
	hr = pHNetCfgMgr->QueryInterface(IID_IHNetProtocolSettings,
									(PVOID*) (&pHNetProtocolSettings));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't get IHNetProtocolSettings interface from IHNetCfgMgr 0x%p (err = 0x%lx)!",
			pHNetCfgMgr, hr);
		goto Failure;
	}


	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pHNetProtocolSettings);


	//
	// Get ready to enumerate the existing mappings.
	//

	hr = pHNetProtocolSettings->EnumPortMappingProtocols(&pEnumHNetPortMappingProtocols);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't enumerate port mapping protocols (err = 0x%lx)!",
			hr);
		goto Failure;
	}


	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pEnumHNetPortMappingProtocols);


	pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

	if (pRegisteredPort->IsTCP())
	{
		ucProtocolToMatch = PORTMAPPINGPROTOCOL_TCP;
	}
	else
	{
		ucProtocolToMatch = PORTMAPPINGPROTOCOL_UDP;
	}



	//
	// Loop through all the ports (that we haven't successfully unmapped yet).
	//
	for(dwTemp = dwStartingPort; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
	{
		//
		// Loop until we find a duplicate item or run out of items.
		//
		do
		{
			hr = pEnumHNetPortMappingProtocols->Next(1,
													&pHNetPortMappingProtocol,
													&ulNumFound);
			if (FAILED(hr))
			{
				dwAttempts++;
				if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
				{
					DPFX(DPFPREP, 0, "Couldn't get next port mapping protocol (err = 0x%lx)!  Trying again after %u ms.",
						hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

					//
					// Dump the object pointers we currently have.
					//

					pEnumHNetPortMappingProtocols->Release();
					pEnumHNetPortMappingProtocols = NULL;

					pHNetProtocolSettings->Release();
					pHNetProtocolSettings = NULL;


					//
					// Sleep, then go back to the top and try again.
					//
					Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
					goto Restart;
				}


				DPFX(DPFPREP, 0, "Couldn't get next port mapping protocol (err = 0x%lx)!",
					hr);
				goto Failure;
			}


			//
			// If there aren't any more items, bail.
			//
			if (ulNumFound == 0)
			{
				//
				// Be sure that IEnumHNetPortMappingProtocols::Next returned
				// the right thing, for PREfix's sake.
				//
				if (pHNetPortMappingProtocol != NULL)
				{
					pHNetPortMappingProtocol->Release();
					pHNetPortMappingProtocol = NULL;
				}


				//
				// pEnumHNetPortMappingProtocols->Next might have returned
				// S_FALSE.
				//
				hr = DPNH_OK;
				break;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(pHNetPortMappingProtocol);


			//
			// Get the port.
			//
			hr = pHNetPortMappingProtocol->GetPort(&wPort);
			if (hr != S_OK)
			{
				DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetPort!"), 2);


				//
				// Dump the unusable mapping object.
				//
				pHNetPortMappingProtocol->Release();
				pHNetPortMappingProtocol = NULL;


				dwAttempts++;
				if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
				{
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol port (err = 0x%lx)!  Trying again after %u ms.",
						hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

					//
					// Dump the object pointers we currently have.
					//

					pEnumHNetPortMappingProtocols->Release();
					pEnumHNetPortMappingProtocols = NULL;

					pHNetProtocolSettings->Release();
					pHNetProtocolSettings = NULL;


					//
					// Sleep, then go back to the top and try again.
					//
					Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
					goto Restart;
				}


				//
				// Break out of the search loop, but continue.
				//
				DPFX(DPFPREP, 0, "Couldn't get port mapping protocol port (err = 0x%lx)!",
					hr);
				break;
			}


			//
			// Get the protocol.
			//
			hr = pHNetPortMappingProtocol->GetIPProtocol(&ucProtocol);
			if (hr != S_OK)
			{
				DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetIPProtocol!"), 2);


				//
				// Dump the unusable mapping object.
				//
				pHNetPortMappingProtocol->Release();
				pHNetPortMappingProtocol = NULL;


				dwAttempts++;
				if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
				{
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's IP protocol (err = 0x%lx)!  Trying again after %u ms.",
						hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

					//
					// Dump the object pointers we currently have.
					//

					pEnumHNetPortMappingProtocols->Release();
					pEnumHNetPortMappingProtocols = NULL;

					pHNetProtocolSettings->Release();
					pHNetProtocolSettings = NULL;


					//
					// Sleep, then go back to the top and try again.
					//
					Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
					goto Restart;
				}


				//
				// Break out of the search loop, but continue.
				//
				DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's IP protocol (err = 0x%lx)!",
					hr);
				break;
			}


			//
			// See if we found the object we need.  Note that we don't verify
			// the target address for simplicity (neither does UPnP).
			//
			if ((wPort == pasaddrinPrivate[dwTemp].sin_port) &&
				(ucProtocol == ucProtocolToMatch))
			{
				//
				// Retrieve the mapping name.
				//
				hr = pHNetPortMappingProtocol->GetName(&pwszName);
				if (hr != S_OK)
				{
					DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetName!"), 2);


					//
					// Dump the unusable mapping object.
					//
					pHNetPortMappingProtocol->Release();
					pHNetPortMappingProtocol = NULL;


					dwAttempts++;
					if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
					{
						DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's name (err = 0x%lx)!  Trying again after %u ms.",
							hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

						//
						// Dump the object pointers we currently have.
						//

						pEnumHNetPortMappingProtocols->Release();
						pEnumHNetPortMappingProtocols = NULL;

						pHNetProtocolSettings->Release();
						pHNetProtocolSettings = NULL;


						//
						// Sleep, then go back to the top and try again.
						//
						Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
						goto Restart;
					}


					//
					// Break out of the search loop, but continue.
					//
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's name (err = 0x%lx)!",
						hr);
					break;
				}

				DPFX(DPFPREP, 8, "Found port mapping protocol 0x%p (\"%ls\").",
					pHNetPortMappingProtocol, pwszName);

				//
				// See if this protocol is built-in.
				//
				hr = pHNetPortMappingProtocol->GetBuiltIn(&fBuiltIn);
				if (hr != S_OK)
				{
					DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetBuiltIn!"), 2);


					//
					// Dump the unusable mapping object and its name.
					//
					pHNetPortMappingProtocol->Release();
					pHNetPortMappingProtocol = NULL;

					CoTaskMemFree(pwszName);
					pwszName = NULL;


					dwAttempts++;
					if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
					{
						DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's built-in status (err = 0x%lx)!  Trying again after %u ms.",
							hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

						//
						// Dump the object pointers we currently have.
						//

						pEnumHNetPortMappingProtocols->Release();
						pEnumHNetPortMappingProtocols = NULL;

						pHNetProtocolSettings->Release();
						pHNetProtocolSettings = NULL;


						//
						// Sleep, then go back to the top and try again.
						//
						Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
						goto Restart;
					}


					//
					// Break out of the search loop, but continue.
					//
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's built-in status (err = 0x%lx)!",
						hr);
					break;
				}


				break;
			}
#ifdef DBG
			else
			{
				//
				// Try to retrieve the mapping name for informational purposes.
				//
				hr = pHNetPortMappingProtocol->GetName(&pwszName);
				if (hr != S_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol 0x%p's name (err = 0x%lx)!",
						pHNetPortMappingProtocol, hr);


					DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetName!"), 2);

					//
					// Ignore error...
					//
				}
				else
				{
					DPFX(DPFPREP, 7, "Skipping non-matching port mapping protocol 0x%p (\"%ls\").",
						pHNetPortMappingProtocol, pwszName);

					CoTaskMemFree(pwszName);
					pwszName = NULL;
				}
			}
#endif // DBG


			//
			// Get ready for the next object.
			//
			pHNetPortMappingProtocol->Release();
			pHNetPortMappingProtocol = NULL;
		}
		while (TRUE);


		//
		// Remove the mapping (if we found it).
		//
		if (pHNetPortMappingProtocol != NULL)
		{
			//
			// If the mapping is built-in we can't delete it.  Disabling it is
			// the best we can do.
			//
			if (fBuiltIn)
			{
				DPFX(DPFPREP, 7, "Disabling built-in port mapping protocol \"%ls\".", pwszName);

				DNASSERT(pRegisteredPort->IsHNetFirewallMappingBuiltIn());

				hr = this->DisableAllBindingsForHNetPortMappingProtocol(pHNetPortMappingProtocol,
																		pHNetCfgMgr);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't disable all bindings for built-in port mapping protocol \"%ls\" (err = 0x%lx)!",
						pwszName, hr);
					goto Failure;
				}
			}
			else
			{
				DPFX(DPFPREP, 7, "Deleting port mapping protocol \"%ls\".", pwszName);

				DNASSERT(! pRegisteredPort->IsHNetFirewallMappingBuiltIn());


				hr = pHNetPortMappingProtocol->Delete();
				if (hr != S_OK)
				{
					//
					// This might be WBEM_E_ACCESSDENIED (0x80041003), which
					// means the current user doesn't have permissions to
					// modify firewall mappings.
					//

					DPFX(DPFPREP, 0, "Couldn't delete port mapping protocol (err = 0x%lx)!",
						hr);
					goto Failure;
				}
			}


			if (fNeedToDeleteRegValue)
			{
				//
				// Delete the crash cleanup registry entry.  The mapping
				// description/name will match the registry key name even in
				// the case of built-in mappings with names we didn't generate.
				// See MapPortOnLocalHNetFirewall.
				//
				if (! RegObject.Open(HKEY_LOCAL_MACHINE,
									DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVEFIREWALLMAPPINGS,
									FALSE,
									TRUE,
									TRUE,
									DPN_KEY_ALL_ACCESS))
				{
					DPFX(DPFPREP, 0, "Couldn't open active firewall mapping key, unable to remove crash cleanup reference!");
				}
				else
				{
					BOOL	fResult;


					//
					// Ignore error.
					//
					fResult = RegObject.DeleteValue(pwszName);
					if (! fResult)
					{
						DPFX(DPFPREP, 0, "Couldn't delete firewall mapping value \"%ls\"!  Continuing.",
							pwszName);
					}

					RegObject.Close();
				}
			}
			else
			{
				DPFX(DPFPREP, 6, "No need to delete firewall crash cleanup registry key \"%ls\".", pwszName);
			}


			//
			// Cleanup pointers we accumulated.
			//

			CoTaskMemFree(pwszName);
			pwszName = NULL;

			pHNetPortMappingProtocol->Release();
			pHNetPortMappingProtocol = NULL;
		}
		else
		{
			//
			// We didn't find the mapping.
			//
			DPFX(DPFPREP, 0, "Didn't find port mapping protocol for port %u %s!  Continuing.",
				NTOHS(pasaddrinPrivate[dwTemp].sin_port),
				((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
		}



		//
		// Cleanup from this port mapping, and get ready for the next one.
		//

		hr = pEnumHNetPortMappingProtocols->Reset();
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't reset port mapping protocol enumeration 0x%p (err = 0x%lx)!",
				pEnumHNetPortMappingProtocols, hr);
			goto Failure;
		}


		//
		// Go on to the next port, and update the starting counter in case we
		// encounter a failure next time.
		//
		dwStartingPort++;
	}


	pRegisteredPort->NoteNotMappedOnHNetFirewall();
	pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

	
	DNASSERT(hr == DPNH_OK);


Exit:

	if (pHNetPortMappingProtocol != NULL)
	{
		pHNetPortMappingProtocol->Release();
		pHNetPortMappingProtocol = NULL;
	}

	if (pEnumHNetPortMappingProtocols != NULL)
	{
		pEnumHNetPortMappingProtocols->Release();
		pEnumHNetPortMappingProtocols = NULL;
	}

	if (pHNetProtocolSettings != NULL)
	{
		pHNetProtocolSettings->Release();
		pHNetProtocolSettings = NULL;
	}


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pwszName != NULL)
	{
		CoTaskMemFree(pwszName);
		pwszName = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::UnmapPortOnLocalHNetFirewallInternal





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::DisableAllBindingsForHNetPortMappingProtocol"
//=============================================================================
// CNATHelpUPnP::DisableAllBindingsForHNetPortMappingProtocol
//-----------------------------------------------------------------------------
//
// Description:    Disables all HNetPortMappingBindings on all HNetConnection
//				interfaces for the given port mapping protocol object.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	IHNetPortMappingProtocol * pHNetPortMappingProtocol		- Pointer to port
//																mapping
//																protocol to
//																disable on all
//																connections.
//	IHNetCfgMgr * pHNetCfgMgr								- Pointer to
//																IHNetCfgMgr
//																interface to
//																use.
//
// Returns: HRESULT
//	DPNH_OK							- Disabling was successful.
//	DPNHERR_GENERIC					- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::DisableAllBindingsForHNetPortMappingProtocol(IHNetPortMappingProtocol * const pHNetPortMappingProtocol,
																IHNetCfgMgr * const pHNetCfgMgr)
{
	HRESULT						hr;
	INetConnectionManager *		pNetConnectionManager = NULL;
	IEnumNetConnection *		pEnumNetConnections = NULL;
	ULONG						ulNumFound;
	INetConnection *			pNetConnection = NULL;
	IHNetConnection *			pHNetConnection = NULL;
	IHNetPortMappingBinding *	pHNetPortMappingBinding = NULL;
#ifdef DBG
	WCHAR *						pwszName = NULL;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pHNetPortMappingProtocol, pHNetCfgMgr);


	//
	// Try creating the base connection object.
	//
	hr = CoCreateInstance(CLSID_ConnectionManager,
						NULL,
						CLSCTX_SERVER,
						IID_INetConnectionManager,
						(PVOID*) (&pNetConnectionManager));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create INetConnectionManager interface (err = 0x%lx)!",
			hr);
		goto Failure;
	}

	SETDEFAULTPROXYBLANKET(pNetConnectionManager);


	DPFX(DPFPREP, 7, "Successfully created net connection manager object 0x%p.",
		pNetConnectionManager);


	//
	// Get the net connection enumeration object.
	//
	hr = pNetConnectionManager->EnumConnections(NCME_DEFAULT, &pEnumNetConnections);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't enum connections (err = 0x%lx)!",
			hr);
		goto Failure;
	}

	SETDEFAULTPROXYBLANKET(pEnumNetConnections);


	//
	// We don't need the base object anymore.
	//
	pNetConnectionManager->Release();
	pNetConnectionManager = NULL;


	//
	// Keep looping until we find the item or run out of items.
	//
	do
	{
		hr = pEnumNetConnections->Next(1, &pNetConnection, &ulNumFound);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "Couldn't get next connection (err = 0x%lx)!",
				hr);
			goto Failure;
		}


		//
		// If there aren't any more items, bail.
		//
		if (ulNumFound == 0)
		{
			//
			// pEnumNetConnections->Next might have returned S_FALSE.
			//
			hr = DPNH_OK;
			break;
		}


		SETDEFAULTPROXYBLANKET(pNetConnection);


		//
		// Get the HNetConnection object for this NetConnection.
		//
		hr = pHNetCfgMgr->GetIHNetConnectionForINetConnection(pNetConnection,
															&pHNetConnection);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't get IHNetConnection interface for INetConnection 0x%p (err = 0x%lx)!",
				pNetConnection, hr);
			goto Failure;
		}


		//
		// The HNetxxx objects appear to not be proxied...
		//
		//SETDEFAULTPROXYBLANKET(pHNetConnection);


		//
		// Don't need the INetConnection interface anymore.
		//
		pNetConnection->Release();
		pNetConnection = NULL;


#ifdef DBG
		//
		// Retrieve the connection name, for debug printing purposes.
		//
		hr = pHNetConnection->GetName(&pwszName);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't get name of HNetConnection 0x%p (err = 0x%lx)!",
				pHNetConnection, hr);
			goto Failure;
		}
#endif // DBG


		//
		// Retrieve the existing binding.
		//
		hr = pHNetConnection->GetBindingForPortMappingProtocol(pHNetPortMappingProtocol,
															&pHNetPortMappingBinding);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't get binding for port mapping protocol 0x%p (err = 0x%lx)!",
				pHNetPortMappingProtocol, hr);
			goto Failure;
		}


		//
		// The HNetxxx objects appear to not be proxied...
		//
		//SETDEFAULTPROXYBLANKET(pHNetPortMappingBinding);


		//
		// Don't need the HomeNet Connection object anymore.
		//
		pHNetConnection->Release();
		pHNetConnection = NULL;


		DPFX(DPFPREP, 6, "Disabling binding 0x%p on connection \"%ls\".",
			pHNetPortMappingBinding, pwszName);

		
		//
		// Disable it.
		//
		hr = pHNetPortMappingBinding->SetEnabled(FALSE);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't disable port mapping binding 0x%p (err = 0x%lx)!",
				pHNetPortMappingBinding, hr);
			goto Failure;
		}

		pHNetPortMappingBinding->Release();
		pHNetPortMappingBinding = NULL;


		//
		// Go to the next mapping.
		//
#ifdef DBG
		CoTaskMemFree(pwszName);
		pwszName = NULL;
#endif // DBG
	}
	while (TRUE);


	//
	// If we're here, we made it through unscathed.
	//
	hr = DPNH_OK;


Exit:

	if (pEnumNetConnections != NULL)
	{
		pEnumNetConnections->Release();
		pEnumNetConnections = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pHNetPortMappingBinding != NULL)
	{
		pHNetPortMappingBinding->Release();
		pHNetPortMappingBinding = NULL;
	}

#ifdef DBG
	if (pwszName != NULL)
	{
		CoTaskMemFree(pwszName);
		pwszName = NULL;
	}
#endif // DBG

	if (pHNetConnection != NULL)
	{
		pHNetConnection->Release();
		pHNetConnection = NULL;
	}

	if (pNetConnection != NULL)
	{
		pNetConnection->Release();
		pNetConnection = NULL;
	}

	if (pNetConnectionManager != NULL)
	{
		pNetConnectionManager->Release();
		pNetConnectionManager = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::DisableAllBindingsForHNetPortMappingProtocol





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CleanupInactiveFirewallMappings"
//=============================================================================
// CNATHelpUPnP::CleanupInactiveFirewallMappings
//-----------------------------------------------------------------------------
//
// Description:    Looks for any mappings previously made by other DPNATHLP
//				instances that are no longer active (because of a crash), and
//				unmaps them.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice					- Pointer to device to use.
//	IHNetCfgMgr * pHNetCfgMgr			- Pointer to IHNetCfgMgr interface to
//											use.
//
// Returns: HRESULT
//	DPNH_OK							- The cleanup was successful.
//	DPNHERR_GENERIC					- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CleanupInactiveFirewallMappings(CDevice * const pDevice,
													IHNetCfgMgr * const pHNetCfgMgr)
{
	HRESULT						hr = DPNH_OK;
	CRegistry					RegObject;
	BOOL						fOpenedRegistry = FALSE;
	DWORD						dwIndex;
	WCHAR						wszValueName[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	DWORD						dwValueNameSize;
	DPNHACTIVEFIREWALLMAPPING	dpnhafm;
	DWORD						dwValueSize;
	TCHAR						tszObjectName[MAX_INSTANCENAMEDOBJECT_SIZE];
	DNHANDLE					hNamedObject = NULL;
	CRegisteredPort *			pRegisteredPort = NULL;
	BOOL						fSetPrivateAddresses = FALSE;
	SOCKADDR_IN					saddrinPrivate;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pDevice, pHNetCfgMgr);


	DNASSERT(pDevice != NULL);
	DNASSERT(pDevice->IsHNetFirewalled());


	if (! RegObject.Open(HKEY_LOCAL_MACHINE,
						DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVEFIREWALLMAPPINGS,
						FALSE,
						TRUE,
						TRUE,
						DPN_KEY_ALL_ACCESS))
	{
		DPFX(DPFPREP, 1, "Couldn't open active firewall mapping key, not performing crash cleanup.");
		DNASSERT(hr == DPNH_OK);
		goto Exit;
	}

	fOpenedRegistry = TRUE;


	//
	// Walk the list of active mappings.
	//
	dwIndex = 0;
	do
	{
		dwValueNameSize = MAX_UPNP_MAPPING_DESCRIPTION_SIZE;
		if (! RegObject.EnumValues(wszValueName, &dwValueNameSize, dwIndex))
		{
			//
			// There was an error or there aren't any more keys.  We're done.
			//
			break;
		}


		//
		// Try reading that mapping's data.
		//
		dwValueSize = sizeof(dpnhafm);
		if (! RegObject.ReadBlob(wszValueName, (LPBYTE) (&dpnhafm), &dwValueSize))
		{
			//
			// We don't have a lock protecting the registry, so some other
			// instance could have deleted the key between when we enumerated
			// it and now.  We'll stop trying (and hopefully that other
			// instance will cover the rest of the items).
			//
			DPFX(DPFPREP, 0, "Couldn't read \"%ls\" mapping value!  Done with cleanup.",
				wszValueName);

			DNASSERT(hr == DPNH_OK);
			goto Exit;
		}

		//
		// Validate the data read.
		//
		if ((dwValueSize != sizeof(dpnhafm)) ||
			(dpnhafm.dwVersion != ACTIVE_MAPPING_VERSION))
		{
			DPFX(DPFPREP, 0, "The \"%ls\" mapping value is invalid!  Done with cleanup.",
				wszValueName);

			//
			// Move to next item.
			//
			dwIndex++;
			continue;
		}


		//
		// See if that DPNHUPNP instance is still around.
		//

		if (this->m_dwFlags & NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX)
		{
			wsprintf(tszObjectName, _T("Global\\") INSTANCENAMEDOBJECT_FORMATSTRING, dpnhafm.dwInstanceKey);
		}
		else
		{
			wsprintf(tszObjectName, INSTANCENAMEDOBJECT_FORMATSTRING, dpnhafm.dwInstanceKey);
		}

		hNamedObject = DNOpenEvent(SYNCHRONIZE, FALSE, tszObjectName);
		if (hNamedObject != NULL)
		{
			//
			// This is still an active mapping.
			//

			DPFX(DPFPREP, 4, "Firewall mapping \"%ls\" belongs to instance %u, which is still active.",
				wszValueName, dpnhafm.dwInstanceKey);

			DNCloseHandle(hNamedObject);
			hNamedObject = NULL;

			//
			// Move to next item.
			//
			dwIndex++;
			continue;
		}


		DPFX(DPFPREP, 4, "Firewall mapping \"%ls\" belongs to instance %u, which no longer exists.",
			wszValueName, dpnhafm.dwInstanceKey);

		//
		// Delete the value now that we have the information we need.
		//
		if (! RegObject.DeleteValue(wszValueName))
		{
			//
			// See ReadBlob comments.  Stop trying to cleanup.
			//
			DPFX(DPFPREP, 0, "Couldn't delete \"%ls\"!  Done with cleanup.",
				wszValueName);

			DNASSERT(hr == DPNH_OK);
			goto Exit;
		}


		//
		// Create a fake registered port that we will deregister.  Ignore the
		// NAT state flags.
		//
		pRegisteredPort = new CRegisteredPort(0, (dpnhafm.dwFlags & REGPORTOBJMASK_HNETFWAPI));
		if (pRegisteredPort == NULL)
		{
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}

		//
		// Assert that the other information/state flags are correct.
		//
		DNASSERT(! pRegisteredPort->IsHNetFirewallPortUnavailable());
		DNASSERT(! pRegisteredPort->IsRemovingUPnPLease());


		//
		// Temporarily associate the registered port with the device.
		//
		pRegisteredPort->MakeDeviceOwner(pDevice);


		
		ZeroMemory(&saddrinPrivate, sizeof(saddrinPrivate));
		saddrinPrivate.sin_family				= AF_INET;
		saddrinPrivate.sin_addr.S_un.S_addr		= dpnhafm.dwAddressV4;
		saddrinPrivate.sin_port					= dpnhafm.wPort;


		//
		// Store the private address.
		//
		hr = pRegisteredPort->SetPrivateAddresses(&saddrinPrivate, 1);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed creating UPnP address array!");
			goto Failure;
		}

		fSetPrivateAddresses = TRUE;


		//
		// Pretend it has been mapped on the local firewall.  Note that this
		// flag shouldn't have been set at the time it was stored in registry
		// but we masked it out if it had been.
		//
		pRegisteredPort->NoteMappedOnHNetFirewall();


		//
		// Actually free the port.
		//
		hr = this->UnmapPortOnLocalHNetFirewallInternal(pRegisteredPort,
														FALSE,
														pHNetCfgMgr);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed deleting temporary HNet firewall port (err = 0x%lx)!  Ignoring.",
				hr);

			//
			// Jump to the failure cleanup case, but don't actually return a
			// failure.
			//
			hr = DPNH_OK;
			goto Failure;
		}


		pRegisteredPort->ClearPrivateAddresses();
		fSetPrivateAddresses = FALSE;

		pRegisteredPort->ClearDeviceOwner();

		delete pRegisteredPort;
		pRegisteredPort = NULL;


		//
		// Move to the next mapping.  Don't increment index since we just
		// deleted the previous entry and everything shifts down one.
		//
	}
	while (TRUE);


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pRegisteredPort != NULL)
	{
		pRegisteredPort->NoteNotMappedOnHNetFirewall();
		pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

		if (fSetPrivateAddresses)
		{
			pRegisteredPort->ClearPrivateAddresses();
			fSetPrivateAddresses = FALSE;
		}

		pRegisteredPort->ClearDeviceOwner();

		delete pRegisteredPort;
		pRegisteredPort = NULL;
	}

	if (fOpenedRegistry)
	{
		RegObject.Close();
	}

	goto Exit;
} // CNATHelpUPnP::CleanupInactiveFirewallMappings




#endif // ! DPNBUILD_NOHNETFWAPI





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::RemoveAllItems"
//=============================================================================
// CNATHelpUPnP::RemoveAllItems
//-----------------------------------------------------------------------------
//
// Description:    Removes all devices (de-registering with Internet gateways
//				if necessary).  This removes all registered port mapping
//				objects and UPnP device objects, as well.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::RemoveAllItems(void)
{
	HRESULT				hr;
	CBilink *			pBilinkDevice;
	CDevice *			pDevice;
	CBilink *			pBilinkRegisteredPort;
	CRegisteredPort *	pRegisteredPort;
	CUPnPDevice *		pUPnPDevice;


	DPFX(DPFPREP, 7, "(0x%p) Enter", this);


	pBilinkDevice = this->m_blDevices.GetNext();
	while (pBilinkDevice != &this->m_blDevices)
	{
		DNASSERT(! pBilinkDevice->IsEmpty());
		pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
		pBilinkDevice = pBilinkDevice->GetNext();


		DPFX(DPFPREP, 5, "Destroying device 0x%p.",
			pDevice);


		pDevice->m_blList.RemoveFromList();


		//
		// All of the device's registered ports are implicitly freed.
		//

		pBilinkRegisteredPort = pDevice->m_blOwnedRegPorts.GetNext();

		while (pBilinkRegisteredPort != &pDevice->m_blOwnedRegPorts)
		{
			DNASSERT(! pBilinkRegisteredPort->IsEmpty());
			pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegisteredPort);
			pBilinkRegisteredPort = pBilinkRegisteredPort->GetNext();


			DPFX(DPFPREP, 5, "Destroying registered port 0x%p (under device 0x%p).",
				pRegisteredPort, pDevice);


			//
			// Unmap on UPnP server if necessary.
			//
			if (pRegisteredPort->HasUPnPPublicAddresses())
			{
				hr = this->UnmapUPnPPort(pRegisteredPort,
										pRegisteredPort->GetNumAddresses(),	// free all ports
										TRUE);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't delete UPnP registered port 0x%p mapping (err = 0x%lx)!  Ignoring.",
						pRegisteredPort, hr);
					
					//
					// Continue anyway, so we can finish cleaning up the object.
					//
				}

				DNASSERT(! pRegisteredPort->HasUPnPPublicAddresses());

				pRegisteredPort->NoteNotPermanentUPnPLease();
				pRegisteredPort->NoteNotUPnPPortUnavailable();
			}


#ifndef DPNBUILD_NOHNETFWAPI
			//
			// Then unmap from the local firewall, if necessary.
			//
			if (pRegisteredPort->IsMappedOnHNetFirewall())
			{
				//
				// Unmap the port.
				//
				// Alert the user since this is unexpected.
				//
				hr = this->UnmapPortOnLocalHNetFirewall(pRegisteredPort,
														TRUE,
														TRUE);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Failed unmapping registered port 0x%p on local HomeNet firewall (err = 0x%lx)!  Ignoring.",
						pRegisteredPort, hr);

					pRegisteredPort->NoteNotMappedOnHNetFirewall();
					pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
					
					//
					// Continue anyway, so we can finish cleaning up the object.
					//
				}
			}
#endif // ! DPNBUILD_NOHNETFWAPI


			pRegisteredPort->ClearDeviceOwner();
			DNASSERT(pRegisteredPort->m_blGlobalList.IsListMember(&this->m_blRegisteredPorts));
			pRegisteredPort->m_blGlobalList.RemoveFromList();

			pRegisteredPort->ClearPrivateAddresses();


			//
			// The user implicitly released this port.
			//
			pRegisteredPort->ClearAllUserRefs();

			delete pRegisteredPort;
		}


		//
		// The device's UPnP gateway is implicitly removed.
		//

		pUPnPDevice = pDevice->GetUPnPDevice();
		if (pUPnPDevice != NULL)
		{
			if ((pUPnPDevice->IsConnecting()) || (pUPnPDevice->IsConnected()))
			{
				if (this->m_pfnshutdown(pUPnPDevice->GetControlSocket(), 0) != 0)
				{
#ifdef DBG
					int		iError;


					iError = this->m_pfnWSAGetLastError();
					DPFX(DPFPREP, 0, "Failed shutting down UPnP device 0x%p's control socket (err = %u)!  Ignoring.",
						pUPnPDevice, iError);
#endif // DBG
				}
			}

			pUPnPDevice->ClearDeviceOwner();
			DNASSERT(pUPnPDevice->m_blList.IsListMember(&this->m_blUPnPDevices));
			pUPnPDevice->m_blList.RemoveFromList();
			//
			// Transfer list reference to our pointer, since GetUPnPDevice did
			// not give us one.
			//

			this->m_pfnclosesocket(pUPnPDevice->GetControlSocket());
			pUPnPDevice->SetControlSocket(INVALID_SOCKET);

			pUPnPDevice->ClearLocationURL();
			pUPnPDevice->ClearUSN();
			pUPnPDevice->ClearServiceControlURL();
			pUPnPDevice->DestroyReceiveBuffer();
			pUPnPDevice->RemoveAllCachedMappings();

			pUPnPDevice->DecRef();
			pUPnPDevice = NULL;
		}


#ifndef DPNBUILD_NOHNETFWAPI
		//
		// If we used the HomeNet firewall API to open a hole for UPnP
		// discovery multicasts, close it.
		//
		if (pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall())
		{
			hr = this->CloseDevicesUPnPDiscoveryPort(pDevice, NULL);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't close device 0x%p's UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring.",
					pDevice, hr);

				//
				// Continue...
				//
				pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();
				hr = DPNH_OK;
			}
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		//
		// Close the socket.
		//
		if (this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP)
		{
			this->m_pfnclosesocket(pDevice->GetUPnPDiscoverySocket());
			pDevice->SetUPnPDiscoverySocket(INVALID_SOCKET);
		}


		//
		// Now we can dump the device object.
		//
		delete pDevice;
	}


	//
	// Removing all the devices normally removes all the registered ports, but
	// there may still be more wildcard ports that were never associated with
	// any device.
	//

	pBilinkRegisteredPort = this->m_blUnownedPorts.GetNext();
	while (pBilinkRegisteredPort != &this->m_blUnownedPorts)
	{
		DNASSERT(! pBilinkRegisteredPort->IsEmpty());
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegisteredPort);
		pBilinkRegisteredPort = pBilinkRegisteredPort->GetNext();


		DPFX(DPFPREP, 5, "Destroying unowned registered port 0x%p.",
			pRegisteredPort);


		pRegisteredPort->m_blDeviceList.RemoveFromList();
		DNASSERT(pRegisteredPort->m_blGlobalList.IsListMember(&this->m_blRegisteredPorts));
		pRegisteredPort->m_blGlobalList.RemoveFromList();

		pRegisteredPort->ClearPrivateAddresses();

#ifndef DPNBUILD_NOHNETFWAPI
		DNASSERT(! pRegisteredPort->IsMappedOnHNetFirewall());
		DNASSERT(! pRegisteredPort->IsHNetFirewallPortUnavailable());
#endif // ! DPNBUILD_NOHNETFWAPI

		DNASSERT(! pRegisteredPort->HasUPnPPublicAddresses());
		DNASSERT(! pRegisteredPort->IsUPnPPortUnavailable());

		//
		// The user implicitly released this port.
		//
		pRegisteredPort->ClearAllUserRefs();

		delete pRegisteredPort;
	}


#ifdef DBG
	DNASSERT(this->m_blRegisteredPorts.IsEmpty());
	DNASSERT(this->m_blUPnPDevices.IsEmpty());


	//
	// Print all items still in the registry.
	//
#ifndef DPNBUILD_NOHNETFWAPI
	this->DebugPrintActiveFirewallMappings();
#endif // ! DPNBUILD_NOHNETFWAPI
	this->DebugPrintActiveNATMappings();
#endif // DBG




	DPFX(DPFPREP, 7, "(0x%p) Leave", this);
} // CNATHelpUPnP::RemoveAllItems





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::FindMatchingDevice"
//=============================================================================
// CNATHelpUPnP::FindMatchingDevice
//-----------------------------------------------------------------------------
//
// Description:    Searches the list of devices for the object matching the
//				given address, or NULL if one could not be found.  If the
//				address is INADDR_ANY, then the first device with a remote NAT
//				is selected.  If none exist, then the first device with a local
//				firewall is selected.
//
//				   If fUseAllInfoSources is TRUE, the list of registered ports
//				associated with devices is searched first for an exact match to
//				the address passed in.  If that fails, then devices are
//				searched as above.  In addition, if the address is INADDR_ANY,
///				the first device with a local NAT can be selected.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	SOCKADDR_IN * psaddrinMatch		- Pointer to address to look up.
//	BOOL fUseAllInfoSources			- Whether all possible sources of
//										information should be considered.
//
// Returns: CDevice
//	NULL if no match, valid object otherwise.
//=============================================================================
CDevice * CNATHelpUPnP::FindMatchingDevice(const SOCKADDR_IN * const psaddrinMatch,
											const BOOL fUseAllInfoSources)
{
	HRESULT				hr;
	BOOL				fUpdatedDeviceList = FALSE;
	CDevice *			pDeviceUPnPGateway = NULL;
#ifndef DPNBUILD_NOHNETFWAPI
	CDevice *			pDeviceLocalHNetFirewall = NULL;
#endif // ! DPNBUILD_NOHNETFWAPI
	SOCKADDR_IN *		pasaddrinTemp;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;
	DWORD				dwTemp;


	do
	{
		//
		// First, make sure there are devices to choose from.
		//
		if (this->m_blDevices.IsEmpty())
		{
			DPFX(DPFPREP, 0, "No devices, can't match address %u.%u.%u.%u!",
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);
			pDevice = NULL;
			goto Exit;
		}


		//
		// It's possible that the address we're trying to match is an already
		// registered port.  Look through all owned port mappings for this
		// address, if we're allowed.
		//
		if (fUseAllInfoSources)
		{
			pBilink = this->m_blRegisteredPorts.GetNext();
			while (pBilink != &this->m_blRegisteredPorts)
			{
				DNASSERT(! pBilink->IsEmpty());
				pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

				//
				// Only check this registered port if it has an owning device.
				//
				pDevice = pRegisteredPort->GetOwningDevice();
				if (pDevice != NULL)
				{
					//
					// Check each port in the array.
					//
					pasaddrinTemp = pRegisteredPort->GetPrivateAddressesArray();
					for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
					{
						//
						// If the address matches, we have a winner.
						//
						if ((pasaddrinTemp[dwTemp].sin_addr.S_un.S_addr == psaddrinMatch->sin_addr.S_un.S_addr) &&
							(pasaddrinTemp[dwTemp].sin_port == psaddrinMatch->sin_port))
						{
							DPFX(DPFPREP, 7, "Registered port 0x%p index %u matches address %u.%u.%u.%u:%u, returning owning device 0x%p.",
								pRegisteredPort,
								dwTemp,
								psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
								psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
								psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
								psaddrinMatch->sin_addr.S_un.S_un_b.s_b4,
								NTOHS(psaddrinMatch->sin_port),
								pDevice);
							goto Exit;
						}
					}
				}

				pBilink = pBilink->GetNext();
			}
		}


		//
		// Darn, the address is not already registered.  Well, match it up with
		// a device as best as possible.
		//

		pBilink = this->m_blDevices.GetNext();

		do
		{
			DNASSERT(! pBilink->IsEmpty());
			pDevice = DEVICE_FROM_BILINK(pBilink);
			
			if ((pDevice->GetLocalAddressV4() == psaddrinMatch->sin_addr.S_un.S_addr))
			{
				DPFX(DPFPREP, 7, "Device 0x%p matches address %u.%u.%u.%u.",
					pDevice,
					psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
					psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
					psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
					psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);
				goto Exit;
			}


			//
			// Remember this device if it has the first remote UPnP gateway
			// device we've seen.
			//
			if ((pDevice->GetUPnPDevice() != NULL) &&
				((! pDevice->GetUPnPDevice()->IsLocal()) || (fUseAllInfoSources)) &&
				(pDeviceUPnPGateway == NULL))
			{
				pDeviceUPnPGateway = pDevice;
			}


#ifndef DPNBUILD_NOHNETFWAPI
			//
			// Remember this device if it has the first HomeNet firewall we've
			// seen.
			//
			if ((pDevice->IsHNetFirewalled()) &&
				(pDeviceLocalHNetFirewall == NULL))
			{
				pDeviceLocalHNetFirewall = pDevice;
			}
#endif // ! DPNBUILD_NOHNETFWAPI


			DPFX(DPFPREP, 7, "Device 0x%p does not match address %u.%u.%u.%u.",
				pDevice,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
				psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);

			pBilink = pBilink->GetNext();
		}
		while (pBilink != &this->m_blDevices);


		//
		// If we got here, there's no matching device.  It might be because the
		// caller detected an address change faster than we did.  Try updating
		// our device list and searching again (if we haven't already).
		//

		if (fUpdatedDeviceList)
		{
			break;
		}


		//
		// Don't bother updating the list to match INADDR_ANY, we know that
		// will never match anything.
		//
		if (psaddrinMatch->sin_addr.S_un.S_addr == INADDR_ANY)
		{
			DPFX(DPFPREP, 7, "Couldn't find matching device for INADDR_ANY, as expected.");
			break;
		}


		DPFX(DPFPREP, 5, "Couldn't find matching device for %u.%u.%u.%u, updating device list and searching again.",
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);


		hr = this->CheckForNewDevices(&fUpdatedDeviceList);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't check for new devices (0x%lx), continuing.",
				hr);
			//
			// Hmm, we have to treat it as non-fatal. Don't search again,
			// though.
			//
			break;
		}

		//
		// If we didn't actually get any new devices, don't bother searching
		// again.
		//
		if (! fUpdatedDeviceList)
		{
			break;
		}

		//
		// fUpdatedDeviceList is set to TRUE so we'll only loop one more time.
		//
	}
	while (TRUE);


	//
	// If we got here, there's still no matching device.  If it's the wildcard
	// value, that's to be expected, but we need to pick a device in the
	// following order:
	//    1. device has an Internet gateway
	//    2. device has a firewall
	// If none of those exists or it's not the wildcard value, we have to give
	// up.
	//
	if (psaddrinMatch->sin_addr.S_un.S_addr == INADDR_ANY)
	{
		if (pDeviceUPnPGateway != NULL)
		{
			pDevice = pDeviceUPnPGateway;

			DPFX(DPFPREP, 1, "Picking device 0x%p with UPnP gateway device to match INADDR_ANY.",
				pDevice);
		}
#ifndef DPNBUILD_NOHNETFWAPI
		else if (pDeviceLocalHNetFirewall != NULL)
		{
			pDevice = pDeviceLocalHNetFirewall;

			DPFX(DPFPREP, 1, "Picking device 0x%p with local HomeNet firewall to match INADDR_ANY.",
				pDevice);
		}
#endif // ! DPNBUILD_NOHNETFWAPI
		else
		{
			pDevice = NULL;

			DPFX(DPFPREP, 1, "No suitable device to match INADDR_ANY.");
		}
	}
	else
	{
		pDevice = NULL;

		DPFX(DPFPREP, 7, "No devices match address %u.%u.%u.%u.",
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b1,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b2,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b3,
			psaddrinMatch->sin_addr.S_un.S_un_b.s_b4);
	}


Exit:

	return pDevice;
} // CNATHelpUPnP::FindMatchingDevice







#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ExtendAllExpiringLeases"
//=============================================================================
// CNATHelpUPnP::ExtendAllExpiringLeases
//-----------------------------------------------------------------------------
//
// Description:    Renews any port leases that are close to expiring (within 2
//				minutes of expiration time).
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK				- Lease extension was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::ExtendAllExpiringLeases(void)
{
	HRESULT				hr = DPNH_OK;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;
	DWORD				dwLeaseTimeRemaining;


	DPFX(DPFPREP, 5, "Enter");


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);


	//
	// Walk the list of all registered ports and check for leases that need to
	// be extended.
	// The lock is already held.
	//

	pBilink = this->m_blRegisteredPorts.GetNext();

	while (pBilink != (&this->m_blRegisteredPorts))
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

		pDevice = pRegisteredPort->GetOwningDevice();


		//
		// If the port is registered with the UPnP device, extend that lease,
		// if necessary.
		//
		if ((pRegisteredPort->HasUPnPPublicAddresses()) &&
			(! pRegisteredPort->HasPermanentUPnPLease()))
		{
			DNASSERT(pDevice != NULL);


			dwLeaseTimeRemaining = pRegisteredPort->GetUPnPLeaseExpiration() - GETTIMESTAMP();

			if (dwLeaseTimeRemaining < LEASE_RENEW_TIME)
			{
				hr = this->ExtendUPnPLease(pRegisteredPort);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't extend port mapping lease on remote UPnP device (0x%lx)!  Ignoring.", hr);

					//
					// We'll treat this as non-fatal, but we have to dump the
					// server.  This may have already been done, but doing it
					// twice shouldn't be harmful.
					//
					this->ClearDevicesUPnPDevice(pDevice);
					hr = DPNH_OK;
				}
			}
		}


		//
		// The local firewall never uses leases, no need to extend.
		//


		pBilink = pBilink->GetNext();
	}


	DNASSERT(hr == DPNH_OK);

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CNATHelpUPnP::ExtendAllExpiringLeases





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::UpdateServerStatus"
//=============================================================================
// CNATHelpUPnP::UpdateServerStatus
//-----------------------------------------------------------------------------
//
// Description:    Checks to see if any Internet gateways have stopped
//				responding or are now available.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK				- The update was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::UpdateServerStatus(void)
{
	HRESULT				hr = DPNH_OK;
	DWORD				dwMinUpdateServerStatusInterval;
	DWORD				dwCurrentTime;
	CBilink *			pBilink;
	CDevice *			pDevice;
	CUPnPDevice *		pUPnPDevice = NULL;
	CDevice *			pDeviceRemoteUPnPGateway = NULL;
#ifndef DPNBUILD_NOHNETFWAPI
	CDevice *			pDeviceLocalHNetFirewall = NULL;
#endif // ! DPNBUILD_NOHNETFWAPI
	BOOL				fSendRemoteGatewayDiscovery;


	DPFX(DPFPREP, 5, "Enter");


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);


	//
	// Cache the current value of the global.  This should be atomic so no need
	// to take the globals lock.
	//
	dwMinUpdateServerStatusInterval = g_dwMinUpdateServerStatusInterval;


	//
	// Capture the current time.
	//
	dwCurrentTime = GETTIMESTAMP();


	//
	// If this isn't the first time to update server status, but it hasn't been
	// very long since we last checked, don't.  This will prevent unnecessary
	// network traffic if GetCaps is called frequently (in response to many
	// alert events, for example).
	//
	// However, if we just found a new device, update the status anyway.
	//
	if (this->m_dwLastUpdateServerStatusTime != 0)
	{
		if ((dwCurrentTime - this->m_dwLastUpdateServerStatusTime) < dwMinUpdateServerStatusInterval)
		{
			if (! (this->m_dwFlags & NATHELPUPNPOBJ_DEVICECHANGED))
			{
				DPFX(DPFPREP, 5, "Server status was just updated at %u, not updating again (time = %u, min interval = %u).",
					this->m_dwLastUpdateServerStatusTime,
					dwCurrentTime,
					dwMinUpdateServerStatusInterval);

				//
				// hr == DPNH_OK
				//
				goto Exit;
			}


			DPFX(DPFPREP, 5, "Server status was just updated at %u (time = %u, min interval = %u), but there was a device change that may affect things.",
				this->m_dwLastUpdateServerStatusTime,
				dwCurrentTime,
				dwMinUpdateServerStatusInterval);

			//
			// Continue...
			//
		}


		//
		// If we're allowed to keep polling for remote gateways after startup,
		// do so.  Otherwise, only do it if a device has changed or a port has
		// been registered since our last check.
		//
		if ((g_fKeepPollingForRemoteGateway) ||
			(this->m_dwFlags & NATHELPUPNPOBJ_DEVICECHANGED) ||
			(this->m_dwFlags & NATHELPUPNPOBJ_PORTREGISTERED))
		{
			fSendRemoteGatewayDiscovery = TRUE;
		}
		else
		{
			fSendRemoteGatewayDiscovery = FALSE;
		}
	}
	else
	{
		//
		// We always poll for new remote gateways during startup.
		//
		fSendRemoteGatewayDiscovery = TRUE;
	}


	//
	// Prevent the timer from landing exactly on 0.
	//
	if (dwCurrentTime == 0)
	{
		dwCurrentTime = 1;
	}
	this->m_dwLastUpdateServerStatusTime = dwCurrentTime;


	//
	// Turn off the 'device changed' and 'port registered' flags, if they were
	// on.
	//
	this->m_dwFlags &= ~(NATHELPUPNPOBJ_DEVICECHANGED | NATHELPUPNPOBJ_PORTREGISTERED);


	//
	// Locate any new UPnP devices.
	//
	if (this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP)
	{
		//
		// We're not listening on the UPnP multicast address and can't hear
		// unsolicited new device announcements.  In order to detect new
		// devices, we need to resend the discovery request periodically so
		// that responses get sent directly to our listening socket.
		//
		hr = this->CheckForUPnPAnnouncements(g_dwUPnPAnnounceResponseWaitTime,
											fSendRemoteGatewayDiscovery);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't check for UPnP announcements!");
			goto Failure;
		}
	}
	else
	{
		//
		// Not using UPnP.
		//
	}


	//
	// Loop through all the devices.
	//
	pBilink = this->m_blDevices.GetNext();
	while (pBilink != &this->m_blDevices)
	{
		DNASSERT(! pBilink->IsEmpty());
		pDevice = DEVICE_FROM_BILINK(pBilink);


		//
		// This might be a new device, so register any ports with this address
		// that were previously unowned (because this device's address was
		// unknown at the time).
		//
		hr = this->RegisterPreviouslyUnownedPortsWithDevice(pDevice, FALSE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't register previously unowned ports with device 0x%p!.",
				pDevice);
			goto Failure;
		}


#ifndef DPNBUILD_NOHNETFWAPI
		if (this->m_dwFlags & NATHELPUPNPOBJ_USEHNETFWAPI)
		{
			//
			// See if the local firewall state has changed.
			//
			hr = this->CheckForLocalHNetFirewallAndMapPorts(pDevice, NULL);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't check for local HNet firewall and map ports (err = 0x%lx)!  Ignoring.",
					hr);
				DNASSERT(! pDevice->IsHNetFirewalled());
				hr = DPNH_OK;
			}


			//
			// If there's a local firewall, remember the device if it's the
			// first one we've found.
			//
			if ((pDevice->IsHNetFirewalled()) &&
				(pDeviceLocalHNetFirewall == NULL))
			{
				pDeviceLocalHNetFirewall = pDevice;
			}
		}
		else
		{
			//
			// Not using firewall traversal.
			//
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		if (this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP)
		{
			pUPnPDevice = pDevice->GetUPnPDevice();
			if (pUPnPDevice != NULL)
			{
				//
				// GetUPnPDevice did not add a reference to pUPnPDevice for us.
				//
				pUPnPDevice->AddRef();


				//
				// Update the public addresses for the UPnP device, if any.
				//
				hr = this->UpdateUPnPExternalAddress(pUPnPDevice, TRUE);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Failed updating UPnP device external address!");

					//
					// It may have been cleared already, but doing it twice
					// shouldn't be harmful.
					//
					this->ClearDevicesUPnPDevice(pDevice);

					hr = DPNH_OK;
				}
				else
				{
					//
					// Save this UPnP device, if it's the first one we've
					// found and it's not local.
					//
					if ((pDeviceRemoteUPnPGateway == NULL) &&
						(! pUPnPDevice->IsLocal()))
					{
						pDeviceRemoteUPnPGateway = pDevice;
					}
				}

				pUPnPDevice->DecRef();
				pUPnPDevice = NULL;
			}
			else
			{
				//
				// No UPnP device.
				//
			}
		}
		else
		{
			//
			// Not using UPnP.
			//
		}

		pBilink = pBilink->GetNext();
	}


	//
	// Some new servers may have come online.  If so, we can now map wildcard
	// ports that were registered previously.  Figure out which device that is.
	//
	if (pDeviceRemoteUPnPGateway != NULL)
	{
		pDevice = pDeviceRemoteUPnPGateway;
	}
#ifndef DPNBUILD_NOHNETFWAPI
	else if (pDeviceLocalHNetFirewall != NULL)
	{
		pDevice = pDeviceLocalHNetFirewall;
	}
#endif // ! DPNBUILD_NOHNETFWAPI
	else
	{
		pDevice = NULL;
	}

	if (pDevice != NULL)
	{
		//
		// Register any wildcard ports that are unowned with this best device.
		//
		hr = this->RegisterPreviouslyUnownedPortsWithDevice(pDevice, TRUE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't register unowned wildcard ports with device 0x%p!.",
				pDevice);
			goto Failure;
		}
	}
#ifdef DBG
	else
	{
		DPFX(DPFPREP, 7, "No devices have a UPnP gateway device or a local HomeNet firewall.");
	}
#endif // DBG


	DPFX(DPFPREP, 7, "Spent %u ms updating server status, starting at %u.",
		(GETTIMESTAMP() - dwCurrentTime), dwCurrentTime);


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::UpdateServerStatus





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::RegisterPreviouslyUnownedPortsWithDevice"
//=============================================================================
// CNATHelpUPnP::RegisterPreviouslyUnownedPortsWithDevice
//-----------------------------------------------------------------------------
//
// Description:    Associates unknown ports with the given device, and
//				registers them with the device's UPnP device or firewall.
//
//				   If fWildcardToo is FALSE, only previously unowned ports that
//				match the device's address are associated.  If TRUE, unowned
//				INADDR_ANY ports are associated as well.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device to take ownership of ports.
//	BOOL fAll			- Whether all ports should be associated.
//
// Returns: HRESULT
//	DPNH_OK				- The extension was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::RegisterPreviouslyUnownedPortsWithDevice(CDevice * const pDevice,
																const BOOL fWildcardToo)
{
	HRESULT				hr = DPNH_OK;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;
	SOCKADDR_IN *		pasaddrinPrivate;
	CUPnPDevice *		pUPnPDevice;
#ifdef DBG
	BOOL				fAssignedPort = FALSE;
	IN_ADDR				inaddrTemp;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)",
		this, pDevice, fWildcardToo);


	//
	// Loop through all unowned ports, assign them to the device if
	// appropriate, then register them.
	//
	pBilink = this->m_blUnownedPorts.GetNext();
	while (pBilink != &this->m_blUnownedPorts)
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);
		pBilink = pBilink->GetNext();

		//
		// The registered port must match the device's address in order to
		// associate them.  If wildcards are allowed, then INADDR_ANY
		// registrations can be associated, too.
		//
		//
		// All addresses should be same (if there are more than one), so just
		// compare the first one in the array.
		//
		pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

		if (pasaddrinPrivate[0].sin_addr.S_un.S_addr != pDevice->GetLocalAddressV4())
		{
			if (pasaddrinPrivate[0].sin_addr.S_un.S_addr != INADDR_ANY)
			{
				DPFX(DPFPREP, 7, "Unowned registered port 0x%p private address %u.%u.%u.%u doesn't match device 0x%p's, skipping.",
					pRegisteredPort,
					pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b1,
					pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b2,
					pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b3,
					pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b4,
					pDevice);
				continue;
			}
			
#ifdef DBG
			inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();
#endif // DBG

			if (! fWildcardToo)
			{
#ifdef DBG
				DPFX(DPFPREP, 7, "Unowned registered port 0x%p (INADDR_ANY) not allowed to be associated with device 0x%p (address %u.%u.%u.%u), skipping.",
					pRegisteredPort,
					pDevice,
					inaddrTemp.S_un.S_un_b.s_b1,
					inaddrTemp.S_un.S_un_b.s_b2,
					inaddrTemp.S_un.S_un_b.s_b3,
					inaddrTemp.S_un.S_un_b.s_b4);
#endif // DBG

				continue;
			}

#ifdef DBG
			DPFX(DPFPREP, 7, "Unowned registered port 0x%p (INADDR_ANY) becoming associated with device 0x%p (address %u.%u.%u.%u).",
				pRegisteredPort,
				pDevice,
				inaddrTemp.S_un.S_un_b.s_b1,
				inaddrTemp.S_un.S_un_b.s_b2,
				inaddrTemp.S_un.S_un_b.s_b3,
				inaddrTemp.S_un.S_un_b.s_b4);
#endif // DBG
		}
		else
		{
			DPFX(DPFPREP, 7, "Unowned registered port 0x%p private address %u.%u.%u.%u matches device 0x%p's, associating.",
				pRegisteredPort,
				pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b1,
				pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b2,
				pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b3,
				pasaddrinPrivate[0].sin_addr.S_un.S_un_b.s_b4,
				pDevice);

			//
			// The way it's currently implemented, all non-wildcard ports
			// should be registered before we even try to register the wildcard
			// ones.
			//
			DNASSERT(! fWildcardToo);
		}


		//
		// If we made it here, we can associate the port with the device.
		//


		pRegisteredPort->m_blDeviceList.RemoveFromList();
		pRegisteredPort->MakeDeviceOwner(pDevice);



#ifndef DPNBUILD_NOHNETFWAPI
		//
		// Start by automatically mapping with the local firewall, if there is
		// one and we're allowed.
		//
		if (this->m_dwFlags & NATHELPUPNPOBJ_USEHNETFWAPI)
		{
			hr = this->CheckForLocalHNetFirewallAndMapPorts(pDevice, NULL);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't check for local HNet firewall and map ports (err = 0x%lx)!  Ignoring.",
					hr);
				DNASSERT(! pDevice->IsHNetFirewalled());
				hr = DPNH_OK;
			}
		}
		else
		{
			//
			// Not using firewall traversal.
			//
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		//
		// Attempt to automatically map it with the (new) UPnP gateway device,
		// if present.
		//
		pUPnPDevice = pDevice->GetUPnPDevice();
		if (pUPnPDevice != NULL)
		{
			//
			// GetUPnPDevice did not add a reference to pUPnPDevice for us.
			//
			pUPnPDevice->AddRef();


			DNASSERT(pUPnPDevice->IsReady());


			hr = this->MapPortsOnUPnPDevice(pUPnPDevice, pRegisteredPort);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't map existing ports on UPnP device 0x%p!",
					pUPnPDevice);

				//
				// It may have been cleared already, but doing it twice
				// shouldn't be harmful.
				//
				this->ClearDevicesUPnPDevice(pDevice);

				hr = DPNH_OK;
			}

			pUPnPDevice->DecRef();
			pUPnPDevice = NULL;
		}
	}


#ifdef DBG
	if (! fAssignedPort)
	{
		DPFX(DPFPREP, 1, "No unowned ports were bound to device object 0x%p.",
			pDevice);
	}
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CNATHelpUPnP::RegisterPreviouslyUnownedPortsWithDevice




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SendUPnPSearchMessagesForDevice"
//=============================================================================
// CNATHelpUPnP::SendUPnPSearchMessagesForDevice
//-----------------------------------------------------------------------------
//
// Description:    Sends one UPnP search message via the given device locally
//				and if fRemoteAllowed is TRUE, to the multicast or gateway
//				address.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice		- Pointer to device to use.
//	BOOL fRemoteAllowed		- Whether we can search remotely or not.
//
// Returns: HRESULT
//	DPNH_OK				- The messages were sent successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::SendUPnPSearchMessagesForDevice(CDevice * const pDevice,
													const BOOL fRemoteAllowed)
{
	HRESULT			hr = DPNH_OK;
	SOCKADDR_IN		saddrinRemote;
	SOCKADDR_IN		saddrinLocal;
	BOOL			fTryRemote;
	int				iWANIPConnectionMsgSize;
	int				iWANPPPConnectionMsgSize;
	int				iReturn;
	SOCKET			sTemp = INVALID_SOCKET;
#ifdef DBG
	DWORD			dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)", this, pDevice, fRemoteAllowed);


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);
	DNASSERT(pDevice->GetUPnPDiscoverySocket() != INVALID_SOCKET);


	ZeroMemory(&saddrinRemote, sizeof(saddrinRemote));
	saddrinRemote.sin_family				= AF_INET;
	//saddrinRemote.sin_addr.S_un.S_addr		= ?
	saddrinRemote.sin_port					= HTONS(UPNP_PORT);


	//
	// If we're allowed to try remotely, use the gateway's address, or the
	// multicast address, as appropriate.
	//
	if ((fRemoteAllowed) && (! pDevice->GotRemoteUPnPDiscoveryConnReset()))
	{
		if (g_fUseMulticastUPnPDiscovery)
		{
			saddrinRemote.sin_addr.S_un.S_addr	= this->m_pfninet_addr(UPNP_DISCOVERY_MULTICAST_ADDRESS);
			fTryRemote = TRUE;
		}
		else
		{
			//
			// Try to get the device's gateway's address.  This might return FALSE
			// if the device does not have a gateway.  In that case, we will ignore
			// the device.  Otherwise the address should be filled in with the
			// gateway or broadcast address.
			//
			fTryRemote = this->GetAddressToReachGateway(pDevice,
														&saddrinRemote.sin_addr);
		}
	}
	else
	{
		fTryRemote = FALSE;
	}

	ZeroMemory(&saddrinLocal, sizeof(saddrinLocal));
	saddrinLocal.sin_family					= AF_INET;
	saddrinLocal.sin_addr.S_un.S_addr		= pDevice->GetLocalAddressV4();
	saddrinLocal.sin_port					= HTONS(UPNP_PORT);


	//
	// Note that these message strings contain:
	//
	//	HOST: multicast_addr:port
	//
	// even though we send the messages to addresses other than the multicast
	// address.  It shouldn't matter.
	//
	iWANIPConnectionMsgSize = strlen(c_szUPnPMsg_Discover_Service_WANIPConnection);
	iWANPPPConnectionMsgSize = strlen(c_szUPnPMsg_Discover_Service_WANPPPConnection);


#ifdef DBG
	this->PrintUPnPTransactionToFile(c_szUPnPMsg_Discover_Service_WANIPConnection,
									iWANIPConnectionMsgSize,
									"Outbound WANIPConnection discovery messages",
									pDevice);


	this->PrintUPnPTransactionToFile(c_szUPnPMsg_Discover_Service_WANPPPConnection,
									iWANPPPConnectionMsgSize,
									"Outbound WANPPPConnection discovery messages",
									pDevice);
#endif // DBG


	DNASSERT(pDevice->GetUPnPDiscoverySocket() != INVALID_SOCKET);


	//
	// First, fire off messages to the remote gateway, if possible.
	//
	if (fTryRemote)
	{
		DPFX(DPFPREP, 7, "Sending UPnP discovery messages (WANIPConnection and WANPPPConnection) to gateway/multicast %u.%u.%u.%u:%u via device 0x%p.",
			saddrinRemote.sin_addr.S_un.S_un_b.s_b1,
			saddrinRemote.sin_addr.S_un.S_un_b.s_b2,
			saddrinRemote.sin_addr.S_un.S_un_b.s_b3,
			saddrinRemote.sin_addr.S_un.S_un_b.s_b4,
			NTOHS(saddrinRemote.sin_port),
			pDevice);


		//
		// Remember that we're trying remotely.
		//
		pDevice->NotePerformingRemoteUPnPDiscovery();

		//
		// Remember the current time, if this is the first thing we've sent
		// from this port.
		//
		if (pDevice->GetFirstUPnPDiscoveryTime() == 0)
		{
			pDevice->SetFirstUPnPDiscoveryTime(GETTIMESTAMP());
		}


		//
		// Multicast/send to gateway a WANIPConnection discovery message.
		//
		iReturn = this->m_pfnsendto(pDevice->GetUPnPDiscoverySocket(),
									c_szUPnPMsg_Discover_Service_WANIPConnection,
									iWANIPConnectionMsgSize,
									0,
									(SOCKADDR*) (&saddrinRemote),
									sizeof(saddrinRemote));

		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u when sending WANIPConnection discovery to UPnP gateway/multicast address on device 0x%p!  Ignoring.",
				dwError, pDevice);
#endif // DBG

			//
			// It's possible that we caught WinSock at a bad time,
			// particularly with WSAEADDRNOTAVAIL (10049), which seems to
			// occur if the address is going away (and we haven't detected
			// it in CheckForNewDevices yet).
			//
			// Ignore the error, we can survive.
			//
		}
		else
		{
			if (iReturn != iWANIPConnectionMsgSize)
			{
				DPFX(DPFPREP, 0, "Didn't multicast send entire WANIPConnection discovery datagram on device 0x%p (%i != %i)?!",
					pDevice, iReturn, iWANIPConnectionMsgSize);
				DNASSERT(FALSE);
				hr = DPNHERR_GENERIC;
				goto Failure;
			}
		}



		//
		// Multicast/send to gateway a WANPPPConnection discovery message.
		//
		iReturn = this->m_pfnsendto(pDevice->GetUPnPDiscoverySocket(),
									c_szUPnPMsg_Discover_Service_WANPPPConnection,
									iWANPPPConnectionMsgSize,
									0,
									(SOCKADDR*) (&saddrinRemote),
									sizeof(saddrinRemote));

		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u when sending WANPPPConnection discovery to UPnP multicast/gateway address on device 0x%p!  Ignoring.",
				dwError, pDevice);
#endif // DBG

			//
			// It's possible that we caught WinSock at a bad time,
			// particularly with WSAEADDRNOTAVAIL (10049), which seems to
			// occur if the address is going away (and we haven't detected
			// it in CheckForNewDevices yet).
			//
			// Ignore the error, we can survive.
			//
		}
		else
		{
			if (iReturn != iWANPPPConnectionMsgSize)
			{
				DPFX(DPFPREP, 0, "Didn't multicast send entire WANPPPConnection discovery datagram on device 0x%p (%i != %i)?!",
					pDevice, iReturn, iWANPPPConnectionMsgSize);
				DNASSERT(FALSE);
				hr = DPNHERR_GENERIC;
				goto Failure;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 2, "Device 0x%p should not attempt to reach a remote gateway.",
			pDevice);


		//
		// Remember that we're not trying remotely.
		//
		pDevice->NoteNotPerformingRemoteUPnPDiscovery();
	}


	//
	// If we didn't already get a CONNRESET from a previous attempt, try to
	// bind a socket locally to the UPnP discovery port.  If it's not in use,
	// then we know nobody will be listening so there's no point in trying the
	// local address.  If it is in use, then this computer might be a UPnP
	// gateway itself.
	//
	if (! pDevice->GotLocalUPnPDiscoveryConnReset())
	{
		sTemp = this->m_pfnsocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
		if (sTemp == INVALID_SOCKET)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't create temporary datagram socket, error = %u!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		if (this->m_pfnbind(sTemp,
							(SOCKADDR *) (&saddrinLocal),
							sizeof(saddrinLocal)) != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 2, "Couldn't bind socket to UPnP discovery port (%u.%u.%u.%u:%u), assuming local device (error = %u).",
				saddrinLocal.sin_addr.S_un.S_un_b.s_b1,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b2,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b3,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b4,
				NTOHS(saddrinLocal.sin_port),
				dwError);
#endif // DBG


			//
			// Remember that we're trying locally.
			//
			pDevice->NotePerformingLocalUPnPDiscovery();

			//
			// Remember the current time, if this is the first thing we've sent
			// from this port.
			//
			if (pDevice->GetFirstUPnPDiscoveryTime() == 0)
			{
				pDevice->SetFirstUPnPDiscoveryTime(GETTIMESTAMP());
			}


			//
			// Do WANIPConnection first.
			//

			DPFX(DPFPREP, 7, "Sending UPnP discovery messages (WANIPConnection and WANPPPConnection) locally to device 0x%p (address %u.%u.%u.%u:%u).",
				pDevice,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b1,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b2,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b3,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b4,
				NTOHS(saddrinLocal.sin_port));



			iReturn = this->m_pfnsendto(pDevice->GetUPnPDiscoverySocket(),
										c_szUPnPMsg_Discover_Service_WANIPConnection,
										iWANIPConnectionMsgSize,
										0,
										(SOCKADDR*) (&saddrinLocal),
										sizeof(saddrinLocal));

			if (iReturn == SOCKET_ERROR)
			{
#ifdef DBG
				dwError = this->m_pfnWSAGetLastError();
				DPFX(DPFPREP, 0, "Got sockets error %u when sending WANIPConnection discovery to local address on device 0x%p!  Ignoring.",
					dwError, pDevice);
#endif // DBG

				//
				// It's possible that we caught WinSock at a bad time,
				// particularly with WSAEADDRNOTAVAIL (10049), which seems to
				// occur if the address is going away (and we haven't detected
				// it in CheckForNewDevices yet).
				//
				// Ignore the error, we can survive.
				//
			}
			else
			{
				if (iReturn != iWANIPConnectionMsgSize)
				{
					DPFX(DPFPREP, 0, "Didn't send entire WANIPConnection discovery datagram locally on device 0x%p (%i != %i)?!",
						pDevice, iReturn, iWANIPConnectionMsgSize);
					DNASSERT(FALSE);
					hr = DPNHERR_GENERIC;
					goto Failure;
				}
			}


			//
			// Now send WANPPPConnection discovery message locally.
			//
			iReturn = this->m_pfnsendto(pDevice->GetUPnPDiscoverySocket(),
										c_szUPnPMsg_Discover_Service_WANPPPConnection,
										iWANPPPConnectionMsgSize,
										0,
										(SOCKADDR*) (&saddrinLocal),
										sizeof(saddrinLocal));

			if (iReturn == SOCKET_ERROR)
			{
#ifdef DBG
				dwError = this->m_pfnWSAGetLastError();
				DPFX(DPFPREP, 0, "Got sockets error %u when sending WANPPPConnection discovery to local address on device 0x%p!  Ignoring.",
					dwError, pDevice);
#endif // DBG

				//
				// It's possible that we caught WinSock at a bad time,
				// particularly with WSAEADDRNOTAVAIL (10049), which seems to
				// occur if the address is going away (and we haven't detected
				// it in CheckForNewDevices yet).
				//
				// Ignore the error, we can survive.
				//
			}
			else
			{
				if (iReturn != iWANPPPConnectionMsgSize)
				{
					DPFX(DPFPREP, 0, "Didn't send entire WANPPPConnection discovery datagram locally on device 0x%p (%i != %i)?!",
						pDevice, iReturn, iWANPPPConnectionMsgSize);
					DNASSERT(FALSE);
					hr = DPNHERR_GENERIC;
					goto Failure;
				}
			}
		}
		else
		{
			DPFX(DPFPREP, 2, "Successfully bound socket to UPnP discovery port (%u.%u.%u.%u:%u), assuming no local UPnP device.",
				saddrinLocal.sin_addr.S_un.S_un_b.s_b1,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b2,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b3,
				saddrinLocal.sin_addr.S_un.S_un_b.s_b4,
				NTOHS(saddrinLocal.sin_port));

			//
			// Remember that we're not trying locally.
			//
			pDevice->NoteNotPerformingLocalUPnPDiscovery();
		}
	}
	else
	{
		//
		// We got a CONNRESET last time.
		//
	}


Exit:

	if (sTemp != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(sTemp);
		sTemp = INVALID_SOCKET;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::SendUPnPSearchMessagesForDevice





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SendUPnPDescriptionRequest"
//=============================================================================
// CNATHelpUPnP::SendUPnPDescriptionRequest
//-----------------------------------------------------------------------------
//
// Description:    Requests a description from the given UPnP device.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice	- Pointer to UPnP device to use.
//
// Returns: HRESULT
//	DPNH_OK				- The message was sent successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::SendUPnPDescriptionRequest(CUPnPDevice * const pUPnPDevice)
{
	HRESULT			hr = DPNH_OK;
	SOCKADDR_IN *	psaddrinHost;
	TCHAR			tszHost[22]; // "xxx.xxx.xxx.xxx:xxxxx" + NULL termination
	char *			pszMessage = NULL;
	int				iMsgSize;
	int				iReturn;
#ifdef DBG
	DWORD			dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pUPnPDevice);


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);
	DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);
	DNASSERT(pUPnPDevice->IsConnected());
	DNASSERT(pUPnPDevice->GetLocationURL() != NULL);


	psaddrinHost = pUPnPDevice->GetHostAddress();

	wsprintf(tszHost, _T("%u.%u.%u.%u:%u"),
		psaddrinHost->sin_addr.S_un.S_un_b.s_b1,
		psaddrinHost->sin_addr.S_un.S_un_b.s_b2,
		psaddrinHost->sin_addr.S_un.S_un_b.s_b3,
		psaddrinHost->sin_addr.S_un.S_un_b.s_b4,
		NTOHS(psaddrinHost->sin_port));

	iMsgSize = strlen("GET ") + strlen(pUPnPDevice->GetLocationURL()) + strlen(" " HTTP_VERSION EOL)
				+ strlen("HOST: ") + _tcslen(tszHost) + strlen(EOL)
				+ strlen("ACCEPT-LANGUAGE: en" EOL)
				+ strlen(EOL);


	pszMessage = (char*) DNMalloc(iMsgSize + 1); // include room for NULL termination that isn't actually sent
	if (pszMessage == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	strcpy(pszMessage, "GET ");
	strcat(pszMessage, pUPnPDevice->GetLocationURL());
	strcat(pszMessage, " " HTTP_VERSION EOL);
	strcat(pszMessage, "HOST: ");
#ifdef UNICODE
	STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
					tszHost,
					(_tcslen(tszHost) + 1));
#else // ! UNICODE
	strcat(pszMessage, tszHost);
#endif // ! UNICODE
	strcat(pszMessage, EOL);
	strcat(pszMessage, "ACCEPT-LANGUAGE: en" EOL);
	strcat(pszMessage, EOL);


#ifdef DBG
	this->PrintUPnPTransactionToFile(pszMessage,
									iMsgSize,
									"Outbound description request",
									pUPnPDevice->GetOwningDevice());
#endif // DBG

	iReturn = this->m_pfnsend(pUPnPDevice->GetControlSocket(),
								pszMessage,
								iMsgSize,
								0);

	if (iReturn == SOCKET_ERROR)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Got sockets error %u when sending to UPnP device!", dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if (iReturn != iMsgSize)
	{
		DPFX(DPFPREP, 0, "Didn't send entire message (%i != %i)?!", iReturn, iMsgSize);
		DNASSERT(FALSE);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}



Exit:

	if (pszMessage != NULL)
	{
		DNFree(pszMessage);
		pszMessage = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::SendUPnPDescriptionRequest





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::UpdateUPnPExternalAddress"
//=============================================================================
// CNATHelpUPnP::UpdateUPnPExternalAddress
//-----------------------------------------------------------------------------
//
// Description:    Retreives the current external address for the given UPnP
//				Internet Gateway Device.
//
//				   The UPnP device may get removed from list if a failure
//				occurs, the caller needs to have a reference.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice	- Pointer to UPnP device that should be
//									updated.
//	BOOL fUpdateRegisteredPorts	- TRUE if existing registered ports should be
//									updated to reflect the new address if it
//									changed, FALSE if not.
//
// Returns: HRESULT
//	DPNH_OK							- The update was successful.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the
//										message.
//=============================================================================
HRESULT CNATHelpUPnP::UpdateUPnPExternalAddress(CUPnPDevice * const pUPnPDevice,
												  const BOOL fUpdateRegisteredPorts)
{
	HRESULT						hr;
	BOOL						fStartedWaitingForControlResponse = FALSE;
	CDevice *					pDevice;
	SOCKADDR_IN *				psaddrinTemp;
	int							iContentLength;
	TCHAR						tszContentLength[32];
	TCHAR						tszHost[22]; // "xxx.xxx.xxx.xxx:xxxxx" + NULL termination
	char *						pszMessage = NULL;
	int							iMsgSize;
	int							iPrevMsgSize = 0;
	int							iReturn;
	UPNP_CONTROLRESPONSE_INFO	RespInfo;
	DWORD						dwStartTime;
	DWORD						dwTimeout;
	CBilink *					pBilink;
	CRegisteredPort *			pRegisteredPort;
#ifdef DBG
	DWORD						dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i)",
		this, pUPnPDevice, fUpdateRegisteredPorts);


	DNASSERT(pUPnPDevice != NULL);
	DNASSERT(pUPnPDevice->IsReady());

	pDevice = pUPnPDevice->GetOwningDevice();
	DNASSERT(pDevice != NULL);


	DNASSERT(this->m_dwFlags & (NATHELPUPNPOBJ_INITIALIZED | NATHELPUPNPOBJ_USEUPNP));

	DNASSERT(pUPnPDevice->GetServiceControlURL() != NULL);

	//
	// If the control socket got disconnected after the last message, then
	// reconnect.
	//
	if (! pUPnPDevice->IsConnected())
	{
		hr = this->ReconnectUPnPControlSocket(pUPnPDevice);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't reconnect UPnP control socket!");
			goto Failure;
		}
	}

	DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);



	psaddrinTemp = pUPnPDevice->GetHostAddress();
	wsprintf(tszHost, _T("%u.%u.%u.%u:%u"),
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b1,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b2,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b3,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b4,
			NTOHS(psaddrinTemp->sin_port));


	/*
	iContentLength = strlen("<s:Envelope" EOL)
					+ strlen("    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL)
					+ strlen("    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL)
					+ strlen("  <s:Body>" EOL)
					+ strlen("    <u:" CONTROL_QUERYSTATEVARIABLE_A " xmlns:u=\"" URI_CONTROL_A "\">" EOL)
					+ strlen("      <u:" ARG_CONTROL_VARNAME_A ">" VAR_EXTERNALIPADDRESS_A "</u:" ARG_CONTROL_VARNAME_A ">" EOL)
					+ strlen("    </u:" CONTROL_QUERYSTATEVARIABLE_A ">" EOL)
					+ strlen("  </s:Body>" EOL)
					+ strlen("</s:Envelope>" EOL)
					+ strlen(EOL);

	wsprintf(tszContentLength, _T("%i"), iContentLength);

	iMsgSize = strlen("POST ") + strlen(pUPnPDevice->GetServiceControlURL()) + strlen(" " HTTP_VERSION EOL)
				+ strlen("HOST: ") + _tcslen(tszHost) + strlen(EOL)
				+ strlen("CONTENT-LENGTH: ") + strlen(szContentLength) + strlen(EOL)
				+ strlen("CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL)
				+ strlen("SOAPACTION: " URI_CONTROL_A "#" CONTROL_QUERYSTATEVARIABLE_A "" EOL)
				+ strlen(EOL)
				+ iContentLength;
	*/
	iContentLength = strlen("<s:Envelope" EOL)
					+ strlen("    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL)
					+ strlen("    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL)
					+ strlen("  <s:Body>" EOL)
					+ strlen("    <u:" ACTION_GETEXTERNALIPADDRESS_A " xmlns:u=\"") + pUPnPDevice->GetStaticServiceURILength() + strlen("\">" EOL)
					+ strlen("    </u:" ACTION_GETEXTERNALIPADDRESS_A ">" EOL)
					+ strlen("  </s:Body>" EOL)
					+ strlen("</s:Envelope>" EOL)
					+ strlen(EOL);

	wsprintf(tszContentLength, _T("%i"), iContentLength);

	iMsgSize = strlen("POST ") + strlen(pUPnPDevice->GetServiceControlURL()) + strlen(" " HTTP_VERSION EOL)
				+ strlen("HOST: ") + _tcslen(tszHost) + strlen(EOL)
				+ strlen("CONTENT-LENGTH: ") + _tcslen(tszContentLength) + strlen(EOL)
				+ strlen("CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL)
				+ strlen("SOAPACTION: ") + pUPnPDevice->GetStaticServiceURILength() + strlen("#" ACTION_GETEXTERNALIPADDRESS_A EOL)
				+ strlen(EOL)
				+ iContentLength;


	//
	// Allocate (or reallocate) the message buffer.
	//
	if (iMsgSize > iPrevMsgSize)
	{
		if (pszMessage != NULL)
		{
			DNFree(pszMessage);
			pszMessage = NULL;
		}

		pszMessage = (char*) DNMalloc(iMsgSize + 1); // include room for NULL termination that isn't actually sent
		if (pszMessage == NULL)
		{
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}

		iPrevMsgSize = iMsgSize;
	}

	/*
	strcpy(pszMessage, "POST ");
	strcat(pszMessage, pUPnPDevice->GetServiceControlURL());
	strcat(pszMessage, " " HTTP_VERSION EOL);
	strcat(pszMessage, "HOST: ");
#ifdef UNICODE
	STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
					tszHost,
					(_tcslen(tszHost) + 1));
#else // ! UNICODE
	strcat(pszMessage, tszHost);
#endif // ! UNICODE
	strcat(pszMessage, EOL);
	strcat(pszMessage, "CONTENT-LENGTH: ");
#ifdef UNICODE
	STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
					tszContentLength,
					(_tcslen(tszContentLength) + 1));
#else // ! UNICODE
	strcat(pszMessage, tszContentLength);
#endif // ! UNICODE
	strcat(pszMessage, EOL);
	strcat(pszMessage, "CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL);
	strcat(pszMessage, "SOAPACTION: " URI_CONTROL_A "#" CONTROL_QUERYSTATEVARIABLE_A "" EOL);
	strcat(pszMessage, EOL);


	strcat(pszMessage, "<s:Envelope" EOL);
	strcat(pszMessage, "    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL);
	strcat(pszMessage, "    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL);
	strcat(pszMessage, "  <s:Body>" EOL);
	strcat(pszMessage, "    <u:" CONTROL_QUERYSTATEVARIABLE_A " xmlns:u=\"" URI_CONTROL_A "\">" EOL);
	strcat(pszMessage, "      <u:" ARG_CONTROL_VARNAME_A ">" VAR_EXTERNALIPADDRESS_A "</u:" ARG_CONTROL_VARNAME_A ">" EOL);
	strcat(pszMessage, "    </u:" CONTROL_QUERYSTATEVARIABLE_A ">" EOL);
	strcat(pszMessage, "  </s:Body>" EOL);
	strcat(pszMessage, "</s:Envelope>" EOL);
	strcat(pszMessage, EOL);
	*/
	strcpy(pszMessage, "POST ");
	strcat(pszMessage, pUPnPDevice->GetServiceControlURL());
	strcat(pszMessage, " " HTTP_VERSION EOL);
	strcat(pszMessage, "HOST: ");
#ifdef UNICODE
	STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
					tszHost,
					(_tcslen(tszHost) + 1));
#else // ! UNICODE
	strcat(pszMessage, tszHost);
#endif // ! UNICODE
	strcat(pszMessage, EOL);
	strcat(pszMessage, "CONTENT-LENGTH: ");
#ifdef UNICODE
	STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
					tszContentLength,
					(_tcslen(tszContentLength) + 1));
#else // ! UNICODE
	strcat(pszMessage, tszContentLength);
#endif // ! UNICODE
	strcat(pszMessage, EOL);
	strcat(pszMessage, "CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL);
	strcat(pszMessage, "SOAPACTION: ");
	strcat(pszMessage, pUPnPDevice->GetStaticServiceURI());
	strcat(pszMessage, "#" ACTION_GETEXTERNALIPADDRESS_A EOL);
	strcat(pszMessage, EOL);


	strcat(pszMessage, "<s:Envelope" EOL);
	strcat(pszMessage, "    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL);
	strcat(pszMessage, "    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL);
	strcat(pszMessage, "  <s:Body>" EOL);
	strcat(pszMessage, "    <u:" ACTION_GETEXTERNALIPADDRESS_A " xmlns:u=\"");
	strcat(pszMessage, pUPnPDevice->GetStaticServiceURI());
	strcat(pszMessage, "\">" EOL);
	strcat(pszMessage, "    </u:" ACTION_GETEXTERNALIPADDRESS_A ">" EOL);
	strcat(pszMessage, "  </s:Body>" EOL);
	strcat(pszMessage, "</s:Envelope>" EOL);
	strcat(pszMessage, EOL);


#ifdef DBG
	this->PrintUPnPTransactionToFile(pszMessage,
									iMsgSize,
									//"Outbound query external IP address",
									"Outbound get external IP address",
									pDevice);
#endif // DBG

	iReturn = this->m_pfnsend(pUPnPDevice->GetControlSocket(),
								pszMessage,
								iMsgSize,
								0);

	if (iReturn == SOCKET_ERROR)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Got sockets error %u when sending control request to UPnP device!", dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if (iReturn != iMsgSize)
	{
		DPFX(DPFPREP, 0, "Didn't send entire message (%i != %i)?!", iReturn, iMsgSize);
		DNASSERT(FALSE);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	//
	// We have the lock so no one could have tried to receive data from the
	// control socket yet.  Mark the device as waiting for a response.
	//
	ZeroMemory(&RespInfo, sizeof(RespInfo));
	//pUPnPDevice->StartWaitingForControlResponse(CONTROLRESPONSETYPE_QUERYSTATEVARIABLE_EXTERNALIPADDRESS,
	pUPnPDevice->StartWaitingForControlResponse(CONTROLRESPONSETYPE_GETEXTERNALIPADDRESS,
												&RespInfo);
	fStartedWaitingForControlResponse = TRUE;


	//
	// Actually wait for the response.
	//
	dwStartTime = GETTIMESTAMP();
	dwTimeout = g_dwUPnPResponseTimeout;
	do
	{
		hr = this->CheckForReceivedUPnPMsgsOnDevice(pUPnPDevice, dwTimeout);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed receiving UPnP messages!");
			goto Failure;
		}

		//
		// We either timed out or got some data.  Check if we got a
		// response of some type.
		//
		if (! pUPnPDevice->IsWaitingForControlResponse())
		{
			break;
		}


		//
		// Make sure our device is still connected.
		//
		if (! pUPnPDevice->IsConnected())
		{
			DPFX(DPFPREP, 0, "UPnP device 0x%p disconnected while retrieving external IP address!",
				pUPnPDevice);
				
			pUPnPDevice->StopWaitingForControlResponse();
				
			hr = DPNHERR_SERVERNOTRESPONDING;
			goto Failure;
		}


		//
		// Calculate how long we have left to wait.  If the calculation
		// goes negative, it means we're done.
		//
		dwTimeout = g_dwUPnPResponseTimeout - (GETTIMESTAMP() - dwStartTime);
	}
	while (((int) dwTimeout > 0));


	//
	// If we never got the response, stop waiting for it.
	//
	if (pUPnPDevice->IsWaitingForControlResponse())
	{
		pUPnPDevice->StopWaitingForControlResponse();

		DPFX(DPFPREP, 0, "Server didn't respond in time!");
		hr = DPNHERR_SERVERNOTRESPONDING;
		goto Failure;
	}


	//
	// If we're here, then we've gotten a valid response from the server.
	//
	if (RespInfo.hrErrorCode != DPNH_OK)
	{
		DPFX(DPFPREP, 1, "Server returned failure response 0x%lx when retrieving external IP address.",
			RespInfo.hrErrorCode);

		hr = RespInfo.hrErrorCode;
		goto Failure;
	}


	DPFX(DPFPREP, 1, "Server returned external IP address \"%u.%u.%u.%u\".",
		((IN_ADDR*) (&RespInfo.dwExternalIPAddressV4))->S_un.S_un_b.s_b1,
		((IN_ADDR*) (&RespInfo.dwExternalIPAddressV4))->S_un.S_un_b.s_b2,
		((IN_ADDR*) (&RespInfo.dwExternalIPAddressV4))->S_un.S_un_b.s_b3,
		((IN_ADDR*) (&RespInfo.dwExternalIPAddressV4))->S_un.S_un_b.s_b4);


	//
	// Convert the loopback address to the device address.
	//
	if (RespInfo.dwExternalIPAddressV4 == NETWORKBYTEORDER_INADDR_LOOPBACK)
	{
		RespInfo.dwExternalIPAddressV4 = pDevice->GetLocalAddressV4();

		DPFX(DPFPREP, 0, "Converted private loopback address to device address (%u.%u.%u.%u)!",
			((IN_ADDR*) (&RespInfo.dwExternalIPAddressV4))->S_un.S_un_b.s_b1,
			((IN_ADDR*) (&RespInfo.dwExternalIPAddressV4))->S_un.S_un_b.s_b2,
			((IN_ADDR*) (&RespInfo.dwExternalIPAddressV4))->S_un.S_un_b.s_b3,
			((IN_ADDR*) (&RespInfo.dwExternalIPAddressV4))->S_un.S_un_b.s_b4);

		DNASSERTX(! "Got loopback address as external IP address!", 2);
	}


#ifdef DBG
	//
	// If this is a local UPnP gateway, print out the device corresponding to
	// the public address.
	//
	if (pUPnPDevice->IsLocal())
	{
		if (RespInfo.dwExternalIPAddressV4 != 0)
		{
			CDevice *		pPublicDevice;


			//
			// Loop through every device.
			//
			pBilink = this->m_blDevices.GetNext();
			while (pBilink != &this->m_blDevices)
			{
				pPublicDevice = DEVICE_FROM_BILINK(pBilink);

				if (pPublicDevice->GetLocalAddressV4() == RespInfo.dwExternalIPAddressV4)
				{
					DPFX(DPFPREP, 7, "Local UPnP gateway 0x%p for device 0x%p's public address is device 0x%p.",
						pUPnPDevice, pDevice, pPublicDevice);
					break;
				}

				pBilink = pBilink->GetNext();
			}

			//
			// If we made it through the entire list without matching the device,
			// that's odd.  It's possible we're slow in detecting new devices, so
			// don't get bent out of shape.
			//
			if (pBilink == &this->m_blDevices)
			{
				DPFX(DPFPREP, 0, "Couldn't match up local UPnP gateway 0x%p (device 0x%p)'s public address to a device!",
					pUPnPDevice, pDevice);
				DNASSERTX(! "Couldn't match up local UPnP gateway public address to a device!", 2);
			}
		}
		else
		{
			DPFX(DPFPREP, 4, "Local UPnP gateway 0x%p (device 0x%p) does not have a valid public address.",
				pUPnPDevice, pDevice);
		}
	}
#endif // DBG


	//
	// If the public address has changed, update all the existing mappings.
	//
	if (RespInfo.dwExternalIPAddressV4 != pUPnPDevice->GetExternalIPAddressV4())
	{
		DPFX(DPFPREP, 1, "UPnP Internet Gateway Device (0x%p) external address changed.",
			pUPnPDevice);

		//
		// Since there was a change in the network, go back to polling
		// relatively quickly.
		//
		this->ResetNextPollInterval();


		//
		// Loop through all the existing registered ports and update their
		// public addresses, if allowed.
		//
		if (fUpdateRegisteredPorts)
		{
			pBilink = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilink != &pDevice->m_blOwnedRegPorts)
			{
				DNASSERT(! pBilink->IsEmpty());
				pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

				if (! pRegisteredPort->IsUPnPPortUnavailable())
				{
					DPFX(DPFPREP, 7, "Updating registered port 0x%p's public address.",
						pRegisteredPort);
					
					pRegisteredPort->UpdateUPnPPublicV4Addresses(RespInfo.dwExternalIPAddressV4);

					//
					// The user should call GetCaps to detect the address change.
					//
					this->m_dwFlags |= NATHELPUPNPOBJ_ADDRESSESCHANGED;
				}
				else
				{
					DPFX(DPFPREP, 7, "Not updating registered port 0x%p's public address because the port is unavailable.",
						pRegisteredPort);
				}

				pBilink = pBilink->GetNext();
			}
		}


		//
		// Store the new public address.
		//
		pUPnPDevice->SetExternalIPAddressV4(RespInfo.dwExternalIPAddressV4);
	}


Exit:

	if (pszMessage != NULL)
	{
		DNFree(pszMessage);
		pszMessage = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// If we started waiting for a response, clear that.
	//
	if (fStartedWaitingForControlResponse)
	{
		pUPnPDevice->StopWaitingForControlResponse();
	}

	goto Exit;
} // CNATHelpUPnP::UpdateUPnPExternalAddress





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::MapPortsOnUPnPDevice"
//=============================================================================
// CNATHelpUPnP::MapPortsOnUPnPDevice
//-----------------------------------------------------------------------------
//
// Description:    Maps the given ports on the given UPnP device.
//
//				   The UPnP device may get removed from list if a failure
//				occurs, the caller needs to have a reference.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice			- Pointer to UPnP device to use.
//	CRegisteredPort * pRegisteredPort	- Pointer to ports to register.
//
// Returns: HRESULT
//	DPNH_OK							- The message was sent successfully.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_SERVERNOTRESPONDING		- A response didn't arrive in time.
//=============================================================================
HRESULT CNATHelpUPnP::MapPortsOnUPnPDevice(CUPnPDevice * const pUPnPDevice,
											CRegisteredPort * const pRegisteredPort)
{
	HRESULT						hr = DPNH_OK;
	HRESULT						temphr;
	BOOL						fStartedWaitingForControlResponse = FALSE;
	CDevice *					pDevice;
	DWORD						dwLeaseExpiration;
	IN_ADDR						inaddrTemp;
	SOCKADDR_IN *				psaddrinTemp;
	WORD						wOriginalExternalPortHostOrder = 0;
	WORD						wExternalPortHostOrder;
	TCHAR						tszInternalPort[32];
	TCHAR						tszExternalPort[32];
	TCHAR						tszInternalClient[16]; // "xxx.xxx.xxx.xxx" + NULL termination
	TCHAR						tszLeaseDuration[32];
	TCHAR						tszDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	int							iContentLength;
	TCHAR						tszContentLength[32];
	TCHAR						tszHost[22]; // "xxx.xxx.xxx.xxx:xxxxx" + NULL termination
	char *						pszMessage = NULL;
	int							iMsgSize;
	int							iPrevMsgSize = 0;
	int							iReturn;
	DWORD						dwTemp = 0;
	UPNP_CONTROLRESPONSE_INFO	RespInfo;
	DWORD						dwStartTime;
	DWORD						dwTimeout;
	BOOL						fFirstLease;
	DWORD						dwDescriptionLength;
#ifndef DPNBUILD_NOWINSOCK2
	BOOL						fResult;
#endif // ! DPNBUILD_NOWINSOCK2
#ifdef DBG
	DWORD						dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pUPnPDevice);


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);
	DNASSERT(pUPnPDevice->IsReady());

	pDevice = pRegisteredPort->GetOwningDevice();

	DNASSERT(pDevice != NULL);
	DNASSERT(pUPnPDevice->GetOwningDevice() == pDevice);


	//
	// Set up variables we'll need.
	//
	DNASSERT(pUPnPDevice->GetServiceControlURL() != NULL);


	//
	// If the port is shared, register the broadcast address instead of the
	// local device address.
	//
	if (pRegisteredPort->IsSharedPort())
	{
		_tcscpy(tszInternalClient, _T("255.255.255.255"));
	}
	else
	{
		//
		// Note that the device address is not necessarily the same as the
		// address the user originally registered, particularly the 0.0.0.0
		// wildcard address will get remapped.
		//
		inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();
		wsprintf(tszInternalClient, _T("%u.%u.%u.%u"),
				inaddrTemp.S_un.S_un_b.s_b1,
				inaddrTemp.S_un.S_un_b.s_b2,
				inaddrTemp.S_un.S_un_b.s_b3,
				inaddrTemp.S_un.S_un_b.s_b4);
	}


	//
	// The current Microsoft UPnP Internet Gateway Device implementation--
	// and most others-- do not support lease durations that are not set
	// for INFINITE time, so we will almost certainly fail.  Because of
	// that, and since there's no server to test against anyway, we will
	// not even attempt to use non-INFINITE leases.  However, you can use
	// the registry key to take a shot at it if you like living on the
	// edge.
	// Note that there's no way to detect whether a given UPnP
	// implementation will allow non-INFINITE lease durations ahead of time,
	// so we have to try it first, and fall back to the infinite lease
	// behavior if it doesn't work.  Ugh.
	//
	if ((! pUPnPDevice->DoesNotSupportLeaseDurations()) && (g_fUseLeaseDurations))
	{
		wsprintf(tszLeaseDuration, _T("%u"),
				(pRegisteredPort->GetRequestedLeaseTime() / 1000));
	}
	else
	{
		_tcscpy(tszLeaseDuration, _T("0"));
		pRegisteredPort->NotePermanentUPnPLease();
	}

	psaddrinTemp = pUPnPDevice->GetHostAddress();
	wsprintf(tszHost, _T("%u.%u.%u.%u:%u"),
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b1,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b2,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b3,
			psaddrinTemp->sin_addr.S_un.S_un_b.s_b4,
			NTOHS(psaddrinTemp->sin_port));


	//
	// Create the array to hold the resulting public addresses.
	//
	hr = pRegisteredPort->CreateUPnPPublicAddressesArray();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create UPnP public addresses array!");
		goto Failure;
	}


	//
	// Note whether this was the first lease or not.
	//
	fFirstLease = (this->m_dwNumLeases == 0) ? TRUE : FALSE;
	this->m_dwNumLeases++;

	DPFX(DPFPREP, 7, "UPnP lease for 0x%p added, total num leases = %u.",
		pRegisteredPort, this->m_dwNumLeases);


	//
	// Assuming all goes well, the first port lease will expire approximately
	// GetRequestedLeaseTime() ms from now.
	// See above note about whether this lease will actually be used, though.
	//
	dwLeaseExpiration = GETTIMESTAMP() + pRegisteredPort->GetRequestedLeaseTime();



	//
	// Get a pointer to the addresses we're mapping.  We don't have to worry
	// about whether it's mapped on a local firewall since the HomeNet API will
	// always map it to the same port.
	//
	psaddrinTemp = pRegisteredPort->GetPrivateAddressesArray();


	//
	// Loop through each port and map it.
	//
	for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
	{
		//
		// Determine the public port number to register.
		//
		if (! pRegisteredPort->IsFixedPort())
		{
			//
			// UPnP does not support wildcard ports (where the gateway
			// device picks an unused public port number for us).  We must
			// select a port ahead of time to try mapping on the server.
			//
			// Worse, UPnP does not require the device support selecting a
			// public port that is different from the client's private port
			// (a.k.a. asymmetric, x to y, or floating port mappings). 
			// This means that even non fixed ports will act that way.  To
			// top it all off, there's no way to detect whether a given
			// UPnP implementation will allow the ports to differ ahead of
			// time, so we have to try it first, and fall back to the fixed
			// port behavior if it doesn't work.  Ugh.
			//

			if (pUPnPDevice->DoesNotSupportAsymmetricMappings())
			{
				//
				// We are forced to use the client's private port.
				//
				wExternalPortHostOrder = NTOHS(psaddrinTemp[dwTemp].sin_port);
			}
			else
			{
				if (wOriginalExternalPortHostOrder == 0)
				{
					DNASSERT(dwTemp == 0);

					//
					// Ideally we would pick a random port that isn't in
					// the reserved range (i.e. is greater than 1024).
					// However, truly random ports cause problems with the
					// Windows XP ICS implementation in a fairly obscure
					// manner:
					//
					//	1. DPlay application starts hosting behind ICS on
					//		port 2302.
					//	2. Port 2302 gets mapped to random port x.
					//	3. External DPlay client is told to connect to x.
					//	4. ICS detects inbound traffic to x, sees mapping
					//		for internal_ip:2302, and creates a virtual
					//		connection.
					//	5. Internal client removes 2302<->x mapping and
					//		closes socket.
					//	6. Internal DPlay application begins hosting on
					//		port 2302 again.
					//	7. Port 2302 gets mapped to random port y.
					//	8. External DPlay client is told to connect to y.
					//	9. ICS detects inbound traffic to y, sees mapping
					//		for internal_ip:2302, but can't create virtual
					//		connection because the 2302<->x connection
					//		still exists.
					//
					// Windows XP ICS keeps the virtual connections around
					// and cleans them up every 60 seconds.  If the
					// reconnect occurs within (up to) 2 minutes, the
					// packets might get dropped due to the mapping
					// collision.
					//
					// This causes all sorts of heartache with automated
					// NAT tests that bring up and tear down connections
					// between the same two machines across the NAT over
					// and