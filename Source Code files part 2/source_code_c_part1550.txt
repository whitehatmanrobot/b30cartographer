_text_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        __gls_decode_text_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        __gls_decode_text_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        __gls_decode_text_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        __gls_decode_text_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_text_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_text_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        __gls_decode_text_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        __gls_decode_text_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_text_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_text_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        __gls_decode_text_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_text_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_text_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_text_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        __gls_decode_text_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        __gls_decode_text_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        __gls_decode_text_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    GLS_NONE, // __GL_WIN_draw_range_elements
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_dectxt.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"
#include "stdlib.h"

void __gls_decode_text_glsBeginGLS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint inVersionMajor;
    GLint inVersionMinor;
    __glsReader_getGLint_text(inoutReader, &inVersionMajor);
    __glsReader_getGLint_text(inoutReader, &inVersionMinor);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[16])(
        inVersionMajor,
        inVersionMinor
    );
end:
    return;
}

void __gls_decode_text_glsBlock(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum);
    GLSenum inBlockType;
    __glsReader_getGLSenum_text(inoutReader, &inBlockType);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[17])(
        inBlockType
    );
end:
    return;
}

void __gls_decode_text_glsCallStream(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLSstring inName;
    __glsString_init(&inName);
    __glsReader_getGLcharv_text(inoutReader, &inName);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[18])(
        inName.head
    );
end:
    __glsString_final(&inName);
    return;
}

void __gls_decode_text_glsEndGLS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[19])(
    );
end:
    return;
}

void __gls_decode_text_glsError(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);
    GLSopcode inOpcode;
    GLSenum inError;
    __glsReader_getGLSopcode_text(inoutReader, &inOpcode);
    __glsReader_getGLSenum_text(inoutReader, &inError);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[20])(
        inOpcode,
        inError
    );
end:
    return;
}

void __gls_decode_text_glsGLRC(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint inGLRC;
    __glsReader_getGLuint_text(inoutReader, &inGLRC);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[21])(
        inGLRC
    );
end:
    return;
}

void __gls_decode_text_glsGLRCLayer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    GLuint inGLRC;
    GLuint inLayer;
    GLuint inReadLayer;
    __glsReader_getGLuint_text(inoutReader, &inGLRC);
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    __glsReader_getGLuint_text(inoutReader, &inReadLayer);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[22])(
        inGLRC,
        inLayer,
        inReadLayer
    );
end:
    return;
}

void __gls_decode_text_glsHeaderGLRCi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    GLuint inGLRC;
    GLSenum inAttrib;
    GLint inVal;
    __glsReader_getGLuint_text(inoutReader, &inGLRC);
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[23])(
        inGLRC,
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderLayerf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLfloat);
    GLuint inLayer;
    GLSenum inAttrib;
    GLfloat inVal;
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLfloat_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[24])(
        inLayer,
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderLayeri(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    GLuint inLayer;
    GLSenum inAttrib;
    GLint inVal;
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[25])(
        inLayer,
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, GLfloat);
    GLSenum inAttrib;
    GLfloat inVal;
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLfloat_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[26])(
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, const GLfloat *);
    GLSenum inAttrib;
    GLint inVec_count;
    GLfloat *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    inVec_count = __gls_glsHeaderfv_inVec_size(inAttrib);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLfloat, 4 * inVec_count);
    if (!inVec) goto end;
    __glsReader_getGLfloatv_text(inoutReader, inVec_count, inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[27])(
        inAttrib,
        inVec
    );
end:
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsHeaderi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, GLint);
    GLSenum inAttrib;
    GLint inVal;
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[28])(
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, const GLint *);
    GLSenum inAttrib;
    GLint inVec_count;
    GLint *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    inVec_count = __gls_glsHeaderiv_inVec_size(inAttrib);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLint, 4 * inVec_count);
    if (!inVec) goto end;
    __glsReader_getGLintv_text(inoutReader, inVec_count, inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[29])(
        inAttrib,
        inVec
    );
end:
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsHeaderubz(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, const GLubyte *);
    GLSenum inAttrib;
    __GLSstring inString;
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsString_init(&inString);
    __glsReader_getGLcharv_text(inoutReader, &inString);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[30])(
        inAttrib,
        inString.head
    );
end:
    __glsString_final(&inString);
    return;
}

void __gls_decode_text_glsRequireExtension(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLSstring inExtension;
    __glsString_init(&inExtension);
    __glsReader_getGLcharv_text(inoutReader, &inExtension);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[31])(
        inExtension.head
    );
end:
    __glsString_final(&inExtension);
    return;
}

void __gls_decode_text_glsUnsupportedCommand(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[32])(
    );
end:
    return;
}

void __gls_decode_text_glsAppRef(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLulong, GLuint);
    GLulong inAddress;
    GLuint inCount;
    __glsReader_getGLulong_text(inoutReader, &inAddress);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[33])(
        inAddress,
        inCount
    );
end:
    return;
}

void __gls_decode_text_glsBeginObj(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLSstring inTag;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[34])(
        inTag.head
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsCharubz(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, const GLubyte *);
    __GLSstring inTag;
    __GLSstring inString;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsString_init(&inString);
    __glsReader_getGLcharv_text(inoutReader, &inString);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[35])(
        inTag.head,
        inString.head
    );
end:
    __glsString_final(&inTag);
    __glsString_final(&inString);
    return;
}

void __gls_decode_text_glsComment(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLSstring inComment;
    __glsString_init(&inComment);
    __glsReader_getGLcharv_text(inoutReader, &inComment);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[36])(
        inComment.head
    );
end:
    __glsString_final(&inComment);
    return;
}

void __gls_decode_text_glsDisplayMapfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLuint, const GLfloat *);
    GLuint inLayer;
    GLSenum inMap;
    GLuint inCount;
    GLfloat *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    __glsReader_getGLSenum_text(inoutReader, &inMap);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLfloat, 4 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[37])(
        inLayer,
        inMap,
        inCount,
        inVec
    );
end:
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsEndObj(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[38])(
    );
end:
    return;
}

void __gls_decode_text_glsNumb(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLbyte);
    __GLSstring inTag;
    GLbyte inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLbyte_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[39])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumbv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLbyte *);
    __GLSstring inTag;
    GLuint inCount;
    GLbyte *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLbyte, 1 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLbytev_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[40])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLdouble);
    __GLSstring inTag;
    GLdouble inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLdouble_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[41])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumdv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLdouble *);
    __GLSstring inTag;
    GLuint inCount;
    GLdouble *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLdouble, 8 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLdoublev_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[42])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLfloat);
    __GLSstring inTag;
    GLfloat inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLfloat_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[43])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLfloat *);
    __GLSstring inTag;
    GLuint inCount;
    GLfloat *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLfloat, 4 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[44])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLint);
    __GLSstring inTag;
    GLint inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[45])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLint *);
    __GLSstring inTag;
    GLuint inCount;
    GLint *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLint, 4 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLintv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[46])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNuml(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLlong);
    __GLSstring inTag;
    GLlong inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLlong_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[47])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumlv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLlong *);
    __GLSstring inTag;
    GLuint inCount;
    GLlong *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLlong, 8 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLlongv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[48])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNums(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLshort);
    __GLSstring inTag;
    GLshort inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLshort_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[49])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumsv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLshort *);
    __GLSstring inTag;
    GLuint inCount;
    GLshort *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLshort, 2 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLshortv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[50])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumub(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLubyte);
    __GLSstring inTag;
    GLubyte inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLubyte_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[51])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumubv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLubyte *);
    __GLSstring inTag;
    GLuint inCount;
    GLubyte *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLubyte, 1 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLubytev_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[52])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumui(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint);
    __GLSstring inTag;
    GLuint inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[53])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumuiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLuint *);
    __GLSstring inTag;
    GLuint inCount;
    GLuint *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLuint, 4 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[54])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumul(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLulong);
    __GLSstring inTag;
    GLulong inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLulong_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[55])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumulv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLulong *);
    __GLSstring inTag;
    GLuint inCount;
    GLulong *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLulong, 8 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLulongv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[56])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumus(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLushort);
    __GLSstring inTag;
    GLushort inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLushort_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[57])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumusv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLushort *);
    __GLSstring inTag;
    GLuint inCount;
    GLushort *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLushort, 2 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLushortv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[58])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsPad(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[59])(
    );
end:
    return;
}

void __gls_decode_text_glsSwapBuffers(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint inLayer;
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[60])(
        inLayer
    );
end:
    return;
}

void __gls_decode_text_glNewList(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLenum);
    GLuint list;
    GLenum mode;
    __glsReader_getGLuint_text(inoutReader, &list);
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[64])(
        list,
        mode
    );
end:
    return;
}

void __gls_decode_text_glEndList(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[65])(
    );
end:
    return;
}

void __gls_decode_text_glCallList(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint list;
    __glsReader_getGLuint_text(inoutReader, &list);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[66])(
        list
    );
end:
    return;
}

void __gls_decode_text_glCallLists(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, const GLvoid *);
    GLsizei n;
    GLenum type;
    GLint lists_count;
    GLvoid *lists = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(lists)
    __glsReader_getGLint_text(inoutReader, &n);
    __glsReader_getGLenum_text(inoutReader, &type);
    lists_count = __gls_glCallLists_lists_size(n, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, lists, GLvoid, 1 * lists_count);
    if (!lists) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, lists_count, lists);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[67])(
        n,
        type,
        lists
    );
end:
    __GLS_DEC_FREE(lists);
    return;
}

void __gls_decode_text_glDeleteLists(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLsizei);
    GLuint list;
    GLsizei range;
    __glsReader_getGLuint_text(inoutReader, &list);
    __glsReader_getGLint_text(inoutReader, &range);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[68])(
        list,
        range
    );
end:
    return;
}

void __gls_decode_text_glGenLists(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei);
    GLsizei range;
    __glsReader_getGLint_text(inoutReader, &range);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[69])(
        range
    );
end:
    return;
}

void __gls_decode_text_glListBase(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint base;
    __glsReader_getGLuint_text(inoutReader, &base);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[70])(
        base
    );
end:
    return;
}

void __gls_decode_text_glBegin(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[71])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glBitmap(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *);
    GLsizei width;
    GLsizei height;
    GLfloat xorig;
    GLfloat yorig;
    GLfloat xmove;
    GLfloat ymove;
    GLint bitmap_count;
    GLubyte *bitmap = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(bitmap)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLfloat_text(inoutReader, &xorig);
    __glsReader_getGLfloat_text(inoutReader, &yorig);
    __glsReader_getGLfloat_text(inoutReader, &xmove);
    __glsReader_getGLfloat_text(inoutReader, &ymove);
    bitmap_count = __gls_glBitmap_bitmap_size(width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, bitmap, GLubyte, 1 * bitmap_count);
    if (!bitmap) goto end;
    __glsReader_getGLubytev_text(inoutReader, bitmap_count, bitmap);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[72])(
        width,
        height,
        xorig,
        yorig,
        xmove,
        ymove,
        bitmap
    );
end:
    __GLS_DEC_FREE(bitmap);
    return;
}

void __gls_decode_text_glColor3b(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    GLbyte red;
    GLbyte green;
    GLbyte blue;
    __glsReader_getGLbyte_text(inoutReader, &red);
    __glsReader_getGLbyte_text(inoutReader, &green);
    __glsReader_getGLbyte_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[73])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3bv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    GLbyte v[3];
    __glsReader_getGLbytev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[74])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble red;
    GLdouble green;
    GLdouble blue;
    __glsReader_getGLdouble_text(inoutReader, &red);
    __glsReader_getGLdouble_text(inoutReader, &green);
    __glsReader_getGLdouble_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[75])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[76])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[77])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[78])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint red;
    GLint green;
    GLint blue;
    __glsReader_getGLint_text(inoutReader, &red);
    __glsReader_getGLint_text(inoutReader, &green);
    __glsReader_getGLint_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[79])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[80])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort red;
    GLshort green;
    GLshort blue;
    __glsReader_getGLshort_text(inoutReader, &red);
    __glsReader_getGLshort_text(inoutReader, &green);
    __glsReader_getGLshort_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[81])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[82])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3ub(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte);
    GLubyte red;
    GLubyte green;
    GLubyte blue;
    __glsReader_getGLubyte_text(inoutReader, &red);
    __glsReader_getGLubyte_text(inoutReader, &green);
    __glsReader_getGLubyte_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[83])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3ubv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    GLubyte v[3];
    __glsReader_getGLubytev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[84])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3ui(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    GLuint red;
    GLuint green;
    GLuint blue;
    __glsReader_getGLuint_text(inoutReader, &red);
    __glsReader_getGLuint_text(inoutReader, &green);
    __glsReader_getGLuint_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[85])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3uiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLuint *);
    GLuint v[3];
    __glsReader_getGLuintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[86])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3us(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort);
    GLushort red;
    GLushort green;
    GLushort blue;
    __glsReader_getGLushort_text(inoutReader, &red);
    __glsReader_getGLushort_text(inoutReader, &green);
    __glsReader_getGLushort_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[87])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3usv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLushort *);
    GLushort v[3];
    __glsReader_getGLushortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[88])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4b(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte, GLbyte);
    GLbyte red;
    GLbyte green;
    GLbyte blue;
    GLbyte alpha;
    __glsReader_getGLbyte_text(inoutReader, &red);
    __glsReader_getGLbyte_text(inoutReader, &green);
    __glsReader_getGLbyte_text(inoutReader, &blue);
    __glsReader_getGLbyte_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[89])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4bv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    GLbyte v[4];
    __glsReader_getGLbytev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[90])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble red;
    GLdouble green;
    GLdouble blue;
    GLdouble alpha;
    __glsReader_getGLdouble_text(inoutReader, &red);
    __glsReader_getGLdouble_text(inoutReader, &green);
    __glsReader_getGLdouble_text(inoutReader, &blue);
    __glsReader_getGLdouble_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[91])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[4];
    __glsReader_getGLdoublev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[92])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    __glsReader_getGLfloat_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[93])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[4];
    __glsReader_getGLfloatv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[94])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint red;
    GLint green;
    GLint blue;
    GLint alpha;
    __glsReader_getGLint_text(inoutReader, &red);
    __glsReader_getGLint_text(inoutReader, &green);
    __glsReader_getGLint_text(inoutReader, &blue);
    __glsReader_getGLint_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[95])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[4];
    __glsReader_getGLintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[96])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort red;
    GLshort green;
    GLshort blue;
    GLshort alpha;
    __glsReader_getGLshort_text(inoutReader, &red);
    __glsReader_getGLshort_text(inoutReader, &green);
    __glsReader_getGLshort_text(inoutReader, &blue);
    __glsReader_getGLshort_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[97])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[4];
    __glsReader_getGLshortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[98])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4ub(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte, GLubyte);
    GLubyte red;
    GLubyte green;
    GLubyte blue;
    GLubyte alpha;
    __glsReader_getGLubyte_text(inoutReader, &red);
    __glsReader_getGLubyte_text(inoutReader, &green);
    __glsReader_getGLubyte_text(inoutReader, &blue);
    __glsReader_getGLubyte_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[99])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4ubv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    GLubyte v[4];
    __glsReader_getGLubytev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[100])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4ui(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint, GLuint);
    GLuint red;
    GLuint green;
    GLuint blue;
    GLuint alpha;
    __glsReader_getGLuint_text(inoutReader, &red);
    __glsReader_getGLuint_text(inoutReader, &green);
    __glsReader_getGLuint_text(inoutReader, &blue);
    __glsReader_getGLuint_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[101])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4uiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLuint *);
    GLuint v[4];
    __glsReader_getGLuintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[102])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4us(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort, GLushort);
    GLushort red;
    GLushort green;
    GLushort blue;
    GLushort alpha;
    __glsReader_getGLushort_text(inoutReader, &red);
    __glsReader_getGLushort_text(inoutReader, &green);
    __glsReader_getGLushort_text(inoutReader, &blue);
    __glsReader_getGLushort_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[103])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4usv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLushort *);
    GLushort v[4];
    __glsReader_getGLushortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[104])(
        v
    );
end:
    return;
}

void __gls_decode_text_glEdgeFlag(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLboolean);
    GLboolean flag;
    __glsReader_getGLboolean_text(inoutReader, &flag);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[105])(
        flag
    );
end:
    return;
}

void __gls_decode_text_glEdgeFlagv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLboolean *);
    GLboolean flag[1];
    __glsReader_getGLbooleanv_text(inoutReader, 1, flag);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[106])(
        flag
    );
end:
    return;
}

void __gls_decode_text_glEnd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[107])(
    );
end:
    return;
}

void __gls_decode_text_glIndexd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble);
    GLdouble c;
    __glsReader_getGLdouble_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[108])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexdv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble c[1];
    __glsReader_getGLdoublev_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[109])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat c;
    __glsReader_getGLfloat_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[110])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat c[1];
    __glsReader_getGLfloatv_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[111])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint c;
    __glsReader_getGLint_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[112])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint c[1];
    __glsReader_getGLintv_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[113])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexs(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort);
    GLshort c;
    __glsReader_getGLshort_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[114])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexsv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort c[1];
    __glsReader_getGLshortv_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[115])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexub(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLubyte);
    GLubyte c;
    __glsReader_getGLubyte_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[379])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexubv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    GLubyte c[1];
    __glsReader_getGLubytev_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[380])(
        c
    );
end:
    return;
}

void __gls_decode_text_glNormal3b(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    GLbyte nx;
    GLbyte ny;
    GLbyte nz;
    __glsReader_getGLbyte_text(inoutReader, &nx);
    __glsReader_getGLbyte_text(inoutReader, &ny);
    __glsReader_getGLbyte_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[116])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3bv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    GLbyte v[3];
    __glsReader_getGLbytev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[117])(
        v
    );
end:
    return;
}

void __gls_decode_text_glNormal3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble nx;
    GLdouble ny;
    GLdouble nz;
    __glsReader_getGLdouble_text(inoutReader, &nx);
    __glsReader_getGLdouble_text(inoutReader, &ny);
    __glsReader_getGLdouble_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[118])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[119])(
        v
    );
end:
    return;
}

void __gls_decode_text_glNormal3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    __glsReader_getGLfloat_text(inoutReader, &nx);
    __glsReader_getGLfloat_text(inoutReader, &ny);
    __glsReader_getGLfloat_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[120])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[121])(
        v
    );
end:
    return;
}

void __gls_decode_text_glNormal3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint nx;
    GLint ny;
    GLint nz;
    __glsReader_getGLint_text(inoutReader, &nx);
    __glsReader_getGLint_text(inoutReader, &ny);
    __glsReader_getGLint_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[122])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[123])(
        v
    );
end:
    return;
}

void __gls_decode_text_glNormal3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort nx;
    GLshort ny;
    GLshort nz;
    __glsReader_getGLshort_text(inoutReader, &nx);
    __glsReader_getGLshort_text(inoutReader, &ny);
    __glsReader_getGLshort_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[124])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[125])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[126])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[127])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[128])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[129])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint x;
    GLint y;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[130])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[2];
    __glsReader_getGLintv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[131])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    GLshort x;
    GLshort y;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[132])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[2];
    __glsReader_getGLshortv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[133])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[134])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[135])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[136])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[137])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint x;
    GLint y;
    GLint z;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[138])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[139])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort x;
    GLshort y;
    GLshort z;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    __glsReader_getGLshort_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[140])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[141])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    GLdouble w;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    __glsReader_getGLdouble_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[142])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[4];
    __glsReader_getGLdoublev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[143])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    __glsReader_getGLfloat_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[144])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[4];
    __glsReader_getGLfloatv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[145])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint x;
    GLint y;
    GLint z;
    GLint w;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &z);
    __glsReader_getGLint_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[146])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[4];
    __glsReader_getGLintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[147])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    __glsReader_getGLshort_text(inoutReader, &z);
    __glsReader_getGLshort_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[148])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[4];
    __glsReader_getGLshortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[149])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRectd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble x1;
    GLdouble y1;
    GLdouble x2;
    GLdouble y2;
    __glsReader_getGLdouble_text(inoutReader, &x1);
    __glsReader_getGLdouble_text(inoutReader, &y1);
    __glsReader_getGLdouble_text(inoutReader, &x2);
    __glsReader_getGLdouble_text(inoutReader, &y2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[150])(
        x1,
        y1,
        x2,
        y2
    );
end:
    return;
}

void __gls_decode_text_glRectdv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *, const GLdouble *);
    GLdouble v1[2];
    GLdouble v2[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, v1);
    __glsReader_getGLdoublev_text(inoutReader, 2, v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[151])(
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glRectf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat x1;
    GLfloat y1;
    GLfloat x2;
    GLfloat y2;
    __glsReader_getGLfloat_text(inoutReader, &x1);
    __glsReader_getGLfloat_text(inoutReader, &y1);
    __glsReader_getGLfloat_text(inoutReader, &x2);
    __glsReader_getGLfloat_text(inoutReader, &y2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[152])(
        x1,
        y1,
        x2,
        y2
    );
end:
    return;
}

void __gls_decode_text_glRectfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *, const GLfloat *);
    GLfloat v1[2];
    GLfloat v2[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, v1);
    __glsReader_getGLfloatv_text(inoutReader, 2, v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[153])(
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glRecti(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint x1;
    GLint y1;
    GLint x2;
    GLint y2;
    __glsReader_getGLint_text(inoutReader, &x1);
    __glsReader_getGLint_text(inoutReader, &y1);
    __glsReader_getGLint_text(inoutReader, &x2);
    __glsReader_getGLint_text(inoutReader, &y2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[154])(
        x1,
        y1,
        x2,
        y2
    );
end:
    return;
}

void __gls_decode_text_glRectiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *, const GLint *);
    GLint v1[2];
    GLint v2[2];
    __glsReader_getGLintv_text(inoutReader, 2, v1);
    __glsReader_getGLintv_text(inoutReader, 2, v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[155])(
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glRects(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort x1;
    GLshort y1;
    GLshort x2;
    GLshort y2;
    __glsReader_getGLshort_text(inoutReader, &x1);
    __glsReader_getGLshort_text(inoutReader, &y1);
    __glsReader_getGLshort_text(inoutReader, &x2);
    __glsReader_getGLshort_text(inoutReader, &y2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[156])(
        x1,
        y1,
        x2,
        y2
    );
end:
    return;
}

void __gls_decode_text_glRectsv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *, const GLshort *);
    GLshort v1[2];
    GLshort v2[2];
    __glsReader_getGLshortv_text(inoutReader, 2, v1);
    __glsReader_getGLshortv_text(inoutReader, 2, v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[157])(
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble);
    GLdouble s;
    __glsReader_getGLdouble_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[158])(
        s
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[1];
    __glsReader_getGLdoublev_text(inoutReader, 1, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[159])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat s;
    __glsReader_getGLfloat_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[160])(
        s
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[1];
    __glsReader_getGLfloatv_text(inoutReader, 1, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[161])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint s;
    __glsReader_getGLint_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[162])(
        s
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[1];
    __glsReader_getGLintv_text(inoutReader, 1, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[163])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort);
    GLshort s;
    __glsReader_getGLshort_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[164])(
        s
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[1];
    __glsReader_getGLshortv_text(inoutReader, 1, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[165])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    GLdouble s;
    GLdouble t;
    __glsReader_getGLdouble_text(inoutReader, &s);
    __glsReader_getGLdouble_text(inoutReader, &t);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[166])(
        s,
        t
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[167])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat s;
    GLfloat t;
    __glsReader_getGLfloat_text(inoutReader, &s);
    __glsReader_getGLfloat_text(inoutReader, &t);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[168])(
        s,
        t
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[169])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint s;
    GLint t;
    __glsReader_getGLint_text(inoutReader, &s);
    __glsReader_getGLint_text(inoutReader, &t);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[170])(
        s,
        t
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[2];
    __glsReader_getGLintv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[171])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    GLshort s;
    GLshort t;
    __glsReader_getGLshort_text(inoutReader, &s);
    __glsReader_getGLshort_text(inoutReader, &t);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[172])(
        s,
        t
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[2];
    __glsReader_getGLshortv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[173])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble s;
    GLdouble t;
    GLdouble r;
    __glsReader_getGLdouble_text(inoutReader, &s);
    __glsReader_getGLdouble_text(inoutReader, &t);
    __glsReader_getGLdouble_text(inoutReader, &r);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[174])(
        s,
        t,
        r
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[175])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat s;
    GLfloat t;
    GLfloat r;
    __glsReader_getGLfloat_text(inoutReader, &s);
    __glsReader_getGLfloat_text(inoutReader, &t);
    __glsReader_getGLfloat_text(inoutReader, &r);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[176])(
        s,
        t,
        r
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[177])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint s;
    GLint t;
    GLint r;
    __glsReader_getGLint_text(inoutReader, &s);
    __glsReader_getGLint_text(inoutReader, &t);
    __glsReader_getGLint_text(inoutReader, &r);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[178])(
        s,
        t,
        r
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[179])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort s;
    GLshort t;
    GLshort r;
    __glsReader_getGLshort_text(inoutReader, &s);
    __glsReader_getGLshort_text(inoutReader, &t);
    __glsReader_getGLshort_text(inoutReader, &r);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[180])(
        s,
        t,
        r
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[181])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble s;
    GLdouble t;
    GLdouble r;
    GLdouble q;
    __glsReader_getGLdouble_text(inoutReader, &s);
    __glsReader_getGLdouble_text(inoutReader, &t);
    __glsReader_getGLdouble_text(inoutReader, &r);
    __glsReader_getGLdouble_text(inoutReader, &q);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[182])(
        s,
        t,
        r,
        q
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[4];
    __glsReader_getGLdoublev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[183])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;
    __glsReader_getGLfloat_text(inoutReader, &s);
    __glsReader_getGLfloat_text(inoutReader, &t);
    __glsReader_getGLfloat_text(inoutReader, &r);
    __glsReader_getGLfloat_text(inoutReader, &q);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[184])(
        s,
        t,
        r,
        q
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[4];
    __glsReader_getGLfloatv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[185])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint s;
    GLint t;
    GLint r;
    GLint q;
    __glsReader_getGLint_text(inoutReader, &s);
    __glsReader_getGLint_text(inoutReader, &t);
    __glsReader_getGLint_text(inoutReader, &r);
    __glsReader_getGLint_text(inoutReader, &q);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[186])(
        s,
        t,
        r,
        q
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[4];
    __glsReader_getGLintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[187])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;
    __glsReader_getGLshort_text(inoutReader, &s);
    __glsReader_getGLshort_text(inoutReader, &t);
    __glsReader_getGLshort_text(inoutReader, &r);
    __glsReader_getGLshort_text(inoutReader, &q);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[188])(
        s,
        t,
        r,
        q
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[4];
    __glsReader_getGLshortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[189])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[190])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glVertex2dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[191])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[192])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glVertex2fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[193])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex2i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint x;
    GLint y;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[194])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glVertex2iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[2];
    __glsReader_getGLintv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[195])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex2s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    GLshort x;
    GLshort y;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[196])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glVertex2sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[2];
    __glsReader_getGLshortv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[197])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[198])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glVertex3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[199])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[200])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glVertex3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[201])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint x;
    GLint y;
    GLint z;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[202])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glVertex3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[203])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort x;
    GLshort y;
    GLshort z;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    __glsReader_getGLshort_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[204])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glVertex3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[205])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex4d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    GLdouble w;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    __glsReader_getGLdouble_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[206])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glVertex4dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[4];
    __glsReader_getGLdoublev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[207])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex4f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    __glsReader_getGLfloat_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[208])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glVertex4fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[4];
    __glsReader_getGLfloatv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[209])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex4i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint x;
    GLint y;
    GLint z;
    GLint w;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &z);
    __glsReader_getGLint_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[210])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glVertex4iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[4];
    __glsReader_getGLintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[211])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex4s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    __glsReader_getGLshort_text(inoutReader, &z);
    __glsReader_getGLshort_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[212])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glVertex4sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[4];
    __glsReader_getGLshortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[213])(
        v
    );
end:
    return;
}

void __gls_decode_text_glClipPlane(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLdouble *);
    GLenum plane;
    GLdouble equation[4];
    __glsReader_getGLenum_text(inoutReader, &plane);
    __glsReader_getGLdoublev_text(inoutReader, 4, equation);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[214])(
        plane,
        equation
    );
end:
    return;
}

void __gls_decode_text_glColorMaterial(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    GLenum face;
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[215])(
        face,
        mode
    );
end:
    return;
}

void __gls_decode_text_glCullFace(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[216])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glFogf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[217])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glFogfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glFogfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[218])(
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glFogi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[219])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glFogiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glFogiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[220])(
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glFrontFace(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[221])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glHint(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    GLenum target;
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[222])(
        target,
        mode
    );
end:
    return;
}

void __gls_decode_text_glLightf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum light;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[223])(
        light,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glLightfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum light;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glLightfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[224])(
        light,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glLighti(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum light;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[225])(
        light,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glLightiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum light;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glLightiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[226])(
        light,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glLightModelf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[227])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glLightModelfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glLightModelfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[228])(
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glLightModeli(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[229])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glLightModeliv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glLightModeliv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[230])(
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glLineStipple(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLushort);
    GLint factor;
    GLushort pattern;
    __glsReader_getGLint_text(inoutReader, &factor);
    __glsReader_getGLushort_text(inoutReader, &pattern);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[231])(
        factor,
        pattern
    );
end:
    return;
}

void __gls_decode_text_glLineWidth(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat width;
    __glsReader_getGLfloat_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[232])(
        width
    );
end:
    return;
}

void __gls_decode_text_glMaterialf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum face;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[233])(
        face,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glMaterialfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum face;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glMaterialfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[234])(
        face,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glMateriali(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum face;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[235])(
        face,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glMaterialiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum face;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glMaterialiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[236])(
        face,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glPointSize(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat size;
    __glsReader_getGLfloat_text(inoutReader, &size);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[237])(
        size
    );
end:
    return;
}

void __gls_decode_text_glPolygonMode(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    GLenum face;
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[238])(
        face,
        mode
    );
end:
    return;
}

void __gls_decode_text_glPolygonStipple(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    GLint mask_count;
    GLubyte *mask = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(mask)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    mask_count = __gls_glPolygonStipple_mask_size();
    __GLS_DEC_ALLOC_TEXT(inoutReader, mask, GLubyte, 1 * mask_count);
    if (!mask) goto end;
    __glsReader_getGLubytev_text(inoutReader, mask_count, mask);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[239])(
        mask
    );
end:
    __GLS_DEC_FREE(mask);
    return;
}

void __gls_decode_text_glScissor(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[240])(
        x,
        y,
        width,
        height
    );
end:
    return;
}

void __gls_decode_text_glShadeModel(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[241])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glTexParameterf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum target;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[242])(
        target,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexParameterfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[243])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexParameteri(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum target;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[244])(
        target,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexParameteriv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[245])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexImage1D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint components;
    GLsizei width;
    GLint border;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLtextureComponentCount_text(inoutReader, &components);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &border);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage1D_pixels_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[246])(
        target,
        level,
        components,
        width,
        border,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glTexImage2D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint components;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLtextureComponentCount_text(inoutReader, &components);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &border);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage2D_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[247])(
        target,
        level,
        components,
        width,
        height,
        border,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glTexEnvf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum target;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[248])(
        target,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexEnvfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexEnvfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[249])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexEnvi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum target;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[250])(
        target,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexEnviv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexEnviv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[251])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexGend(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble);
    GLenum coord;
    GLenum pname;
    GLdouble param;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLdouble_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[252])(
        coord,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexGendv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLdouble *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexGendv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLdouble, 8 * params_count);
    if (!params) goto end;
    __glsReader_getGLdoublev_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[253])(
        coord,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexGenf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum coord;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[254])(
        coord,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexGenfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexGenfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[255])(
        coord,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexGeni(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum coord;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[256])(
        coord,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexGeniv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexGeniv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[257])(
        coord,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glFeedbackBuffer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, GLfloat *);
    GLsizei size;
    GLenum type;
    GLfloat *buffer = GLS_NONE;
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &size);
    __glsReader_getGLenum_text(inoutReader, &type);
    buffer = (GLfloat *)__glsReader_allocFeedbackBuf(inoutReader, 4 * __GLS_MAX(size, 0));
    if (!buffer) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[258])(
        size,
        type,
        buffer
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}

void __gls_decode_text_glSelectBuffer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    GLsizei size;
    GLuint *buffer = GLS_NONE;
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &size);
    buffer = (GLuint *)__glsReader_allocSelectBuf(inoutReader, 4 * __GLS_MAX(size, 0));
    if (!buffer) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[259])(
        size,
        buffer
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}

void __gls_decode_text_glRenderMode(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[260])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glInitNames(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[261])(
    );
end:
    return;
}

void __gls_decode_text_glLoadName(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint name;
    __glsReader_getGLuint_text(inoutReader, &name);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[262])(
        name
    );
end:
    return;
}

void __gls_decode_text_glPassThrough(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat token;
    __glsReader_getGLfloat_text(inoutReader, &token);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[263])(
        token
    );
end:
    return;
}

void __gls_decode_text_glPopName(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[264])(
    );
end:
    return;
}

void __gls_decode_text_glPushName(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint name;
    __glsReader_getGLuint_text(inoutReader, &name);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[265])(
        name
    );
end:
    return;
}

void __gls_decode_text_glDrawBuffer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLdrawBufferMode_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[266])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glClear(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbitfield);
    GLbitfield mask;
    __glsReader_getGLclearBufferMask_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[267])(
        mask
    );
end:
    return;
}

void __gls_decode_text_glClearAccum(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    __glsReader_getGLfloat_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[268])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glClearIndex(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat c;
    __glsReader_getGLfloat_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[269])(
        c
    );
end:
    return;
}

void __gls_decode_text_glClearColor(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    __glsReader_getGLfloat_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[270])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glClearStencil(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint s;
    __glsReader_getGLint_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[271])(
        s
    );
end:
    return;
}

void __gls_decode_text_glClearDepth(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampd);
    GLclampd depth;
    __glsReader_getGLdouble_text(inoutReader, &depth);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[272])(
        depth
    );
end:
    return;
}

void __gls_decode_text_glStencilMask(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint mask;
    __glsReader_getGLuint_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[273])(
        mask
    );
end:
    return;
}

void __gls_decode_text_glColorMask(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLboolean, GLboolean, GLboolean, GLboolean);
    GLboolean red;
    GLboolean green;
    GLboolean blue;
    GLboolean alpha;
    __glsReader_getGLboolean_text(inoutReader, &red);
    __glsReader_getGLboolean_text(inoutReader, &green);
    __glsReader_getGLboolean_text(inoutReader, &blue);
    __glsReader_getGLboolean_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[274])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glDepthMask(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLboolean);
    GLboolean flag;
    __glsReader_getGLboolean_text(inoutReader, &flag);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[275])(
        flag
    );
end:
    return;
}

void __gls_decode_text_glIndexMask(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint mask;
    __glsReader_getGLuint_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[276])(
        mask
    );
end:
    return;
}

void __gls_decode_text_glAccum(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum op;
    GLfloat value;
    __glsReader_getGLenum_text(inoutReader, &op);
    __glsReader_getGLfloat_text(inoutReader, &value);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[277])(
        op,
        value
    );
end:
    return;
}

void __gls_decode_text_glDisable(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[278])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glEnable(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[279])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glFinish(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[280])(
    );
end:
    return;
}

void __gls_decode_text_glFlush(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[281])(
    );
end:
    return;
}

void __gls_decode_text_glPopAttrib(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[282])(
    );
end:
    return;
}

void __gls_decode_text_glPushAttrib(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbitfield);
    GLbitfield mask;
    __glsReader_getGLattribMask_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[283])(
        mask
    );
end:
    return;
}

void __gls_decode_text_glMap1d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    GLenum target;
    GLdouble u1;
    GLdouble u2;
    GLint stride;
    GLint order;
    GLint points_count;
    GLdouble *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLdouble_text(inoutReader, &u1);
    __glsReader_getGLdouble_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &order);
    points_count = __gls_glMap1d_points_size(target, stride, order);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLdouble, 8 * points_count);
    if (!points) goto end;
    __glsReader_getGLdoublev_text(inoutReader, points_count, points);
    if (stride > __glsEvalComputeK(target)) {
        __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    }
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[284])(
        target,
        u1,
        u2,
        stride,
        order,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}

void __gls_decode_text_glMap1f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint stride;
    GLint order;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLfloat_text(inoutReader, &u1);
    __glsReader_getGLfloat_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &order);
    points_count = __gls_glMap1f_points_size(target, stride, order);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * points_count);
    if (!points) goto end;
    __glsReader_getGLfloatv_text(inoutReader, points_count, points);
    if (stride > __glsEvalComputeK(target)) {
        __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    }
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[285])(
        target,
        u1,
        u2,
        stride,
        order,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}

void __gls_decode_text_glMap2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    GLenum target;
    GLdouble u1;
    GLdouble u2;
    GLint ustride;
    GLint uorder;
    GLdouble v1;
    GLdouble v2;
    GLint vstride;
    GLint vorder;
    GLint points_count;
    GLdouble *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLdouble_text(inoutReader, &u1);
    __glsReader_getGLdouble_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &ustride);
    __glsReader_getGLint_text(inoutReader, &uorder);
    __glsReader_getGLdouble_text(inoutReader, &v1);
    __glsReader_getGLdouble_text(inoutReader, &v2);
    __glsReader_getGLint_text(inoutReader, &vstride);
    __glsReader_getGLint_text(inoutReader, &vorder);
    points_count = __gls_glMap2d_points_size(target, ustride, uorder, vstride, vorder);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLdouble, 8 * points_count);
    if (!points) goto end;
    __glsReader_getGLdoublev_text(inoutReader, points_count, points);
    if (!(
        vstride <= __glsEvalComputeK(target) && ustride <= vstride * vorder ||
        ustride <= __glsEvalComputeK(target) && vstride <= ustride * uorder
    )) {
        __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    }
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[286])(
        target,
        u1,
        u2,
        ustride,
        uorder,
        v1,
        v2,
        vstride,
        vorder,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}

void __gls_decode_text_glMap2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLfloat_text(inoutReader, &u1);
    __glsReader_getGLfloat_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &ustride);
    __glsReader_getGLint_text(inoutReader, &uorder);
    __glsReader_getGLfloat_text(inoutReader, &v1);
    __glsReader_getGLfloat_text(inoutReader, &v2);
    __glsReader_getGLint_text(inoutReader, &vstride);
    __glsReader_getGLint_text(inoutReader, &vorder);
    points_count = __gls_glMap2f_points_size(target, ustride, uorder, vstride, vorder);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * points_count);
    if (!points) goto end;
    __glsReader_getGLfloatv_text(inoutReader, points_count, points);
    if (!(
        vstride <= __glsEvalComputeK(target) && ustride <= vstride * vorder ||
        ustride <= __glsEvalComputeK(target) && vstride <= ustride * uorder
    )) {
        __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    }
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[287])(
        target,
        u1,
        u2,
        ustride,
        uorder,
        v1,
        v2,
        vstride,
        vorder,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}

void __gls_decode_text_glMapGrid1d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble);
    GLint un;
    GLdouble u1;
    GLdouble u2;
    __glsReader_getGLint_text(inoutReader, &un);
    __glsReader_getGLdouble_text(inoutReader, &u1);
    __glsReader_getGLdouble_text(inoutReader, &u2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[288])(
        un,
        u1,
        u2
    );
end:
    return;
}

void __gls_decode_text_glMapGrid1f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat);
    GLint un;
    GLfloat u1;
    GLfloat u2;
    __glsReader_getGLint_text(inoutReader, &un);
    __glsReader_getGLfloat_text(inoutReader, &u1);
    __glsReader_getGLfloat_text(inoutReader, &u2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[289])(
        un,
        u1,
        u2
    );
end:
    return;
}

void __gls_decode_text_glMapGrid2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble);
    GLint un;
    GLdouble u1;
    GLdouble u2;
    GLint vn;
    GLdouble v1;
    GLdouble v2;
    __glsReader_getGLint_text(inoutReader, &un);
    __glsReader_getGLdouble_text(inoutReader, &u1);
    __glsReader_getGLdouble_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &vn);
    __glsReader_getGLdouble_text(inoutReader, &v1);
    __glsReader_getGLdouble_text(inoutReader, &v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[290])(
        un,
        u1,
        u2,
        vn,
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glMapGrid2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat);
    GLint un;
    GLfloat u1;
    GLfloat u2;
    GLint vn;
    GLfloat v1;
    GLfloat v2;
    __glsReader_getGLint_text(inoutReader, &un);
    __glsReader_getGLfloat_text(inoutReader, &u1);
    __glsReader_getGLfloat_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &vn);
    __glsReader_getGLfloat_text(inoutReader, &v1);
    __glsReader_getGLfloat_text(inoutReader, &v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[291])(
        un,
        u1,
        u2,
        vn,
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord1d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble);
    GLdouble u;
    __glsReader_getGLdouble_text(inoutReader, &u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[292])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord1dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble u[1];
    __glsReader_getGLdoublev_text(inoutReader, 1, u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[293])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord1f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat u;
    __glsReader_getGLfloat_text(inoutReader, &u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[294])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord1fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat u[1];
    __glsReader_getGLfloatv_text(inoutReader, 1, u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[295])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    GLdouble u;
    GLdouble v;
    __glsReader_getGLdouble_text(inoutReader, &u);
    __glsReader_getGLdouble_text(inoutReader, &v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[296])(
        u,
        v
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord2dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble u[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[297])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat u;
    GLfloat v;
    __glsReader_getGLfloat_text(inoutReader, &u);
    __glsReader_getGLfloat_text(inoutReader, &v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[298])(
        u,
        v
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord2fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat u[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[299])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalMesh1(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint);
    GLenum mode;
    GLint i1;
    GLint i2;
    __glsReader_getGLenum_text(inoutReader, &mode);
    __glsReader_getGLint_text(inoutReader, &i1);
    __glsReader_getGLint_text(inoutReader, &i2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[300])(
        mode,
        i1,
        i2
    );
end:
    return;
}

void __gls_decode_text_glEvalPoint1(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint i;
    __glsReader_getGLint_text(inoutReader, &i);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[301])(
        i
    );
end:
    return;
}

void __gls_decode_text_glEvalMesh2(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint);
    GLenum mode;
    GLint i1;
    GLint i2;
    GLint j1;
    GLint j2;
    __glsReader_getGLenum_text(inoutReader, &mode);
    __glsReader_getGLint_text(inoutReader, &i1);
    __glsReader_getGLint_text(inoutReader, &i2);
    __glsReader_getGLint_text(inoutReader, &j1);
    __glsReader_getGLint_text(inoutReader, &j2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[302])(
        mode,
        i1,
        i2,
        j1,
        j2
    );
end:
    return;
}

void __gls_decode_text_glEvalPoint2(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint i;
    GLint j;
    __glsReader_getGLint_text(inoutReader, &i);
    __glsReader_getGLint_text(inoutReader, &j);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[303])(
        i,
        j
    );
end:
    return;
}

void __gls_decode_text_glAlphaFunc(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLclampf);
    GLenum func;
    GLclampf ref;
    __glsReader_getGLenum_text(inoutReader, &func);
    __glsReader_getGLfloat_text(inoutReader, &ref);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[304])(
        func,
        ref
    );
end:
    return;
}

void __gls_decode_text_glBlendFunc(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    GLenum sfactor;
    GLenum dfactor;
    __glsReader_getGLblendingFactor_text(inoutReader, &sfactor);
    __glsReader_getGLblendingFactor_text(inoutReader, &dfactor);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[305])(
        sfactor,
        dfactor
    );
end:
    return;
}

void __gls_decode_text_glLogicOp(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum opcode;
    __glsReader_getGLenum_text(inoutReader, &opcode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[306])(
        opcode
    );
end:
    return;
}

void __gls_decode_text_glStencilFunc(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLuint);
    GLenum func;
    GLint ref;
    GLuint mask;
    __glsReader_getGLenum_text(inoutReader, &func);
    __glsReader_getGLint_text(inoutReader, &ref);
    __glsReader_getGLuint_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[307])(
        func,
        ref,
        mask
    );
end:
    return;
}

void __gls_decode_text_glStencilOp(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum);
    GLenum fail;
    GLenum zfail;
    GLenum zpass;
    __glsReader_getGLstencilOp_text(inoutReader, &fail);
    __glsReader_getGLstencilOp_text(inoutReader, &zfail);
    __glsReader_getGLstencilOp_text(inoutReader, &zpass);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[308])(
        fail,
        zfail,
        zpass
    );
end:
    return;
}

void __gls_decode_text_glDepthFunc(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum func;
    __glsReader_getGLenum_text(inoutReader, &func);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[309])(
        func
    );
end:
    return;
}

void __gls_decode_text_glPixelZoom(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat xfactor;
    GLfloat yfactor;
    __glsReader_getGLfloat_text(inoutReader, &xfactor);
    __glsReader_getGLfloat_text(inoutReader, &yfactor);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[310])(
        xfactor,
        yfactor
    );
end:
    return;
}

void __gls_decode_text_glPixelTransferf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[311])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glPixelTransferi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[312])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glPixelStoref(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[313])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glPixelStorei(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[314])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glPixelMapfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLfloat *);
    GLenum map;
    GLint mapsize;
    GLfloat *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    __glsReader_getGLenum_text(inoutReader, &map);
    __glsReader_getGLint_text(inoutReader, &mapsize);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLfloat, 4 * __GLS_MAX(mapsize, 0));
    if (!values) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(mapsize, 0), values);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[315])(
        map,
        mapsize,
        values
    );
end:
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glPixelMapuiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLuint *);
    GLenum map;
    GLint mapsize;
    GLuint *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    __glsReader_getGLenum_text(inoutReader, &map);
    __glsReader_getGLint_text(inoutReader, &mapsize);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLuint, 4 * __GLS_MAX(mapsize, 0));
    if (!values) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(mapsize, 0), values);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[316])(
        map,
        mapsize,
        values
    );
end:
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glPixelMapusv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLushort *);
    GLenum map;
    GLint mapsize;
    GLushort *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    __glsReader_getGLenum_text(inoutReader, &map);
    __glsReader_getGLint_text(inoutReader, &mapsize);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLushort, 2 * __GLS_MAX(mapsize, 0));
    if (!values) goto end;
    __glsReader_getGLushortv_text(inoutReader, __GLS_MAX(mapsize, 0), values);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[317])(
        map,
        mapsize,
        values
    );
end:
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glReadBuffer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[318])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glCopyPixels(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum);
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum type;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &type);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[319])(
        x,
        y,
        width,
        height,
        type
    );
end:
    return;
}

void __gls_decode_text_glReadPixels(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glReadPixels_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[320])(
        x,
        y,
        width,
        height,
        format,
        type,
        pixels
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glDrawPixels(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glDrawPixels_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[321])(
        width,
        height,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glGetBooleanv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean *);
    GLenum pname;
    GLint params_count;
    GLboolean *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetBooleanv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLboolean, 1 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[322])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetClipPlane(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    GLenum plane;
    GLdouble equation[4];
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &plane);
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[323])(
        plane,
        equation
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}

void __gls_decode_text_glGetDoublev(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetDoublev_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLdouble, 8 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[324])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetError(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[325])(
    );
end:
    return;
}

void __gls_decode_text_glGetFloatv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetFloatv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[326])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetIntegerv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint *);
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetIntegerv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[327])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetLightfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum light;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetLightfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[328])(
        light,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetLightiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum light;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetLightiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[329])(
        light,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetMapdv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    GLenum target;
    GLenum query;
    GLint v_count;
    GLdouble *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &query);
    v_count = __gls_glGetMapdv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_TEXT(inoutReader, v, GLdouble, 8 * v_count);
    if (!v) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[330])(
        target,
        query,
        v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
    return;
}

void __gls_decode_text_glGetMapfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum query;
    GLint v_count;
    GLfloat *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &query);
    v_count = __gls_glGetMapfv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_TEXT(inoutReader, v, GLfloat, 4 * v_count);
    if (!v) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[331])(
        target,
        query,
        v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
    return;
}

void __gls_decode_text_glGetMapiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum query;
    GLint v_count;
    GLint *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &query);
    v_count = __gls_glGetMapiv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_TEXT(inoutReader, v, GLint, 4 * v_count);
    if (!v) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[332])(
        target,
        query,
        v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
    return;
}

void __gls_decode_text_glGetMaterialfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum face;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetMaterialfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[333])(
        face,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetMaterialiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum face;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetMaterialiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[334])(
        face,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetPixelMapfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    GLenum map;
    GLint values_count;
    GLfloat *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &map);
    values_count = __gls_glGetPixelMapfv_values_size(ctx, map);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLfloat, 4 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[335])(
        map,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glGetPixelMapuiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLuint *);
    GLenum map;
    GLint values_count;
    GLuint *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &map);
    values_count = __gls_glGetPixelMapuiv_values_size(ctx, map);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLuint, 4 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[336])(
        map,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glGetPixelMapusv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLushort *);
    GLenum map;
    GLint values_count;
    GLushort *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &map);
    values_count = __gls_glGetPixelMapusv_values_size(ctx, map);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLushort, 2 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[337])(
        map,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glGetPolygonStipple(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLubyte *);
    GLint mask_count;
    GLubyte *mask = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(mask)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    mask_count = __gls_glGetPolygonStipple_mask_size();
    __GLS_DEC_ALLOC_TEXT(inoutReader, mask, GLubyte, 1 * mask_count);
    if (!mask) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[338])(
        mask
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(mask);
    return;
}

void __gls_decode_text_glGetString(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum name;
    __glsReader_getGLenum_text(inoutReader, &name);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[339])(
        name
    );
end:
    return;
}

void __gls_decode_text_glGetTexEnvfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexEnvfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[340])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexEnviv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexEnviv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[341])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexGendv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexGendv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLdouble, 8 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[342])(
        coord,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexGenfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexGenfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[343])(
        coord,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexGeniv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexGeniv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[344])(
        coord,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexImage(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glGetTexImage_pixels_size(ctx, target, level, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[345])(
        target,
        level,
        format,
        type,
        pixels
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glGetTexParameterfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[346])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexParameteriv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[347])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexLevelParameterfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLfloat *);
    GLenum target;
    GLint level;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexLevelParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[348])(
        target,
        level,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexLevelParameteriv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint *);
    GLenum target;
    GLint level;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexLevelParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[349])(
        target,
        level,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glIsEnabled(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[350])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glIsList(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint list;
    __glsReader_getGLuint_text(inoutReader, &list);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[351])(
        list
    );
end:
    return;
}

void __gls_decode_text_glDepthRange(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampd, GLclampd);
    GLclampd zNear;
    GLclampd zFar;
    __glsReader_getGLdouble_text(inoutReader, &zNear);
    __glsReader_getGLdouble_text(inoutReader, &zFar);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[352])(
        zNear,
        zFar
    );
end:
    return;
}

void __gls_decode_text_glFrustum(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble left;
    GLdouble right;
    GLdouble bottom;
    GLdouble top;
    GLdouble zNear;
    GLdouble zFar;
    __glsReader_getGLdouble_text(inoutReader, &left);
    __glsReader_getGLdouble_text(inoutReader, &right);
    __glsReader_getGLdouble_text(inoutReader, &bottom);
    __glsReader_getGLdouble_text(inoutReader, &top);
    __glsReader_getGLdouble_text(inoutReader, &zNear);
    __glsReader_getGLdouble_text(inoutReader, &zFar);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[353])(
        left,
        right,
        bottom,
        top,
        zNear,
        zFar
    );
end:
    return;
}

void __gls_decode_text_glLoadIdentity(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[354])(
    );
end:
    return;
}

void __gls_decode_text_glLoadMatrixf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat m[16];
    __glsReader_getGLfloatv_text(inoutReader, 16, m);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[355])(
        m
    );
end:
    return;
}

void __gls_decode_text_glLoadMatrixd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble m[16];
    __glsReader_getGLdoublev_text(inoutReader, 16, m);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[356])(
        m
    );
end:
    return;
}

void __gls_decode_text_glMatrixMode(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[357])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glMultMatrixf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat m[16];
    __glsReader_getGLfloatv_text(inoutReader, 16, m);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[358])(
        m
    );
end:
    return;
}

void __gls_decode_text_glMultMatrixd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble m[16];
    __glsReader_getGLdoublev_text(inoutReader, 16, m);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[359])(
        m
    );
end:
    return;
}

void __gls_decode_text_glOrtho(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble left;
    GLdouble right;
    GLdouble bottom;
    GLdouble top;
    GLdouble zNear;
    GLdouble zFar;
    __glsReader_getGLdouble_text(inoutReader, &left);
    __glsReader_getGLdouble_text(inoutReader, &right);
    __glsReader_getGLdouble_text(inoutReader, &bottom);
    __glsReader_getGLdouble_text(inoutReader, &top);
    __glsReader_getGLdouble_text(inoutReader, &zNear);
    __glsReader_getGLdouble_text(inoutReader, &zFar);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[360])(
        left,
        right,
        bottom,
        top,
        zNear,
        zFar
    );
end:
    return;
}

void __gls_decode_text_glPopMatrix(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[361])(
    );
end:
    return;
}

void __gls_decode_text_glPushMatrix(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[362])(
    );
end:
    return;
}

void __gls_decode_text_glRotated(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble angle;
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &angle);
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[363])(
        angle,
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRotatef(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat angle;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &angle);
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[364])(
        angle,
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glScaled(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[365])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glScalef(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[366])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glTranslated(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[367])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glTranslatef(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[368])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glViewport(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[369])(
        x,
        y,
        width,
        height
    );
end:
    return;
}

#if __GL_EXT_blend_color
void __gls_decode_text_glBlendColorEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    __glsReader_getGLfloat_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[384])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}
#endif /* __GL_EXT_blend_color */

#if __GL_EXT_blend_minmax
void __gls_decode_text_glBlendEquationEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[385])(
        mode
    );
end:
    return;
}
#endif /* __GL_EXT_blend_minmax */

#if __GL_EXT_polygon_offset
void __gls_decode_text_glPolygonOffsetEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat factor;
    GLfloat bias;
    __glsReader_getGLfloat_text(inoutReader, &factor);
    __glsReader_getGLfloat_text(inoutReader, &bias);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[386])(
        factor,
        bias
    );
end:
    return;
}
#endif /* __GL_EXT_polygon_offset */

void __gls_decode_text_glPolygonOffset(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat factor;
    GLfloat units;
    __glsReader_getGLfloat_text(inoutReader, &factor);
    __glsReader_getGLfloat_text(inoutReader, &units);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[383])(
        factor,
        units
    );
end:
    return;
}

#if __GL_EXT_subtexture
void __gls_decode_text_glTexSubImage1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage1DEXT_pixels_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[387])(
        target,
        level,
        xoffset,
        width,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_text_glTexSubImage1D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage1D_pixels_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[396])(
        target,
        level,
        xoffset,
        width,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

#if __GL_EXT_subtexture
void __gls_decode_text_glTexSubImage2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage2DEXT_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[388])(
        target,
        level,
        xoffset,
        yoffset,
        width,
        height,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_text_glTexSubImage2D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage2D_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[397])(
        target,
        level,
        xoffset,
        yoffset,
        width,
        height,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

#if __GL_SGIS_multisample
void __gls_decode_text_glSampleMaskSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampf, GLboolean);
    GLclampf value;
    GLboolean invert;
    __glsReader_getGLfloat_text(inoutReader, &value);
    __glsReader_getGLboolean_text(inoutReader, &invert);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[389])(
        value,
        invert
    );
end:
    return;
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIS_multisample
void __gls_decode_text_glSamplePatternSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum pattern;
    __glsReader_getGLenum_text(inoutReader, &pattern);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[390])(
        pattern
    );
end:
    return;
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIX_multisample
void __gls_decode_text_glTagSampleBufferSGIX(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[391])(
    );
end:
    return;
}
#endif /* __GL_SGIX_multisample */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionFilter1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint image_count;
    GLvoid *image = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(image)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    image_count = __gls_glConvolutionFilter1DEXT_image_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, image, GLvoid, 1 * image_count);
    if (!image) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, image_count, image);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[392])(
        target,
        internalformat,
        width,
        format,
        type,
        image
    );
end:
    __GLS_DEC_FREE(image);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionFilter2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint image_count;
    GLvoid *image = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(image)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    image_count = __gls_glConvolutionFilter2DEXT_image_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, image, GLvoid, 1 * image_count);
    if (!image) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, image_count, image);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[393])(
        target,
        internalformat,
        width,
        height,
        format,
        type,
        image
    );
end:
    __GLS_DEC_FREE(image);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionParameterfEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum target;
    GLenum pname;
    GLfloat params;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[394])(
        target,
        pname,
        params
    );
end:
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glConvolutionParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[395])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionParameteriEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum target;
    GLenum pname;
    GLint params;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[396])(
        target,
        pname,
        params
    );
end:
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glConvolutionParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[397])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glCopyConvolutionFilter1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[398])(
        target,
        internalformat,
        x,
        y,
        width
    );
end:
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glCopyConvolutionFilter2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[399])(
        target,
        internalformat,
        x,
        y,
        width,
        height
    );
end:
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glGetConvolutionFilterEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLenum format;
    GLenum type;
    GLint image_count;
    GLvoid *image = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(image)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    image_count = __gls_glGetConvolutionFilterEXT_image_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, image, GLvoid, 1 * image_count);
    if (!image) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[400])(
        target,
        format,
        type,
        image
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(image);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glGetConvolutionParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetConvolutionParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[401])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glGetConvolutionParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetConvolutionParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[402])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glGetSeparableFilterEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
    GLenum target;
    GLenum format;
    GLenum type;
    GLint row_count;
    GLvoid *row = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(row)
    GLint column_count;
    GLvoid *column = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(column)
    GLint span_count;
    GLvoid *span = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(span)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    row_count = __gls_glGetSeparableFilterEXT_row_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, row, GLvoid, 1 * row_count);
    if (!row) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    column_count = __gls_glGetSeparableFilterEXT_column_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, column, GLvoid, 1 * column_count);
    if (!column) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 1);
    span_count = __gls_glGetSeparableFilterEXT_span_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, span, GLvoid, 1 * span_count);
    if (!span) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 2);
    ctx->outArgs.count = 3;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[403])(
        target,
        format,
        type,
        row,
        column,
        span
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(row);
    __GLS_DEC_FREE(column);
    __GLS_DEC_FREE(span);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glSeparableFilter2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint row_count;
    GLvoid *row = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(row)
    GLint column_count;
    GLvoid *column = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(column)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    row_count = __gls_glSeparableFilter2DEXT_row_size(target, format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, row, GLvoid, 1 * row_count);
    if (!row) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, row_count, row);
    column_count = __gls_glSeparableFilter2DEXT_column_size(target, format, type, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, column, GLvoid, 1 * column_count);
    if (!column) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, column_count, column);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[404])(
        target,
        internalformat,
        width,
        height,
        format,
        type,
        row,
        column
    );
end:
    __GLS_DEC_FREE(row);
    __GLS_DEC_FREE(column);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram
void __gls_decode_text_glGetHistogramEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLint values_count;
    GLvoid *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLboolean_text(inoutReader, &reset);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    values_count = __gls_glGetHistogramEXT_values_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLvoid, 1 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[405])(
        target,
        reset,
        format,
        type,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetHistogramParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetHistogramParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[406])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetHistogramParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetHistogramParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[407])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetMinmaxEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLint values_count;
    GLvoid *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLboolean_text(inoutReader, &reset);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    values_count = __gls_glGetMinmaxEXT_values_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLvoid, 1 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[408])(
        target,
        reset,
        format,
        type,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetMinmaxParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetMinmaxParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[409])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetMinmaxParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetMinmaxParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[410])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glHistogramEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLenum, GLboolean);
    GLenum target;
    GLsizei width;
    GLenum internalformat;
    GLboolean sink;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLboolean_text(inoutReader, &sink);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[411])(
        target,
        width,
        internalformat,
        sink
    );
end:
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glMinmaxEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLboolean);
    GLenum target;
    GLenum internalformat;
    GLboolean sink;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLboolean_text(inoutReader, &sink);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[412])(
        target,
        internalformat,
        sink
    );
end:
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glResetHistogramEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum target;
    __glsReader_getGLenum_text(inoutReader, &target);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[413])(
        target
    );
end:
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glResetMinmaxEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum target;
    __glsReader_getGLenum_text(inoutReader, &target);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[414])(
        target
    );
end:
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_texture3D
void __gls_decode_text_glTexImage3DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &depth);
    __glsReader_getGLint_text(inoutReader, &border);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage3DEXT_pixels_size(format, type, width, height, depth);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[415])(
        target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_subtexture
void __gls_decode_text_glTexSubImage3DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &zoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &depth);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage3DEXT_pixels_size(format, type, width, height, depth);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[416])(
        target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_EXT_subtexture */

#if __GL_SGIS_detail_texture
void __gls_decode_text_glDetailTexFuncSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    GLenum target;
    GLsizei n;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * __GLS_MAX(n*2, 0));
    if (!points) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(n*2, 0), points);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[417])(
        target,
        n,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_detail_texture
void __gls_decode_text_glGetDetailTexFuncSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    GLenum target;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    points_count = __gls_glGetDetailTexFuncSGIS_points_size(target);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * points_count);
    if (!points) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[418])(
        target,
        points
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(points);
    return;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_text_glSharpenTexFuncSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    GLenum target;
    GLsizei n;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * __GLS_MAX(n*2, 0));
    if (!points) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(n*2, 0), points);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[419])(
        target,
        n,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_text_glGetSharpenTexFuncSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    GLenum target;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    points_count = __gls_glGetSharpenTexFuncSGIS_points_size(target);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * points_count);
    if (!points) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[420])(
        target,
        points
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(points);
    return;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_EXT_vertex_array
void __gls_decode_text_glArrayElementEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint i;
    __glsReader_getGLint_text(inoutReader, &i);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[437])(
        i
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glArrayElement(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLuint enabled;
    GLsizei count;
    GLvoid *data;
    data = __glsSetArrayStateText(ctx, inoutReader, &enabled, &count);
    if (data == NULL) goto end;
    ((__GLSdispatch)ctx->dispatchCall[370])(
        0
    );
    __glsDisableArrayState(ctx, enabled);
    free(data);
end:
    return;
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glColorPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLint_text(inoutReader, &size);
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glColorPointerEXT_pointer_size(size, type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65494, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[438])(
        size,
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glColorPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because ColorPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glDrawArraysEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    GLenum mode;
    GLint first;
    GLsizei count;
    __glsReader_getGLenum_text(inoutReader, &mode);
    __glsReader_getGLint_text(inoutReader, &first);
    __glsReader_getGLint_text(inoutReader, &count);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[439])(
        mode,
        first,
        count
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glDrawArrays(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    GLenum mode;
    GLuint enabled;
    GLsizei count;
    GLvoid *data;
    __glsReader_getGLenum_text(inoutReader, &mode);
    data = __glsSetArrayStateText(ctx, inoutReader, &enabled, &count);
    if (data == NULL) goto end;
    ((__GLSdispatch)ctx->dispatchCall[374])(
        mode,
        0,
        count
    );
    __glsDisableArrayState(ctx, enabled);
    free(data);
end:
    return;
}

void __gls_decode_text_glDrawElements(__GLScontext *ctx, __GLSreader *inoutReader) {
    // DrewB - Non-functional
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glEdgeFlagPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, const GLboolean *);
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLboolean *pointer = GLS_NONE;
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glEdgeFlagPointerEXT_pointer_size(stride, count);
    pointer = (GLboolean *)__glsReader_allocVertexArrayBuf(inoutReader, 65496, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLbooleanv_text(inoutReader, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[440])(
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glEdgeFlagPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because EdgeFlagPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glGetPointervEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    GLenum pname;
    GLvoid* params[1];
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[441])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glGetPointerv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    GLenum pname;
    GLvoid* params[1];
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[393])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glIndexPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glIndexPointerEXT_pointer_size(type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65498, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[442])(
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glIndexPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because IndexPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glNormalPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glNormalPointerEXT_pointer_size(type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65499, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[443])(
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glNormalPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because NormalPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glTexCoordPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLint_text(inoutReader, &size);
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glTexCoordPointerEXT_pointer_size(size, type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65500, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[444])(
        size,
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glTexCoordPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because TexCoordPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glVertexPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLint_text(inoutReader, &size);
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glVertexPointerEXT_pointer_size(size, type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65501, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[445])(
        size,
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glVertexPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because VertexPointer isn't captured
}

#if __GL_EXT_texture_object
void __gls_decode_text_glAreTexturesResidentEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    GLboolean *residences = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(residences)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    __GLS_DEC_ALLOC_TEXT(inoutReader, residences, GLboolean, 1 * __GLS_MAX(n, 0));
    if (!residences) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[430])(
        n,
        textures,
        residences
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
    __GLS_DEC_FREE(residences);
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glAreTexturesResident(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    GLboolean *residences = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(residences)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    __GLS_DEC_ALLOC_TEXT(inoutReader, residences, GLboolean, 1 * __GLS_MAX(n, 0));
    if (!residences) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[386])(
        n,
        textures,
        residences
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
    __GLS_DEC_FREE(residences);
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glBindTextureEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    GLenum target;
    GLuint texture;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLuint_text(inoutReader, &texture);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[431])(
        target,
        texture
    );
end:
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glBindTexture(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    GLenum target;
    GLuint texture;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLuint_text(inoutReader, &texture);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[371])(
        target,
        texture
    );
end:
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glDeleteTexturesEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[432])(
        n,
        textures
    );
end:
    __GLS_DEC_FREE(textures);
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glDeleteTextures(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[391])(
        n,
        textures
    );
end:
    __GLS_DEC_FREE(textures);
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glGenTexturesEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[433])(
        n,
        textures
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glGenTextures(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[392])(
        n,
        textures
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glIsTextureEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint texture;
    __glsReader_getGLuint_text(inoutReader, &texture);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[434])(
        texture
    );
end:
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glIsTexture(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint texture;
    __glsReader_getGLuint_text(inoutReader, &texture);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[394])(
        texture
    );
end:
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glPrioritizeTexturesEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    GLclampf *priorities = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(priorities)
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    __GLS_DEC_ALLOC_TEXT(inoutReader, priorities, GLclampf, 4 * __GLS_MAX(n, 0));
    if (!priorities) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(n, 0), priorities);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[435])(
        n,
        textures,
        priorities
    );
end:
    __GLS_DEC_FREE(textures);
    __GLS_DEC_FREE(priorities);
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glPrioritizeTextures(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    GLclampf *priorities = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(priorities)
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    __GLS_DEC_ALLOC_TEXT(inoutReader, priorities, GLclampf, 4 * __GLS_MAX(n, 0));
    if (!priorities) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(n, 0), priorities);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[395])(
        n,
        textures,
        priorities
    );
end:
    __GLS_DEC_FREE(textures);
    __GLS_DEC_FREE(priorities);
    return;
}

#if __GL_EXT_paletted_texture
void __gls_decode_text_glColorTableEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint table_count;
    GLvoid *table = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(table)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    table_count = __gls_glColorTableEXT_table_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, table, GLvoid, 1 * table_count);
    if (!table) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, table_count, table);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[452])(
        target,
        internalformat,
        width,
        format,
        type,
        table
    );
end:
    __GLS_DEC_FREE(table);
    return;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_color_table
void __gls_decode_text_glColorTableParameterfvSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glColorTableParameterfvSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[437])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_text_glColorTableParameterivSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glColorTableParameterivSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[438])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_text_glCopyColorTableSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[439])(
        target,
        internalformat,
        x,
        y,
        width
    );
end:
    return;
}
#endif /* __GL_SGI_color_table */

#if __GL_EXT_paletted_texture
void __gls_decode_text_glGetColorTableEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLenum format;
    GLenum type;
    GLint table_count;
    GLvoid *table = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(table)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    table_count = __gls_glGetColorTableEXT_table_size(ctx, target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, table, GLvoid, 1 * table_count);
    if (!table) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[456])(
        target,
        format,
        type,
        table
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(table);
    return;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_text_glGetColorTableParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetColorTableParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[457])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_text_glGetColorTableParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetColorTableParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[458])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table
void __gls_decode_text_glGetTexColorTableParameterfvSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexColorTableParameterfvSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[443])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_text_glGetTexColorTableParameterivSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexColorTableParameterivSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[444])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_text_glTexColorTableParameterfvSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexColorTableParameterfvSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[445])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_text_glTexColorTableParameterivSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexColorTableParameterivSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[446])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexImage1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &border);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[447])(
        target,
        level,
        internalformat,
        x,
        y,
        width,
        border
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_text_glCopyTexImage1D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &border);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[387])(
        target,
        level,
        internalformat,
        x,
        y,
        width,
        border
    );
end:
    return;
}

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexImage2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &border);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[448])(
        target,
        level,
        internalformat,
        x,
        y,
        width,
        height,
        border
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_text_glCopyTexImage2D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &border);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[388])(
        target,
        level,
        internalformat,
        x,
        y,
        width,
        height,
        border
    );
end:
    return;
}

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexSubImage1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[449])(
        target,
        level,
        xoffset,
        x,
        y,
        width
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_text_glCopyTexSubImage1D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[389])(
        target,
        level,
        xoffset,
        x,
        y,
        width
    );
end:
    return;
}

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexSubImage2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[450])(
        target,
        level,
        xoffset,
        yoffset,
        x,
        y,
        width,
        height
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_text_glCopyTexSubImage2D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[390])(
        target,
        level,
        xoffset,
        yoffset,
        x,
        y,
        width,
        height
    );
end:
    return;
}

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexSubImage3DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &zoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[451])(
        target,
        level,
        xoffset,
        yoffset,
        zoffset,
        x,
        y,
        width,
        height
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

#if __GL_SGIS_texture4D
void __gls_decode_text_glTexImage4DSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLint border;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &depth);
    __glsReader_getGLint_text(inoutReader, &size4d);
    __glsReader_getGLint_text(inoutReader, &border);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[452])(
        target,
        level,
        internalformat,
        width,
        height,
        depth,
        size4d,
        border,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIS_texture4D
void __gls_decode_text_glTexSubImage4DSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint woffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &zoffset);
    __glsReader_getGLint_text(inoutReader, &woffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &depth);
    __glsReader_getGLint_text(inoutReader, &size4d);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[453])(
        target,
        level,
        xoffset,
        yoffset,
        zoffset,
        woffset,
        width,
        height,
        depth,
        size4d,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIX_pixel_texture
void __gls_decode_text_glPixelTexGenSGIX(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[454])(
        mode
    );
end:
    return;
}
#endif /* __GL_SGIX_pixel_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_text_glColorSubTableEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLuint, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLuint start;
    GLsizei count;
    GLenum format;
    GLenum type;
    GLint entries_count;
    GLvoid *entries = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(entries)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLuint_text(inoutReader, &start);
    __glsReader_getGLint_text(inoutReader, &count);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    entries_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glColorSubTableEXT_entries_size(format, type, count);
    __GLS_DEC_ALLOC_TEXT(inoutReader, entries, GLvoid, 1 * entries_count);
    if (!entries) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, entries_count, entries);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[496])(
        target,
        start,
        count,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : entries
    );
end:
    __GLS_DEC_FREE(entries);
    return;
}
#endif // __GL_EXT_paletted_texture

void __gls_decode_text_glDisableClientState(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[373])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glEnableClientState(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[377])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glInterleavedArrays(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because InterleavedArrays isn't captured
}

void __gls_decode_text_glPushClientAttrib(__GLScontext *ctx, __GLSreader *inoutReader) {
    // Nonfunctional
}

void __gls_decode_text_glPopClientAttrib(__GLScontext *ctx, __GLSreader *inoutReader) {
    // Nonfunctional
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_irix.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "types.h"
#include "g_dispatch.h"

extern void __gls_capture_glNewList(GLuint list, GLenum mode);
extern void __gls_capture_glEndList(void);
extern void __gls_capture_glCallList(GLuint list);
extern void __gls_capture_glCallLists(GLsizei n, GLenum type, const GLvoid *lists);
extern void __gls_capture_glDeleteLists(GLuint list, GLsizei range);
extern GLuint __gls_capture_glGenLists(GLsizei range);
extern void __gls_capture_glListBase(GLuint base);
extern void __gls_capture_glBegin(GLenum mode);
extern void __gls_capture_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void __gls_capture_glColor3b(GLbyte red, GLbyte green, GLbyte blue);
extern void __gls_capture_glColor3bv(const GLbyte *v);
extern void __gls_capture_glColor3d(GLdouble red, GLdouble green, GLdouble blue);
extern void __gls_capture_glColor3dv(const GLdouble *v);
extern void __gls_capture_glColor3f(GLfloat red, GLfloat green, GLfloat blue);
extern void __gls_capture_glColor3fv(const GLfloat *v);
extern void __gls_capture_glColor3i(GLint red, GLint green, GLint blue);
extern void __gls_capture_glColor3iv(const GLint *v);
extern void __gls_capture_glColor3s(GLshort red, GLshort green, GLshort blue);
extern void __gls_capture_glColor3sv(const GLshort *v);
extern void __gls_capture_glColor3ub(GLubyte red, GLubyte green, GLubyte blue);
extern void __gls_capture_glColor3ubv(const GLubyte *v);
extern void __gls_capture_glColor3ui(GLuint red, GLuint green, GLuint blue);
extern void __gls_capture_glColor3uiv(const GLuint *v);
extern void __gls_capture_glColor3us(GLushort red, GLushort green, GLushort blue);
extern void __gls_capture_glColor3usv(const GLushort *v);
extern void __gls_capture_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void __gls_capture_glColor4bv(const GLbyte *v);
extern void __gls_capture_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void __gls_capture_glColor4dv(const GLdouble *v);
extern void __gls_capture_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void __gls_capture_glColor4fv(const GLfloat *v);
extern void __gls_capture_glColor4i(GLint red, GLint green, GLint blue, GLint alpha);
extern void __gls_capture_glColor4iv(const GLint *v);
extern void __gls_capture_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void __gls_capture_glColor4sv(const GLshort *v);
extern void __gls_capture_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void __gls_capture_glColor4ubv(const GLubyte *v);
extern void __gls_capture_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void __gls_capture_glColor4uiv(const GLuint *v);
extern void __gls_capture_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void __gls_capture_glColor4usv(const GLushort *v);
extern void __gls_capture_glEdgeFlag(GLboolean flag);
extern void __gls_capture_glEdgeFlagv(const GLboolean *flag);
extern void __gls_capture_glEnd(void);
extern void __gls_capture_glIndexd(GLdouble c);
extern void __gls_capture_glIndexdv(const GLdouble *c);
extern void __gls_capture_glIndexf(GLfloat c);
extern void __gls_capture_glIndexfv(const GLfloat *c);
extern void __gls_capture_glIndexi(GLint c);
extern void __gls_capture_glIndexiv(const GLint *c);
extern void __gls_capture_glIndexs(GLshort c);
extern void __gls_capture_glIndexsv(const GLshort *c);
extern void __gls_capture_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);
extern void __gls_capture_glNormal3bv(const GLbyte *v);
extern void __gls_capture_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);
extern void __gls_capture_glNormal3dv(const GLdouble *v);
extern void __gls_capture_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
extern void __gls_capture_glNormal3fv(const GLfloat *v);
extern void __gls_capture_glNormal3i(GLint nx, GLint ny, GLint nz);
extern void __gls_capture_glNormal3iv(const GLint *v);
extern void __gls_capture_glNormal3s(GLshort nx, GLshort ny, GLshort nz);
extern void __gls_capture_glNormal3sv(const GLshort *v);
extern void __gls_capture_glRasterPos2d(GLdouble x, GLdouble y);
extern void __gls_capture_glRasterPos2dv(const GLdouble *v);
extern void __gls_capture_glRasterPos2f(GLfloat x, GLfloat y);
extern void __gls_capture_glRasterPos2fv(const GLfloat *v);
extern void __gls_capture_glRasterPos2i(GLint x, GLint y);
extern void __gls_capture_glRasterPos2iv(const GLint *v);
extern void __gls_capture_glRasterPos2s(GLshort x, GLshort y);
extern void __gls_capture_glRasterPos2sv(const GLshort *v);
extern void __gls_capture_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glRasterPos3dv(const GLdouble *v);
extern void __gls_capture_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glRasterPos3fv(const GLfloat *v);
extern void __gls_capture_glRasterPos3i(GLint x, GLint y, GLint z);
extern void __gls_capture_glRasterPos3iv(const GLint *v);
extern void __gls_capture_glRasterPos3s(GLshort x, GLshort y, GLshort z);
extern void __gls_capture_glRasterPos3sv(const GLshort *v);
extern void __gls_capture_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void __gls_capture_glRasterPos4dv(const GLdouble *v);
extern void __gls_capture_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void __gls_capture_glRasterPos4fv(const GLfloat *v);
extern void __gls_capture_glRasterPos4i(GLint x, GLint y, GLint z, GLint w);
extern void __gls_capture_glRasterPos4iv(const GLint *v);
extern void __gls_capture_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);
extern void __gls_capture_glRasterPos4sv(const GLshort *v);
extern void __gls_capture_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void __gls_capture_glRectdv(const GLdouble *v1, const GLdouble *v2);
extern void __gls_capture_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void __gls_capture_glRectfv(const GLfloat *v1, const GLfloat *v2);
extern void __gls_capture_glRecti(GLint x1, GLint y1, GLint x2, GLint y2);
extern void __gls_capture_glRectiv(const GLint *v1, const GLint *v2);
extern void __gls_capture_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void __gls_capture_glRectsv(const GLshort *v1, const GLshort *v2);
extern void __gls_capture_glTexCoord1d(GLdouble s);
extern void __gls_capture_glTexCoord1dv(const GLdouble *v);
extern void __gls_capture_glTexCoord1f(GLfloat s);
extern void __gls_capture_glTexCoord1fv(const GLfloat *v);
extern void __gls_capture_glTexCoord1i(GLint s);
extern void __gls_capture_glTexCoord1iv(const GLint *v);
extern void __gls_capture_glTexCoord1s(GLshort s);
extern void __gls_capture_glTexCoord1sv(const GLshort *v);
extern void __gls_capture_glTexCoord2d(GLdouble s, GLdouble t);
extern void __gls_capture_glTexCoord2dv(const GLdouble *v);
extern void __gls_capture_glTexCoord2f(GLfloat s, GLfloat t);
extern void __gls_capture_glTexCoord2fv(const GLfloat *v);
extern void __gls_capture_glTexCoord2i(GLint s, GLint t);
extern void __gls_capture_glTexCoord2iv(const GLint *v);
extern void __gls_capture_glTexCoord2s(GLshort s, GLshort t);
extern void __gls_capture_glTexCoord2sv(const GLshort *v);
extern void __gls_capture_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);
extern void __gls_capture_glTexCoord3dv(const GLdouble *v);
extern void __gls_capture_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);
extern void __gls_capture_glTexCoord3fv(const GLfloat *v);
extern void __gls_capture_glTexCoord3i(GLint s, GLint t, GLint r);
extern void __gls_capture_glTexCoord3iv(const GLint *v);
extern void __gls_capture_glTexCoord3s(GLshort s, GLshort t, GLshort r);
extern void __gls_capture_glTexCoord3sv(const GLshort *v);
extern void __gls_capture_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void __gls_capture_glTexCoord4dv(const GLdouble *v);
extern void __gls_capture_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void __gls_capture_glTexCoord4fv(const GLfloat *v);
extern void __gls_capture_glTexCoord4i(GLint s, GLint t, GLint r, GLint q);
extern void __gls_capture_glTexCoord4iv(const GLint *v);
extern void __gls_capture_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);
extern void __gls_capture_glTexCoord4sv(const GLshort *v);
extern void __gls_capture_glVertex2d(GLdouble x, GLdouble y);
extern void __gls_capture_glVertex2dv(const GLdouble *v);
extern void __gls_capture_glVertex2f(GLfloat x, GLfloat y);
extern void __gls_capture_glVertex2fv(const GLfloat *v);
extern void __gls_capture_glVertex2i(GLint x, GLint y);
extern void __gls_capture_glVertex2iv(const GLint *v);
extern void __gls_capture_glVertex2s(GLshort x, GLshort y);
extern void __gls_capture_glVertex2sv(const GLshort *v);
extern void __gls_capture_glVertex3d(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glVertex3dv(const GLdouble *v);
extern void __gls_capture_glVertex3f(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glVertex3fv(const GLfloat *v);
extern void __gls_capture_glVertex3i(GLint x, GLint y, GLint z);
extern void __gls_capture_glVertex3iv(const GLint *v);
extern void __gls_capture_glVertex3s(GLshort x, GLshort y, GLshort z);
extern void __gls_capture_glVertex3sv(const GLshort *v);
extern void __gls_capture_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void __gls_capture_glVertex4dv(const GLdouble *v);
extern void __gls_capture_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void __gls_capture_glVertex4fv(const GLfloat *v);
extern void __gls_capture_glVertex4i(GLint x, GLint y, GLint z, GLint w);
extern void __gls_capture_glVertex4iv(const GLint *v);
extern void __gls_capture_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);
extern void __gls_capture_glVertex4sv(const GLshort *v);
extern void __gls_capture_glClipPlane(GLenum plane, const GLdouble *equation);
extern void __gls_capture_glColorMaterial(GLenum face, GLenum mode);
extern void __gls_capture_glCullFace(GLenum mode);
extern void __gls_capture_glFogf(GLenum pname, GLfloat param);
extern void __gls_capture_glFogfv(GLenum pname, const GLfloat *params);
extern void __gls_capture_glFogi(GLenum pname, GLint param);
extern void __gls_capture_glFogiv(GLenum pname, const GLint *params);
extern void __gls_capture_glFrontFace(GLenum mode);
extern void __gls_capture_glHint(GLenum target, GLenum mode);
extern void __gls_capture_glLightf(GLenum light, GLenum pname, GLfloat param);
extern void __gls_capture_glLightfv(GLenum light, GLenum pname, const GLfloat *params);
extern void __gls_capture_glLighti(GLenum light, GLenum pname, GLint param);
extern void __gls_capture_glLightiv(GLenum light, GLenum pname, const GLint *params);
extern void __gls_capture_glLightModelf(GLenum pname, GLfloat param);
extern void __gls_capture_glLightModelfv(GLenum pname, const GLfloat *params);
extern void __gls_capture_glLightModeli(GLenum pname, GLint param);
extern void __gls_capture_glLightModeliv(GLenum pname, const GLint *params);
extern void __gls_capture_glLineStipple(GLint factor, GLushort pattern);
extern void __gls_capture_glLineWidth(GLfloat width);
extern void __gls_capture_glMaterialf(GLenum face, GLenum pname, GLfloat param);
extern void __gls_capture_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params);
extern void __gls_capture_glMateriali(GLenum face, GLenum pname, GLint param);
extern void __gls_capture_glMaterialiv(GLenum face, GLenum pname, const GLint *params);
extern void __gls_capture_glPointSize(GLfloat size);
extern void __gls_capture_glPolygonMode(GLenum face, GLenum mode);
extern void __gls_capture_glPolygonStipple(const GLubyte *mask);
extern void __gls_capture_glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glShadeModel(GLenum mode);
extern void __gls_capture_glTexParameterf(GLenum target, GLenum pname, GLfloat param);
extern void __gls_capture_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexParameteri(GLenum target, GLenum pname, GLint param);
extern void __gls_capture_glTexParameteriv(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexEnvf(GLenum target, GLenum pname, GLfloat param);
extern void __gls_capture_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexEnvi(GLenum target, GLenum pname, GLint param);
extern void __gls_capture_glTexEnviv(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glTexGend(GLenum coord, GLenum pname, GLdouble param);
extern void __gls_capture_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params);
extern void __gls_capture_glTexGenf(GLenum coord, GLenum pname, GLfloat param);
extern void __gls_capture_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexGeni(GLenum coord, GLenum pname, GLint param);
extern void __gls_capture_glTexGeniv(GLenum coord, GLenum pname, const GLint *params);
extern void __gls_capture_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer);
extern void __gls_capture_glSelectBuffer(GLsizei size, GLuint *buffer);
extern GLint __gls_capture_glRenderMode(GLenum mode);
extern void __gls_capture_glInitNames(void);
extern void __gls_capture_glLoadName(GLuint name);
extern void __gls_capture_glPassThrough(GLfloat token);
extern void __gls_capture_glPopName(void);
extern void __gls_capture_glPushName(GLuint name);
extern void __gls_capture_glDrawBuffer(GLenum mode);
extern void __gls_capture_glClear(GLbitfield mask);
extern void __gls_capture_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void __gls_capture_glClearIndex(GLfloat c);
extern void __gls_capture_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void __gls_capture_glClearStencil(GLint s);
extern void __gls_capture_glClearDepth(GLclampd depth);
extern void __gls_capture_glStencilMask(GLuint mask);
extern void __gls_capture_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void __gls_capture_glDepthMask(GLboolean flag);
extern void __gls_capture_glIndexMask(GLuint mask);
extern void __gls_capture_glAccum(GLenum op, GLfloat value);
extern void __gls_capture_glDisable(GLenum cap);
extern void __gls_capture_glEnable(GLenum cap);
extern void __gls_capture_glFinish(void);
extern void __gls_capture_glFlush(void);
extern void __gls_capture_glPopAttrib(void);
extern void __gls_capture_glPushAttrib(GLbitfield mask);
extern void __gls_capture_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void __gls_capture_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void __gls_capture_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void __gls_capture_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void __gls_capture_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);
extern void __gls_capture_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);
extern void __gls_capture_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void __gls_capture_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void __gls_capture_glEvalCoord1d(GLdouble u);
extern void __gls_capture_glEvalCoord1dv(const GLdouble *u);
extern void __gls_capture_glEvalCoord1f(GLfloat u);
extern void __gls_capture_glEvalCoord1fv(const GLfloat *u);
extern void __gls_capture_glEvalCoord2d(GLdouble u, GLdouble v);
extern void __gls_capture_glEvalCoord2dv(const GLdouble *u);
extern void __gls_capture_glEvalCoord2f(GLfloat u, GLfloat v);
extern void __gls_capture_glEvalCoord2fv(const GLfloat *u);
extern void __gls_capture_glEvalMesh1(GLenum mode, GLint i1, GLint i2);
extern void __gls_capture_glEvalPoint1(GLint i);
extern void __gls_capture_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void __gls_capture_glEvalPoint2(GLint i, GLint j);
extern void __gls_capture_glAlphaFunc(GLenum func, GLclampf ref);
extern void __gls_capture_glBlendFunc(GLenum sfactor, GLenum dfactor);
extern void __gls_capture_glLogicOp(GLenum opcode);
extern void __gls_capture_glStencilFunc(GLenum func, GLint ref, GLuint mask);
extern void __gls_capture_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
extern void __gls_capture_glDepthFunc(GLenum func);
extern void __gls_capture_glPixelZoom(GLfloat xfactor, GLfloat yfactor);
extern void __gls_capture_glPixelTransferf(GLenum pname, GLfloat param);
extern void __gls_capture_glPixelTransferi(GLenum pname, GLint param);
extern void __gls_capture_glPixelStoref(GLenum pname, GLfloat param);
extern void __gls_capture_glPixelStorei(GLenum pname, GLint param);
extern void __gls_capture_glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values);
extern void __gls_capture_glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values);
extern void __gls_capture_glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values);
extern void __gls_capture_glReadBuffer(GLenum mode);
extern void __gls_capture_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void __gls_capture_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void __gls_capture_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glGetBooleanv(GLenum pname, GLboolean *params);
extern void __gls_capture_glGetClipPlane(GLenum plane, GLdouble *equation);
extern void __gls_capture_glGetDoublev(GLenum pname, GLdouble *params);
extern GLenum __gls_capture_glGetError(void);
extern void __gls_capture_glGetFloatv(GLenum pname, GLfloat *params);
extern void __gls_capture_glGetIntegerv(GLenum pname, GLint *params);
extern void __gls_capture_glGetLightfv(GLenum light, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetLightiv(GLenum light, GLenum pname, GLint *params);
extern void __gls_capture_glGetMapdv(GLenum target, GLenum query, GLdouble *v);
extern void __gls_capture_glGetMapfv(GLenum target, GLenum query, GLfloat *v);
extern void __gls_capture_glGetMapiv(GLenum target, GLenum query, GLint *v);
extern void __gls_capture_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetMaterialiv(GLenum face, GLenum pname, GLint *params);
extern void __gls_capture_glGetPixelMapfv(GLenum map, GLfloat *values);
extern void __gls_capture_glGetPixelMapuiv(GLenum map, GLuint *values);
extern void __gls_capture_glGetPixelMapusv(GLenum map, GLushort *values);
extern void __gls_capture_glGetPolygonStipple(GLubyte *mask);
extern const GLubyte * __gls_capture_glGetString(GLenum name);
extern void __gls_capture_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexEnviv(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params);
extern void __gls_capture_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void __gls_capture_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params);
extern GLboolean __gls_capture_glIsEnabled(GLenum cap);
extern GLboolean __gls_capture_glIsList(GLuint list);
extern void __gls_capture_glDepthRange(GLclampd near, GLclampd far);
extern void __gls_capture_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);
extern void __gls_capture_glLoadIdentity(void);
extern void __gls_capture_glLoadMatrixf(const GLfloat *m);
extern void __gls_capture_glLoadMatrixd(const GLdouble *m);
extern void __gls_capture_glMatrixMode(GLenum mode);
extern void __gls_capture_glMultMatrixf(const GLfloat *m);
extern void __gls_capture_glMultMatrixd(const GLdouble *m);
extern void __gls_capture_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);
extern void __gls_capture_glPopMatrix(void);
extern void __gls_capture_glPushMatrix(void);
extern void __gls_capture_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glScaled(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glScalef(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glTranslated(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glTranslatef(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void __gls_capture_glBlendEquationEXT(GLenum mode);
extern void __gls_capture_glPolygonOffsetEXT(GLfloat factor, GLfloat bias);
extern void __gls_capture_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glSampleMaskSGIS(GLclampf value, GLboolean invert);
extern void __gls_capture_glSamplePatternSGIS(GLenum pattern);
extern void __gls_capture_glTagSampleBufferSGIX(void);
extern void __gls_capture_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
extern void __gls_capture_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
extern void __gls_capture_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params);
extern void __gls_capture_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params);
extern void __gls_capture_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image);
extern void __gls_capture_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
extern void __gls_capture_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
extern void __gls_capture_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void __gls_capture_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void __gls_capture_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern void __gls_capture_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink);
extern void __gls_capture_glResetHistogramEXT(GLenum target);
extern void __gls_capture_glResetMinmaxEXT(GLenum target);
extern void __gls_capture_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);
extern void __gls_capture_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points);
extern void __gls_capture_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);
extern void __gls_capture_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points);
extern void __gls_capture_glArrayElementEXT(GLint i);
extern void __gls_capture_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);
extern void __gls_capture_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer);
extern void __gls_capture_glGetPointervEXT(GLenum pname, GLvoid* *params);
extern void __gls_capture_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern GLboolean __gls_capture_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences);
extern void __gls_capture_glBindTextureEXT(GLenum target, GLuint texture);
extern void __gls_capture_glDeleteTexturesEXT(GLsizei n, const GLuint *textures);
extern void __gls_capture_glGenTexturesEXT(GLsizei n, GLuint *textures);
extern GLboolean __gls_capture_glIsTextureEXT(GLuint texture);
extern void __gls_capture_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void __gls_capture_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
extern void __gls_capture_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table);
extern void __gls_capture_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void __gls_capture_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void __gls_capture_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glPixelTexGenSGIX(GLenum mode);

__GLdispatchState __glDispatchCapture = {
    {
        __gls_capture_glNewList,
        __gls_capture_glEndList,
        __gls_capture_glCallList,
        __gls_capture_glCallLists,
        __gls_capture_glDeleteLists,
        __gls_capture_glGenLists,
        __gls_capture_glListBase,
        __gls_capture_glBegin,
        __gls_capture_glBitmap,
        __gls_capture_glEdgeFlag,
        __gls_capture_glEdgeFlagv,
        __gls_capture_glEnd,
        __gls_capture_glClipPlane,
        __gls_capture_glColorMaterial,
        __gls_capture_glCullFace,
        __gls_capture_glFogf,
        __gls_capture_glFogfv,
        __gls_capture_glFogi,
        __gls_capture_glFogiv,
        __gls_capture_glFrontFace,
        __gls_capture_glHint,
        __gls_capture_glLightf,
        __gls_capture_glLightfv,
        __gls_capture_glLighti,
        __gls_capture_glLightiv,
        __gls_capture_glLightModelf,
        __gls_capture_glLightModelfv,
        __gls_capture_glLightModeli,
        __gls_capture_glLightModeliv,
        __gls_capture_glLineStipple,
        __gls_capture_glLineWidth,
        __gls_capture_glMaterialf,
        __gls_capture_glMaterialfv,
        __gls_capture_glMateriali,
        __gls_capture_glMaterialiv,
        __gls_capture_glPointSize,
        __gls_capture_glPolygonMode,
        __gls_capture_glPolygonStipple,
        __gls_capture_glScissor,
        __gls_capture_glShadeModel,
        __gls_capture_glTexParameterf,
        __gls_capture_glTexParameterfv,
        __gls_capture_glTexParameteri,
        __gls_capture_glTexParameteriv,
        __gls_capture_glTexImage1D,
        __gls_capture_glTexImage2D,
        __gls_capture_glTexEnvf,
        __gls_capture_glTexEnvfv,
        __gls_capture_glTexEnvi,
        __gls_capture_glTexEnviv,
        __gls_capture_glTexGend,
        __gls_capture_glTexGendv,
        __gls_capture_glTexGenf,
        __gls_capture_glTexGenfv,
        __gls_capture_glTexGeni,
        __gls_capture_glTexGeniv,
        __gls_capture_glFeedbackBuffer,
        __gls_capture_glSelectBuffer,
        __gls_capture_glRenderMode,
        __gls_capture_glInitNames,
        __gls_capture_glLoadName,
        __gls_capture_glPassThrough,
        __gls_capture_glPopName,
        __gls_capture_glPushName,
        __gls_capture_glDrawBuffer,
        __gls_capture_glClear,
        __gls_capture_glClearAccum,
        __gls_capture_glClearIndex,
        __gls_capture_glClearColor,
        __gls_capture_glClearStencil,
        __gls_capture_glClearDepth,
        __gls_capture_glStencilMask,
        __gls_capture_glColorMask,
        __gls_capture_glDepthMask,
        __gls_capture_glIndexMask,
        __gls_capture_glAccum,
        __gls_capture_glDisable,
        __gls_capture_glEnable,
        __gls_capture_glFinish,
        __gls_capture_glFlush,
        __gls_capture_glPopAttrib,
        __gls_capture_glPushAttrib,
        __gls_capture_glMap1d,
        __gls_capture_glMap1f,
        __gls_capture_glMap2d,
        __gls_capture_glMap2f,
        __gls_capture_glMapGrid1d,
        __gls_capture_glMapGrid1f,
        __gls_capture_glMapGrid2d,
        __gls_capture_glMapGrid2f,
        __gls_capture_glEvalCoord1d,
        __gls_capture_glEvalCoord1dv,
        __gls_capture_glEvalCoord1f,
        __gls_capture_glEvalCoord1fv,
        __gls_capture_glEvalCoord2d,
        __gls_capture_glEvalCoord2dv,
        __gls_capture_glEvalCoord2f,
        __gls_capture_glEvalCoord2fv,
        __gls_capture_glEvalMesh1,
        __gls_capture_glEvalPoint1,
        __gls_capture_glEvalMesh2,
        __gls_capture_glEvalPoint2,
        __gls_capture_glAlphaFunc,
        __gls_capture_glBlendFunc,
        __gls_capture_glLogicOp,
        __gls_capture_glStencilFunc,
        __gls_capture_glStencilOp,
        __gls_capture_glDepthFunc,
        __gls_capture_glPixelZoom,
        __gls_capture_glPixelTransferf,
        __gls_capture_glPixelTransferi,
        __gls_capture_glPixelStoref,
        __gls_capture_glPixelStorei,
        __gls_capture_glPixelMapfv,
        __gls_capture_glPixelMapuiv,
        __gls_capture_glPixelMapusv,
        __gls_capture_glReadBuffer,
        __gls_capture_glCopyPixels,
        __gls_capture_glReadPixels,
        __gls_capture_glDrawPixels,
        __gls_capture_glGetBooleanv,
        __gls_capture_glGetClipPlane,
        __gls_capture_glGetDoublev,
        __gls_capture_glGetError,
        __gls_capture_glGetFloatv,
        __gls_capture_glGetIntegerv,
        __gls_capture_glGetLightfv,
        __gls_capture_glGetLightiv,
        __gls_capture_glGetMapdv,
        __gls_capture_glGetMapfv,
        __gls_capture_glGetMapiv,
        __gls_capture_glGetMaterialfv,
        __gls_capture_glGetMaterialiv,
        __gls_capture_glGetPixelMapfv,
        __gls_capture_glGetPixelMapuiv,
        __gls_capture_glGetPixelMapusv,
        __gls_capture_glGetPolygonStipple,
        __gls_capture_glGetString,
        __gls_capture_glGetTexEnvfv,
        __gls_capture_glGetTexEnviv,
        __gls_capture_glGetTexGendv,
        __gls_capture_glGetTexGenfv,
        __gls_capture_glGetTexGeniv,
        __gls_capture_glGetTexImage,
        __gls_capture_glGetTexParameterfv,
        __gls_capture_glGetTexParameteriv,
        __gls_capture_glGetTexLevelParameterfv,
        __gls_capture_glGetTexLevelParameteriv,
        __gls_capture_glIsEnabled,
        __gls_capture_glIsList,
        __gls_capture_glDepthRange,
        __gls_capture_glFrustum,
        __gls_capture_glLoadIdentity,
        __gls_capture_glLoadMatrixf,
        __gls_capture_glLoadMatrixd,
        __gls_capture_glMatrixMode,
        __gls_capture_glMultMatrixf,
        __gls_capture_glMultMatrixd,
        __gls_capture_glOrtho,
        __gls_capture_glPopMatrix,
        __gls_capture_glPushMatrix,
        __gls_capture_glRotated,
        __gls_capture_glRotatef,
        __gls_capture_glScaled,
        __gls_capture_glScalef,
        __gls_capture_glTranslated,
        __gls_capture_glTranslatef,
        __gls_capture_glViewport,
        __gls_capture_glBlendColorEXT,
        __gls_capture_glBlendEquationEXT,
        __gls_capture_glPolygonOffsetEXT,
        __gls_capture_glTexSubImage1DEXT,
        __gls_capture_glTexSubImage2DEXT,
        __gls_capture_glSampleMaskSGIS,
        __gls_capture_glSamplePatternSGIS,
        __gls_capture_glTagSampleBufferSGIX,
        __gls_capture_glConvolutionFilter1DEXT,
        __gls_capture_glConvolutionFilter2DEXT,
        __gls_capture_glConvolutionParameterfEXT,
        __gls_capture_glConvolutionParameterfvEXT,
        __gls_capture_glConvolutionParameteriEXT,
        __gls_capture_glConvolutionParameterivEXT,
        __gls_capture_glCopyConvolutionFilter1DEXT,
        __gls_capture_glCopyConvolutionFilter2DEXT,
        __gls_capture_glGetConvolutionFilterEXT,
        __gls_capture_glGetConvolutionParameterfvEXT,
        __gls_capture_glGetConvolutionParameterivEXT,
        __gls_capture_glGetSeparableFilterEXT,
        __gls_capture_glSeparableFilter2DEXT,
        __gls_capture_glGetHistogramEXT,
        __gls_capture_glGetHistogramParameterfvEXT,
        __gls_capture_glGetHistogramParameterivEXT,
        __gls_capture_glGetMinmaxEXT,
        __gls_capture_glGetMinmaxParameterfvEXT,
        __gls_capture_glGetMinmaxParameterivEXT,
        __gls_capture_glHistogramEXT,
        __gls_capture_glMinmaxEXT,
        __gls_capture_glResetHistogramEXT,
        __gls_capture_glResetMinmaxEXT,
        __gls_capture_glTexImage3DEXT,
        __gls_capture_glTexSubImage3DEXT,
        __gls_capture_glDetailTexFuncSGIS,
        __gls_capture_glGetDetailTexFuncSGIS,
        __gls_capture_glSharpenTexFuncSGIS,
        __gls_capture_glGetSharpenTexFuncSGIS,
        __gls_capture_glArrayElementEXT,
        __gls_capture_glColorPointerEXT,
        __gls_capture_glDrawArraysEXT,
        __gls_capture_glEdgeFlagPointerEXT,
        __gls_capture_glGetPointervEXT,
        __gls_capture_glIndexPointerEXT,
        __gls_capture_glNormalPointerEXT,
        __gls_capture_glTexCoordPointerEXT,
        __gls_capture_glVertexPointerEXT,
        __gls_capture_glAreTexturesResidentEXT,
        __gls_capture_glBindTextureEXT,
        __gls_capture_glDeleteTexturesEXT,
        __gls_capture_glGenTexturesEXT,
        __gls_capture_glIsTextureEXT,
        __gls_capture_glPrioritizeTexturesEXT,
        __gls_capture_glColorTableSGI,
        __gls_capture_glColorTableParameterfvSGI,
        __gls_capture_glColorTableParameterivSGI,
        __gls_capture_glCopyColorTableSGI,
        __gls_capture_glGetColorTableSGI,
        __gls_capture_glGetColorTableParameterfvSGI,
        __gls_capture_glGetColorTableParameterivSGI,
        __gls_capture_glGetTexColorTableParameterfvSGI,
        __gls_capture_glGetTexColorTableParameterivSGI,
        __gls_capture_glTexColorTableParameterfvSGI,
        __gls_capture_glTexColorTableParameterivSGI,
        __gls_capture_glCopyTexImage1DEXT,
        __gls_capture_glCopyTexImage2DEXT,
        __gls_capture_glCopyTexSubImage1DEXT,
        __gls_capture_glCopyTexSubImage2DEXT,
        __gls_capture_glCopyTexSubImage3DEXT,
        __gls_capture_glTexImage4DSGIS,
        __gls_capture_glTexSubImage4DSGIS,
        __gls_capture_glPixelTexGenSGIX,
        glSpriteParameterfSGIX,
        glSpriteParameterfvSGIX,
        glSpriteParameteriSGIX,
        glSpriteParameterivSGIX,
    },
    {
        __gls_capture_glVertex2d,
        __gls_capture_glVertex2dv,
        __gls_capture_glVertex2f,
        __gls_capture_glVertex2fv,
        __gls_capture_glVertex2i,
        __gls_capture_glVertex2iv,
        __gls_capture_glVertex2s,
        __gls_capture_glVertex2sv,
        __gls_capture_glVertex3d,
        __gls_capture_glVertex3dv,
        __gls_capture_glVertex3f,
        __gls_capture_glVertex3fv,
        __gls_capture_glVertex3i,
        __gls_capture_glVertex3iv,
        __gls_capture_glVertex3s,
        __gls_capture_glVertex3sv,
        __gls_capture_glVertex4d,
        __gls_capture_glVertex4dv,
        __gls_capture_glVertex4f,
        __gls_capture_glVertex4fv,
        __gls_capture_glVertex4i,
        __gls_capture_glVertex4iv,
        __gls_capture_glVertex4s,
        __gls_capture_glVertex4sv,
    },
    {
        __gls_capture_glColor3b,
        __gls_capture_glColor3bv,
        __gls_capture_glColor3d,
        __gls_capture_glColor3dv,
        __gls_capture_glColor3f,
        __gls_capture_glColor3fv,
        __gls_capture_glColor3i,
        __gls_capture_glColor3iv,
        __gls_capture_glColor3s,
        __gls_capture_glColor3sv,
        __gls_capture_glColor3ub,
        __gls_capture_glColor3ubv,
        __gls_capture_glColor3ui,
        __gls_capture_glColor3uiv,
        __gls_capture_glColor3us,
        __gls_capture_glColor3usv,
        __gls_capture_glColor4b,
        __gls_capture_glColor4bv,
        __gls_capture_glColor4d,
        __gls_capture_glColor4dv,
        __gls_capture_glColor4f,
        __gls_capture_glColor4fv,
        __gls_capture_glColor4i,
        __gls_capture_glColor4iv,
        __gls_capture_glColor4s,
        __gls_capture_glColor4sv,
        __gls_capture_glColor4ub,
        __gls_capture_glColor4ubv,
        __gls_capture_glColor4ui,
        __gls_capture_glColor4uiv,
        __gls_capture_glColor4us,
        __gls_capture_glColor4usv,
        __gls_capture_glIndexd,
        __gls_capture_glIndexdv,
        __gls_capture_glIndexf,
        __gls_capture_glIndexfv,
        __gls_capture_glIndexi,
        __gls_capture_glIndexiv,
        __gls_capture_glIndexs,
        __gls_capture_glIndexsv,
    },
    {
        __gls_capture_glNormal3b,
        __gls_capture_glNormal3bv,
        __gls_capture_glNormal3d,
        __gls_capture_glNormal3dv,
        __gls_capture_glNormal3f,
        __gls_capture_glNormal3fv,
        __gls_capture_glNormal3i,
        __gls_capture_glNormal3iv,
        __gls_capture_glNormal3s,
        __gls_capture_glNormal3sv,
    },
    {
        __gls_capture_glTexCoord1d,
        __gls_capture_glTexCoord1dv,
        __gls_capture_glTexCoord1f,
        __gls_capture_glTexCoord1fv,
        __gls_capture_glTexCoord1i,
        __gls_capture_glTexCoord1iv,
        __gls_capture_glTexCoord1s,
        __gls_capture_glTexCoord1sv,
        __gls_capture_glTexCoord2d,
        __gls_capture_glTexCoord2dv,
        __gls_capture_glTexCoord2f,
        __gls_capture_glTexCoord2fv,
        __gls_capture_glTexCoord2i,
        __gls_capture_glTexCoord2iv,
        __gls_capture_glTexCoord2s,
        __gls_capture_glTexCoord2sv,
        __gls_capture_glTexCoord3d,
        __gls_capture_glTexCoord3dv,
        __gls_capture_glTexCoord3f,
        __gls_capture_glTexCoord3fv,
        __gls_capture_glTexCoord3i,
        __gls_capture_glTexCoord3iv,
        __gls_capture_glTexCoord3s,
        __gls_capture_glTexCoord3sv,
        __gls_capture_glTexCoord4d,
        __gls_capture_glTexCoord4dv,
        __gls_capture_glTexCoord4f,
        __gls_capture_glTexCoord4fv,
        __gls_capture_glTexCoord4i,
        __gls_capture_glTexCoord4iv,
        __gls_capture_glTexCoord4s,
        __gls_capture_glTexCoord4sv,
    },
    {
        __gls_capture_glRasterPos2d,
        __gls_capture_glRasterPos2dv,
        __gls_capture_glRasterPos2f,
        __gls_capture_glRasterPos2fv,
        __gls_capture_glRasterPos2i,
        __gls_capture_glRasterPos2iv,
        __gls_capture_glRasterPos2s,
        __gls_capture_glRasterPos2sv,
        __gls_capture_glRasterPos3d,
        __gls_capture_glRasterPos3dv,
        __gls_capture_glRasterPos3f,
        __gls_capture_glRasterPos3fv,
        __gls_capture_glRasterPos3i,
        __gls_capture_glRasterPos3iv,
        __gls_capture_glRasterPos3s,
        __gls_capture_glRasterPos3sv,
        __gls_capture_glRasterPos4d,
        __gls_capture_glRasterPos4dv,
        __gls_capture_glRasterPos4f,
        __gls_capture_glRasterPos4fv,
        __gls_capture_glRasterPos4i,
        __gls_capture_glRasterPos4iv,
        __gls_capture_glRasterPos4s,
        __gls_capture_glRasterPos4sv,
    },
    {
        __gls_capture_glRectd,
        __gls_capture_glRectdv,
        __gls_capture_glRectf,
        __gls_capture_glRectfv,
        __gls_capture_glRecti,
        __gls_capture_glRectiv,
        __gls_capture_glRects,
        __gls_capture_glRectsv,
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_exec.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void __gls_exec_glsAppRef(GLulong inAddress, GLuint inCount) {}

void __gls_exec_glsBeginObj(const GLubyte *inTag) {}

void __gls_exec_glsCharubz(const GLubyte *inTag, const GLubyte *inString) {}

void __gls_exec_glsComment(const GLubyte *inComment) {}

void __gls_exec_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec) {}

void __gls_exec_glsEndObj(void) {}

void __gls_exec_glsNumb(const GLubyte *inTag, GLbyte inVal) {}

void __gls_exec_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec) {}

void __gls_exec_glsNumd(const GLubyte *inTag, GLdouble inVal) {}

void __gls_exec_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec) {}

void __gls_exec_glsNumf(const GLubyte *inTag, GLfloat inVal) {}

void __gls_exec_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec) {}

void __gls_exec_glsNumi(const GLubyte *inTag, GLint inVal) {}

void __gls_exec_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec) {}

void __gls_exec_glsNuml(const GLubyte *inTag, GLlong inVal) {}

void __gls_exec_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec) {}

void __gls_exec_glsNums(const GLubyte *inTag, GLshort inVal) {}

void __gls_exec_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec) {}

void __gls_exec_glsNumub(const GLubyte *inTag, GLubyte inVal) {}

void __gls_exec_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec) {}

void __gls_exec_glsNumui(const GLubyte *inTag, GLuint inVal) {}

void __gls_exec_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec) {}

void __gls_exec_glsNumul(const GLubyte *inTag, GLulong inVal) {}

void __gls_exec_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec) {}

void __gls_exec_glsNumus(const GLubyte *inTag, GLushort inVal) {}

void __gls_exec_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec) {}

void __gls_exec_glsPad(void) {}

void __gls_exec_glsSwapBuffers(GLuint inLayer) {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_glstub.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void glNewList(GLuint list, GLenum mode) {
    fprintf(stderr, "stub_glNewList\n");
}

void glEndList(void) {
    fprintf(stderr, "stub_glEndList\n");
}

void glCallList(GLuint list) {
    fprintf(stderr, "stub_glCallList\n");
}

void glCallLists(GLsizei n, GLenum type, const GLvoid *lists) {
    fprintf(stderr, "stub_glCallLists\n");
}

void glDeleteLists(GLuint list, GLsizei range) {
    fprintf(stderr, "stub_glDeleteLists\n");
}

GLuint glGenLists(GLsizei range) {
    fprintf(stderr, "stub_glGenLists\n");
    return 0;
}

void glListBase(GLuint base) {
    fprintf(stderr, "stub_glListBase\n");
}

void glBegin(GLenum mode) {
    fprintf(stderr, "stub_glBegin\n");
}

void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap) {
    fprintf(stderr, "stub_glBitmap\n");
}

void glColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    fprintf(stderr, "stub_glColor3b\n");
}

void glColor3bv(const GLbyte *v) {
    fprintf(stderr, "stub_glColor3bv\n");
}

void glColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    fprintf(stderr, "stub_glColor3d\n");
}

void glColor3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glColor3dv\n");
}

void glColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    fprintf(stderr, "stub_glColor3f\n");
}

void glColor3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glColor3fv\n");
}

void glColor3i(GLint red, GLint green, GLint blue) {
    fprintf(stderr, "stub_glColor3i\n");
}

void glColor3iv(const GLint *v) {
    fprintf(stderr, "stub_glColor3iv\n");
}

void glColor3s(GLshort red, GLshort green, GLshort blue) {
    fprintf(stderr, "stub_glColor3s\n");
}

void glColor3sv(const GLshort *v) {
    fprintf(stderr, "stub_glColor3sv\n");
}

void glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    fprintf(stderr, "stub_glColor3ub\n");
}

void glColor3ubv(const GLubyte *v) {
    fprintf(stderr, "stub_glColor3ubv\n");
}

void glColor3ui(GLuint red, GLuint green, GLuint blue) {
    fprintf(stderr, "stub_glColor3ui\n");
}

void glColor3uiv(const GLuint *v) {
    fprintf(stderr, "stub_glColor3uiv\n");
}

void glColor3us(GLushort red, GLushort green, GLushort blue) {
    fprintf(stderr, "stub_glColor3us\n");
}

void glColor3usv(const GLushort *v) {
    fprintf(stderr, "stub_glColor3usv\n");
}

void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
    fprintf(stderr, "stub_glColor4b\n");
}

void glColor4bv(const GLbyte *v) {
    fprintf(stderr, "stub_glColor4bv\n");
}

void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
    fprintf(stderr, "stub_glColor4d\n");
}

void glColor4dv(const GLdouble *v) {
    fprintf(stderr, "stub_glColor4dv\n");
}

void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    fprintf(stderr, "stub_glColor4f\n");
}

void glColor4fv(const GLfloat *v) {
    fprintf(stderr, "stub_glColor4fv\n");
}

void glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {
    fprintf(stderr, "stub_glColor4i\n");
}

void glColor4iv(const GLint *v) {
    fprintf(stderr, "stub_glColor4iv\n");
}

void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
    fprintf(stderr, "stub_glColor4s\n");
}

void glColor4sv(const GLshort *v) {
    fprintf(stderr, "stub_glColor4sv\n");
}

void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
    fprintf(stderr, "stub_glColor4ub\n");
}

void glColor4ubv(const GLubyte *v) {
    fprintf(stderr, "stub_glColor4ubv\n");
}

void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    fprintf(stderr, "stub_glColor4ui\n");
}

void glColor4uiv(const GLuint *v) {
    fprintf(stderr, "stub_glColor4uiv\n");
}

void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
    fprintf(stderr, "stub_glColor4us\n");
}

void glColor4usv(const GLushort *v) {
    fprintf(stderr, "stub_glColor4usv\n");
}

void glEdgeFlag(GLboolean flag) {
    fprintf(stderr, "stub_glEdgeFlag\n");
}

void glEdgeFlagv(const GLboolean *flag) {
    fprintf(stderr, "stub_glEdgeFlagv\n");
}

void glEnd(void) {
    fprintf(stderr, "stub_glEnd\n");
}

void glIndexd(GLdouble c) {
    fprintf(stderr, "stub_glIndexd\n");
}

void glIndexdv(const GLdouble *c) {
    fprintf(stderr, "stub_glIndexdv\n");
}

void glIndexf(GLfloat c) {
    fprintf(stderr, "stub_glIndexf\n");
}

void glIndexfv(const GLfloat *c) {
    fprintf(stderr, "stub_glIndexfv\n");
}

void glIndexi(GLint c) {
    fprintf(stderr, "stub_glIndexi\n");
}

void glIndexiv(const GLint *c) {
    fprintf(stderr, "stub_glIndexiv\n");
}

void glIndexs(GLshort c) {
    fprintf(stderr, "stub_glIndexs\n");
}

void glIndexsv(const GLshort *c) {
    fprintf(stderr, "stub_glIndexsv\n");
}

void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
    fprintf(stderr, "stub_glNormal3b\n");
}

void glNormal3bv(const GLbyte *v) {
    fprintf(stderr, "stub_glNormal3bv\n");
}

void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
    fprintf(stderr, "stub_glNormal3d\n");
}

void glNormal3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glNormal3dv\n");
}

void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
    fprintf(stderr, "stub_glNormal3f\n");
}

void glNormal3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glNormal3fv\n");
}

void glNormal3i(GLint nx, GLint ny, GLint nz) {
    fprintf(stderr, "stub_glNormal3i\n");
}

void glNormal3iv(const GLint *v) {
    fprintf(stderr, "stub_glNormal3iv\n");
}

void glNormal3s(GLshort nx, GLshort ny, GLshort nz) {
    fprintf(stderr, "stub_glNormal3s\n");
}

void glNormal3sv(const GLshort *v) {
    fprintf(stderr, "stub_glNormal3sv\n");
}

void glRasterPos2d(GLdouble x, GLdouble y) {
    fprintf(stderr, "stub_glRasterPos2d\n");
}

void glRasterPos2dv(const GLdouble *v) {
    fprintf(stderr, "stub_glRasterPos2dv\n");
}

void glRasterPos2f(GLfloat x, GLfloat y) {
    fprintf(stderr, "stub_glRasterPos2f\n");
}

void glRasterPos2fv(const GLfloat *v) {
    fprintf(stderr, "stub_glRasterPos2fv\n");
}

void glRasterPos2i(GLint x, GLint y) {
    fprintf(stderr, "stub_glRasterPos2i\n");
}

void glRasterPos2iv(const GLint *v) {
    fprintf(stderr, "stub_glRasterPos2iv\n");
}

void glRasterPos2s(GLshort x, GLshort y) {
    fprintf(stderr, "stub_glRasterPos2s\n");
}

void glRasterPos2sv(const GLshort *v) {
    fprintf(stderr, "stub_glRasterPos2sv\n");
}

void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glRasterPos3d\n");
}

void glRasterPos3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glRasterPos3dv\n");
}

void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glRasterPos3f\n");
}

void glRasterPos3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glRasterPos3fv\n");
}

void glRasterPos3i(GLint x, GLint y, GLint z) {
    fprintf(stderr, "stub_glRasterPos3i\n");
}

void glRasterPos3iv(const GLint *v) {
    fprintf(stderr, "stub_glRasterPos3iv\n");
}

void glRasterPos3s(GLshort x, GLshort y, GLshort z) {
    fprintf(stderr, "stub_glRasterPos3s\n");
}

void glRasterPos3sv(const GLshort *v) {
    fprintf(stderr, "stub_glRasterPos3sv\n");
}

void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    fprintf(stderr, "stub_glRasterPos4d\n");
}

void glRasterPos4dv(const GLdouble *v) {
    fprintf(stderr, "stub_glRasterPos4dv\n");
}

void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    fprintf(stderr, "stub_glRasterPos4f\n");
}

void glRasterPos4fv(const GLfloat *v) {
    fprintf(stderr, "stub_glRasterPos4fv\n");
}

void glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {
    fprintf(stderr, "stub_glRasterPos4i\n");
}

void glRasterPos4iv(const GLint *v) {
    fprintf(stderr, "stub_glRasterPos4iv\n");
}

void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    fprintf(stderr, "stub_glRasterPos4s\n");
}

void glRasterPos4sv(const GLshort *v) {
    fprintf(stderr, "stub_glRasterPos4sv\n");
}

void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
    fprintf(stderr, "stub_glRectd\n");
}

void glRectdv(const GLdouble *v1, const GLdouble *v2) {
    fprintf(stderr, "stub_glRectdv\n");
}

void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
    fprintf(stderr, "stub_glRectf\n");
}

void glRectfv(const GLfloat *v1, const GLfloat *v2) {
    fprintf(stderr, "stub_glRectfv\n");
}

void glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {
    fprintf(stderr, "stub_glRecti\n");
}

void glRectiv(const GLint *v1, const GLint *v2) {
    fprintf(stderr, "stub_glRectiv\n");
}

void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
    fprintf(stderr, "stub_glRects\n");
}

void glRectsv(const GLshort *v1, const GLshort *v2) {
    fprintf(stderr, "stub_glRectsv\n");
}

void glTexCoord1d(GLdouble s) {
    fprintf(stderr, "stub_glTexCoord1d\n");
}

void glTexCoord1dv(const GLdouble *v) {
    fprintf(stderr, "stub_glTexCoord1dv\n");
}

void glTexCoord1f(GLfloat s) {
    fprintf(stderr, "stub_glTexCoord1f\n");
}

void glTexCoord1fv(const GLfloat *v) {
    fprintf(stderr, "stub_glTexCoord1fv\n");
}

void glTexCoord1i(GLint s) {
    fprintf(stderr, "stub_glTexCoord1i\n");
}

void glTexCoord1iv(const GLint *v) {
    fprintf(stderr, "stub_glTexCoord1iv\n");
}

void glTexCoord1s(GLshort s) {
    fprintf(stderr, "stub_glTexCoord1s\n");
}

void glTexCoord1sv(const GLshort *v) {
    fprintf(stderr, "stub_glTexCoord1sv\n");
}

void glTexCoord2d(GLdouble s, GLdouble t) {
    fprintf(stderr, "stub_glTexCoord2d\n");
}

void glTexCoord2dv(const GLdouble *v) {
    fprintf(stderr, "stub_glTexCoord2dv\n");
}

void glTexCoord2f(GLfloat s, GLfloat t) {
    fprintf(stderr, "stub_glTexCoord2f\n");
}

void glTexCoord2fv(const GLfloat *v) {
    fprintf(stderr, "stub_glTexCoord2fv\n");
}

void glTexCoord2i(GLint s, GLint t) {
    fprintf(stderr, "stub_glTexCoord2i\n");
}

void glTexCoord2iv(const GLint *v) {
    fprintf(stderr, "stub_glTexCoord2iv\n");
}

void glTexCoord2s(GLshort s, GLshort t) {
    fprintf(stderr, "stub_glTexCoord2s\n");
}

void glTexCoord2sv(const GLshort *v) {
    fprintf(stderr, "stub_glTexCoord2sv\n");
}

void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {
    fprintf(stderr, "stub_glTexCoord3d\n");
}

void glTexCoord3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glTexCoord3dv\n");
}

void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {
    fprintf(stderr, "stub_glTexCoord3f\n");
}

void glTexCoord3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glTexCoord3fv\n");
}

void glTexCoord3i(GLint s, GLint t, GLint r) {
    fprintf(stderr, "stub_glTexCoord3i\n");
}

void glTexCoord3iv(const GLint *v) {
    fprintf(stderr, "stub_glTexCoord3iv\n");
}

void glTexCoord3s(GLshort s, GLshort t, GLshort r) {
    fprintf(stderr, "stub_glTexCoord3s\n");
}

void glTexCoord3sv(const GLshort *v) {
    fprintf(stderr, "stub_glTexCoord3sv\n");
}

void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    fprintf(stderr, "stub_glTexCoord4d\n");
}

void glTexCoord4dv(const GLdouble *v) {
    fprintf(stderr, "stub_glTexCoord4dv\n");
}

void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    fprintf(stderr, "stub_glTexCoord4f\n");
}

void glTexCoord4fv(const GLfloat *v) {
    fprintf(stderr, "stub_glTexCoord4fv\n");
}

void glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {
    fprintf(stderr, "stub_glTexCoord4i\n");
}

void glTexCoord4iv(const GLint *v) {
    fprintf(stderr, "stub_glTexCoord4iv\n");
}

void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
    fprintf(stderr, "stub_glTexCoord4s\n");
}

void glTexCoord4sv(const GLshort *v) {
    fprintf(stderr, "stub_glTexCoord4sv\n");
}

void glVertex2d(GLdouble x, GLdouble y) {
    fprintf(stderr, "stub_glVertex2d\n");
}

void glVertex2dv(const GLdouble *v) {
    fprintf(stderr, "stub_glVertex2dv\n");
}

void glVertex2f(GLfloat x, GLfloat y) {
    fprintf(stderr, "stub_glVertex2f\n");
}

void glVertex2fv(const GLfloat *v) {
    fprintf(stderr, "stub_glVertex2fv\n");
}

void glVertex2i(GLint x, GLint y) {
    fprintf(stderr, "stub_glVertex2i\n");
}

void glVertex2iv(const GLint *v) {
    fprintf(stderr, "stub_glVertex2iv\n");
}

void glVertex2s(GLshort x, GLshort y) {
    fprintf(stderr, "stub_glVertex2s\n");
}

void glVertex2sv(const GLshort *v) {
    fprintf(stderr, "stub_glVertex2sv\n");
}

void glVertex3d(GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glVertex3d\n");
}

void glVertex3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glVertex3dv\n");
}

void glVertex3f(GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glVertex3f\n");
}

void glVertex3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glVertex3fv\n");
}

void glVertex3i(GLint x, GLint y, GLint z) {
    fprintf(stderr, "stub_glVertex3i\n");
}

void glVertex3iv(const GLint *v) {
    fprintf(stderr, "stub_glVertex3iv\n");
}

void glVertex3s(GLshort x, GLshort y, GLshort z) {
    fprintf(stderr, "stub_glVertex3s\n");
}

void glVertex3sv(const GLshort *v) {
    fprintf(stderr, "stub_glVertex3sv\n");
}

void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    fprintf(stderr, "stub_glVertex4d\n");
}

void glVertex4dv(const GLdouble *v) {
    fprintf(stderr, "stub_glVertex4dv\n");
}

void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    fprintf(stderr, "stub_glVertex4f\n");
}

void glVertex4fv(const GLfloat *v) {
    fprintf(stderr, "stub_glVertex4fv\n");
}

void glVertex4i(GLint x, GLint y, GLint z, GLint w) {
    fprintf(stderr, "stub_glVertex4i\n");
}

void glVertex4iv(const GLint *v) {
    fprintf(stderr, "stub_glVertex4iv\n");
}

void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    fprintf(stderr, "stub_glVertex4s\n");
}

void glVertex4sv(const GLshort *v) {
    fprintf(stderr, "stub_glVertex4sv\n");
}

void glClipPlane(GLenum plane, const GLdouble *equation) {
    fprintf(stderr, "stub_glClipPlane\n");
}

void glColorMaterial(GLenum face, GLenum mode) {
    fprintf(stderr, "stub_glColorMaterial\n");
}

void glCullFace(GLenum mode) {
    fprintf(stderr, "stub_glCullFace\n");
}

void glFogf(GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glFogf\n");
}

void glFogfv(GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glFogfv\n");
}

void glFogi(GLenum pname, GLint param) {
    fprintf(stderr, "stub_glFogi\n");
}

void glFogiv(GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glFogiv\n");
}

void glFrontFace(GLenum mode) {
    fprintf(stderr, "stub_glFrontFace\n");
}

void glHint(GLenum target, GLenum mode) {
    fprintf(stderr, "stub_glHint\n");
}

void glLightf(GLenum light, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glLightf\n");
}

void glLightfv(GLenum light, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glLightfv\n");
}

void glLighti(GLenum light, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glLighti\n");
}

void glLightiv(GLenum light, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glLightiv\n");
}

void glLightModelf(GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glLightModelf\n");
}

void glLightModelfv(GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glLightModelfv\n");
}

void glLightModeli(GLenum pname, GLint param) {
    fprintf(stderr, "stub_glLightModeli\n");
}

void glLightModeliv(GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glLightModeliv\n");
}

void glLineStipple(GLint factor, GLushort pattern) {
    fprintf(stderr, "stub_glLineStipple\n");
}

void glLineWidth(GLfloat width) {
    fprintf(stderr, "stub_glLineWidth\n");
}

void glMaterialf(GLenum face, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glMaterialf\n");
}

void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glMaterialfv\n");
}

void glMateriali(GLenum face, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glMateriali\n");
}

void glMaterialiv(GLenum face, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glMaterialiv\n");
}

void glPointSize(GLfloat size) {
    fprintf(stderr, "stub_glPointSize\n");
}

void glPolygonMode(GLenum face, GLenum mode) {
    fprintf(stderr, "stub_glPolygonMode\n");
}

void glPolygonStipple(const GLubyte *mask) {
    fprintf(stderr, "stub_glPolygonStipple\n");
}

void glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glScissor\n");
}

void glShadeModel(GLenum mode) {
    fprintf(stderr, "stub_glShadeModel\n");
}

void glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glTexParameterf\n");
}

void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glTexParameterfv\n");
}

void glTexParameteri(GLenum target, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glTexParameteri\n");
}

void glTexParameteriv(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glTexParameteriv\n");
}

void glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexImage1D\n");
}

void glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexImage2D\n");
}

void glTexEnvf(GLenum target, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glTexEnvf\n");
}

void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glTexEnvfv\n");
}

void glTexEnvi(GLenum target, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glTexEnvi\n");
}

void glTexEnviv(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glTexEnviv\n");
}

void glTexGend(GLenum coord, GLenum pname, GLdouble param) {
    fprintf(stderr, "stub_glTexGend\n");
}

void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params) {
    fprintf(stderr, "stub_glTexGendv\n");
}

void glTexGenf(GLenum coord, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glTexGenf\n");
}

void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glTexGenfv\n");
}

void glTexGeni(GLenum coord, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glTexGeni\n");
}

void glTexGeniv(GLenum coord, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glTexGeniv\n");
}

void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer) {
    fprintf(stderr, "stub_glFeedbackBuffer\n");
}

void glSelectBuffer(GLsizei size, GLuint *buffer) {
    fprintf(stderr, "stub_glSelectBuffer\n");
}

GLint glRenderMode(GLenum mode) {
    fprintf(stderr, "stub_glRenderMode\n");
    return 0;
}

void glInitNames(void) {
    fprintf(stderr, "stub_glInitNames\n");
}

void glLoadName(GLuint name) {
    fprintf(stderr, "stub_glLoadName\n");
}

void glPassThrough(GLfloat token) {
    fprintf(stderr, "stub_glPassThrough\n");
}

void glPopName(void) {
    fprintf(stderr, "stub_glPopName\n");
}

void glPushName(GLuint name) {
    fprintf(stderr, "stub_glPushName\n");
}

void glDrawBuffer(GLenum mode) {
    fprintf(stderr, "stub_glDrawBuffer\n");
}

void glClear(GLbitfield mask) {
    fprintf(stderr, "stub_glClear\n");
}

void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    fprintf(stderr, "stub_glClearAccum\n");
}

void glClearIndex(GLfloat c) {
    fprintf(stderr, "stub_glClearIndex\n");
}

void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    fprintf(stderr, "stub_glClearColor\n");
}

void glClearStencil(GLint s) {
    fprintf(stderr, "stub_glClearStencil\n");
}

void glClearDepth(GLclampd depth) {
    fprintf(stderr, "stub_glClearDepth\n");
}

void glStencilMask(GLuint mask) {
    fprintf(stderr, "stub_glStencilMask\n");
}

void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    fprintf(stderr, "stub_glColorMask\n");
}

void glDepthMask(GLboolean flag) {
    fprintf(stderr, "stub_glDepthMask\n");
}

void glIndexMask(GLuint mask) {
    fprintf(stderr, "stub_glIndexMask\n");
}

void glAccum(GLenum op, GLfloat value) {
    fprintf(stderr, "stub_glAccum\n");
}

void glDisable(GLenum cap) {
    fprintf(stderr, "stub_glDisable\n");
}

void glEnable(GLenum cap) {
    fprintf(stderr, "stub_glEnable\n");
}

void glFinish(void) {
    fprintf(stderr, "stub_glFinish\n");
}

void glFlush(void) {
    fprintf(stderr, "stub_glFlush\n");
}

void glPopAttrib(void) {
    fprintf(stderr, "stub_glPopAttrib\n");
}

void glPushAttrib(GLbitfield mask) {
    fprintf(stderr, "stub_glPushAttrib\n");
}

void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points) {
    fprintf(stderr, "stub_glMap1d\n");
}

void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points) {
    fprintf(stderr, "stub_glMap1f\n");
}

void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points) {
    fprintf(stderr, "stub_glMap2d\n");
}

void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points) {
    fprintf(stderr, "stub_glMap2f\n");
}

void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
    fprintf(stderr, "stub_glMapGrid1d\n");
}

void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
    fprintf(stderr, "stub_glMapGrid1f\n");
}

void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
    fprintf(stderr, "stub_glMapGrid2d\n");
}

void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
    fprintf(stderr, "stub_glMapGrid2f\n");
}

void glEvalCoord1d(GLdouble u) {
    fprintf(stderr, "stub_glEvalCoord1d\n");
}

void glEvalCoord1dv(const GLdouble *u) {
    fprintf(stderr, "stub_glEvalCoord1dv\n");
}

void glEvalCoord1f(GLfloat u) {
    fprintf(stderr, "stub_glEvalCoord1f\n");
}

void glEvalCoord1fv(const GLfloat *u) {
    fprintf(stderr, "stub_glEvalCoord1fv\n");
}

void glEvalCoord2d(GLdouble u, GLdouble v) {
    fprintf(stderr, "stub_glEvalCoord2d\n");
}

void glEvalCoord2dv(const GLdouble *u) {
    fprintf(stderr, "stub_glEvalCoord2dv\n");
}

void glEvalCoord2f(GLfloat u, GLfloat v) {
    fprintf(stderr, "stub_glEvalCoord2f\n");
}

void glEvalCoord2fv(const GLfloat *u) {
    fprintf(stderr, "stub_glEvalCoord2fv\n");
}

void glEvalMesh1(GLenum mode, GLint i1, GLint i2) {
    fprintf(stderr, "stub_glEvalMesh1\n");
}

void glEvalPoint1(GLint i) {
    fprintf(stderr, "stub_glEvalPoint1\n");
}

void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {
    fprintf(stderr, "stub_glEvalMesh2\n");
}

void glEvalPoint2(GLint i, GLint j) {
    fprintf(stderr, "stub_glEvalPoint2\n");
}

void glAlphaFunc(GLenum func, GLclampf ref) {
    fprintf(stderr, "stub_glAlphaFunc\n");
}

void glBlendFunc(GLenum sfactor, GLenum dfactor) {
    fprintf(stderr, "stub_glBlendFunc\n");
}

void glLogicOp(GLenum opcode) {
    fprintf(stderr, "stub_glLogicOp\n");
}

void glStencilFunc(GLenum func, GLint ref, GLuint mask) {
    fprintf(stderr, "stub_glStencilFunc\n");
}

void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
    fprintf(stderr, "stub_glStencilOp\n");
}

void glDepthFunc(GLenum func) {
    fprintf(stderr, "stub_glDepthFunc\n");
}

void glPixelZoom(GLfloat xfactor, GLfloat yfactor) {
    fprintf(stderr, "stub_glPixelZoom\n");
}

void glPixelTransferf(GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glPixelTransferf\n");
}

void glPixelTransferi(GLenum pname, GLint param) {
    fprintf(stderr, "stub_glPixelTransferi\n");
}

void glPixelStoref(GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glPixelStoref\n");
}

void glPixelStorei(GLenum pname, GLint param) {
    fprintf(stderr, "stub_glPixelStorei\n");
}

void glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values) {
    fprintf(stderr, "stub_glPixelMapfv\n");
}

void glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values) {
    fprintf(stderr, "stub_glPixelMapuiv\n");
}

void glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values) {
    fprintf(stderr, "stub_glPixelMapusv\n");
}

void glReadBuffer(GLenum mode) {
    fprintf(stderr, "stub_glReadBuffer\n");
}

void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {
    fprintf(stderr, "stub_glCopyPixels\n");
}

void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {
    fprintf(stderr, "stub_glReadPixels\n");
}

void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glDrawPixels\n");
}

void glGetBooleanv(GLenum pname, GLboolean *params) {
    fprintf(stderr, "stub_glGetBooleanv\n");
}

void glGetClipPlane(GLenum plane, GLdouble *equation) {
    fprintf(stderr, "stub_glGetClipPlane\n");
}

void glGetDoublev(GLenum pname, GLdouble *params) {
    fprintf(stderr, "stub_glGetDoublev\n");
}

GLenum glGetError(void) {
    fprintf(stderr, "stub_glGetError\n");
    return 0;
}

void glGetFloatv(GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetFloatv\n");
}

void glGetIntegerv(GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetIntegerv\n");
}

void glGetLightfv(GLenum light, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetLightfv\n");
}

void glGetLightiv(GLenum light, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetLightiv\n");
}

void glGetMapdv(GLenum target, GLenum query, GLdouble *v) {
    fprintf(stderr, "stub_glGetMapdv\n");
}

void glGetMapfv(GLenum target, GLenum query, GLfloat *v) {
    fprintf(stderr, "stub_glGetMapfv\n");
}

void glGetMapiv(GLenum target, GLenum query, GLint *v) {
    fprintf(stderr, "stub_glGetMapiv\n");
}

void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetMaterialfv\n");
}

void glGetMaterialiv(GLenum face, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetMaterialiv\n");
}

void glGetPixelMapfv(GLenum map, GLfloat *values) {
    fprintf(stderr, "stub_glGetPixelMapfv\n");
}

void glGetPixelMapuiv(GLenum map, GLuint *values) {
    fprintf(stderr, "stub_glGetPixelMapuiv\n");
}

void glGetPixelMapusv(GLenum map, GLushort *values) {
    fprintf(stderr, "stub_glGetPixelMapusv\n");
}

void glGetPolygonStipple(GLubyte *mask) {
    fprintf(stderr, "stub_glGetPolygonStipple\n");
}

const GLubyte * glGetString(GLenum name) {
    fprintf(stderr, "stub_glGetString\n");
    return 0;
}

void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexEnvfv\n");
}

void glGetTexEnviv(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexEnviv\n");
}

void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params) {
    fprintf(stderr, "stub_glGetTexGendv\n");
}

void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexGenfv\n");
}

void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexGeniv\n");
}

void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels) {
    fprintf(stderr, "stub_glGetTexImage\n");
}

void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexParameterfv\n");
}

void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexParameteriv\n");
}

void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexLevelParameterfv\n");
}

void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexLevelParameteriv\n");
}

GLboolean glIsEnabled(GLenum cap) {
    fprintf(stderr, "stub_glIsEnabled\n");
    return 0;
}

GLboolean glIsList(GLuint list) {
    fprintf(stderr, "stub_glIsList\n");
    return 0;
}

void glDepthRange(GLclampd zNear, GLclampd zFar) {
    fprintf(stderr, "stub_glDepthRange\n");
}

void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    fprintf(stderr, "stub_glFrustum\n");
}

void glLoadIdentity(void) {
    fprintf(stderr, "stub_glLoadIdentity\n");
}

void glLoadMatrixf(const GLfloat *m) {
    fprintf(stderr, "stub_glLoadMatrixf\n");
}

void glLoadMatrixd(const GLdouble *m) {
    fprintf(stderr, "stub_glLoadMatrixd\n");
}

void glMatrixMode(GLenum mode) {
    fprintf(stderr, "stub_glMatrixMode\n");
}

void glMultMatrixf(const GLfloat *m) {
    fprintf(stderr, "stub_glMultMatrixf\n");
}

void glMultMatrixd(const GLdouble *m) {
    fprintf(stderr, "stub_glMultMatrixd\n");
}

void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    fprintf(stderr, "stub_glOrtho\n");
}

void glPopMatrix(void) {
    fprintf(stderr, "stub_glPopMatrix\n");
}

void glPushMatrix(void) {
    fprintf(stderr, "stub_glPushMatrix\n");
}

void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glRotated\n");
}

void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glRotatef\n");
}

void glScaled(GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glScaled\n");
}

void glScalef(GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glScalef\n");
}

void glTranslated(GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glTranslated\n");
}

void glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glTranslatef\n");
}

void glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glViewport\n");
}

void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    fprintf(stderr, "stub_glBlendColorEXT\n");
}

void glBlendEquationEXT(GLenum mode) {
    fprintf(stderr, "stub_glBlendEquationEXT\n");
}

void glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {
    fprintf(stderr, "stub_glPolygonOffsetEXT\n");
}

void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexSubImage1DEXT\n");
}

void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexSubImage2DEXT\n");
}

void glSampleMaskSGIS(GLclampf value, GLboolean invert) {
    fprintf(stderr, "stub_glSampleMaskSGIS\n");
}

void glSamplePatternSGIS(GLenum pattern) {
    fprintf(stderr, "stub_glSamplePatternSGIS\n");
}

void glTagSampleBufferSGIX(void) {
    fprintf(stderr, "stub_glTagSampleBufferSGIX\n");
}

void glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image) {
    fprintf(stderr, "stub_glConvolutionFilter1DEXT\n");
}

void glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image) {
    fprintf(stderr, "stub_glConvolutionFilter2DEXT\n");
}

void glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {
    fprintf(stderr, "stub_glConvolutionParameterfEXT\n");
}

void glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glConvolutionParameterfvEXT\n");
}

void glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {
    fprintf(stderr, "stub_glConvolutionParameteriEXT\n");
}

void glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glConvolutionParameterivEXT\n");
}

void glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    fprintf(stderr, "stub_glCopyConvolutionFilter1DEXT\n");
}

void glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glCopyConvolutionFilter2DEXT\n");
}

void glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image) {
    fprintf(stderr, "stub_glGetConvolutionFilterEXT\n");
}

void glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetConvolutionParameterfvEXT\n");
}

void glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetConvolutionParameterivEXT\n");
}

void glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span) {
    fprintf(stderr, "stub_glGetSeparableFilterEXT\n");
}

void glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column) {
    fprintf(stderr, "stub_glSeparableFilter2DEXT\n");
}

void glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
    fprintf(stderr, "stub_glGetHistogramEXT\n");
}

void glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetHistogramParameterfvEXT\n");
}

void glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetHistogramParameterivEXT\n");
}

void glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
    fprintf(stderr, "stub_glGetMinmaxEXT\n");
}

void glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetMinmaxParameterfvEXT\n");
}

void glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetMinmaxParameterivEXT\n");
}

void glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    fprintf(stderr, "stub_glHistogramEXT\n");
}

void glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {
    fprintf(stderr, "stub_glMinmaxEXT\n");
}

void glResetHistogramEXT(GLenum target) {
    fprintf(stderr, "stub_glResetHistogramEXT\n");
}

void glResetMinmaxEXT(GLenum target) {
    fprintf(stderr, "stub_glResetMinmaxEXT\n");
}

void glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexImage3DEXT\n");
}

void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexSubImage3DEXT\n");
}

void glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
    fprintf(stderr, "stub_glDetailTexFuncSGIS\n");
}

void glGetDetailTexFuncSGIS(GLenum target, GLfloat *points) {
    fprintf(stderr, "stub_glGetDetailTexFuncSGIS\n");
}

void glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
    fprintf(stderr, "stub_glSharpenTexFuncSGIS\n");
}

void glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points) {
    fprintf(stderr, "stub_glGetSharpenTexFuncSGIS\n");
}

void glArrayElementEXT(GLint i) {
    fprintf(stderr, "stub_glArrayElementEXT\n");
}

void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glColorPointerEXT\n");
}

void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {
    fprintf(stderr, "stub_glDrawArraysEXT\n");
}

void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer) {
    fprintf(stderr, "stub_glEdgeFlagPointerEXT\n");
}

void glGetPointervEXT(GLenum pname, GLvoid* *params) {
    fprintf(stderr, "stub_glGetPointervEXT\n");
}

void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glIndexPointerEXT\n");
}

void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glNormalPointerEXT\n");
}

void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glTexCoordPointerEXT\n");
}

void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glVertexPointerEXT\n");
}

GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences) {
    fprintf(stderr, "stub_glAreTexturesResidentEXT\n");
    return 0;
}

void glBindTextureEXT(GLenum target, GLuint texture) {
    fprintf(stderr, "stub_glBindTextureEXT\n");
}

void glDeleteTexturesEXT(GLsizei n, const GLuint *textures) {
    fprintf(stderr, "stub_glDeleteTexturesEXT\n");
}

void glGenTexturesEXT(GLsizei n, GLuint *textures) {
    fprintf(stderr, "stub_glGenTexturesEXT\n");
}

GLboolean glIsTextureEXT(GLuint texture) {
    fprintf(stderr, "stub_glIsTextureEXT\n");
    return 0;
}

void glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
    fprintf(stderr, "stub_glPrioritizeTexturesEXT\n");
}

void glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table) {
    fprintf(stderr, "stub_glColorTableSGI\n");
}

void glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glColorTableParameterfvSGI\n");
}

void glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glColorTableParameterivSGI\n");
}

void glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    fprintf(stderr, "stub_glCopyColorTableSGI\n");
}

void glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table) {
    fprintf(stderr, "stub_glGetColorTableSGI\n");
}

void glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetColorTableParameterfvSGI\n");
}

void glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetColorTableParameterivSGI\n");
}

void glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexColorTableParameterfvSGI\n");
}

void glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexColorTableParameterivSGI\n");
}

void glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glTexColorTableParameterfvSGI\n");
}

void glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glTexColorTableParameterivSGI\n");
}

void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    fprintf(stderr, "stub_glCopyTexImage1DEXT\n");
}

void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    fprintf(stderr, "stub_glCopyTexImage2DEXT\n");
}

void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    fprintf(stderr, "stub_glCopyTexSubImage1DEXT\n");
}

void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glCopyTexSubImage2DEXT\n");
}

void glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glCopyTexSubImage3DEXT\n");
}

void glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexImage4DSGIS\n");
}

void glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexSubImage4DSGIS\n");
}

void glPixelTexGenSGIX(GLenum mode) {
    fprintf(stderr, "stub_glPixelTexGenSGIX\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_win32.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void __gls_null_glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor) {}
void __gls_null_glsBlock(GLSenum inBlockType) {}
GLSenum __gls_null_glsCallStream(const GLubyte *inName) {return 0;}
void __gls_null_glsEndGLS(void) {}
void __gls_null_glsError(GLSopcode inOpcode, GLSenum inError) {}
void __gls_null_glsGLRC(GLuint inGLRC) {}
void __gls_null_glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer) {}
void __gls_null_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal) {}
void __gls_null_glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal) {}
void __gls_null_glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal) {}
void __gls_null_glsHeaderf(GLSenum inAttrib, GLfloat inVal) {}
void __gls_null_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec) {}
void __gls_null_glsHeaderi(GLSenum inAttrib, GLint inVal) {}
void __gls_null_glsHeaderiv(GLSenum inAttrib, const GLint *inVec) {}
void __gls_null_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString) {}
void __gls_null_glsRequireExtension(const GLubyte *inExtension) {}
void __gls_null_glsUnsupportedCommand(void) {}
void __gls_null_glsAppRef(GLulong inAddress, GLuint inCount) {}
void __gls_null_glsBeginObj(const GLubyte *inTag) {}
void __gls_null_glsCharubz(const GLubyte *inTag, const GLubyte *inString) {}
void __gls_null_glsComment(const GLubyte *inComment) {}
void __gls_null_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec) {}
void __gls_null_glsEndObj(void) {}
void __gls_null_glsNumb(const GLubyte *inTag, GLbyte inVal) {}
void __gls_null_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec) {}
void __gls_null_glsNumd(const GLubyte *inTag, GLdouble inVal) {}
void __gls_null_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec) {}
void __gls_null_glsNumf(const GLubyte *inTag, GLfloat inVal) {}
void __gls_null_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec) {}
void __gls_null_glsNumi(const GLubyte *inTag, GLint inVal) {}
void __gls_null_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec) {}
void __gls_null_glsNuml(const GLubyte *inTag, GLlong inVal) {}
void __gls_null_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec) {}
void __gls_null_glsNums(const GLubyte *inTag, GLshort inVal) {}
void __gls_null_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec) {}
void __gls_null_glsNumub(const GLubyte *inTag, GLubyte inVal) {}
void __gls_null_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec) {}
void __gls_null_glsNumui(const GLubyte *inTag, GLuint inVal) {}
void __gls_null_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec) {}
void __gls_null_glsNumul(const GLubyte *inTag, GLulong inVal) {}
void __gls_null_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec) {}
void __gls_null_glsNumus(const GLubyte *inTag, GLushort inVal) {}
void __gls_null_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec) {}
void __gls_null_glsPad(void) {}
void __gls_null_glsSwapBuffers(GLuint inLayer) {}
void __gls_null_glNewList(GLuint list, GLenum mode) {}
void __gls_null_glEndList(void) {}
void __gls_null_glCallList(GLuint list) {}
void __gls_null_glCallLists(GLsizei n, GLenum type, const GLvoid *lists) {}
void __gls_null_glDeleteLists(GLuint list, GLsizei range) {}
GLuint __gls_null_glGenLists(GLsizei range) {return 0;}
void __gls_null_glListBase(GLuint base) {}
void __gls_null_glBegin(GLenum mode) {}
void __gls_null_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap) {}
void __gls_null_glColor3b(GLbyte red, GLbyte green, GLbyte blue) {}
void __gls_null_glColor3bv(const GLbyte *v) {}
void __gls_null_glColor3d(GLdouble red, GLdouble green, GLdouble blue) {}
void __gls_null_glColor3dv(const GLdouble *v) {}
void __gls_null_glColor3f(GLfloat red, GLfloat green, GLfloat blue) {}
void __gls_null_glColor3fv(const GLfloat *v) {}
void __gls_null_glColor3i(GLint red, GLint green, GLint blue) {}
void __gls_null_glColor3iv(const GLint *v) {}
void __gls_null_glColor3s(GLshort red, GLshort green, GLshort blue) {}
void __gls_null_glColor3sv(const GLshort *v) {}
void __gls_null_glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {}
void __gls_null_glColor3ubv(const GLubyte *v) {}
void __gls_null_glColor3ui(GLuint red, GLuint green, GLuint blue) {}
void __gls_null_glColor3uiv(const GLuint *v) {}
void __gls_null_glColor3us(GLushort red, GLushort green, GLushort blue) {}
void __gls_null_glColor3usv(const GLushort *v) {}
void __gls_null_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {}
void __gls_null_glColor4bv(const GLbyte *v) {}
void __gls_null_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {}
void __gls_null_glColor4dv(const GLdouble *v) {}
void __gls_null_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {}
void __gls_null_glColor4fv(const GLfloat *v) {}
void __gls_null_glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {}
void __gls_null_glColor4iv(const GLint *v) {}
void __gls_null_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {}
void __gls_null_glColor4sv(const GLshort *v) {}
void __gls_null_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {}
void __gls_null_glColor4ubv(const GLubyte *v) {}
void __gls_null_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {}
void __gls_null_glColor4uiv(const GLuint *v) {}
void __gls_null_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {}
void __gls_null_glColor4usv(const GLushort *v) {}
void __gls_null_glEdgeFlag(GLboolean flag) {}
void __gls_null_glEdgeFlagv(const GLboolean *flag) {}
void __gls_null_glEnd(void) {}
void __gls_null_glIndexd(GLdouble c) {}
void __gls_null_glIndexdv(const GLdouble *c) {}
void __gls_null_glIndexf(GLfloat c) {}
void __gls_null_glIndexfv(const GLfloat *c) {}
void __gls_null_glIndexi(GLint c) {}
void __gls_null_glIndexiv(const GLint *c) {}
void __gls_null_glIndexs(GLshort c) {}
void __gls_null_glIndexsv(const GLshort *c) {}
void __gls_null_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {}
void __gls_null_glNormal3bv(const GLbyte *v) {}
void __gls_null_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {}
void __gls_null_glNormal3dv(const GLdouble *v) {}
void __gls_null_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {}
void __gls_null_glNormal3fv(const GLfloat *v) {}
void __gls_null_glNormal3i(GLint nx, GLint ny, GLint nz) {}
void __gls_null_glNormal3iv(const GLint *v) {}
void __gls_null_glNormal3s(GLshort nx, GLshort ny, GLshort nz) {}
void __gls_null_glNormal3sv(const GLshort *v) {}
void __gls_null_glRasterPos2d(GLdouble x, GLdouble y) {}
void __gls_null_glRasterPos2dv(const GLdouble *v) {}
void __gls_null_glRasterPos2f(GLfloat x, GLfloat y) {}
void __gls_null_glRasterPos2fv(const GLfloat *v) {}
void __gls_null_glRasterPos2i(GLint x, GLint y) {}
void __gls_null_glRasterPos2iv(const GLint *v) {}
void __gls_null_glRasterPos2s(GLshort x, GLshort y) {}
void __gls_null_glRasterPos2sv(const GLshort *v) {}
void __gls_null_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glRasterPos3dv(const GLdouble *v) {}
void __gls_null_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glRasterPos3fv(const GLfloat *v) {}
void __gls_null_glRasterPos3i(GLint x, GLint y, GLint z) {}
void __gls_null_glRasterPos3iv(const GLint *v) {}
void __gls_null_glRasterPos3s(GLshort x, GLshort y, GLshort z) {}
void __gls_null_glRasterPos3sv(const GLshort *v) {}
void __gls_null_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {}
void __gls_null_glRasterPos4dv(const GLdouble *v) {}
void __gls_null_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {}
void __gls_null_glRasterPos4fv(const GLfloat *v) {}
void __gls_null_glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {}
void __gls_null_glRasterPos4iv(const GLint *v) {}
void __gls_null_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {}
void __gls_null_glRasterPos4sv(const GLshort *v) {}
void __gls_null_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {}
void __gls_null_glRectdv(const GLdouble *v1, const GLdouble *v2) {}
void __gls_null_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {}
void __gls_null_glRectfv(const GLfloat *v1, const GLfloat *v2) {}
void __gls_null_glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {}
void __gls_null_glRectiv(const GLint *v1, const GLint *v2) {}
void __gls_null_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {}
void __gls_null_glRectsv(const GLshort *v1, const GLshort *v2) {}
void __gls_null_glTexCoord1d(GLdouble s) {}
void __gls_null_glTexCoord1dv(const GLdouble *v) {}
void __gls_null_glTexCoord1f(GLfloat s) {}
void __gls_null_glTexCoord1fv(const GLfloat *v) {}
void __gls_null_glTexCoord1i(GLint s) {}
void __gls_null_glTexCoord1iv(const GLint *v) {}
void __gls_null_glTexCoord1s(GLshort s) {}
void __gls_null_glTexCoord1sv(const GLshort *v) {}
void __gls_null_glTexCoord2d(GLdouble s, GLdouble t) {}
void __gls_null_glTexCoord2dv(const GLdouble *v) {}
void __gls_null_glTexCoord2f(GLfloat s, GLfloat t) {}
void __gls_null_glTexCoord2fv(const GLfloat *v) {}
void __gls_null_glTexCoord2i(GLint s, GLint t) {}
void __gls_null_glTexCoord2iv(const GLint *v) {}
void __gls_null_glTexCoord2s(GLshort s, GLshort t) {}
void __gls_null_glTexCoord2sv(const GLshort *v) {}
void __gls_null_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {}
void __gls_null_glTexCoord3dv(const GLdouble *v) {}
void __gls_null_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {}
void __gls_null_glTexCoord3fv(const GLfloat *v) {}
void __gls_null_glTexCoord3i(GLint s, GLint t, GLint r) {}
void __gls_null_glTexCoord3iv(const GLint *v) {}
void __gls_null_glTexCoord3s(GLshort s, GLshort t, GLshort r) {}
void __gls_null_glTexCoord3sv(const GLshort *v) {}
void __gls_null_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {}
void __gls_null_glTexCoord4dv(const GLdouble *v) {}
void __gls_null_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {}
void __gls_null_glTexCoord4fv(const GLfloat *v) {}
void __gls_null_glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {}
void __gls_null_glTexCoord4iv(const GLint *v) {}
void __gls_null_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {}
void __gls_null_glTexCoord4sv(const GLshort *v) {}
void __gls_null_glVertex2d(GLdouble x, GLdouble y) {}
void __gls_null_glVertex2dv(const GLdouble *v) {}
void __gls_null_glVertex2f(GLfloat x, GLfloat y) {}
void __gls_null_glVertex2fv(const GLfloat *v) {}
void __gls_null_glVertex2i(GLint x, GLint y) {}
void __gls_null_glVertex2iv(const GLint *v) {}
void __gls_null_glVertex2s(GLshort x, GLshort y) {}
void __gls_null_glVertex2sv(const GLshort *v) {}
void __gls_null_glVertex3d(GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glVertex3dv(const GLdouble *v) {}
void __gls_null_glVertex3f(GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glVertex3fv(const GLfloat *v) {}
void __gls_null_glVertex3i(GLint x, GLint y, GLint z) {}
void __gls_null_glVertex3iv(const GLint *v) {}
void __gls_null_glVertex3s(GLshort x, GLshort y, GLshort z) {}
void __gls_null_glVertex3sv(const GLshort *v) {}
void __gls_null_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {}
void __gls_null_glVertex4dv(const GLdouble *v) {}
void __gls_null_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {}
void __gls_null_glVertex4fv(const GLfloat *v) {}
void __gls_null_glVertex4i(GLint x, GLint y, GLint z, GLint w) {}
void __gls_null_glVertex4iv(const GLint *v) {}
void __gls_null_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {}
void __gls_null_glVertex4sv(const GLshort *v) {}
void __gls_null_glClipPlane(GLenum plane, const GLdouble *equation) {}
void __gls_null_glColorMaterial(GLenum face, GLenum mode) {}
void __gls_null_glCullFace(GLenum mode) {}
void __gls_null_glFogf(GLenum pname, GLfloat param) {}
void __gls_null_glFogfv(GLenum pname, const GLfloat *params) {}
void __gls_null_glFogi(GLenum pname, GLint param) {}
void __gls_null_glFogiv(GLenum pname, const GLint *params) {}
void __gls_null_glFrontFace(GLenum mode) {}
void __gls_null_glHint(GLenum target, GLenum mode) {}
void __gls_null_glLightf(GLenum light, GLenum pname, GLfloat param) {}
void __gls_null_glLightfv(GLenum light, GLenum pname, const GLfloat *params) {}
void __gls_null_glLighti(GLenum light, GLenum pname, GLint param) {}
void __gls_null_glLightiv(GLenum light, GLenum pname, const GLint *params) {}
void __gls_null_glLightModelf(GLenum pname, GLfloat param) {}
void __gls_null_glLightModelfv(GLenum pname, const GLfloat *params) {}
void __gls_null_glLightModeli(GLenum pname, GLint param) {}
void __gls_null_glLightModeliv(GLenum pname, const GLint *params) {}
void __gls_null_glLineStipple(GLint factor, GLushort pattern) {}
void __gls_null_glLineWidth(GLfloat width) {}
void __gls_null_glMaterialf(GLenum face, GLenum pname, GLfloat param) {}
void __gls_null_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params) {}
void __gls_null_glMateriali(GLenum face, GLenum pname, GLint param) {}
void __gls_null_glMaterialiv(GLenum face, GLenum pname, const GLint *params) {}
void __gls_null_glPointSize(GLfloat size) {}
void __gls_null_glPolygonMode(GLenum face, GLenum mode) {}
void __gls_null_glPolygonStipple(const GLubyte *mask) {}
void __gls_null_glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {}
void __gls_null_glShadeModel(GLenum mode) {}
void __gls_null_glTexParameterf(GLenum target, GLenum pname, GLfloat param) {}
void __gls_null_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {}
void __gls_null_glTexParameteri(GLenum target, GLenum pname, GLint param) {}
void __gls_null_glTexParameteriv(GLenum target, GLenum pname, const GLint *params) {}
void __gls_null_glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glTexEnvf(GLenum target, GLenum pname, GLfloat param) {}
void __gls_null_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params) {}
void __gls_null_glTexEnvi(GLenum target, GLenum pname, GLint param) {}
void __gls_null_glTexEnviv(GLenum target, GLenum pname, const GLint *params) {}
void __gls_null_glTexGend(GLenum coord, GLenum pname, GLdouble param) {}
void __gls_null_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params) {}
void __gls_null_glTexGenf(GLenum coord, GLenum pname, GLfloat param) {}
void __gls_null_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params) {}
void __gls_null_glTexGeni(GLenum coord, GLenum pname, GLint param) {}
void __gls_null_glTexGeniv(GLenum coord, GLenum pname, const GLint *params) {}
void __gls_null_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer) {}
void __gls_null_glSelectBuffer(GLsizei size, GLuint *buffer) {}
GLint __gls_null_glRenderMode(GLenum mode) {return 0;}
void __gls_null_glInitNames(void) {}
void __gls_null_glLoadName(GLuint name) {}
void __gls_null_glPassThrough(GLfloat token) {}
void __gls_null_glPopName(void) {}
void __gls_null_glPushName(GLuint name) {}
void __gls_null_glDrawBuffer(GLenum mode) {}
void __gls_null_glClear(GLbitfield mask) {}
void __gls_null_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {}
void __gls_null_glClearIndex(GLfloat c) {}
void __gls_null_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {}
void __gls_null_glClearStencil(GLint s) {}
void __gls_null_glClearDepth(GLclampd depth) {}
void __gls_null_glStencilMask(GLuint mask) {}
void __gls_null_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {}
void __gls_null_glDepthMask(GLboolean flag) {}
void __gls_null_glIndexMask(GLuint mask) {}
void __gls_null_glAccum(GLenum op, GLfloat value) {}
void __gls_null_glDisable(GLenum cap) {}
void __gls_null_glEnable(GLenum cap) {}
void __gls_null_glFinish(void) {}
void __gls_null_glFlush(void) {}
void __gls_null_glPopAttrib(void) {}
void __gls_null_glPushAttrib(GLbitfield mask) {}
void __gls_null_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points) {}
void __gls_null_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points) {}
void __gls_null_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points) {}
void __gls_null_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points) {}
void __gls_null_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {}
void __gls_null_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {}
void __gls_null_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {}
void __gls_null_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {}
void __gls_null_glEvalCoord1d(GLdouble u) {}
void __gls_null_glEvalCoord1dv(const GLdouble *u) {}
void __gls_null_glEvalCoord1f(GLfloat u) {}
void __gls_null_glEvalCoord1fv(const GLfloat *u) {}
void __gls_null_glEvalCoord2d(GLdouble u, GLdouble v) {}
void __gls_null_glEvalCoord2dv(const GLdouble *u) {}
void __gls_null_glEvalCoord2f(GLfloat u, GLfloat v) {}
void __gls_null_glEvalCoord2fv(const GLfloat *u) {}
void __gls_null_glEvalMesh1(GLenum mode, GLint i1, GLint i2) {}
void __gls_null_glEvalPoint1(GLint i) {}
void __gls_null_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {}
void __gls_null_glEvalPoint2(GLint i, GLint j) {}
void __gls_null_glAlphaFunc(GLenum func, GLclampf ref) {}
void __gls_null_glBlendFunc(GLenum sfactor, GLenum dfactor) {}
void __gls_null_glLogicOp(GLenum opcode) {}
void __gls_null_glStencilFunc(GLenum func, GLint ref, GLuint mask) {}
void __gls_null_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {}
void __gls_null_glDepthFunc(GLenum func) {}
void __gls_null_glPixelZoom(GLfloat xfactor, GLfloat yfactor) {}
void __gls_null_glPixelTransferf(GLenum pname, GLfloat param) {}
void __gls_null_glPixelTransferi(GLenum pname, GLint param) {}
void __gls_null_glPixelStoref(GLenum pname, GLfloat param) {}
void __gls_null_glPixelStorei(GLenum pname, GLint param) {}
void __gls_null_glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values) {}
void __gls_null_glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values) {}
void __gls_null_glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values) {}
void __gls_null_glReadBuffer(GLenum mode) {}
void __gls_null_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {}
void __gls_null_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {}
void __gls_null_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glGetBooleanv(GLenum pname, GLboolean *params) {}
void __gls_null_glGetClipPlane(GLenum plane, GLdouble *equation) {}
void __gls_null_glGetDoublev(GLenum pname, GLdouble *params) {}
GLenum __gls_null_glGetError(void) {return 0;}
void __gls_null_glGetFloatv(GLenum pname, GLfloat *params) {}
void __gls_null_glGetIntegerv(GLenum pname, GLint *params) {}
void __gls_null_glGetLightfv(GLenum light, GLenum pname, GLfloat *params) {}
void __gls_null_glGetLightiv(GLenum light, GLenum pname, GLint *params) {}
void __gls_null_glGetMapdv(GLenum target, GLenum query, GLdouble *v) {}
void __gls_null_glGetMapfv(GLenum target, GLenum query, GLfloat *v) {}
void __gls_null_glGetMapiv(GLenum target, GLenum query, GLint *v) {}
void __gls_null_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params) {}
void __gls_null_glGetMaterialiv(GLenum face, GLenum pname, GLint *params) {}
void __gls_null_glGetPixelMapfv(GLenum map, GLfloat *values) {}
void __gls_null_glGetPixelMapuiv(GLenum map, GLuint *values) {}
void __gls_null_glGetPixelMapusv(GLenum map, GLushort *values) {}
void __gls_null_glGetPolygonStipple(GLubyte *mask) {}
const GLubyte * __gls_null_glGetString(GLenum name) {return 0;}
void __gls_null_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params) {}
void __gls_null_glGetTexEnviv(GLenum target, GLenum pname, GLint *params) {}
void __gls_null_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params) {}
void __gls_null_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params) {}
void __gls_null_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params) {}
void __gls_null_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels) {}
void __gls_null_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params) {}
void __gls_null_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) {}
void __gls_null_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params) {}
void __gls_null_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params) {}
GLboolean __gls_null_glIsEnabled(GLenum cap) {return 0;}
GLboolean __gls_null_glIsList(GLuint list) {return 0;}
void __gls_null_glDepthRange(GLclampd zNear, GLclampd zFar) {}
void __gls_null_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {}
void __gls_null_glLoadIdentity(void) {}
void __gls_null_glLoadMatrixf(const GLfloat *m) {}
void __gls_null_glLoadMatrixd(const GLdouble *m) {}
void __gls_null_glMatrixMode(GLenum mode) {}
void __gls_null_glMultMatrixf(const GLfloat *m) {}
void __gls_null_glMultMatrixd(const GLdouble *m) {}
void __gls_null_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {}
void __gls_null_glPopMatrix(void) {}
void __gls_null_glPushMatrix(void) {}
void __gls_null_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glScaled(GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glScalef(GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glTranslated(GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glTranslatef(GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {}
#if __GL_EXT_blend_color
    void __gls_null_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {}
#endif /* __GL_EXT_blend_color */
#if __GL_EXT_blend_minmax
    void __gls_null_glBlendEquationEXT(GLenum mode) {}
#endif /* __GL_EXT_blend_minmax */
#if __GL_EXT_polygon_offset
    void __gls_null_glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {}
#endif /* __GL_EXT_polygon_offset */
#if __GL_EXT_subtexture
    void __gls_null_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_EXT_subtexture */
#if __GL_EXT_subtexture
    void __gls_null_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_EXT_subtexture */
#if __GL_SGIS_multisample
    void __gls_null_glSampleMaskSGIS(GLclampf value, GLboolean invert) {}
#endif /* __GL_SGIS_multisample */
#if __GL_SGIS_multisample
    void __gls_null_glSamplePatternSGIS(GLenum pattern) {}
#endif /* __GL_SGIS_multisample */
#if __GL_SGIX_multisample
    void __gls_null_glTagSampleBufferSGIX(void) {}
#endif /* __GL_SGIX_multisample */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_histogram
    void __gls_null_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glResetHistogramEXT(GLenum target) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glResetMinmaxEXT(GLenum target) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_texture3D
    void __gls_null_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_EXT_texture3D */
#if __GL_EXT_subtexture
    void __gls_null_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_EXT_subtexture */
#if __GL_SGIS_detail_texture
    void __gls_null_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {}
#endif /* __GL_SGIS_detail_texture */
#if __GL_SGIS_detail_texture
    void __gls_null_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points) {}
#endif /* __GL_SGIS_detail_texture */
#if __GL_SGIS_sharpen_texture
    void __gls_null_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {}
#endif /* __GL_SGIS_sharpen_texture */
#if __GL_SGIS_sharpen_texture
    void __gls_null_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points) {}
#endif /* __GL_SGIS_sharpen_texture */
#if __GL_EXT_vertex_array
    void __gls_null_glArrayElementEXT(GLint i) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glGetPointervEXT(GLenum pname, GLvoid* *params) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_texture_object
    GLboolean __gls_null_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences) {return 0;}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    void __gls_null_glBindTextureEXT(GLenum target, GLuint texture) {}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    void __gls_null_glDeleteTexturesEXT(GLsizei n, const GLuint *textures) {}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    void __gls_null_glGenTexturesEXT(GLsizei n, GLuint *textures) {}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    GLboolean __gls_null_glIsTextureEXT(GLuint texture) {return 0;}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    void __gls_null_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities) {}
#endif /* __GL_EXT_texture_object */

#if __GL_WIN_draw_range_elements
void __gls_null_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices) {}
#endif // __GL_EXT_draw_range_elements

#if __GL_EXT_paletted_texture
    void __gls_null_glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table) {}
#endif /* __GL_EXT_paletted_texture */
#if __GL_SGI_color_table
    void __gls_null_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {}
#endif /* __GL_SGI_color_table */
#if __GL_SGI_color_table
    void __gls_null_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {}
#endif /* __GL_SGI_color_table */
#if __GL_SGI_color_table
    void __gls_null_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {}
#endif /* __GL_SGI_color_table */
#if __GL_EXT_paletted_texture
    void __gls_null_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table) {}
#endif /* __GL_EXT_paletted_texture */
#if __GL_EXT_paletted_texture
    void __gls_null_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_EXT_paletted_texture */
#if __GL_EXT_paletted_texture
    void __gls_null_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_EXT_paletted_texture */
#if __GL_SGI_texture_color_table
    void __gls_null_glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_SGI_texture_color_table */
#if __GL_SGI_texture_color_table
    void __gls_null_glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_SGI_texture_color_table */
#if __GL_SGI_texture_color_table
    void __gls_null_glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {}
#endif /* __GL_SGI_texture_color_table */
#if __GL_SGI_texture_color_table
    void __gls_null_glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {}
#endif /* __GL_SGI_texture_color_table */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_SGIS_texture4D
    void __gls_null_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_SGIS_texture4D */
#if __GL_SGIS_texture4D
    void __gls_null_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_SGIS_texture4D */
#if __GL_SGIX_pixel_texture
    void __gls_null_glPixelTexGenSGIX(GLenum mode) {}
#endif /* __GL_SGIX_pixel_texture */

// DrewB - 1.1
void __gls_null_glArrayElement(GLint i) {}
void __gls_null_glBindTexture(GLenum target, GLuint texture) {}
void __gls_null_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glDisableClientState(GLenum array) {}
void __gls_null_glDrawArrays(GLenum mode, GLint first, GLsizei count) {}
void __gls_null_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) {}
void __gls_null_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glEnableClientState(GLenum array) {}
void __gls_null_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glIndexub(GLubyte c) {}
void __gls_null_glIndexubv(const GLubyte *c) {}
void __gls_null_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glPolygonOffset(GLfloat factor, GLfloat units) {}
void __gls_null_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences) {}
void __gls_null_glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border) {}
void __gls_null_glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {}
void __gls_null_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {}
void __gls_null_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {}
void __gls_null_glDeleteTextures(GLsizei n, const GLuint *textures) {}
void __gls_null_glGenTextures(GLsizei n, GLuint *textures) {}
void __gls_null_glGetPointerv(GLenum pname, GLvoid* *params) {}
void __gls_null_glIsTexture(GLuint texture) {}
void __gls_null_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities) {}
void __gls_null_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glPushClientAttrib(GLbitfield mask) {}
void __gls_null_glPopClientAttrib(void) {}

#if __GL_EXT_paletted_texture
// DrewB
void __gls_null_glColorSubTableEXT(GLenum target, GLuint start, GLsizei count, GLenum format, GLenum type, const GLvoid *data) {}
#endif
#if __GL_WIN_draw_range_elements
// MarcFo
void __gls_null_glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices) {}
#endif

const GLSfunc __glsNullCommandFuncs[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_null_glsBeginGLS,
    (GLSfunc)__gls_null_glsBlock,
    (GLSfunc)__gls_null_glsCallStream,
    (GLSfunc)__gls_null_glsEndGLS,
    (GLSfunc)__gls_null_glsError,
    (GLSfunc)__gls_null_glsGLRC,
    (GLSfunc)__gls_null_glsGLRCLayer,
    (GLSfunc)__gls_null_glsHeaderGLRCi,
    (GLSfunc)__gls_null_glsHeaderLayerf,
    (GLSfunc)__gls_null_glsHeaderLayeri,
    (GLSfunc)__gls_null_glsHeaderf,
    (GLSfunc)__gls_null_glsHeaderfv,
    (GLSfunc)__gls_null_glsHeaderi,
    (GLSfunc)__gls_null_glsHeaderiv,
    (GLSfunc)__gls_null_glsHeaderubz,
    (GLSfunc)__gls_null_glsRequireExtension,
    (GLSfunc)__gls_null_glsUnsupportedCommand,
    (GLSfunc)__gls_null_glsAppRef,
    (GLSfunc)__gls_null_glsBeginObj,
    (GLSfunc)__gls_null_glsCharubz,
    (GLSfunc)__gls_null_glsComment,
    (GLSfunc)__gls_null_glsDisplayMapfv,
    (GLSfunc)__gls_null_glsEndObj,
    (GLSfunc)__gls_null_glsNumb,
    (GLSfunc)__gls_null_glsNumbv,
    (GLSfunc)__gls_null_glsNumd,
    (GLSfunc)__gls_null_glsNumdv,
    (GLSfunc)__gls_null_glsNumf,
    (GLSfunc)__gls_null_glsNumfv,
    (GLSfunc)__gls_null_glsNumi,
    (GLSfunc)__gls_null_glsNumiv,
    (GLSfunc)__gls_null_glsNuml,
    (GLSfunc)__gls_null_glsNumlv,
    (GLSfunc)__gls_null_glsNums,
    (GLSfunc)__gls_null_glsNumsv,
    (GLSfunc)__gls_null_glsNumub,
    (GLSfunc)__gls_null_glsNumubv,
    (GLSfunc)__gls_null_glsNumui,
    (GLSfunc)__gls_null_glsNumuiv,
    (GLSfunc)__gls_null_glsNumul,
    (GLSfunc)__gls_null_glsNumulv,
    (GLSfunc)__gls_null_glsNumus,
    (GLSfunc)__gls_null_glsNumusv,
    (GLSfunc)__gls_null_glsPad,
    (GLSfunc)__gls_null_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_null_glNewList,
    (GLSfunc)__gls_null_glEndList,
    (GLSfunc)__gls_null_glCallList,
    (GLSfunc)__gls_null_glCallLists,
    (GLSfunc)__gls_null_glDeleteLists,
    (GLSfunc)__gls_null_glGenLists,
    (GLSfunc)__gls_null_glListBase,
    (GLSfunc)__gls_null_glBegin,
    (GLSfunc)__gls_null_glBitmap,
    (GLSfunc)__gls_null_glColor3b,
    (GLSfunc)__gls_null_glColor3bv,
    (GLSfunc)__gls_null_glColor3d,
    (GLSfunc)__gls_null_glColor3dv,
    (GLSfunc)__gls_null_glColor3f,
    (GLSfunc)__gls_null_glColor3fv,
    (GLSfunc)__gls_null_glColor3i,
    (GLSfunc)__gls_null_glColor3iv,
    (GLSfunc)__gls_null_glColor3s,
    (GLSfunc)__gls_null_glColor3sv,
    (GLSfunc)__gls_null_glColor3ub,
    (GLSfunc)__gls_null_glColor3ubv,
    (GLSfunc)__gls_null_glColor3ui,
    (GLSfunc)__gls_null_glColor3uiv,
    (GLSfunc)__gls_null_glColor3us,
    (GLSfunc)__gls_null_glColor3usv,
    (GLSfunc)__gls_null_glColor4b,
    (GLSfunc)__gls_null_glColor4bv,
    (GLSfunc)__gls_null_glColor4d,
    (GLSfunc)__gls_null_glColor4dv,
    (GLSfunc)__gls_null_glColor4f,
    (GLSfunc)__gls_null_glColor4fv,
    (GLSfunc)__gls_null_glColor4i,
    (GLSfunc)__gls_null_glColor4iv,
    (GLSfunc)__gls_null_glColor4s,
    (GLSfunc)__gls_null_glColor4sv,
    (GLSfunc)__gls_null_glColor4ub,
    (GLSfunc)__gls_null_glColor4ubv,
    (GLSfunc)__gls_null_glColor4ui,
    (GLSfunc)__gls_null_glColor4uiv,
    (GLSfunc)__gls_null_glColor4us,
    (GLSfunc)__gls_null_glColor4usv,
    (GLSfunc)__gls_null_glEdgeFlag,
    (GLSfunc)__gls_null_glEdgeFlagv,
    (GLSfunc)__gls_null_glEnd,
    (GLSfunc)__gls_null_glIndexd,
    (GLSfunc)__gls_null_glIndexdv,
    (GLSfunc)__gls_null_glIndexf,
    (GLSfunc)__gls_null_glIndexfv,
    (GLSfunc)__gls_null_glIndexi,
    (GLSfunc)__gls_null_glIndexiv,
    (GLSfunc)__gls_null_glIndexs,
    (GLSfunc)__gls_null_glIndexsv,
    (GLSfunc)__gls_null_glNormal3b,
    (GLSfunc)__gls_null_glNormal3bv,
    (GLSfunc)__gls_null_glNormal3d,
    (GLSfunc)__gls_null_glNormal3dv,
    (GLSfunc)__gls_null_glNormal3f,
    (GLSfunc)__gls_null_glNormal3fv,
    (GLSfunc)__gls_null_glNormal3i,
    (GLSfunc)__gls_null_glNormal3iv,
    (GLSfunc)__gls_null_glNormal3s,
    (GLSfunc)__gls_null_glNormal3sv,
    (GLSfunc)__gls_null_glRasterPos2d,
    (GLSfunc)__gls_null_glRasterPos2dv,
    (GLSfunc)__gls_null_glRasterPos2f,
    (GLSfunc)__gls_null_glRasterPos2fv,
    (GLSfunc)__gls_null_glRasterPos2i,
    (GLSfunc)__gls_null_glRasterPos2iv,
    (GLSfunc)__gls_null_glRasterPos2s,
    (GLSfunc)__gls_null_glRasterPos2sv,
    (GLSfunc)__gls_null_glRasterPos3d,
    (GLSfunc)__gls_null_glRasterPos3dv,
    (GLSfunc)__gls_null_glRasterPos3f,
    (GLSfunc)__gls_null_glRasterPos3fv,
    (GLSfunc)__gls_null_glRasterPos3i,
    (GLSfunc)__gls_null_glRasterPos3iv,
    (GLSfunc)__gls_null_glRasterPos3s,
    (GLSfunc)__gls_null_glRasterPos3sv,
    (GLSfunc)__gls_null_glRasterPos4d,
    (GLSfunc)__gls_null_glRasterPos4dv,
    (GLSfunc)__gls_null_glRasterPos4f,
    (GLSfunc)__gls_null_glRasterPos4fv,
    (GLSfunc)__gls_null_glRasterPos4i,
    (GLSfunc)__gls_null_glRasterPos4iv,
    (GLSfunc)__gls_null_glRasterPos4s,
    (GLSfunc)__gls_null_glRasterPos4sv,
    (GLSfunc)__gls_null_glRectd,
    (GLSfunc)__gls_null_glRectdv,
    (GLSfunc)__gls_null_glRectf,
    (GLSfunc)__gls_null_glRectfv,
    (GLSfunc)__gls_null_glRecti,
    (GLSfunc)__gls_null_glRectiv,
    (GLSfunc)__gls_null_glRects,
    (GLSfunc)__gls_null_glRectsv,
    (GLSfunc)__gls_null_glTexCoord1d,
    (GLSfunc)__gls_null_glTexCoord1dv,
    (GLSfunc)__gls_null_glTexCoord1f,
    (GLSfunc)__gls_null_glTexCoord1fv,
    (GLSfunc)__gls_null_glTexCoord1i,
    (GLSfunc)__gls_null_glTexCoord1iv,
    (GLSfunc)__gls_null_glTexCoord1s,
    (GLSfunc)__gls_null_glTexCoord1sv,
    (GLSfunc)__gls_null_glTexCoord2d,
    (GLSfunc)__gls_null_glTexCoord2dv,
    (GLSfunc)__gls_null_glTexCoord2f,
    (GLSfunc)__gls_null_glTexCoord2fv,
    (GLSfunc)__gls_null_glTexCoord2i,
    (GLSfunc)__gls_null_glTexCoord2iv,
    (GLSfunc)__gls_null_glTexCoord2s,
    (GLSfunc)__gls_null_glTexCoord2sv,
    (GLSfunc)__gls_null_glTexCoord3d,
    (GLSfunc)__gls_null_glTexCoord3dv,
    (GLSfunc)__gls_null_glTexCoord3f,
    (GLSfunc)__gls_null_glTexCoord3fv,
    (GLSfunc)__gls_null_glTexCoord3i,
    (GLSfunc)__gls_null_glTexCoord3iv,
    (GLSfunc)__gls_null_glTexCoord3s,
    (GLSfunc)__gls_null_glTexCoord3sv,
    (GLSfunc)__gls_null_glTexCoord4d,
    (GLSfunc)__gls_null_glTexCoord4dv,
    (GLSfunc)__gls_null_glTexCoord4f,
    (GLSfunc)__gls_null_glTexCoord4fv,
    (GLSfunc)__gls_null_glTexCoord4i,
    (GLSfunc)__gls_null_glTexCoord4iv,
    (GLSfunc)__gls_null_glTexCoord4s,
    (GLSfunc)__gls_null_glTexCoord4sv,
    (GLSfunc)__gls_null_glVertex2d,
    (GLSfunc)__gls_null_glVertex2dv,
    (GLSfunc)__gls_null_glVertex2f,
    (GLSfunc)__gls_null_glVertex2fv,
    (GLSfunc)__gls_null_glVertex2i,
    (GLSfunc)__gls_null_glVertex2iv,
    (GLSfunc)__gls_null_glVertex2s,
    (GLSfunc)__gls_null_glVertex2sv,
    (GLSfunc)__gls_null_glVertex3d,
    (GLSfunc)__gls_null_glVertex3dv,
    (GLSfunc)__gls_null_glVertex3f,
    (GLSfunc)__gls_null_glVertex3fv,
    (GLSfunc)__gls_null_glVertex3i,
    (GLSfunc)__gls_null_glVertex3iv,
    (GLSfunc)__gls_null_glVertex3s,
    (GLSfunc)__gls_null_glVertex3sv,
    (GLSfunc)__gls_null_glVertex4d,
    (GLSfunc)__gls_null_glVertex4dv,
    (GLSfunc)__gls_null_glVertex4f,
    (GLSfunc)__gls_null_glVertex4fv,
    (GLSfunc)__gls_null_glVertex4i,
    (GLSfunc)__gls_null_glVertex4iv,
    (GLSfunc)__gls_null_glVertex4s,
    (GLSfunc)__gls_null_glVertex4sv,
    (GLSfunc)__gls_null_glClipPlane,
    (GLSfunc)__gls_null_glColorMaterial,
    (GLSfunc)__gls_null_glCullFace,
    (GLSfunc)__gls_null_glFogf,
    (GLSfunc)__gls_null_glFogfv,
    (GLSfunc)__gls_null_glFogi,
    (GLSfunc)__gls_null_glFogiv,
    (GLSfunc)__gls_null_glFrontFace,
    (GLSfunc)__gls_null_glHint,
    (GLSfunc)__gls_null_glLightf,
    (GLSfunc)__gls_null_glLightfv,
    (GLSfunc)__gls_null_glLighti,
    (GLSfunc)__gls_null_glLightiv,
    (GLSfunc)__gls_null_glLightModelf,
    (GLSfunc)__gls_null_glLightModelfv,
    (GLSfunc)__gls_null_glLightModeli,
    (GLSfunc)__gls_null_glLightModeliv,
    (GLSfunc)__gls_null_glLineStipple,
    (GLSfunc)__gls_null_glLineWidth,
    (GLSfunc)__gls_null_glMaterialf,
    (GLSfunc)__gls_null_glMaterialfv,
    (GLSfunc)__gls_null_glMateriali,
    (GLSfunc)__gls_null_glMaterialiv,
    (GLSfunc)__gls_null_glPointSize,
    (GLSfunc)__gls_null_glPolygonMode,
    (GLSfunc)__gls_null_glPolygonStipple,
    (GLSfunc)__gls_null_glScissor,
    (GLSfunc)__gls_null_glShadeModel,
    (GLSfunc)__gls_null_glTexParameterf,
    (GLSfunc)__gls_null_glTexParameterfv,
    (GLSfunc)__gls_null_glTexParameteri,
    (GLSfunc)__gls_null_glTexParameteriv,
    (GLSfunc)__gls_null_glTexImage1D,
    (GLSfunc)__gls_null_glTexImage2D,
    (GLSfunc)__gls_null_glTexEnvf,
    (GLSfunc)__gls_null_glTexEnvfv,
    (GLSfunc)__gls_null_glTexEnvi,
    (GLSfunc)__gls_null_glTexEnviv,
    (GLSfunc)__gls_null_glTexGend,
    (GLSfunc)__gls_null_glTexGendv,
    (GLSfunc)__gls_null_glTexGenf,
    (GLSfunc)__gls_null_glTexGenfv,
    (GLSfunc)__gls_null_glTexGeni,
    (GLSfunc)__gls_null_glTexGeniv,
    (GLSfunc)__gls_null_glFeedbackBuffer,
    (GLSfunc)__gls_null_glSelectBuffer,
    (GLSfunc)__gls_null_glRenderMode,
    (GLSfunc)__gls_null_glInitNames,
    (GLSfunc)__gls_null_glLoadName,
    (GLSfunc)__gls_null_glPassThrough,
    (GLSfunc)__gls_null_glPopName,
    (GLSfunc)__gls_null_glPushName,
    (GLSfunc)__gls_null_glDrawBuffer,
    (GLSfunc)__gls_null_glClear,
    (GLSfunc)__gls_null_glClearAccum,
    (GLSfunc)__gls_null_glClearIndex,
    (GLSfunc)__gls_null_glClearColor,
    (GLSfunc)__gls_null_glClearStencil,
    (GLSfunc)__gls_null_glClearDepth,
    (GLSfunc)__gls_null_glStencilMask,
    (GLSfunc)__gls_null_glColorMask,
    (GLSfunc)__gls_null_glDepthMask,
    (GLSfunc)__gls_null_glIndexMask,
    (GLSfunc)__gls_null_glAccum,
    (GLSfunc)__gls_null_glDisable,
    (GLSfunc)__gls_null_glEnable,
    (GLSfunc)__gls_null_glFinish,
    (GLSfunc)__gls_null_glFlush,
    (GLSfunc)__gls_null_glPopAttrib,
    (GLSfunc)__gls_null_glPushAttrib,
    (GLSfunc)__gls_null_glMap1d,
    (GLSfunc)__gls_null_glMap1f,
    (GLSfunc)__gls_null_glMap2d,
    (GLSfunc)__gls_null_glMap2f,
    (GLSfunc)__gls_null_glMapGrid1d,
    (GLSfunc)__gls_null_glMapGrid1f,
    (GLSfunc)__gls_null_glMapGrid2d,
    (GLSfunc)__gls_null_glMapGrid2f,
    (GLSfunc)__gls_null_glEvalCoord1d,
    (GLSfunc)__gls_null_glEvalCoord1dv,
    (GLSfunc)__gls_null_glEvalCoord1f,
    (GLSfunc)__gls_null_glEvalCoord1fv,
    (GLSfunc)__gls_null_glEvalCoord2d,
    (GLSfunc)__gls_null_glEvalCoord2dv,
    (GLSfunc)__gls_null_glEvalCoord2f,
    (GLSfunc)__gls_null_glEvalCoord2fv,
    (GLSfunc)__gls_null_glEvalMesh1,
    (GLSfunc)__gls_null_glEvalPoint1,
    (GLSfunc)__gls_null_glEvalMesh2,
    (GLSfunc)__gls_null_glEvalPoint2,
    (GLSfunc)__gls_null_glAlphaFunc,
    (GLSfunc)__gls_null_glBlendFunc,
    (GLSfunc)__gls_null_glLogicOp,
    (GLSfunc)__gls_null_glStencilFunc,
    (GLSfunc)__gls_null_glStencilOp,
    (GLSfunc)__gls_null_glDepthFunc,
    (GLSfunc)__gls_null_glPixelZoom,
    (GLSfunc)__gls_null_glPixelTransferf,
    (GLSfunc)__gls_null_glPixelTransferi,
    (GLSfunc)__gls_null_glPixelStoref,
    (GLSfunc)__gls_null_glPixelStorei,
    (GLSfunc)__gls_null_glPixelMapfv,
    (GLSfunc)__gls_null_glPixelMapuiv,
    (GLSfunc)__gls_null_glPixelMapusv,
    (GLSfunc)__gls_null_glReadBuffer,
    (GLSfunc)__gls_null_glCopyPixels,
    (GLSfunc)__gls_null_glReadPixels,
    (GLSfunc)__gls_null_glDrawPixels,
    (GLSfunc)__gls_null_glGetBooleanv,
    (GLSfunc)__gls_null_glGetClipPlane,
    (GLSfunc)__gls_null_glGetDoublev,
    (GLSfunc)__gls_null_glGetError,
    (GLSfunc)__gls_null_glGetFloatv,
    (GLSfunc)__gls_null_glGetIntegerv,
    (GLSfunc)__gls_null_glGetLightfv,
    (GLSfunc)__gls_null_glGetLightiv,
    (GLSfunc)__gls_null_glGetMapdv,
    (GLSfunc)__gls_null_glGetMapfv,
    (GLSfunc)__gls_null_glGetMapiv,
    (GLSfunc)__gls_null_glGetMaterialfv,
    (GLSfunc)__gls_null_glGetMaterialiv,
    (GLSfunc)__gls_null_glGetPixelMapfv,
    (GLSfunc)__gls_null_glGetPixelMapuiv,
    (GLSfunc)__gls_null_glGetPixelMapusv,
    (GLSfunc)__gls_null_glGetPolygonStipple,
    (GLSfunc)__gls_null_glGetString,
    (GLSfunc)__gls_null_glGetTexEnvfv,
    (GLSfunc)__gls_null_glGetTexEnviv,
    (GLSfunc)__gls_null_glGetTexGendv,
    (GLSfunc)__gls_null_glGetTexGenfv,
    (GLSfunc)__gls_null_glGetTexGeniv,
    (GLSfunc)__gls_null_glGetTexImage,
    (GLSfunc)__gls_null_glGetTexParameterfv,
    (GLSfunc)__gls_null_glGetTexParameteriv,
    (GLSfunc)__gls_null_glGetTexLevelParameterfv,
    (GLSfunc)__gls_null_glGetTexLevelParameteriv,
    (GLSfunc)__gls_null_glIsEnabled,
    (GLSfunc)__gls_null_glIsList,
    (GLSfunc)__gls_null_glDepthRange,
    (GLSfunc)__gls_null_glFrustum,
    (GLSfunc)__gls_null_glLoadIdentity,
    (GLSfunc)__gls_null_glLoadMatrixf,
    (GLSfunc)__gls_null_glLoadMatrixd,
    (GLSfunc)__gls_null_glMatrixMode,
    (GLSfunc)__gls_null_glMultMatrixf,
    (GLSfunc)__gls_null_glMultMatrixd,
    (GLSfunc)__gls_null_glOrtho,
    (GLSfunc)__gls_null_glPopMatrix,
    (GLSfunc)__gls_null_glPushMatrix,
    (GLSfunc)__gls_null_glRotated,
    (GLSfunc)__gls_null_glRotatef,
    (GLSfunc)__gls_null_glScaled,
    (GLSfunc)__gls_null_glScalef,
    (GLSfunc)__gls_null_glTranslated,
    (GLSfunc)__gls_null_glTranslatef,
    (GLSfunc)__gls_null_glViewport,
    // DrewB - 1.1
    (GLSfunc)__gls_null_glArrayElement,
    (GLSfunc)__gls_null_glBindTexture,
    (GLSfunc)__gls_null_glColorPointer,
    (GLSfunc)__gls_null_glDisableClientState,
    (GLSfunc)__gls_null_glDrawArrays,
    (GLSfunc)__gls_null_glDrawElements,
    (GLSfunc)__gls_null_glEdgeFlagPointer,
    (GLSfunc)__gls_null_glEnableClientState,
    (GLSfunc)__gls_null_glIndexPointer,
    (GLSfunc)__gls_null_glIndexub,
    (GLSfunc)__gls_null_glIndexubv,
    (GLSfunc)__gls_null_glInterleavedArrays,
    (GLSfunc)__gls_null_glNormalPointer,
    (GLSfunc)__gls_null_glPolygonOffset,
    (GLSfunc)__gls_null_glTexCoordPointer,
    (GLSfunc)__gls_null_glVertexPointer,
    (GLSfunc)__gls_null_glAreTexturesResident,
    (GLSfunc)__gls_null_glCopyTexImage1D,
    (GLSfunc)__gls_null_glCopyTexImage2D,
    (GLSfunc)__gls_null_glCopyTexSubImage1D,
    (GLSfunc)__gls_null_glCopyTexSubImage2D,
    (GLSfunc)__gls_null_glDeleteTextures,
    (GLSfunc)__gls_null_glGenTextures,
    (GLSfunc)__gls_null_glGetPointerv,
    (GLSfunc)__gls_null_glIsTexture,
    (GLSfunc)__gls_null_glPrioritizeTextures,
    (GLSfunc)__gls_null_glTexSubImage1D,
    (GLSfunc)__gls_null_glTexSubImage2D,
    (GLSfunc)__gls_null_glPushClientAttrib,
    (GLSfunc)__gls_null_glPopClientAttrib,
    #if __GL_EXT_blend_color
        (GLSfunc)__gls_null_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        (GLSfunc)__gls_null_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        (GLSfunc)__gls_null_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_null_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_null_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        (GLSfunc)__gls_null_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        (GLSfunc)__gls_null_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        (GLSfunc)__gls_null_glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        (GLSfunc)__gls_null_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_null_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)__gls_null_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)__gls_null_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)__gls_null_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)__gls_null_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_null_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_null_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_null_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_null_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_null_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_null_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_null_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_null_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_null_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_null_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_null_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        (GLSfunc)__gls_null_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        (GLSfunc)__gls_null_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        (GLSfunc)__gls_null_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        // DrewB
        (GLSfunc)__gls_null_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    #if __GL_WIN_draw_range_elements
        // MarcFo
        (GLSfunc)__gls_null_glDrawRangeElementsWIN,
    #else
        GLS_NONE,
    #endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_glapi.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void glNewList(GLuint list, GLenum mode) {
    typedef void (*__GLSdispatch)(GLuint, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[64])(list, mode);
}

void glEndList(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[65])();
}

void glCallList(GLuint list) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[66])(list);
}

void glCallLists(GLsizei n, GLenum type, const GLvoid *lists) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[67])(n, type, lists);
}

void glDeleteLists(GLuint list, GLsizei range) {
    typedef void (*__GLSdispatch)(GLuint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[68])(list, range);
}

GLuint glGenLists(GLsizei range) {
    typedef GLuint (*__GLSdispatch)(GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[69])(range);
}

void glListBase(GLuint base) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[70])(base);
}

void glBegin(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[71])(mode);
}

void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[72])(width, height, xorig, yorig, xmove, ymove, bitmap);
}

void glColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[73])(red, green, blue);
}

void glColor3bv(const GLbyte *v) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[74])(v);
}

void glColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[75])(red, green, blue);
}

void glColor3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[76])(v);
}

void glColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[77])(red, green, blue);
}

void glColor3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[78])(v);
}

void glColor3i(GLint red, GLint green, GLint blue) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[79])(red, green, blue);
}

void glColor3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[80])(v);
}

void glColor3s(GLshort red, GLshort green, GLshort blue) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[81])(red, green, blue);
}

void glColor3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[82])(v);
}

void glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[83])(red, green, blue);
}

void glColor3ubv(const GLubyte *v) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[84])(v);
}

void glColor3ui(GLuint red, GLuint green, GLuint blue) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[85])(red, green, blue);
}

void glColor3uiv(const GLuint *v) {
    typedef void (*__GLSdispatch)(const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[86])(v);
}

void glColor3us(GLushort red, GLushort green, GLushort blue) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[87])(red, green, blue);
}

void glColor3usv(const GLushort *v) {
    typedef void (*__GLSdispatch)(const GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[88])(v);
}

void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte, GLbyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[89])(red, green, blue, alpha);
}

void glColor4bv(const GLbyte *v) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[90])(v);
}

void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[91])(red, green, blue, alpha);
}

void glColor4dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[92])(v);
}

void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[93])(red, green, blue, alpha);
}

void glColor4fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[94])(v);
}

void glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[95])(red, green, blue, alpha);
}

void glColor4iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[96])(v);
}

void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[97])(red, green, blue, alpha);
}

void glColor4sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[98])(v);
}

void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte, GLubyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[99])(red, green, blue, alpha);
}

void glColor4ubv(const GLubyte *v) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[100])(v);
}

void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[101])(red, green, blue, alpha);
}

void glColor4uiv(const GLuint *v) {
    typedef void (*__GLSdispatch)(const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[102])(v);
}

void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort, GLushort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[103])(red, green, blue, alpha);
}

void glColor4usv(const GLushort *v) {
    typedef void (*__GLSdispatch)(const GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[104])(v);
}

void glEdgeFlag(GLboolean flag) {
    typedef void (*__GLSdispatch)(GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[105])(flag);
}

void glEdgeFlagv(const GLboolean *flag) {
    typedef void (*__GLSdispatch)(const GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[106])(flag);
}

void glEnd(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[107])();
}

void glIndexd(GLdouble c) {
    typedef void (*__GLSdispatch)(GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[108])(c);
}

void glIndexdv(const GLdouble *c) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[109])(c);
}

void glIndexf(GLfloat c) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[110])(c);
}

void glIndexfv(const GLfloat *c) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[111])(c);
}

void glIndexi(GLint c) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[112])(c);
}

void glIndexiv(const GLint *c) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[113])(c);
}

void glIndexs(GLshort c) {
    typedef void (*__GLSdispatch)(GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[114])(c);
}

void glIndexsv(const GLshort *c) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[115])(c);
}

void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[116])(nx, ny, nz);
}

void glNormal3bv(const GLbyte *v) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[117])(v);
}

void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[118])(nx, ny, nz);
}

void glNormal3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[119])(v);
}

void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[120])(nx, ny, nz);
}

void glNormal3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[121])(v);
}

void glNormal3i(GLint nx, GLint ny, GLint nz) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[122])(nx, ny, nz);
}

void glNormal3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[123])(v);
}

void glNormal3s(GLshort nx, GLshort ny, GLshort nz) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[124])(nx, ny, nz);
}

void glNormal3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[125])(v);
}

void glRasterPos2d(GLdouble x, GLdouble y) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[126])(x, y);
}

void glRasterPos2dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[127])(v);
}

void glRasterPos2f(GLfloat x, GLfloat y) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[128])(x, y);
}

void glRasterPos2fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[129])(v);
}

void glRasterPos2i(GLint x, GLint y) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[130])(x, y);
}

void glRasterPos2iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[131])(v);
}

void glRasterPos2s(GLshort x, GLshort y) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[132])(x, y);
}

void glRasterPos2sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[133])(v);
}

void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[134])(x, y, z);
}

void glRasterPos3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[135])(v);
}

void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[136])(x, y, z);
}

void glRasterPos3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[137])(v);
}

void glRasterPos3i(GLint x, GLint y, GLint z) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[138])(x, y, z);
}

void glRasterPos3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[139])(v);
}

void glRasterPos3s(GLshort x, GLshort y, GLshort z) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[140])(x, y, z);
}

void glRasterPos3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[141])(v);
}

void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[142])(x, y, z, w);
}

void glRasterPos4dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[143])(v);
}

void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[144])(x, y, z, w);
}

void glRasterPos4fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[145])(v);
}

void glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[146])(x, y, z, w);
}

void glRasterPos4iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[147])(v);
}

void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[148])(x, y, z, w);
}

void glRasterPos4sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[149])(v);
}

void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[150])(x1, y1, x2, y2);
}

void glRectdv(const GLdouble *v1, const GLdouble *v2) {
    typedef void (*__GLSdispatch)(const GLdouble *, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[151])(v1, v2);
}

void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[152])(x1, y1, x2, y2);
}

void glRectfv(const GLfloat *v1, const GLfloat *v2) {
    typedef void (*__GLSdispatch)(const GLfloat *, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[153])(v1, v2);
}

void glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[154])(x1, y1, x2, y2);
}

void glRectiv(const GLint *v1, const GLint *v2) {
    typedef void (*__GLSdispatch)(const GLint *, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[155])(v1, v2);
}

void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[156])(x1, y1, x2, y2);
}

void glRectsv(const GLshort *v1, const GLshort *v2) {
    typedef void (*__GLSdispatch)(const GLshort *, const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[157])(v1, v2);
}

void glTexCoord1d(GLdouble s) {
    typedef void (*__GLSdispatch)(GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[158])(s);
}

void glTexCoord1dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[159])(v);
}

void glTexCoord1f(GLfloat s) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[160])(s);
}

void glTexCoord1fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[161])(v);
}

void glTexCoord1i(GLint s) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[162])(s);
}

void glTexCoord1iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[163])(v);
}

void glTexCoord1s(GLshort s) {
    typedef void (*__GLSdispatch)(GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[164])(s);
}

void glTexCoord1sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[165])(v);
}

void glTexCoord2d(GLdouble s, GLdouble t) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[166])(s, t);
}

void glTexCoord2dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[167])(v);
}

void glTexCoord2f(GLfloat s, GLfloat t) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[168])(s, t);
}

void glTexCoord2fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[169])(v);
}

void glTexCoord2i(GLint s, GLint t) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[170])(s, t);
}

void glTexCoord2iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[171])(v);
}

void glTexCoord2s(GLshort s, GLshort t) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[172])(s, t);
}

void glTexCoord2sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[173])(v);
}

void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[174])(s, t, r);
}

void glTexCoord3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[175])(v);
}

void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[176])(s, t, r);
}

void glTexCoord3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[177])(v);
}

void glTexCoord3i(GLint s, GLint t, GLint r) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[178])(s, t, r);
}

void glTexCoord3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[179])(v);
}

void glTexCoord3s(GLshort s, GLshort t, GLshort r) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[180])(s, t, r);
}

void glTexCoord3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[181])(v);
}

void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[182])(s, t, r, q);
}

void glTexCoord4dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[183])(v);
}

void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[184])(s, t, r, q);
}

void glTexCoord4fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[185])(v);
}

void glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[186])(s, t, r, q);
}

void glTexCoord4iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[187])(v);
}

void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[188])(s, t, r, q);
}

void glTexCoord4sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[189])(v);
}

void glVertex2d(GLdouble x, GLdouble y) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[190])(x, y);
}

void glVertex2dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[191])(v);
}

void glVertex2f(GLfloat x, GLfloat y) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[192])(x, y);
}

void glVertex2fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[193])(v);
}

void glVertex2i(GLint x, GLint y) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[194])(x, y);
}

void glVertex2iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[195])(v);
}

void glVertex2s(GLshort x, GLshort y) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[196])(x, y);
}

void glVertex2sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[197])(v);
}

void glVertex3d(GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[198])(x, y, z);
}

void glVertex3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[199])(v);
}

void glVertex3f(GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[200])(x, y, z);
}

void glVertex3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[201])(v);
}

void glVertex3i(GLint x, GLint y, GLint z) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[202])(x, y, z);
}

void glVertex3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[203])(v);
}

void glVertex3s(GLshort x, GLshort y, GLshort z) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[204])(x, y, z);
}

void glVertex3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[205])(v);
}

void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[206])(x, y, z, w);
}

void glVertex4dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[207])(v);
}

void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[208])(x, y, z, w);
}

void glVertex4fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[209])(v);
}

void glVertex4i(GLint x, GLint y, GLint z, GLint w) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[210])(x, y, z, w);
}

void glVertex4iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[211])(v);
}

void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[212])(x, y, z, w);
}

void glVertex4sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[213])(v);
}

void glClipPlane(GLenum plane, const GLdouble *equation) {
    typedef void (*__GLSdispatch)(GLenum, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[214])(plane, equation);
}

void glColorMaterial(GLenum face, GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[215])(face, mode);
}

void glCullFace(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[216])(mode);
}

void glFogf(GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[217])(pname, param);
}

void glFogfv(GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[218])(pname, params);
}

void glFogi(GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[219])(pname, param);
}

void glFogiv(GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[220])(pname, params);
}

void glFrontFace(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[221])(mode);
}

void glHint(GLenum target, GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[222])(target, mode);
}

void glLightf(GLenum light, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[223])(light, pname, param);
}

void glLightfv(GLenum light, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[224])(light, pname, params);
}

void glLighti(GLenum light, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[225])(light, pname, param);
}

void glLightiv(GLenum light, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[226])(light, pname, params);
}

void glLightModelf(GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[227])(pname, param);
}

void glLightModelfv(GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[228])(pname, params);
}

void glLightModeli(GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[229])(pname, param);
}

void glLightModeliv(GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[230])(pname, params);
}

void glLineStipple(GLint factor, GLushort pattern) {
    typedef void (*__GLSdispatch)(GLint, GLushort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[231])(factor, pattern);
}

void glLineWidth(GLfloat width) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[232])(width);
}

void glMaterialf(GLenum face, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[233])(face, pname, param);
}

void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[234])(face, pname, params);
}

void glMateriali(GLenum face, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[235])(face, pname, param);
}

void glMaterialiv(GLenum face, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[236])(face, pname, params);
}

void glPointSize(GLfloat size) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[237])(size);
}

void glPolygonMode(GLenum face, GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[238])(face, mode);
}

void glPolygonStipple(const GLubyte *mask) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[239])(mask);
}

void glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[240])(x, y, width, height);
}

void glShadeModel(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[241])(mode);
}

void glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[242])(target, pname, param);
}

void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[243])(target, pname, params);
}

void glTexParameteri(GLenum target, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[244])(target, pname, param);
}

void glTexParameteriv(GLenum target, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[245])(target, pname, params);
}

void glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[246])(target, level, components, width, border, format, type, pixels);
}

void glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[247])(target, level, components, width, height, border, format, type, pixels);
}

void glTexEnvf(GLenum target, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[248])(target, pname, param);
}

void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[249])(target, pname, params);
}

void glTexEnvi(GLenum target, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[250])(target, pname, param);
}

void glTexEnviv(GLenum target, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[251])(target, pname, params);
}

void glTexGend(GLenum coord, GLenum pname, GLdouble param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[252])(coord, pname, param);
}

void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[253])(coord, pname, params);
}

void glTexGenf(GLenum coord, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[254])(coord, pname, param);
}

void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[255])(coord, pname, params);
}

void glTexGeni(GLenum coord, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[256])(coord, pname, param);
}

void glTexGeniv(GLenum coord, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[257])(coord, pname, params);
}

void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[258])(size, type, buffer);
}

void glSelectBuffer(GLsizei size, GLuint *buffer) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[259])(size, buffer);
}

GLint glRenderMode(GLenum mode) {
    typedef GLint (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[260])(mode);
}

void glInitNames(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[261])();
}

void glLoadName(GLuint name) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[262])(name);
}

void glPassThrough(GLfloat token) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[263])(token);
}

void glPopName(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[264])();
}

void glPushName(GLuint name) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[265])(name);
}

void glDrawBuffer(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[266])(mode);
}

void glClear(GLbitfield mask) {
    typedef void (*__GLSdispatch)(GLbitfield);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[267])(mask);
}

void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[268])(red, green, blue, alpha);
}

void glClearIndex(GLfloat c) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[269])(c);
}

void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[270])(red, green, blue, alpha);
}

void glClearStencil(GLint s) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[271])(s);
}

void glClearDepth(GLclampd depth) {
    typedef void (*__GLSdispatch)(GLclampd);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[272])(depth);
}

void glStencilMask(GLuint mask) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[273])(mask);
}

void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    typedef void (*__GLSdispatch)(GLboolean, GLboolean, GLboolean, GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[274])(red, green, blue, alpha);
}

void glDepthMask(GLboolean flag) {
    typedef void (*__GLSdispatch)(GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[275])(flag);
}

void glIndexMask(GLuint mask) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[276])(mask);
}

void glAccum(GLenum op, GLfloat value) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[277])(op, value);
}

void glDisable(GLenum cap) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[278])(cap);
}

void glEnable(GLenum cap) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[279])(cap);
}

void glFinish(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[280])();
}

void glFlush(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[281])();
}

void glPopAttrib(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[282])();
}

void glPushAttrib(GLbitfield mask) {
    typedef void (*__GLSdispatch)(GLbitfield);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[283])(mask);
}

void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[284])(target, u1, u2, stride, order, points);
}

void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[285])(target, u1, u2, stride, order, points);
}

void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[286])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[287])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[288])(un, u1, u2);
}

void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[289])(un, u1, u2);
}

void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[290])(un, u1, u2, vn, v1, v2);
}

void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[291])(un, u1, u2, vn, v1, v2);
}

void glEvalCoord1d(GLdouble u) {
    typedef void (*__GLSdispatch)(GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[292])(u);
}

void glEvalCoord1dv(const GLdouble *u) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[293])(u);
}

void glEvalCoord1f(GLfloat u) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[294])(u);
}

void glEvalCoord1fv(const GLfloat *u) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[295])(u);
}

void glEvalCoord2d(GLdouble u, GLdouble v) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[296])(u, v);
}

void glEvalCoord2dv(const GLdouble *u) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[297])(u);
}

void glEvalCoord2f(GLfloat u, GLfloat v) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[298])(u, v);
}

void glEvalCoord2fv(const GLfloat *u) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[299])(u);
}

void glEvalMesh1(GLenum mode, GLint i1, GLint i2) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[300])(mode, i1, i2);
}

void glEvalPoint1(GLint i) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[301])(i);
}

void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[302])(mode, i1, i2, j1, j2);
}

void glEvalPoint2(GLint i, GLint j) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[303])(i, j);
}

void glAlphaFunc(GLenum func, GLclampf ref) {
    typedef void (*__GLSdispatch)(GLenum, GLclampf);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[304])(func, ref);
}

void glBlendFunc(GLenum sfactor, GLenum dfactor) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[305])(sfactor, dfactor);
}

void glLogicOp(GLenum opcode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[306])(opcode);
}

void glStencilFunc(GLenum func, GLint ref, GLuint mask) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[307])(func, ref, mask);
}

void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[308])(fail, zfail, zpass);
}

void glDepthFunc(GLenum func) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[309])(func);
}

void glPixelZoom(GLfloat xfactor, GLfloat yfactor) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[310])(xfactor, yfactor);
}

void glPixelTransferf(GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[311])(pname, param);
}

void glPixelTransferi(GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[312])(pname, param);
}

void glPixelStoref(GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[313])(pname, param);
}

void glPixelStorei(GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[314])(pname, param);
}

void glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[315])(map, mapsize, values);
}

void glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[316])(map, mapsize, values);
}

void glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[317])(map, mapsize, values);
}

void glReadBuffer(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[318])(mode);
}

void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[319])(x, y, width, height, type);
}

void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[320])(x, y, width, height, format, type, pixels);
}

void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[321])(width, height, format, type, pixels);
}

void glGetBooleanv(GLenum pname, GLboolean *params) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[322])(pname, params);
}

void glGetClipPlane(GLenum plane, GLdouble *equation) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[323])(plane, equation);
}

void glGetDoublev(GLenum pname, GLdouble *params) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[324])(pname, params);
}

GLenum glGetError(void) {
    typedef GLenum (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[325])();
}

void glGetFloatv(GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[326])(pname, params);
}

void glGetIntegerv(GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[327])(pname, params);
}

void glGetLightfv(GLenum light, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[328])(light, pname, params);
}

void glGetLightiv(GLenum light, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[329])(light, pname, params);
}

void glGetMapdv(GLenum target, GLenum query, GLdouble *v) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[330])(target, query, v);
}

void glGetMapfv(GLenum target, GLenum query, GLfloat *v) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[331])(target, query, v);
}

void glGetMapiv(GLenum target, GLenum query, GLint *v) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[332])(target, query, v);
}

void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[333])(face, pname, params);
}

void glGetMaterialiv(GLenum face, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[334])(face, pname, params);
}

void glGetPixelMapfv(GLenum map, GLfloat *values) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[335])(map, values);
}

void glGetPixelMapuiv(GLenum map, GLuint *values) {
    typedef void (*__GLSdispatch)(GLenum, GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[336])(map, values);
}

void glGetPixelMapusv(GLenum map, GLushort *values) {
    typedef void (*__GLSdispatch)(GLenum, GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[337])(map, values);
}

void glGetPolygonStipple(GLubyte *mask) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[338])(mask);
}

const GLubyte * glGetString(GLenum name) {
    typedef const GLubyte * (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[339])(name);
}

void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[340])(target, pname, params);
}

void glGetTexEnviv(GLenum target, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[341])(target, pname, params);
}

void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[342])(coord, pname, params);
}

void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[343])(coord, pname, params);
}

void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[344])(coord, pname, params);
}

void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[345])(target, level, format, type, pixels);
}

void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[346])(target, pname, params);
}

void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[347])(target, pname, params);
}

void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[348])(target, level, pname, params);
}

void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[349])(target, level, pname, params);
}

GLboolean glIsEnabled(GLenum cap) {
    typedef GLboolean (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[350])(cap);
}

GLboolean glIsList(GLuint list) {
    typedef GLboolean (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[351])(list);
}

void glDepthRange(GLclampd zNear, GLclampd zFar) {
    typedef void (*__GLSdispatch)(GLclampd, GLclampd);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[352])(zNear, zFar);
}

void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[353])(left, right, bottom, top, zNear, zFar);
}

void glLoadIdentity(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[354])();
}

void glLoadMatrixf(const GLfloat *m) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[355])(m);
}

void glLoadMatrixd(const GLdouble *m) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[356])(m);
}

void glMatrixMode(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[357])(mode);
}

void glMultMatrixf(const GLfloat *m) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[358])(m);
}

void glMultMatrixd(const GLdouble *m) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[359])(m);
}

void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[360])(left, right, bottom, top, zNear, zFar);
}

void glPopMatrix(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[361])();
}

void glPushMatrix(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[362])();
}

void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[363])(angle, x, y, z);
}

void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[364])(angle, x, y, z);
}

void glScaled(GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[365])(x, y, z);
}

void glScalef(GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[366])(x, y, z);
}

void glTranslated(GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[367])(x, y, z);
}

void glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[368])(x, y, z);
}

void glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[369])(x, y, width, height);
}

void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
#if __GL_EXT_blend_color
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[384])(red, green, blue, alpha);
#endif /* __GL_EXT_blend_color */
}

void glBlendEquationEXT(GLenum mode) {
#if __GL_EXT_blend_minmax
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[385])(mode);
#endif /* __GL_EXT_blend_minmax */
}

void glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {
#if __GL_EXT_polygon_offset
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[386])(factor, bias);
#endif /* __GL_EXT_polygon_offset */
}

void glPolygonOffset(GLfloat factor, GLfloat bias) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[383])(factor, bias);
}

void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_EXT_subtexture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[387])(target, level, xoffset, width, format, type, pixels);
#endif /* __GL_EXT_subtexture */
}

void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[396])(target, level, xoffset, width, format, type, pixels);
}

void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_EXT_subtexture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[388])(target, level, xoffset, yoffset, width, height, format, type, pixels);
#endif /* __GL_EXT_subtexture */
}

void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[397])(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

void glSampleMaskSGIS(GLclampf value, GLboolean invert) {
#if __GL_SGIS_multisample
    typedef void (*__GLSdispatch)(GLclampf, GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[389])(value, invert);
#endif /* __GL_SGIS_multisample */
}

void glSamplePatternSGIS(GLenum pattern) {
#if __GL_SGIS_multisample
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[390])(pattern);
#endif /* __GL_SGIS_multisample */
}

void glTagSampleBufferSGIX(void) {
#if __GL_SGIX_multisample
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[391])();
#endif /* __GL_SGIX_multisample */
}

void glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[392])(target, internalformat, width, format, type, image);
#endif /* __GL_EXT_convolution */
}

void glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[393])(target, internalformat, width, height, format, type, image);
#endif /* __GL_EXT_convolution */
}

void glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[394])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[395])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[396])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[397])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[398])(target, internalformat, x, y, width);
#endif /* __GL_EXT_convolution */
}

void glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[399])(target, internalformat, x, y, width, height);
#endif /* __GL_EXT_convolution */
}

void glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[400])(target, format, type, image);
#endif /* __GL_EXT_convolution */
}

void glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[401])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[402])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[403])(target, format, type, row, column, span);
#endif /* __GL_EXT_convolution */
}

void glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[404])(target, internalformat, width, height, format, type, row, column);
#endif /* __GL_EXT_convolution */
}

void glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[405])(target, reset, format, type, values);
#endif /* __GL_EXT_histogram */
}

void glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[406])(target, pname, params);
#endif /* __GL_EXT_histogram */
}

void glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[407])(target, pname, params);
#endif /* __GL_EXT_histogram */
}

void glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[408])(target, reset, format, type, values);
#endif /* __GL_EXT_histogram */
}

void glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[409])(target, pname, params);
#endif /* __GL_EXT_histogram */
}

void glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[410])(target, pname, params);
#endif /* __GL_EXT_histogram */
}

void glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLenum, GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[411])(target, width, internalformat, sink);
#endif /* __GL_EXT_histogram */
}

void glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[412])(target, internalformat, sink);
#endif /* __GL_EXT_histogram */
}

void glResetHistogramEXT(GLenum target) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[413])(target);
#endif /* __GL_EXT_histogram */
}

void glResetMinmaxEXT(GLenum target) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[414])(target);
#endif /* __GL_EXT_histogram */
}

void glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_EXT_texture3D
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[415])(target, level, internalformat, width, height, depth, border, format, type, pixels);
#endif /* __GL_EXT_texture3D */
}

void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_EXT_subtexture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[416])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
#endif /* __GL_EXT_subtexture */
}

void glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
#if __GL_SGIS_detail_texture
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[417])(target, n, points);
#endif /* __GL_SGIS_detail_texture */
}

void glGetDetailTexFuncSGIS(GLenum target, GLfloat *points) {
#if __GL_SGIS_detail_texture
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[418])(target, points);
#endif /* __GL_SGIS_detail_texture */
}

void glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
#if __GL_SGIS_sharpen_texture
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[419])(target, n, points);
#endif /* __GL_SGIS_sharpen_texture */
}

void glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points) {
#if __GL_SGIS_sharpen_texture
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[420])(target, points);
#endif /* __GL_SGIS_sharpen_texture */
}

void glArrayElementEXT(GLint i) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[437])(i);
#endif /* __GL_EXT_vertex_array */
}

void glArrayElement(GLint i) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[370])(i);
}

void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[438])(size, type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[372])(size, type, stride, pointer);
}

void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[439])(mode, first, count);
#endif /* __GL_EXT_vertex_array */
}

void glDrawArrays(GLenum mode, GLint first, GLsizei count) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[374])(mode, first, count);
}

void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, const GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[440])(stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glEdgeFlagPointer(GLsizei stride, const GLboolean *pointer) {
    typedef void (*__GLSdispatch)(GLsizei, const GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[376])(stride, pointer);
}

void glGetPointervEXT(GLenum pname, GLvoid* *params) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[441])(pname, params);
#endif /* __GL_EXT_vertex_array */
}

void glGetPointerv(GLenum pname, GLvoid* *params) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[393])(pname, params);
}

void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[442])(type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[378])(type, stride, pointer);
}

void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[443])(type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[382])(type, stride, pointer);
}

void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[444])(size, type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[384])(size, type, stride, pointer);
}

void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[445])(size, type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[385])(size, type, stride, pointer);
}

GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences) {
#if __GL_EXT_texture_object
    typedef GLboolean (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[430])(n, textures, residences);
#else /* __GL_EXT_texture_object */
    return 0;
#endif /* __GL_EXT_texture_object */
}

GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences) {
    typedef GLboolean (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[386])(n, textures, residences);
}

void glBindTextureEXT(GLenum target, GLuint texture) {
#if __GL_EXT_texture_object
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[431])(target, texture);
#endif /* __GL_EXT_texture_object */
}

void glBindTexture(GLenum target, GLuint texture) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[371])(target, texture);
}

void glDeleteTexturesEXT(GLsizei n, const GLuint *textures) {
#if __GL_EXT_texture_object
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[432])(n, textures);
#endif /* __GL_EXT_texture_object */
}

void glDeleteTextures(GLsizei n, const GLuint *textures) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[391])(n, textures);
}

void glGenTexturesEXT(GLsizei n, GLuint *textures) {
#if __GL_EXT_texture_object
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[433])(n, textures);
#endif /* __GL_EXT_texture_object */
}

void glGenTextures(GLsizei n, GLuint *textures) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[392])(n, textures);
}

GLboolean glIsTextureEXT(GLuint texture) {
#if __GL_EXT_texture_object
    typedef GLboolean (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[434])(texture);
#else /* __GL_EXT_texture_object */
    return 0;
#endif /* __GL_EXT_texture_object */
}

GLboolean glIsTexture(GLuint texture) {
    typedef GLboolean (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[394])(texture);
}

void glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
#if __GL_EXT_texture_object
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[435])(n, textures, priorities);
#endif /* __GL_EXT_texture_object */
}

void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[395])(n, textures, priorities);
}

void glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table) {
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[452])(target, internalformat, width, format, type, table);
#endif /* __GL_EXT_paletted_texture */
}

void glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
#if __GL_SGI_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[437])(target, pname, params);
#endif /* __GL_SGI_color_table */
}

void glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
#if __GL_SGI_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[438])(target, pname, params);
#endif /* __GL_SGI_color_table */
}

void glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
#if __GL_SGI_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[439])(target, internalformat, x, y, width);
#endif /* __GL_SGI_color_table */
}

void glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table) {
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[456])(target, format, type, table);
#endif /* __GL_EXT_paletted_texture */
}

void glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[457])(target, pname, params);
#endif /* __GL_EXT_paletted_texture */
}

void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params) {
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[458])(target, pname, params);
#endif /* __GL_EXT_paletted_texture */
}

void glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_SGI_texture_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[443])(target, pname, params);
#endif /* __GL_SGI_texture_color_table */
}

void glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {
#if __GL_SGI_texture_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[444])(target, pname, params);
#endif /* __GL_SGI_texture_color_table */
}

void glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
#if __GL_SGI_texture_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[445])(target, pname, params);
#endif /* __GL_SGI_texture_color_table */
}

void glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
#if __GL_SGI_texture_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[446])(target, pname, params);
#endif /* __GL_SGI_texture_color_table */
}

void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[447])(target, level, internalformat, x, y, width, border);
#endif /* __GL_EXT_copy_texture */
}

void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[387])(target, level, internalformat, x, y, width, border);
}

void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[448])(target, level, internalformat, x, y, width, height, border);
#endif /* __GL_EXT_copy_texture */
}

void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[388])(target, level, internalformat, x, y, width, height, border);
}

void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[449])(target, level, xoffset, x, y, width);
#endif /* __GL_EXT_copy_texture */
}

void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[389])(target, level, xoffset, x, y, width);
}

void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[450])(target, level, xoffset, yoffset, x, y, width, height);
#endif /* __GL_EXT_copy_texture */
}

void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[390])(target, level, xoffset, yoffset, x, y, width, height);
}

void glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[451])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
#endif /* __GL_EXT_copy_texture */
}

void glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_SGIS_texture4D
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[452])(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
#endif /* __GL_SGIS_texture4D */
}

void glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_SGIS_texture4D
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[453])(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
#endif /* __GL_SGIS_texture4D */
}

void glPixelTexGenSGIX(GLenum mode) {
#if __GL_SGIX_pixel_texture
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[454])(mode);
#endif /* __GL_SGIX_pixel_texture */
}

void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
    typedef void (*__GLSdispatch)(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[375])(mode, count, type, indices);
}

void
glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
#if __GL_WIN_draw_range_elements
    glDrawElements( mode, count, type, indices );
#endif  // __GL_EXT_draw_range_elements
}

void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer)
{
    typedef void (*__GLSdispatch)(GLenum format, GLsizei stride, const GLvoid *pointer);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[381])(format, stride, pointer);
}

void glIndexub (GLubyte c)
{
    typedef void (*__GLSdispatch)(GLubyte c);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[379])(c);
}

void glIndexubv (const GLubyte *c)
{
    typedef void (*__GLSdispatch)(const GLubyte *c);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[380])(c);
}

void glEnableClientState (GLenum array)
{
    typedef void (*__GLSdispatch)(GLenum array);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[377])(array);
}

void glDisableClientState (GLenum array)
{
    typedef void (*__GLSdispatch)(GLenum array);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[373])(array);
}

void glColorSubTableEXT(GLenum target, GLuint start, GLsizei count,
                        GLenum format, GLenum type,
                        const GLvoid *data)
{
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum target, GLuint start, GLsizei count,
                                  GLenum format, GLenum type, const GLvoid *data);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[496])(target, start, count, format, type, data);
#endif // __GL_EXT_paletted_texture
}

void glPushClientAttrib(GLbitfield mask) {
    typedef void (*__GLSdispatch)(GLbitfield);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[398])(mask);
}

void glPopClientAttrib(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[399])();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_op.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

const GLbitfield __glsOpcodeAttrib[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GEN_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_REPLY_BIT | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    // DrewB - 1.1
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GEN_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    #if __GL_EXT_blend_color
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE | GLS_COMMAND_GEN_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_SGI_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_texture_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    #if __GL_EXT_paletted_texture
        // DrewB
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
        GLS_NONE,
    #else
        GLS_NONE,
        GLS_NONE,
    #endif
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
};

const GLubyte *const __glsOpcodeString[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("glsBeginGLS"),
    glsCSTR("glsBlock"),
    glsCSTR("glsCallStream"),
    glsCSTR("glsEndGLS"),
    glsCSTR("glsError"),
    glsCSTR("glsGLRC"),
    glsCSTR("glsGLRCLayer"),
    glsCSTR("glsHeaderGLRCi"),
    glsCSTR("glsHeaderLayerf"),
    glsCSTR("glsHeaderLayeri"),
    glsCSTR("glsHeaderf"),
    glsCSTR("glsHeaderfv"),
    glsCSTR("glsHeaderi"),
    glsCSTR("glsHeaderiv"),
    glsCSTR("glsHeaderubz"),
    glsCSTR("glsRequireExtension"),
    glsCSTR("glsUnsupportedCommand"),
    glsCSTR("glsAppRef"),
    glsCSTR("glsBeginObj"),
    glsCSTR("glsCharubz"),
    glsCSTR("glsComment"),
    glsCSTR("glsDisplayMapfv"),
    glsCSTR("glsEndObj"),
    glsCSTR("glsNumb"),
    glsCSTR("glsNumbv"),
    glsCSTR("glsNumd"),
    glsCSTR("glsNumdv"),
    glsCSTR("glsNumf"),
    glsCSTR("glsNumfv"),
    glsCSTR("glsNumi"),
    glsCSTR("glsNumiv"),
    glsCSTR("glsNuml"),
    glsCSTR("glsNumlv"),
    glsCSTR("glsNums"),
    glsCSTR("glsNumsv"),
    glsCSTR("glsNumub"),
    glsCSTR("glsNumubv"),
    glsCSTR("glsNumui"),
    glsCSTR("glsNumuiv"),
    glsCSTR("glsNumul"),
    glsCSTR("glsNumulv"),
    glsCSTR("glsNumus"),
    glsCSTR("glsNumusv"),
    glsCSTR("glsPad"),
    glsCSTR("glsSwapBuffers"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("glNewList"),
    glsCSTR("glEndList"),
    glsCSTR("glCallList"),
    glsCSTR("glCallLists"),
    glsCSTR("glDeleteLists"),
    glsCSTR("glGenLists"),
    glsCSTR("glListBase"),
    glsCSTR("glBegin"),
    glsCSTR("glBitmap"),
    glsCSTR("glColor3b"),
    glsCSTR("glColor3bv"),
    glsCSTR("glColor3d"),
    glsCSTR("glColor3dv"),
    glsCSTR("glColor3f"),
    glsCSTR("glColor3fv"),
    glsCSTR("glColor3i"),
    glsCSTR("glColor3iv"),
    glsCSTR("glColor3s"),
    glsCSTR("glColor3sv"),
    glsCSTR("glColor3ub"),
    glsCSTR("glColor3ubv"),
    glsCSTR("glColor3ui"),
    glsCSTR("glColor3uiv"),
    glsCSTR("glColor3us"),
    glsCSTR("glColor3usv"),
    glsCSTR("glColor4b"),
    glsCSTR("glColor4bv"),
    glsCSTR("glColor4d"),
    glsCSTR("glColor4dv"),
    glsCSTR("glColor4f"),
    glsCSTR("glColor4fv"),
    glsCSTR("glColor4i"),
    glsCSTR("glColor4iv"),
    glsCSTR("glColor4s"),
    glsCSTR("glColor4sv"),
    glsCSTR("glColor4ub"),
    glsCSTR("glColor4ubv"),
    glsCSTR("glColor4ui"),
    glsCSTR("glColor4uiv"),
    glsCSTR("glColor4us"),
    glsCSTR("glColor4usv"),
    glsCSTR("glEdgeFlag"),
    glsCSTR("glEdgeFlagv"),
    glsCSTR("glEnd"),
    glsCSTR("glIndexd"),
    glsCSTR("glIndexdv"),
    glsCSTR("glIndexf"),
    glsCSTR("glIndexfv"),
    glsCSTR("glIndexi"),
    glsCSTR("glIndexiv"),
    glsCSTR("glIndexs"),
    glsCSTR("glIndexsv"),
    glsCSTR("glNormal3b"),
    glsCSTR("glNormal3bv"),
    glsCSTR("glNormal3d"),
    glsCSTR("glNormal3dv"),
    glsCSTR("glNormal3f"),
    glsCSTR("glNormal3fv"),
    glsCSTR("glNormal3i"),
    glsCSTR("glNormal3iv"),
    glsCSTR("glNormal3s"),
    glsCSTR("glNormal3sv"),
    glsCSTR("glRasterPos2d"),
    glsCSTR("glRasterPos2dv"),
    glsCSTR("glRasterPos2f"),
    glsCSTR("glRasterPos2fv"),
    glsCSTR("glRasterPos2i"),
    glsCSTR("glRasterPos2iv"),
    glsCSTR("glRasterPos2s"),
    glsCSTR("glRasterPos2sv"),
    glsCSTR("glRasterPos3d"),
    glsCSTR("glRasterPos3dv"),
    glsCSTR("glRasterPos3f"),
    glsCSTR("glRasterPos3fv"),
    glsCSTR("glRasterPos3i"),
    glsCSTR("glRasterPos3iv"),
    glsCSTR("glRasterPos3s"),
    glsCSTR("glRasterPos3sv"),
    glsCSTR("glRasterPos4d"),
    glsCSTR("glRasterPos4dv"),
    glsCSTR("glRasterPos4f"),
    glsCSTR("glRasterPos4fv"),
    glsCSTR("glRasterPos4i"),
    glsCSTR("glRasterPos4iv"),
    glsCSTR("glRasterPos4s"),
    glsCSTR("glRasterPos4sv"),
    glsCSTR("glRectd"),
    glsCSTR("glRectdv"),
    glsCSTR("glRectf"),
    glsCSTR("glRectfv"),
    glsCSTR("glRecti"),
    glsCSTR("glRectiv"),
    glsCSTR("glRects"),
    glsCSTR("glRectsv"),
    glsCSTR("glTexCoord1d"),
    glsCSTR("glTexCoord1dv"),
    glsCSTR("glTexCoord1f"),
    glsCSTR("glTexCoord1fv"),
    glsCSTR("glTexCoord1i"),
    glsCSTR("glTexCoord1iv"),
    glsCSTR("glTexCoord1s"),
    glsCSTR("glTexCoord1sv"),
    glsCSTR("glTexCoord2d"),
    glsCSTR("glTexCoord2dv"),
    glsCSTR("glTexCoord2f"),
    glsCSTR("glTexCoord2fv"),
    glsCSTR("glTexCoord2i"),
    glsCSTR("glTexCoord2iv"),
    glsCSTR("glTexCoord2s"),
    glsCSTR("glTexCoord2sv"),
    glsCSTR("glTexCoord3d"),
    glsCSTR("glTexCoord3dv"),
    glsCSTR("glTexCoord3f"),
    glsCSTR("glTexCoord3fv"),
    glsCSTR("glTexCoord3i"),
    glsCSTR("glTexCoord3iv"),
    glsCSTR("glTexCoord3s"),
    glsCSTR("glTexCoord3sv"),
    glsCSTR("glTexCoord4d"),
    glsCSTR("glTexCoord4dv"),
    glsCSTR("glTexCoord4f"),
    glsCSTR("glTexCoord4fv"),
    glsCSTR("glTexCoord4i"),
    glsCSTR("glTexCoord4iv"),
    glsCSTR("glTexCoord4s"),
    glsCSTR("glTexCoord4sv"),
    glsCSTR("glVertex2d"),
    glsCSTR("glVertex2dv"),
    glsCSTR("glVertex2f"),
    glsCSTR("glVertex2fv"),
    glsCSTR("glVertex2i"),
    glsCSTR("glVertex2iv"),
    glsCSTR("glVertex2s"),
    glsCSTR("glVertex2sv"),
    glsCSTR("glVertex3d"),
    glsCSTR("glVertex3dv"),
    glsCSTR("glVertex3f"),
    glsCSTR("glVertex3fv"),
    glsCSTR("glVertex3i"),
    glsCSTR("glVertex3iv"),
    glsCSTR("glVertex3s"),
    glsCSTR("glVertex3sv"),
    glsCSTR("glVertex4d"),
    glsCSTR("glVertex4dv"),
    glsCSTR("glVertex4f"),
    glsCSTR("glVertex4fv"),
    glsCSTR("glVertex4i"),
    glsCSTR("glVertex4iv"),
    glsCSTR("glVertex4s"),
    glsCSTR("glVertex4sv"),
    glsCSTR("glClipPlane"),
    glsCSTR("glColorMaterial"),
    glsCSTR("glCullFace"),
    glsCSTR("glFogf"),
    glsCSTR("glFogfv"),
    glsCSTR("glFogi"),
    glsCSTR("glFogiv"),
    glsCSTR("glFrontFace"),
    glsCSTR("glHint"),
    glsCSTR("glLightf"),
    glsCSTR("glLightfv"),
    glsCSTR("glLighti"),
    glsCSTR("glLightiv"),
    glsCSTR("glLightModelf"),
    glsCSTR("glLightModelfv"),
    glsCSTR("glLightModeli"),
    glsCSTR("glLightModeliv"),
    glsCSTR("glLineStipple"),
    glsCSTR("glLineWidth"),
    glsCSTR("glMaterialf"),
    glsCSTR("glMaterialfv"),
    glsCSTR("glMateriali"),
    glsCSTR("glMaterialiv"),
    glsCSTR("glPointSize"),
    glsCSTR("glPolygonMode"),
    glsCSTR("glPolygonStipple"),
    glsCSTR("glScissor"),
    glsCSTR("glShadeModel"),
    glsCSTR("glTexParameterf"),
    glsCSTR("glTexParameterfv"),
    glsCSTR("glTexParameteri"),
    glsCSTR("glTexParameteriv"),
    glsCSTR("glTexImage1D"),
    glsCSTR("glTexImage2D"),
    glsCSTR("glTexEnvf"),
    glsCSTR("glTexEnvfv"),
    glsCSTR("glTexEnvi"),
    glsCSTR("glTexEnviv"),
    glsCSTR("glTexGend"),
    glsCSTR("glTexGendv"),
    glsCSTR("glTexGenf"),
    glsCSTR("glTexGenfv"),
    glsCSTR("glTexGeni"),
    glsCSTR("glTexGeniv"),
    glsCSTR("glFeedbackBuffer"),
    glsCSTR("glSelectBuffer"),
    glsCSTR("glRenderMode"),
    glsCSTR("glInitNames"),
    glsCSTR("glLoadName"),
    glsCSTR("glPassThrough"),
    glsCSTR("glPopName"),
    glsCSTR("glPushName"),
    glsCSTR("glDrawBuffer"),
    glsCSTR("glClear"),
    glsCSTR("glClearAccum"),
    glsCSTR("glClearIndex"),
    glsCSTR("glClearColor"),
    glsCSTR("glClearStencil"),
    glsCSTR("glClearDepth"),
    glsCSTR("glStencilMask"),
    glsCSTR("glColorMask"),
    glsCSTR("glDepthMask"),
    glsCSTR("glIndexMask"),
    glsCSTR("glAccum"),
    glsCSTR("glDisable"),
    glsCSTR("glEnable"),
    glsCSTR("glFinish"),
    glsCSTR("glFlush"),
    glsCSTR("glPopAttrib"),
    glsCSTR("glPushAttrib"),
    glsCSTR("glMap1d"),
    glsCSTR("glMap1f"),
    glsCSTR("glMap2d"),
    glsCSTR("glMap2f"),
    glsCSTR("glMapGrid1d"),
    glsCSTR("glMapGrid1f"),
    glsCSTR("glMapGrid2d"),
    glsCSTR("glMapGrid2f"),
    glsCSTR("glEvalCoord1d"),
    glsCSTR("glEvalCoord1dv"),
    glsCSTR("glEvalCoord1f"),
    glsCSTR("glEvalCoord1fv"),
    glsCSTR("glEvalCoord2d"),
    glsCSTR("glEvalCoord2dv"),
    glsCSTR("glEvalCoord2f"),
    glsCSTR("glEvalCoord2fv"),
    glsCSTR("glEvalMesh1"),
    glsCSTR("glEvalPoint1"),
    glsCSTR("glEvalMesh2"),
    glsCSTR("glEvalPoint2"),
    glsCSTR("glAlphaFunc"),
    glsCSTR("glBlendFunc"),
    glsCSTR("glLogicOp"),
    glsCSTR("glStencilFunc"),
    glsCSTR("glStencilOp"),
    glsCSTR("glDepthFunc"),
    glsCSTR("glPixelZoom"),
    glsCSTR("glPixelTransferf"),
    glsCSTR("glPixelTransferi"),
    glsCSTR("glPixelStoref"),
    glsCSTR("glPixelStorei"),
    glsCSTR("glPixelMapfv"),
    glsCSTR("glPixelMapuiv"),
    glsCSTR("glPixelMapusv"),
    glsCSTR("glReadBuffer"),
    glsCSTR("glCopyPixels"),
    glsCSTR("glReadPixels"),
    glsCSTR("glDrawPixels"),
    glsCSTR("glGetBooleanv"),
    glsCSTR("glGetClipPlane"),
    glsCSTR("glGetDoublev"),
    glsCSTR("glGetError"),
    glsCSTR("glGetFloatv"),
    glsCSTR("glGetIntegerv"),
    glsCSTR("glGetLightfv"),
    glsCSTR("glGetLightiv"),
    glsCSTR("glGetMapdv"),
    glsCSTR("glGetMapfv"),
    glsCSTR("glGetMapiv"),
    glsCSTR("glGetMaterialfv"),
    glsCSTR("glGetMaterialiv"),
    glsCSTR("glGetPixelMapfv"),
    glsCSTR("glGetPixelMapuiv"),
    glsCSTR("glGetPixelMapusv"),
    glsCSTR("glGetPolygonStipple"),
    glsCSTR("glGetString"),
    glsCSTR("glGetTexEnvfv"),
    glsCSTR("glGetTexEnviv"),
    glsCSTR("glGetTexGendv"),
    glsCSTR("glGetTexGenfv"),
    glsCSTR("glGetTexGeniv"),
    glsCSTR("glGetTexImage"),
    glsCSTR("glGetTexParameterfv"),
    glsCSTR("glGetTexParameteriv"),
    glsCSTR("glGetTexLevelParameterfv"),
    glsCSTR("glGetTexLevelParameteriv"),
    glsCSTR("glIsEnabled"),
    glsCSTR("glIsList"),
    glsCSTR("glDepthRange"),
    glsCSTR("glFrustum"),
    glsCSTR("glLoadIdentity"),
    glsCSTR("glLoadMatrixf"),
    glsCSTR("glLoadMatrixd"),
    glsCSTR("glMatrixMode"),
    glsCSTR("glMultMatrixf"),
    glsCSTR("glMultMatrixd"),
    glsCSTR("glOrtho"),
    glsCSTR("glPopMatrix"),
    glsCSTR("glPushMatrix"),
    glsCSTR("glRotated"),
    glsCSTR("glRotatef"),
    glsCSTR("glScaled"),
    glsCSTR("glScalef"),
    glsCSTR("glTranslated"),
    glsCSTR("glTranslatef"),
    glsCSTR("glViewport"),
    glsCSTR("glArrayElement"),
    glsCSTR("glBindTexture"),
    glsCSTR("glColorPointer"),
    glsCSTR("glDisableClientState"),
    glsCSTR("glDrawArrays"),
    glsCSTR("glDrawElements"),
    glsCSTR("glEdgeFlagPointer"),
    glsCSTR("glEnableClientState"),
    glsCSTR("glIndexPointer"),
    glsCSTR("glIndexub"),
    glsCSTR("glIndexubv"),
    glsCSTR("glInterleavedArrays"),
    glsCSTR("glNormalPointer"),
    glsCSTR("glPolygonOffset"),
    glsCSTR("glTexCoordPointer"),
    glsCSTR("glVertexPointer"),
    glsCSTR("glAreTexturesResident"),
    glsCSTR("glCopyTexImage1D"),
    glsCSTR("glCopyTexImage2D"),
    glsCSTR("glCopyTexSubImage1D"),
    glsCSTR("glCopyTexSubImage2D"),
    glsCSTR("glDeleteTextures"),
    glsCSTR("glGenTextures"),
    glsCSTR("glGetPointerv"),
    glsCSTR("glIsTexture"),
    glsCSTR("glPrioritizeTextures"),
    glsCSTR("glTexSubImage1D"),
    glsCSTR("glTexSubImage2D"),
    glsCSTR("glPushClientAttrib"),
    glsCSTR("glPopClientAttrib"),
    #if __GL_EXT_blend_color
        glsCSTR("glBlendColorEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        glsCSTR("glBlendEquationEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        glsCSTR("glPolygonOffsetEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        glsCSTR("glTexSubImage1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        glsCSTR("glTexSubImage2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        glsCSTR("glSampleMaskSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        glsCSTR("glSamplePatternSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        glsCSTR("glTagSampleBufferSGIX"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionFilter1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionFilter2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionParameterfEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionParameteriEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glCopyConvolutionFilter1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glCopyConvolutionFilter2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glGetConvolutionFilterEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glGetConvolutionParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glGetConvolutionParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glGetSeparableFilterEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glSeparableFilter2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        glsCSTR("glGetHistogramEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetHistogramParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetHistogramParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetMinmaxEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetMinmaxParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetMinmaxParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glHistogramEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glMinmaxEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glResetHistogramEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glResetMinmaxEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        glsCSTR("glTexImage3DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        glsCSTR("glTexSubImage3DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        glsCSTR("glDetailTexFuncSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        glsCSTR("glGetDetailTexFuncSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        glsCSTR("glSharpenTexFuncSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        glsCSTR("glGetSharpenTexFuncSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        glsCSTR("glArrayElementEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glColorPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glDrawArraysEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glEdgeFlagPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glGetPointervEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glIndexPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glNormalPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glTexCoordPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glVertexPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        glsCSTR("glAreTexturesResidentEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glBindTextureEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glDeleteTexturesEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glGenTexturesEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glIsTextureEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glPrioritizeTexturesEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        glsCSTR("glColorTableEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        glsCSTR("glColorTableParameterfvSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        glsCSTR("glColorTableParameterivSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        glsCSTR("glCopyColorTableSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        glsCSTR("glGetColorTableEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        glsCSTR("glGetColorTableParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        glsCSTR("glGetColorTableParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        glsCSTR("glGetTexColorTableParameterfvSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        glsCSTR("glGetTexColorTableParameterivSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        glsCSTR("glTexColorTableParameterfvSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        glsCSTR("glTexColorTableParameterivSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexImage1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexImage2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexSubImage1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexSubImage2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexSubImage3DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        glsCSTR("glTexImage4DSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        glsCSTR("glTexSubImage4DSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        glsCSTR("glPixelTexGenSGIX"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        // DrewB
        glsCSTR("glColorSubTableEXT"),
    #else
        GLS_NONE,
        GLS_NONE,
    #endif
};

const GLSopcode __glsOpcodesGLS[] = {
    GLS_OP_glsBeginGLS,
    GLS_OP_glsBlock,
    GLS_OP_glsCallStream,
    GLS_OP_glsEndGLS,
    GLS_OP_glsError,
    GLS_OP_glsGLRC,
    GLS_OP_glsGLRCLayer,
    GLS_OP_glsHeaderGLRCi,
    GLS_OP_glsHeaderLayerf,
    GLS_OP_glsHeaderLayeri,
    GLS_OP_glsHeaderf,
    GLS_OP_glsHeaderfv,
    GLS_OP_glsHeaderi,
    GLS_OP_glsHeaderiv,
    GLS_OP_glsHeaderubz,
    GLS_OP_glsRequireExtension,
    GLS_OP_glsUnsupportedCommand,
    GLS_OP_glsAppRef,
    GLS_OP_glsBeginObj,
    GLS_OP_glsCharubz,
    GLS_OP_glsComment,
    GLS_OP_glsDisplayMapfv,
    GLS_OP_glsEndObj,
    GLS_OP_glsNumb,
    GLS_OP_glsNumbv,
    GLS_OP_glsNumd,
    GLS_OP_glsNumdv,
    GLS_OP_glsNumf,
    GLS_OP_glsNumfv,
    GLS_OP_glsNumi,
    GLS_OP_glsNumiv,
    GLS_OP_glsNuml,
    GLS_OP_glsNumlv,
    GLS_OP_glsNums,
    GLS_OP_glsNumsv,
    GLS_OP_glsNumub,
    GLS_OP_glsNumubv,
    GLS_OP_glsNumui,
    GLS_OP_glsNumuiv,
    GLS_OP_glsNumul,
    GLS_OP_glsNumulv,
    GLS_OP_glsNumus,
    GLS_OP_glsNumusv,
    GLS_OP_glsPad,
    GLS_OP_glsSwapBuffers,
    GLS_NONE
};

const GLSopcode __glsOpcodesGL[] = {
    GLS_OP_glNewList,
    GLS_OP_glEndList,
    GLS_OP_glCallList,
    GLS_OP_glCallLists,
    GLS_OP_glDeleteLists,
    GLS_OP_glGenLists,
    GLS_OP_glListBase,
    GLS_OP_glBegin,
    GLS_OP_glBitmap,
    GLS_OP_glColor3b,
    GLS_OP_glColor3bv,
    GLS_OP_glColor3d,
    GLS_OP_glColor3dv,
    GLS_OP_glColor3f,
    GLS_OP_glColor3fv,
    GLS_OP_glColor3i,
    GLS_OP_glColor3iv,
    GLS_OP_glColor3s,
    GLS_OP_glColor3sv,
    GLS_OP_glColor3ub,
    GLS_OP_glColor3ubv,
    GLS_OP_glColor3ui,
    GLS_OP_glColor3uiv,
    GLS_OP_glColor3us,
    GLS_OP_glColor3usv,
    GLS_OP_glColor4b,
    GLS_OP_glColor4bv,
    GLS_OP_glColor4d,
    GLS_OP_glColor4dv,
    GLS_OP_glColor4f,
    GLS_OP_glColor4fv,
    GLS_OP_glColor4i,
    GLS_OP_glColor4iv,
    GLS_OP_glColor4s,
    GLS_OP_glColor4sv,
    GLS_OP_glColor4ub,
    GLS_OP_glColor4ubv,
    GLS_OP_glColor4ui,
    GLS_OP_glColor4uiv,
    GLS_OP_glColor4us,
    GLS_OP_glColor4usv,
    GLS_OP_glEdgeFlag,
    GLS_OP_glEdgeFlagv,
    GLS_OP_glEnd,
    GLS_OP_glIndexd,
    GLS_OP_glIndexdv,
    GLS_OP_glIndexf,
    GLS_OP_glIndexfv,
    GLS_OP_glIndexi,
    GLS_OP_glIndexiv,
    GLS_OP_glIndexs,
    GLS_OP_glIndexsv,
    GLS_OP_glNormal3b,
    GLS_OP_glNormal3bv,
    GLS_OP_glNormal3d,
    GLS_OP_glNormal3dv,
    GLS_OP_glNormal3f,
    GLS_OP_glNormal3fv,
    GLS_OP_glNormal3i,
    GLS_OP_glNormal3iv,
    GLS_OP_glNormal3s,
    GLS_OP_glNormal3sv,
    GLS_OP_glRasterPos2d,
    GLS_OP_glRasterPos2dv,
    GLS_OP_glRasterPos2f,
    GLS_OP_glRasterPos2fv,
    GLS_OP_glRasterPos2i,
    GLS_OP_glRasterPos2iv,
    GLS_OP_glRasterPos2s,
    GLS_OP_glRasterPos2sv,
    GLS_OP_glRasterPos3d,
    GLS_OP_glRasterPos3dv,
    GLS_OP_glRasterPos3f,
    GLS_OP_glRasterPos3fv,
    GLS_OP_glRasterPos3i,
    GLS_OP_glRasterPos3iv,
    GLS_OP_glRasterPos3s,
    GLS_OP_glRasterPos3sv,
    GLS_OP_glRasterPos4d,
    GLS_OP_glRasterPos4dv,
    GLS_OP_glRasterPos4f,
    GLS_OP_glRasterPos4fv,
    GLS_OP_glRasterPos4i,
    GLS_OP_glRasterPos4iv,
    GLS_OP_glRasterPos4s,
    GLS_OP_glRasterPos4sv,
    GLS_OP_glRectd,
    GLS_OP_glRectdv,
    GLS_OP_glRectf,
    GLS_OP_glRectfv,
    GLS_OP_glRecti,
    GLS_OP_glRectiv,
    GLS_OP_glRects,
    GLS_OP_glRectsv,
    GLS_OP_glTexCoord1d,
    GLS_OP_glTexCoord1dv,
    GLS_OP_glTexCoord1f,
    GLS_OP_glTexCoord1fv,
    GLS_OP_glTexCoord1i,
    GLS_OP_glTexCoord1iv,
    GLS_OP_glTexCoord1s,
    GLS_OP_glTexCoord1sv,
    GLS_OP_glTexCoord2d,
    GLS_OP_glTexCoord2dv,
    GLS_OP_glTexCoord2f,
    GLS_OP_glTexCoord2fv,
    GLS_OP_glTexCoord2i,
    GLS_OP_glTexCoord2iv,
    GLS_OP_glTexCoord2s,
    GLS_OP_glTexCoord2sv,
    GLS_OP_glTexCoord3d,
    GLS_OP_glTexCoord3dv,
    GLS_OP_glTexCoord3f,
    GLS_OP_glTexCoord3fv,
    GLS_OP_glTexCoord3i,
    GLS_OP_glTexCoord3iv,
    GLS_OP_glTexCoord3s,
    GLS_OP_glTexCoord3sv,
    GLS_OP_glTexCoord4d,
    GLS_OP_glTexCoord4dv,
    GLS_OP_glTexCoord4f,
    GLS_OP_glTexCoord4fv,
    GLS_OP_glTexCoord4i,
    GLS_OP_glTexCoord4iv,
    GLS_OP_glTexCoord4s,
    GLS_OP_glTexCoord4sv,
    GLS_OP_glVertex2d,
    GLS_OP_glVertex2dv,
    GLS_OP_glVertex2f,
    GLS_OP_glVertex2fv,
    GLS_OP_glVertex2i,
    GLS_OP_glVertex2iv,
    GLS_OP_glVertex2s,
    GLS_OP_glVertex2sv,
    GLS_OP_glVertex3d,
    GLS_OP_glVertex3dv,
    GLS_OP_glVertex3f,
    GLS_OP_glVertex3fv,
    GLS_OP_glVertex3i,
    GLS_OP_glVertex3iv,
    GLS_OP_glVertex3s,
    GLS_OP_glVertex3sv,
    GLS_OP_glVertex4d,
    GLS_OP_glVertex4dv,
    GLS_OP_glVertex4f,
    GLS_OP_glVertex4fv,
    GLS_OP_glVertex4i,
    GLS_OP_glVertex4iv,
    GLS_OP_glVertex4s,
    GLS_OP_glVertex4sv,
    GLS_OP_glClipPlane,
    GLS_OP_glColorMaterial,
    GLS_OP_glCullFace,
    GLS_OP_glFogf,
    GLS_OP_glFogfv,
    GLS_OP_glFogi,
    GLS_OP_glFogiv,
    GLS_OP_glFrontFace,
    GLS_OP_glHint,
    GLS_OP_glLightf,
    GLS_OP_glLightfv,
    GLS_OP_glLighti,
    GLS_OP_glLightiv,
    GLS_OP_glLightModelf,
    GLS_OP_glLightModelfv,
    GLS_OP_glLightModeli,
    GLS_OP_glLightModeliv,
    GLS_OP_glLineStipple,
    GLS_OP_glLineWidth,
    GLS_OP_glMaterialf,
    GLS_OP_glMaterialfv,
    GLS_OP_glMateriali,
    GLS_OP_glMaterialiv,
    GLS_OP_glPointSize,
    GLS_OP_glPolygonMode,
    GLS_OP_glPolygonStipple,
    GLS_OP_glScissor,
    GLS_OP_glShadeModel,
    GLS_OP_glTexParameterf,
    GLS_OP_glTexParameterfv,
    GLS_OP_glTexParameteri,
    GLS_OP_glTexParameteriv,
    GLS_OP_glTexImage1D,
    GLS_OP_glTexImage2D,
    GLS_OP_glTexEnvf,
    GLS_OP_glTexEnvfv,
    GLS_OP_glTexEnvi,
    GLS_OP_glTexEnviv,
    GLS_OP_glTexGend,
    GLS_OP_glTexGendv,
    GLS_OP_glTexGenf,
    GLS_OP_glTexGenfv,
    GLS_OP_glTexGeni,
    GLS_OP_glTexGeniv,
    GLS_OP_glFeedbackBuffer,
    GLS_OP_glSelectBuffer,
    GLS_OP_glRenderMode,
    GLS_OP_glInitNames,
    GLS_OP_glLoadName,
    GLS_OP_glPassThrough,
    GLS_OP_glPopName,
    GLS_OP_glPushName,
    GLS_OP_glDrawBuffer,
    GLS_OP_glClear,
    GLS_OP_glClearAccum,
    GLS_OP_glClearIndex,
    GLS_OP_glClearColor,
    GLS_OP_glClearStencil,
    GLS_OP_glClearDepth,
    GLS_OP_glStencilMask,
    GLS_OP_glColorMask,
    GLS_OP_glDepthMask,
    GLS_OP_glIndexMask,
    GLS_OP_glAccum,
    GLS_OP_glDisable,
    GLS_OP_glEnable,
    GLS_OP_glFinish,
    GLS_OP_glFlush,
    GLS_OP_glPopAttrib,
    GLS_OP_glPushAttrib,
    GLS_OP_glMap1d,
    GLS_OP_glMap1f,
    GLS_OP_glMap2d,
    GLS_OP_glMap2f,
    GLS_OP_glMapGrid1d,
    GLS_OP_glMapGrid1f,
    GLS_OP_glMapGrid2d,
    GLS_OP_glMapGrid2f,
    GLS_OP_glEvalCoord1d,
    GLS_OP_glEvalCoord1dv,
    GLS_OP_glEvalCoord1f,
    GLS_OP_glEvalCoord1fv,
    GLS_OP_glEvalCoord2d,
    GLS_OP_glEvalCoord2dv,
    GLS_OP_glEvalCoord2f,
    GLS_OP_glEvalCoord2fv,
    GLS_OP_glEvalMesh1,
    GLS_OP_glEvalPoint1,
    GLS_OP_glEvalMesh2,
    GLS_OP_glEvalPoint2,
    GLS_OP_glAlphaFunc,
    GLS_OP_glBlendFunc,
    GLS_OP_glLogicOp,
    GLS_OP_glStencilFunc,
    GLS_OP_glStencilOp,
    GLS_OP_glDepthFunc,
    GLS_OP_glPixelZoom,
    GLS_OP_glPixelTransferf,
    GLS_OP_glPixelTransferi,
    GLS_OP_glPixelStoref,
    GLS_OP_glPixelStorei,
    GLS_OP_glPixelMapfv,
    GLS_OP_glPixelMapuiv,
    GLS_OP_glPixelMapusv,
    GLS_OP_glReadBuffer,
    GLS_OP_glCopyPixels,
    GLS_OP_glReadPixels,
    GLS_OP_glDrawPixels,
    GLS_OP_glGetBooleanv,
    GLS_OP_glGetClipPlane,
    GLS_OP_glGetDoublev,
    GLS_OP_glGetError,
    GLS_OP_glGetFloatv,
    GLS_OP_glGetIntegerv,
    GLS_OP_glGetLightfv,
    GLS_OP_glGetLightiv,
    GLS_OP_glGetMapdv,
    GLS_OP_glGetMapfv,
    GLS_OP_glGetMapiv,
    GLS_OP_glGetMaterialfv,
    GLS_OP_glGetMaterialiv,
    GLS_OP_glGetPixelMapfv,
    GLS_OP_glGetPixelMapuiv,
    GLS_OP_glGetPixelMapusv,
    GLS_OP_glGetPolygonStipple,
    GLS_OP_glGetString,
    GLS_OP_glGetTexEnvfv,
    GLS_OP_glGetTexEnviv,
    GLS_OP_glGetTexGendv,
    GLS_OP_glGetTexGenfv,
    GLS_OP_glGetTexGeniv,
    GLS_OP_glGetTexImage,
    GLS_OP_glGetTexParameterfv,
    GLS_OP_glGetTexParameteriv,
    GLS_OP_glGetTexLevelParameterfv,
    GLS_OP_glGetTexLevelParameteriv,
    GLS_OP_glIsEnabled,
    GLS_OP_glIsList,
    GLS_OP_glDepthRange,
    GLS_OP_glFrustum,
    GLS_OP_glLoadIdentity,
    GLS_OP_glLoadMatrixf,
    GLS_OP_glLoadMatrixd,
    GLS_OP_glMatrixMode,
    GLS_OP_glMultMatrixf,
    GLS_OP_glMultMatrixd,
    GLS_OP_glOrtho,
    GLS_OP_glPopMatrix,
    GLS_OP_glPushMatrix,
    GLS_OP_glRotated,
    GLS_OP_glRotatef,
    GLS_OP_glScaled,
    GLS_OP_glScalef,
    GLS_OP_glTranslated,
    GLS_OP_glTranslatef,
    GLS_OP_glViewport,
    GLS_OP_glArrayElement,
    GLS_OP_glBindTexture,
    GLS_OP_glColorPointer,
    GLS_OP_glDisableClientState,
    GLS_OP_glDrawArrays,
    GLS_OP_glDrawElements,
    GLS_OP_glEdgeFlagPointer,
    GLS_OP_glEnableClientState,
    GLS_OP_glIndexPointer,
    GLS_OP_glIndexub,
    GLS_OP_glIndexubv,
    GLS_OP_glInterleavedArrays,
    GLS_OP_glNormalPointer,
    GLS_OP_glPolygonOffset,
    GLS_OP_glTexCoordPointer,
    GLS_OP_glVertexPointer,
    GLS_OP_glAreTexturesResident,
    GLS_OP_glCopyTexImage1D,
    GLS_OP_glCopyTexImage2D,
    GLS_OP_glCopyTexSubImage1D,
    GLS_OP_glCopyTexSubImage2D,
    GLS_OP_glDeleteTextures,
    GLS_OP_glGenTextures,
    GLS_OP_glGetPointerv,
    GLS_OP_glIsTexture,
    GLS_OP_glPrioritizeTextures,
    GLS_OP_glTexSubImage1D,
    GLS_OP_glTexSubImage2D,
    GLS_OP_glPushClientAttrib,
    GLS_OP_glPopClientAttrib,
    #if __GL_EXT_blend_color
        GLS_OP_glBlendColorEXT,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        GLS_OP_glBlendEquationEXT,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        GLS_OP_glPolygonOffsetEXT,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        GLS_OP_glTexSubImage1DEXT,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        GLS_OP_glTexSubImage2DEXT,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        GLS_OP_glSampleMaskSGIS,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        GLS_OP_glSamplePatternSGIS,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        GLS_OP_glTagSampleBufferSGIX,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionFilter1DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionFilter2DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionParameterfEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionParameterfvEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionParameteriEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionParameterivEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glCopyConvolutionFilter1DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glCopyConvolutionFilter2DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glGetConvolutionFilterEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glGetConvolutionParameterfvEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glGetConvolutionParameterivEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glGetSeparableFilterEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glSeparableFilter2DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        GLS_OP_glGetHistogramEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetHistogramParameterfvEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetHistogramParameterivEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetMinmaxEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetMinmaxParameterfvEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetMinmaxParameterivEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glHistogramEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glMinmaxEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glResetHistogramEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glResetMinmaxEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        GLS_OP_glTexImage3DEXT,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        GLS_OP_glTexSubImage3DEXT,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        GLS_OP_glDetailTexFuncSGIS,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        GLS_OP_glGetDetailTexFuncSGIS,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        GLS_OP_glSharpenTexFuncSGIS,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        GLS_OP_glGetSharpenTexFuncSGIS,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        GLS_OP_glArrayElementEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glColorPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glDrawArraysEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glEdgeFlagPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glGetPointervEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glIndexPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glNormalPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glTexCoordPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glVertexPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        GLS_OP_glAreTexturesResidentEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glBindTextureEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glDeleteTexturesEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glGenTexturesEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glIsTextureEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glPrioritizeTexturesEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        GLS_OP_glColorTableEXT,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        GLS_OP_glColorTableParameterfvSGI,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_OP_glColorTableParameterivSGI,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_OP_glCopyColorTableSGI,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        GLS_OP_glGetColorTableEXT,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        GLS_OP_glGetColorTableParameterfvEXT,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        GLS_OP_glGetColorTableParameterivEXT,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        GLS_OP_glGetTexColorTableParameterfvSGI,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_OP_glGetTexColorTableParameterivSGI,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_OP_glTexColorTableParameterfvSGI,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_OP_glTexColorTableParameterivSGI,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexImage1DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexImage2DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexSubImage1DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexSubImage2DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexSubImage3DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        GLS_OP_glTexImage4DSGIS,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        GLS_OP_glTexSubImage4DSGIS,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        GLS_OP_glPixelTexGenSGIX,
    #endif /* __GL_SGIX_pixel_texture */
    #if __GL_EXT_paletted_texture
        // DrewB
        GLS_OP_glColorSubTableEXT,
    #endif
    GLS_NONE
};

const GLint __glsOpcodesGLSCount = (
    45
);

const GLint __glsOpcodesGLCount = (
    #if __GL_EXT_blend_color
        1 +
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        1 +
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        1 +
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        1 +
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        1 +
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        1 +
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        1 +
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        1 +
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        1 +
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        1 +
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        1 +
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        1 +
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        1 +
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        1 +
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        1 +
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        1 +
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        1 +
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        1 +
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        1 +
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        1 +
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        1 +
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        1 +
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        1 +
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        1 +
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        1 +
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        1 +
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        1 +
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        1 +
    #endif /* __GL_SGIX_pixel_texture */
    #if __GL_EXT_paletted_texture
        // DrewB
        1 +
    #endif
    // DrewB - 1.1
    336
);

const GLint __glsOpPageMap[__GLS_MAPPED_OPCODE_PAGE_COUNT] = {
    4095,
    4094,
    4093,
    4092,
    4091,
    4090,
    4089,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_glsapi.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[16])(inVersionMajor, inVersionMinor);
}

void glsBlock(GLSenum inBlockType) {
    typedef void (*__GLSdispatch)(GLSenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[17])(inBlockType);
}

GLSenum glsCallStream(const GLubyte *inName) {
    typedef GLSenum (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return 0;
    return ((__GLSdispatch)__glsCtx->dispatchAPI[18])(inName);
}

void glsEndGLS(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[19])();
}

void glsError(GLSopcode inOpcode, GLSenum inError) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[20])(inOpcode, inError);
}

void glsGLRC(GLuint inGLRC) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[21])(inGLRC);
}

void glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[22])(inGLRC, inLayer, inReadLayer);
}

void glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[23])(inGLRC, inAttrib, inVal);
}

void glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[24])(inLayer, inAttrib, inVal);
}

void glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[25])(inLayer, inAttrib, inVal);
}

void glsHeaderf(GLSenum inAttrib, GLfloat inVal) {
    typedef void (*__GLSdispatch)(GLSenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[26])(inAttrib, inVal);
}

void glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec) {
    typedef void (*__GLSdispatch)(GLSenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[27])(inAttrib, inVec);
}

void glsHeaderi(GLSenum inAttrib, GLint inVal) {
    typedef void (*__GLSdispatch)(GLSenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[28])(inAttrib, inVal);
}

void glsHeaderiv(GLSenum inAttrib, const GLint *inVec) {
    typedef void (*__GLSdispatch)(GLSenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[29])(inAttrib, inVec);
}

void glsHeaderubz(GLSenum inAttrib, const GLubyte *inString) {
    typedef void (*__GLSdispatch)(GLSenum, const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[30])(inAttrib, inString);
}

void glsRequireExtension(const GLubyte *inExtension) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[31])(inExtension);
}

void glsUnsupportedCommand(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[32])();
}

void glsAppRef(GLulong inAddress, GLuint inCount) {
    typedef void (*__GLSdispatch)(GLulong, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[33])(inAddress, inCount);
}

void glsBeginObj(const GLubyte *inTag) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[34])(inTag);
}

void glsCharubz(const GLubyte *inTag, const GLubyte *inString) {
    typedef void (*__GLSdispatch)(const GLubyte *, const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[35])(inTag, inString);
}

void glsComment(const GLubyte *inComment) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[36])(inComment);
}

void glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLuint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[37])(inLayer, inMap, inCount, inVec);
}

void glsEndObj(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[38])();
}

void glsNumb(const GLubyte *inTag, GLbyte inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLbyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[39])(inTag, inVal);
}

void glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLbyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[40])(inTag, inCount, inVec);
}

void glsNumd(const GLubyte *inTag, GLdouble inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[41])(inTag, inVal);
}

void glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[42])(inTag, inCount, inVec);
}

void glsNumf(const GLubyte *inTag, GLfloat inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[43])(inTag, inVal);
}

void glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[44])(inTag, inCount, inVec);
}

void glsNumi(const GLubyte *inTag, GLint inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[45])(inTag, inVal);
}

void glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[46])(inTag, inCount, inVec);
}

void glsNuml(const GLubyte *inTag, GLlong inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLlong);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[47])(inTag, inVal);
}

void glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLlong *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[48])(inTag, inCount, inVec);
}

void glsNums(const GLubyte *inTag, GLshort inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[49])(inTag, inVal);
}

void glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[50])(inTag, inCount, inVec);
}

void glsNumub(const GLubyte *inTag, GLubyte inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLubyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[51])(inTag, inVal);
}

void glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[52])(inTag, inCount, inVec);
}

void glsNumui(const GLubyte *inTag, GLuint inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[53])(inTag, inVal);
}

void glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[54])(inTag, inCount, inVec);
}

void glsNumul(const GLubyte *inTag, GLulong inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLulong);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[55])(inTag, inVal);
}

void glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLulong *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[56])(inTag, inCount, inVec);
}

void glsNumus(const GLubyte *inTag, GLushort inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLushort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[57])(inTag, inVal);
}

void glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[58])(inTag, inCount, inVec);
}

void glsPad(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[59])();
}

void glsSwapBuffers(GLuint inLayer) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[60])(inLayer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\immed.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

static GLboolean __glsRequireContext(void) {
    if (__GLS_CONTEXT) {
        return GL_TRUE;
    } else {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return GL_FALSE;
    }
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
void glsAbortCall(GLSenum inMode) {
    if (!__glsRequireContext()) return;
    switch (inMode) {
        case GLS_NONE:
        case GLS_LAST:
        case GLS_ALL:
            __GLS_CONTEXT->abortMode = inMode;
            __glsContext_updateDispatchDecode_bin(__GLS_CONTEXT);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}
#else
void __glsInternalAbortCall(__GLScontext *ctx, GLSenum inMode) {
    switch (inMode) {
    case GLS_NONE:
    case GLS_LAST:
    case GLS_ALL:
        ctx->abortMode = inMode;
        __glsContext_updateDispatchDecode_bin(ctx);
        break;
    default:
        __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
        break;
    }
}
void glsAbortCall(GLSenum inMode) {
    if (!__glsRequireContext()) return;
    __glsInternalAbortCall(__GLS_CONTEXT, inMode);
}
#endif

GLboolean glsBeginCapture(
    const GLubyte *inStreamName,
    GLSenum inCaptureStreamType,
    GLbitfield inWriteFlags
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;

    if (!__glsRequireContext()) return GL_FALSE;
    if (ctx->captureNesting >= __GLS_MAX_CAPTURE_NESTING) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return GL_FALSE;
    }
    if (!__glsValidateString(inStreamName)) return GL_FALSE;
    switch (inCaptureStreamType) {
        case GLS_CONTEXT:
        case GLS_BINARY_LSB_FIRST:
        case GLS_BINARY_MSB_FIRST:
        case GLS_TEXT:
            if (
                writer = __glsWriter_create(
                    inStreamName, inCaptureStreamType, inWriteFlags
                )
            ) {
                if (!ctx->captureNesting++) {
                    __glsContext_updateDispatchTables(ctx);
                }
                ctx->writer = ctx->writers[ctx->captureNesting - 1] = writer;
                return GL_TRUE;
            } else {
                return GL_FALSE;
            }
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GL_FALSE;
    }
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
static void __glsCallArray_bin(size_t inCount, const GLubyte *inArray) {
    __GLScontext *ctx = __GLS_CONTEXT;
#else
static void __glsCallArray_bin(__GLScontext *ctx,
                               size_t inCount, const GLubyte *inArray) {
#endif
    const GLubyte *const arrayTail = inArray + inCount;
    size_t cmdBytes, headBytes;
    const __GLSbinCommandHead_large *head;
    GLSopcode op;

    for (;;) {
        headBytes = sizeof(__GLSbinCommandHead_small);
        if (inArray + headBytes > arrayTail) return;
        head = (const __GLSbinCommandHead_large *)inArray;
        if (head->countSmall) {
            op = head->opSmall;
            cmdBytes = head->countSmall << 2;
        } else {
            if (ctx->abortMode) return;
            headBytes = sizeof(__GLSbinCommandHead_large);
            if (inArray + headBytes > arrayTail) return;
            op = head->opLarge;
            cmdBytes = head->countLarge << 2;
        }
        if (inArray + cmdBytes > arrayTail) return;
        op = __glsMapOpcode(op);
        if (!__glsOpcodeString[op]) op = GLS_OP_glsUnsupportedCommand;
#ifndef __GLS_PLATFORM_WIN32
        // DrewB
        ctx->dispatchDecode_bin[op]((GLubyte *)inArray + headBytes);
#else
        ctx->dispatchDecode_bin[op](ctx, (GLubyte *)inArray + headBytes);
#endif
        inArray += cmdBytes;
    }
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
static void __glsCallArray_bin_swap(size_t inCount, const GLubyte *inArray) {
    __GLScontext *ctx = __GLS_CONTEXT;
#else
static void __glsCallArray_bin_swap(__GLScontext *ctx,
                               size_t inCount, const GLubyte *inArray) {
#endif
    const GLubyte *const arrayTail = inArray + inCount;
    GLubyte *buf = GLS_NONE;
    size_t bufSize = 0, cmdBytes, headBytes;
    const __GLSbinCommandHead_large *head;
    GLSopcode mappedOp, op;

    for (;;) {
        if (ctx->abortMode) goto done;
        headBytes = sizeof(__GLSbinCommandHead_small);
        if (inArray + headBytes > arrayTail) goto done;
        head = (const __GLSbinCommandHead_large *)inArray;
        if (head->countSmall) {
            op = __glsSwaps((GLshort)head->opSmall);
            cmdBytes = __glsSwaps((GLshort)head->countSmall) << 2;
        } else {
            headBytes = sizeof(__GLSbinCommandHead_large);
            if (inArray + headBytes > arrayTail) goto done;
            op = __glsSwapi((GLint)head->opLarge);
            cmdBytes = __glsSwapi((GLint)head->countLarge) << 2;
        }
        if (inArray + cmdBytes > arrayTail) goto done;
        if (__glsOpcodeString[mappedOp = __glsMapOpcode(op)]) {
            GLScommandAlignment align;

            glsGetCommandAlignment(op, __GLS_BINARY_SWAP1, &align);
            if (bufSize < cmdBytes + align.value) {
                GLubyte *const newBuf = (GLubyte *)realloc(
                    buf, bufSize = cmdBytes + align.value
                );

                if (!newBuf) {
                    free(buf);
                    bufSize = 0;
                }
                buf = newBuf;
            }
            if (buf) {
                memcpy(buf + align.value, inArray, cmdBytes);
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                __glsDispatchDecode_bin_swap[mappedOp](
                    buf + align.value + headBytes
                );
#else
                __glsDispatchDecode_bin_swap[mappedOp](
                    ctx, buf + align.value + headBytes
                );
#endif
            } else {
                __GLS_CALL_ERROR(ctx, op, GLS_OUT_OF_MEMORY);
            }
        } else {
            __GLS_CALL_UNSUPPORTED_COMMAND(ctx);
        }
        inArray += cmdBytes;
    }
done:
    free(buf);
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
static void __glsCallArray_text(size_t inCount, const GLubyte *inArray) {
    __GLScontext *ctx = __GLS_CONTEXT;
#else
static void __glsCallArray_text(__GLScontext *ctx,
                               size_t inCount, const GLubyte *inArray) {
#endif
    __GLSstring cmd;
    GLSopcode op;
    __GLSreader reader;

    if (!__glsParser) {
        __glsBeginCriticalSection();
        if (!__glsParser) __glsParser = __glsParser_create();
        __glsEndCriticalSection();
        if (!__glsParser) {
            __GLS_RAISE_ERROR(GLS_OUT_OF_MEMORY);
            return;
        }
    }
    __glsString_init(&cmd);
    __glsReader_init_array(&reader, inArray, inCount);
    for (;;) {
        if (ctx->abortMode || !__glsReader_beginCommand_text(&reader, &cmd)) {
            break;
        }
        if (__glsParser_findCommand(__glsParser, cmd.head, &op)) {
#ifndef __GLS_PLATFORM_WIN32
            // DrewB
            __glsDispatchDecode_text[__glsMapOpcode(op)](&reader);
#else
            __glsDispatchDecode_text[__glsMapOpcode(op)](ctx, &reader);
#endif
            __glsReader_endCommand_text(&reader);
            if (reader.error) {
                __GLS_CALL_ERROR(ctx, op, reader.error);
                __glsReader_abortCommand_text(&reader);
            }
        } else {
            __glsReader_abortCommand_text(&reader);
        }
    }
    __glsString_final(&cmd);
    __glsReader_final(&reader);
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
void glsCallArray(
    GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray
) {
    GLboolean callSave;
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return;
    if (ctx->abortMode) return;
    if (ctx->callNesting >= __GLS_MAX_CALL_NESTING) {
        __GLS_RAISE_ERROR(GLS_CALL_OVERFLOW);
        glsAbortCall(GLS_ALL);
        return;
    }
    ++ctx->callNesting;
    callSave = ctx->contextCall;
    ctx->contextCall = GL_TRUE;
    switch (inExternStreamType) {
        case __GLS_BINARY_SWAP0:
            __glsCallArray_bin(inCount, inArray);
            break;
        case __GLS_BINARY_SWAP1:
            __glsCallArray_bin_swap(inCount, inArray);
            break;
        case GLS_TEXT:
            __glsCallArray_text(inCount, inArray);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
    ctx->contextCall = callSave;
    --ctx->callNesting;
    switch (ctx->abortMode) {
        case GLS_ALL:
            if (!ctx->callNesting) glsAbortCall(GLS_NONE);
            break;
        case GLS_LAST:
            glsAbortCall(GLS_NONE);
            break;
    }
}
#else
void glsCallArrayInContext(
    GLuint inCtx,
    GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray
) {
    GLboolean callSave;
    __GLScontext *ctx;

    __glsBeginCriticalSection();
    ctx = (__GLScontext *)__glsInt2PtrDict_find(
            __glsContextDict, (GLint)inCtx
            );
    __glsEndCriticalSection();

    if (ctx == NULL) return;
    if (ctx->abortMode) return;
    if (ctx->callNesting >= __GLS_MAX_CALL_NESTING) {
        __GLS_RAISE_ERROR(GLS_CALL_OVERFLOW);
        __glsInternalAbortCall(ctx, GLS_ALL);
        return;
    }
    ++ctx->callNesting;
    callSave = ctx->contextCall;
    ctx->contextCall = GL_TRUE;
    switch (inExternStreamType) {
        case __GLS_BINARY_SWAP0:
            __glsCallArray_bin(ctx, inCount, inArray);
            break;
        case __GLS_BINARY_SWAP1:
            __glsCallArray_bin_swap(ctx, inCount, inArray);
            break;
        case GLS_TEXT:
            __glsCallArray_text(ctx, inCount, inArray);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
    ctx->contextCall = callSave;
    --ctx->callNesting;
    switch (ctx->abortMode) {
        case GLS_ALL:
            if (!ctx->callNesting) __glsInternalAbortCall(ctx, GLS_NONE);
            break;
        case GLS_LAST:
            __glsInternalAbortCall(ctx, GLS_NONE);
            break;
    }
}
void glsCallArray(
    GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray
) {
    glsCallArrayInContext(__GLS_CONTEXT->name, inExternStreamType, inCount,
                          inArray);
}
#endif

void glsCaptureFlags(GLSopcode inOpcode, GLbitfield inFlags) {
    if (!__glsRequireContext()) return;
    if (!__glsValidateOpcode(inOpcode)) return;
    switch (inOpcode) {
        case GLS_OP_glsBeginGLS:
        case GLS_OP_glsEndGLS:
        case GLS_OP_glsPad:
            return;
    }
    inOpcode = __glsMapOpcode(inOpcode);
    __GLS_CONTEXT->captureFlags[inOpcode] = (GLubyte)inFlags;
}

void glsCaptureFunc(GLSenum inTarget, GLScaptureFunc inFunc) {
    if (!__glsRequireContext()) return;
    switch (inTarget) {
        case GLS_CAPTURE_ENTRY_FUNC:
            __GLS_CONTEXT->captureEntryFunc = inFunc;
            break;
        case GLS_CAPTURE_EXIT_FUNC:
            __GLS_CONTEXT->captureExitFunc = inFunc;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void glsChannel(GLSenum inTarget, FILE *inChannel) {
    if (!__glsRequireContext()) return;
    switch (inTarget) {
        case GLS_DEFAULT_READ_CHANNEL:
            __GLS_CONTEXT->defaultReadChannel = inChannel;
            break;
        case GLS_DEFAULT_WRITE_CHANNEL:
            __GLS_CONTEXT->defaultWriteChannel = inChannel;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    }
}

void glsCommandFunc(GLSopcode inOpcode, GLSfunc inFunc) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return;
    if (!__glsValidateOpcode(inOpcode)) return;
    inOpcode = __glsMapOpcode(inOpcode);
    ctx->commandFuncs[inOpcode] = inFunc;
    ctx->dispatchCall[inOpcode] = inFunc ? inFunc : ctx->dispatchAPI[inOpcode];
    if (!ctx->abortMode && !__glsDispatchDecode_bin_default[inOpcode]) {
        ctx->dispatchDecode_bin[inOpcode] = (
            (__GLSdecodeBinFunc)ctx->dispatchCall[inOpcode]
        );
    }
}

GLSenum glsCopyStream(
    const GLubyte *inSource,
    const GLubyte *inDest,
    GLSenum inDestType,
    GLbitfield inWriteFlags
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;
    GLSenum outType = GLS_NONE;
    __GLSversion versionSave;

    if (!__glsRequireContext()) return outType;
    if (!__glsValidateString(inSource)) return outType;
    if (!__glsValidateString(inDest)) return outType;
    switch (inDestType) {
        case GLS_NONE:
        case GLS_CONTEXT:
        case GLS_BINARY_LSB_FIRST:
        case GLS_BINARY_MSB_FIRST:
        case GLS_TEXT:
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return outType;
    }
    if (ctx->abortMode) return outType;
    if (ctx->callNesting >= __GLS_MAX_CALL_NESTING) {
        __GLS_RAISE_ERROR(GLS_CALL_OVERFLOW);
        glsAbortCall(GLS_ALL);
        return outType;
    }
    ++ctx->callNesting;
    versionSave = ctx->streamVersion;
    ctx->streamVersion.major = ctx->streamVersion.minor = 0;
    if (
        contextStream = __glsStr2PtrDict_find(ctx->contextStreamDict, inSource)
    ) {
        GLint i;

        if (inDestType == GLS_NONE) inDestType = GLS_CONTEXT;
        for (i = 0 ; i < ctx->captureNesting ; ++i) {
            if (ctx->writers[i]->contextStream == contextStream) {
                __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
                inDestType = GLS_NONE;
                break;
            }
        }
        if (
            inDestType == GLS_CONTEXT &&
            !strcmp(
                (const char *)inDest, (const char *)contextStream->name.head
            )
        ) {
            __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
            inDestType = GLS_NONE;
        }
        if (inDestType) {
            if (glsBeginCapture(inDest, inDestType, inWriteFlags)) {
                outType = GLS_CONTEXT;
                __glsContextStream_call(contextStream);
                glsEndCapture();
            }
        }
    } else if (readStream = __glsReadStream_create(inSource)) {
        __GLSreader reader;

        if (__glsReader_init_stream(
            &reader, readStream, __GLS_READER_BUF_BYTES
        )) {
            if (inDestType == GLS_NONE) inDestType = reader.type;
            if (glsBeginCapture(inDest, inDestType, inWriteFlags)) {
                outType = reader.type;
                __glsReader_call(&reader);
                glsEndCapture();
            }
            __glsReader_final(&reader);
        } else {
            __GLS_RAISE_ERROR(GLS_INVALID_STREAM);
        }
        __glsReadStream_destroy(readStream);
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
    }
    --ctx->callNesting;
    switch (ctx->abortMode) {
        case GLS_ALL:
            if (!ctx->callNesting) glsAbortCall(GLS_NONE);
            break;
        case GLS_LAST:
            glsAbortCall(GLS_NONE);
            break;
    }
    ctx->streamVersion = versionSave;
    return outType;
}

void glsDataPointer(GLvoid *inPointer) {
    if (!__glsRequireContext()) return;
    __GLS_CONTEXT->dataPointer = inPointer;
}

void glsDeleteReadPrefix(GLuint inIndex) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return;
    if (inIndex >= ctx->readPrefixList.count) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return;
    }
    __GLS_ITERLIST_SEEK(&ctx->readPrefixList, inIndex);
    __GLS_ITERLIST_REMOVE_DESTROY(
        &ctx->readPrefixList,
        ctx->readPrefixList.iterElem,
        __glsListString_destroy
    );
}

void glsDeleteStream(const GLubyte *inName) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;

    if (!__glsRequireContext()) return;
    if (!__glsValidateString(inName)) return;
    if (
        contextStream = __glsStr2PtrDict_find(ctx->contextStreamDict, inName)
    ) {
        __glsStrDict_remove(ctx->contextStreamDict, contextStream->name.head);
        __GLS_ITERLIST_REMOVE(&ctx->contextStreamList, contextStream);
        if (contextStream->callCount) {
            contextStream->deleted = GL_TRUE;
        } else {
            __glsContextStream_destroy(contextStream);
        }
    } else if (readStream = __glsReadStream_create(inName)) {
        if (remove((const char *)readStream->name.head)) {
            __GLS_RAISE_ERROR(GLS_STREAM_DELETE_ERROR);
        }
        __glsReadStream_destroy(readStream);
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
    }
}

void glsEndCapture(void) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return;
    if (ctx->captureNesting > 0) {
        const GLint n = --ctx->captureNesting;

        __glsWriter_destroy(ctx->writer);
        ctx->writer = n ? ctx->writers[n - 1] : GLS_NONE;
        if (!n) __glsContext_updateDispatchTables(ctx);
    } else {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
    }
}

void glsFlush(GLSenum inFlushType) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLint i;

    if (!__glsRequireContext()) return;
    switch (inFlushType) {
        case GLS_ALL:
            for (i = 0 ; i < ctx->captureNesting ; ++i) {
                __glsWriter_flush(ctx->writers[i]);
            }
            break;
        case GLS_LAST:
            if (ctx->writer) __glsWriter_flush(ctx->writer);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

GLbitfield glsGetCaptureFlags(GLSopcode inOpcode) {
    if (!__glsRequireContext()) return GLS_NONE;
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;

    return __GLS_CONTEXT->captureFlags[__glsMapOpcode(inOpcode)];
}

GLSfunc glsGetCommandFunc(GLSopcode inOpcode) {
    if (!__glsRequireContext()) return GLS_NONE;
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;

    return __GLS_CONTEXT->commandFuncs[__glsMapOpcode(inOpcode)];
}

GLSfunc glsGetContextFunc(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_CAPTURE_ENTRY_FUNC:
            return (GLSfunc)ctx->captureEntryFunc;
        case GLS_CAPTURE_EXIT_FUNC:
            return (GLSfunc)ctx->captureExitFunc;
        case GLS_READ_FUNC:
            return (GLSfunc)ctx->readFunc;
        case GLS_UNREAD_FUNC:
            return (GLSfunc)ctx->unreadFunc;
        case GLS_WRITE_FUNC:
            return (GLSfunc)ctx->writeFunc;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
}

GLlong glsGetContextListl(GLSenum inAttrib, GLuint inIndex) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return __glsSizeToLong(0);
    switch (inAttrib) {
        case GLS_OUT_ARG_LIST:
            if (inIndex >= (GLuint)ctx->outArgs.count) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
                return __glsSizeToLong(0);
            }
            return *(GLlong *)(ctx->outArgs.vals + inIndex);
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return __glsSizeToLong(0);
    }
}

const GLubyte* glsGetContextListubz(GLSenum inAttrib, GLuint inIndex) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLubyte *outStr;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_CONTEXT_STREAM_LIST:
            if (inIndex >= ctx->contextStreamList.count) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
                return 0;
            }
            __GLS_ITERLIST_SEEK(&ctx->contextStreamList, inIndex);
            outStr = ctx->contextStreamList.iterElem->name.head;
            break;
        case GLS_READ_PREFIX_LIST:
            if (inIndex >= ctx->readPrefixList.count) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
                return 0;
            }
            __GLS_ITERLIST_SEEK(&ctx->readPrefixList, inIndex);
            outStr = ctx->readPrefixList.iterElem->val.head;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
    return (
        __glsString_assign(&ctx->returnString, outStr) ?
        ctx->returnString.head :
        GLS_NONE
    );
}

GLvoid* glsGetContextPointer(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_DEFAULT_READ_CHANNEL:
            return ctx->defaultReadChannel;
        case GLS_DEFAULT_WRITE_CHANNEL:
            return ctx->defaultWriteChannel;
        case GLS_DATA_POINTER:
            return ctx->dataPointer;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
}

GLint glsGetContexti(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return 0;
    switch (inAttrib) {
        case GLS_ABORT_MODE:
            return (GLint)ctx->abortMode;
        case GLS_BLOCK_TYPE:
            return (GLint)ctx->blockType;
        case GLS_CALL_NESTING:
            return ctx->callNesting;
        case GLS_CAPTURE_NESTING:
            return ctx->captureNesting;
        case GLS_CONTEXT_STREAM_COUNT:
            return (GLint)ctx->contextStreamList.count;
        case GLS_CURRENT_GLRC:
            return (GLint)ctx->currentGLRC;
        case GLS_OUT_ARG_COUNT:
            return ctx->outArgs.count;
        case GLS_PIXEL_SETUP_GEN:
            return ctx->pixelSetupGen;
        case GLS_READ_PREFIX_COUNT:
            return (GLint)ctx->readPrefixList.count;
        case GLS_STREAM_VERSION_MAJOR:
            return ctx->streamVersion.major;
        case GLS_STREAM_VERSION_MINOR:
            return ctx->streamVersion.minor;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return 0;
    }
}

const GLubyte* glsGetContextubz(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLubyte *outStr;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_WRITE_PREFIX:
            outStr = ctx->writePrefix->val.head;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
    return (
        __glsString_assign(&ctx->returnString, outStr) ?
        ctx->returnString.head :
        GLS_NONE
    );
}

GLint glsGetGLRCi(GLuint inGLRC, GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSglrc *glrc;

    if (!__glsRequireContext()) return 0;
    if (!inGLRC || inGLRC > (GLuint)ctx->header.glrcCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return 0;
    }
    glrc = ctx->header.glrcs + inGLRC - 1;
    switch (inAttrib) {
        case GLS_LAYER:
            return (GLint)glrc->layer;
        case GLS_READ_LAYER:
            return (GLint)glrc->readLayer;
        case GLS_SHARE_GLRC:
            return (GLint)glrc->shareGLRC;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return 0;
    }
}

GLfloat glsGetHeaderf(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return (GLfloat)0;
    switch (inAttrib) {
        case GLS_ASPECT:
            return ctx->header.aspect;
        case GLS_BORDER_WIDTH:
            return ctx->header.borderWidth;
        case GLS_CONTRAST_RATIO:
            return ctx->header.contrastRatio;
        case GLS_HEIGHT_MM:
            return ctx->header.heightMM;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return (GLfloat)0;
    }
}

GLfloat* glsGetHeaderfv(GLSenum inAttrib, GLfloat *outVec) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLint i;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_BORDER_COLOR:
            for (i = 0 ; i < 4 ; ++i) outVec[i] = ctx->header.borderColor[i];
            return outVec;
        case GLS_GAMMA:
            for (i = 0 ; i < 4 ; ++i) outVec[i] = ctx->header.gamma[i];
            return outVec;
        case GLS_ORIGIN:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.origin[i];
            return outVec;
        case GLS_PAGE_COLOR:
            for (i = 0 ; i < 4 ; ++i) outVec[i] = ctx->header.pageColor[i];
            return outVec;
        case GLS_PAGE_SIZE:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.pageSize[i];
            return outVec;
        case GLS_RED_POINT:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.redPoint[i];
            return outVec;
        case GLS_GREEN_POINT:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.greenPoint[i];
            return outVec;
        case GLS_BLUE_POINT:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.bluePoint[i];
            return outVec;
        case GLS_WHITE_POINT:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.whitePoint[i];
            return outVec;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
}

GLint glsGetHeaderi(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return 0;
    switch (inAttrib) {
        case GLS_FRAME_COUNT:
            return ctx->header.frameCount;
        case GLS_GLRC_COUNT:
            return ctx->header.glrcCount;
        case GLS_HEIGHT_PIXELS:
            return ctx->header.heightPixels;
        case GLS_LAYER_COUNT:
            return ctx->header.layerCount;
        case GLS_TILEABLE:
            return ctx->header.tileable;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return 0;
    }
}

GLint* glsGetHeaderiv(GLSenum inAttrib, GLint *outVec) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLint i;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_CREATE_TIME:
            for (i = 0 ; i < 6 ; ++i) outVec[i] = ctx->header.createTime[i];
            return outVec;
        case GLS_MODIFY_TIME:
            for (i = 0 ; i < 6 ; ++i) outVec[i] = ctx->header.modifyTime[i];
            return outVec;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
}

const GLubyte* glsGetHeaderubz(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLubyte *outStr;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_EXTENSIONS:
            outStr = ctx->header.extensions.head;
            break;
        case GLS_AUTHOR:
            outStr = ctx->header.author.head;
            break;
        case GLS_DESCRIPTION:
            outStr = ctx->header.description.head;
            break;
        case GLS_NOTES:
            outStr = ctx->header.notes.head;
            break;
        case GLS_TITLE:
            outStr = ctx->header.title.head;
            break;
        case GLS_TOOLS:
            outStr = ctx->header.tools.head;
            break;
        case GLS_VERSION:
            outStr = ctx->header.version.head;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
    return (
        __glsString_assign(&ctx->returnString, outStr) ?
        ctx->returnString.head :
        GLS_NONE
    );
}

GLfloat glsGetLayerf(GLuint inLayer, GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlayer *layer;

    if (!__glsRequireContext()) return (GLfloat)0;
    if (!inLayer || inLayer > (GLuint)ctx->header.layerCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return (GLfloat)0;
    }
    layer = ctx->header.layers + inLayer - 1;
    switch (inAttrib) {
        case GLS_INVISIBLE_ASPECT:
            return layer->invisibleAspect;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return (GLfloat)0;
    }
}

GLint glsGetLayeri(GLuint inLayer, GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlayer *layer;

    if (!__glsRequireContext()) return 0;
    if (!inLayer || inLayer > (GLuint)ctx->header.layerCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return 0;
    }
    layer = ctx->header.layers + inLayer - 1;
    switch (inAttrib) {
        case GLS_DISPLAY_FORMAT:
            return (GLint)layer->displayFormat;
        case GLS_DOUBLEBUFFER:
            return layer->doubleBuffer;
        case GLS_INVISIBLE:
            return layer->invisible;
        case GLS_INVISIBLE_HEIGHT_PIXELS:
            return layer->invisibleHeightPixels;
        case GLS_LEVEL:
            return layer->level;
        case GLS_STEREO:
            return layer->stereo;
        case GLS_TRANSPARENT:
            return layer->transparent;
        case GLS_INDEX_BITS:
            return layer->indexBits;
        case GLS_RED_BITS:
            return layer->redBits;
        case GLS_GREEN_BITS:
            return layer->greenBits;
        case GLS_BLUE_BITS:
            return layer->blueBits;
        case GLS_ALPHA_BITS:
            return layer->alphaBits;
        case GLS_DEPTH_BITS:
            return layer->depthBits;
        case GLS_STENCIL_BITS:
            return layer->stencilBits;
        case GLS_ACCUM_RED_BITS:
            return layer->accumRedBits;
        case GLS_ACCUM_GREEN_BITS:
            return layer->accumGreenBits;
        case GLS_ACCUM_BLUE_BITS:
            return layer->accumBlueBits;
        case GLS_ACCUM_ALPHA_BITS:
            return layer->accumAlphaBits;
        case GLS_AUX_BUFFERS:
            return layer->auxBuffers;
        #if __GL_SGIS_multisample
            case GLS_SAMPLE_BUFFERS_SGIS:
                return layer->sampleBuffers;
            case GLS_SAMPLES_SGIS:
                return layer->samples;
        #endif /* __GL_SGIS_multisample */
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return 0;
    }
}

GLbitfield glsGetStreamAttrib(const GLubyte *inName) {
    if (!__glsRequireContext()) return GL_FALSE;
    if (!__glsValidateString(inName)) return GL_FALSE;
    if (__glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName)) {
        return (
            GLS_STREAM_CONTEXT_BIT |
            GLS_STREAM_NAMED_BIT |
            GLS_STREAM_READABLE_BIT |
            GLS_STREAM_WRITABLE_BIT |
            GLS_STREAM_SEEKABLE_BIT
        );
    } else {
        GLbitfield outVal = GLS_NONE;
        __GLSreadStream *const readStream = __glsReadStream_create(inName);

        if (readStream) {
            outVal = __glsReadStream_getAttrib(readStream);
            __glsReadStream_destroy(readStream);
        }
        return outVal;
    }
}

GLuint glsGetStreamCRC32(const GLubyte *inName) {
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;

    if (!__glsRequireContext()) return 0;
    if (!__glsValidateString(inName)) return 0;
    glsFlush(GLS_ALL);
    if (
        contextStream =
        __glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName)
    ) {
        return __glsContextStream_getCRC32(contextStream);
    } else if (readStream = __glsReadStream_create(inName)) {
        const GLuint outVal = __glsReadStream_getCRC32(readStream);

        __glsReadStream_destroy(readStream);
        return outVal;
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        return 0;
    }
}

const GLubyte* glsGetStreamReadName(const GLubyte *inName) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;
    GLboolean ok;

    if (!__glsRequireContext()) return GLS_NONE;
    if (!__glsValidateString(inName)) return GLS_NONE;
    if (
        contextStream =
        __glsStr2PtrDict_find(ctx->contextStreamDict, inName)
    ) {
        ok = __glsString_assign(&ctx->returnString, contextStream->name.head);
    } else if (readStream = __glsReadStream_create(inName)) {
        ok = __glsString_assign(&ctx->returnString, readStream->name.head);
        __glsReadStream_destroy(readStream);
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        return GLS_NONE;
    }
    return ok ? ctx->returnString.head : GLS_NONE;
}

size_t glsGetStreamSize(const GLubyte *inName) {
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;

    if (!__glsRequireContext()) return 0;
    if (!__glsValidateString(inName)) return 0;
    glsFlush(GLS_ALL);
    if (
        contextStream =
        __glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName)
    ) {
        return __glsContextStream_getByteCount(contextStream);
    } else if (readStream = __glsReadStream_create(inName)) {
        const size_t outVal = __glsReadStream_getByteCount(readStream);
        __glsReadStream_destroy(readStream);
        return outVal;
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        return 0;
    }
}

GLSenum glsGetStreamType(const GLubyte *inName) {
    __GLSreadStream *readStream;

    if (!__glsRequireContext()) return GLS_NONE;
    if (!__glsValidateString(inName)) return GLS_NONE;
    if (__glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName)) {
        return GLS_CONTEXT;
    } else if (readStream = __glsReadStream_create(inName)) {
        const GLSenum outVal = __glsReadStream_getType(readStream);

        __glsReadStream_destroy(readStream);
        return outVal;
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        return GLS_NONE;
    }
}

GLboolean glsIsContextStream(const GLubyte *inName) {
    if (!__glsRequireContext()) return GL_FALSE;
    if (!__glsValidateString(inName)) return GL_FALSE;
    return (GLboolean)(
        __glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName) !=
        GLS_NONE
    );
}

void glsPixelSetupGen(GLboolean inEnabled) {
    __GLS_CONTEXT->pixelSetupGen = (GLboolean)(inEnabled ? GL_TRUE : GL_FALSE);
}

void glsReadFunc(GLSreadFunc inFunc) {
    if (!__glsRequireContext()) return;
    __GLS_CONTEXT->readFunc = inFunc;
}

void glsReadPrefix(GLSenum inListOp, const GLubyte *inPrefix) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlistString *prefix;

    if (!__glsRequireContext()) return;
    if (!__glsValidateString(inPrefix)) return;
    switch (inListOp) {
        case GLS_APPEND:
            if (prefix = __glsListString_create(inPrefix)) {
                __GLS_ITERLIST_APPEND(&ctx->readPrefixList, prefix);
            }
            break;
        case GLS_PREPEND:
            if (prefix = __glsListString_create(inPrefix)) {
                __GLS_ITERLIST_PREPEND(&ctx->readPrefixList, prefix);
            }
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void glsUnreadFunc(GLSwriteFunc inFunc) {
    if (!__glsRequireContext()) return;
    __GLS_CONTEXT->unreadFunc = inFunc;
}

void glsWriteFunc(GLSwriteFunc inFunc) {
    if (!__glsRequireContext()) return;
    __GLS_CONTEXT->writeFunc = inFunc;
}

void glsWritePrefix(const GLubyte *inPrefix) {
    if (!__glsRequireContext()) return;
    if (!__glsValidateString(inPrefix)) return;
    __glsString_assign(&__GLS_CONTEXT->writePrefix->val, inPrefix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\pixel.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

void __glsGenPixelSetup_pack(__GLScontext *ctx) {
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glPixelStorei);
    __glsPixelSetup_pack();
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glPixelStorei);
}

void __glsGenPixelSetup_unpack(__GLScontext *ctx) {
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glPixelStorei);
    __glsPixelSetup_unpack();
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glPixelStorei);
}

void __glsPixelSetup_pack(void) {
    glPixelStorei(GL_PACK_ALIGNMENT, 1);
    glPixelStorei(GL_PACK_LSB_FIRST, GL_FALSE);
    glPixelStorei(GL_PACK_ROW_LENGTH, 0);
    glPixelStorei(GL_PACK_SKIP_ROWS, 0);
    glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
    glPixelStorei(GL_PACK_SWAP_BYTES, GL_FALSE);
    #if __GL_EXT_texture3D
        glPixelStorei(GL_PACK_IMAGE_HEIGHT_EXT, 0);
        glPixelStorei(GL_PACK_SKIP_IMAGES_EXT, 0);
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        glPixelStorei(GL_PACK_IMAGE_DEPTH_SGIS, 0);
        glPixelStorei(GL_PACK_SKIP_VOLUMES_SGIS, 0);
    #endif /* __GL_SGIS_texture4D */
}

void __glsPixelSetup_unpack(void) {
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glPixelStorei(GL_UNPACK_LSB_FIRST, GL_FALSE);
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
    glPixelStorei(GL_UNPACK_SWAP_BYTES, GL_FALSE);
    #if __GL_EXT_texture3D
        glPixelStorei(GL_UNPACK_IMAGE_HEIGHT_EXT, 0);
        glPixelStorei(GL_UNPACK_SKIP_IMAGES_EXT, 0);
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        glPixelStorei(GL_UNPACK_IMAGE_DEPTH_SGIS, 0);
        glPixelStorei(GL_UNPACK_SKIP_VOLUMES_SGIS, 0);
    #endif /* __GL_SGIS_texture4D */
}

static void __glsPixelStoreConfig_init(__GLSpixelStoreConfig *outConfig) {
    outConfig->alignment = 1;
    outConfig->lsbFirst = GL_FALSE;
    outConfig->rowLength = 0;
    outConfig->skipRows = 0;
    outConfig->skipPixels = 0;
    outConfig->swapBytes = GL_FALSE;
    #if __GL_EXT_texture3D
        outConfig->imageHeight = 0;
        outConfig->skipImages = 0;
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        outConfig->imageDepth = 0;
        outConfig->skipVolumes = 0;
    #endif /* __GL_SGIS_texture4D */
}

void __glsPixelStoreConfig_get_pack(__GLSpixelStoreConfig *outConfig) {
    __glsPixelStoreConfig_init(outConfig);
    __GLS_BEGIN_CAPTURE_EXEC(__GLS_CONTEXT, GLS_OP_glGetIntegerv);
    glGetIntegerv(GL_PACK_ALIGNMENT, &outConfig->alignment);
    glGetIntegerv(GL_PACK_LSB_FIRST, &outConfig->lsbFirst);
    glGetIntegerv(GL_PACK_ROW_LENGTH, &outConfig->rowLength);
    glGetIntegerv(GL_PACK_SKIP_ROWS, &outConfig->skipRows);
    glGetIntegerv(GL_PACK_SKIP_PIXELS, &outConfig->skipPixels);
    glGetIntegerv(GL_PACK_SWAP_BYTES, &outConfig->swapBytes);
    #if __GL_EXT_texture3D
        glGetIntegerv(GL_PACK_IMAGE_HEIGHT_EXT, &outConfig->imageHeight);
        glGetIntegerv(GL_PACK_SKIP_IMAGES_EXT, &outConfig->skipImages);
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        glGetIntegerv(GL_PACK_IMAGE_DEPTH_SGIS, &outConfig->imageDepth);
        glGetIntegerv(GL_PACK_SKIP_VOLUMES_SGIS, &outConfig->skipVolumes);
    #endif /* __GL_SGIS_texture4D */
    __GLS_END_CAPTURE_EXEC(__GLS_CONTEXT, GLS_OP_glGetIntegerv);
}

void __glsPixelStoreConfig_get_unpack(__GLSpixelStoreConfig *outConfig) {
    __glsPixelStoreConfig_init(outConfig);
    __GLS_BEGIN_CAPTURE_EXEC(__GLS_CONTEXT, GLS_OP_glGetIntegerv);
    glGetIntegerv(GL_UNPACK_ALIGNMENT, &outConfig->alignment);
    glGetIntegerv(GL_UNPACK_LSB_FIRST, &outConfig->lsbFirst);
    glGetIntegerv(GL_UNPACK_ROW_LENGTH, &outConfig->rowLength);
    glGetIntegerv(GL_UNPACK_SKIP_ROWS, &outConfig->skipRows);
    glGetIntegerv(GL_UNPACK_SKIP_PIXELS, &outConfig->skipPixels);
    glGetIntegerv(GL_UNPACK_SWAP_BYTES, &outConfig->swapBytes);
    #if __GL_EXT_texture3D
        glGetIntegerv(GL_UNPACK_IMAGE_HEIGHT_EXT, &outConfig->imageHeight);
        glGetIntegerv(GL_UNPACK_SKIP_IMAGES_EXT, &outConfig->skipImages);
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        glGetIntegerv(GL_UNPACK_IMAGE_DEPTH_SGIS, &outConfig->imageDepth);
        glGetIntegerv(GL_UNPACK_SKIP_VOLUMES_SGIS, &outConfig->skipVolumes);
    #endif /* __GL_SGIS_texture4D */
    __GLS_END_CAPTURE_EXEC(__GLS_CONTEXT, GLS_OP_glGetIntegerv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\platform.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <ctype.h>
#include <errno.h>
#include <stdlib.h>

/******************************************************************************
POSIX threads
******************************************************************************/

#if __GLS_POSIX_THREADS

#if !__GLS_FAKE_MUTEX

static pthread_mutex_t __gls_lock;

static const pthread_mutexattr_t __gls_lockInit = {
    MUTEX_TYPE_FAST,
    MUTEX_FLAGS_INITED,
};

void __glsBeginCriticalSection(void) {
    if (pthread_mutex_lock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: pthread_mutex_lock failed\n");
        exit(EXIT_FAILURE);
    }
}

void __glsEndCriticalSection(void) {
    if (pthread_mutex_unlock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: pthread_mutex_unlock failed\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* !__GLS_FAKE_MUTEX */

#if !__GLS_FAKE_THREAD_LOCAL_STORAGE

pthread_key_t __gls_contextTLS;
pthread_key_t __gls_errorTLS;

__GLScontext* __glsGetContext(void) {
    return (__GLScontext *)pthread_getspecific(__gls_contextTLS);
}

GLSenum __glsGetError(void) {
    return (GLSenum)pthread_getspecific(__gls_errorTLS);
}

#endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

static void __glsFinalPthreads(void) {
    #if !__GLS_FAKE_MUTEX
        pthread_mutex_destroy(&__gls_lock);
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        pthread_key_delete(__gls_contextTLS);
        pthread_key_delete(__gls_errorTLS);
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
}

static void __glsInitPthreads(void) {
    #if !__GLS_FAKE_MUTEX
        if (pthread_mutex_init(&__gls_lock, &__gls_lockInit)) {
            fprintf(stderr, "GLS fatal: pthread_mutex_init failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        if (
            pthread_key_create(&__gls_contextTLS, GLS_NONE) ||
            pthread_key_create(&__gls_errorTLS, GLS_NONE)
        ) {
            fprintf(stderr, "GLS fatal: pthread_key_create failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
}

#endif /* __GLS_POSIX_THREADS */

/******************************************************************************
These routines must be called during library loading/unloading
******************************************************************************/

static GLboolean __glsInitContextDict(void) {
    __glsContextDict = __glsIntDict_create(1);
    return (GLboolean)(__glsContextDict != GLS_NONE);
}

static void __glsFinalContextDict(void) {
    __GLScontext *ctx;
    __GLS_LIST_ITER(__GLScontext) iter;

    __GLS_LIST_FIRST(&__glsContextList, &iter);
    while (ctx = iter.elem) {
        __GLS_LIST_NEXT(&__glsContextList, &iter);
        __glsContext_destroy(ctx);
    }
    __glsIntDict_destroy(__glsContextDict);
}

/******************************************************************************
Fake lltostr
******************************************************************************/

#if __GLS_FAKE_LLTOSTR

char *ulltostr(GLulong inVal, char *outBuf) {
    char buf[24];
    char *p1 = buf;
    char *p2 = outBuf;

    do {
        *p1++ = '0' + (char)(inVal % 10);
        inVal /= 10;
    } while (inVal);
    while (--p1 >= buf) *p2++ = *p1;
    *p2 = 0;
    return outBuf;
}

char *lltostr(GLlong inVal, char *outBuf) {
    char *p = outBuf;

    if (inVal < 0) {
        *p++ = '-';
        inVal = -inVal;
    }
    ulltostr(inVal, p);
    return outBuf;
}

#endif /* __GLS_FAKE_LLTOSTR */

/******************************************************************************
Fake mutex
******************************************************************************/

#if __GLS_FAKE_MUTEX

void __glsBeginCriticalSection(void) {
}

void __glsEndCriticalSection(void) {
}

#endif /* __GLS_FAKE_MUTEX */

/******************************************************************************
Fake strtoll
******************************************************************************/

#if __GLS_FAKE_STRTOLL

#define __GLS_DIGIT(c) ( \
    isdigit(c) ? c - '0' : islower(c) ? c - 'a' + 10 : c - 'A' + 10 \
)

#define __GLS_LL_MIN    (-9223372036854775807LL-1LL)
#define __GLS_LL_MAX    9223372036854775807LL
#define __GLS_ULL_MAX   18446744073709551615LLU

static GLboolean __gls_strtoull(
    const char *inStr, char **outPtr, GLboolean *outNeg, GLulong *outVal
) {
    GLint base, c, d;
    GLulong multMax, val;
    const char **ptr = (const char **)outPtr;

    if (ptr) *ptr = inStr;
    *outNeg = GL_FALSE;
    if (!isalnum(c = *inStr)) {
        while (isspace(c)) c = *++inStr;
        switch (c) {
            case '-':
                *outNeg = GL_TRUE;
                c = *++inStr;
                break;
            case '+':
                c = *++inStr;
                break;
        }
    }
    if (c != '0') {
        base = 10;
    } else if (inStr[1] == 'x' || inStr[1] == 'X') {
        base = 16;
    } else {
        base = 8;
    }
    if (!isalnum(c) || __GLS_DIGIT(c) >= base) {
        *outVal = 0;
        return GL_TRUE;
    }
    if (base == 16 && isxdigit(inStr[2])) c = *(inStr += 2);
    multMax = __GLS_ULL_MAX / base;
    val = __GLS_DIGIT(c);
    for (c = *++inStr; isalnum(c) && (d = __GLS_DIGIT(c)) < base; ) {
        if (val > multMax) goto overflow;
        val *= base;
        if (__GLS_ULL_MAX - val < d) goto overflow;
        val += d;
        c = *++inStr;
    }
    if (ptr) *ptr = inStr;
    *outVal = val;
    return GL_TRUE;
overflow:
    for (c = *++inStr; isalnum(c) && __GLS_DIGIT(c) < base; c = *++inStr);
    if (ptr) *ptr = inStr;
    return GL_FALSE;
}

extern GLlong strtoll(const char *inStr, char **outPtr, int inBase) {
    GLboolean neg;
    GLulong outVal;

    if (
        !__gls_strtoull(inStr, outPtr, &neg, &outVal) ||
        outVal > (GLulong)__GLS_LL_MAX + (GLulong)neg
    ) {
        __GLS_PUT_ERRNO(ERANGE);
        return neg ? __GLS_LL_MIN : __GLS_LL_MAX;
    } else {
        return neg ? -outVal : outVal;
    }
}

extern GLulong strtoull(const char *inStr, char **outPtr, int inBase) {
    GLboolean neg;
    GLulong outVal;

    if (!__gls_strtoull(inStr, outPtr, &neg, &outVal)) {
        __GLS_PUT_ERRNO(ERANGE);
        return __GLS_ULL_MAX;
    } else {
        return neg ? -outVal : outVal;
    }
}

#endif /* __GLS_FAKE_STRTOLL */

/******************************************************************************
Fake thread-local storage
******************************************************************************/

#if __GLS_FAKE_THREAD_LOCAL_STORAGE
    __GLScontext *__gls_context;
    GLSenum __gls_error;
#endif /* __GLS_FAKE_THREAD_LOCAL_STORAGE */

/******************************************************************************
2-level GL dispatch with GLS library defining all GL entry points
******************************************************************************/

#if __GLS_GL_DISPATCH

#if __GLS_PLATFORM_WIN32

#include <gldrv.h>
#include <exttable.h>
    
// Version 1.1 table mapping
static GLSopcode opGl11Procs[] =
{
    GLS_OP_glArrayElement,
    GLS_OP_glBindTexture,
    GLS_OP_glColorPointer,
    GLS_OP_glDisableClientState,
    GLS_OP_glDrawArrays,
    GLS_OP_glDrawElements,
    GLS_OP_glEdgeFlagPointer,
    GLS_OP_glEnableClientState,
    GLS_OP_glIndexPointer,
    GLS_OP_glIndexub,
    GLS_OP_glIndexubv,
    GLS_OP_glInterleavedArrays,
    GLS_OP_glNormalPointer,
    GLS_OP_glPolygonOffset,
    GLS_OP_glTexCoordPointer,
    GLS_OP_glVertexPointer,
    GLS_OP_glAreTexturesResident,
    GLS_OP_glCopyTexImage1D,
    GLS_OP_glCopyTexImage2D,
    GLS_OP_glCopyTexSubImage1D,
    GLS_OP_glCopyTexSubImage2D,
    GLS_OP_glDeleteTextures,
    GLS_OP_glGenTextures,
    GLS_OP_glGetPointerv,
    GLS_OP_glIsTexture,
    GLS_OP_glPrioritizeTextures,
    GLS_OP_glTexSubImage1D,
    GLS_OP_glTexSubImage2D,
    GLS_OP_glPopClientAttrib,
    GLS_OP_glPushClientAttrib,
};
#define GL11_PROCS (sizeof(opGl11Procs)/sizeof(opGl11Procs[0]))

// Extension function mapping
static GLSopcode opExtProcs[] =
{
    GLS_OP_glDrawRangeElementsWIN,
    GLS_OP_glColorTableEXT,
    GLS_OP_glColorSubTableEXT,
    GLS_OP_glGetColorTableEXT,
    GLS_OP_glGetColorTableParameterivEXT,
    GLS_OP_glGetColorTableParameterfvEXT
};
#define EXT_PROCS (sizeof(opExtProcs)/sizeof(opExtProcs[0]))

// DrewB
void glsUpdateCaptureExecTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    GLint i;
    GLSopcode op;
    __GLScontext *ctx = __GLS_CONTEXT;
    GLSfunc *pgfn;

    if (ctx == NULL)
    {
#if DBG
        OutputDebugString(TEXT("glsUpdateCaptureExecTable call ignored\n"));
#endif
        return;
    }
    
    ctx->captureExecOverride = GL_TRUE;

    // Copy over standard 1.0 entries
    // The ordering is the same between OpenGL and GLS so straight copy works
    memcpy(&ctx->captureExec[GLS_OP_glNewList], &pgcpt->glDispatchTable,
           OPENGL_VERSION_100_ENTRIES*sizeof(GLSfunc));

    // If the dispatch table contains 1.1 entries, map them in
    pgfn = (GLSfunc *)&pgcpt->glDispatchTable.glArrayElement;
    if (pgcpt->cEntries == OPENGL_VERSION_110_ENTRIES)
    {
        for (i = 0; i < GL11_PROCS; i++)
        {
            op = __glsMapOpcode(opGl11Procs[i]);
            ctx->captureExec[op] = *pgfn++;
        }
    }
#if DBG
    else if (pgcpt->cEntries != OPENGL_VERSION_100_ENTRIES)
    {
        OutputDebugString("glsUpdateCaptureExecTable clt table size wrong\n");
    }
#endif

    // Map in extension functions
#if DBG
    if (pgept->cEntries != EXT_PROCS)
    {
        OutputDebugString("glsUpdateCaptureExecTable ext table size wrong\n");
    }
#endif
    pgfn = (GLSfunc *)&pgept->glDispatchTable;
    for (i = 0; i < EXT_PROCS; i++)
    {
        op = __glsMapOpcode(opExtProcs[i]);
        ctx->captureExec[op] = *pgfn++;
    }
}

void __glsMapGlsTableToGl(const GLSfunc *pgfnGlsTable,
                          GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    GLint i;
    GLSopcode op;
    GLSfunc *pgfn;

#if DBG
    if (sizeof(GLDISPATCHTABLE)/sizeof(PROC) < OPENGL_VERSION_110_ENTRIES)
    {
        OutputDebugString("__glsMapGlsTableToGl GLDISPATCHTABLE too small\n");
    }
#endif
    
    // GLS supports all 1.1 functions so set a 1.1 entry count
    pgcpt->cEntries = OPENGL_VERSION_110_ENTRIES;
    pgept->cEntries = EXT_PROCS;
    
    // Copy over standard 1.0 entries
    // The ordering is the same between OpenGL and GLS so straight copy works
    memcpy(&pgcpt->glDispatchTable, &pgfnGlsTable[GLS_OP_glNewList],
           OPENGL_VERSION_100_ENTRIES*sizeof(GLSfunc));

    // Map in 1.1 entries
    pgfn = (GLSfunc *)&pgcpt->glDispatchTable.glArrayElement;
    for (i = 0; i < GL11_PROCS; i++)
    {
        op = __glsMapOpcode(opGl11Procs[i]);
        *pgfn++ = pgfnGlsTable[op];
    }

    // Map in extension functions
    pgfn = (GLSfunc *)&pgept->glDispatchTable;
    for (i = 0; i < EXT_PROCS; i++)
    {
        op = __glsMapOpcode(opExtProcs[i]);
        *pgfn++ = pgfnGlsTable[op];
    }
}
void glsGetCaptureExecTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    __GLScontext *ctx = __GLS_CONTEXT;

    if (ctx == NULL ||
        !ctx->captureExecOverride)
    {
#if DBG
        OutputDebugString(TEXT("glsGetCaptureExecTable call ignored\n"));
#endif
        return;
    }

    __glsMapGlsTableToGl(ctx->captureExec, pgcpt, pgept);
}

void glsGetCaptureDispatchTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    __glsMapGlsTableToGl(__glsDispatchCapture, pgcpt, pgept);
}

void __glsBeginCaptureExec(__GLScontext *ctx, GLSopcode inOpcode) {
    if (!ctx->captureNesting) return;
    inOpcode = __glsMapOpcode(inOpcode);
    if (ctx->captureExecOverride)
    {
        ctx->dispatchAPI[inOpcode] = ctx->captureExec[inOpcode];
    }
    else
    {
        ctx->dispatchAPI[inOpcode] = __glsDispatchExec[inOpcode];
    }
}

void __glsEndCaptureExec(__GLScontext *ctx, GLSopcode inOpcode) {
    if (!ctx->captureNesting) return;
    inOpcode = __glsMapOpcode(inOpcode);
    ctx->dispatchAPI[inOpcode] = (
        (GLSfunc)__glsDispatchCapture[inOpcode]
    );
}
#else
void __glsBeginCaptureExec(GLSopcode inOpcode) {
    if (!__GLS_CONTEXT->captureNesting) return;
    inOpcode = __glsMapOpcode(inOpcode);
    __GLS_CONTEXT->dispatchAPI[inOpcode] = __glsDispatchExec[inOpcode];
}

void __glsEndCaptureExec(GLSopcode inOpcode) {
    if (!__GLS_CONTEXT->captureNesting) return;
    inOpcode = __glsMapOpcode(inOpcode);
    __GLS_CONTEXT->dispatchAPI[inOpcode] = (
        (GLSfunc)__glsDispatchCapture[inOpcode]
    );
}
#endif

void __glsUpdateDispatchTables(void) {
}

#include "g_glapi.c"

#endif /* __GLS_GL_DISPATCH */

/******************************************************************************
If using DSOs for the 2-level dispatch, use this DSO init function as well
******************************************************************************/

#if __GLS_GL_DISPATCH_DSO

#include <dlfcn.h>

static void __glsInitGLDispatch_DSO(void) {
    GLvoid *const dso = dlopen(__GL_LIB_NAME, RTLD_LAZY);
    GLint i;
    GLSopcode op;

    if (!dso) {
        fprintf(stderr, "GLS fatal: dlopen failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    for (i = 0 ; op = __glsMapOpcode(__glsOpcodesGL[i]) ; ++i) {
        const GLSfunc func = (
            (GLSfunc) dlsym(dso, (const char *)__glsOpcodeString[op])
        );

        __glsDispatchExec[op] = func ? func : __glsNop;
    }
}

#endif /* __GLS_GL_DISPATCH_DSO */

/******************************************************************************
Null command func
******************************************************************************/

#if __GLS_SINGLE_NULL_COMMAND_FUNC

GLSfunc glsNullCommandFunc(GLSopcode inOpcode) {
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    return (GLSfunc)__glsNop;
}

#endif /* __GLS_SINGLE_NULL_COMMAND_FUNC */

/******************************************************************************
AIX
******************************************************************************/

#if __GLS_PLATFORM_AIX

#include <a.out.h>
#include <ldfcn.h>
#include <string.h>
#include <sys/ldr.h>

static void __glsInitSA(void) {
    GLint i;
    LDFILE *ldFile = GLS_NONE;
    LDHDR *ldHdr;
    struct ld_info *ldInfo;
    GLvoid *ldInfoBuf = GLS_NONE;
    GLint ldInfoBufSize = 4096;
    LDSYM *ldSym;
    GLSopcode op;
    GLubyte *scnBuf;
    SCNHDR scnHdr;

    if (0) __gls_glRef();
    for (;;) {
        ldInfoBuf = realloc(ldInfoBuf, ldInfoBufSize);
        if (!ldInfoBuf) {
            fprintf(stderr, "GLS fatal: realloc for loadquery failed\n");
            exit(EXIT_FAILURE);
        }
        if (loadquery(L_GETINFO, ldInfoBuf, ldInfoBufSize) != -1) break;
        if (__GLS_ERRNO != ENOMEM) {
            fprintf(stderr, "GLS fatal: loadquery failed\n");
            exit(EXIT_FAILURE);
        }
        ldInfoBufSize <<= 1;
    }
    ldInfo = (struct ld_info *)ldInfoBuf;
    for (;;) {
        if (strstr(ldInfo->ldinfo_filename, __GL_LIB_NAME)) break;
        if (!ldInfo->ldinfo_next) {
            fprintf(stderr, "GLS fatal: %s not loaded\n", __GL_LIB_NAME);
            exit(EXIT_FAILURE);
        }
        ldInfo = (struct ld_info *)((GLubyte *)ldInfo + ldInfo->ldinfo_next);
    }
    ldFile = ldopen(ldInfo->ldinfo_filename, ldFile);
    if (!ldFile) {
        fprintf(
            stderr,
            "GLS fatal: ldopen failed on %s\n",
            ldInfo->ldinfo_filename
        );
        exit(EXIT_FAILURE);
    }
    if (ldnshread(ldFile, _LOADER, &scnHdr) != SUCCESS) {
        fprintf(stderr, "GLS fatal: ldnshread failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    scnBuf = (GLubyte *)malloc(scnHdr.s_size);
    if (!scnBuf) {
        fprintf(stderr, "GLS fatal: malloc for scnBuf failed\n");
        exit(EXIT_FAILURE);
    }
    if (FSEEK(ldFile, scnHdr.s_scnptr, BEGINNING) != OKFSEEK) {
        fprintf(stderr, "GLS fatal: FSEEK failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    if (FREAD((char *)scnBuf, scnHdr.s_size, 1, ldFile) != 1) {
        fprintf(stderr, "GLS fatal: FREAD failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    for (i = 0 ; op = __glsMapOpcode(__glsOpcodesGL[i]) ; ++i) {
        __glsDispatchExec[op] = __glsNop;
    }
    __glsParser = __glsParser_create();
    ldHdr = (LDHDR *)scnBuf;
    ldSym = (LDSYM *)(scnBuf + LDHDRSZ);
    for (i = 0 ; i < ldHdr->l_nsyms ; ++i, ++ldSym) {
        GLubyte *sym;

	if (!LDR_EXPORT(*ldSym)) continue;
        if (ldSym->l_zeroes) {
            sym = (GLubyte *)ldSym->l_name;
        } else {
            sym = scnBuf + ldHdr->l_stoff + ldSym->l_offset;
        }
        if (__glsStr2IntDict_find(__glsParser->glsOpDict, sym, (GLint*)&op)) {
            __glsDispatchExec[__glsMapOpcode(op)] = (GLSfunc)(
                (GLubyte *)ldInfo->ldinfo_dataorg + ldSym->l_value
            );
        }
    }
    free(ldInfoBuf);
    free(scnBuf);
    while(ldclose(ldFile) == FAILURE);
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

static GLboolean __glsInitDone;

void __glsBeginCriticalSection(void) {
    if (!__glsInitDone) {
        __glsInitSA();
        __glsInitDone = GL_TRUE;
    }
}

void __glsEndCriticalSection(void) {
}

#endif /* __GLS_PLATFORM_AIX */

/******************************************************************************
DECUNIX
******************************************************************************/

#if __GLS_PLATFORM_DECUNIX


#if !__GLS_FAKE_MUTEX

static pthread_mutex_t __gls_lock;

void __glsBeginCriticalSection(void) {
    if (pthread_mutex_lock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: pthread_mutex_lock failed\n");
        exit(EXIT_FAILURE);
    }
}

void __glsEndCriticalSection(void) {
    if (pthread_mutex_unlock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: pthread_mutex_unlock failed\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* !__GLS_FAKE_MUTEX */

#if !__GLS_FAKE_THREAD_LOCAL_STORAGE

pthread_key_t __gls_contextTLS;
pthread_key_t __gls_errorTLS;

__GLScontext* __glsGetContext(void) {
    __GLScontext *outContext;

    pthread_getspecific(__gls_contextTLS, (pthread_addr_t *)&outContext);
    return outContext;
}

GLSenum __glsGetError(void) {
    GLvoid *outError;

    pthread_getspecific(__gls_errorTLS, (pthread_addr_t *)&outError);
    return (GLSenum)outError;
}

#endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

void __glsFinalDSO(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
    #if !__GLS_FAKE_MUTEX
        pthread_mutex_destroy(&__gls_lock);
    #endif /* !__GLS_FAKE_MUTEX */
}

void __glsInitDSO(void) {
    #if __GLS_GL_DISPATCH_DSO
        __glsInitGLDispatch_DSO();
    #endif /* __GLS_GL_DISPATCH_DSO */
    #if !__GLS_FAKE_MUTEX
        if (pthread_mutex_init(&__gls_lock, pthread_mutexattr_default)) {
            fprintf(stderr, "GLS fatal: pthread_mutex_init failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        if (
            pthread_keycreate(&__gls_contextTLS, GLS_NONE) ||
            pthread_keycreate(&__gls_errorTLS, GLS_NONE)
        ) {
            fprintf(stderr, "GLS fatal: pthread_keycreate failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* __GLS_PLATFORM_DECUNIX */

/******************************************************************************
HPUX
******************************************************************************/

#if __GLS_PLATFORM_HPUX

#include <dl.h>

void __glsInitSL(void) {
    GLint i;
    GLSopcode op;
    shl_t sl = shl_load(__GL_LIB_NAME, BIND_DEFERRED | DYNAMIC_PATH, 0);

    if (!sl) {
        fprintf(stderr, "GLS fatal: shl_load failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    for (i = 0 ; op = __glsMapOpcode(__glsOpcodesGL[i]) ; ++i) {
        GLSfunc func;

        if (
            !shl_findsym(
                &sl,
                (const char *)__glsOpcodeString[op],
                TYPE_PROCEDURE,
                &func
            )
        ) {
            __glsDispatchExec[op] = func;
        } else {
            __glsDispatchExec[op] = __glsNop;
        }
    }
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* __GLS_PLATFORM_HPUX */

/******************************************************************************
IRIX
******************************************************************************/

#if __GLS_PLATFORM_IRIX

#if !__GLS_FAKE_MUTEX

#include <abi_mutex.h>

static abilock_t __gls_lock;

void __glsBeginCriticalSection(void) {
    spin_lock(&__gls_lock);
}

void __glsEndCriticalSection(void) {
    if (release_lock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: release_lock failed\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* !__GLS_FAKE_MUTEX */

void __glsFinalDSO(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
}

void __glsInitDSO(void) {
    #if __GLS_GL_DISPATCH_DSO
        __glsInitGLDispatch_DSO();
    #endif /* __GLS_GL_DISPATCH_DSO */
    #if !__GLS_FAKE_MUTEX
        if (init_lock(&__gls_lock)) {
            fprintf(stderr, "GLS fatal: init_lock failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_MUTEX */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#if !__GLS_GL_DISPATCH

#include "glxclient.h"

extern __GLdispatchState __glDispatchCapture;

void __glsBeginCaptureExec(GLSopcode inOpcode) {
    if (!__gl_dispatchOverride) return;
    __gl_dispatch = *__glXDispatchExec();
}

void __glsEndCaptureExec(GLSopcode inOpcode) {
    if (!__gl_dispatchOverride) return;
    __gl_dispatch = __glDispatchCapture;
}

void __glsUpdateDispatchTables(void) {
    if (__GLS_CONTEXT && __GLS_CONTEXT->captureNesting) {
        __glXBeginDispatchOverride(&__glDispatchCapture);
    } else if (!__GLS_CONTEXT || !__GLS_CONTEXT->captureNesting) {
        __glXEndDispatchOverride();
    }
}

#include "g_irix.c"

#endif /* !__GLS_GL_DISPATCH */

#endif /* __GLS_PLATFORM_IRIX */

/******************************************************************************
LINUX
******************************************************************************/

#if __GLS_PLATFORM_LINUX

void __glsFinalDSO(void) __attribute__ ((destructor));
void __glsInitDSO(void) __attribute__ ((constructor));

void __glsFinalDSO(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
    #if __GLS_POSIX_THREADS
        __glsFinalPthreads();
    #endif /* __GLS_POSIX_THREADS */
}

void __glsInitDSO(void) {
    #if __GLS_GL_DISPATCH_DSO
        __glsInitGLDispatch_DSO();
    #endif /* __GLS_GL_DISPATCH_DSO */
    #if __GLS_POSIX_THREADS
        __glsInitPthreads();
    #endif /* __GLS_POSIX_THREADS */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* __GLS_PLATFORM_LINUX */

/******************************************************************************
SOLARIS
******************************************************************************/

#if __GLS_PLATFORM_SOLARIS

#if !__GLS_FAKE_MUTEX

#include <synch.h>

static mutex_t __gls_lock;

void __glsBeginCriticalSection(void) {
    if (mutex_lock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: mutex_lock failed\n");
        exit(EXIT_FAILURE);
    }
}

void __glsEndCriticalSection(void) {
    if (mutex_unlock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: mutex_unlock failed\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* !__GLS_FAKE_MUTEX */

#if !__GLS_FAKE_THREAD_LOCAL_STORAGE

#include <thread.h>

thread_key_t __gls_contextTLS;
thread_key_t __gls_errorTLS;

__GLScontext* __glsGetContext(void) {
    __GLScontext *outContext;

    thr_getspecific(__gls_contextTLS, (GLvoid **)&outContext);
    return outContext;
}

GLSenum __glsGetError(void) {
    GLvoid *outError;

    thr_getspecific(__gls_errorTLS, &outError);
    return (GLSenum)outError;
}

#endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

#pragma fini(__glsFinalDSO)
#pragma init(__glsInitDSO)

void __glsFinalDSO(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
    #if !__GLS_FAKE_MUTEX
        mutex_destroy(&__gls_lock);
    #endif /* !__GLS_FAKE_MUTEX */
}

void __glsInitDSO(void) {
    #if __GLS_GL_DISPATCH_DSO
        __glsInitGLDispatch_DSO();
    #endif /* __GLS_GL_DISPATCH_DSO */
    #if !__GLS_FAKE_MUTEX
        if (mutex_init(&__gls_lock, USYNC_THREAD, GLS_NONE)) {
            fprintf(stderr, "GLS fatal: mutex_init failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        if (
            thr_keycreate(&__gls_contextTLS, GLS_NONE) ||
            thr_keycreate(&__gls_errorTLS, GLS_NONE)
        ) {
            fprintf(stderr, "GLS fatal: thr_keycreate failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* __GLS_PLATFORM_SOLARIS */

/******************************************************************************
WIN32
******************************************************************************/

#if __GLS_PLATFORM_WIN32

#include <string.h>
#include "g_win32.c"

#if !__GLS_FAKE_MUTEX

static CRITICAL_SECTION __gls_lock;

void __glsBeginCriticalSection(void) {
    EnterCriticalSection(&__gls_lock);
}

void __glsEndCriticalSection(void) {
    LeaveCriticalSection(&__gls_lock);
}

#endif /* !__GLS_FAKE_MUTEX */

#if !__GLS_FAKE_THREAD_LOCAL_STORAGE
    GLint __gls_contextTLS;
    GLint __gls_errorTLS;
#endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

// DrewB
typedef PROC (APIENTRY *wglGetDefaultProcAddressFunc)(LPCSTR);

BOOL __glsDLLProcessAttach(void) {
    GLvoid *const dll = LoadLibrary(__GL_LIB_NAME);
    GLint i;
    GLSopcode op;
    // DrewB
    wglGetDefaultProcAddressFunc pfnGetDefaultProcAddress;

    if (!dll) {
        fprintf(
            stderr, "GLS fatal: LoadLibrary failed on %s\n", __GL_LIB_NAME
        );
        return GL_FALSE;
    }
    
    // DrewB
    pfnGetDefaultProcAddress = (wglGetDefaultProcAddressFunc)
        GetProcAddress(dll, "wglGetDefaultProcAddress");
    
    for (i = 0 ; op = __glsMapOpcode(__glsOpcodesGL[i]) ; ++i) {
        GLSfunc func;

        func = (GLSfunc) GetProcAddress(dll, __glsOpcodeString[op]);
        if (func == NULL)
        {
            func = (GLSfunc) pfnGetDefaultProcAddress(__glsOpcodeString[op]);
        }

        __glsDispatchExec[op] = func ? func : __glsNullCommandFuncs[op];
    }

    for (i = 0 ; i < __GLS_OPCODE_COUNT ; ++i) {
        if (__glsOpcodeAttrib[i] & __GLS_COMMAND_0_PARAMS_BIT) {
            __glsDispatchDecode_bin_default[i] =
                __glsDispatchDecode_bin_swap[i];
        }
    }
    
    #if !__GLS_FAKE_MUTEX
        __try 
        {
            InitializeCriticalSection(&__gls_lock);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return GL_FALSE;
        }
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        __gls_contextTLS = TlsAlloc();
        __gls_errorTLS = TlsAlloc();
        if (__gls_contextTLS == -1 || __gls_errorTLS == -1) {
            fprintf(stderr, "GLS fatal: TlsAlloc failed\n");
            return GL_FALSE;
        }
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        return GL_FALSE;
    }
    return GL_TRUE;
}

BOOL __glsDLLProcessDetach(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
    #if !__GLS_FAKE_MUTEX
        DeleteCriticalSection(&__gls_lock);
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        TlsFree(__gls_contextTLS);
        TlsFree(__gls_errorTLS);
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
    return GL_TRUE;
}

BOOL DllMain(HINSTANCE hModule, DWORD inReason, LPVOID inReserved) {
    inReserved;
    switch (inReason) {
        case DLL_PROCESS_ATTACH:
            return __glsDLLProcessAttach();
        case DLL_PROCESS_DETACH:
            return __glsDLLProcessDetach();
    }
    return GL_TRUE;
}

GLlong __gls_strtoi64(const char *inStr, char **outPtr, int inBase) {
    GLlong outVal;

    inBase;
    if (sscanf(inStr, "%I64i", &outVal) == 1) {
        if (outPtr) *outPtr = (char *)inStr + strlen(inStr);
        return outVal;
    } else {
        if (outPtr) *outPtr = (char *)inStr;
        return 0;
    }
}

GLulong __gls_strtoui64(const char *inStr, char **outPtr, int inBase) {
    GLulong outVal;

    inBase;
    if (sscanf(inStr, "%I64i", &outVal) ==1) {
        if (outPtr) *outPtr = (char *)inStr + strlen(inStr);
        return outVal;
    } else {
        if (outPtr) *outPtr = (char *)inStr;
        return 0;
    }
}

GLSfunc glsNullCommandFunc(GLSopcode inOpcode) {
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    return __glsNullCommandFuncs[__glsMapOpcode(inOpcode)];
}

#endif /* __GLS_PLATFORM_WIN32 */

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\opcode.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

GLSopcode __glsMapOpcode(GLSopcode inOpcode) {
    GLint i;
    const GLint page = __GLS_OPCODE_PAGE(inOpcode);

    if (page < __GLS_OPCODE_PAGE_MAPPED0) return inOpcode;
    #if __GLS_MAPPED_OPCODE_PAGE_COUNT
        for (i = 0 ; i < __GLS_MAPPED_OPCODE_PAGE_COUNT ; ++i) {
            if (page == __glsOpPageMap[i]) return (
                __GLS_OPCODE(
                    __GLS_OPCODE_PAGE_MAPPED0 + i,
                    __GLS_OPCODE_OFFSET(inOpcode)
                )
            );
        }
    #endif /* __GLS_MAPPED_OPCODE_PAGE_COUNT */
    return GLS_NONE;
}

GLSenum __glsOpcodeAPI(GLSopcode inOpcode) {
    switch (__GLS_OPCODE_PAGE(inOpcode)) {
        case __GLS_OPCODE_PAGE_GLS0:
        case __GLS_OPCODE_PAGE_GLS1:
        case __GLS_OPCODE_PAGE_GLS2:
            return (
                __glsOpcodeString[__glsMapOpcode(inOpcode)] ?
                GLS_API_GLS :
                GLS_NONE
            );
        case __GLS_OPCODE_PAGE_GL0:
        case __GLS_OPCODE_PAGE_GL1:
        case __GLS_OPCODE_PAGE_GL2:
        case __GLS_OPCODE_PAGE_GL3:
        case __GLS_OPCODE_PAGE_GL4:
        case __GLS_OPCODE_PAGE_GL5:
        case __GLS_OPCODE_PAGE_GL6:
        case __GLS_OPCODE_PAGE_GL7:
        case __GLS_OPCODE_PAGE_GL8:
        case __GLS_OPCODE_PAGE_GL9:
        case __GLS_OPCODE_PAGE_GL10:
        case __GLS_OPCODE_PAGE_GL11:
        case __GLS_OPCODE_PAGE_GL12:
        case __GLS_OPCODE_PAGE_GL13:
        case __GLS_OPCODE_PAGE_GL14:
        case __GLS_OPCODE_PAGE_GL15:
        case __GLS_OPCODE_PAGE_GL16:
        case __GLS_OPCODE_PAGE_GL17:
        case __GLS_OPCODE_PAGE_GL18:
        case __GLS_OPCODE_PAGE_GL19:
        // DrewB - 1.1
        case __GLS_OPCODE_PAGE_GL20:
        case __GLS_OPCODE_PAGE_GL_SGI0:
        case __GLS_OPCODE_PAGE_GL_SGI1:
        case __GLS_OPCODE_PAGE_GL_SGI2:
        case __GLS_OPCODE_PAGE_GL_SGI3:
        case __GLS_OPCODE_PAGE_GL_SGI4:
        // DrewB - ColorSubTable
        case __GLS_OPCODE_PAGE_GL_MSFT0:
            return (
                __glsOpcodeString[__glsMapOpcode(inOpcode)] ?
                GLS_API_GL :
                GLS_NONE
            );
    }
    return GLS_NONE;
}

GLSopcode __glsUnmapOpcode(GLSopcode inOpcode) {
    GLint i;
    const GLint page = __GLS_OPCODE_PAGE(inOpcode);

    if (page < __GLS_OPCODE_PAGE_MAPPED0) return inOpcode;
    #if __GLS_MAPPED_OPCODE_PAGE_COUNT
        for (i = 0 ; i < __GLS_MAPPED_OPCODE_PAGE_COUNT ; ++i) {
            if (page == __GLS_OPCODE_PAGE_MAPPED0 + i) return (
                __GLS_OPCODE(__glsOpPageMap[i], __GLS_OPCODE_OFFSET(inOpcode))
            );
        }
    #endif /* __GLS_MAPPED_OPCODE_PAGE_COUNT */
    return GLS_NONE;
}

GLboolean __glsValidateOpcode(GLSopcode inOpcode) {
    if (!__glsOpcodeAPI(inOpcode)) {
        __GLS_RAISE_ERROR(GLS_UNSUPPORTED_COMMAND);
        return GL_FALSE;
    }
    return GL_TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\readbin.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

#define __GLS_HEAD_LARGE_BYTES sizeof(__GLSbinCommandHead_large)

GLboolean __glsReader_call_bin(__GLSreader *inoutReader) {
    GLubyte *pc;
    GLubyte *pcNext;
    GLuint word;
    __GLSdecodeBinFunc *const dispatchDecode = (
        __GLS_CONTEXT->dispatchDecode_bin
    );
    GLubyte *pcLimit;

    if (
        inoutReader->readPtr + __GLS_HEAD_LARGE_BYTES > inoutReader->readTail &&
        !__glsReader_fillBuf(inoutReader, __GLS_HEAD_LARGE_BYTES, GL_TRUE)
    ) {
        __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
        return GL_FALSE;
    }
    pc = inoutReader->readPtr;
    pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
    for (;;) {
        if (word = *(GLuint *)pc) {
            pcNext = pc + (__GLS_COUNT_SMALL(word) << 2);
            word = __glsMapOpcode(__GLS_OP_SMALL(word));
            if (pcNext > pcLimit) {
                inoutReader->readPtr = pc;
                if (__GLS_CONTEXT->abortMode) break;
                if (!__glsReader_fillBuf(
                    inoutReader, (size_t)(pcNext - pc + __GLS_HEAD_LARGE_BYTES), GL_TRUE
                )) {
                    __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                    break;
                }
                pc = inoutReader->readPtr;
                pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
            } else if (pcNext == pc) {
                inoutReader->readPtr = pc;
                __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                break;
            } else if (!__glsOpcodeString[word]) {
                __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
                pc = pcNext;
            } else {
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                dispatchDecode[word](pc + 4);
#else
                dispatchDecode[word](__GLS_CONTEXT, pc + 4);
#endif
                pc = pcNext;
            }
        } else if (word = __GLS_HEAD_LARGE(pc)->opLarge) {
            word = __glsMapOpcode(word);

            pcNext = pc + (__GLS_HEAD_LARGE(pc)->countLarge << 2);
            if (word == GLS_OP_glsEndGLS) {
                inoutReader->readPtr = pcNext;
                return GL_TRUE;
            } else if (pcNext > pcLimit) {
                inoutReader->readPtr = pc;
                if (__GLS_CONTEXT->abortMode) break;
                if (!__glsReader_fillBuf(
                    inoutReader, (size_t)((ULONG_PTR)(pcNext - pc + __GLS_HEAD_LARGE_BYTES)), GL_TRUE
                )) {
                    __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                    break;
                }
                pc = inoutReader->readPtr;
                pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
            } else if (pcNext == pc) {
                inoutReader->readPtr = pc;
                __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                break;
            } else if (!__glsOpcodeString[word]) {
                __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
                pc = pcNext;
            } else {
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                dispatchDecode[word](pc + 12);
#else
                dispatchDecode[word](__GLS_CONTEXT, pc + 12);
#endif
                pc = pcNext;
            }
        } else {
            inoutReader->readPtr = pc;
            __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
            break;
        }
    }
    return GL_FALSE;
}

GLboolean __glsReader_call_bin_swap(__GLSreader *inoutReader) {
    GLubyte *pc;
    GLubyte *pcNext;
    GLuint word;
    const __GLSdecodeBinFunc *const dispatchDecode = (
        __glsDispatchDecode_bin_swap
    );
    GLubyte *pcLimit;

    if (
        inoutReader->readPtr + __GLS_HEAD_LARGE_BYTES > inoutReader->readTail &&
        !__glsReader_fillBuf(inoutReader, __GLS_HEAD_LARGE_BYTES, GL_TRUE)
    ) {
        __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
        return GL_FALSE;
    }
    pc = inoutReader->readPtr;
    pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
    for (;;) {
        if (__GLS_CONTEXT->abortMode) {
            inoutReader->readPtr = pc;
            break;
        } else if (*(GLuint *)pc) {
            __glsSwap2(pc);
            __glsSwap2(pc + 2);
            word = *(GLuint*)pc;
            pcNext = pc + (__GLS_COUNT_SMALL(word) << 2);
            word = __glsMapOpcode(__GLS_OP_SMALL(word));
            if (pcNext > pcLimit) {
                inoutReader->readPtr = pc;
                if (!__glsReader_fillBuf(
                    inoutReader, (size_t)((ULONG_PTR)(pcNext - pc + __GLS_HEAD_LARGE_BYTES)), GL_TRUE
                )) {
                    __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                    break;
                }
                pc = inoutReader->readPtr;
                pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
                __glsSwap2(pc);
                __glsSwap2(pc + 2);
            } else if (pcNext == pc) {
                inoutReader->readPtr = pc;
                __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                break;
            } else if (!__glsOpcodeString[word]) {
                __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
                pc = pcNext;
            } else {
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                dispatchDecode[word](pc + 4);
#else
                dispatchDecode[word](__GLS_CONTEXT, pc + 4);
#endif
                pc = pcNext;
            }
        } else if (__GLS_HEAD_LARGE(pc)->opLarge) {
            __glsSwap4(&__GLS_HEAD_LARGE(pc)->opLarge);
            __glsSwap4(&__GLS_HEAD_LARGE(pc)->countLarge);
            word = __glsMapOpcode(__GLS_HEAD_LARGE(pc)->opLarge);
            pcNext = pc + (__GLS_HEAD_LARGE(pc)->countLarge << 2);
            if (word == GLS_OP_glsEndGLS) {
                inoutReader->readPtr = pcNext;
                return GL_TRUE;
            } else if (pcNext > pcLimit) {
                inoutReader->readPtr = pc;
                if (!__glsReader_fillBuf(
                    inoutReader, (size_t)((ULONG_PTR)(pcNext - pc + __GLS_HEAD_LARGE_BYTES)), GL_TRUE
                )) {
                    __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                    break;
                }
                pc = inoutReader->readPtr;
                pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
                __glsSwap4(&__GLS_HEAD_LARGE(pc)->opLarge);
                __glsSwap4(&__GLS_HEAD_LARGE(pc)->countLarge);
            } else if (pcNext == pc) {
                inoutReader->readPtr = pc;
                __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                break;
            } else if (!__glsOpcodeString[word]) {
                __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
                pc = pcNext;
            } else {
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                dispatchDecode[word](pc + 12);
#else
                dispatchDecode[word](__GLS_CONTEXT, pc + 12);
#endif
                pc = pcNext;
            }
        } else {
            inoutReader->readPtr = pc;
            __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
            break;
        }
    }
    return GL_FALSE;
}

GLSenum __glsReader_readBeginGLS_bin(
    __GLSreader *inoutReader, __GLSversion *outVersion
) {
    if (__glsReader_fillBuf(
        inoutReader, sizeof(__GLSbinCommand_BeginGLS), GL_FALSE
    )) {
        const GLSenum outType = __glsBinCommand_BeginGLS_getType(
            (__GLSbinCommand_BeginGLS *)inoutReader->readPtr, outVersion
        );

        if (outType != GLS_NONE) {
            inoutReader->readPtr += sizeof(__GLSbinCommand_BeginGLS);
        }
        return outType;
    } else {
        return GLS_NONE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\parser.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>

__GLSparser* __glsParser_create(void) {
    __GLSparser *const outParser = __glsCalloc(1, sizeof(__GLSparser));
    GLint count, i, j;

    if (!outParser) return GLS_NONE;
    outParser->glAttribMaskDict = __glsStrDict_create(
        __GL_ATTRIB_MASK_COUNT, GL_TRUE
    );
    if (!outParser->glAttribMaskDict) return __glsParser_destroy(outParser);
    for (i = 0 ; i < __GL_ATTRIB_MASK_COUNT ; ++i) {
        if (!__glsStr2IntDict_add(
            outParser->glAttribMaskDict,
            __glAttribMaskString[i],
            (GLint)__glAttribMaskVal[i]
        )) {
            return __glsParser_destroy(outParser);
        }
    }
    /* GL_ZERO GL_ONE GL_FALSE GL_TRUE GL_NONE GL_NO_ERROR */
    count = 6;
    for (i = 0 ; i < __GL_ENUM_PAGE_COUNT ; ++i) {
        count += __glEnumStringCount[i];
    }
    outParser->glEnumDict = __glsStrDict_create(count, GL_TRUE);
    if (!outParser->glEnumDict) return __glsParser_destroy(outParser);
    if (
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_ZERO"), 0) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_ONE"), 1) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_FALSE"), 0) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_TRUE"), 1) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_NONE"), 0) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_NO_ERROR"), 0)
    ) {
        return __glsParser_destroy(outParser);
    }
    for (i = 0 ; i < __GL_ENUM_PAGE_COUNT ; ++i) {
        for (j = 0 ; j < __glEnumStringCount[i] ; ++j) {
            if (__glEnumString[i][j] && !__glsStr2IntDict_add(
                outParser->glEnumDict,
                __glEnumString[i][j],
                __GL_ENUM(i, j)
            )) {
                return __glsParser_destroy(outParser);
            }
        }
    }
    /* GL_FALSE GL_TRUE */
    count = 2;
    for (i = 0 ; i < __GLS_ENUM_PAGE_COUNT ; ++i) {
        count += __glsEnumStringCount[i];
    }
    outParser->glsEnumDict = __glsStrDict_create(count, GL_TRUE);
    if (!outParser->glsEnumDict) return __glsParser_destroy(outParser);
    if (
        !__glsStr2IntDict_add(
            outParser->glsEnumDict, glsCSTR("GL_FALSE"), 0
        ) ||
        !__glsStr2IntDict_add(
            outParser->glsEnumDict, glsCSTR("GL_TRUE"), 1
        )
    ) {
        return __glsParser_destroy(outParser);
    }
    for (i = 0 ; i < __GLS_ENUM_PAGE_COUNT ; ++i) {
        for (j = 0 ; j < __glsEnumStringCount[i] ; ++j) {
            if (__glsEnumString[i][j] && !__glsStr2IntDict_add(
                outParser->glsEnumDict,
                __glsEnumString[i][j],
                __GLS_ENUM(i, j)
            )) {
                return __glsParser_destroy(outParser);
            }
        }
    }
    outParser->glsImageFlagsDict = __glsStrDict_create(
        __GLS_IMAGE_FLAGS_COUNT, GL_TRUE
    );
    if (!outParser->glsImageFlagsDict) return __glsParser_destroy(outParser);
    for (i = 0 ; i < __GLS_IMAGE_FLAGS_COUNT ; ++i) {
        if (!__glsStr2IntDict_add(
            outParser->glsImageFlagsDict,
            __glsImageFlagsString[i],
            (GLint)__glsImageFlagsVal[i]
        )) {
            return __glsParser_destroy(outParser);
        }
    }
    for (
        count = 0, i = __GLS_OPCODES_PER_PAGE ; i < __GLS_OPCODE_COUNT ; ++i
    ) {
        if (__glsOpcodeString[i]) ++count;
    }
    outParser->glsOpDict = __glsStrDict_create(count, GL_TRUE);
    if (!outParser->glsOpDict) return __glsParser_destroy(outParser);

    for (i = __GLS_OPCODES_PER_PAGE ; i < __GLS_OPCODE_COUNT ; ++i) {
        if (__glsOpcodeString[i] && !__glsStr2IntDict_add(
            outParser->glsOpDict,
            __glsOpcodeString[i],
            (GLint)__glsUnmapOpcode(i)
        )) {
            return __glsParser_destroy(outParser);
        }
    }
    return outParser;
}

__GLSparser* __glsParser_destroy(__GLSparser *inParser) {
    if (!inParser) return GLS_NONE;
    __glsStrDict_destroy(inParser->glAttribMaskDict);
    __glsStrDict_destroy(inParser->glEnumDict);
    __glsStrDict_destroy(inParser->glsEnumDict);
    __glsStrDict_destroy(inParser->glsImageFlagsDict);
    __glsStrDict_destroy(inParser->glsOpDict);
    free(inParser);
    return GLS_NONE;
}

GLboolean __glsParser_findCommand(
    const __GLSparser *inParser, const GLubyte *inCommand, GLSopcode *outOpcode
) {
    if (
        __glsStr2IntDict_find(inParser->glsOpDict, inCommand, (GLint*)outOpcode
    )) {
        return GL_TRUE;
    } else {
        __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
        *outOpcode = GLS_OP_glsUnsupportedCommand;
        return GL_FALSE;
    }
}

void __glsParser_print(const __GLSparser *inParser) {
    __glsStrDict_print(
        inParser->glAttribMaskDict, glsCSTR("glAttribMaskDict")
    );
    __glsStrDict_print(
        inParser->glEnumDict, glsCSTR("glEnumDict")
    );
    __glsStrDict_print(
        inParser->glsEnumDict, glsCSTR("glsEnumDict")
    );
    __glsStrDict_print(
        inParser->glsImageFlagsDict, glsCSTR("glsImageFlagsDict")
    );
    __glsStrDict_print(
        inParser->glsOpDict, glsCSTR("glsOpDict")
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\read.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

/******************************************************************************
__GLSreadStream
******************************************************************************/

__GLSreadStream* __glsReadStream_create(const GLubyte *inName) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSreadStream *const outStream = __glsCalloc(
        1, sizeof(__GLSreadStream)
    );

    if (!outStream) return GLS_NONE;
    __glsString_init(&outStream->name);
    outStream->unreadFunc = ctx->unreadFunc;
    if (inName[0]) {
        const GLubyte *openName;

        __GLS_ITERLIST_FIRST(&ctx->readPrefixList);
        while (ctx->readPrefixList.iterElem) {
            if (
                !__glsListString_prefix(
                    ctx->readPrefixList.iterElem, inName, &outStream->name
                ) ||
                !(openName = __glsUCS1String(outStream->name.head))
            ) {
                return __glsReadStream_destroy(outStream);
            }
            outStream->channel = fopen((const char *)openName, "rb");
            if (openName != outStream->name.head) free((GLvoid *)openName);
            if (outStream->channel) {
                setbuf(outStream->channel, GLS_NONE);
                outStream->opened = GL_TRUE;
                return outStream;
            }
            __GLS_ITERLIST_NEXT(&ctx->readPrefixList);
        }
        if (
            !__glsListString_prefix(
                ctx->writePrefix, inName, &outStream->name
            ) ||
            !(openName = __glsUCS1String(outStream->name.head))
        ) {
            return __glsReadStream_destroy(outStream);
        }
        outStream->channel = fopen((const char *)openName, "rb");
        if (openName != outStream->name.head) free((GLvoid *)openName);
        if (outStream->channel) {
            setbuf(outStream->channel, GLS_NONE);
            outStream->opened = GL_TRUE;
            return outStream;
        }
        return __glsReadStream_destroy(outStream);
    } else {
        outStream->readFunc = ctx->readFunc;
        if (!outStream->readFunc) outStream->channel = ctx->defaultReadChannel;
        return outStream;
    }
}

__GLSreadStream* __glsReadStream_destroy(__GLSreadStream *inStream) {
    if (!inStream) return GLS_NONE;

    if (inStream->opened && fclose(inStream->channel)) {
        __GLS_RAISE_ERROR(GLS_STREAM_CLOSE_ERROR);
    }
    __glsString_final(&inStream->name);
    free(inStream);
    return GLS_NONE;
}

GLbitfield __glsReadStream_getAttrib(const __GLSreadStream *inStream) {
    GLbitfield outVal = GLS_STREAM_READABLE_BIT;

    if (inStream->opened) {
        const GLubyte *const openName = __glsUCS1String(inStream->name.head);
        FILE *channel;

        if (!openName) return GLS_NONE;
        channel = fopen((const char *)openName, "ab");
        if (openName != inStream->name.head) free((GLvoid *)openName);
        if (channel) {
            fclose(channel);
            outVal |= GLS_STREAM_WRITABLE_BIT;
        }
        outVal |= GLS_STREAM_NAMED_BIT;
    }
    if (!fseek(inStream->channel, 0, SEEK_CUR)) {
        outVal |= GLS_STREAM_SEEKABLE_BIT;
    }
    return outVal;
}

size_t __glsReadStream_getByteCount(const __GLSreadStream *inStream) {
    long outVal;
    fpos_t pos;

    if (!inStream->channel) return 0;
    if (
        fgetpos(inStream->channel, &pos) ||
        fseek(inStream->channel, 0, SEEK_END)
    ) {
        return 0;
    }
    outVal = ftell(inStream->channel);
    fsetpos(inStream->channel, &pos);
    return outVal == -1L ? 0 : (size_t)outVal;
}

GLuint __glsReadStream_getCRC32(const __GLSreadStream *inStream) {
    GLubyte buf[__GLS_CHECKSUM_BUF_BYTES];
    size_t i, n;
    GLuint outVal = 0xffffffff;
    fpos_t pos;

    if (!inStream->channel) return 0;
    if (
        fgetpos(inStream->channel, &pos) ||
        fseek(inStream->channel, 0, SEEK_SET)
    ) {
        return 0;
    }
    while (n = fread(buf, 1, __GLS_CHECKSUM_BUF_BYTES, inStream->channel)) {
        for (i = 0 ; i < n ; ++i) __GLS_CRC32_STEP(outVal, buf[i]);
    }
    fsetpos(inStream->channel, &pos);
    if (ferror(inStream->channel)) {
        __GLS_RAISE_ERROR(GLS_STREAM_READ_ERROR);
        clearerr(inStream->channel);
        return 0;
    }
    return ~outVal;
}

GLSenum __glsReadStream_getType(const __GLSreadStream *inStream) {
    __GLSreader reader;

    if (!inStream->channel) return GLS_NONE;
    if (fseek(inStream->channel, 0, SEEK_CUR)) return GLS_UNKNOWN;
    if (__glsReader_init_stream(&reader, inStream, 256)) {
        const GLenum outType = reader.type;

        __glsReader_final(&reader);
        return outType;
    } else {
        return GLS_NONE;
    }
}

/******************************************************************************
__GLSreader
******************************************************************************/

GLvoid* __glsReader_allocCallBuf(
    __GLSreader *inoutReader, size_t inByteCount
) {
    GLvoid *outVal;

    if (inoutReader->error) return GLS_NONE;
    outVal = __glsMalloc(inByteCount);
    if (!outVal) __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY);
    return outVal;
}

GLvoid* __glsReader_allocFeedbackBuf(
    __GLSreader *inoutReader, size_t inByteCount
) {
    GLvoid *outVal;

    if (inoutReader->error) return GLS_NONE;
    outVal = __glsContext_allocFeedbackBuf(__GLS_CONTEXT, inByteCount);
    if (!outVal) __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY);
    return outVal;
}

GLvoid* __glsReader_allocSelectBuf(
    __GLSreader *inoutReader, size_t inByteCount
) {
    GLvoid *outVal;

    if (inoutReader->error) return GLS_NONE;
    outVal = __glsContext_allocSelectBuf(__GLS_CONTEXT, inByteCount);
    if (!outVal) __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY);
    return outVal;
}

#if __GL_EXT_vertex_array
GLvoid* __glsReader_allocVertexArrayBuf(
    __GLSreader *inoutReader, GLSopcode inOpcode, size_t inByteCount
) {
    GLvoid *outVal;

    if (inoutReader->error) return GLS_NONE;
    outVal = __glsContext_allocVertexArrayBuf(
        __GLS_CONTEXT, inOpcode, inByteCount
    );
    if (!outVal) __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY);
    return outVal;
}
#endif /* __GL_EXT_vertex_array */

void __glsReader_call(__GLSreader *inoutReader) {
    GLboolean callSave;
    __GLScontext *const ctx = __GLS_CONTEXT;

    callSave = ctx->contextCall;
    ctx->contextCall = GL_FALSE;
    while (inoutReader->type != GLS_NONE) {
#ifndef __GLS_PLATFORM_WIN32
        // DrewB
        ctx->dispatchDecode_bin[GLS_OP_glsBeginGLS](
            (GLubyte *)&inoutReader->version
        );
#else
        ctx->dispatchDecode_bin[GLS_OP_glsBeginGLS](
            ctx, (GLubyte *)&inoutReader->version
        );
#endif
        if (inoutReader->type == GLS_TEXT) {
            if (!__glsReader_call_text(inoutReader)) break;
            inoutReader->readHead = inoutReader->readPtr;
            __GLS_GET_SPACE(inoutReader);
        } else if (inoutReader->type == __GLS_BINARY_SWAP0) {
            if (!__glsReader_call_bin(inoutReader)) break;
            inoutReader->readHead = inoutReader->readPtr;
        } else {
            if (!__glsReader_call_bin_swap(inoutReader)) break;
            inoutReader->readHead = inoutReader->readPtr;
        }
#ifndef __GLS_PLATFORM_WIN32
        // DrewB
        ctx->dispatchDecode_bin[GLS_OP_glsEndGLS](GLS_NONE);
#else
        ctx->dispatchDecode_bin[GLS_OP_glsEndGLS](ctx, GLS_NONE);
#endif
        inoutReader->type = __glsReader_readBeginGLS_bin(
            inoutReader, &inoutReader->version
        );
        if (inoutReader->type == GLS_NONE) {
            inoutReader->type = __glsReader_readBeginGLS_text(
                inoutReader, &inoutReader->version
            );
        }
        if (inoutReader->type == GLS_NONE) {
            inoutReader->readPtr = inoutReader->readHead;
        }
        inoutReader->readHead = GLS_NONE;
    }
    ctx->contextCall = callSave;
}

__GLSreader* __glsReader_final(__GLSreader *inoutReader) {
    if (inoutReader && inoutReader->stream) {
        const ptrdiff_t excess = inoutReader->readTail - inoutReader->readPtr;
        if (excess > 0) {
            if (
                (
                    !inoutReader->stream->channel ||
                    fseek(
                        inoutReader->stream->channel,
                        -1 * (long)excess,
                        SEEK_CUR
                    )
                ) &&
                __GLS_CONTEXT->unreadFunc
            ) {
                __GLS_CONTEXT->unreadFunc(
                    (size_t)excess, inoutReader->readPtr
                );
            }
        }
        free(inoutReader->buf);
    }
    return GLS_NONE;
}

GLboolean __glsReader_fillBuf(
    __GLSreader *inoutReader, size_t inMinBytes, GLboolean inRealign
) {
    FILE *channel;
    size_t keepBytes, needBytes, padBytes, unreadBytes;
    GLubyte *ptr, *readHead;

    if (!inoutReader->readPtr || !inoutReader->stream) return GL_FALSE;
    readHead = (
        inoutReader->readHead ? inoutReader->readHead : inoutReader->readPtr
    );
    keepBytes = (size_t)((ULONG_PTR)(inoutReader->readPtr - readHead));
    unreadBytes = (size_t)((ULONG_PTR)(inoutReader->readTail - inoutReader->readPtr));
    if (inRealign) {
        padBytes = (size_t)((ULONG_PTR)(readHead - inoutReader->buf) & (__GLS_MAX_ALIGN_BYTES - 4));
    } else if (keepBytes % __GLS_MAX_ALIGN_BYTES) {
        padBytes = __GLS_MAX_ALIGN_BYTES - keepBytes % __GLS_MAX_ALIGN_BYTES;
    } else {
        padBytes = 0;
    }
    needBytes = padBytes + keepBytes + __GLS_MAX(inMinBytes, unreadBytes);
    if (needBytes > inoutReader->bufSize) {
        GLubyte *const buf = __glsMalloc(needBytes);

        if (!buf) goto eos;
        ptr = buf + padBytes;
        while (readHead < inoutReader->readTail) *ptr++ = *readHead++;
        free(inoutReader->buf);
        inoutReader->buf = buf;
        inoutReader->bufSize = needBytes;
    } else {
        ptr = inoutReader->buf + padBytes;
        if (ptr != readHead) memmove(ptr, readHead, keepBytes + unreadBytes);
    }
    readHead = inoutReader->buf + padBytes;
    if (inoutReader->readHead) inoutReader->readHead = readHead;
    inoutReader->readPtr = readHead + keepBytes;
    inoutReader->readTail = inoutReader->readPtr + unreadBytes;
    channel = inoutReader->stream->channel;
    for (;;) {
        if (
            (size_t)(inoutReader->readTail - inoutReader->readPtr) >=
            inMinBytes
        ) {
            return GL_TRUE;
        }
        ptr = inoutReader->readTail;
        if (channel) {
            inoutReader->readTail += fread(
                ptr,
                1,
                (size_t)((ULONG_PTR)(inoutReader->buf + inoutReader->bufSize - ptr)),
                channel
            );
            if (ferror(channel)) {
                __GLS_RAISE_ERROR(GLS_STREAM_READ_ERROR);
                clearerr(channel);
            }
        } else {
            inoutReader->readTail += inoutReader->stream->readFunc(
                (size_t)((ULONG_PTR)(inoutReader->buf + inoutReader->bufSize - ptr)), ptr
            );
        }
        if (inoutReader->readTail <= ptr) break;
    }
eos:
    inoutReader->readHead = GLS_NONE;
    inoutReader->readPtr = GLS_NONE;
    inoutReader->readTail = GLS_NONE;
    return GL_FALSE;
}

__GLSreader* __glsReader_init_array(
    __GLSreader *outReader, const GLubyte *inArray, size_t inCount
) {
    memset(outReader, 0, sizeof(__GLSreader));
    outReader->buf = (GLubyte *)inArray;
    outReader->bufSize = inCount;
    outReader->readPtr = outReader->buf;
    outReader->readTail = outReader->buf + inCount;
    return outReader;
}

__GLSreader* __glsReader_init_stream(
    __GLSreader *outReader, const __GLSreadStream *inStream, size_t inBufSize
) {
    memset(outReader, 0, sizeof(__GLSreader));
    outReader->stream = inStream;
    outReader->buf = __glsMalloc(inBufSize);
    if (!outReader->buf) return __glsReader_final(outReader);
    outReader->bufSize = inBufSize;
    outReader->readPtr = outReader->buf;
    outReader->readTail = outReader->buf;
    outReader->readHead = outReader->readPtr;
    outReader->type = __glsReader_readBeginGLS_bin(
        outReader, &outReader->version
    );
    if (outReader->type == GLS_NONE) {
        outReader->type = __glsReader_readBeginGLS_text(
            outReader, &outReader->version
        );
    }
    if (outReader->type == GLS_NONE) {
        outReader->readPtr = outReader->readHead;
        return __glsReader_final(outReader);
    }
    outReader->readHead = GLS_NONE;
    return outReader;
}

void __glsReader_raiseError(__GLSreader *inoutReader, GLSenum inError) {
    if (!inoutReader->error) inoutReader->error = inError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\readtxt.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

/******************************************************************************
Helpers
******************************************************************************/

#define __GLS_BEGIN_PARAM(inoutReader) \
    if ( \
        inoutReader->error || \
        inoutReader->paramCount++ && \
        !__glsReader_getChar_text(inoutReader, ',', GL_TRUE) \
    ) { \
        return GL_FALSE; \
    }

#define __GLS_GET_TEXT(inType, inBase) \
    __GLS_GET_TEXT_VAL(inType, inBase) \
    __GLS_GET_TEXT_VEC(inType, inBase)

#define __GLS_GET_TEXT_VAL(inType, inBase) \
GLboolean __glsReader_get##inType##_text( \
    __GLSreader *inoutReader, inType *outVal \
) { \
    __GLSstring token; \
    __glsString_init(&token); \
    __GLS_BEGIN_PARAM(inoutReader); \
    if ( \
        __glsReader_getToken_text(inoutReader, &token) && \
        __glsTokenTo##inBase(token.head, outVal) \
    ) { \
        __glsString_final(&token); \
        return GL_TRUE; \
    } else { \
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR); \
        __glsString_final(&token); \
        return GL_FALSE; \
    } \
}

#define __GLS_GET_TEXT_VEC(inType, inBase) \
GLboolean __glsReader_get##inType##v_text( \
    __GLSreader *inoutReader, GLuint inCount, inType *outVec \
) { \
    __GLSstring token; \
    __GLS_BEGIN_PARAM(inoutReader); \
    if (!__glsReader_getChar_text(inoutReader, '{', GL_TRUE)) { \
        return GL_FALSE; \
    } \
    __glsString_init(&token); \
    while (inCount-- > 0) if ( \
        !__glsReader_getToken_text(inoutReader, &token) || \
        !__glsTokenTo##inBase(token.head, outVec++) || \
        inCount > 0 && !__glsReader_getChar_text(inoutReader, ',', GL_TRUE) \
    ) { \
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR); \
        __glsString_final(&token); \
        return GL_FALSE; \
    } \
    __glsString_final(&token); \
    __glsReader_getChar_text(inoutReader, ',', GL_FALSE); \
    if (!__glsReader_getChar_text(inoutReader, '}', GL_TRUE)) { \
        return GL_FALSE; \
    } \
    return GL_TRUE; \
}

#define __GLS_READER_APPEND_CHAR(inoutReader, inoutString, inChar) \
    if (!__glsString_appendChar(inoutString, inChar)) { \
        __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY); \
        return GL_FALSE; \
    }

/******************************************************************************
Token converters
******************************************************************************/

__GLS_FORWARD static GLboolean __glsTokenToGLulong(
    const GLubyte *inToken, GLulong *outVal
);
__GLS_FORWARD static GLboolean __glsTokenToGLuint(
    const GLubyte *inToken, GLuint *outVal
);

static GLubyte __glsQuotedChar(const GLubyte *inToken, GLubyte **outPtr) {
    if (
        inToken[0] == '\''&&
        inToken[2] == '\'' &&
        !inToken[3] &&
        __GLS_CHAR_IS_GRAPHIC(inToken[1])
    ) {
        if (outPtr) *outPtr = (GLubyte *)inToken + 3;
        return inToken[1];
    } else {
        if (outPtr) *outPtr = (GLubyte *)inToken;
        return 0;
    }
}

static GLboolean __glsTokenToGLboolean(
    const GLubyte *inToken, GLboolean *outVal
) {
    GLubyte *ptr;
    unsigned long val;
    
    if (!strcmp((const char *)inToken, "GL_FALSE")) {
        *outVal = GL_FALSE;
        return GL_TRUE;
    } else if (!strcmp((const char *)inToken, "GL_TRUE")) {
        *outVal = GL_TRUE;
        return GL_TRUE;
    }
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    *outVal = (GLboolean)val;
    return (GLboolean)(!*ptr && val <= UCHAR_MAX);
}

static GLboolean __glsTokenToGLbyte(const GLubyte *inToken, GLbyte *outVal) {
    GLubyte *ptr;
    long val;
    
    val = strtol((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) val = __glsQuotedChar(inToken, &ptr);
    *outVal = (GLbyte)val;
    return (GLboolean)(!*ptr && val >= SCHAR_MIN && val <= SCHAR_MAX);
}

static GLboolean __glsTokenToGLdouble(
    const GLubyte *inToken, GLdouble *outVal
) {
    GLubyte *ptr;
    GLdouble sign;
    __GLS_C_LOCALE_DECLARE;

    __GLS_PUT_ERRNO(0);
    __GLS_C_LOCALE_BEGIN;
    *outVal = strtod((const char *)inToken, (char **)&ptr);
    __GLS_C_LOCALE_END;
    if (!*ptr) return (GLboolean)(__GLS_ERRNO != ERANGE);
    if (
        inToken[0] == '0' && __glsTokenToGLulong(inToken, (GLulong *)outVal)
    ) {
        return GL_TRUE;
    }
    if (!strcmp((const char *)inToken, "nan")) {
        *outVal = *(const GLdouble *)__glsQuietNaN;
        return GL_TRUE;
    }
    sign = 1.;
    if (*inToken == '-') {
        sign = -1.;
        ++inToken;
    } else if (*inToken == '+') {
        ++inToken;
    }
    if (!strcmp((const char *)inToken, "inf")) {
        *outVal = sign * HUGE_VAL;
        return GL_TRUE;
    }
    {
        GLint intVal;
        if (
            __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
            __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
        ) {
            *outVal = (GLdouble)intVal;
            return GL_TRUE;
        }
    }
    return GL_FALSE;
}

static GLboolean __glsTokenToGLfloat(
    const GLubyte *inToken, GLfloat *outVal
) {
    GLdouble doubleVal;
    GLubyte *ptr;
    GLdouble sign;
    __GLS_C_LOCALE_DECLARE;

    __GLS_PUT_ERRNO(0);
    __GLS_C_LOCALE_BEGIN;
    doubleVal = strtod((const char *)inToken, (char **)&ptr);
    *outVal = (GLfloat)doubleVal;
    __GLS_C_LOCALE_END;
    if (doubleVal < 0.) doubleVal = -doubleVal;
    if (!*ptr) return (GLboolean)(
        __GLS_ERRNO != ERANGE &&
        (
            !doubleVal ||
            doubleVal >= (GLdouble)FLT_MIN && doubleVal <= (GLdouble)FLT_MAX
        )
    );
    if (
        inToken[0] == '0' && __glsTokenToGLuint(inToken, (GLuint *)outVal)
    ) {
        return GL_TRUE;
    }
    if (!strcmp((const char *)inToken, "nan")) {
        *outVal = *(const GLfloat *)__glsQuietNaN;
        return GL_TRUE;
    }
    sign = 1.;
    if (*inToken == '-') {
        sign = -1.;
        ++inToken;
    } else if (*inToken == '+') {
        ++inToken;
    }
    if (!strcmp((const char *)inToken, "inf")) {
        *outVal = (GLfloat)(sign * HUGE_VAL);
        return GL_TRUE;
    }
    {
        GLint intVal;
        if (
            __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
            __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
        ) {
            *outVal = (GLfloat)intVal;
            return GL_TRUE;
        }
    }
    return GL_FALSE;
}

static GLboolean __glsTokenToGLint(const GLubyte *inToken, GLint *outVal) {
    GLubyte *ptr;
    long val;
    
    __GLS_PUT_ERRNO(0);
    val = strtol((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) {
        __GLS_PUT_ERRNO(0);
        val = __glsQuotedChar(inToken, &ptr);
    }
    if (!*ptr) {
        *outVal = (GLint)val;
        return (GLboolean)(
            __GLS_ERRNO != ERANGE && val >= INT_MIN && val <= INT_MAX
        );
    }
    return (GLboolean)(
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, outVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, outVal)
    );
}

#if defined(__GLS_STR_TO_INT64)

static GLboolean __glsTokenToGLlong(const GLubyte *inToken, GLlong *outVal) {
    GLint intVal;
    GLubyte *ptr;
    
    __GLS_PUT_ERRNO(0);
    *outVal = __GLS_STR_TO_INT64((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) {
        __GLS_PUT_ERRNO(0);
        *outVal = __glsQuotedChar(inToken, &ptr);
    }
    if (!*ptr) return (GLboolean)(__GLS_ERRNO != ERANGE);
    if (
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
    ) {
        *outVal = intVal;
        return GL_TRUE;
    }
    return GL_FALSE;
}

#else /* !defined(__GLS_STR_TO_INT64) */

static GLboolean __glsTokenToGLlong(const GLubyte *inToken, GLlong *outVal) {
    GLubyte *ptr;
    GLint intVal;
    long val;
    
    if (
        inToken[0] == '0' &&
        (inToken[1] == 'x' || inToken[1] == 'X') &&
        strlen((const char *)inToken) == 18
    ) {
        GLint high;
        GLuint low;
        __GLSstringBuf strBuf;

        strcpy((char *)strBuf, (const char *)inToken);
        strBuf[10] = 0;
        high = (GLint)strtol((const char *)strBuf, (char **)&ptr, 0);
        if (*ptr) return GL_FALSE;
        strcpy((char *)(strBuf + 2), (const char *)(inToken + 10));
        low = (GLuint)strtoul((const char *)strBuf, (char **)&ptr, 0);
        *outVal = glsLong(high, low);
        return !*ptr;
    }
    __GLS_PUT_ERRNO(0);
    val = strtol((const char *)inToken, (char **)&ptr, 0);
    if (!*ptr) {
        *outVal = glsLong((val & 0x80000000) ? -1 : 0, (GLuint)val);
        return __GLS_ERRNO != ERANGE && val >= INT_MIN && val <= INT_MAX;
    }
    if (
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
    ) {
        *outVal = glsLong(0, intVal);
        return GL_TRUE;
    }
    *outVal = glsLong(0, __glsQuotedChar(inToken, &ptr));
    return !*ptr;
}

#endif /* defined(__GLS_STR_TO_INT64) */

static GLboolean __glsTokenToGLshort(const GLubyte *inToken, GLshort *outVal) {
    GLubyte *ptr;
    long val;
    
    val = strtol((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) val = __glsQuotedChar(inToken, &ptr);
    *outVal = (GLshort)val;
    return (GLboolean)(!*ptr && val >= SHRT_MIN && val <= SHRT_MAX);
}

static GLboolean __glsTokenToGLubyte(const GLubyte *inToken, GLubyte *outVal) {
    GLubyte *ptr;
    unsigned long val;
    
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) val = __glsQuotedChar(inToken, &ptr);
    *outVal = (GLubyte)val;
    return (GLboolean)(!*ptr && val <= UCHAR_MAX);
}

static GLboolean __glsTokenToGLuint(const GLubyte *inToken, GLuint *outVal) {
    GLubyte *ptr;
    unsigned long val;
    
    __GLS_PUT_ERRNO(0);
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) {
        __GLS_PUT_ERRNO(0);
        val = __glsQuotedChar(inToken, &ptr);
    }
    if (!*ptr) {
        *outVal = (GLuint)val;
        return (GLboolean)(__GLS_ERRNO != ERANGE && val <= UINT_MAX);
    }
    return (GLboolean)(
        __glsStr2IntDict_find(
            __glsParser->glEnumDict, inToken, (GLint *)outVal
        ) ||
        __glsStr2IntDict_find(
            __glsParser->glsEnumDict, inToken, (GLint *)outVal
        )
    );
}

#if defined(__GLS_STR_TO_INT64U)

static GLboolean __glsTokenToGLulong(
    const GLubyte *inToken, GLulong *outVal
) {
    GLint intVal;
    GLubyte *ptr;
    
    __GLS_PUT_ERRNO(0);
    *outVal = __GLS_STR_TO_INT64U((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) {
        __GLS_PUT_ERRNO(0);
        *outVal = __glsQuotedChar(inToken, &ptr);
    }
    if (!*ptr) return (GLboolean)(__GLS_ERRNO != ERANGE);
    if (
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
    ) {
        *outVal = intVal;
        return GL_TRUE;
    }
    return GL_FALSE;
}

#else /* !defined(__GLS_STR_TO_INT64U) */

static GLboolean __glsTokenToGLulong(const GLubyte *inToken, GLulong *outVal) {
    GLubyte *ptr;
    GLint intVal;
    unsigned long val;
    
    if (
        inToken[0] == '0' &&
        (inToken[1] == 'x' || inToken[1] == 'X') &&
        strlen((const char *)inToken) == 18
    ) {
        GLuint high, low;
        __GLSstringBuf strBuf;

        strcpy((char *)strBuf, (const char *)inToken);
        strBuf[10] = 0;
        high = (GLuint)strtoul((const char *)strBuf, (char **)&ptr, 0);
        if (*ptr) return GL_FALSE;
        strcpy((char *)(strBuf + 2), (const char *)(inToken + 10));
        low = (GLuint)strtoul((const char *)strBuf, (char **)&ptr, 0);
        *outVal = glsULong(high, low);
        return !*ptr;
    }
    __GLS_PUT_ERRNO(0);
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    if (!*ptr) {
        *outVal = glsULong(0, (GLuint)val);
        return __GLS_ERRNO != ERANGE && val <= UINT_MAX;
    }
    if (
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
    ) {
        *outVal = glsULong(0, intVal);
        return GL_TRUE;
    }
    *outVal = glsULong(0, __glsQuotedChar(inToken, &ptr));
    return !*ptr;
}

#endif /* defined(__GLS_STR_TO_INT64U) */

static GLboolean __glsTokenToGLushort(
    const GLubyte *inToken, GLushort *outVal
) {
    GLubyte *ptr;
    unsigned long val;
    
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) val = __glsQuotedChar(inToken, &ptr);
    *outVal = (GLushort)val;
    return (GLboolean)(!*ptr && val <= USHRT_MAX);
}

/******************************************************************************
Private readers
******************************************************************************/

__GLS_FORWARD static GLboolean __glsReader_getChar_text(
    __GLSreader *inoutReader, GLubyte inChar, GLboolean inRequired
);

__GLS_FORWARD static GLboolean __glsReader_getToken_text(
    __GLSreader *inoutReader, __GLSstring *outToken
);

static GLboolean __glsReader_getBitfield_text(
    __GLSreader *inoutReader, const __GLSdict *inDict, GLbitfield *outBits
) {
    __GLSstring token;
    GLbitfield val = 0;

    __glsString_init(&token);
    __GLS_BEGIN_PARAM(inoutReader);
    *outBits = GLS_NONE;
    while (__glsReader_getToken_text(inoutReader, &token)) {
        if (
            __glsStr2IntDict_find(inDict, token.head, (GLint *)&val) ||
            __glsTokenToGLuint(token.head, &val)
        ) {
            *outBits |= val;
        } else {
            __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
            __glsString_final(&token);
            return GL_FALSE;
        }
        if (!__glsReader_getChar_text(inoutReader, '|', GL_FALSE)) {
            __glsString_final(&token);
            return GL_TRUE;
        }
    }
    __glsString_final(&token);
    return GL_FALSE;
}

static GLboolean __glsReader_getChar_text(
    __GLSreader *inoutReader, GLubyte inChar, GLboolean inRequired
) {
    GLubyte readChar;

    __GLS_GET_SPACE(inoutReader);
    __GLS_READ_CHAR(inoutReader, readChar);
    if (readChar != inChar) {
        __GLS_UNREAD_CHAR(inoutReader);
        if (inRequired) __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
    }
    return (GLboolean)(readChar == inChar);
}

static GLboolean __glsReader_getEnum_text(
    __GLSreader *inoutReader, const __GLSdict *inDict, GLuint *outVal
) {
    __GLSstring token;

    __glsString_init(&token);
    __GLS_BEGIN_PARAM(inoutReader);
    if (
        __glsReader_getToken_text(inoutReader, &token) &&
        (
            __glsStr2IntDict_find(inDict, token.head, (GLint *)outVal) ||
            __glsTokenToGLuint(token.head, outVal)
        )
    ) {
        __glsString_final(&token);
        return GL_TRUE;
    } else {
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
        __glsString_final(&token);
        return GL_FALSE;
    }
}

static GLboolean __glsReader_getIntOrEnum_text(
    __GLSreader *inoutReader, const __GLSdict *inDict, GLint *outVal
) {
    __GLSstring token;

    __glsString_init(&token);
    __GLS_BEGIN_PARAM(inoutReader);
    if (
        __glsReader_getToken_text(inoutReader, &token) &&
        (
            __glsTokenToGLint(token.head, outVal) ||
            __glsStr2IntDict_find(inDict, token.head, outVal)
        )
    ) {
        __glsString_final(&token);
        return GL_TRUE;
    } else {
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
        __glsString_final(&token);
        return GL_FALSE;
    }
}

static GLboolean __glsReader_getToken_text(
    __GLSreader *inoutReader, __GLSstring *outToken
) {
    GLint count = 0;
    GLubyte readChar;

    __GLS_GET_SPACE(inoutReader);
    __glsString_reset(outToken);
    for (;;) {
        __GLS_READ_CHAR(inoutReader, readChar);
        if (__GLS_CHAR_IS_TOKEN(readChar)) {
            __GLS_READER_APPEND_CHAR(inoutReader, outToken, readChar);
            ++count;
        } else if (!count && readChar == '\'') {
            __GLS_READER_APPEND_CHAR(inoutReader, outToken, readChar);
            __GLS_READ_CHAR(inoutReader, readChar);
            if (__GLS_CHAR_IS_GRAPHIC(readChar)) {
                __GLS_READER_APPEND_CHAR(inoutReader, outToken, readChar);
            } else {
                __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                break;
            }
            __GLS_READ_CHAR(inoutReader, readChar);
            if (readChar == '\'') {
                __GLS_READER_APPEND_CHAR(inoutReader, outToken, readChar);
                return GL_TRUE;
            } else {
                __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                break;
            }
        } else {
            __GLS_UNREAD_CHAR(inoutReader);
            if (count && count < __GLS_STRING_BUF_BYTES - 1) {
                return GL_TRUE;
            } else {
                __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                break;
            }
        }
    }
    return GL_FALSE;
}

/******************************************************************************
Public functions
******************************************************************************/

GLboolean __glsReader_abortCommand_text(__GLSreader *inoutReader) {
    GLubyte prevChar = 0;
    GLubyte readChar;
    GLboolean string = GL_FALSE;

    for (;;) {
        if (
            inoutReader->readPtr >= inoutReader->readTail &&
            !__glsReader_fillBuf(inoutReader, 1, GL_FALSE)
        ) {
            break;
        }
        readChar = *inoutReader->readPtr++;
        if (readChar == '"') {
            if (string) {
                if (prevChar != '\\') string = GL_FALSE;
            } else {
                string = GL_TRUE;
            }
        }
        if (readChar == ';' && !string) return GL_TRUE;
        prevChar = readChar;
    }
    return GL_FALSE;
}

GLboolean __glsReader_beginCommand_text(
    __GLSreader *inoutReader, __GLSstring *outCommand
) {
    inoutReader->error = GLS_NONE;
    inoutReader->paramCount = 0;
    return (GLboolean)(
        __glsReader_getToken_text(inoutReader, outCommand) &&
        __glsReader_getChar_text(inoutReader, '(', GL_TRUE)
    );
}

GLboolean __glsReader_call_text(__GLSreader *inoutReader) {
    __GLSstring command;
    GLSopcode opcode;

    if (!__glsParser) {
        __glsBeginCriticalSection();
        if (!__glsParser) __glsParser = __glsParser_create();
        __glsEndCriticalSection();
        if (!__glsParser) {
            __GLS_RAISE_ERROR(GLS_OUT_OF_MEMORY);
            return GL_FALSE;
        }
    }
    __glsString_init(&command);
    for (;;) {
        if (__GLS_CONTEXT->abortMode) {
            __glsString_final(&command);
            break;
        }
        if (__glsReader_beginCommand_text(inoutReader, &command)) {
            if (__glsParser_findCommand(__glsParser, command.head, &opcode)) {
                if (opcode == GLS_OP_glsEndGLS) {
                    if (__glsReader_endCommand_text(inoutReader)) {
                        __glsString_final(&command);
                        return GL_TRUE;
                    } else {
                        __GLS_CALL_ERROR(__GLS_CONTEXT, opcode, GLS_DECODE_ERROR);
                        __glsString_final(&command);
                        return __glsReader_abortCommand_text(inoutReader);
                    }
                }
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                __glsDispatchDecode_text[__glsMapOpcode(opcode)](inoutReader);
#else
                __glsDispatchDecode_text[__glsMapOpcode(opcode)](__GLS_CONTEXT,
                                                                 inoutReader);
#endif
                __glsReader_endCommand_text(inoutReader);
                if (inoutReader->error) {
                    __GLS_CALL_ERROR(__GLS_CONTEXT, opcode, inoutReader->error);
                    if (!__glsReader_abortCommand_text(inoutReader)) {
                        __glsString_final(&command);
                        break;
                    }
                }
            } else {
                if (!__glsReader_abortCommand_text(inoutReader)) {
                    __glsString_final(&command);
                    break;
                }
            }
        } else {
            __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
            if (!__glsReader_abortCommand_text(inoutReader)) {
                __glsString_final(&command);
                break;
            }
        }
    }
    return GL_FALSE;
}

GLboolean __glsReader_endCommand_text(__GLSreader *inoutReader) {
    return (GLboolean)(
        !inoutReader->error &&
        __glsReader_getChar_text(inoutReader, ')', GL_TRUE) &&
        __glsReader_getChar_text(inoutReader, ';', GL_TRUE)
    );
}

GLboolean __glsReader_getGLSenum_text(
    __GLSreader *inoutReader, GLSenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glsEnumDict, outVal
    );
}

GLboolean __glsReader_getGLSimageFlags_text(
    __GLSreader *inoutReader, GLbitfield *outVal
) {
    return __glsReader_getBitfield_text(
        inoutReader, __glsParser->glsImageFlagsDict, outVal
    );
}

GLboolean __glsReader_getGLSopcode_text(
    __GLSreader *inoutReader, GLSopcode *outVal
) {
    __GLSstring token;

    __glsString_init(&token);
    __GLS_BEGIN_PARAM(inoutReader);
    if (
        __glsReader_getToken_text(inoutReader, &token) &&
        (
            !strncmp((const char *)token.head, "GLS_OP_", 7) &&
            __glsStr2IntDict_find(
                __glsParser->glsOpDict,
                token.head + 7,
                (GLint *)outVal
            ) ||
            __glsTokenToGLuint(token.head, outVal)
        )
    ) {
        __glsString_final(&token);
        return GL_TRUE;
    } else {
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
        __glsString_final(&token);
        return GL_FALSE;
    }
}

GLboolean __glsReader_getGLattribMask_text(
    __GLSreader *inoutReader, GLbitfield *outVal
) {
    return __glsReader_getBitfield_text(
        inoutReader, __glsParser->glAttribMaskDict, outVal
    );
}

GLboolean __glsReader_getGLblendingFactor_text(
    __GLSreader *inoutReader, GLenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

__GLS_GET_TEXT(GLboolean, GLboolean)
__GLS_GET_TEXT(GLbyte, GLbyte)

GLboolean __glsReader_getGLcharv_text(
    __GLSreader *inoutReader, __GLSstring *outString
) {
    GLint hexCount = -1;
    GLboolean outVal = GL_TRUE;
    GLubyte prevChar = 0;
    GLubyte readChar;

    __GLS_BEGIN_PARAM(inoutReader);
    if (!__glsReader_getChar_text(inoutReader, '"', GL_TRUE)) return GL_FALSE;
    __glsString_reset(outString);
    for (;;) {
        __GLS_READ_CHAR(inoutReader, readChar);
        if (!readChar) {
            __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
            break;
        } else if (hexCount >= 0) {
            if (!isxdigit(readChar)) {
                __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                outVal = GL_FALSE;
                hexCount = -1;
            } else if (++hexCount == 2) {
                GLubyte buf[3];

                buf[0] = prevChar;
                buf[1] = readChar;
                buf[2] = 0;
                readChar = (GLubyte)strtoul((const char *)buf, GLS_NONE, 16);
                __GLS_READER_APPEND_CHAR(inoutReader, outString, readChar);
                hexCount = -1;
            }
        } else if (readChar == '\\') {
            if (prevChar == '\\') {
                __GLS_READER_APPEND_CHAR(inoutReader, outString, readChar);
                readChar = 0;
            }
        } else if (readChar == '"') {
            if (prevChar == '\\') {
                __GLS_READER_APPEND_CHAR(inoutReader, outString, readChar);
            } else if (__glsReader_getChar_text(inoutReader, '"', GL_FALSE)) {
                continue;
            } else {
                if (outVal && !glsIsUTF8String(outString->head)) {
                    __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                    outVal = GL_FALSE;
                }
                return outVal;
            }
        } else if (readChar == 'x' && prevChar == '\\') {
            hexCount = 0;
        } else if (!__GLS_CHAR_IS_GRAPHIC(readChar) || prevChar == '\\') {
            __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
            outVal = GL_FALSE;
        } else {
            __GLS_READER_APPEND_CHAR(inoutReader, outString, readChar);
        }
        prevChar = readChar;
    }
    return GL_FALSE;
}

GLboolean __glsReader_getGLclearBufferMask_text(
    __GLSreader *inoutReader, GLbitfield *outVal
) {
    return __glsReader_getBitfield_text(
        inoutReader, __glsParser->glAttribMaskDict, outVal
    );
}

GLboolean __glsReader_getGLcompv_text(
    __GLSreader *inoutReader, GLenum inType, GLuint inBytes, GLvoid *outVec
) {
    switch (inType) {
        case __GLS_BOOLEAN:
            return __glsReader_getGLbooleanv_text(
                inoutReader, inBytes, (GLboolean *)outVec
            );
        case GL_BITMAP:
            return __glsReader_getGLubytev_text(
                inoutReader, (inBytes + 7) / 8, (GLubyte *)outVec
            );
        case GL_BYTE:
            return __glsReader_getGLbytev_text(
                inoutReader, inBytes, (GLbyte *)outVec
            );
        case GL_FLOAT:
            return __glsReader_getGLfloatv_text(
                inoutReader, inBytes / 4, (GLfloat *)outVec
            );
        case GL_INT:
            return __glsReader_getGLintv_text(
                inoutReader, inBytes / 4, (GLint *)outVec
            );
        case GL_SHORT:
            return __glsReader_getGLshortv_text(
                inoutReader, inBytes / 2, (GLshort *)outVec
            );
        case GL_2_BYTES:
        case GL_3_BYTES:
        case GL_4_BYTES:
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return __glsReader_getGLubytev_text(
                inoutReader, inBytes, (GLubyte *)outVec
            );
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return __glsReader_getGLuintv_text(
                inoutReader, inBytes / 4, (GLuint *)outVec
            );
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return __glsReader_getGLushortv_text(
                inoutReader, inBytes / 2, (GLushort *)outVec
            );
        #if __GL_EXT_vertex_array
            case GL_DOUBLE_EXT:
                return __glsReader_getGLdoublev_text(
                    inoutReader, inBytes / 8, (GLdouble *)outVec
                );
        #endif /* __GL_EXT_vertex_array */
        default:
            return __glsReader_getGLbytev_text(inoutReader, 0, GLS_NONE);
    }
}

__GLS_GET_TEXT(GLdouble, GLdouble)

GLboolean __glsReader_getGLdrawBufferMode_text(
    __GLSreader *inoutReader, GLenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

GLboolean __glsReader_getGLenum_text(
    __GLSreader *inoutReader, GLenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

__GLS_GET_TEXT(GLfloat, GLfloat)
__GLS_GET_TEXT(GLint, GLint)
__GLS_GET_TEXT(GLlong, GLlong)
__GLS_GET_TEXT(GLshort, GLshort)

GLboolean __glsReader_getGLstencilOp_text(
    __GLSreader *inoutReader, GLenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

GLboolean __glsReader_getGLtextureComponentCount_text(
    __GLSreader *inoutReader, GLint *outVal
) {
    return __glsReader_getIntOrEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

__GLS_GET_TEXT(GLubyte, GLubyte)
__GLS_GET_TEXT(GLuint, GLuint)
__GLS_GET_TEXT(GLulong, GLulong)
__GLS_GET_TEXT(GLushort, GLushort)

GLboolean __glsReader_nextList_text(__GLSreader *inoutReader) {
    inoutReader->paramCount = 0;
    return (GLboolean)(
        !inoutReader->error &&
        __glsReader_getChar_text(inoutReader, ')', GL_TRUE) &&
        __glsReader_getChar_text(inoutReader, '(', GL_TRUE)
    );
}

GLSenum __glsReader_readBeginGLS_text(
    __GLSreader *inoutReader, __GLSversion *outVersion
) {
    __GLSstring beginGLS;
    __GLSversion version;

    __glsString_init(&beginGLS);
    if (
        __glsReader_beginCommand_text(inoutReader, &beginGLS) &&
        !strcmp((const char *)beginGLS.head, "glsBeginGLS") &&
        __glsReader_getGLint_text(inoutReader, &version.major) &&
        __glsReader_getGLint_text(inoutReader, &version.minor) &&
        __glsReader_endCommand_text(inoutReader) &&
        (!version.major || version.major == __GLS_VERSION_MAJOR)
    ) {
        __glsString_final(&beginGLS);
        *outVersion = version;
        return GLS_TEXT;
    } else {
        __glsString_final(&beginGLS);
        return GLS_NONE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\size.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

// DrewB - Changed size functions to take contexts

// DrewB
GLint __glsTypeSize(GLenum type)
{
    switch(type)
    {
    case __GLS_BOOLEAN:
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
        return 1;
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
        return 2;
    case GL_INT:
    case GL_UNSIGNED_INT:
    case GL_FLOAT:
        return 4;
    case GL_DOUBLE_EXT:
        return 8;
        
    default:
        return 0;
    }
}

GLint __glsEvalComputeK(GLenum inTarget) {
    switch(inTarget) {
        case GL_MAP1_INDEX:
        case GL_MAP1_TEXTURE_COORD_1:
        case GL_MAP2_INDEX:
        case GL_MAP2_TEXTURE_COORD_1:
            return 1;
        case GL_MAP1_TEXTURE_COORD_2:
        case GL_MAP2_TEXTURE_COORD_2:
            return 2;
        case GL_MAP1_NORMAL:
        case GL_MAP1_TEXTURE_COORD_3:
        case GL_MAP1_VERTEX_3:
        case GL_MAP2_NORMAL:
        case GL_MAP2_TEXTURE_COORD_3:
        case GL_MAP2_VERTEX_3:
            return 3;
        case GL_MAP1_COLOR_4:
        case GL_MAP1_TEXTURE_COORD_4:
        case GL_MAP1_VERTEX_4:
        case GL_MAP2_COLOR_4:
        case GL_MAP2_TEXTURE_COORD_4:
        case GL_MAP2_VERTEX_4:
            return 4;
    }
    return 0;
}
  
static GLint __glsGetMapSize(__GLScontext *ctx, GLenum inTarget, GLenum inQuery) {
    GLint order[2];

    order[0] = order[1] = 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetMapiv);
    glGetMapiv(inTarget, GL_ORDER, order);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetMapiv);
    if (order[0] < 0 || order[1] < 0) return 0;
    switch (inTarget) {
        case GL_MAP1_COLOR_4:
        case GL_MAP1_INDEX:
        case GL_MAP1_NORMAL:
        case GL_MAP1_TEXTURE_COORD_1:
        case GL_MAP1_TEXTURE_COORD_2:
        case GL_MAP1_TEXTURE_COORD_3:
        case GL_MAP1_TEXTURE_COORD_4:
        case GL_MAP1_VERTEX_3:
        case GL_MAP1_VERTEX_4:
            switch (inQuery) {
                case GL_COEFF:
                    return __glsEvalComputeK(inTarget) * order[0];
                case GL_DOMAIN:
                    return 2;
                case GL_ORDER:
                    return 1;
            }
            break;
        case GL_MAP2_COLOR_4:
        case GL_MAP2_INDEX:
        case GL_MAP2_NORMAL:
        case GL_MAP2_TEXTURE_COORD_1:
        case GL_MAP2_TEXTURE_COORD_2:
        case GL_MAP2_TEXTURE_COORD_3:
        case GL_MAP2_TEXTURE_COORD_4:
        case GL_MAP2_VERTEX_3:
        case GL_MAP2_VERTEX_4:
            switch (inQuery) {
                case GL_COEFF:
                    return (
                        __glsEvalComputeK(inTarget) * order[0] * order[1]
                    );
                case GL_DOMAIN:
                    return 4;
                case GL_ORDER:
                    return 2;
            }
            break;
    }
    return 0;
}

static GLint __glsGetPixelMapSize(__GLScontext *ctx, GLenum inMap) {
    GLint size = 0;
    GLenum query;
    
    switch (inMap) {
        case GL_PIXEL_MAP_I_TO_I:
            query = GL_PIXEL_MAP_I_TO_I_SIZE;
            break;
        case GL_PIXEL_MAP_S_TO_S:
            query = GL_PIXEL_MAP_S_TO_S_SIZE;
            break;
        case GL_PIXEL_MAP_I_TO_R:
            query = GL_PIXEL_MAP_I_TO_R_SIZE;
            break;
        case GL_PIXEL_MAP_I_TO_G:
            query = GL_PIXEL_MAP_I_TO_G_SIZE;
            break;
        case GL_PIXEL_MAP_I_TO_B:
            query = GL_PIXEL_MAP_I_TO_B_SIZE;
            break;
        case GL_PIXEL_MAP_I_TO_A:
            query = GL_PIXEL_MAP_I_TO_A_SIZE;
            break;
        case GL_PIXEL_MAP_R_TO_R:
            query = GL_PIXEL_MAP_R_TO_R_SIZE;
            break;
        case GL_PIXEL_MAP_G_TO_G:
            query = GL_PIXEL_MAP_G_TO_G_SIZE;
            break;
        case GL_PIXEL_MAP_B_TO_B:
            query = GL_PIXEL_MAP_B_TO_B_SIZE;
            break;
        case GL_PIXEL_MAP_A_TO_A:
            query = GL_PIXEL_MAP_A_TO_A_SIZE;
            break;
        default:
            return 0;
    }
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetIntegerv);
    glGetIntegerv(query, &size);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetIntegerv);
    return size;
}

static GLint __glsGetSize(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

static GLint __glsImageSize(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    GLint elemCount;
    
    if (inWidth < 0 || inHeight < 0) return 0;
    switch (inFormat) {
        case GL_ALPHA:
        case GL_BLUE:
        case GL_COLOR_INDEX:
        case GL_DEPTH_COMPONENT:
        case GL_GREEN:
        case GL_LUMINANCE:
        case GL_RED:
        case GL_STENCIL_INDEX:
            elemCount = 1;
            break;
        case GL_LUMINANCE_ALPHA:
            elemCount = 2;
            break;
        case GL_RGB:
#if __GL_EXT_bgra
        case GL_BGR_EXT:
#endif
            elemCount = 3;
            break;
        case GL_RGBA:
#if __GL_EXT_bgra
        case GL_BGRA_EXT:
#endif
            elemCount = 4;
            break;
        #if __GL_EXT_abgr
            case GL_ABGR_EXT:
                elemCount = 4;
                break;
        #endif /* __GL_EXT_abgr */
        #if __GL_EXT_cmyka
            case GL_CMYK_EXT:
                elemCount = 4;
                break;
            case GL_CMYKA_EXT:
                elemCount = 5;
                break;
        #endif /* __GL_EXT_cmyka */
        default:
            return 0;
    }
    #if __GL_EXT_packed_pixels
        switch (inType) {
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
                if (elemCount != 3) return 0;
                break;
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
                if (elemCount != 4) return 0;
                break;
        }
    #endif /* __GL_EXT_packed_pixels */
    switch (inType) {
        case GL_BITMAP:
            if (inFormat != GL_COLOR_INDEX && inFormat != GL_STENCIL_INDEX) {
                return 0;
            }
            return inHeight * ((inWidth + 7) / 8);
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return elemCount * inWidth * inHeight;
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return elemCount * 2 * inWidth * inHeight;
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return elemCount * 4 * inWidth * inHeight;
    }
    return 0;
}

static GLint __glsTextureSize(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    switch (inFormat) {
        case GL_DEPTH_COMPONENT:
        case GL_STENCIL_INDEX:
            return 0;
    }
    if (inType == GL_BITMAP) return 0;
    return __glsImageSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glBitmap_bitmap_size(GLint inWidth, GLint inHeight) {
    return __glsImageSize(GL_COLOR_INDEX, GL_BITMAP, inWidth, inHeight);
}

GLint __gls_glCallLists_lists_size(GLint inCount, GLenum inType) {
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
            return inCount;
        case GL_2_BYTES:
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
            return 2 * inCount;
        case GL_3_BYTES:
            return 3 * inCount;
        case GL_4_BYTES:
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
            return 4 * inCount;
    }
    return 0;
}

GLint __gls_glDrawPixels_pixels_size(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    return __glsImageSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glFogfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_FOG_DENSITY:
        case GL_FOG_END:
        case GL_FOG_INDEX:
        case GL_FOG_MODE:
        case GL_FOG_START:
            return 1;
        case GL_FOG_COLOR:
            return 4;
    }
    return 0;
}

GLint __gls_glFogiv_params_size(GLenum inPname) {
    return __gls_glFogfv_params_size(inPname);
}

GLint __gls_glGetBooleanv_params_size(GLenum inPname) {
    return __glsGetSize(inPname);
}

GLint __gls_glGetDoublev_params_size(GLenum inPname) {
    return __glsGetSize(inPname);
}

GLint __gls_glGetFloatv_params_size(GLenum inPname) {
    return __glsGetSize(inPname);
}

GLint __gls_glGetIntegerv_params_size(GLenum inPname) {
    return __glsGetSize(inPname);
}

GLint __gls_glGetLightfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetLightiv_params_size(GLenum inPname) {
    return __gls_glGetLightfv_params_size(inPname);
}

GLint __gls_glGetMapdv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery) {
    return __glsGetMapSize(ctx, inTarget, inQuery);
}

GLint __gls_glGetMapfv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery) {
    return __glsGetMapSize(ctx, inTarget, inQuery);
}

GLint __gls_glGetMapiv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery) {
    return __glsGetMapSize(ctx, inTarget, inQuery);
}

GLint __gls_glGetMaterialfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetMaterialiv_params_size(GLenum inPname) {
    return __gls_glGetMaterialfv_params_size(inPname);
}

GLint __gls_glGetPixelMapfv_values_size(__GLScontext *ctx, GLenum inMap) {
    return __glsGetPixelMapSize(ctx, inMap);
}

GLint __gls_glGetPixelMapuiv_values_size(__GLScontext *ctx, GLenum inMap) {
    return __glsGetPixelMapSize(ctx, inMap);
}

GLint __gls_glGetPixelMapusv_values_size(__GLScontext *ctx, GLenum inMap) {
    return __glsGetPixelMapSize(ctx, inMap);
}

GLint __gls_glGetPolygonStipple_mask_size(void) {
    return 128;
}

GLint __gls_glGetTexEnvfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexEnviv_params_size(GLenum inPname) {
    return __gls_glGetTexEnvfv_params_size(inPname);
}

GLint __gls_glGetTexGendv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexGenfv_params_size(GLenum inPname) {
    return __gls_glGetTexGendv_params_size(inPname);
}

GLint __gls_glGetTexGeniv_params_size(GLenum inPname) {
    return __gls_glGetTexGendv_params_size(inPname);
}

GLint __gls_glGetTexImage_pixels_size(
    __GLScontext *ctx,
    GLenum inTarget, GLint inLevel, GLenum inFormat, GLenum inType
) {
    GLint width, height, depth, size4d;

    switch (inTarget) {
        case GL_TEXTURE_1D:
        case GL_TEXTURE_2D:
        #if __GL_EXT_texture3D
            case GL_TEXTURE_3D_EXT:
        #endif /* __GL_EXT_texture3D */
        #if __GL_SGIS_detail_texture
            case GL_DETAIL_TEXTURE_2D_SGIS:
        #endif /* __GL_SGIS_detail_texture */
        #if __GL_SGIS_texture4D
            case GL_TEXTURE_4D_SGIS:
        #endif /* __GL_SGIS_texture4D */
            break;
        default:
            return 0;
    }
    if (inLevel < 0) return 0;
    width = height = 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetTexLevelParameteriv);
    glGetTexLevelParameteriv(inTarget, inLevel, GL_TEXTURE_WIDTH, &width);
    glGetTexLevelParameteriv(inTarget, inLevel, GL_TEXTURE_HEIGHT, &height);
    #if __GL_EXT_texture3D
        depth = 0;
        glGetTexLevelParameteriv(
            inTarget, inLevel, GL_TEXTURE_DEPTH_EXT, &depth
        );
    #else /* !__GL_EXT_texture3D */
        depth = 1;
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        size4d = 0;
        glGetTexLevelParameteriv(
            inTarget, inLevel, GL_TEXTURE_4DSIZE_SGIS, &size4d
        );
    #else /* !__GL_SGIS_texture4D */
        size4d = 1;
    #endif /* __GL_SGIS_texture4D */
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetTexLevelParameteriv);
    return __glsTextureSize(inFormat, inType, width, height) * depth * size4d;
}

GLint __gls_glGetTexLevelParameterfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexLevelParameteriv_params_size(GLenum inPname) {
    return __gls_glGetTexLevelParameterfv_params_size(inPname);
}

GLint __gls_glGetTexParameterfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexParameteriv_params_size(GLenum inPname) {
    return __gls_glGetTexParameterfv_params_size(inPname);
}

GLint __gls_glLightfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_CONSTANT_ATTENUATION:
        case GL_LINEAR_ATTENUATION:
        case GL_QUADRATIC_ATTENUATION:
        case GL_SPOT_CUTOFF:
        case GL_SPOT_EXPONENT:
            return 1;
        case GL_SPOT_DIRECTION:
            return 3;
        case GL_AMBIENT:
        case GL_DIFFUSE:
        case GL_POSITION:
        case GL_SPECULAR:
            return 4;
    }
    return 0;
}

GLint __gls_glLightiv_params_size(GLenum inPname) {
    return __gls_glLightfv_params_size(inPname);
}

GLint __gls_glLightModelfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_LIGHT_MODEL_LOCAL_VIEWER:
        case GL_LIGHT_MODEL_TWO_SIDE:
            return 1;
        case GL_LIGHT_MODEL_AMBIENT:
            return 4;
    }
    return 0;
}

GLint __gls_glLightModeliv_params_size(GLenum inPname) {
    return __gls_glLightModelfv_params_size(inPname);
}

GLint __gls_glMap1d_points_size(
    GLenum inTarget, GLint inStride, GLint inOrder
) {
    const GLint k = __glsEvalComputeK(inTarget);

    if (inStride < k || inOrder < 0) return 0;
    return k * inOrder;
}

GLint __gls_glMap1f_points_size(
    GLenum inTarget, GLint inStride, GLint inOrder
) {
    const GLint k = __glsEvalComputeK(inTarget);

    if (inStride < k || inOrder < 0) return 0;
    return k * inOrder;
}

GLint __gls_glMap2d_points_size(
    GLenum inTarget, GLint inUstride, GLint inUorder, GLint inVstride,
    GLint inVorder
) {
    const GLint k = __glsEvalComputeK(inTarget);

    if (inUstride < k || inUorder < 0 || inVstride < k || inVorder < 0) {
        return 0;
    }
    return k * inUorder * inVorder;
}

GLint __gls_glMap2f_points_size(
    GLenum inTarget, GLint inUstride, GLint inUorder, GLint inVstride,
    GLint inVorder
) {
    const GLint k = __glsEvalComputeK(inTarget);

    if (inUstride < k || inUorder < 0 || inVstride < k || inVorder < 0) {
        return 0;
    }
    return k * inUorder * inVorder;
}

GLint __gls_glMaterialfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_SHININESS:
            return 1;
        case GL_COLOR_INDEXES:
            return 3;
        case GL_AMBIENT:
        case GL_AMBIENT_AND_DIFFUSE:
        case GL_DIFFUSE:
        case GL_EMISSION:
        case GL_SPECULAR:
            return 4;
    }
    return 0;
}

GLint __gls_glMaterialiv_params_size(GLenum inPname) {
    return __gls_glMaterialfv_params_size(inPname);
}

GLint __gls_glPolygonStipple_mask_size(void) {
    return 128;
}

GLint __gls_glReadPixels_pixels_size(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    return __glsImageSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glTexEnvfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_TEXTURE_ENV_MODE:
            return 1;
        case GL_TEXTURE_ENV_COLOR:
            return 4;
    }
    return 0;
}

GLint __gls_glTexEnviv_params_size(GLenum inPname) {
    return __gls_glTexEnvfv_params_size(inPname);
}

GLint __gls_glTexGendv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_TEXTURE_GEN_MODE:
            return 1;
        case GL_EYE_PLANE:
        case GL_OBJECT_PLANE:
            return 4;
    }
    return 0;
}

GLint __gls_glTexGenfv_params_size(GLenum inPname) {
    return __gls_glTexGendv_params_size(inPname);
}

GLint __gls_glTexGeniv_params_size(GLenum inPname) {
    return __gls_glTexGendv_params_size(inPname);
}

GLint __gls_glTexImage1D_pixels_size(
    GLenum inFormat, GLenum inType, GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glTexImage2D_pixels_size(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glColorSubTableEXT_entries_size(
    GLenum inFormat, GLenum inType, GLint inCount
) {
    return __glsTextureSize(inFormat, inType, inCount, 1);
}

GLint __gls_glTexParameterfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_TEXTURE_MAG_FILTER:
        case GL_TEXTURE_MIN_FILTER:
        case GL_TEXTURE_WRAP_S:
        case GL_TEXTURE_WRAP_T:
            return 1;
        case GL_TEXTURE_BORDER_COLOR:
            return 4;
        #if __GL_SGIS_component_select
            case GL_TEXTURE_SS_SELECT_SGIS:
            case GL_TEXTURE_SSSS_SELECT_SGIS:
                return 1;
        #endif /* __GL_SGIS_component_select */
        #if __GL_SGIS_detail_texture
            case GL_DETAIL_TEXTURE_LEVEL_SGIS:
            case GL_DETAIL_TEXTURE_MODE_SGIS:
                return 1;
        #endif /* __GL_SGIS_detail_texture */
        #if __GL_EXT_texture_object
            case GL_TEXTURE_PRIORITY_EXT:
                return 1;
        #endif /* __GL_EXT_texture_object */
        #if __GL_EXT_texture3D
            case GL_TEXTURE_WRAP_R_EXT:
                return 1;
        #endif /* __GL_EXT_texture3D */
        #if __GL_SGIS_texture_lod
            case GL_TEXTURE_MIN_LOD_SGIS:
            case GL_TEXTURE_MAX_LOD_SGIS:
            case GL_TEXTURE_BASE_LEVEL_SGIS:
            case GL_TEXTURE_MAX_LEVEL_SGIS:
                return 1;
        #endif /* __GL_SGIS_texture_lod */
        #if __GL_SGIS_texture4D
            case GL_TEXTURE_WRAP_Q_SGIS:
                return 1;
        #endif /* __GL_SGIS_texture4D */
    }
    return 0;
}

GLint __gls_glTexParameteriv_params_size(GLenum inPname) {
    return __gls_glTexParameterfv_params_size(inPname);
}

GLint __gls_glsHeaderfv_inVec_size(GLenum inAttrib) {
    switch (inAttrib) {
        case GLS_ORIGIN:
        case GLS_PAGE_SIZE:
        case GLS_RED_POINT:
        case GLS_GREEN_POINT:
        case GLS_BLUE_POINT:
        case GLS_WHITE_POINT:
            return 2;
        case GLS_BORDER_COLOR:
        case GLS_GAMMA:
        case GLS_PAGE_COLOR:
            return 4;
    }
    return 0;
}

GLint __gls_glsHeaderiv_inVec_size(GLenum inAttrib) {
    switch (inAttrib) {
        case GLS_CREATE_TIME:
        case GLS_MODIFY_TIME:
            return 6;
    }
    return 0;
}

#if __GL_EXT_convolution

GLint __gls_glConvolutionFilter1DEXT_image_size(
    GLenum inFormat, GLenum inType, GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glConvolutionFilter2DEXT_image_size(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glConvolutionParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_CONVOLUTION_BORDER_MODE_EXT:
            return 1;
        case GL_CONVOLUTION_FILTER_SCALE_EXT:
        case GL_CONVOLUTION_FILTER_BIAS_EXT:
            return 4;
    }
    return 0;
}

GLint __gls_glConvolutionParameterivEXT_params_size(GLenum inPname) {
    return __gls_glConvolutionParameterfvEXT_params_size(inPname);
}

GLint __gls_glGetConvolutionFilterEXT_image_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint width, height;

    switch (inTarget) {
        case GL_CONVOLUTION_1D_EXT:
        case GL_CONVOLUTION_2D_EXT:
            break;
        default:
            return 0;
    }
    width = height = 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    glGetConvolutionParameterivEXT(
        inTarget, GL_CONVOLUTION_WIDTH_EXT, &width
    );
    glGetConvolutionParameterivEXT(
        inTarget, GL_CONVOLUTION_HEIGHT_EXT, &height
    );
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    return __glsTextureSize(inFormat, inType, width, height);
}

GLint __gls_glGetConvolutionParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetConvolutionParameterivEXT_params_size(GLenum inPname) {
    return __gls_glGetConvolutionParameterfvEXT_params_size(inPname);
}

GLint __gls_glGetSeparableFilterEXT_row_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint width = 0;

    if (inTarget != GL_SEPARABLE_2D_EXT) return 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    glGetConvolutionParameterivEXT(inTarget, GL_CONVOLUTION_WIDTH_EXT, &width);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    return __glsTextureSize(inFormat, inType, width, 1);
}

GLint __gls_glGetSeparableFilterEXT_column_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint height = 0;

    if (inTarget != GL_SEPARABLE_2D_EXT) return 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    glGetConvolutionParameterivEXT(
        inTarget, GL_CONVOLUTION_HEIGHT_EXT, &height
    );
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    return __glsTextureSize(inFormat, inType, 1, height);
}

GLint __gls_glGetSeparableFilterEXT_span_size(
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    return 0;
}

GLint __gls_glSeparableFilter2DEXT_row_size(
    GLenum inTarget, GLenum inFormat, GLenum inType, GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glSeparableFilter2DEXT_column_size(
    GLenum inTarget, GLenum inFormat, GLenum inType, GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, 1, inHeight);
}

#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram

GLint __gls_glGetHistogramEXT_values_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint width = 0;

    if (inTarget != GL_HISTOGRAM_EXT) return 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetHistogramParameterivEXT);
    glGetHistogramParameterivEXT(inTarget, GL_HISTOGRAM_WIDTH_EXT, &width);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetHistogramParameterivEXT);
    return __glsTextureSize(inFormat, inType, width, 1);
}

GLint __gls_glGetHistogramParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetHistogramParameterivEXT_params_size(GLenum inPname) {
    return __gls_glGetHistogramParameterfvEXT_params_size(inPname);
}

GLint __gls_glGetMinmaxEXT_values_size(
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    return __glsTextureSize(inFormat, inType, 2, 1);
}

GLint __gls_glGetMinmaxParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetMinmaxParameterivEXT_params_size(GLenum inPname) {
    return __gls_glGetMinmaxParameterfvEXT_params_size(inPname);
}

#endif /* __GL_EXT_histogram */

GLint __gls_glTexSubImage1D_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glTexSubImage2D_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, inWidth, inHeight);
}

#if __GL_EXT_subtexture

GLint __gls_glTexSubImage1DEXT_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glTexSubImage2DEXT_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glTexSubImage3DEXT_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    GLint inDepth
) {
    if (inDepth < 0) return 0;
    return __glsTextureSize(inFormat, inType, inWidth, inHeight) * inDepth;
}

#endif /* __GL_EXT_subtexture */

#if __GL_EXT_texture3D
GLint __gls_glTexImage3DEXT_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    GLint inDepth
) {
    if (inDepth < 0) return 0;
    return __glsTextureSize(inFormat, inType, inWidth, inHeight) * inDepth;
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_vertex_array

GLint __gls_glColorPointerEXT_pointer_size(
    GLint inSize, GLenum inType, GLint inStride, GLint inCount
) {
    if (inSize < 3 || inSize > 4) return 0;
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
            return inSize * inCount;
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
            return 2 * inSize * inCount;
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
            return 4 * inSize * inCount;
        case GL_DOUBLE_EXT:
            return 8 * inSize * inCount;
    }
    return 0;
}

GLint __gls_glEdgeFlagPointerEXT_pointer_size(
    GLint inStride, GLint inCount
) {
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    return inCount;
}

GLint __gls_glIndexPointerEXT_pointer_size(
    GLenum inType, GLint inStride, GLint inCount
) {
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_SHORT:
            return 2 * inCount;
        case GL_FLOAT:
        case GL_INT:
            return 4 * inCount;
        case GL_DOUBLE_EXT:
            return 8 * inCount;
    }
    return 0;
}

GLint __gls_glNormalPointerEXT_pointer_size(
    GLenum inType, GLint inStride, GLint inCount
) {
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_BYTE:
            return 3 * inCount;
        case GL_SHORT:
            return 2 * 3 * inCount;
        case GL_FLOAT:
        case GL_INT:
            return 4 * 3 * inCount;
        case GL_DOUBLE_EXT:
            return 8 * 3 * inCount;
    }
    return 0;
}

GLint __gls_glTexCoordPointerEXT_pointer_size(
    GLint inSize, GLenum inType, GLint inStride, GLint inCount
) {
    if (inSize < 1 || inSize > 4) return 0;
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_SHORT:
            return 2 * inSize * inCount;
        case GL_FLOAT:
        case GL_INT:
            return 4 * inSize * inCount;
        case GL_DOUBLE_EXT:
            return 8 * inSize * inCount;
    }
    return 0;
}

GLint __gls_glVertexPointerEXT_pointer_size(
    GLint inSize, GLenum inType, GLint inStride, GLint inCount
) {
    if (inSize < 2 || inSize > 4) return 0;
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_SHORT:
            return 2 * inSize * inCount;
        case GL_FLOAT:
        case GL_INT:
            return 4 * inSize * inCount;
        case GL_DOUBLE_EXT:
            return 8 * inSize * inCount;
    }
    return 0;
}

#endif /* __GL_EXT_vertex_array */

#if __GL_SGI_color_table

GLint __gls_glColorTableParameterfvSGI_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_COLOR_TABLE_BIAS_SGI:
        case GL_COLOR_TABLE_SCALE_SGI:
            return 4;
    }
    return 0;
}

GLint __gls_glColorTableParameterivSGI_params_size(GLenum inPname) {
    return __gls_glColorTableParameterfvSGI_params_size(inPname);
}

#endif // __GL_SGI_color_table

#if __GL_EXT_paletted_texture

GLint __gls_glColorTableEXT_table_size(
    GLenum inFormat, GLenum inType, GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params);
GLint __gls_glGetColorTableEXT_table_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint width = 0;

    switch (inTarget) {
#if __GL_SGI_color_table
        case GL_COLOR_TABLE_SGI:
        case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
        case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
#endif
        #if __GL_SGI_texture_color_table
            case GL_TEXTURE_COLOR_TABLE_SGI:
        #endif /* __GL_SGI_texture_color_table */
#if __GL_EXT_paletted_texture
    case GL_TEXTURE_1D:
    case GL_TEXTURE_2D:
    case GL_PROXY_TEXTURE_1D:
    case GL_PROXY_TEXTURE_2D:
#endif
            break;
        default:
            return 0;
    }
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetColorTableParameterivEXT);
    glGetColorTableParameterivEXT(inTarget, GL_COLOR_TABLE_WIDTH_EXT, &width);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetColorTableParameterivEXT);
    return __glsTextureSize(inFormat, inType, width, 1);
}

GLint __gls_glGetColorTableParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetColorTableParameterivEXT_params_size(GLenum inPname) {
    return __gls_glGetColorTableParameterfvEXT_params_size(inPname);
}

#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table

GLint __gls_glTexColorTableParameterfvSGI_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_TEXTURE_COLOR_TABLE_BIAS_SGI:
        case GL_TEXTURE_COLOR_TABLE_SCALE_SGI:
            return 4;
    }
    return 0;
}

GLint __gls_glTexColorTableParameterivSGI_params_size(GLenum inPname) {
    return __gls_glTexColorTableParameterfvSGI_params_size(inPname);
}

GLint __gls_glGetTexColorTableParameterfvSGI_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexColorTableParameterivSGI_params_size(GLenum inPname) {
    return __gls_glGetColorTableParameterfvSGI_params_size(inPname);
}

#endif /* __GL_SGI_texture_color_table */

#if __GL_SGIS_detail_texture
GLint __gls_glGetDetailTexFuncSGIS_points_size(__GLScontext *ctx, GLenum inTarget) {
    GLint points = 0;

    switch (inTarget) {
        case GL_TEXTURE_2D:
            break;
        default:
            return 0;
    }
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetTexParameteriv);
    glGetTexParameteriv(inTarget, GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS, &points);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetTexParameteriv);
    return points * 2;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
GLint __gls_glGetSharpenTexFuncSGIS_points_size(__GLScontext *ctx, GLenum inTarget) {
    GLint points = 0;

    switch (inTarget) {
        case GL_TEXTURE_1D:
        case GL_TEXTURE_2D:
        #if __GL_EXT_texture3D
            case GL_TEXTURE_3D_EXT:
        #endif /* __GL_EXT_texture3D */
            break;
        default:
            return 0;
    }
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetTexParameteriv);
    glGetTexParameteriv(
        inTarget, GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS, &points
    );
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetTexParameteriv);
    return points * 2;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_texture4D

GLint __gls_glTexImage4DSGIS_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    GLint inDepth,
    GLint inSize4d
) {
    if (inDepth < 0 || inSize4d < 0) return 0;
    return (
        __glsTextureSize(inFormat, inType, inWidth, inHeight) *
        inDepth *
        inSize4d
    );
}

GLint __gls_glTexSubImage4DSGIS_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    GLint inDepth,
    GLint inSize4d
) {
    if (inDepth < 0 || inSize4d < 0) return 0;
    return (
        __glsTextureSize(inFormat, inType, inWidth, inHeight) *
         inDepth *
         inSize4d
    );
}

#endif /* __GL_SGIS_texture4D */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\write.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>

/******************************************************************************
__GLSwriteStream
******************************************************************************/

__GLSwriteStream* __glsWriteStream_create(
    const GLubyte *inName, GLboolean inAppend
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriteStream *const outStream = __glsCalloc(
        1, sizeof(__GLSwriteStream)
    );

    if (!outStream) return GLS_NONE;
    __glsString_init(&outStream->name);
    if (inName[0]) {
        const GLubyte *openName;

        if (
            !__glsListString_prefix(
                ctx->writePrefix, inName, &outStream->name
            ) ||
            !(openName = __glsUCS1String(outStream->name.head))
        ) {
            return __glsWriteStream_destroy(outStream);
        }
        if (outStream->channel = fopen((const char *)openName, "rb")) {
            fclose(outStream->channel);
        } else {
            outStream->created = GL_TRUE;
        }
        outStream->channel = fopen(
            (const char *)openName, inAppend ? "ab" : "wb"
        );
        if (openName != outStream->name.head) free((GLvoid *)openName);
        if (outStream->channel) {
            setbuf(outStream->channel, GLS_NONE);
            outStream->opened = GL_TRUE;
            return outStream;
        }
        __GLS_RAISE_ERROR(GLS_STREAM_OPEN_ERROR);
        return __glsWriteStream_destroy(outStream);
    } else {
        outStream->writeFunc = ctx->writeFunc;
        if (!outStream->writeFunc) {
            outStream->channel = ctx->defaultWriteChannel;
        }
        return outStream;
    }
}

__GLSwriteStream* __glsWriteStream_destroy(__GLSwriteStream *inStream) {
    if (!inStream) return GLS_NONE;

    if (inStream->opened && fclose(inStream->channel)) {
        __GLS_RAISE_ERROR(GLS_STREAM_CLOSE_ERROR);
    }
    __glsString_final(&inStream->name);
    free(inStream);
    return GLS_NONE;
}

size_t __glsWriteStream_getByteCount(const __GLSwriteStream *inStream) {
    fpos_t pos;

    if (!inStream->channel) return 0;
    if (
        !fgetpos(inStream->channel, &pos) &&
        !fseek(inStream->channel, 0, SEEK_END)
    ) {
        const long outVal = ftell(inStream->channel);

        fsetpos(inStream->channel, &pos);
        return outVal >= 0 ? (size_t)outVal : 0;
    } else {
        return 0;
    }
}

/******************************************************************************
__GLSwriter
******************************************************************************/

static const GLvoid* __glsPixelBase(
    GLenum inType,
    GLint inGroupElems,
    GLint inStrideElems,
    const __GLSpixelStoreConfig *inConfig,
    const GLvoid *inPixels
) {
    GLint skipRows = inConfig->skipRows;

    #if __GL_EXT_texture3D
        skipRows += inConfig->skipImages * inConfig->imageHeight;
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        skipRows += (
            inConfig->skipVolumes *
            inConfig->imageDepth *
            inConfig->imageHeight
        );
    #endif /* __GL_SGIS_texture4D */
    switch (inType) {
        case GL_BITMAP:
            return (
                (const GLubyte *)inPixels +
                skipRows * inStrideElems / 8 +
                inConfig->skipPixels * inGroupElems / 8
            );
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return (
                (const GLbyte *)inPixels +
                skipRows * inStrideElems +
                inConfig->skipPixels * inGroupElems
            );
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return (
                (const GLshort *)inPixels +
                skipRows * inStrideElems +
                inConfig->skipPixels * inGroupElems
            );
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return (
                (const GLint *)inPixels +
                skipRows * inStrideElems +
                inConfig->skipPixels * inGroupElems
            );
        default:
            return inPixels;
    }
}

static GLint __glsPixelStrideElems(
    GLenum inType,
    GLint inGroupElems,
    GLint inWidth,
    const __GLSpixelStoreConfig *inConfig
) {
    const GLint align = inConfig->alignment;
    GLint elemLog, padBytes, strideBytes;
    const GLint strideElems = (
        inGroupElems * (inConfig->rowLength ? inConfig->rowLength : inWidth)
    );

    switch (inType) {
        case GL_BITMAP:
            strideBytes = (strideElems + 7) >> 3;
            if (padBytes = strideBytes & align - 1) {
                strideBytes += align - padBytes;
            }
            return strideBytes << 3;
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            elemLog = 0;
            break;
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            elemLog = 1;
            break;
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            elemLog = 2;
            break;
        default:
            return 0;
    }
    strideBytes = strideElems << elemLog;
    if (padBytes = strideBytes & align - 1) {
        return (strideBytes + align - padBytes) >> elemLog;
    } else {
        return strideElems;
    }
}

static __GLSwriter* __glsWriter_create_context(
    const GLubyte *inStreamName, GLbitfield inWriteFlags
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStreamBlock *block;
    __GLSwriter *outWriter = GLS_NONE;
    __GLScontextStream *stream = GLS_NONE;

    if (stream = __glsStr2PtrDict_find(ctx->contextStreamDict, inStreamName)) {
        GLint i;

        for (i = 0 ; i < ctx->captureNesting ; ++i) {
            if (ctx->writers[i]->contextStream == stream) {
                __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
                return GLS_NONE;
            }
        }
        if (stream->callCount) {
            __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
            return GLS_NONE;
        }
        outWriter = __glsCalloc(1, sizeof(__GLSwriter));
        if (!outWriter) return GLS_NONE;

        if (!(inWriteFlags & GLS_WRITE_APPEND_BIT)) {
            __glsContextStream_truncate(
                stream, __glsContextStream_firstBlock(stream), 0
            );
        }
    } else {
        if (
            !(outWriter = __glsCalloc(1, sizeof(__GLSwriter))) ||
            !(stream = __glsContextStream_create(inStreamName)) ||
            !__glsStr2PtrDict_add(ctx->contextStreamDict, inStreamName, stream)
        ) {
            __glsContextStream_destroy(stream);
            return __glsWriter_destroy(outWriter);
        }
        __GLS_ITERLIST_APPEND(&ctx->contextStreamList, stream);
        outWriter->contextCreated = GL_TRUE;
    }
    block = __glsContextStream_lastBlock(stream);
    __glsContextStreamBlock_removeJump(block);
    outWriter->bufPtr = block->writeTail;
    outWriter->bufTail = block->bufTail - __GLS_JUMP_ALLOC;
    outWriter->startBlock = block;
    outWriter->startOffset = (size_t)((ULONG_PTR)(block->writeTail - block->buf));
    outWriter->contextStream = stream;
    __glsWriter_initDispatch_bin(outWriter, GLS_CONTEXT);
    outWriter->type = GLS_CONTEXT;
    return outWriter;
}

static __GLSwriter* __glsWriter_create_extern(
    const GLubyte *inStreamName, GLSenum inStreamType, GLbitfield inWriteFlags
) {
    __GLSwriter *outWriter;

    outWriter = __glsCalloc(1, sizeof(__GLSwriter));
    if (!outWriter) return GLS_NONE;
    outWriter->externStream = __glsWriteStream_create(
        inStreamName,
        (GLboolean)(inWriteFlags & GLS_WRITE_APPEND_BIT ? GL_TRUE : GL_FALSE)
    );
    if (!outWriter->externStream) return __glsWriter_destroy(outWriter);
    outWriter->startOffset = __glsWriteStream_getByteCount(
        outWriter->externStream
    );
    outWriter->externBuf = outWriter->externBufHead = __glsMalloc(
        __GLS_WRITER_EXTERN_BUF_BYTES
    );
    if (!outWriter->externBuf) return __glsWriter_destroy(outWriter);
    outWriter->bufPtr = outWriter->externBufHead;
    /*
    ** bufTail is moved back from actual buffer tail to streamline ALLOC
    ** check for GLS_TEXT parameter writing.
    */
    outWriter->bufTail = (
        outWriter->externBufHead +
        __GLS_WRITER_EXTERN_BUF_BYTES -
        __GLS_WRITER_EXTERN_BUF_SLOP
    );
    if (inStreamType == GLS_TEXT) {
        __glsWriter_initDispatch_text(outWriter);
    } else {
        __glsWriter_initDispatch_bin(outWriter, inStreamType);
    }
    outWriter->type = inStreamType;
    return outWriter;
}

__GLSwriter* __glsWriter_create(
    const GLubyte *inStreamName, GLSenum inStreamType, GLbitfield inWriteFlags
) {
    __GLSwriter *outWriter;

    if (inStreamType == GLS_CONTEXT) {
        outWriter = __glsWriter_create_context(inStreamName, inWriteFlags);
    } else {
        outWriter = __glsWriter_create_extern(
            inStreamName, inStreamType, inWriteFlags
        );
    }
    if (outWriter) {
        outWriter->beginCommand(outWriter, GLS_OP_glsBeginGLS, 8);
        outWriter->putGLint(outWriter, __GLS_VERSION_MAJOR);
        outWriter->putGLint(outWriter, __GLS_VERSION_MINOR);
        outWriter->endCommand(outWriter);
        __glsWriter_flush(outWriter);
    }
    return outWriter;
}

__GLSwriter* __glsWriter_destroy(__GLSwriter *inWriter) {
    if (!inWriter) return GLS_NONE;
    if (inWriter->type != GLS_NONE) {
        if (inWriter->beginCommand(inWriter, GLS_OP_glsEndGLS, 0)) {
            inWriter->endCommand(inWriter);
        }
        __glsWriter_flush(inWriter);
        if (inWriter->type == GLS_CONTEXT) {
            __GLScontextStreamBlock *endBlock;
            if (inWriter->error && inWriter->contextCreated) {
                __glsStrDict_remove(
                    __GLS_CONTEXT->contextStreamDict,
                    inWriter->contextStream->name.head
                );
                __GLS_ITERLIST_REMOVE_DESTROY(
                    &__GLS_CONTEXT->contextStreamList,
                    inWriter->contextStream,
                    __glsContextStream_destroy
                );
            } else if (inWriter->error) {
                endBlock = inWriter->startBlock;
                endBlock->writeTail = endBlock->buf + inWriter->startOffset;
                __glsContextStream_truncate(
                    inWriter->contextStream,
                    endBlock,
                    (size_t)((ULONG_PTR)(endBlock->writeTail - endBlock->buf))
                );
            } else {
                endBlock = __glsContextStream_lastBlock(
                    inWriter->contextStream
                );
                endBlock->writeTail = inWriter->bufPtr;
                __glsContextStream_truncate(
                    inWriter->contextStream,
                    endBlock,
                    (size_t)((ULONG_PTR)(endBlock->writeTail - endBlock->buf))
                );
            }
        } else {
            if (inWriter->error && inWriter->externStream->opened) {
                if (inWriter->externStream->created) {
                    if (
                        remove((const char *)inWriter->externStream->name.head)
                    ) {
                        __GLS_RAISE_ERROR(GLS_STREAM_DELETE_ERROR);
                    }
                } else if (inWriter->externStream->channel) {
                    __GLS_TRUNCATE_EXTERN(
                        inWriter->externStream->channel, inWriter->startOffset
                    );
                }
            }
        }
    }
    free(inWriter->externBuf);
    __glsWriteStream_destroy(inWriter->externStream);
    free(inWriter);
    return GLS_NONE;
}

GLboolean __glsWriter_flush(__GLSwriter *inoutWriter) {
    if (inoutWriter->error) return GL_FALSE;
    inoutWriter->prevCommand = GLS_NONE;
    if (inoutWriter->type == GLS_CONTEXT) {
        return GL_TRUE;
    } else {
        FILE *channel;

        const size_t n = (size_t)((ULONG_PTR)(inoutWriter->bufPtr - inoutWriter->externBufHead));
        if (!n) return GL_TRUE;
        if (channel = inoutWriter->externStream->channel) {
            if (
                fwrite(inoutWriter->externBufHead, 1, n, channel) == n &&
                !fflush(channel)
            ) {
                inoutWriter->externBufHead = (
                    (inoutWriter->wordCount & 1) ?
                    inoutWriter->externBuf + 4 :
                    inoutWriter->externBuf
                );
                inoutWriter->bufPtr = inoutWriter->externBufHead;
                return GL_TRUE;
            } else {
                __GLS_RAISE_ERROR(GLS_STREAM_WRITE_ERROR);
                clearerr(channel);
                inoutWriter->error = GL_TRUE;
                return GL_FALSE;
            }
        } else {
            if (
                inoutWriter->externStream->writeFunc(
                    n, inoutWriter->externBufHead
                )
                == n
            ) {
                inoutWriter->externBufHead = (
                    (inoutWriter->wordCount & 1) ?
                    inoutWriter->externBuf + 4 :
                    inoutWriter->externBuf
                );
                inoutWriter->bufPtr = inoutWriter->externBufHead;
                return GL_TRUE;
            } else {
                __GLS_RAISE_ERROR(GLS_STREAM_WRITE_ERROR);
                inoutWriter->error = GL_TRUE;
                return GL_FALSE;
            }
        }
    }
}

void __glsWriter_putListv(
    __GLSwriter *inoutWriter,
    GLenum inType,
    GLint inCount,
    const GLvoid *inVec
) {
    switch (inType) {
        case GL_2_BYTES:
            inoutWriter->putGLubytev(
                inoutWriter, 2 * inCount, (const GLubyte *)inVec
            );
            break;
        case GL_3_BYTES:
            inoutWriter->putGLubytev(
                inoutWriter, 3 * inCount, (const GLubyte *)inVec
            );
            break;
        case GL_4_BYTES:
            inoutWriter->putGLubytev(
                inoutWriter, 4 * inCount, (const GLubyte *)inVec
            );
            break;
        case GL_BYTE:
            inoutWriter->putGLbytev(
                inoutWriter, inCount, (const GLbyte *)inVec
            );
            break;
        case GL_FLOAT:
            inoutWriter->putGLfloatv(
                inoutWriter, inCount, (const GLfloat *)inVec
            );
            break;
        case GL_INT:
            inoutWriter->putGLintv(
                inoutWriter, inCount, (const GLint *)inVec
            );
            break;
        case GL_SHORT:
            inoutWriter->putGLshortv(
                inoutWriter, inCount, (const GLshort *)inVec
            );
            break;
        case GL_UNSIGNED_BYTE:
            inoutWriter->putGLubytev(
                inoutWriter, inCount, (const GLubyte *)inVec
            );
            break;
        case GL_UNSIGNED_INT:
            inoutWriter->putGLuintv(
                inoutWriter, inCount, (const GLuint *)inVec
            );
            break;
        case GL_UNSIGNED_SHORT:
            inoutWriter->putGLushortv(
                inoutWriter, inCount, (const GLushort *)inVec
            );
            break;
        default:
            inoutWriter->putGLbytev(inoutWriter, 0, GLS_NONE);
            break;
    }
}

void __glsWriter_putPixelv(
    __GLSwriter *inoutWriter,
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    const GLvoid *inVec
) {
    GLint groupElems;
    GLint rowElems;
    GLint strideElems;
    __GLSpixelStoreConfig pixelStore;

    if (!inVec) inType = GLS_NONE;
    __glsPixelStoreConfig_get_unpack(&pixelStore);
    switch (inFormat) {
        case GL_ALPHA:
        case GL_BLUE:
        case GL_COLOR_INDEX:
        case GL_DEPTH_COMPONENT:
        case GL_GREEN:
        case GL_LUMINANCE:
        case GL_RED:
        case GL_STENCIL_INDEX:
            groupElems = 1;
            break;
        case GL_LUMINANCE_ALPHA:
            groupElems = 2;
            break;
        case GL_RGB:
#if __GL_EXT_bgra
        case GL_BGR_EXT:
#endif
            groupElems = 3;
            break;
        case GL_RGBA:
#if __GL_EXT_bgra
        case GL_BGRA_EXT:
#endif
            groupElems = 4;
            break;
        #if __GL_EXT_abgr
            case GL_ABGR_EXT:
                groupElems = 4;
                break;
        #endif /* __GL_EXT_abgr */
        #if __GL_EXT_cmyka
            case GL_CMYK_EXT:
                groupElems = 4;
                break;
            case GL_CMYKA_EXT:
                groupElems = 5;
                break;
        #endif /* __GL_EXT_cmyka */
        default:
            groupElems = 0;
            inType = GLS_NONE;
    }
    #if __GL_EXT_packed_pixels
        switch (inType) {
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
                if (groupElems != 3) inType = GLS_NONE;
                break;
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
                if (groupElems != 4) inType = GLS_NONE;
                break;
        }
    #endif /* __GL_EXT_packed_pixels */
    rowElems = groupElems * inWidth;
    strideElems = __glsPixelStrideElems(
        inType, groupElems, inWidth, &pixelStore
    );
    switch (inType) {
        case GL_BITMAP:
            inoutWriter->putGLbitvs(
                inoutWriter,
                (GLboolean)pixelStore.lsbFirst,
                pixelStore.skipPixels * groupElems & 7,
                rowElems,
                strideElems - rowElems,
                inHeight,
                (const GLubyte *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_BYTE:
            inoutWriter->putGLbytevs(
                inoutWriter,
                GL_FALSE,
                rowElems,
                strideElems - rowElems,
                inHeight,
                0,
                1,
                (const GLbyte *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_FLOAT:
            inoutWriter->putGLfloatvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 4,
                inHeight,
                0,
                1,
                (const GLfloat *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_INT:
            inoutWriter->putGLintvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 4,
                inHeight,
                0,
                1,
                (const GLint *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_SHORT:
            inoutWriter->putGLshortvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 2,
                inHeight,
                0,
                1,
                (const GLshort *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            inoutWriter->putGLubytevs(
                inoutWriter,
                GL_FALSE,
                rowElems,
                strideElems - rowElems,
                inHeight,
                0,
                1,
                (const GLubyte *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            inoutWriter->putGLuintvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 4,
                inHeight,
                0,
                1,
                (const GLuint *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            inoutWriter->putGLushortvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 2,
                inHeight,
                0,
                1,
                (const GLushort *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        default:
            inoutWriter->putGLbytev(inoutWriter, 0, GLS_NONE);
            break;
    }
}

// DrewB - Always enabled for 1.1 support
void __glsWriter_putVertexv(
    __GLSwriter *inoutWriter,
    GLint inSize,
    GLenum inType,
    GLint inStride,
    GLint inCount,
    const GLvoid *inVec
) {
    if (!inVec) inType = GLS_NONE;
    switch (inType) {
        case __GLS_BOOLEAN:
            inoutWriter->putGLbooleanvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize : 0,
                inCount,
                0,
                1,
                (const GLboolean *)inVec
            );
            break;
        case GL_BYTE:
            inoutWriter->putGLbytevs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize : 0,
                inCount,
                0,
                1,
                (const GLbyte *)inVec
            );
            break;
        case GL_DOUBLE_EXT:
            inoutWriter->putGLdoublevs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 8 : 0,
                inCount,
                0,
                1,
                (const GLdouble *)inVec
            );
            break;
        case GL_FLOAT:
            inoutWriter->putGLfloatvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 4 : 0,
                inCount,
                0,
                1,
                (const GLfloat *)inVec
            );
            break;
        case GL_INT:
            inoutWriter->putGLintvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 4 : 0,
                inCount,
                0,
                1,
                (const GLint *)inVec
            );
            break;
        case GL_SHORT:
            inoutWriter->putGLshortvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 2 : 0,
                inCount,
                0,
                1,
                (const GLshort *)inVec
            );
            break;
        case GL_UNSIGNED_BYTE:
            inoutWriter->putGLubytevs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize : 0,
                inCount,
                0,
                1,
                (const GLubyte *)inVec
            );
            break;
        case GL_UNSIGNED_INT:
            inoutWriter->putGLuintvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 4 : 0,
                inCount,
                0,
                1,
                (const GLuint *)inVec
            );
            break;
        case GL_UNSIGNED_SHORT:
            inoutWriter->putGLushortvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 2 : 0,
                inCount,
                0,
                1,
                (const GLushort *)inVec
            );
            break;
        default:
            inoutWriter->putGLbytev(inoutWriter, 0, GLS_NONE);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\writebin.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <limits.h>
#include <stdlib.h>

/******************************************************************************
Helpers
******************************************************************************/

#define __GLS_PUT_BIN(inType, inSize) \
    __GLS_PUT_BIN_VAL(inType, inSize) \
    __GLS_PUT_BIN_VEC(inType, inSize) \
    __GLS_PUT_BIN_VECSTRIDE(inType, inSize)

#define __GLS_PUT_BIN_ENUM(inType, inEnum) \
    __GLS_PUT_BIN_ENUM_VAL(inType, inEnum) \
    __GLS_PUT_BIN_ENUM_VEC(inType, inEnum)

#define __GLS_PUT_BIN_SWAP(inType, inSize) \
    __GLS_PUT_BIN(inType, inSize) \
    __GLS_PUT_BIN_SWAP_VAL(inType, inSize) \
    __GLS_PUT_BIN_SWAP_VEC(inType, inSize) \
    __GLS_PUT_BIN_SWAP_VECSTRIDE(inType, inSize)

#define __GLS_PUT_BIN_ENUM_VAL(inType, inEnum) \
static void __glsWriter_put##inType##Or##inEnum##_bin( \
    __GLSwriter *inoutWriter, inEnum inParam, inType inVal \
) { \
    inoutWriter->put##inType(inoutWriter, inVal); \
}

#define __GLS_PUT_BIN_ENUM_VEC(inType, inEnum) \
static void __glsWriter_put##inType##Or##inEnum##v_bin( \
    __GLSwriter *inoutWriter, \
    inEnum inParam, \
    GLuint inCount, \
    const inType *inVec \
) { \
    inoutWriter->put##inType##v(inoutWriter, inCount, inVec); \
}

#define __GLS_PUT_BIN_SWAP_VAL(inType, inSize) \
static void __glsWriter_put##inType##_bin_swap( \
    __GLSwriter *inoutWriter, inType inVal \
) { \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += inSize; \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    *(inType *)bufPtr = inVal; \
    __glsSwap##inSize(bufPtr); \
}

#define __GLS_PUT_BIN_SWAP_VEC(inType, inSize) \
static void __glsWriter_put##inType##v_bin_swap( \
    __GLSwriter *inoutWriter, GLuint inCount, const inType *inVec \
) { \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += inSize * inCount; \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    while (inCount-- > 0) { \
        *(inType *)bufPtr = *inVec++; \
        __glsSwap##inSize(bufPtr); \
        bufPtr += inSize; \
    } \
}

#define __GLS_PUT_BIN_SWAP_VECSTRIDE(inType, inSize) \
static void __glsWriter_put##inType##vs_bin_swap( \
    __GLSwriter *inoutWriter, \
    GLboolean inItemSwap, \
    GLint inStride1DataItems, \
    GLint inStride1PadBytes, \
    GLint inStride1Count, \
    GLint inStride2PadBytes, \
    GLint inStride2Count, \
    const inType *inVec \
) { \
    GLint i, j; \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += ( \
        inSize * inStride1DataItems * inStride1Count * inStride2Count \
    ); \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    if (inItemSwap) while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, bufPtr += inSize) { \
                *(inType *)bufPtr = *inVec++; \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } else  while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, bufPtr += inSize) { \
                *(inType *)bufPtr = *inVec++; \
                __glsSwap##inSize(bufPtr); \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } \
}

#define __GLS_PUT_BIN_VAL(inType, inSize) \
static void __glsWriter_put##inType##_bin( \
    __GLSwriter *inoutWriter, inType inVal \
) { \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += inSize; \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    *(inType *)bufPtr = inVal; \
}

#define __GLS_PUT_BIN_VEC(inType, inSize) \
static void __glsWriter_put##inType##v_bin( \
    __GLSwriter *inoutWriter, GLuint inCount, const inType *inVec \
) { \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += inSize * inCount; \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    while (inCount-- > 0) { \
        *(inType *)bufPtr = *inVec++; \
        bufPtr += inSize; \
    } \
}

#define __GLS_PUT_BIN_VECSTRIDE(inType, inSize) \
static void __glsWriter_put##inType##vs_bin( \
    __GLSwriter *inoutWriter, \
    GLboolean inItemSwap, \
    GLint inStride1DataItems, \
    GLint inStride1PadBytes, \
    GLint inStride1Count, \
    GLint inStride2PadBytes, \
    GLint inStride2Count, \
    const inType *inVec \
) { \
    GLint i, j; \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += ( \
        inSize * inStride1DataItems * inStride1Count * inStride2Count \
    ); \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    if (inItemSwap) while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, bufPtr += inSize) { \
                *(inType *)bufPtr = *inVec++; \
                __glsSwap##inSize(bufPtr); \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } else  while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, bufPtr += inSize) { \
                *(inType *)bufPtr = *inVec++; \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } \
}

/******************************************************************************
Writers
******************************************************************************/

static GLboolean __glsWriter_alloc_bin(
    __GLSwriter *inoutWriter, size_t inWordCount
) {
    if (!__glsWriter_flush(inoutWriter)) return GL_FALSE;
    if (inoutWriter->bufPtr + inWordCount * 4 <= inoutWriter->bufTail) {
        return GL_TRUE;
    }
    free(inoutWriter->externBuf);
    if (inoutWriter->wordCount & 1) ++inWordCount;
    if (
        inoutWriter->externBuf = inoutWriter->externBufHead = __glsMalloc(
            inWordCount * 4
        )
    ) {
        if (inoutWriter->wordCount & 1) inoutWriter->externBufHead += 4;
        inoutWriter->bufPtr = inoutWriter->externBufHead;
        inoutWriter->bufTail = inoutWriter->externBuf + inWordCount * 4;
        return GL_TRUE;
    } else {
        inoutWriter->bufPtr = GLS_NONE;
        inoutWriter->bufTail = GLS_NONE;
        inoutWriter->error = GL_TRUE;
        return GL_FALSE;
    }
}

static GLboolean __glsWriter_alloc_context(
    __GLSwriter *inoutWriter, size_t inWordCount
) {
    __GLScontextStream *const stream = inoutWriter->contextStream;
    __GLScontextStreamBlock *const block = __glsContextStream_lastBlock(
        stream
    );
    const size_t fillBytes = (size_t)((ULONG_PTR)(inoutWriter->bufPtr - block->buf));
    const GLfloat fillFrac = (
        (GLfloat)(fillBytes + __GLS_JUMP_ALLOC) /
        (GLfloat)(block->bufTail - block->buf)
    );
    const size_t reqBytes = (inWordCount + 1) * 4 + __GLS_JUMP_ALLOC;

    __glsWriter_flush(inoutWriter);
    block->writeTail = inoutWriter->bufPtr;
    if (fillFrac < __GLS_FULL_CONTEXT_STREAM_BLOCK) {
        GLubyte *const buf = __glsMalloc(fillBytes + reqBytes);

        if (buf) {
            size_t i = fillBytes;
            __GLS_LIST_ITER(__GLScontextStreamBlock) iter;

            while (i-- > 0) buf[i] = block->buf[i];
            free(block->buf);
            block->buf = buf;
            block->bufTail = buf + fillBytes + reqBytes;
            block->writeTail = buf + fillBytes;
            inoutWriter->bufPtr = block->writeTail;
            inoutWriter->bufTail = block->bufTail - __GLS_JUMP_ALLOC;
            iter.elem = block;
            __GLS_LIST_PREV(&stream->blockList, &iter);
            if (iter.elem) {
                __glsContextStreamBlock_removeJump(iter.elem);
                __glsContextStreamBlock_addJump(iter.elem, buf);
            }
            return GL_TRUE;
        } else {
            inoutWriter->error = GL_TRUE;
            return GL_FALSE;
        }
    } else {
        __GLScontextStreamBlock *const newBlock = (
            __glsContextStream_appendBlock(
                stream, __GLS_MAX(__GLS_CONTEXT_STREAM_BLOCK_BYTES, reqBytes)
            )
        );

        if (newBlock) {
            if (inoutWriter->wordCount & 1) {
                __glsContextStreamBlock_addPad(newBlock);
            }
            inoutWriter->bufPtr = newBlock->writeTail;
            __glsContextStreamBlock_addJump(block, inoutWriter->bufPtr);
            inoutWriter->bufTail = newBlock->bufTail - __GLS_JUMP_ALLOC;
            return GL_TRUE;
        } else {
            inoutWriter->error = GL_TRUE;
            return GL_FALSE;
        }
    }
}

static GLboolean __glsWriter_beginCommand_bin(
    __GLSwriter *inoutWriter, GLSopcode inOpcode, size_t inByteCount
) {
    size_t wordCount = (inByteCount + 3) >> 2;
    GLboolean longForm;
    GLSopcode opcode;

    if (inoutWriter->error) return GL_FALSE;
    if (inoutWriter->type == GLS_CONTEXT) {
        opcode = __glsMapOpcode(inOpcode);
    } else {
        opcode = inOpcode;
    }
    longForm = (GLboolean)(
        opcode == GLS_OP_glsBeginGLS ||
        opcode == GLS_OP_glsEndGLS ||
        opcode >= 65536 ||
        wordCount >= 65535
    );
    wordCount += longForm ? 3 : 1;
    if (wordCount > UINT_MAX) {
        glsError(inOpcode, GLS_ENCODE_ERROR);
        return GL_FALSE;
    }
    if (
        inoutWriter->bufPtr + wordCount * 4 > inoutWriter->bufTail &&
        !inoutWriter->alloc(inoutWriter, wordCount)
    ) {
        return GL_FALSE;
    }
    inoutWriter->commandOpcode = inOpcode;
    inoutWriter->commandHead = inoutWriter->bufPtr;
    inoutWriter->commandTail = inoutWriter->bufPtr + wordCount * 4;
    inoutWriter->prevCommand = (
        (__GLSbinCommandHead_large *)inoutWriter->bufPtr
    );
    if (longForm) {
        inoutWriter->putGLushort(inoutWriter, GLS_NONE);
        inoutWriter->putGLushort(inoutWriter, 0);
        inoutWriter->putGLuint(inoutWriter, opcode);
        inoutWriter->putGLuint(inoutWriter, (GLuint)wordCount);
    } else {
        inoutWriter->putGLushort(inoutWriter, (GLushort)opcode);
        inoutWriter->putGLushort(inoutWriter, (GLushort)wordCount);
    }
    inoutWriter->wordCount += wordCount;
    return GL_TRUE;
}

static void __glsWriter_endCommand_bin(__GLSwriter *inoutWriter) {
    ptrdiff_t mod4 = ((ptrdiff_t)(inoutWriter->bufPtr - (GLubyte *)0)) & 3;

    if (mod4) while (mod4++ <  4) *inoutWriter->bufPtr++ = 0;
    if (inoutWriter->bufPtr != inoutWriter->commandTail) {
        inoutWriter->bufPtr = inoutWriter->commandHead;
        fprintf(
            stderr,
            "GLS encoder error on command %s\n",
            __glsOpcodeString[__glsMapOpcode(inoutWriter->commandOpcode)]
        );
        exit(EXIT_FAILURE);
    }
}

static void __glsWriter_nextList_bin(__GLSwriter *inoutWriter) {
}

static GLboolean __glsWriter_padWordCount_bin(
    __GLSwriter *inoutWriter, GLboolean inCountMod2
) {
    if (inoutWriter->error) return GL_FALSE;
    if ((inoutWriter->wordCount & 1) == inCountMod2) return GL_TRUE;
    if (inoutWriter->bufPtr + 4 > inoutWriter->bufTail) {
        if (!inoutWriter->alloc(inoutWriter, 1)) return GL_FALSE;
    }
    if (
        inoutWriter->prevCommand &&
        inoutWriter->prevCommand->opSmall &&
        inoutWriter->prevCommand->countSmall != USHRT_MAX
    ) {
        ++inoutWriter->prevCommand->countSmall;
        inoutWriter->commandTail += 4;
        inoutWriter->putGLuint(inoutWriter, 0);
        ++inoutWriter->wordCount;
        return GL_TRUE;
    } else  if (
        inoutWriter->prevCommand &&
        inoutWriter->prevCommand->opLarge != GLS_OP_glsBeginGLS &&
        inoutWriter->prevCommand->countLarge != ULONG_MAX
    ) {
        ++inoutWriter->prevCommand->countLarge;
        inoutWriter->commandTail += 4;
        inoutWriter->putGLuint(inoutWriter, 0);
        ++inoutWriter->wordCount;
        return GL_TRUE;
    } else {
        if (inoutWriter->beginCommand(inoutWriter, GLS_OP_glsPad, 0)) {
            inoutWriter->endCommand(inoutWriter);
            return GL_TRUE;
        } else {
            return GL_FALSE;
        }
    }
}

static GLboolean __glsWriter_padWordCount_bin_swap(
    __GLSwriter *inoutWriter, GLboolean inCountMod2
) {
    if (inoutWriter->error) return GL_FALSE;
    if ((inoutWriter->wordCount & 1) == inCountMod2) return GL_TRUE;
    if (inoutWriter->bufPtr + 4 > inoutWriter->bufTail) {
        if (!inoutWriter->alloc(inoutWriter, 1)) return GL_FALSE;
    }
    if (
        inoutWriter->prevCommand &&
        inoutWriter->prevCommand->opSmall &&
        inoutWriter->prevCommand->countSmall != USHRT_MAX
    ) {
        __glsSwap2(&inoutWriter->prevCommand->countSmall);
        ++inoutWriter->prevCommand->countSmall;
        __glsSwap2(&inoutWriter->prevCommand->countSmall);
        inoutWriter->commandTail += 4;
        inoutWriter->putGLuint(inoutWriter, 0);
        ++inoutWriter->wordCount;
        return GL_TRUE;
    } else  if (
        inoutWriter->prevCommand &&
        (
            __glsSwapi((GLint)inoutWriter->prevCommand->opLarge) !=
            GLS_OP_glsBeginGLS
        ) &&
        inoutWriter->prevCommand->countLarge != ULONG_MAX
    ) {
        __glsSwap4(&inoutWriter->prevCommand->countLarge);
        ++inoutWriter->prevCommand->countLarge;
        __glsSwap4(&inoutWriter->prevCommand->countLarge);
        inoutWriter->commandTail += 4;
        inoutWriter->putGLuint(inoutWriter, 0);
        ++inoutWriter->wordCount;
        return GL_TRUE;
    } else {
        if (inoutWriter->beginCommand(inoutWriter, GLS_OP_glsPad, 0)) {
            inoutWriter->endCommand(inoutWriter);
            return GL_TRUE;
        } else {
            return GL_FALSE;
        }
    }
}

static void __glsWriter_putGLbitvs_bin(
    __GLSwriter *inoutWriter,
    GLboolean inItemSwap,
    GLint inItemLeftShift,
    GLint inStrideDataItems,
    GLint inStridePadItems,
    GLint inStrideCount,
    const GLubyte *inVec
) {
    GLubyte *bufPtr = inoutWriter->bufPtr;
    GLint i;
    const GLint highShift = inItemLeftShift;
    const GLint lowShift = 8 - inItemLeftShift;
    GLubyte lastMask = 0xffu;
    
    if (inStrideDataItems & 7) lastMask <<= 8 - (inStrideDataItems & 7);
    inStrideDataItems = (inStrideDataItems + 7) >> 3;
    inStridePadItems >>= 3;
    inoutWriter->bufPtr += inStrideDataItems * inStrideCount;
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return;
    if (!inItemSwap && !inItemLeftShift) while (inStrideCount-- > 0) {
        i = inStrideDataItems;
        while (i-- > 1) *bufPtr++ = *inVec++;
        if (!i) *bufPtr++ = (GLubyte)(*inVec++ & lastMask);
        inVec += inStridePadItems;
    } else if (!inItemLeftShift) while (inStrideCount-- > 0) {
        i = inStrideDataItems;
        while (i-- > 1) *bufPtr++ = __glsBitReverse[*inVec++];
        if (!i) *bufPtr++ = (GLubyte)(__glsBitReverse[*inVec++] & lastMask);
        inVec += inStridePadItems;
    } else if (!inItemSwap) while (inStrideCount-- > 0) {
        i = inStrideDataItems;
        while (i-- > 1) {
            *bufPtr++ = (GLubyte)(*inVec++ << highShift | *inVec >> lowShift);
        }
        if (!i) *bufPtr++ = (GLubyte)((*inVec++ & lastMask) << highShift);
        inVec += inStridePadItems;
    } else while (inStrideCount-- > 0) {
        i = inStrideDataItems;
        while (i-- > 1) *bufPtr++ = (GLubyte)(
            __glsBitReverse[*inVec++] << highShift |
            __glsBitReverse[*inVec] >> lowShift
        );
        if (!i) {
            *bufPtr++ = (GLubyte)(
                (__glsBitReverse[*inVec++] & lastMask) << highShift
            );
        }
        inVec += inStridePadItems;
    }
}

__GLS_PUT_BIN(GLbyte, 1)
__GLS_PUT_BIN(GLubyte, 1)
__GLS_PUT_BIN_ENUM(GLint, GLenum)
__GLS_PUT_BIN_ENUM(GLfloat, GLenum)
__GLS_PUT_BIN_ENUM(GLdouble, GLenum)
__GLS_PUT_BIN_ENUM_VAL(GLint, GLSenum)
__GLS_PUT_BIN_SWAP(GLshort, 2)
__GLS_PUT_BIN_SWAP(GLushort, 2)
__GLS_PUT_BIN_SWAP(GLint, 4)
__GLS_PUT_BIN_SWAP(GLuint, 4)
__GLS_PUT_BIN_SWAP(GLfloat, 4)
__GLS_PUT_BIN_SWAP(GLdouble, 8)
__GLS_PUT_BIN_SWAP_VAL(GLlong, 8)
__GLS_PUT_BIN_SWAP_VAL(GLulong, 8)
__GLS_PUT_BIN_SWAP_VEC(GLlong, 8)
__GLS_PUT_BIN_SWAP_VEC(GLulong, 8)
__GLS_PUT_BIN_VAL(GLlong, 8)
__GLS_PUT_BIN_VAL(GLulong, 8)
__GLS_PUT_BIN_VEC(GLlong, 8)
__GLS_PUT_BIN_VEC(GLulong, 8)

static void __glsWriter_putGLdoublem_bin(
    __GLSwriter *inoutWriter, const GLdouble *inMat
) {
    __glsWriter_putGLdoublev_bin(inoutWriter, 16, inMat);
}

static void __glsWriter_putGLdoublem_bin_swap(
    __GLSwriter *inoutWriter, const GLdouble *inMat
) {
    __glsWriter_putGLdoublev_bin_swap(inoutWriter, 16, inMat);
}

static void __glsWriter_putGLfloatm_bin(
    __GLSwriter *inoutWriter, const GLfloat *inMat
) {
    __glsWriter_putGLfloatv_bin(inoutWriter, 16, inMat);
}

static void __glsWriter_putGLfloatm_bin_swap(
    __GLSwriter *inoutWriter, const GLfloat *inMat
) {
    __glsWriter_putGLfloatv_bin_swap(inoutWriter, 16, inMat);
}

static void __glsWriter_putGLoutArg_bin(
    __GLSwriter *inoutWriter, GLuint inIndex, const GLvoid *inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    __glsWriter_putGLulong_bin(
        inoutWriter,
        (
            ctx->callNesting &&
            !ctx->commandFuncs[__glsMapOpcode(inoutWriter->commandOpcode)]
        ) ?
        ctx->outArgs.vals[inIndex] :
        __glsPtrToULong(inVal)
    );
}

static void __glsWriter_putGLoutArg_bin_swap(
    __GLSwriter *inoutWriter, GLuint inIndex, const GLvoid *inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    __glsWriter_putGLulong_bin_swap(
        inoutWriter,
        (
            ctx->callNesting &&
            !ctx->commandFuncs[__glsMapOpcode(inoutWriter->commandOpcode)]
        ) ?
        ctx->outArgs.vals[inIndex] :
        __glsPtrToULong(inVal)
    );
}

/******************************************************************************
Dispatch setup
******************************************************************************/

#define __GLS_INIT_PUT_BIN(inDst, inSrc) \
    __GLS_INIT_PUT_BIN_VAL(inDst, inSrc); \
    __GLS_INIT_PUT_BIN_VEC(inDst, inSrc); \
    __GLS_INIT_PUT_BIN_VECSTRIDE(inDst, inSrc);

#define __GLS_INIT_PUT_BIN_SWAP(inDst, inSrc) \
    __GLS_INIT_PUT_BIN_SWAP_VAL(inDst, inSrc); \
    __GLS_INIT_PUT_BIN_SWAP_VEC(inDst, inSrc); \
    __GLS_INIT_PUT_BIN_SWAP_VECSTRIDE(inDst, inSrc);

#define __GLS_INIT_PUT_BIN_SWAP_MAT(inDst, inSrc) \
    inoutWriter->put##inDst##m = ( \
        swap ? \
        __glsWriter_put##inSrc##m_bin_swap : __glsWriter_put##inSrc##m_bin \
    );

#define __GLS_INIT_PUT_BIN_SWAP_VAL(inDst, inSrc) \
    inoutWriter->put##inDst = ( \
        swap ? \
        __glsWriter_put##inSrc##_bin_swap : __glsWriter_put##inSrc##_bin \
    );

#define __GLS_INIT_PUT_BIN_SWAP_VEC(inDst, inSrc) \
    inoutWriter->put##inDst##v = ( \
        swap ? \
        __glsWriter_put##inSrc##v_bin_swap : __glsWriter_put##inSrc##v_bin \
    );

#define __GLS_INIT_PUT_BIN_SWAP_VECSTRIDE(inDst, inSrc) \
    inoutWriter->put##inDst##vs = ( \
        swap ? \
        __glsWriter_put##inSrc##vs_bin_swap : __glsWriter_put##inSrc##vs_bin \
    );

#define __GLS_INIT_PUT_BIN_VAL(inDst, inSrc) \
    inoutWriter->put##inDst = __glsWriter_put##inSrc##_bin;

#define __GLS_INIT_PUT_BIN_VEC(inDst, inSrc) \
    inoutWriter->put##inDst##v = __glsWriter_put##inSrc##v_bin;

#define __GLS_INIT_PUT_BIN_VECSTRIDE(inDst, inSrc) \
    inoutWriter->put##inDst##vs = __glsWriter_put##inSrc##vs_bin;

void __glsWriter_initDispatch_bin(
    __GLSwriter *inoutWriter, GLSenum inStreamType
) {
    const GLboolean swap = (GLboolean)(inStreamType == __GLS_BINARY_SWAP1);

    if (inStreamType == GLS_CONTEXT) {
        inoutWriter->alloc = __glsWriter_alloc_context;
    } else {
        inoutWriter->alloc = __glsWriter_alloc_bin;
    }
    inoutWriter->beginCommand = __glsWriter_beginCommand_bin;
    inoutWriter->endCommand = __glsWriter_endCommand_bin;
    inoutWriter->nextList = __glsWriter_nextList_bin;
    inoutWriter->padWordCount = (
        swap ? __glsWriter_padWordCount_bin_swap : __glsWriter_padWordCount_bin
    );
    __GLS_INIT_PUT_BIN(GLbyte, GLbyte);
    __GLS_INIT_PUT_BIN(GLubyte, GLubyte);
    __GLS_INIT_PUT_BIN_SWAP(GLdouble, GLdouble);
    __GLS_INIT_PUT_BIN_SWAP(GLfloat, GLfloat);
    __GLS_INIT_PUT_BIN_SWAP(GLint, GLint);
    __GLS_INIT_PUT_BIN_SWAP(GLshort, GLshort);
    __GLS_INIT_PUT_BIN_SWAP(GLuint, GLuint);
    __GLS_INIT_PUT_BIN_SWAP(GLushort, GLushort);
    __GLS_INIT_PUT_BIN_SWAP_MAT(GLdouble, GLdouble);
    __GLS_INIT_PUT_BIN_SWAP_MAT(GLfloat, GLfloat);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLSenum, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLSimageFlags, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLSopcode, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLattribMask, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLblendingFactor, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLclearBufferMask, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLdrawBufferMode, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLenum, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLlong, GLlong);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLoutArg, GLoutArg);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLstencilOp, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLtextureComponentCount, GLint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLuinthex, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLulong, GLulong);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLulonghex, GLulong);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLushorthex, GLushort);
    __GLS_INIT_PUT_BIN_SWAP_VEC(GLlong, GLlong);
    __GLS_INIT_PUT_BIN_SWAP_VEC(GLulong, GLulong);
    __GLS_INIT_PUT_BIN_VAL(GLboolean, GLubyte);
    __GLS_INIT_PUT_BIN_VAL(GLdoubleOrGLenum, GLdoubleOrGLenum);
    __GLS_INIT_PUT_BIN_VAL(GLfloatOrGLenum, GLfloatOrGLenum);
    __GLS_INIT_PUT_BIN_VAL(GLintOrGLSenum, GLintOrGLSenum);
    __GLS_INIT_PUT_BIN_VAL(GLintOrGLenum, GLintOrGLenum);
    __GLS_INIT_PUT_BIN_VEC(GLboolean, GLubyte);
    __GLS_INIT_PUT_BIN_VEC(GLchar, GLubyte);
    __GLS_INIT_PUT_BIN_VEC(GLdoubleOrGLenum, GLdoubleOrGLenum);
    __GLS_INIT_PUT_BIN_VEC(GLfloatOrGLenum, GLfloatOrGLenum);
    __GLS_INIT_PUT_BIN_VEC(GLintOrGLenum, GLintOrGLenum);
    __GLS_INIT_PUT_BIN_VECSTRIDE(GLbit, GLbit);
    __GLS_INIT_PUT_BIN_VECSTRIDE(GLboolean, GLubyte);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\test\tcapture.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <GL/gls.h>

#if __GLS_PLATFORM_WIN32
    #include <fcntl.h>
    #include <io.h>
    #define __MAIN_LINKAGE __cdecl
#else /* !__GLS_PLATFORM_WIN32 */
    #define __MAIN_LINKAGE
#endif /* __GLS_PLATFORM_WIN32 */

static void configStdio(void) {
    setbuf(stdout, GLS_NONE);
    #if __GLS_PLATFORM_WIN32
        _setmode(_fileno(stdout), _O_BINARY);
        _setmode(_fileno(stderr), _O_BINARY);
    #endif /* __GLS_PLATFORM_WIN32 */
}

GLint __MAIN_LINKAGE main(const GLsizei inArgc, const GLubyte *inArgv[]) {
    configStdio();
    glsContext(glsGenContext());
    glsBeginCapture(glsCSTR(""), GLS_TEXT, GLS_NONE);
    glsComment(glsCSTR("GLS test"));
    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
    glBegin(GL_POINTS);
    glVertex3f((GLfloat)1.3, (GLfloat)2.4, (GLfloat)5.6);
    glEnd();
    glsEndCapture();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\writetxt.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <string.h>

/******************************************************************************
Helpers
******************************************************************************/

#define __GLS_ALLOC(inoutWriter, inReturn) \
    if ( \
        inoutWriter->bufPtr >= inoutWriter->bufTail && \
        !__glsWriter_flush(inoutWriter) \
    ) { \
        return inReturn; \
    }

#define __GLS_PARAM_SEP(inoutWriter) \
    if (inoutWriter->paramCount++) { \
        __GLS_PUT_CHAR(inoutWriter, ','); \
        __GLS_PUT_CHAR(inoutWriter, ' '); \
    }

#define __GLS_PARAM_SETUP(inoutWriter) \
    __GLS_ALLOC(inoutWriter, __GLS_NULL); \
    __GLS_PARAM_SEP(inoutWriter);

#define __GLS_PUT_BOOLEAN(inoutWriter, inVal) \
    if (!__glsWriter_putGLbooleanVal_text(inoutWriter, inVal)) { \
        __GLS_PUT_INT(inoutWriter, inVal); \
    }

#define __GLS_PUT_CHAR(inoutWriter, inChar) \
    *inoutWriter->bufPtr++ = inChar;

#define __GLS_PUT_DOUBLE(inoutWriter, inVal) \
    if (__GLS_FINITE(inVal)) { \
        __GLS_C_LOCALE_DECLARE; \
        __GLS_C_LOCALE_BEGIN; \
        __GLS_PUT_NUM(inoutWriter, "%.16g", inVal); \
        __GLS_C_LOCALE_END; \
    } else { \
        __GLS_PUT_HEX16(inoutWriter, *(const GLulong *)&(inVal)); \
    }

#define __GLS_PUT_DOUBLE17(inoutWriter, inVal) \
    if (__GLS_FINITE(inVal)) { \
        __GLS_C_LOCALE_DECLARE; \
        __GLS_C_LOCALE_BEGIN; \
        __GLS_PUT_NUM(inoutWriter, "%-17.16g", inVal); \
        __GLS_C_LOCALE_END; \
    } else { \
        __GLS_PUT_HEX16(inoutWriter, *(const GLulong *)&(inVal)); \
    }

#define __GLS_PUT_FLOAT(inoutWriter, inVal) \
    if (__GLS_FINITE((GLdouble)inVal)) { \
        __GLS_C_LOCALE_DECLARE; \
        __GLS_C_LOCALE_BEGIN; \
        __GLS_PUT_NUM(inoutWriter, "%.7g", inVal); \
        __GLS_C_LOCALE_END; \
    } else { \
        __GLS_PUT_HEX8(inoutWriter, *(const GLuint *)&(inVal)); \
    }

#define __GLS_PUT_FLOAT11(inoutWriter, inVal) \
    if (__GLS_FINITE((GLdouble)inVal)) { \
        __GLS_C_LOCALE_DECLARE; \
        __GLS_C_LOCALE_BEGIN; \
        __GLS_PUT_NUM(inoutWriter, "%-11.7g", inVal); \
        __GLS_C_LOCALE_END; \
    } else { \
        __GLS_PUT_HEX8(inoutWriter, *(const GLuint *)&(inVal)); \
    }

#define __GLS_PUT_HEX2(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "0x%.2x", inVal);

#define __GLS_PUT_HEX4(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "0x%.4x", inVal);

#define __GLS_PUT_HEX8(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "0x%.8x", inVal);

#if __GLS_SPRINTF_INT64
    #define __GLS_PUT_HEX16(inoutWriter, inVal) \
        __GLS_PUT_NUM(inoutWriter, __GLS_OUT_FORMAT_INT64HEX, inVal);
#else /* !__GLS_SPRINTF_INT64 */
    #define __GLS_PUT_HEX16(inoutWriter, inVal) \
        __GLS_PUT_NUM( \
            inoutWriter, "0x%.8x", glsULongHigh(*(const GLulong *)&(inVal)) \
        ); \
        __GLS_PUT_NUM( \
            inoutWriter, "%.8x", glsULongLow(*(const GLulong *)&(inVal)) \
        );
#endif /* __GLS_SPRINTF_INT64 */

#define __GLS_PUT_INT(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "%d", inVal);

#if __GLS_SPRINTF_INT64
    #define __GLS_PUT_LONG(inoutWriter, inVal) \
        __GLS_PUT_NUM(inoutWriter, __GLS_OUT_FORMAT_INT64, inVal);
#elif defined(__GLS_INT64_TO_STR)
    #define __GLS_PUT_LONG(inoutWriter, inVal) \
        inoutWriter->bufPtr += \
            strlen(__GLS_INT64_TO_STR(inVal, (char *)inoutWriter->bufPtr));
#else /* !__GLS_SPRINTF_INT64 && !defined(__GLS_INT64_TO_STR) */
    #define __GLS_PUT_LONG(inoutWriter, inVal) \
        __GLS_PUT_HEX16(inoutWriter, inVal);
#endif /* __GLS_SPRINTF_INT64 */

#define __GLS_PUT_NUM(inoutWriter, inFormat, inVal) \
    inoutWriter->bufPtr += sprintf( \
        (char *)inoutWriter->bufPtr, (const char *)(inFormat), inVal \
    );

#define __GLS_PUT_STRING(inoutWriter, inString) { \
    size_t __count = strlen((const char *)inString); \
    const GLubyte *ptr = glsCSTR(inString); \
    while (__count-- > 0) { \
        if (*ptr == '\\' || *ptr == '\"') *inoutWriter->bufPtr++ = '\\'; \
        *inoutWriter->bufPtr++ = *ptr++; \
    } \
}

#define __GLS_PUT_TEXT(inType, inSize, inCategory) \
    __GLS_PUT_TEXT_VAL(inType, inSize, inCategory) \
    __GLS_PUT_TEXT_VEC(inType, inSize, inCategory) \
    __GLS_PUT_TEXT_VECSTRIDE(inType, inSize, inCategory)

#define __GLS_PUT_TEXT_ENUM(inType, inEnum, inCategory) \
    __GLS_PUT_TEXT_ENUM_VAL(inType, inEnum, inCategory) \
    __GLS_PUT_TEXT_ENUM_VEC(inType, inEnum, inCategory)

#define __GLS_PUT_TEXT_ENUM_VAL(inType, inEnum, inCategory) \
static void __glsWriter_put##inType##Or##inEnum##_text( \
    __GLSwriter *inoutWriter, \
    GLenum inParam, \
    inType inVal \
) { \
    __GLS_PARAM_SETUP(inoutWriter); \
    if ( \
        !__GLS_FINITE((GLdouble)inVal) || \
        floor((GLdouble)inVal) != (GLdouble)inVal || \
        (GLdouble)inVal < 0. || \
        (GLdouble)inVal > (GLdouble)UINT_MAX || \
        !__glsWriter_put##inEnum##ParamVal_text( \
            inoutWriter, inParam, (inEnum)inVal \
        ) \
    ) { \
        __GLS_PUT_##inCategory(inoutWriter, inVal); \
    } \
}

#define __GLS_PUT_TEXT_ENUM_VEC(inType, inEnum, inCategory) \
static void __glsWriter_put##inType##Or##inEnum##v_text( \
    __GLSwriter *inoutWriter, \
    GLenum inParam, \
    GLuint inCount, \
    const inType *inVec \
) { \
    GLuint i; \
    const GLboolean multiLine = (GLboolean)(inCount > 4); \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_CHAR(inoutWriter, '{'); \
    for (i = 0 ; i < inCount ; ++i) { \
        __GLS_ALLOC(inoutWriter, __GLS_NULL); \
        if (i) __GLS_PUT_CHAR(inoutWriter, ','); \
        if (multiLine && !(i & 7)) { \
            __GLS_PUT_STRING(inoutWriter, "\n    "); \
        } else if (i) { \
            __GLS_PUT_CHAR(inoutWriter, ' '); \
        } \
        if ( \
            !__GLS_FINITE((GLdouble)inVec[i]) || \
            floor((GLdouble)inVec[i]) != (GLdouble)inVec[i] || \
            (GLdouble)inVec[i] < 0. || \
            (GLdouble)inVec[i] > (GLdouble)UINT_MAX || \
            !__glsWriter_put##inEnum##ParamVal_text( \
                inoutWriter, inParam, (inEnum)inVec[i] \
            ) \
        ) { \
            __GLS_PUT_##inCategory(inoutWriter, inVec[i]); \
        } \
    } \
    if (multiLine) __GLS_PUT_CHAR(inoutWriter, '\n'); \
    __GLS_PUT_CHAR(inoutWriter, '}'); \
}

#define __GLS_PUT_TEXT_MAT(inType, inCategory) \
static void __glsWriter_put##inType##m_text( \
    __GLSwriter *inoutWriter, \
    const inType *inMat \
) { \
    GLuint i, j; \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_CHAR(inoutWriter, '{'); \
    for (i = 0 ; i < 4 ; ++i) { \
        __GLS_ALLOC(inoutWriter, __GLS_NULL); \
        if (i) __GLS_PUT_CHAR(inoutWriter, ','); \
        __GLS_PUT_STRING(inoutWriter, "\n    "); \
        for (j = 0 ; j < 4 ; ++j) { \
            if (j) __GLS_PUT_STRING(inoutWriter, ", "); \
            __GLS_PUT_##inCategory(inoutWriter, inMat[i * 4 + j]); \
        } \
    } \
    __GLS_PUT_STRING(inoutWriter, "\n}"); \
}

#define __GLS_PUT_TEXT_VAL(inType, inSize, inCategory) \
static void __glsWriter_put##inType##_text( \
    __GLSwriter *inoutWriter, inType inVal \
) { \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_##inCategory(inoutWriter, inVal); \
}

#define __GLS_PUT_TEXT_VEC(inType, inSize, inCategory) \
static void __glsWriter_put##inType##v_text( \
    __GLSwriter *inoutWriter, \
    GLuint inCount, \
    const inType *inVec \
) { \
    GLuint i; \
    const GLboolean multiLine = (GLboolean)(inCount > 4); \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_CHAR(inoutWriter, '{'); \
    for (i = 0 ; i < inCount ; ++i) { \
        __GLS_ALLOC(inoutWriter, __GLS_NULL); \
        if (i) __GLS_PUT_CHAR(inoutWriter, ','); \
        if (multiLine && !(i & 7)) { \
            __GLS_PUT_STRING(inoutWriter, "\n    "); \
        } else if (i) { \
            __GLS_PUT_CHAR(inoutWriter, ' '); \
        } \
        __GLS_PUT_##inCategory(inoutWriter, inVec[i]); \
    } \
    if (multiLine) __GLS_PUT_CHAR(inoutWriter, '\n'); \
    __GLS_PUT_CHAR(inoutWriter, '}'); \
}

#define __GLS_PUT_TEXT_VECSTRIDE(inType, inSize, inCategory) \
static void __glsWriter_put##inType##vs_text( \
    __GLSwriter *inoutWriter, \
    GLboolean inItemSwap, \
    GLint inStride1DataItems, \
    GLint inStride1PadBytes, \
    GLint inStride1Count, \
    GLint inStride2PadBytes, \
    GLint inStride2Count, \
    const inType *inVec \
) { \
    GLint i, j, param = 0; \
    const GLboolean multiLine = (GLboolean)( \
        inStride1DataItems * inStride1Count * inStride2Count > 4 \
    ); \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_CHAR(inoutWriter, '{'); \
    if (inItemSwap) while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, ++param) { \
                inType val = *inVec++; \
                __GLS_ALLOC(inoutWriter, __GLS_NULL); \
                if (param) __GLS_PUT_CHAR(inoutWriter, ','); \
                if (multiLine && !(param & 7)) { \
                    __GLS_PUT_STRING(inoutWriter, "\n    "); \
                } else if (param) { \
                    __GLS_PUT_CHAR(inoutWriter, ' '); \
                } \
                __glsSwap##inSize(&val); \
                __GLS_PUT_##inCategory(inoutWriter, val); \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } else while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, ++param) { \
                inType val = *inVec++; \
                __GLS_ALLOC(inoutWriter, __GLS_NULL); \
                if (param) __GLS_PUT_CHAR(inoutWriter, ','); \
                if (multiLine && !(param & 7)) { \
                    __GLS_PUT_STRING(inoutWriter, "\n    "); \
                } else if (param) { \
                    __GLS_PUT_CHAR(inoutWriter, ' '); \
                } \
                __GLS_PUT_##inCategory(inoutWriter, val); \
            } \
       } \
       inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
     } \
    if (multiLine) __GLS_PUT_CHAR(inoutWriter, '\n'); \
    __GLS_PUT_CHAR(inoutWriter, '}'); \
}

#define __GLS_PUT_UNSIGNED_INT(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "%u", inVal);

#if __GLS_SPRINTF_INT64
    #define __GLS_PUT_UNSIGNED_LONG(inoutWriter, inVal) \
        __GLS_PUT_NUM(inoutWriter, __GLS_OUT_FORMAT_INT64U, inVal);
#elif defined(__GLS_INT64U_TO_STR)
    #define __GLS_PUT_UNSIGNED_LONG(inoutWriter, inVal) \
        inoutWriter->bufPtr += \
            strlen(__GLS_INT64U_TO_STR(inVal, (char *)inoutWriter->bufPtr));
#else /* !__GLS_SPRINTF_INT64 && !defined(__GLS_INT64U_TO_STR) */
    #define __GLS_PUT_UNSIGNED_LONG(inoutWriter, inVal) \
        __GLS_PUT_HEX16(inoutWriter, inVal);
#endif /* __GLS_SPRINTF_INT64 */

__GLS_FORWARD static GLboolean __glsWriter_putGLbooleanVal_text(
    __GLSwriter *inoutWriter, GLboolean inVal
);

__GLS_FORWARD static GLboolean __glsWriter_putGLenumVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
);

__GLS_FORWARD static GLboolean __glsWriter_putGLstencilOpVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
);

__GLS_FORWARD static GLboolean __glsWriter_putGLtextureComponentCountVal_text(
    __GLSwriter *inoutWriter, GLint inVal
);

static void __glsWriter_putBitfield_text(
    __GLSwriter *inoutWriter,
    GLbitfield inBits,
    GLint inCount,
    const GLubyte *const inString[],
    const GLbitfield inVal[]
) {
    GLint i, putCount;

    __GLS_PARAM_SETUP(inoutWriter);
    for (i = 0 ; i < inCount ; ++i) {
        if (inBits == inVal[i]) {
            __GLS_PUT_STRING(inoutWriter, inString[i]);
            return;
        }
    }
    for (putCount = i = 0 ; i < inCount ; ++i) {
        if (inBits & inVal[i]) {
            inBits &= ~inVal[i];
            __GLS_ALLOC(inoutWriter, __GLS_NULL);
            if (putCount++) __GLS_PUT_STRING(inoutWriter, " | ");
            __GLS_PUT_STRING(inoutWriter, inString[i]);
        }
    }
    if (inBits) {
        __GLS_ALLOC(inoutWriter, __GLS_NULL);
        if (putCount) __GLS_PUT_STRING(inoutWriter, " | ");
        __GLS_PUT_HEX8(inoutWriter, inBits);
    }
}

static GLboolean __glsWriter_putGLSenumVal_text(
    __GLSwriter *inoutWriter, GLSenum inVal
) {
    const GLint page = __GLS_ENUM_PAGE(inVal);
    const GLint offset = __GLS_ENUM_OFFSET(inVal);

    if (
        page < __GLS_ENUM_PAGE_COUNT &&
        offset < __glsEnumStringCount[page] &&
        __glsEnumString[page][offset]
    ) {
        __GLS_PUT_STRING(inoutWriter, __glsEnumString[page][offset]);
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLSenumParamVal_text(
    __GLSwriter *inoutWriter, GLSenum inParam, GLSenum inVal
) {
    switch (inParam) {
        case GLS_DISPLAY_FORMAT:
            return __glsWriter_putGLSenumVal_text(inoutWriter, inVal);
        case GLS_DOUBLEBUFFER:
        case GLS_INVISIBLE:
        case GLS_STEREO:
        case GLS_TILEABLE:
        case GLS_TRANSPARENT:
            return (
                __glsWriter_putGLbooleanVal_text(inoutWriter, (GLboolean)inVal)
            );
        default:
            return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLblendingFactorVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    switch (inVal) {
        case GL_ZERO:
            __GLS_PUT_STRING(inoutWriter, "GL_ZERO");
            return GL_TRUE;
        case GL_ONE:
            __GLS_PUT_STRING(inoutWriter, "GL_ONE");
            return GL_TRUE;
        default:
            return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
    }
}

static GLboolean __glsWriter_putGLbooleanVal_text(
    __GLSwriter *inoutWriter, GLboolean inVal
) {
    switch (inVal) {
        case GL_FALSE:
            __GLS_PUT_STRING(inoutWriter, "GL_FALSE");
            return GL_TRUE;
        case GL_TRUE:
            __GLS_PUT_STRING(inoutWriter, "GL_TRUE");
            return GL_TRUE;
        default:
            return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLdrawBufferModeVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    if (inVal) {
        return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
    } else {
        __GLS_PUT_STRING(inoutWriter, "GL_NONE");
        return GL_TRUE;
    }
}

static GLboolean __glsWriter_putGLenumParamVal_text(
    __GLSwriter *inoutWriter, GLenum inParam, GLenum inVal
) {
    switch (inParam) {
        case GL_FOG_MODE:
        case GL_TEXTURE_ENV_MODE:
        case GL_TEXTURE_GEN_MODE:
        case GL_TEXTURE_MAG_FILTER:
        case GL_TEXTURE_MIN_FILTER:
        case GL_TEXTURE_WRAP_S:
        case GL_TEXTURE_WRAP_T:
        #if __GL_EXT_convolution
            case GL_CONVOLUTION_BORDER_MODE_EXT:
        #endif /* __GL_EXT_convolution */
        #if __GL_EXT_texture3D
            case GL_TEXTURE_WRAP_R_EXT:
        #endif /* __GL_EXT_texture3D */
        #if __GL_SGIS_component_select
            case GL_TEXTURE_SS_SELECT_SGIS:
            case GL_TEXTURE_SSSS_SELECT_SGIS:
        #endif /* __GL_SGIS_component_select */
        #if __GL_SGIS_detail_texture
            case GL_DETAIL_TEXTURE_MODE_SGIS:
        #endif /* __GL_SGIS_detail_texture */
        #if __GL_SGIS_texture4D
            case GL_TEXTURE_WRAP_Q_SGIS:
        #endif /* __GL_SGIS_texture4D */
        #if __GL_SGIX_sprite
            case GL_SPRITE_MODE_SGIX:
        #endif /* __GL_SGIX_sprite */
            return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
        case GL_LIGHT_MODEL_LOCAL_VIEWER:
        case GL_LIGHT_MODEL_TWO_SIDE:
        case GL_MAP_COLOR:
        case GL_MAP_STENCIL:
        case GL_PACK_LSB_FIRST:
        case GL_PACK_SWAP_BYTES:
        case GL_UNPACK_LSB_FIRST:
        case GL_UNPACK_SWAP_BYTES:
            return (
                __glsWriter_putGLbooleanVal_text(inoutWriter, (GLboolean)inVal)
            );
        default:
            return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLenumVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    const GLint page = __GL_ENUM_PAGE(inVal);
    const GLint offset = __GL_ENUM_OFFSET(inVal);

    if (
        page < __GL_ENUM_PAGE_COUNT &&
        offset < __glEnumStringCount[page] &&
        __glEnumString[page][offset]
    ) {
        __GLS_PUT_STRING(inoutWriter, __glEnumString[page][offset]);
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLstencilOpVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    if (inVal) {
        return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
    } else {
        __GLS_PUT_STRING(inoutWriter, "GL_ZERO");
        return GL_TRUE;
    }
}

static GLboolean __glsWriter_putGLtextureComponentCountVal_text(
    __GLSwriter *inoutWriter, GLint inVal
) {
    if (inVal > 4) {
        return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
    } else {
        return GL_FALSE;
    }
}

typedef GLuint GLuinthex;
typedef GLulong GLulonghex;
typedef GLushort GLushorthex;

__GLS_PUT_TEXT(GLbyte, 1, INT)
__GLS_PUT_TEXT(GLubyte, 1, UNSIGNED_INT)
__GLS_PUT_TEXT(GLshort, 2, INT)
__GLS_PUT_TEXT(GLushort, 2, UNSIGNED_INT)
__GLS_PUT_TEXT(GLint, 4, INT)
__GLS_PUT_TEXT(GLuint, 4, UNSIGNED_INT)
__GLS_PUT_TEXT(GLfloat, 4, FLOAT)
__GLS_PUT_TEXT(GLdouble, 8, DOUBLE)
__GLS_PUT_TEXT_ENUM(GLfloat, GLenum, FLOAT)
__GLS_PUT_TEXT_ENUM(GLdouble, GLenum, DOUBLE)
__GLS_PUT_TEXT_ENUM(GLint, GLenum, INT)
__GLS_PUT_TEXT_ENUM_VAL(GLint, GLSenum, INT)
__GLS_PUT_TEXT_MAT(GLfloat, FLOAT11)
__GLS_PUT_TEXT_MAT(GLdouble, DOUBLE17)
__GLS_PUT_TEXT_VAL(GLlong, 8, LONG)
__GLS_PUT_TEXT_VAL(GLuinthex, 4, HEX8)
__GLS_PUT_TEXT_VAL(GLulong, 8, UNSIGNED_LONG)
__GLS_PUT_TEXT_VAL(GLulonghex, 8, HEX16)
__GLS_PUT_TEXT_VAL(GLushorthex, 2, HEX4)
__GLS_PUT_TEXT_VEC(GLboolean, 1, BOOLEAN)
__GLS_PUT_TEXT_VEC(GLlong, 8, LONG)
__GLS_PUT_TEXT_VEC(GLulong, 8, UNSIGNED_LONG)
__GLS_PUT_TEXT_VECSTRIDE(GLboolean, 1, BOOLEAN)

/******************************************************************************
Writers
******************************************************************************/

static GLboolean __glsWriter_beginCommand_text(
    __GLSwriter *inoutWriter, GLSopcode inOpcode, size_t inByteCount
) {
    if (!inoutWriter || inoutWriter->error) return GL_FALSE;
    __GLS_ALLOC(inoutWriter, GL_FALSE);
    inoutWriter->commandOpcode = inOpcode;
    inoutWriter->paramCount = 0;
    __GLS_PUT_STRING(inoutWriter, __glsOpcodeString[__glsMapOpcode(inOpcode)]);
    __GLS_PUT_CHAR(inoutWriter, '(');
    return GL_TRUE;
}

static void __glsWriter_endCommand_text(__GLSwriter *inoutWriter) {
    __GLS_ALLOC(inoutWriter, __GLS_NULL);
    __GLS_PUT_CHAR(inoutWriter, ')');
    __GLS_PUT_CHAR(inoutWriter, ';');
    __GLS_PUT_CHAR(inoutWriter, '\n');
}

static void __glsWriter_nextList_text(__GLSwriter *inoutWriter) {
    __GLS_ALLOC(inoutWriter, __GLS_NULL);
    __GLS_PUT_STRING(inoutWriter, ")(");
    inoutWriter->paramCount = 0;
}

static GLboolean __glsWriter_padWordCount_text(
    __GLSwriter *inoutWriter, GLboolean inCountMod2
) {
    return GL_TRUE;
}

static void __glsWriter_putGLSenum_text(
    __GLSwriter *inoutWriter, GLSenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLSenumVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLSimageFlags_text(
    __GLSwriter *inoutWriter, GLbitfield inVal
) {
    __glsWriter_putBitfield_text(
        inoutWriter,
        inVal,
        __GLS_IMAGE_FLAGS_COUNT,
        __glsImageFlagsString,
        __glsImageFlagsVal
    );
}

static void __glsWriter_putGLSopcode_text(
    __GLSwriter *inoutWriter, GLSopcode inVal
) {
    const GLSopcode opcode = __glsMapOpcode(inVal);

    __GLS_PARAM_SETUP(inoutWriter);
    if (
        opcode >= __GLS_OPCODES_PER_PAGE &&
        opcode < __GLS_OPCODE_COUNT &&
        __glsOpcodeString[opcode]
    ) {
        __GLS_PUT_STRING(inoutWriter, "GLS_OP_");
        __GLS_PUT_STRING(inoutWriter, __glsOpcodeString[opcode]);
    } else {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLattribMask_text(
    __GLSwriter *inoutWriter, GLbitfield inVal
) {
    __glsWriter_putBitfield_text(
        inoutWriter,
        inVal,
        __GL_ATTRIB_MASK_COUNT,
        __glAttribMaskString,
        __glAttribMaskVal
    );
}

static void __glsWriter_putGLbitvs_text(
    __GLSwriter *inoutWriter,
    GLboolean inItemSwap,
    GLint inItemLeftShift,
    GLint inStrideDataItems,
    GLint inStridePadItems,
    GLint inStrideCount,
    const GLubyte *inVec
) {
    GLint i, param = 0;
    const GLboolean multiLine = (GLboolean)(
        inStrideDataItems * inStrideCount / 8 > 4
    );
    const GLint highShift = inItemLeftShift;
    const GLint lowShift = 8 - inItemLeftShift;
    GLubyte lastMask = 0xffu;

    if (inStrideDataItems & 7) lastMask <<= 8 - (inStrideDataItems & 7);
    inStrideDataItems = (inStrideDataItems + 7) >> 3;
    inStridePadItems >>= 3;
    __GLS_PARAM_SETUP(inoutWriter);
    __GLS_PUT_CHAR(inoutWriter, '{');
    while (inStrideCount-- > 0) {
        GLubyte val;

        i = inStrideDataItems;
        while (i-- > 0) {
            if (inItemSwap) {
                val = __glsBitReverse[*inVec++];
                if (inItemLeftShift) {
                    if (i) {
                        val <<= highShift;
                        val |= __glsBitReverse[*inVec] >> lowShift;
                    } else {
                        val = (GLubyte)((val & lastMask) << highShift);
                    }
                } else if (!i) {
                    val &= lastMask;
                }
            } else {
                val = *inVec++;
                if (inItemLeftShift) {
                    if (i) {
                        val = (GLubyte)(val << highShift | *inVec >> lowShift);
                    } else {
                        val = (GLubyte)((val & lastMask) << highShift);
                    }
                } else if (!i) {
                    val &= lastMask;
                }
            }
            __GLS_ALLOC(inoutWriter, __GLS_NULL);
            if (param) __GLS_PUT_CHAR(inoutWriter, ',');
            if (multiLine && !(param & 7)) {
                __GLS_PUT_STRING(inoutWriter, "\n    ");
            } else if (param) {
                __GLS_PUT_CHAR(inoutWriter, ' ');
            }
            __GLS_PUT_HEX2(inoutWriter, val);
            ++param;
        }
        inVec += inStridePadItems;
    }
    if (multiLine) __GLS_PUT_CHAR(inoutWriter, '\n');
    __GLS_PUT_CHAR(inoutWriter, '}');
}

static void __glsWriter_putGLblendingFactor_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLblendingFactorVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLboolean_text(
    __GLSwriter *inoutWriter, GLboolean inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLbooleanVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLcharv_text(
    __GLSwriter *inoutWriter, GLuint inCount, const GLubyte *inString
) {
    size_t count = strlen((const char *)inString);
    const GLubyte *ptr = inString;

    __GLS_PARAM_SETUP(inoutWriter);
    __GLS_PUT_CHAR(inoutWriter, '"');
    while (count-- > 0) {
        __GLS_ALLOC(inoutWriter, __GLS_NULL);
        if (__GLS_CHAR_IS_GRAPHIC(*ptr)) {
            if (*ptr == '\\' || *ptr == '\"') *inoutWriter->bufPtr++ = '\\';
            *inoutWriter->bufPtr++ = *ptr++;
        } else {
            __GLS_PUT_NUM(inoutWriter, "\\x%.2x", *ptr++);
        }
    }
    __GLS_PUT_CHAR(inoutWriter, '"');
}

static void __glsWriter_putGLclearBufferMask_text(
    __GLSwriter *inoutWriter, GLbitfield inVal
) {
    __glsWriter_putGLattribMask_text(inoutWriter, inVal);
}

static void __glsWriter_putGLdrawBufferMode_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLdrawBufferModeVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLenum_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLenumVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLoutArg_text(
    __GLSwriter *inoutWriter, GLuint inIndex, const GLvoid *inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    __glsWriter_putGLulonghex_text(
        inoutWriter,
        (
            ctx->callNesting &&
            !ctx->commandFuncs[__glsMapOpcode(inoutWriter->commandOpcode)]
        ) ?
        ctx->outArgs.vals[inIndex] :
        __glsPtrToULong(inVal)
    );
}

static void __glsWriter_putGLstencilOp_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLstencilOpVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLtextureComponentCount_text(
    __GLSwriter *inoutWriter, GLint inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLtextureComponentCountVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

/******************************************************************************
Dispatch setup
******************************************************************************/

#define __GLS_INIT_PUT_TEXT(inType) \
    inoutWriter->put##inType = __glsWriter_put##inType##_text

void __glsWriter_initDispatch_text(__GLSwriter *inoutWriter) {
    inoutWriter->beginCommand = __glsWriter_beginCommand_text;
    inoutWriter->endCommand = __glsWriter_endCommand_text;
    inoutWriter->nextList = __glsWriter_nextList_text;
    inoutWriter->padWordCount = __glsWriter_padWordCount_text;
    __GLS_INIT_PUT_TEXT(GLSenum);
    __GLS_INIT_PUT_TEXT(GLSimageFlags);
    __GLS_INIT_PUT_TEXT(GLSopcode);
    __GLS_INIT_PUT_TEXT(GLattribMask);
    __GLS_INIT_PUT_TEXT(GLbitvs);
    __GLS_INIT_PUT_TEXT(GLblendingFactor);
    __GLS_INIT_PUT_TEXT(GLboolean);
    __GLS_INIT_PUT_TEXT(GLbooleanv);
    __GLS_INIT_PUT_TEXT(GLbooleanvs);
    __GLS_INIT_PUT_TEXT(GLbyte);
    __GLS_INIT_PUT_TEXT(GLbytev);
    __GLS_INIT_PUT_TEXT(GLbytevs);
    __GLS_INIT_PUT_TEXT(GLcharv);
    __GLS_INIT_PUT_TEXT(GLclearBufferMask);
    __GLS_INIT_PUT_TEXT(GLdouble);
    __GLS_INIT_PUT_TEXT(GLdoubleOrGLenum);
    __GLS_INIT_PUT_TEXT(GLdoubleOrGLenumv);
    __GLS_INIT_PUT_TEXT(GLdoublem);
    __GLS_INIT_PUT_TEXT(GLdoublev);
    __GLS_INIT_PUT_TEXT(GLdoublevs);
    __GLS_INIT_PUT_TEXT(GLdrawBufferMode);
    __GLS_INIT_PUT_TEXT(GLenum);
    __GLS_INIT_PUT_TEXT(GLfloat);
    __GLS_INIT_PUT_TEXT(GLfloatOrGLenum);
    __GLS_INIT_PUT_TEXT(GLfloatOrGLenumv);
    __GLS_INIT_PUT_TEXT(GLfloatm);
    __GLS_INIT_PUT_TEXT(GLfloatv);
    __GLS_INIT_PUT_TEXT(GLfloatvs);
    __GLS_INIT_PUT_TEXT(GLint);
    __GLS_INIT_PUT_TEXT(GLintOrGLSenum);
    __GLS_INIT_PUT_TEXT(GLintOrGLenum);
    __GLS_INIT_PUT_TEXT(GLintOrGLenumv);
    __GLS_INIT_PUT_TEXT(GLintv);
    __GLS_INIT_PUT_TEXT(GLintvs);
    __GLS_INIT_PUT_TEXT(GLlong);
    __GLS_INIT_PUT_TEXT(GLlongv);
    __GLS_INIT_PUT_TEXT(GLoutArg);
    __GLS_INIT_PUT_TEXT(GLshort);
    __GLS_INIT_PUT_TEXT(GLshortv);
    __GLS_INIT_PUT_TEXT(GLshortvs);
    __GLS_INIT_PUT_TEXT(GLstencilOp);
    __GLS_INIT_PUT_TEXT(GLtextureComponentCount);
    __GLS_INIT_PUT_TEXT(GLubyte);
    __GLS_INIT_PUT_TEXT(GLubytev);
    __GLS_INIT_PUT_TEXT(GLubytevs);
    __GLS_INIT_PUT_TEXT(GLuint);
    __GLS_INIT_PUT_TEXT(GLuinthex);
    __GLS_INIT_PUT_TEXT(GLuintv);
    __GLS_INIT_PUT_TEXT(GLuintvs);
    __GLS_INIT_PUT_TEXT(GLulong);
    __GLS_INIT_PUT_TEXT(GLulonghex);
    __GLS_INIT_PUT_TEXT(GLulongv);
    __GLS_INIT_PUT_TEXT(GLushort);
    __GLS_INIT_PUT_TEXT(GLushorthex);
    __GLS_INIT_PUT_TEXT(GLushortv);
    __GLS_INIT_PUT_TEXT(GLushortvs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\test\tparser.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

#if __GLS_PLATFORM_WIN32
    #include <fcntl.h>
    #include <io.h>
    #define __MAIN_LINKAGE __cdecl
#else /* !__GLS_PLATFORM_WIN32 */
    #define __MAIN_LINKAGE
#endif /* __GLS_PLATFORM_WIN32 */

static void configStdio(void) {
    setbuf(stdout, GLS_NONE);
    #if __GLS_PLATFORM_WIN32
        _setmode(_fileno(stdout), _O_BINARY);
        _setmode(_fileno(stderr), _O_BINARY);
    #endif /* __GLS_PLATFORM_WIN32 */
}

GLint __MAIN_LINKAGE main(const GLsizei inArgc, const GLubyte *inArgv[]) {
    configStdio();
    __glsParser_print(__glsParser_create());
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\inc\winmem.h ===
#include <windows.h>

#define malloc(size)        gluAlloc((UINT)(size))
#define calloc(nobj, size)  gluCalloc((UINT)(nobj), (UINT)(size))
#define realloc(p, size)    gluReAlloc((HLOCAL)(p), (UINT)(size))
#define free(p)             LocalFree((HLOCAL)(p))

HLOCAL gluAlloc (UINT size);
HLOCAL gluCalloc (UINT nobj, UINT size);
HLOCAL gluReAlloc (HLOCAL p, UINT size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\inc\glstring.h ===
/******************************Module*Header*******************************\
* Module Name: glstring.h
*
* String resource IDs.
*
* Created: 17-Feb-1994 15:54:45
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef _GLSTRING_H_
#define _GLSTRING_H_

#define STR_GLU_NO_ERROR                1
#define STR_GLU_INVALID_ENUM            2
#define STR_GLU_INVALID_VAL             3
#define STR_GLU_INVALID_OP              4
#define STR_GLU_STACK_OVER              5
#define STR_GLU_STACK_UNDER             6
#define STR_GLU_OUT_OF_MEM              7

#define STR_TESS_BEGIN_POLY             40
#define STR_TESS_BEGIN_CONTOUR          41
#define STR_TESS_END_POLY               42
#define STR_TESS_END_CONTOUR            43
#define STR_TESS_COORD_TOO_LARGE        44
#define STR_TESS_NEED_COMBINE_CALLBACK  45

#define STR_NURB_00             100
#define STR_NURB_01             101
#define STR_NURB_02             102
#define STR_NURB_03             103
#define STR_NURB_04             104
#define STR_NURB_05             105
#define STR_NURB_06             106
#define STR_NURB_07             107
#define STR_NURB_08             108
#define STR_NURB_09             109
#define STR_NURB_10             110
#define STR_NURB_11             111
#define STR_NURB_12             112
#define STR_NURB_13             113
#define STR_NURB_14             114
#define STR_NURB_15             115
#define STR_NURB_16             116
#define STR_NURB_17             117
#define STR_NURB_18             118
#define STR_NURB_19             119
#define STR_NURB_20             120
#define STR_NURB_21             121
#define STR_NURB_22             122
#define STR_NURB_23             123
#define STR_NURB_24             124
#define STR_NURB_25             125
#define STR_NURB_26             126
#define STR_NURB_27             127
#define STR_NURB_28             128
#define STR_NURB_29             129
#define STR_NURB_30             130
#define STR_NURB_31             131
#define STR_NURB_32             132
#define STR_NURB_33             133
#define STR_NURB_34             134
#define STR_NURB_35             135
#define STR_NURB_36             136
#define STR_NURB_37             137

extern char *pszGetResourceStringA(HINSTANCE hMod, UINT uiID);
extern WCHAR *pwszGetResourceStringW(HINSTANCE hMod, UINT uiID);
extern VOID vInitGluStrings(HINSTANCE hMod, BOOL bAnsi);
extern VOID vInitNurbStrings(HINSTANCE hMod, BOOL bAnsi);
extern VOID vInitTessStrings(HINSTANCE hMod, BOOL bAnsi);

#endif //_GLSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\test\tcallarr.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <GL/gls.h>
#include <stdlib.h>

#if __GLS_PLATFORM_WIN32
    #include <fcntl.h>
    #include <io.h>
    #define __MAIN_LINKAGE __cdecl
#else /* !__GLS_PLATFORM_WIN32 */
    #define __MAIN_LINKAGE
#endif /* __GLS_PLATFORM_WIN32 */

static void configStdio(void) {
    setbuf(stdout, GLS_NONE);
    #if __GLS_PLATFORM_WIN32
        _setmode(_fileno(stdout), _O_BINARY);
        _setmode(_fileno(stderr), _O_BINARY);
    #endif /* __GLS_PLATFORM_WIN32 */
}

GLint __MAIN_LINKAGE main(const GLsizei inArgc, const GLubyte *inArgv[]) {
    GLubyte *array;
    size_t count;
    GLSenum streamType;

    configStdio();
    if (inArgc != 2) {
        fprintf(stderr, "usage: %s <streamName>\n", inArgv[0]);
        exit(EXIT_FAILURE);
    }
    glsContext(glsGenContext());
    streamType = glsGetStreamType(inArgv[1]);
    if (!streamType) {
        fprintf(stderr, "%s: invalid stream %s\n", inArgv[0], inArgv[1]);
        exit(EXIT_FAILURE);
    }
    count = glsGetStreamSize(inArgv[1]);
    if (!count) {
        fprintf(
            stderr,
            "%s: could not determine size of stream %s\n",
            inArgv[0],
            inArgv[1]
        );
        exit(EXIT_FAILURE);
    }
    array = (GLubyte *)malloc(count);
    if (!array) {
        fprintf(stderr, "%s: malloc(%u) failed\n", inArgv[0], count);
        exit(EXIT_FAILURE);
    }
    fread(array, 1, count, fopen((const char *)inArgv[1], "rb"));
    glsBeginCapture(glsCSTR(""), GLS_TEXT, GLS_NONE);
    glsCallArray(streamType, count, array);
    glsEndCapture();
    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\arc.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/arc.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;













struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};





struct Mapdesc;



struct BezierArc;



struct BezierArc {	

char __W3__9PooledObj ;

REAL *cpts__9BezierArc ;
int order__9BezierArc ;
int stride__9BezierArc ;
long type__9BezierArc ;
struct Mapdesc *mapdesc__9BezierArc ;
};






extern int __glbezier_tag__3Arc ;

int __glbezier_tag__3Arc = 8192;
extern int __glarc_tag__3Arc ;

int __glarc_tag__3Arc = 8;
extern int __gltail_tag__3Arc ;

int __gltail_tag__3Arc = 64;


extern struct __mptr* __ptbl_vec_____core_arc_c___makeSide_[];

void __glmakeSide__3ArcFP6PwlArc8ar0 (struct Arc *__0this , struct PwlArc *__1pwl , int __1side )
{ 
((void )0 );
((void )0 );
((void )0 );
((void )0 );
__0this -> pwlArc__3Arc = __1pwl ;
( (__0this -> type__3Arc &= (~ 8192))) ;
( ( (__0this -> type__3Arc &= -1793)) , (__0this -> type__3Arc |= ((((long )__1side ))<< 8 ))) ;
}

int __glnumpts__3ArcFv (struct Arc *__0this )
{ 
Arc_ptr __1jarc ;
int __1npts ;

__1jarc = (struct Arc *)__0this ;
__1npts = 0 ;
do { 
__1npts += __1jarc -> pwlArc__3Arc -> npts__6PwlArc ;
__1jarc = __1jarc -> next__3Arc ;
}
while (__1jarc != (struct Arc *)__0this );

return __1npts ;
}

void __glmarkverts__3ArcFv (struct Arc *__0this )
{ 
Arc_ptr __1jarc ;

__1jarc = (struct Arc *)__0this ;

do { 
struct TrimVertex *__2p ;

__2p = __1jarc -> pwlArc__3Arc -> pts__6PwlArc ;
{ { int __2i ;

__2i = 0 ;

for(;__2i < __1jarc -> pwlArc__3Arc -> npts__6PwlArc ;__2i ++ ) 
(__2p [__2i ]). nuid__10TrimVertex = __1jarc -> nuid__3Arc ;
__1jarc = __1jarc -> next__3Arc ;

}

}
}
while (__1jarc != (struct Arc *)__0this );

}


void __glgetextrema__3ArcFPP3Arc (struct Arc *__0this , Arc_ptr *__1extrema )
{ 
REAL __1leftpt ;

REAL __1botpt ;

REAL __1rightpt ;

REAL __1toppt ;

(__1extrema [0 ])= ((__1extrema [1 ])= ((__1extrema [2 ])= ((__1extrema [3 ])= (struct Arc *)__0this )));

__1leftpt = (__1rightpt = (( (((REAL *)(__0this -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ]));
__1botpt = (__1toppt = (( (((REAL *)(__0this -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ]));

{ { Arc_ptr __1jarc ;

__1jarc = __0this -> next__3Arc ;

for(;__1jarc != (struct Arc *)__0this ;__1jarc = __1jarc -> next__3Arc ) { 
if ((( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])<=
__1leftpt ){ 
__1leftpt = (__1jarc -> pwlArc__3Arc -> pts__6PwlArc -> param__10TrimVertex [0 ]);
(__1extrema [1 ])= __1jarc ;
}
if ((( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])>= __1rightpt ){ 
__1rightpt = (__1jarc -> pwlArc__3Arc -> pts__6PwlArc -> param__10TrimVertex [0 ]);

(__1extrema [3 ])= __1jarc ;
}
if ((( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])<= __1botpt ){ 
__1botpt = (__1jarc -> pwlArc__3Arc -> pts__6PwlArc -> param__10TrimVertex [1 ]);

(__1extrema [2 ])= __1jarc ;
}
if ((( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])>= __1toppt ){ 
__1toppt = (__1jarc -> pwlArc__3Arc -> pts__6PwlArc -> param__10TrimVertex [1 ]);

(__1extrema [0 ])= __1jarc ;
}
}

}

}
}

void __glshow__3ArcFv (struct Arc *__0this )
{ 
}

void __glprint__3ArcFv (struct Arc *__0this )
{ 
Arc_ptr __1jarc ;

__1jarc = (struct Arc *)__0this ;

if (! __0this ){ 
return ;
}

do { 
__glshow__3ArcFv ( (struct Arc *)__1jarc ) ;
__1jarc = __1jarc -> next__3Arc ;
}
while (__1jarc != (struct Arc *)__0this );

}



int __glisDisconnected__3ArcFv (struct Arc *__0this )
{ 
if (__0this -> pwlArc__3Arc == 0 )return 0 ;
if (__0this -> prev__3Arc -> pwlArc__3Arc == 0 )return 0 ;

{ REAL *__1p0 ;
REAL *__1p1 ;

struct Arc *__0__X5 ;

__1p0 = ( (((REAL *)(__0this -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ;
__1p1 = ( (__0__X5 = (struct Arc *)__0this -> prev__3Arc ), ( (((REAL *)(__0__X5 -> pwlArc__3Arc -> pts__6PwlArc [(__0__X5 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]). param__10TrimVertex )))
) ;

if ((((((__1p0 [0 ])- (__1p1 [0 ]))> 0.000001 )|| (((__1p1 [0 ])- (__1p0 [0 ]))> 0.000001 ))|| (((__1p0 [1 ])- (__1p1 [1 ]))> 0.000001 ))|| (((__1p1 [1 ])- (__1p0 [1 ]))> 0.000001 ))
{ 
return
1 ;
}
else 
{ 
(__1p0 [0 ])= ((__1p1 [0 ])= (((__1p1 [0 ])+ (__1p0 [0 ]))* 0.5 ));
(__1p0 [1 ])= ((__1p1 [1 ])= (((__1p1 [1 ])+ (__1p0 [1 ]))* 0.5 ));
return 0 ;
}

}
}










int __glcheck__3ArcFv (struct Arc *__0this )
{ 
if (__0this == 0 )return 1 ;
{ Arc_ptr __1jarc ;

__1jarc = (struct Arc *)__0this ;
do { 
((void )0 );

if ((__1jarc -> prev__3Arc == 0 )|| (__1jarc -> next__3Arc == 0 )){ 
return 0 ;
}

if (__1jarc -> next__3Arc -> prev__3Arc != __1jarc ){ 
return 0 ;
}

if (__1jarc -> pwlArc__3Arc ){ 
if (__1jarc -> prev__3Arc -> pwlArc__3Arc ){ 
struct Arc *__0__X6 ;

struct Arc *__0__X7 ;

if ((( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])!= (( (__0__X6 = (struct Arc *)__1jarc -> prev__3Arc ), (
(((REAL *)(__0__X6 -> pwlArc__3Arc -> pts__6PwlArc [(__0__X6 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]). param__10TrimVertex ))) ) [1 ])){ 
return 0 ;
}
if ((( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])!= (( (__0__X7 = (struct Arc *)__1jarc -> prev__3Arc ), (
(((REAL *)(__0__X7 -> pwlArc__3Arc -> pts__6PwlArc [(__0__X7 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]). param__10TrimVertex ))) ) [0 ])){ 
return 0 ;
}
}
if (__1jarc -> next__3Arc -> pwlArc__3Arc ){ 
struct Arc *__0__X8 ;

struct Arc *__0__X9 ;

if ((( (__0__X8 = (struct Arc *)__1jarc -> next__3Arc ), ( (((REAL *)(__0__X8 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ])!= ((
(((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [(((struct Arc *)__1jarc )-> pwlArc__3Arc -> npts__6PwlArc - 1 )]). param__10TrimVertex ))) [0 ])){ 
return 0 ;
}
if ((( (__0__X9 = (struct Arc *)__1jarc -> next__3Arc ), ( (((REAL *)(__0__X9 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])!= ((
(((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [(((struct Arc *)__1jarc )-> pwlArc__3Arc -> npts__6PwlArc - 1 )]). param__10TrimVertex ))) [1 ])){ 
return 0 ;
}
}
if (( (((struct Arc *)__1jarc )-> type__3Arc & 8192)) ){ 
((void )0 );
((void )0 );
}
}
__1jarc = __1jarc -> next__3Arc ;
}
while (__1jarc != (struct Arc *)__0this );

return 1 ;

}
}


Arc_ptr __glappend__3ArcFP3Arc (struct Arc *__0this , Arc_ptr __1jarc )
{ 
if (__1jarc != 0 ){ 
__0this -> next__3Arc = __1jarc -> next__3Arc ;
__0this -> prev__3Arc = __1jarc ;
__0this -> next__3Arc -> prev__3Arc = (__0this -> prev__3Arc -> next__3Arc = (struct Arc *)__0this );
}
else 
{ 
__0this -> next__3Arc = (__0this -> prev__3Arc = (struct Arc *)__0this );
}
return (struct Arc *)__0this ;
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\arcsorte.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/arcsorter.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };







typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;












struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};


struct Subdivider;

struct ArcSorter;

struct ArcSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;

struct Subdivider *subdivider__9ArcSorter ;
};
struct ArcSdirSorter;

struct ArcSdirSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;

struct Subdivider *subdivider__9ArcSorter ;
};
struct ArcTdirSorter;

struct ArcTdirSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;

struct Subdivider *subdivider__9ArcSorter ;
};





struct JumpBuffer;







struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};







struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};



struct Sorter *__gl__ct__6SorterFi (struct Sorter *, int );
extern struct __mptr* __gl__ptbl_vec_____core_arcsor0[];


struct ArcSorter *__gl__ct__9ArcSorterFR10Subdiv0 (struct ArcSorter *__0this , struct Subdivider *__1s )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct ArcSorter *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct ArcSorter))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))(
( (__0this = (struct ArcSorter *)__gl__ct__6SorterFi ( ((struct Sorter *)__0this ), (int )(sizeof (struct Arc **))) ), (__0this -> __vptr__6Sorter = (struct
__mptr *) __gl__ptbl_vec_____core_arcsor0[0])) , (__0this -> subdivider__9ArcSorter = __1s )) ;
return __0this ;

}


int __glqscmp__9ArcSorterFPcT1 (struct ArcSorter *__0this , char *__1__A16 , char *__1__A17 )
{ 
( 0 ) ;
return 0 ;
}

void __glqsort__9ArcSorterFPP3Arci (struct ArcSorter *, struct Arc **, int );

void __glqsort__6SorterFPvi (struct Sorter *, void *, int );

void __glqsort__9ArcSorterFPP3Arci (struct ArcSorter *__0this , struct Arc **__1a , int __1n )
{ 
__glqsort__6SorterFPvi ( (struct Sorter *)__0this , ((void *)__1a ), __1n ) ;

}

void __glqsexc__9ArcSorterFPcT1 (struct ArcSorter *__0this , char *__1i , char *__1j )
{ 
struct Arc **__1jarc1 ;
struct Arc **__1jarc2 ;
struct Arc *__1tmp ;

__1jarc1 = (((struct Arc **)__1i ));
__1jarc2 = (((struct Arc **)__1j ));
__1tmp = ((*__1jarc1 ));
((*__1jarc1 ))= ((*__1jarc2 ));
((*__1jarc2 ))= __1tmp ;
}

void __glqstexc__9ArcSorterFPcN21 (struct ArcSorter *__0this , char *__1i , char *__1j , char *__1k )
{ 
struct Arc **__1jarc1 ;
struct Arc **__1jarc2 ;
struct Arc **__1jarc3 ;
struct Arc *__1tmp ;

__1jarc1 = (((struct Arc **)__1i ));
__1jarc2 = (((struct Arc **)__1j ));
__1jarc3 = (((struct Arc **)__1k ));
__1tmp = ((*__1jarc1 ));
((*__1jarc1 ))= ((*__1jarc3 ));
((*__1jarc3 ))= ((*__1jarc2 ));
((*__1jarc2 ))= __1tmp ;
}


struct ArcSdirSorter *__gl__ct__13ArcSdirSorterFR10S0 (struct ArcSdirSorter *__0this , struct Subdivider *__1s )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct ArcSdirSorter *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct ArcSdirSorter))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))(
(__0this = (struct ArcSdirSorter *)__gl__ct__9ArcSorterFR10Subdiv0 ( ((struct ArcSorter *)__0this ), __1s ) ), (__0this -> __vptr__6Sorter = (struct __mptr *) __gl__ptbl_vec_____core_arcsor0[1])) ;
return __0this ;

}



int __glccwTurn_sl__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);
int __glccwTurn_sr__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);


int __glqscmp__13ArcSdirSorterFPcT0 (struct ArcSdirSorter *__0this , char *__1i , char *__1j )
{ 
struct Arc *__1jarc1 ;
struct Arc *__1jarc2 ;

int __1v1 ;
int __1v2 ;

REAL __1diff ;

__1jarc1 = ((*(((struct Arc **)__1i ))));
__1jarc2 = ((*(((struct Arc **)__1j ))));

__1v1 = (( (((int )(((struct Arc *)__1jarc1 )-> type__3Arc & __gltail_tag__3Arc )))) ?0 :(__1jarc1 -> pwlArc__3Arc -> npts__6PwlArc - 1 ));
__1v2 = (( (((int )(((struct Arc *)__1jarc2 )-> type__3Arc & __gltail_tag__3Arc )))) ?0 :(__1jarc2 -> pwlArc__3Arc -> npts__6PwlArc - 1 ));

__1diff = (((__1jarc1 -> pwlArc__3Arc -> pts__6PwlArc [__1v1 ]). param__10TrimVertex [1 ])- ((__1jarc2 -> pwlArc__3Arc -> pts__6PwlArc [__1v2 ]). param__10TrimVertex [1 ]));

if (__1diff < 0.0 )
return -1;
else if (__1diff > 0.0 )
return 1 ;
else { 
if (__1v1 == 0 ){ 
if ((( (((REAL *)(((struct Arc *)__1jarc2 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])< ((
(((REAL *)(((struct Arc *)__1jarc1 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])){ 
return (__glccwTurn_sl__10SubdividerFP0 ( (struct Subdivider *)__0this -> subdivider__9ArcSorter , __1jarc2 , __1jarc1 ) ?1 :-1);

}
else 
{ 
return (__glccwTurn_sr__10SubdividerFP0 ( (struct Subdivider *)__0this -> subdivider__9ArcSorter , __1jarc2 , __1jarc1 ) ?-1:1 );
}
}
else 
{ 
if ((( (((REAL *)(((struct Arc *)__1jarc2 )-> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])< (( (((REAL *)(((struct Arc *)__1jarc1 )->
next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])){ 
return (__glccwTurn_sl__10SubdividerFP0 ( (struct Subdivider *)__0this -> subdivider__9ArcSorter , __1jarc1 , __1jarc2 ) ?-1:1 );
}
else 
{ 
return (__glccwTurn_sr__10SubdividerFP0 ( (struct Subdivider *)__0this -> subdivider__9ArcSorter , __1jarc1 , __1jarc2 ) ?1 :-1);
}
}
}
}


struct ArcTdirSorter *__gl__ct__13ArcTdirSorterFR10S0 (struct ArcTdirSorter *__0this , struct Subdivider *__1s )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct ArcTdirSorter *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct ArcTdirSorter))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))(
(__0this = (struct ArcTdirSorter *)__gl__ct__9ArcSorterFR10Subdiv0 ( ((struct ArcSorter *)__0this ), __1s ) ), (__0this -> __vptr__6Sorter = (struct __mptr *) __gl__ptbl_vec_____core_arcsor0[2])) ;
return __0this ;

}



int __glccwTurn_tl__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);
int __glccwTurn_tr__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);


int __glqscmp__13ArcTdirSorterFPcT0 (struct ArcTdirSorter *__0this , char *__1i , char *__1j )
{ 
struct Arc *__1jarc1 ;
struct Arc *__1jarc2 ;

int __1v1 ;
int __1v2 ;

REAL __1diff ;

__1jarc1 = ((*(((struct Arc **)__1i ))));
__1jarc2 = ((*(((struct Arc **)__1j ))));

__1v1 = (( (((int )(((struct Arc *)__1jarc1 )-> type__3Arc & __gltail_tag__3Arc )))) ?0 :(__1jarc1 -> pwlArc__3Arc -> npts__6PwlArc - 1 ));
__1v2 = (( (((int )(((struct Arc *)__1jarc2 )-> type__3Arc & __gltail_tag__3Arc )))) ?0 :(__1jarc2 -> pwlArc__3Arc -> npts__6PwlArc - 1 ));

__1diff = (((__1jarc1 -> pwlArc__3Arc -> pts__6PwlArc [__1v1 ]). param__10TrimVertex [0 ])- ((__1jarc2 -> pwlArc__3Arc -> pts__6PwlArc [__1v2 ]). param__10TrimVertex [0 ]));

if (__1diff < 0.0 )
return 1 ;
else if (__1diff > 0.0 )
return -1;
else { 
if (__1v1 == 0 ){ 
if ((( (((REAL *)(((struct Arc *)__1jarc2 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])< ((
(((REAL *)(((struct Arc *)__1jarc1 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])){ 
return (__glccwTurn_tl__10SubdividerFP0 ( (struct Subdivider *)__0this -> subdivider__9ArcSorter , __1jarc2 , __1jarc1 ) ?1 :-1);

}
else 
{ 
return (__glccwTurn_tr__10SubdividerFP0 ( (struct Subdivider *)__0this -> subdivider__9ArcSorter , __1jarc2 , __1jarc1 ) ?-1:1 );
}
}
else 
{ 
if ((( (((REAL *)(((struct Arc *)__1jarc2 )-> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])< (( (((REAL *)(((struct Arc *)__1jarc1 )->
next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])){ 
return (__glccwTurn_tl__10SubdividerFP0 ( (struct Subdivider *)__0this -> subdivider__9ArcSorter , __1jarc1 , __1jarc2 ) ?-1:1 );
}
else 
{ 
return (__glccwTurn_tr__10SubdividerFP0 ( (struct Subdivider *)__0this -> subdivider__9ArcSorter , __1jarc1 , __1jarc2 ) ?1 :-1);
}
}
}
}
struct __mptr __gl__vtbl__13ArcTdirSorter[] = {0,0,0,
0,0,(__vptp)__glqscmp__13ArcTdirSorterFPcT0 ,
0,0,(__vptp)__glqsexc__9ArcSorterFPcT1 ,
0,0,(__vptp)__glqstexc__9ArcSorterFPcN21 ,
0,0,0};
struct __mptr __gl__vtbl__13ArcSdirSorter[] = {0,0,0,
0,0,(__vptp)__glqscmp__13ArcSdirSorterFPcT0 ,
0,0,(__vptp)__glqsexc__9ArcSorterFPcT1 ,
0,0,(__vptp)__glqstexc__9ArcSorterFPcN21 ,
0,0,0};
struct __mptr __gl__vtbl__9ArcSorter[] = {0,0,0,
0,0,(__vptp)__glqscmp__9ArcSorterFPcT1 ,
0,0,(__vptp)__glqsexc__9ArcSorterFPcT1 ,
0,0,(__vptp)__glqstexc__9ArcSorterFPcN21 ,
0,0,0};
struct __mptr* __gl__ptbl_vec_____core_arcsor0[] = {
__gl__vtbl__9ArcSorter,
__gl__vtbl__13ArcSdirSorter,
__gl__vtbl__13ArcTdirSorter,

};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\basiccrv.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/basiccrveval.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };








typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;








struct CachingEvaluator;
enum __Q2_16CachingEvaluator11ServiceMode { play__Q2_16CachingEvaluator11ServiceMode = 0, record__Q2_16CachingEvaluator11ServiceMode = 1, playAndRecord__Q2_16CachingEvaluator11ServiceMode = 2} ;

struct CachingEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

extern void *__nw__FUi (unsigned int );


struct BasicCurveEvaluator;


struct BasicCurveEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};


extern struct __mptr* __ptbl_vec_____core_basiccrveval_c___domain1f_[];

void __gldomain1f__19BasicCurveEval0 (struct BasicCurveEvaluator *__0this , REAL __1__A5 , REAL __1__A6 )
{ 
}

void __glrange1f__19BasicCurveEvalu0 (struct BasicCurveEvaluator *__0this , long __1type , REAL *__1__A7 , REAL *__1__A8 )
{ 
}

void __glenable__19BasicCurveEvalua0 (struct
BasicCurveEvaluator *__0this , long __1__A9 )
{ 
}

void __gldisable__19BasicCurveEvalu0 (struct BasicCurveEvaluator *__0this , long __1__A10 )
{ 
}

void __glbgnmap1f__19BasicCurveEval0 (struct BasicCurveEvaluator *__0this , long __1__A11 )
{ 
}

void
__glmap1f__19BasicCurveEvaluat0 (struct BasicCurveEvaluator *__0this , long __1__A12 , REAL __1__A13 , REAL __1__A14 , long __1__A15 , long __1__A16 , REAL *__1__A17 )
{ 
}

void __glmapgrid1f__19BasicCurveEva0 (struct BasicCurveEvaluator *__0this ,
long __1__A18 , REAL __1__A19 , REAL __1__A20 )
{ 
}

void __glmapmesh1f__19BasicCurveEva0 (struct BasicCurveEvaluator *__0this , long __1__A21 , long __1__A22 , long __1__A23 )
{ 
}

void
__glevalcoord1f__19BasicCurveE0 (struct BasicCurveEvaluator *__0this , long __1__A24 , REAL __1__A25 )
{ 
}

void __glendmap1f__19BasicCurveEval0 (struct BasicCurveEvaluator *__0this )
{ 
}

void __glbgnline__19BasicCurveEvalu0 (struct BasicCurveEvaluator *__0this )
{ 
}

void __glendline__19BasicCurveEvalu0 (struct BasicCurveEvaluator *__0this )
{

}
int __glcanRecord__16CachingEvalua0 (struct CachingEvaluator *);
int __glcanPlayAndRecord__16Cachin0 (struct CachingEvaluator *);
int __glcreateHandle__16CachingEva0 (struct CachingEvaluator *, int );
void __glbeginOutput__16CachingEval0 (struct CachingEvaluator *, int , int );
void __glendOutput__16CachingEvalua0 (struct CachingEvaluator *);
void __gldiscardRecording__16Cachin0 (struct CachingEvaluator *, int );
void __glplayRecording__16CachingEv0 (struct CachingEvaluator *, int );
struct __mptr __gl__vtbl__19BasicCurveEvalua0[] = {0,0,0,
0,0,(__vptp)__glcanRecord__16CachingEvalua0 ,
0,0,(__vptp)__glcanPlayAndRecord__16Cachin0 ,
0,0,(__vptp)__glcreateHandle__16CachingEva0 ,
0,0,(__vptp)__glbeginOutput__16CachingEval0 ,
0,0,(__vptp)__glendOutput__16CachingEvalua0 ,
0,0,(__vptp)__gldiscardRecording__16Cachin0 ,
0,0,(__vptp)__glplayRecording__16CachingEv0 ,
0,0,(__vptp)__gldomain1f__19BasicCurveEval0 ,
0,0,(__vptp)__glrange1f__19BasicCurveEvalu0 ,
0,0,(__vptp)__glenable__19BasicCurveEvalua0 ,
0,0,(__vptp)__gldisable__19BasicCurveEvalu0 ,
0,0,(__vptp)__glbgnmap1f__19BasicCurveEval0 ,
0,0,(__vptp)__glmap1f__19BasicCurveEvaluat0 ,
0,0,(__vptp)__glmapgrid1f__19BasicCurveEva0 ,
0,0,(__vptp)__glmapmesh1f__19BasicCurveEva0 ,
0,0,(__vptp)__glevalcoord1f__19BasicCurveE0 ,
0,0,(__vptp)__glendmap1f__19BasicCurveEval0 ,
0,0,(__vptp)__glbgnline__19BasicCurveEvalu0 ,
0,0,(__vptp)__glendline__19BasicCurveEvalu0 ,
0,0,0};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\basicsur.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/basicsurfeval.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };








typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;








struct CachingEvaluator;
enum __Q2_16CachingEvaluator11ServiceMode { play__Q2_16CachingEvaluator11ServiceMode = 0, record__Q2_16CachingEvaluator11ServiceMode = 1, playAndRecord__Q2_16CachingEvaluator11ServiceMode = 2} ;

struct CachingEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

extern void *__nw__FUi (unsigned int );


struct BasicSurfaceEvaluator;


struct BasicSurfaceEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};


extern struct __mptr* __ptbl_vec_____core_basicsurfeval_c___domain2f_[];

void __gldomain2f__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *__0this , REAL __1__A5 , REAL __1__A6 , REAL __1__A7 , REAL __1__A8 )
{ 
}

void __glpolymode__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *__0this , long __1__A9 )
{ 
}

void __glrange2f__21BasicSurfaceEva0 (struct
BasicSurfaceEvaluator *__0this , long __1type , REAL *__1from , REAL *__1to )
{ 
}

void __glenable__21BasicSurfaceEval0 (struct BasicSurfaceEvaluator *__0this , long __1__A10 )
{ 
}

void __gldisable__21BasicSurfaceEva0 (struct BasicSurfaceEvaluator *__0this , long
__1__A11 )
{ 
}

void __glbgnmap2f__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *__0this , long __1__A12 )
{ 
}

void __glendmap2f__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *__0this )
{ 
}

void __glmap2f__21BasicSurfaceEvalu0 (struct BasicSurfaceEvaluator *__0this , long __1__A13 ,
REAL __1__A14 , REAL __1__A15 , long __1__A16 , long __1__A17 , 
REAL __1__A18 , REAL __1__A19 , long __1__A20 , long __1__A21 , 
REAL *__1__A22 )
{ 
}

void
__glmapgrid2f__21BasicSurfaceE0 (struct BasicSurfaceEvaluator *__0this , long __1__A23 , REAL __1__A24 , REAL __1__A25 , long __1__A26 , REAL __1__A27 , REAL __1__A28 )
{ 
}

void __glmapmesh2f__21BasicSurfaceE0 (struct BasicSurfaceEvaluator *__0this , long
__1__A29 , long __1__A30 , long __1__A31 , long __1__A32 , long __1__A33 )
{ 
}

void __glevalcoord2f__21BasicSurfac0 (struct BasicSurfaceEvaluator *__0this , long __1__A34 ,
REAL __1__A35 , REAL __1__A36 )
{ 
}

void __glevalpoint2i__21BasicSurfac0 (struct BasicSurfaceEvaluator *__0this , long __1__A37 , long __1__A38 )
{ 
}

void __glbgnline__21BasicSurfaceEva0 (struct BasicSurfaceEvaluator *__0this )
{ 
}

void __glendline__21BasicSurfaceEva0 (struct
BasicSurfaceEvaluator *__0this )
{ 
}

void __glbgnclosedline__21BasicSurf0 (struct BasicSurfaceEvaluator *__0this )
{ 
}

void __glendclosedline__21BasicSurf0 (struct BasicSurfaceEvaluator *__0this )
{ 
}

void __glbgntmesh__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *__0this )
{ 
}

void __glswaptmesh__21BasicSurfaceE0 (struct BasicSurfaceEvaluator *__0this )
{ 
}

void
__glendtmesh__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *__0this )
{ 
}

void __glbgnqstrip__21BasicSurfaceE0 (struct BasicSurfaceEvaluator *__0this )
{ 
}

void __glendqstrip__21BasicSurfaceE0 (struct BasicSurfaceEvaluator *__0this )
{ 
}
int __glcanRecord__16CachingEvalua0 (struct CachingEvaluator *);
int __glcanPlayAndRecord__16Cachin0 (struct CachingEvaluator *);
int __glcreateHandle__16CachingEva0 (struct CachingEvaluator *, int );
void __glbeginOutput__16CachingEval0 (struct CachingEvaluator *, int , int );
void __glendOutput__16CachingEvalua0 (struct CachingEvaluator *);
void __gldiscardRecording__16Cachin0 (struct CachingEvaluator *, int );
void __glplayRecording__16CachingEv0 (struct CachingEvaluator *, int );
struct __mptr __gl__vtbl__21BasicSurfaceEval0[] = {0,0,0,
0,0,(__vptp)__glcanRecord__16CachingEvalua0 ,
0,0,(__vptp)__glcanPlayAndRecord__16Cachin0 ,
0,0,(__vptp)__glcreateHandle__16CachingEva0 ,
0,0,(__vptp)__glbeginOutput__16CachingEval0 ,
0,0,(__vptp)__glendOutput__16CachingEvalua0 ,
0,0,(__vptp)__gldiscardRecording__16Cachin0 ,
0,0,(__vptp)__glplayRecording__16CachingEv0 ,
0,0,(__vptp)__glrange2f__21BasicSurfaceEva0 ,
0,0,(__vptp)__gldomain2f__21BasicSurfaceEv0 ,
0,0,(__vptp)__glenable__21BasicSurfaceEval0 ,
0,0,(__vptp)__gldisable__21BasicSurfaceEva0 ,
0,0,(__vptp)__glbgnmap2f__21BasicSurfaceEv0 ,
0,0,(__vptp)__glmap2f__21BasicSurfaceEvalu0 ,
0,0,(__vptp)__glmapgrid2f__21BasicSurfaceE0 ,
0,0,(__vptp)__glmapmesh2f__21BasicSurfaceE0 ,
0,0,(__vptp)__glevalcoord2f__21BasicSurfac0 ,
0,0,(__vptp)__glevalpoint2i__21BasicSurfac0 ,
0,0,(__vptp)__glendmap2f__21BasicSurfaceEv0 ,
0,0,(__vptp)__glpolymode__21BasicSurfaceEv0 ,
0,0,(__vptp)__glbgnline__21BasicSurfaceEva0 ,
0,0,(__vptp)__glendline__21BasicSurfaceEva0 ,
0,0,(__vptp)__glbgnclosedline__21BasicSurf0 ,
0,0,(__vptp)__glendclosedline__21BasicSurf0 ,
0,0,(__vptp)__glbgntmesh__21BasicSurfaceEv0 ,
0,0,(__vptp)__glswaptmesh__21BasicSurfaceE0 ,
0,0,(__vptp)__glendtmesh__21BasicSurfaceEv0 ,
0,0,(__vptp)__glbgnqstrip__21BasicSurfaceE0 ,
0,0,(__vptp)__glendqstrip__21BasicSurfaceE0 ,
0,0,0};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\bin.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/bin.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);










struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};



extern struct __mptr* __ptbl_vec_____core_bin_c_____ct_[];


struct Bin *__gl__ct__3BinFv (struct Bin *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Bin *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Bin))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))
__0this ->
head__3Bin = 0 ;
return __0this ;

}


void __gl__dt__3BinFv (struct Bin *__0this , 
int __0__free )
{ if (__0this ){ 
((void )0 );
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}

void __glremove_this_arc__3BinFP3Ar0 (struct Bin *__0this , Arc_ptr __1arc )
{ 
{ { Arc_ptr *__1j ;

__1j = (& __0this -> head__3Bin );

for(;(((*__1j ))!= 0 )&& (((*__1j ))!= __1arc );__1j = (& ((*__1j ))-> link__3Arc )) ;

if (((*__1j ))!= 0 ){ 
if (((*__1j ))== __0this -> current__3Bin )
__0this -> current__3Bin = ((*__1j ))-> link__3Arc ;
((*__1j ))= ((*__1j ))-> link__3Arc ;
}

}

}
}



int __glnumarcs__3BinFv (struct Bin *__0this )
{ 
long __1count ;

__1count = 0 ;
{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00munkaiee ;

__1jarc = ( (__0this -> current__3Bin = __0this -> head__3Bin ), ( (__1__Xjarc00munkaiee = __0this -> current__3Bin ), ( (__1__Xjarc00munkaiee ?( (__0this -> current__3Bin =
__1__Xjarc00munkaiee -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc00munkaiee ) ) ) ;

for(;__1jarc ;__1jarc = ( (__1__Xjarc00munkaiee = __0this -> current__3Bin ), ( (__1__Xjarc00munkaiee ?( (__0this -> current__3Bin = __1__Xjarc00munkaiee -> link__3Arc ), 0 ) :( 0 )
), __1__Xjarc00munkaiee ) ) ) 
__1count ++ ;
return (int )__1count ;

}

}
}

void __glmarkall__3BinFv (struct Bin *);




void __gladopt__3BinFv (struct Bin *__0this )
{ 
Arc_ptr __1orphan ;

struct Arc *__1__Xjarc00aynkaiee ;

__glmarkall__3BinFv ( __0this ) ;

;
while (__1orphan = ( (__1__Xjarc00aynkaiee = __0this -> head__3Bin ), ( (__1__Xjarc00aynkaiee ?( (__0this -> head__3Bin = __1__Xjarc00aynkaiee -> link__3Arc ), 0 ) :(
0 ) ), __1__Xjarc00aynkaiee ) ) ){ 
{ { Arc_ptr __2parent ;

__2parent = __1orphan -> next__3Arc ;

for(;__2parent != __1orphan ;__2parent = __2parent -> next__3Arc ) { 
if (! ( (((struct Arc *)__2parent )-> type__3Arc & __glarc_tag__3Arc )) ){ 
__1orphan ->
link__3Arc = __2parent -> link__3Arc ;
__2parent -> link__3Arc = __1orphan ;
( (((struct Arc *)__1orphan )-> type__3Arc &= (~ __glarc_tag__3Arc ))) ;
break ;
}
}

}

}
}
}

void __glshow__3BinFPc (struct Bin *__0this , char *__1name )
{ 
}




void __glmarkall__3BinFv (struct Bin *__0this )
{ 
{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00munkaiee ;

__1jarc = ( (__0this -> current__3Bin = __0this -> head__3Bin ), ( (__1__Xjarc00munkaiee = __0this -> current__3Bin ), ( (__1__Xjarc00munkaiee ?( (__0this -> current__3Bin =
__1__Xjarc00munkaiee -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc00munkaiee ) ) ) ;

for(;__1jarc ;__1jarc = ( (__1__Xjarc00munkaiee = __0this -> current__3Bin ), ( (__1__Xjarc00munkaiee ?( (__0this -> current__3Bin = __1__Xjarc00munkaiee -> link__3Arc ), 0 ) :( 0 )
), __1__Xjarc00munkaiee ) ) ) 
( (((struct Arc *)__1jarc )-> type__3Arc |= __glarc_tag__3Arc )) ;

}

}
}




void __gllistBezier__3BinFv (struct Bin *__0this )
{ 
{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00munkaiee ;

__1jarc = ( (__0this -> current__3Bin = __0this -> head__3Bin ), ( (__1__Xjarc00munkaiee = __0this -> current__3Bin ), ( (__1__Xjarc00munkaiee ?( (__0this -> current__3Bin =
__1__Xjarc00munkaiee -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc00munkaiee ) ) ) ;

for(;__1jarc ;__1jarc = ( (__1__Xjarc00munkaiee = __0this -> current__3Bin ), ( (__1__Xjarc00munkaiee ?( (__0this -> current__3Bin = __1__Xjarc00munkaiee -> link__3Arc ), 0 ) :( 0 )
), __1__Xjarc00munkaiee ) ) ) { 
if (( (((struct Arc *)__1jarc )-> type__3Arc & __glbezier_tag__3Arc )) ){ 
((void )0 );

{ struct TrimVertex *__3pts ;
REAL __3s1 ;
REAL __3t1 ;
REAL __3s2 ;
REAL __3t2 ;

__3pts = __1jarc -> pwlArc__3Arc -> pts__6PwlArc ;
__3s1 = ((__3pts [0 ]). param__10TrimVertex [0 ]);
__3t1 = ((__3pts [0 ]). param__10TrimVertex [1 ]);
__3s2 = ((__3pts [1 ]). param__10TrimVertex [0 ]);
__3t2 = ((__3pts [1 ]). param__10TrimVertex [1 ]);

}

}
}

}

}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\bufpool.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/bufpool.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);






struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};




extern struct __mptr* __ptbl_vec_____core_bufpool_c_____ct_[];


struct Pool *__gl__ct__4PoolFiT1Pc (struct Pool *__0this , int __1_buffersize , int __1initpoolsize , char *__1n )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Pool *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Pool))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> buffersize__4Pool = ((__1_buffersize < (sizeof (struct Buffer )))?(sizeof (struct Buffer )):(((unsigned int )__1_buffersize )));
__0this -> initsize__4Pool = (__1initpoolsize * __0this -> buffersize__4Pool );
__0this -> nextsize__4Pool = __0this -> initsize__4Pool ;
__0this -> name__4Pool = __1n ;
__0this -> magic__4Pool = 62369;
__0this -> nextblock__4Pool = 0 ;
__0this -> curblock__4Pool = 0 ;
__0this -> freelist__4Pool = 0 ;
__0this -> nextfree__4Pool = 0 ;
} return __0this ;

}


void __gl__dt__4PoolFv (struct Pool *__0this , 
int __0__free )
{ if (__0this ){ 
((void )0 );

while (__0this -> nextblock__4Pool ){ 
void *__1__X5 ;

( (__1__X5 = (void *)(__0this -> blocklist__4Pool [(-- __0this -> nextblock__4Pool )])), ( (__1__X5 ?( free ( __1__X5 ) , 0 ) :(
0 ) )) ) ;
(__0this -> blocklist__4Pool [__0this -> nextblock__4Pool ])= 0 ;
}
__0this -> magic__4Pool = 61858;
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}


void __glgrow__4PoolFv (struct Pool *__0this )
{ 
void *__1__Xp00uzigaiaa ;

((void )0 );
__0this -> curblock__4Pool = (((char *)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (char ))* __0this -> nextsize__4Pool )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void
*)__1__Xp00uzigaiaa )))) ));
(__0this -> blocklist__4Pool [(__0this -> nextblock__4Pool ++ )])= __0this -> curblock__4Pool ;
__0this -> nextfree__4Pool = __0this -> nextsize__4Pool ;
__0this -> nextsize__4Pool *= 2 ;
}


void __glclear__4PoolFv (struct Pool *__0this )
{ 
((void )0 );

while (__0this -> nextblock__4Pool ){ 
void *__1__X6 ;

( (__1__X6 = (void *)(__0this -> blocklist__4Pool [(-- __0this -> nextblock__4Pool )])), ( (__1__X6 ?( free ( __1__X6 ) , 0 ) :(
0 ) )) ) ;
(__0this -> blocklist__4Pool [__0this -> nextblock__4Pool ])= 0 ;
}
__0this -> curblock__4Pool = 0 ;
__0this -> freelist__4Pool = 0 ;
__0this -> nextfree__4Pool = 0 ;
if (__0this -> nextsize__4Pool > __0this -> initsize__4Pool )
__0this -> nextsize__4Pool /= 2 ;
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\arctess.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/arctess.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);












typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;





struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};









struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;








struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];






struct Mapdesc;



struct BezierArc;



struct BezierArc {	

char __W3__9PooledObj ;

REAL *cpts__9BezierArc ;
int order__9BezierArc ;
int stride__9BezierArc ;
long type__9BezierArc ;
struct Mapdesc *mapdesc__9BezierArc ;
};





struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};


extern struct __mptr* __ptbl_vec_____core_arctess_c_____ct_[];


struct ArcTessellator *__gl__ct__14ArcTessellatorFR140 (struct ArcTessellator *__0this , struct TrimVertexPool *__1t , struct Pool *__1p )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct ArcTessellator *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct ArcTessellator))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))(
(__0this -> pwlarcpool__14ArcTessellator = __1p ), (__0this -> trimvertexpool__14ArcTessellator = __1t )) ;
return __0this ;

}


void __gl__dt__14ArcTessellatorFv (struct ArcTessellator *__0this , 
int __0__free )
{ if (__0this )
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void
*)__0this )) , 0 ) :( 0 ) )) ;

}

struct TrimVertex *__glget__14TrimVertexPoolFi (struct TrimVertexPool *, int );




void __glbezier__14ArcTessellatorFP0 (struct ArcTessellator *__0this , struct Arc *__1arc , REAL __1s1 , REAL __1s2 , REAL __1t1 , REAL __1t2 )
{ 
((void )0 );
((void )0 );

{ struct TrimVertex *__1p ;

struct PwlArc *__0__X5 ;

void *__1__Xbuffer00eohgaiaa ;

__1p = __glget__14TrimVertexPoolFi ( (struct TrimVertexPool *)__0this -> trimvertexpool__14ArcTessellator , 2 ) ;
__1arc -> pwlArc__3Arc = ((__0__X5 = (struct PwlArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ?(
( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ))), (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool = ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )) , 0 ) :( 0 ) ), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool -= ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> curblock__4Pool + ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool ))))) ) )
, 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct PwlArc *)__0__X5 )-> pts__6PwlArc = __1p ), ( (((struct
PwlArc *)__0__X5 )-> npts__6PwlArc = 2 ), ( (((struct PwlArc *)__0__X5 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X5 )))) ) ) :0 );
((__1p [0 ]). param__10TrimVertex [0 ])= __1s1 ;
((__1p [0 ]). param__10TrimVertex [1 ])= __1t1 ;
((__1p [1 ]). param__10TrimVertex [0 ])= __1s2 ;
((__1p [1 ]). param__10TrimVertex [1 ])= __1t2 ;
((void )0 );
( (((struct Arc *)__1arc )-> type__3Arc |= __glbezier_tag__3Arc )) ;

}
}

void __glmakeSide__3ArcFP6PwlArc8ar0 (struct Arc *, struct PwlArc *, int );



void __glpwl_left__14ArcTessellator0 (struct ArcTessellator *__0this , struct Arc *__1arc , REAL __1s , REAL __1t1 , REAL __1t2 , REAL __1rate )
{ 
((void )0 );
((void )0 );

{ int __1nsteps ;
REAL __1stepsize ;

struct TrimVertex *__1newvert ;

__1nsteps = (1 + (((int )((__1t1 - __1t2 )/ __1rate ))));
__1stepsize = ((__1t1 - __1t2 )/ (((float )__1nsteps )));

__1newvert = __glget__14TrimVertexPoolFi ( (struct TrimVertexPool *)__0this -> trimvertexpool__14ArcTessellator , __1nsteps + 1 ) ;
{ { int __1i ;

struct PwlArc *__0__X6 ;

void *__1__Xbuffer00eohgaiaa ;

__1i = __1nsteps ;

for(;__1i > 0 ;__1i -- ) { 
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t2 ;
__1t2 += __1stepsize ;
}
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t1 ;

__glmakeSide__3ArcFP6PwlArc8ar0 ( (struct Arc *)__1arc , (__0__X6 = (struct PwlArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ))), (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool = ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct
Pool *)__0this -> pwlarcpool__14ArcTessellator )) , 0 ) :( 0 ) ), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool -= ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> curblock__4Pool + ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool ))))) )
) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct PwlArc *)__0__X6 )-> pts__6PwlArc = __1newvert ), (
(((struct PwlArc *)__0__X6 )-> npts__6PwlArc = (__1nsteps + 1 )), ( (((struct PwlArc *)__0__X6 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X6 )))) ) )
:0 , 3) ;

}

}

}
}



void __glpwl_right__14ArcTessellato0 (struct ArcTessellator *__0this , struct Arc *__1arc , REAL __1s , REAL __1t1 , REAL __1t2 , REAL __1rate )
{ 
((void )0 );
((void )0 );

{ int __1nsteps ;
REAL __1stepsize ;

struct TrimVertex *__1newvert ;

__1nsteps = (1 + (((int )((__1t2 - __1t1 )/ __1rate ))));
__1stepsize = ((__1t2 - __1t1 )/ (((float )__1nsteps )));

__1newvert = __glget__14TrimVertexPoolFi ( (struct TrimVertexPool *)__0this -> trimvertexpool__14ArcTessellator , __1nsteps + 1 ) ;
{ { int __1i ;

struct PwlArc *__0__X7 ;

void *__1__Xbuffer00eohgaiaa ;

__1i = 0 ;

for(;__1i < __1nsteps ;__1i ++ ) { 
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t1 ;
__1t1 += __1stepsize ;
}
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t2 ;

__glmakeSide__3ArcFP6PwlArc8ar0 ( (struct Arc *)__1arc , (__0__X7 = (struct PwlArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ))), (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool = ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct
Pool *)__0this -> pwlarcpool__14ArcTessellator )) , 0 ) :( 0 ) ), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool -= ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> curblock__4Pool + ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool ))))) )
) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct PwlArc *)__0__X7 )-> pts__6PwlArc = __1newvert ), (
(((struct PwlArc *)__0__X7 )-> npts__6PwlArc = (__1nsteps + 1 )), ( (((struct PwlArc *)__0__X7 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X7 )))) ) )
:0 , 1) ;

}

}

}
}



void __glpwl_top__14ArcTessellatorF0 (struct ArcTessellator *__0this , struct Arc *__1arc , REAL __1t , REAL __1s1 , REAL __1s2 , REAL __1rate )
{ 
((void )0 );
((void )0 );

{ int __1nsteps ;
REAL __1stepsize ;

struct TrimVertex *__1newvert ;

__1nsteps = (1 + (((int )((__1s1 - __1s2 )/ __1rate ))));
__1stepsize = ((__1s1 - __1s2 )/ (((float )__1nsteps )));

__1newvert = __glget__14TrimVertexPoolFi ( (struct TrimVertexPool *)__0this -> trimvertexpool__14ArcTessellator , __1nsteps + 1 ) ;
{ { int __1i ;

struct PwlArc *__0__X8 ;

void *__1__Xbuffer00eohgaiaa ;

__1i = __1nsteps ;

for(;__1i > 0 ;__1i -- ) { 
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s2 ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t ;
__1s2 += __1stepsize ;
}
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s1 ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t ;

__glmakeSide__3ArcFP6PwlArc8ar0 ( (struct Arc *)__1arc , (__0__X8 = (struct PwlArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ))), (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool = ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct
Pool *)__0this -> pwlarcpool__14ArcTessellator )) , 0 ) :( 0 ) ), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool -= ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> curblock__4Pool + ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool ))))) )
) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct PwlArc *)__0__X8 )-> pts__6PwlArc = __1newvert ), (
(((struct PwlArc *)__0__X8 )-> npts__6PwlArc = (__1nsteps + 1 )), ( (((struct PwlArc *)__0__X8 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X8 )))) ) )
:0 , 2) ;

}

}

}
}



void __glpwl_bottom__14ArcTessellat0 (struct ArcTessellator *__0this , struct Arc *__1arc , REAL __1t , REAL __1s1 , REAL __1s2 , REAL __1rate )
{ 
((void )0 );
((void )0 );

{ int __1nsteps ;
REAL __1stepsize ;

struct TrimVertex *__1newvert ;

__1nsteps = (1 + (((int )((__1s2 - __1s1 )/ __1rate ))));
__1stepsize = ((__1s2 - __1s1 )/ (((float )__1nsteps )));

__1newvert = __glget__14TrimVertexPoolFi ( (struct TrimVertexPool *)__0this -> trimvertexpool__14ArcTessellator , __1nsteps + 1 ) ;
{ { int __1i ;

struct PwlArc *__0__X9 ;

void *__1__Xbuffer00eohgaiaa ;

__1i = 0 ;

for(;__1i < __1nsteps ;__1i ++ ) { 
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s1 ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t ;
__1s1 += __1stepsize ;
}
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s2 ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t ;

__glmakeSide__3ArcFP6PwlArc8ar0 ( (struct Arc *)__1arc , (__0__X9 = (struct PwlArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ))), (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool = ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct
Pool *)__0this -> pwlarcpool__14ArcTessellator )) , 0 ) :( 0 ) ), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool -= ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> curblock__4Pool + ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool ))))) )
) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct PwlArc *)__0__X9 )-> pts__6PwlArc = __1newvert ), (
(((struct PwlArc *)__0__X9 )-> npts__6PwlArc = (__1nsteps + 1 )), ( (((struct PwlArc *)__0__X9 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X9 )))) ) )
:0 , 4) ;

}

}

}
}







void __glpwl__14ArcTessellatorFP3Ar0 (struct ArcTessellator *__0this , struct Arc *__1arc , REAL __1s1 , REAL __1s2 , REAL __1t1 , REAL __1t2 , REAL __1rate )
{ 
((void )0 );

{ int __1snsteps ;
int __1tnsteps ;
int __1nsteps ;

REAL __1sstepsize ;
REAL __1tstepsize ;
struct TrimVertex *__1newvert ;

__1snsteps = (1 + (((int )(( (((__1s2 - __1s1 )< 0.0 )?(- (__1s2 - __1s1 )):(__1s2 - __1s1 ))) / __1rate ))));
__1tnsteps = (1 + (((int )(( (((__1t2 - __1t1 )< 0.0 )?(- (__1t2 - __1t1 )):(__1t2 - __1t1 ))) / __1rate ))));
__1nsteps = ( ((__1snsteps < __1tnsteps )?__1tnsteps :__1snsteps )) ;

__1sstepsize = ((__1s2 - __1s1 )/ (((float )__1nsteps )));
__1tstepsize = ((__1t2 - __1t1 )/ (((float )__1nsteps )));
__1newvert = __glget__14TrimVertexPoolFi ( (struct TrimVertexPool *)__0this -> trimvertexpool__14ArcTessellator , __1nsteps + 1 ) ;
{ { long __1i ;

struct PwlArc *__0__X10 ;

void *__1__Xbuffer00eohgaiaa ;

__1i = 0 ;

for(;__1i < __1nsteps ;__1i ++ ) { 
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s1 ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t1 ;
__1s1 += __1sstepsize ;
__1t1 += __1tstepsize ;
}
((__1newvert [__1i ]). param__10TrimVertex [0 ])= __1s2 ;
((__1newvert [__1i ]). param__10TrimVertex [1 ])= __1t2 ;

__1arc -> pwlArc__3Arc = ((__0__X10 = (struct PwlArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ?(
( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ))), (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool = ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )) , 0 ) :( 0 ) ), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool -= ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> curblock__4Pool + ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool ))))) ) )
, 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct PwlArc *)__0__X10 )-> pts__6PwlArc = __1newvert ), ( (((struct
PwlArc *)__0__X10 )-> npts__6PwlArc = (__1nsteps + 1 )), ( (((struct PwlArc *)__0__X10 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X10 )))) ) ) :0 );

( (((struct Arc *)__1arc )-> type__3Arc &= (~ __glbezier_tag__3Arc ))) ;
( (((struct Arc *)__1arc )-> type__3Arc &= -1793)) ;

}

}

}
}

void __gltessellateLizNear__14ArcTes0 (struct ArcTessellator *__0this , struct Arc *__1arc , REAL __1geo_stepsize , REAL __1arc_stepsize , int __1isrational )
{ 
REAL __1s1 ;

REAL __1s2 ;

REAL __1t1 ;

REAL __1t2 ;
REAL __1stepsize ;
struct BezierArc *__1b ;

((void )0 );
;

;

;

;
__1stepsize = (__1geo_stepsize * __1arc_stepsize );
__1b = __1arc -> bezierArc__3Arc ;

if (__1isrational ){ 
__1s1 = ((__1b -> cpts__9BezierArc [0 ])/ (__1b -> cpts__9BezierArc [2 ]));
__1t1 = ((__1b -> cpts__9BezierArc [1 ])/ (__1b -> cpts__9BezierArc [2 ]));
__1s2 = ((__1b -> cpts__9BezierArc [(__1b -> stride__9BezierArc + 0 )])/ (__1b -> cpts__9BezierArc [(__1b -> stride__9BezierArc + 2 )]));
__1t2 = ((__1b -> cpts__9BezierArc [(__1b -> stride__9BezierArc + 1 )])/ (__1b -> cpts__9BezierArc [(__1b -> stride__9BezierArc + 2 )]));
}
else 
{ 
__1s1 = (__1b -> cpts__9BezierArc [0 ]);
__1t1 = (__1b -> cpts__9BezierArc [1 ]);
__1s2 = (__1b -> cpts__9BezierArc [(__1b -> stride__9BezierArc + 0 )]);
__1t2 = (__1b -> cpts__9BezierArc [(__1b -> stride__9BezierArc + 1 )]);
}
if (__1s1 == __1s2 )
if (__1t1 < __1t2 )
__glpwl_right__14ArcTessellato0 ( __0this , __1arc , __1s1 , __1t1 , __1t2 , __1stepsize ) ;
else 
__glpwl_left__14ArcTessellator0 ( __0this , __1arc , __1s1 , __1t1 , __1t2 , __1stepsize ) ;
else if (__1t1 == __1t2 )
if (__1s1 < __1s2 )
__glpwl_bottom__14ArcTessellat0 ( __0this , __1arc , __1t1 , __1s1 , __1s2 , __1stepsize ) ;
else 
__glpwl_top__14ArcTessellatorF0 ( __0this , __1arc , __1t1 , __1s1 , __1s2 , __1stepsize ) ;
else 
__glpwl__14ArcTessellatorFP3Ar0 ( __0this , __1arc , __1s1 , __1s2 , __1t1 , __1t2 , __1stepsize ) ;
}


void __gltrim_power_coeffs__14ArcTe0 (struct BezierArc *, REAL *, int );


void __gltessellateNonlizNear__14Arc0 (struct ArcTessellator *__0this , struct Arc *__1arc , REAL __1geo_stepsize , REAL __1arc_stepsize , int __1isrational )
{ 
((void )0 );

{ REAL __1stepsize ;

int __1nsteps ;

struct TrimVertex *__1vert ;
REAL __1dp ;
struct BezierArc *__1bezierArc ;

struct PwlArc *__0__X11 ;

void *__1__Xbuffer00eohgaiaa ;

__1stepsize = (__1geo_stepsize * __1arc_stepsize );

__1nsteps = (1 + (((int )(1.0 / __1stepsize ))));

__1vert = __glget__14TrimVertexPoolFi ( (struct TrimVertexPool *)__0this -> trimvertexpool__14ArcTessellator , __1nsteps + 1 ) ;
__1dp = (1.0 / __1nsteps );
__1bezierArc = __1arc -> bezierArc__3Arc ;

__1arc -> pwlArc__3Arc = ((__0__X11 = (struct PwlArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ?(
( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool ))), (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> freelist__4Pool = ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)__0this ->
pwlarcpool__14ArcTessellator )) , 0 ) :( 0 ) ), ( (((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool -= ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )->
buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> curblock__4Pool + ((struct Pool *)__0this -> pwlarcpool__14ArcTessellator )-> nextfree__4Pool ))))) ) )
, 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct PwlArc *)__0__X11 )-> type__6PwlArc = 0x8 ), ( (((struct
PwlArc *)__0__X11 )-> pts__6PwlArc = 0 ), ( (((struct PwlArc *)__0__X11 )-> npts__6PwlArc = -1), ((((struct PwlArc *)__0__X11 )))) ) ) :0 );
__1arc -> pwlArc__3Arc -> pts__6PwlArc = __1vert ;

if (__1isrational ){ 
REAL __2pow_u [24];

REAL __2pow_v [24];

REAL __2pow_w [24];
__gltrim_power_coeffs__14ArcTe0 ( __1bezierArc , (float *)__2pow_u , 0 ) ;
__gltrim_power_coeffs__14ArcTe0 ( __1bezierArc , (float *)__2pow_v , 1 ) ;
__gltrim_power_coeffs__14ArcTe0 ( __1bezierArc , (float *)__2pow_w , 2 ) ;

{ REAL *__2b ;

int __2step ;
int __2ocanremove ;
register long __2order ;

__2b = __1bezierArc -> cpts__9BezierArc ;
(__1vert -> param__10TrimVertex [0 ])= ((__2b [0 ])/ (__2b [2 ]));
(__1vert -> param__10TrimVertex [1 ])= ((__2b [1 ])/ (__2b [2 ]));

;
__2ocanremove = 0 ;
__2order = __1bezierArc -> order__9BezierArc ;
for(( (__2step = 1 ), (++ __1vert )) ;__2step < __1nsteps ;( (__2step ++ ), (__1vert ++ )) ) { 
register
REAL __3p ;
register REAL __3u ;
register REAL __3v ;
register REAL __3w ;

__3p = (__1dp * __2step );
__3u = (__2pow_u [0 ]);
__3v = (__2pow_v [0 ]);
__3w = (__2pow_w [0 ]);
{ { register int __3i ;

__3i = 1 ;

for(;__3i < __2order ;__3i ++ ) { 
__3u = ((__3u * __3p )+ (__2pow_u [__3i ]));
__3v = ((__3v * __3p )+ (__2pow_v [__3i ]));
__3w = ((__3w * __3p )+ (__2pow_w [__3i ]));
}
(__1vert -> param__10TrimVertex [0 ])= (__3u / __3w );
(__1vert -> param__10TrimVertex [1 ])= (__3v / __3w );

}

}

}

__2b += ((__2order - 1 )* __1bezierArc -> stride__9BezierArc );
(__1vert -> param__10TrimVertex [0 ])= ((__2b [0 ])/ (__2b [2 ]));
(__1vert -> param__10TrimVertex [1 ])= ((__2b [1 ])/ (__2b [2 ]));

}

}
else 
{ 
REAL __2pow_u [24];

REAL __2pow_v [24];
__gltrim_power_coeffs__14ArcTe0 ( __1bezierArc , (float *)__2pow_u , 0 ) ;
__gltrim_power_coeffs__14ArcTe0 ( __1bezierArc , (float *)__2pow_v , 1 ) ;

{ REAL *__2b ;

int __2step ;
int __2ocanremove ;
register long __2order ;

__2b = __1bezierArc -> cpts__9BezierArc ;
(__1vert -> param__10TrimVertex [0 ])= (__2b [0 ]);
(__1vert -> param__10TrimVertex [1 ])= (__2b [1 ]);

;
__2ocanremove = 0 ;
__2order = __1bezierArc -> order__9BezierArc ;
for(( (__2step = 1 ), (++ __1vert )) ;__2step < __1nsteps ;( (__2step ++ ), (__1vert ++ )) ) { 
register
REAL __3p ;
register REAL __3u ;
register REAL __3v ;

__3p = (__1dp * __2step );
__3u = (__2pow_u [0 ]);
__3v = (__2pow_v [0 ]);
{ { register int __3i ;

__3i = 1 ;

for(;__3i < __1bezierArc -> order__9BezierArc ;__3i ++ ) { 
__3u = ((__3u * __3p )+ (__2pow_u [__3i ]));
__3v = ((__3v * __3p )+ (__2pow_v [__3i ]));
}
(__1vert -> param__10TrimVertex [0 ])= __3u ;
(__1vert -> param__10TrimVertex [1 ])= __3v ;

}

}

}

__2b += ((__2order - 1 )* __1bezierArc -> stride__9BezierArc );
(__1vert -> param__10TrimVertex [0 ])= (__2b [0 ]);
(__1vert -> param__10TrimVertex [1 ])= (__2b [1 ]);

}
}
__1arc -> pwlArc__3Arc -> npts__6PwlArc = ((__1vert - __1arc -> pwlArc__3Arc -> pts__6PwlArc )+ 1 );

}

}

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];
REAL __glgl_Bernstein__14ArcTessell0 [][24][24]= { { { 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , {
0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 ,
0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 }
, { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 ,
0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 ,
0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } } ,
{ { - 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } , { 1 ,
0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 ,
0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,
{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 ,
0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } } , {
{ 1 , - 2 , 1 , 0 , 0 , 0 , 0 , 0 } , { - 2 ,
2 , 0 , 0 , 0 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 , 0 ,
0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ,
{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 ,
0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } } , {
{ - 1 , 3 , - 3 , 1 , 0 , 0 , 0 , 0 } , { 3 ,
- 6 , 3 , 0 , 0 , 0 , 0 , 0 } , { - 3 , 3 , 0 ,
0 , 0 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 ,
0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 ,
0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } }
, { { 1 , - 4 , 6 , - 4 , 1 , 0 , 0 , 0 } ,
{ - 4 , 12 , - 12 , 4 , 0 , 0 , 0 , 0 } , { 6 ,
- 12 , 6 , 0 , 0 , 0 , 0 , 0 } , { - 4 , 4 , 0 ,
0 , 0 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 ,
0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 ,
0 , 0 , 0 } } , { { - 1 , 5 , - 10 , 10 , -
5 , 1 , 0 , 0 } , { 5 , - 20 , 30 , - 20 , 5 , 0 ,
0 , 0 } , { - 10 , 30 , - 30 , 10 , 0 , 0 , 0 , 0 }
, { 10 , - 20 , 10 , 0 , 0 , 0 , 0 , 0 } , { -
5 , 5 , 0 , 0 , 0 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 ,
0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 }
, { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } } , { {
1 , - 6 , 15 , - 20 , 15 , - 6 , 1 , 0 } , { -
6 , 30 , - 60 , 60 , - 30 , 6 , 0 , 0 } , { 15 , -
60 , 90 , - 60 , 15 , 0 , 0 , 0 } , { - 20 , 60 , -
60 , 20 , 0 , 0 , 0 , 0 } , { 15 , - 30 , 15 , 0 , 0 ,
0 , 0 , 0 } , { - 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 }
, { 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 ,
0 , 0 , 0 , 0 , 0 , 0 } } , { { - 1 , 7 , -
21 , 35 , - 35 , 21 , - 7 , 1 } , { 7 , - 42 , 105 ,
- 140 , 105 , - 42 , 7 , 0 } , { - 21 , 105 , - 210 ,
210 , - 105 , 21 , 0 , 0 } , { 35 , - 140 , 210 , - 140 ,
35 , 0 , 0 , 0 } , { - 35 , 105 , - 105 , 35 , 0 , 0 ,
0 , 0 } , { 21 , - 42 , 21 , 0 , 0 , 0 , 0 , 0 } ,
{ - 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 } , { 1 , 0 ,
0 , 0 , 0 , 0 , 0 , 0 } } } ;

void __gltrim_power_coeffs__14ArcTe0 (struct BezierArc *__1bez_arc , REAL *__1p , int __1coord )
{ 
register int __1stride ;
register int __1order ;
register REAL *__1base ;

REAL (*__1mat )[24][24];
REAL (*__1lrow )[24];

__1stride = __1bez_arc -> stride__9BezierArc ;
__1order = __1bez_arc -> order__9BezierArc ;
__1base = (__1bez_arc -> cpts__9BezierArc + __1coord );

__1mat = (((REAL (*)[24][24])(__glgl_Bernstein__14ArcTessell0 [(__1order - 1 )])));
__1lrow = (((REAL (*)[24])(((*__1mat ))[__1order ])));
{ { REAL (*__1row )[24];

__1row = (((REAL (*)[24])(((*__1mat ))[0 ])));

for(;__1row != __1lrow ;__1row ++ ) { 
register REAL __2s ;
register REAL *__2point ;
register REAL *__2mlast ;

__2s = 0.0 ;
__2point = __1base ;
__2mlast = (float *)(((*__1row ))+ __1order );
{ { REAL *__2m ;

__2m = (float *)((*__1row ));

for(;__2m != __2mlast ;( (__2m ++ ), (__2point += __1stride )) ) 
__2s += (((*__2m ))* ((*__2point )));
((*(__1p ++ )))= __2s ;

}

}
}

}

}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\backend.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/backend.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;



struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};










struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};






struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};










struct CachingEvaluator;
enum __Q2_16CachingEvaluator11ServiceMode { play__Q2_16CachingEvaluator11ServiceMode = 0, record__Q2_16CachingEvaluator11ServiceMode = 1, playAndRecord__Q2_16CachingEvaluator11ServiceMode = 2} ;

struct CachingEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

static void *__nw__FUi (size_t );


struct BasicCurveEvaluator;


struct BasicCurveEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};




struct BasicSurfaceEvaluator;

static struct CachingEvaluator *__ct__16CachingEvaluatorFv (struct CachingEvaluator *);

struct BasicSurfaceEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};






void __glbgnmap2f__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *, long );
extern struct __mptr* __gl__ptbl_vec_____core_backen0[];

void __glbgnsurf__7BackendFiT1l (struct Backend *__0this , int __1wiretris , int __1wirequads , long __1nuid )
{ 
struct BasicSurfaceEvaluator *__0__K9 ;

__0this -> wireframetris__7Backend = __1wiretris ;
__0this -> wireframequads__7Backend = __1wirequads ;

( (__0__K9 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long ))(__0__K9 -> __vptr__16CachingEvaluator [12]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K9 ))+
(__0__K9 -> __vptr__16CachingEvaluator [12]).d))), __1nuid ) ) ;
}

void __gldomain2f__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *, REAL , REAL , REAL , REAL );

void __glpatch__7BackendFfN31 (struct Backend *__0this , REAL __1ulo , REAL __1uhi , REAL __1vlo , REAL __1vhi )
{ 
struct BasicSurfaceEvaluator *__0__K10 ;

( (__0__K10 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, REAL , REAL , REAL , REAL ))(__0__K10 -> __vptr__16CachingEvaluator [9]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K10 ))+ (__0__K10 -> __vptr__16CachingEvaluator [9]).d))), __1ulo , __1uhi , __1vlo , __1vhi ) ) ;
}

void __glrange2f__21BasicSurfaceEva0 (struct BasicSurfaceEvaluator *, long , REAL *, REAL *);

void __glsurfbbox__7BackendFlPfT2 (struct Backend *__0this , long __1type , REAL *__1from , REAL *__1to )
{ 
struct BasicSurfaceEvaluator *__0__K11 ;

( (__0__K11 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL *, REAL *))(__0__K11 -> __vptr__16CachingEvaluator [8]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K11 ))+ (__0__K11 -> __vptr__16CachingEvaluator [8]).d))), __1type , __1from , __1to ) ) ;
}

void __glmap2f__21BasicSurfaceEvalu0 (struct BasicSurfaceEvaluator *, long , REAL , REAL , long , long , REAL , REAL , long
, long , REAL *);

void __glenable__21BasicSurfaceEval0 (struct BasicSurfaceEvaluator *, long );

void __glsurfpts__7BackendFlPfN21iT0 (struct Backend *__0this , 
long __1type , 
REAL *__1pts , 
long __1ustride , 
long __1vstride , 
int __1uorder , 
int __1vorder ,

REAL __1ulo , 
REAL __1uhi , 
REAL __1vlo , 
REAL __1vhi )
{ 
struct BasicSurfaceEvaluator *__0__K12 ;

struct BasicSurfaceEvaluator *__0__K13 ;

( (__0__K12 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL , REAL , long , long
, REAL , REAL , long , long , REAL *))(__0__K12 -> __vptr__16CachingEvaluator [13]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K12 ))+ (__0__K12 ->
__vptr__16CachingEvaluator [13]).d))), __1type , __1ulo , __1uhi , __1ustride , (long )__1uorder , __1vlo , __1vhi , __1vstride , (long )__1vorder , __1pts ) )
;
( (__0__K13 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long ))(__0__K13 -> __vptr__16CachingEvaluator [10]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K13 ))+
(__0__K13 -> __vptr__16CachingEvaluator [10]).d))), __1type ) ) ;
}

void __glmapgrid2f__21BasicSurfaceE0 (struct BasicSurfaceEvaluator *, long , REAL , REAL , long , REAL , REAL );

void __glsurfgrid__7BackendFfT1lN210 (struct Backend *__0this , REAL __1u0 , REAL __1u1 , long __1nu , REAL __1v0 , REAL __1v1 , long __1nv )
{ 
struct BasicSurfaceEvaluator *__0__K14 ;

( (__0__K14 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL , REAL , long , REAL ,
REAL ))(__0__K14 -> __vptr__16CachingEvaluator [14]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K14 ))+ (__0__K14 -> __vptr__16CachingEvaluator [14]).d))), __1nu , __1u0 , __1u1 , __1nv , __1v0 , __1v1 )
) ;
}

void __glbgnline__21BasicSurfaceEva0 (struct BasicSurfaceEvaluator *);

void __glevalpoint2i__21BasicSurfac0 (struct BasicSurfaceEvaluator *, long , long );

void __glendline__21BasicSurfaceEva0 (struct BasicSurfaceEvaluator *);

void __glmapmesh2f__21BasicSurfaceE0 (struct BasicSurfaceEvaluator *, long , long , long , long , long );

void __glsurfmesh__7BackendFlN31 (struct Backend *__0this , long __1u , long __1v , long __1n , long __1m )
{ 
if (__0this -> wireframequads__7Backend ){

long __2v0 ;

long __2v1 ;
long __2u0f ;

long __2u1f ;
long __2v0f ;

long __2v1f ;
long __2parity ;

__2u0f = __1u ;

__2u1f = (__1u + __1n );
__2v0f = __1v ;

__2v1f = (__1v + __1m );
__2parity = (__1u & 1 );

for(( (__2v0 = __2v0f ), (__2v1 = (__2v0f ++ ))) ;__2v0 < __2v1f ;( (__2v0 = __2v1 ), (__2v1 ++ )) ) {

struct BasicSurfaceEvaluator *__0__K15 ;

( (__0__K15 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K15 -> __vptr__16CachingEvaluator [20]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K15 ))+ (__0__K15 -> __vptr__16CachingEvaluator [20]).d))))
) ;
{ { long __3u ;

struct BasicSurfaceEvaluator *__0__K20 ;

__3u = __2u0f ;

for(;__3u <= __2u1f ;__3u ++ ) { 
if (__2parity ){ 
struct BasicSurfaceEvaluator *__0__K16 ;

struct BasicSurfaceEvaluator *__0__K17 ;

( (__0__K16 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K16 -> __vptr__16CachingEvaluator [17]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K16 ))+ (__0__K16 -> __vptr__16CachingEvaluator [17]).d))), __3u , __2v0 ) ) ;
( (__0__K17 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K17 -> __vptr__16CachingEvaluator [17]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K17 ))+ (__0__K17 -> __vptr__16CachingEvaluator [17]).d))), __3u , __2v1 ) ) ;
}
else 
{ 
struct BasicSurfaceEvaluator *__0__K18 ;

struct BasicSurfaceEvaluator *__0__K19 ;

( (__0__K18 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K18 -> __vptr__16CachingEvaluator [17]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K18 ))+ (__0__K18 -> __vptr__16CachingEvaluator [17]).d))), __3u , __2v1 ) ) ;
( (__0__K19 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K19 -> __vptr__16CachingEvaluator [17]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K19 ))+ (__0__K19 -> __vptr__16CachingEvaluator [17]).d))), __3u , __2v0 ) ) ;
}
__2parity = (1 - __2parity );
}
( (__0__K20 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K20 -> __vptr__16CachingEvaluator [21]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K20 ))+ (__0__K20 -> __vptr__16CachingEvaluator [21]).d))))
) ;

}

}
}
}
else 
{ 
struct BasicSurfaceEvaluator *__0__K21 ;

( (__0__K21 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long , long , long
, long ))(__0__K21 -> __vptr__16CachingEvaluator [15]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K21 ))+ (__0__K21 -> __vptr__16CachingEvaluator [15]).d))), (long )0 , __1u , __1u +
__1n , __1v , __1v + __1m ) ) ;
}

}

void __glendmap2f__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *);

void __glendsurf__7BackendFv (struct Backend *__0this )
{ 
struct BasicSurfaceEvaluator *__0__K22 ;

( (__0__K22 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K22 -> __vptr__16CachingEvaluator [18]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K22 ))+ (__0__K22 -> __vptr__16CachingEvaluator [18]).d))))
) ;
}

void __glbgntmesh__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *);

void __glbgntmesh__7BackendFPc (struct Backend *__0this , char *__1__A23 )
{ 
if (__0this -> wireframetris__7Backend ){ 
__0this -> meshindex__7Backend = 0 ;
__0this -> npts__7Backend = 0 ;
}
else 
{ 
struct BasicSurfaceEvaluator *__0__K24 ;

( (__0__K24 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K24 -> __vptr__16CachingEvaluator [24]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K24 ))+ (__0__K24 -> __vptr__16CachingEvaluator [24]).d))))
) ;
}

}


void __gltmeshvert__7BackendFP10Gri0 (struct Backend *, struct GridVertex *);

void __gltmeshvert__7BackendFP10Tri0 (struct Backend *, struct TrimVertex *);

void __gltmeshvert__7BackendFP14Gri0 (struct Backend *__0this , struct GridTrimVertex *__1v )
{ 
if (( (((struct GridTrimVertex *)__1v )-> g__14GridTrimVertex ?1 :0 )) ){ 
__gltmeshvert__7BackendFP10Gri0 ( __0this , __1v ->
g__14GridTrimVertex ) ;
}
else 
{ 
__gltmeshvert__7BackendFP10Tri0 ( __0this , __1v -> t__14GridTrimVertex ) ;
}
}

void __glbgnclosedline__21BasicSurf0 (struct BasicSurfaceEvaluator *);

void __glevalcoord2f__21BasicSurfac0 (struct BasicSurfaceEvaluator *, long , REAL , REAL );

void __glendclosedline__21BasicSurf0 (struct BasicSurfaceEvaluator *);

void __gltmeshvert__7BackendFP10Tri0 (struct Backend *__0this , struct TrimVertex *__1t )
{ 
long __1nuid ;
REAL __1u ;
REAL __1v ;

__1nuid = __1t -> nuid__10TrimVertex ;
__1u = (__1t -> param__10TrimVertex [0 ]);
__1v = (__1t -> param__10TrimVertex [1 ]);

__0this -> npts__7Backend ++ ;
if (__0this -> wireframetris__7Backend ){ 
if (__0this -> npts__7Backend >= 3 ){ 
struct BasicSurfaceEvaluator *__0__K25 ;

struct BasicSurfaceEvaluator *__0__K26 ;

struct BasicSurfaceEvaluator *__0__K27 ;

struct BasicSurfaceEvaluator *__0__K28 ;

struct BasicSurfaceEvaluator *__0__K29 ;

struct BasicSurfaceEvaluator *__0__K30 ;

struct BasicSurfaceEvaluator *__0__K31 ;

( (__0__K25 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K25 -> __vptr__16CachingEvaluator [22]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K25 ))+ (__0__K25 -> __vptr__16CachingEvaluator [22]).d))))
) ;
if (((__0this -> mesh__7Backend [0 ])[2 ])== 0 )
( (__0__K26 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL , REAL ))(__0__K26 ->
__vptr__16CachingEvaluator [16]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K26 ))+ (__0__K26 -> __vptr__16CachingEvaluator [16]).d))), (long )((__0this -> mesh__7Backend [0 ])[3 ]), (__0this -> mesh__7Backend [0 ])[0 ], (__0this -> mesh__7Backend [0 ])[1 ])
) ;
else 
( (__0__K27 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K27 -> __vptr__16CachingEvaluator [17]).f))))( (struct
BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K27 ))+ (__0__K27 -> __vptr__16CachingEvaluator [17]).d))), ((long )((__0this -> mesh__7Backend [0 ])[0 ])), ((long )((__0this -> mesh__7Backend [0 ])[1 ]))) ) ;
if (((__0this -> mesh__7Backend [1 ])[2 ])== 0 )
( (__0__K28 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL , REAL ))(__0__K28 ->
__vptr__16CachingEvaluator [16]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K28 ))+ (__0__K28 -> __vptr__16CachingEvaluator [16]).d))), (long )((__0this -> mesh__7Backend [1 ])[3 ]), (__0this -> mesh__7Backend [1 ])[0 ], (__0this -> mesh__7Backend [1 ])[1 ])
) ;
else 
( (__0__K29 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K29 -> __vptr__16CachingEvaluator [17]).f))))( (struct
BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K29 ))+ (__0__K29 -> __vptr__16CachingEvaluator [17]).d))), ((long )((__0this -> mesh__7Backend [1 ])[0 ])), ((long )((__0this -> mesh__7Backend [1 ])[1 ]))) ) ;
( (__0__K30 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL , REAL ))(__0__K30 -> __vptr__16CachingEvaluator [16]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K30 ))+ (__0__K30 -> __vptr__16CachingEvaluator [16]).d))), (long )__1nuid , (float )__1u , (float )__1v ) ) ;
( (__0__K31 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K31 -> __vptr__16CachingEvaluator [23]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K31 ))+ (__0__K31 -> __vptr__16CachingEvaluator [23]).d))))
) ;
}
((__0this -> mesh__7Backend [__0this -> meshindex__7Backend ])[0 ])= __1u ;
((__0this -> mesh__7Backend [__0this -> meshindex__7Backend ])[1 ])= __1v ;
((__0this -> mesh__7Backend [__0this -> meshindex__7Backend ])[2 ])= 0 ;
((__0this -> mesh__7Backend [__0this -> meshindex__7Backend ])[3 ])= __1nuid ;
__0this -> meshindex__7Backend = ((__0this -> meshindex__7Backend + 1 )% 2 );
}
else 
{ 
struct BasicSurfaceEvaluator *__0__K32 ;

( (__0__K32 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL , REAL ))(__0__K32 -> __vptr__16CachingEvaluator [16]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K32 ))+ (__0__K32 -> __vptr__16CachingEvaluator [16]).d))), (long )__1nuid , (float )__1u , (float )__1v ) ) ;
}

}

void __gltmeshvert__7BackendFP10Gri0 (struct Backend *__0this , struct GridVertex *__1g )
{ 
long __1u ;
long __1v ;

__1u = (__1g -> gparam__10GridVertex [0 ]);
__1v = (__1g -> gparam__10GridVertex [1 ]);

__0this -> npts__7Backend ++ ;
if (__0this -> wireframetris__7Backend ){ 
if (__0this -> npts__7Backend >= 3 ){ 
struct BasicSurfaceEvaluator *__0__K33 ;

struct BasicSurfaceEvaluator *__0__K34 ;

struct BasicSurfaceEvaluator *__0__K35 ;

struct BasicSurfaceEvaluator *__0__K36 ;

struct BasicSurfaceEvaluator *__0__K37 ;

struct BasicSurfaceEvaluator *__0__K38 ;

struct BasicSurfaceEvaluator *__0__K39 ;

( (__0__K33 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K33 -> __vptr__16CachingEvaluator [22]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K33 ))+ (__0__K33 -> __vptr__16CachingEvaluator [22]).d))))
) ;
if (((__0this -> mesh__7Backend [0 ])[2 ])== 0 )
( (__0__K34 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL , REAL ))(__0__K34 ->
__vptr__16CachingEvaluator [16]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K34 ))+ (__0__K34 -> __vptr__16CachingEvaluator [16]).d))), (long )((__0this -> mesh__7Backend [0 ])[3 ]), (__0this -> mesh__7Backend [0 ])[0 ], (__0this -> mesh__7Backend [0 ])[1 ])
) ;
else 
( (__0__K35 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K35 -> __vptr__16CachingEvaluator [17]).f))))( (struct
BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K35 ))+ (__0__K35 -> __vptr__16CachingEvaluator [17]).d))), ((long )((__0this -> mesh__7Backend [0 ])[0 ])), ((long )((__0this -> mesh__7Backend [0 ])[1 ]))) ) ;
if (((__0this -> mesh__7Backend [1 ])[2 ])== 0 )
( (__0__K36 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL , REAL ))(__0__K36 ->
__vptr__16CachingEvaluator [16]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K36 ))+ (__0__K36 -> __vptr__16CachingEvaluator [16]).d))), (long )((__0this -> mesh__7Backend [1 ])[3 ]), (__0this -> mesh__7Backend [1 ])[0 ], (__0this -> mesh__7Backend [1 ])[1 ])
) ;
else 
( (__0__K37 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K37 -> __vptr__16CachingEvaluator [17]).f))))( (struct
BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K37 ))+ (__0__K37 -> __vptr__16CachingEvaluator [17]).d))), ((long )((__0this -> mesh__7Backend [1 ])[0 ])), ((long )((__0this -> mesh__7Backend [1 ])[1 ]))) ) ;
( (__0__K38 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K38 -> __vptr__16CachingEvaluator [17]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K38 ))+ (__0__K38 -> __vptr__16CachingEvaluator [17]).d))), (long )__1u , (long )__1v ) ) ;
( (__0__K39 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K39 -> __vptr__16CachingEvaluator [23]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K39 ))+ (__0__K39 -> __vptr__16CachingEvaluator [23]).d))))
) ;
}
((__0this -> mesh__7Backend [__0this -> meshindex__7Backend ])[0 ])= __1u ;
((__0this -> mesh__7Backend [__0this -> meshindex__7Backend ])[1 ])= __1v ;
((__0this -> mesh__7Backend [__0this -> meshindex__7Backend ])[2 ])= 1 ;
__0this -> meshindex__7Backend = ((__0this -> meshindex__7Backend + 1 )% 2 );
}
else 
{ 
struct BasicSurfaceEvaluator *__0__K40 ;

( (__0__K40 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K40 -> __vptr__16CachingEvaluator [17]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K40 ))+ (__0__K40 -> __vptr__16CachingEvaluator [17]).d))), (long )__1u , (long )__1v ) ) ;
}

}

void __glswaptmesh__21BasicSurfaceE0 (struct BasicSurfaceEvaluator *);

void __glswaptmesh__7BackendFv (struct Backend *__0this )
{ 
if (__0this -> wireframetris__7Backend ){ 
__0this -> meshindex__7Backend = (1 - __0this -> meshindex__7Backend );
}
else 
{ 
struct BasicSurfaceEvaluator *__0__K41 ;

( (__0__K41 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K41 -> __vptr__16CachingEvaluator [25]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K41 ))+ (__0__K41 -> __vptr__16CachingEvaluator [25]).d))))
) ;
}

}

void __glendtmesh__21BasicSurfaceEv0 (struct BasicSurfaceEvaluator *);

void __glendtmesh__7BackendFv (struct Backend *__0this )
{ 
struct BasicSurfaceEvaluator *__0__K42 ;

if (! __0this -> wireframetris__7Backend )
( (__0__K42 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K42 -> __vptr__16CachingEvaluator [26]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char
*)__0__K42 ))+ (__0__K42 -> __vptr__16CachingEvaluator [26]).d)))) ) ;

}

void __glbgnoutline__7BackendFv (struct Backend *__0this )
{ 
struct BasicSurfaceEvaluator *__0__K43 ;

( (__0__K43 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K43 -> __vptr__16CachingEvaluator [20]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K43 ))+ (__0__K43 -> __vptr__16CachingEvaluator [20]).d))))
) ;
}

void __gllinevert__7BackendFP10Trim0 (struct Backend *__0this , struct TrimVertex *__1t )
{ 
struct BasicSurfaceEvaluator *__0__K44 ;

( (__0__K44 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , REAL , REAL ))(__0__K44 -> __vptr__16CachingEvaluator [16]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K44 ))+ (__0__K44 -> __vptr__16CachingEvaluator [16]).d))), __1t -> nuid__10TrimVertex , __1t -> param__10TrimVertex [0 ], __1t -> param__10TrimVertex [1 ]) ) ;
}

void __gllinevert__7BackendFP10Grid0 (struct Backend *__0this , struct GridVertex *__1g )
{ 
struct BasicSurfaceEvaluator *__0__K45 ;

( (__0__K45 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *, long , long ))(__0__K45 -> __vptr__16CachingEvaluator [17]).f))))( (struct BasicSurfaceEvaluator *)(((struct
BasicSurfaceEvaluator *)((((char *)__0__K45 ))+ (__0__K45 -> __vptr__16CachingEvaluator [17]).d))), __1g -> gparam__10GridVertex [0 ], __1g -> gparam__10GridVertex [1 ]) ) ;
}

void __glendoutline__7BackendFv (struct Backend *__0this )
{ 
struct BasicSurfaceEvaluator *__0__K46 ;

( (__0__K46 = __0this -> surfaceEvaluator__7Backend ), ((*(((void (*)(struct BasicSurfaceEvaluator *))(__0__K46 -> __vptr__16CachingEvaluator [21]).f))))( (struct BasicSurfaceEvaluator *)(((struct BasicSurfaceEvaluator *)((((char *)__0__K46 ))+ (__0__K46 -> __vptr__16CachingEvaluator [21]).d))))
) ;
}

void __gltriangle__7BackendFP10Trim0 (struct Backend *__0this , struct TrimVertex *__1a , struct TrimVertex *__1b , struct TrimVertex *__1c )
{ 
__glbgntmesh__7BackendFPc ( __0this , (char *)"spittriangle")
;
__gltmeshvert__7BackendFP10Tri0 ( __0this , __1a ) ;
__gltmeshvert__7BackendFP10Tri0 ( __0this , __1b ) ;
__gltmeshvert__7BackendFP10Tri0 ( __0this , __1c ) ;
__glendtmesh__7BackendFv ( __0this ) ;
}

void __glbgnmap1f__19BasicCurveEval0 (struct BasicCurveEvaluator *, long );

void __glbgncurv__7BackendFv (struct Backend *__0this )
{ 
struct BasicCurveEvaluator *__0__K47 ;

( (__0__K47 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *, long ))(__0__K47 -> __vptr__16CachingEvaluator [12]).f))))( (struct BasicCurveEvaluator *)(((struct BasicCurveEvaluator *)((((char *)__0__K47 ))+
(__0__K47 -> __vptr__16CachingEvaluator [12]).d))), (long )0 ) ) ;
}

void __gldomain1f__19BasicCurveEval0 (struct BasicCurveEvaluator *, REAL , REAL );

void __glsegment__7BackendFfT1 (struct Backend *__0this , REAL __1ulo , REAL __1uhi )
{ 
struct BasicCurveEvaluator *__0__K48 ;

( (__0__K48 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *, REAL , REAL ))(__0__K48 -> __vptr__16CachingEvaluator [8]).f))))( (struct BasicCurveEvaluator *)(((struct BasicCurveEvaluator *)((((char *)__0__K48 ))+
(__0__K48 -> __vptr__16CachingEvaluator [8]).d))), __1ulo , __1uhi ) ) ;
}

void __glmap1f__19BasicCurveEvaluat0 (struct BasicCurveEvaluator *, long , REAL , REAL , long , long , REAL *);

void __glenable__19BasicCurveEvalua0 (struct BasicCurveEvaluator *, long );

void __glcurvpts__7BackendFlPfT1ifT0 (struct Backend *__0this , 
long __1type , 
REAL *__1pts , 
long __1stride , 
int __1order , 
REAL __1ulo , 
REAL __1uhi )
{ 
struct BasicCurveEvaluator *__0__K49 ;
struct BasicCurveEvaluator *__0__K50 ;

( (__0__K49 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *, long , REAL , REAL , long , long
, REAL *))(__0__K49 -> __vptr__16CachingEvaluator [13]).f))))( (struct BasicCurveEvaluator *)(((struct BasicCurveEvaluator *)((((char *)__0__K49 ))+ (__0__K49 -> __vptr__16CachingEvaluator [13]).d))), __1type , __1ulo , __1uhi , __1stride , (long
)__1order , __1pts ) ) ;
( (__0__K50 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *, long ))(__0__K50 -> __vptr__16CachingEvaluator [10]).f))))( (struct BasicCurveEvaluator *)(((struct BasicCurveEvaluator *)((((char *)__0__K50 ))+
(__0__K50 -> __vptr__16CachingEvaluator [10]).d))), __1type ) ) ;
}

void __glmapgrid1f__19BasicCurveEva0 (struct BasicCurveEvaluator *, long , REAL , REAL );

void __glcurvgrid__7BackendFfT1l (struct Backend *__0this , REAL __1u0 , REAL __1u1 , long __1nu )
{ 
struct BasicCurveEvaluator *__0__K51 ;

( (__0__K51 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *, long , REAL , REAL ))(__0__K51 -> __vptr__16CachingEvaluator [14]).f))))( (struct BasicCurveEvaluator *)(((struct
BasicCurveEvaluator *)((((char *)__0__K51 ))+ (__0__K51 -> __vptr__16CachingEvaluator [14]).d))), __1nu , __1u0 , __1u1 ) ) ;
}

void __glmapmesh1f__19BasicCurveEva0 (struct BasicCurveEvaluator *, long , long , long );

void __glcurvmesh__7BackendFlT1 (struct Backend *__0this , long __1from , long __1n )
{ 
struct BasicCurveEvaluator *__0__K52 ;

( (__0__K52 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *, long , long , long ))(__0__K52 -> __vptr__16CachingEvaluator [15]).f))))(
(struct BasicCurveEvaluator *)(((struct BasicCurveEvaluator *)((((char *)__0__K52 ))+ (__0__K52 -> __vptr__16CachingEvaluator [15]).d))), (long )0 , __1from , __1from + __1n ) ) ;
}

void __glevalcoord1f__19BasicCurveE0 (struct BasicCurveEvaluator *, long , REAL );

void __glcurvpt__7BackendFf (struct Backend *__0this , REAL __1u )
{ 
struct BasicCurveEvaluator *__0__K53 ;

( (__0__K53 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *, long , REAL ))(__0__K53 -> __vptr__16CachingEvaluator [16]).f))))( (struct BasicCurveEvaluator *)(((struct BasicCurveEvaluator *)((((char
*)__0__K53 ))+ (__0__K53 -> __vptr__16CachingEvaluator [16]).d))), (long )0 , __1u ) ) ;
}

void __glbgnline__19BasicCurveEvalu0 (struct BasicCurveEvaluator *);

void __glbgnline__7BackendFv (struct Backend *__0this )
{ 
struct BasicCurveEvaluator *__0__K54 ;

( (__0__K54 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *))(__0__K54 -> __vptr__16CachingEvaluator [18]).f))))( (struct BasicCurveEvaluator *)(((struct BasicCurveEvaluator *)((((char *)__0__K54 ))+ (__0__K54 -> __vptr__16CachingEvaluator [18]).d))))
) ;
}

void __glendline__19BasicCurveEvalu0 (struct BasicCurveEvaluator *);

void __glendline__7BackendFv (struct Backend *__0this )
{ 
struct BasicCurveEvaluator *__0__K55 ;

( (__0__K55 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *))(__0__K55 -> __vptr__16CachingEvaluator [19]).f))))( (struct BasicCurveEvaluator *)(((struct BasicCurveEvaluator *)((((char *)__0__K55 ))+ (__0__K55 -> __vptr__16CachingEvaluator [19]).d))))
) ;
}

void __glendmap1f__19BasicCurveEval0 (struct BasicCurveEvaluator *);

void __glendcurv__7BackendFv (struct Backend *__0this )
{ 
struct BasicCurveEvaluator *__0__K56 ;

( (__0__K56 = __0this -> curveEvaluator__7Backend ), ((*(((void (*)(struct BasicCurveEvaluator *))(__0__K56 -> __vptr__16CachingEvaluator [17]).f))))( (struct BasicCurveEvaluator *)(((struct BasicCurveEvaluator *)((((char *)__0__K56 ))+ (__0__K56 -> __vptr__16CachingEvaluator [17]).d))))
) ;
}

static struct CachingEvaluator *__ct__16CachingEvaluatorFv (struct CachingEvaluator *__0this ){ if (__0this || (__0this = (struct CachingEvaluator *)__nw__FUi ( sizeof (struct CachingEvaluator)) ))__0this -> __vptr__16CachingEvaluator = (struct
__mptr *) __gl__ptbl_vec_____core_backen0[0];

return __0this ;

}

static void *__nw__FUi (
size_t __1s )
{ 
void *__1__Xp00uzigaiaa ;

__1__Xp00uzigaiaa = malloc ( __1s ) ;
if (__1__Xp00uzigaiaa ){ 
return __1__Xp00uzigaiaa ;
}
else 
{ 
return __1__Xp00uzigaiaa ;
}
}
extern struct __mptr __gl__vtbl__16CachingEvaluator[];
struct __mptr* __gl__ptbl_vec_____core_backen0[] = {
__gl__vtbl__16CachingEvaluator,

};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\ccw.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/ccw.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct JumpBuffer;








struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};






int __glbbox__10SubdividerSFfN51 (REAL , REAL , REAL , REAL , REAL , REAL );



int __glccw__10SubdividerSFP10Trim0 (struct TrimVertex *, struct TrimVertex *, struct TrimVertex *);



extern struct __mptr* __ptbl_vec_____core_ccw_c___ccwTurn_sr_[];

int __glccwTurn_sr__10SubdividerFP0 (struct Subdivider *__0this , Arc_ptr __1j1 , Arc_ptr __1j2 )
{ 
register struct TrimVertex *__1v1 ;
register struct TrimVertex *__1v1last ;
register struct TrimVertex *__1v2 ;
register struct TrimVertex *__1v2last ;
register struct TrimVertex *__1v1next ;
register struct TrimVertex *__1v2next ;
int __1sgn ;

__1v1 = (& (__1j1 -> pwlArc__3Arc -> pts__6PwlArc [(__1j1 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]));
__1v1last = (& (__1j1 -> pwlArc__3Arc -> pts__6PwlArc [0 ]));
__1v2 = (& (__1j2 -> pwlArc__3Arc -> pts__6PwlArc [0 ]));
__1v2last = (& (__1j2 -> pwlArc__3Arc -> pts__6PwlArc [(__1j2 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]));
__1v1next = (__1v1 - 1 );
__1v2next = (__1v2 + 1 );

((void )0 );
((void )0 );

if (((__1v1 -> param__10TrimVertex [0 ])== (__1v1next -> param__10TrimVertex [0 ]))&& ((__1v2 -> param__10TrimVertex [0 ])== (__1v2next -> param__10TrimVertex [0 ])))
return 0 ;

if (((__1v2next -> param__10TrimVertex [0 ])< (__1v2 -> param__10TrimVertex [0 ]))|| ((__1v1next -> param__10TrimVertex [0 ])< (__1v1 -> param__10TrimVertex [0 ])))
mylongjmp ( __0this -> jumpbuffer__10Subdivider , 28 ) ;

if ((__1v1 -> param__10TrimVertex [1 ])< (__1v2 -> param__10TrimVertex [1 ]))
return 0 ;
else if ((__1v1 -> param__10TrimVertex [1 ])> (__1v2 -> param__10TrimVertex [1 ]))
return 1 ;

while (1 ){ 
if ((__1v1next -> param__10TrimVertex [0 ])< (__1v2next -> param__10TrimVertex [0 ])){ 
struct TrimVertex *__1__X13 ;

struct TrimVertex *__1__X14 ;

struct TrimVertex *__1__X15 ;

((void )0 );
((void )0 );
switch (( (__1__X13 = __1v2 ), ( (__1__X14 = __1v2next ), ( (__1__X15 = __1v1next ), ( __glbbox__10SubdividerSFfN51 ( __1__X13 -> param__10TrimVertex [1 ],
__1__X14 -> param__10TrimVertex [1 ], __1__X15 -> param__10TrimVertex [1 ], __1__X13 -> param__10TrimVertex [(1 - 1 )], __1__X14 -> param__10TrimVertex [(1 - 1 )], __1__X15 -> param__10TrimVertex [(1 - 1 )]) )
) ) ) ){ 
case -1:
return 0 ;
case 0 :
__1sgn = __glccw__10SubdividerSFP10Trim0 ( __1v1next , __1v2 , __1v2next ) ;
if (__1sgn != -1){ 
return __1sgn ;
}
else 
{ 
( 0 ) ;
__1v1 = (__1v1next -- );
if (__1v1 == __1v1last ){ 
( 0 ) ;
return 0 ;
}
}
break ;
case 1 :
return 1 ;
}
}
else 
if ((__1v1next -> param__10TrimVertex [0 ])> (__1v2next -> param__10TrimVertex [0 ])){ 
struct TrimVertex *__1__X16 ;

struct TrimVertex *__1__X17 ;

struct TrimVertex *__1__X18 ;

((void )0 );
((void )0 );
switch (( (__1__X16 = __1v1 ), ( (__1__X17 = __1v1next ), ( (__1__X18 = __1v2next ), ( __glbbox__10SubdividerSFfN51 ( __1__X16 -> param__10TrimVertex [1 ],
__1__X17 -> param__10TrimVertex [1 ], __1__X18 -> param__10TrimVertex [1 ], __1__X16 -> param__10TrimVertex [(1 - 1 )], __1__X17 -> param__10TrimVertex [(1 - 1 )], __1__X18 -> param__10TrimVertex [(1 - 1 )]) )
) ) ) ){ 
case -1:
return 1 ;
case 0 :
__1sgn = __glccw__10SubdividerSFP10Trim0 ( __1v1next , __1v1 , __1v2next ) ;
if (__1sgn != -1){ 
return __1sgn ;
}
else 
{ 
( 0 ) ;
__1v2 = (__1v2next ++ );
if (__1v2 == __1v2last ){ 
( 0 ) ;
return 0 ;
}
}
break ;
case 1 :
return 0 ;
}
}
else 
{ 
if ((__1v1next -> param__10TrimVertex [1 ])< (__1v2next -> param__10TrimVertex [1 ]))
return 0 ;
else if ((__1v1next -> param__10TrimVertex [1 ])> (__1v2next -> param__10TrimVertex [1 ]))
return 1 ;
else { 
( 0 ) ;
__1v2 = (__1v2next ++ );
if (__1v2 == __1v2last ){ 
( 0 ) ;
return 0 ;
}
}
}
}
}





int __glccwTurn_sl__10SubdividerFP0 (struct Subdivider *__0this , Arc_ptr __1j1 , Arc_ptr __1j2 )
{ 
register struct TrimVertex *__1v1 ;
register struct TrimVertex *__1v1last ;
register struct TrimVertex *__1v2 ;
register struct TrimVertex *__1v2last ;
register struct TrimVertex *__1v1next ;
register struct TrimVertex *__1v2next ;
int __1sgn ;

__1v1 = (& (__1j1 -> pwlArc__3Arc -> pts__6PwlArc [(__1j1 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]));
__1v1last = (& (__1j1 -> pwlArc__3Arc -> pts__6PwlArc [0 ]));
__1v2 = (& (__1j2 -> pwlArc__3Arc -> pts__6PwlArc [0 ]));
__1v2last = (& (__1j2 -> pwlArc__3Arc -> pts__6PwlArc [(__1j2 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]));
__1v1next = (__1v1 - 1 );
__1v2next = (__1v2 + 1 );

((void )0 );
((void )0 );

if (((__1v1 -> param__10TrimVertex [0 ])== (__1v1next -> param__10TrimVertex [0 ]))&& ((__1v2 -> param__10TrimVertex [0 ])== (__1v2next -> param__10TrimVertex [0 ])))
return 0 ;

if (((__1v2next -> param__10TrimVertex [0 ])> (__1v2 -> param__10TrimVertex [0 ]))|| ((__1v1next -> param__10TrimVertex [0 ])> (__1v1 -> param__10TrimVertex [0 ])))
mylongjmp ( __0this -> jumpbuffer__10Subdivider , 28 ) ;

if ((__1v1 -> param__10TrimVertex [1 ])< (__1v2 -> param__10TrimVertex [1 ]))
return 1 ;
else if ((__1v1 -> param__10TrimVertex [1 ])> (__1v2 -> param__10TrimVertex [1 ]))
return 0 ;

while (1 ){ 
if ((__1v1next -> param__10TrimVertex [0 ])> (__1v2next -> param__10TrimVertex [0 ])){ 
struct TrimVertex *__1__X19 ;

struct TrimVertex *__1__X20 ;

struct TrimVertex *__1__X21 ;

((void )0 );
((void )0 );
switch (( (__1__X19 = __1v2next ), ( (__1__X20 = __1v2 ), ( (__1__X21 = __1v1next ), ( __glbbox__10SubdividerSFfN51 ( __1__X19 -> param__10TrimVertex [1 ],
__1__X20 -> param__10TrimVertex [1 ], __1__X21 -> param__10TrimVertex [1 ], __1__X19 -> param__10TrimVertex [(1 - 1 )], __1__X20 -> param__10TrimVertex [(1 - 1 )], __1__X21 -> param__10TrimVertex [(1 - 1 )]) )
) ) ) ){ 
case -1:
return 1 ;
case 0 :
__1sgn = __glccw__10SubdividerSFP10Trim0 ( __1v1next , __1v2 , __1v2next ) ;
if (__1sgn != -1)
return __1sgn ;
else { 
__1v1 = (__1v1next -- );
( 0 ) ;
if (__1v1 == __1v1last ){ 
( 0 ) ;
return 0 ;
}
}
break ;
case 1 :
return 0 ;
}
}
else 
if ((__1v1next -> param__10TrimVertex [0 ])< (__1v2next -> param__10TrimVertex [0 ])){ 
struct TrimVertex *__1__X22 ;

struct TrimVertex *__1__X23 ;

struct TrimVertex *__1__X24 ;

((void )0 );
((void )0 );
switch (( (__1__X22 = __1v1next ), ( (__1__X23 = __1v1 ), ( (__1__X24 = __1v2next ), ( __glbbox__10SubdividerSFfN51 ( __1__X22 -> param__10TrimVertex [1 ],
__1__X23 -> param__10TrimVertex [1 ], __1__X24 -> param__10TrimVertex [1 ], __1__X22 -> param__10TrimVertex [(1 - 1 )], __1__X23 -> param__10TrimVertex [(1 - 1 )], __1__X24 -> param__10TrimVertex [(1 - 1 )]) )
) ) ) ){ 
case -1:
return 0 ;
case 0 :
__1sgn = __glccw__10SubdividerSFP10Trim0 ( __1v1next , __1v1 , __1v2next ) ;
if (__1sgn != -1)
return __1sgn ;
else { 
__1v2 = (__1v2next ++ );
( 0 ) ;
if (__1v2 == __1v2last ){ 
( 0 ) ;
return 0 ;
}
}
break ;
case 1 :
return 1 ;
}
}
else 
{ 
( 0 ) ;
if ((__1v1next -> param__10TrimVertex [1 ])< (__1v2next -> param__10TrimVertex [1 ]))
return 1 ;
else if ((__1v1next -> param__10TrimVertex [1 ])> (__1v2next -> param__10TrimVertex [1 ]))
return 0 ;
else { 
__1v2 = (__1v2next ++ );
( 0 ) ;
if (__1v2 == __1v2last ){ 
( 0 ) ;
return 0 ;
}
}
}
}
}





int __glccwTurn_tr__10SubdividerFP0 (struct Subdivider *__0this , Arc_ptr __1j1 , Arc_ptr __1j2 )
{ 
register struct TrimVertex *__1v1 ;
register struct TrimVertex *__1v1last ;
register struct TrimVertex *__1v2 ;
register struct TrimVertex *__1v2last ;
register struct TrimVertex *__1v1next ;
register struct TrimVertex *__1v2next ;
int __1sgn ;

__1v1 = (& (__1j1 -> pwlArc__3Arc -> pts__6PwlArc [(__1j1 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]));
__1v1last = (& (__1j1 -> pwlArc__3Arc -> pts__6PwlArc [0 ]));
__1v2 = (& (__1j2 -> pwlArc__3Arc -> pts__6PwlArc [0 ]));
__1v2last = (& (__1j2 -> pwlArc__3Arc -> pts__6PwlArc [(__1j2 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]));
__1v1next = (__1v1 - 1 );
__1v2next = (__1v2 + 1 );

((void )0 );
((void )0 );

if (((__1v1 -> param__10TrimVertex [1 ])== (__1v1next -> param__10TrimVertex [1 ]))&& ((__1v2 -> param__10TrimVertex [1 ])== (__1v2next -> param__10TrimVertex [1 ])))
return 0 ;

if (((__1v2next -> param__10TrimVertex [1 ])< (__1v2 -> param__10TrimVertex [1 ]))|| ((__1v1next -> param__10TrimVertex [1 ])< (__1v1 -> param__10TrimVertex [1 ])))
mylongjmp ( __0this -> jumpbuffer__10Subdivider , 28 ) ;

if ((__1v1 -> param__10TrimVertex [0 ])< (__1v2 -> param__10TrimVertex [0 ]))
return 1 ;
else if ((__1v1 -> param__10TrimVertex [0 ])> (__1v2 -> param__10TrimVertex [0 ]))
return 0 ;

while (1 ){ 
if ((__1v1next -> param__10TrimVertex [1 ])< (__1v2next -> param__10TrimVertex [1 ])){ 
struct TrimVertex *__1__X25 ;

struct TrimVertex *__1__X26 ;

struct TrimVertex *__1__X27 ;

((void )0 );
((void )0 );
switch (( (__1__X25 = __1v2 ), ( (__1__X26 = __1v2next ), ( (__1__X27 = __1v1next ), ( __glbbox__10SubdividerSFfN51 ( __1__X25 -> param__10TrimVertex [0 ],
__1__X26 -> param__10TrimVertex [0 ], __1__X27 -> param__10TrimVertex [0 ], __1__X25 -> param__10TrimVertex [(1 - 0 )], __1__X26 -> param__10TrimVertex [(1 - 0 )], __1__X27 -> param__10TrimVertex [(1 - 0 )]) )
) ) ) ){ 
case -1:
return 1 ;
case 0 :
__1sgn = __glccw__10SubdividerSFP10Trim0 ( __1v1next , __1v2 , __1v2next ) ;
if (__1sgn != -1){ 
return __1sgn ;
}
else 
{ 
( 0 ) ;
__1v1 = (__1v1next -- );
if (__1v1 == __1v1last ){ 
( 0 ) ;
return 0 ;
}
}
break ;
case 1 :
return 0 ;
}
}
else 
if ((__1v1next -> param__10TrimVertex [1 ])> (__1v2next -> param__10TrimVertex [1 ])){ 
struct TrimVertex *__1__X28 ;

struct TrimVertex *__1__X29 ;

struct TrimVertex *__1__X30 ;

((void )0 );
((void )0 );
switch (( (__1__X28 = __1v1 ), ( (__1__X29 = __1v1next ), ( (__1__X30 = __1v2next ), ( __glbbox__10SubdividerSFfN51 ( __1__X28 -> param__10TrimVertex [0 ],
__1__X29 -> param__10TrimVertex [0 ], __1__X30 -> param__10TrimVertex [0 ], __1__X28 -> param__10TrimVertex [(1 - 0 )], __1__X29 -> param__10TrimVertex [(1 - 0 )], __1__X30 -> param__10TrimVertex [(1 - 0 )]) )
) ) ) ){ 
case -1:
return 0 ;
case 0 :
__1sgn = __glccw__10SubdividerSFP10Trim0 ( __1v1next , __1v1 , __1v2next ) ;
if (__1sgn != -1){ 
return __1sgn ;
}
else 
{ 
( 0 ) ;
__1v2 = (__1v2next ++ );
if (__1v2 == __1v2last ){ 
( 0 ) ;
return 0 ;
}
}
break ;
case 1 :
return 1 ;
}
}
else 
{ 
( 0 ) ;
if ((__1v1next -> param__10TrimVertex [0 ])< (__1v2next -> param__10TrimVertex [0 ]))
return 1 ;
else if ((__1v1next -> param__10TrimVertex [0 ])> (__1v2next -> param__10TrimVertex [0 ]))
return 0 ;
else { 
( 0 ) ;
__1v2 = (__1v2next ++ );
if (__1v2 == __1v2last ){ 
( 0 ) ;
return 0 ;
}
}
}
}
}





int __glccwTurn_tl__10SubdividerFP0 (struct Subdivider *__0this , Arc_ptr __1j1 , Arc_ptr __1j2 )
{ 
register struct TrimVertex *__1v1 ;
register struct TrimVertex *__1v1last ;
register struct TrimVertex *__1v2 ;
register struct TrimVertex *__1v2last ;
register struct TrimVertex *__1v1next ;
register struct TrimVertex *__1v2next ;
int __1sgn ;

__1v1 = (& (__1j1 -> pwlArc__3Arc -> pts__6PwlArc [(__1j1 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]));
__1v1last = (& (__1j1 -> pwlArc__3Arc -> pts__6PwlArc [0 ]));
__1v2 = (& (__1j2 -> pwlArc__3Arc -> pts__6PwlArc [0 ]));
__1v2last = (& (__1j2 -> pwlArc__3Arc -> pts__6PwlArc [(__1j2 -> pwlArc__3Arc -> npts__6PwlArc - 1 )]));
__1v1next = (__1v1 - 1 );
__1v2next = (__1v2 + 1 );

((void )0 );
((void )0 );

if (((__1v1 -> param__10TrimVertex [1 ])== (__1v1next -> param__10TrimVertex [1 ]))&& ((__1v2 -> param__10TrimVertex [1 ])== (__1v2next -> param__10TrimVertex [1 ])))
return 0 ;

if (((__1v2next -> param__10TrimVertex [1 ])> (__1v2 -> param__10TrimVertex [1 ]))|| ((__1v1next -> param__10TrimVertex [1 ])> (__1v1 -> param__10TrimVertex [1 ])))
mylongjmp ( __0this -> jumpbuffer__10Subdivider , 28 ) ;

if ((__1v1 -> param__10TrimVertex [0 ])< (__1v2 -> param__10TrimVertex [0 ]))
return 0 ;
else if ((__1v1 -> param__10TrimVertex [0 ])> (__1v2 -> param__10TrimVertex [0 ]))
return 1 ;

while (1 ){ 
if ((__1v1next -> param__10TrimVertex [1 ])> (__1v2next -> param__10TrimVertex [1 ])){ 
struct TrimVertex *__1__X31 ;

struct TrimVertex *__1__X32 ;

struct TrimVertex *__1__X33 ;

((void )0 );
((void )0 );
switch (( (__1__X31 = __1v2next ), ( (__1__X32 = __1v2 ), ( (__1__X33 = __1v1next ), ( __glbbox__10SubdividerSFfN51 ( __1__X31 -> param__10TrimVertex [0 ],
__1__X32 -> param__10TrimVertex [0 ], __1__X33 -> param__10TrimVertex [0 ], __1__X31 -> param__10TrimVertex [(1 - 0 )], __1__X32 -> param__10TrimVertex [(1 - 0 )], __1__X33 -> param__10TrimVertex [(1 - 0 )]) )
) ) ) ){ 
case -1:
return 0 ;
case 0 :
__1sgn = __glccw__10SubdividerSFP10Trim0 ( __1v1next , __1v2 , __1v2next ) ;
if (__1sgn != -1)
return __1sgn ;
else { 
__1v1 = (__1v1next -- );
( 0 ) ;
if (__1v1 == __1v1last ){ 
( 0 ) ;
return 0 ;
}
}
break ;
case 1 :
return 1 ;
}
}
else 
if ((__1v1next -> param__10TrimVertex [1 ])< (__1v2next -> param__10TrimVertex [1 ])){ 
struct TrimVertex *__1__X34 ;

struct TrimVertex *__1__X35 ;

struct TrimVertex *__1__X36 ;

switch (( (__1__X34 = __1v1next ), ( (__1__X35 = __1v1 ), ( (__1__X36 = __1v2next ), ( __glbbox__10SubdividerSFfN51 ( __1__X34 -> param__10TrimVertex [0 ],
__1__X35 -> param__10TrimVertex [0 ], __1__X36 -> param__10TrimVertex [0 ], __1__X34 -> param__10TrimVertex [(1 - 0 )], __1__X35 -> param__10TrimVertex [(1 - 0 )], __1__X36 -> param__10TrimVertex [(1 - 0 )]) )
) ) ) ){ 
case -1:
return 1 ;
case 0 :
__1sgn = __glccw__10SubdividerSFP10Trim0 ( __1v1next , __1v1 , __1v2next ) ;
if (__1sgn != -1)
return __1sgn ;
else { 
__1v2 = (__1v2next ++ );
( 0 ) ;
if (__1v2 == __1v2last ){ 
( 0 ) ;
return 0 ;
}
}
break ;
case 1 :
return 0 ;
}
}
else 
{ 
( 0 ) ;
if ((__1v1next -> param__10TrimVertex [0 ])< (__1v2next -> param__10TrimVertex [0 ]))
return 0 ;
else if ((__1v1next -> param__10TrimVertex [0 ])> (__1v2next -> param__10TrimVertex [0 ]))
return 1 ;
else { 
__1v2 = (__1v2next ++ );
( 0 ) ;
if (__1v2 == __1v2last ){ 
( 0 ) ;
return 0 ;
}
}
}
}
}

int __glbbox__10SubdividerSFfN51 (register REAL __1sa , register REAL __1sb , register REAL __1sc , 
register REAL __1__A37 , register REAL __1__A38 , register REAL __1__A39 )
{ 
if
(__1sa < __1sb ){ 
if (__1sc <= __1sa ){ 
return -1;
}
else 
if (__1sb <= __1sc ){ 
return 1 ;
}
else 
{ 
return 0 ;
}
}
else 
if (__1sa > __1sb ){ 
if (__1sc >= __1sa ){ 
return 1 ;
}
else 
if (__1sb >= __1sc ){ 
return -1;
}
else 
{ 
return 0 ;
}
}
else 
{ 
if (__1sc > __1sa ){ 
return 1 ;
}
else 
if (__1sb > __1sc ){ 
return -1;
}
else 
{ 
return 0 ;
}
}
}



int __glccw__10SubdividerSFP10Trim0 (struct TrimVertex *__1a , struct TrimVertex *__1b , struct TrimVertex *__1c )
{ 
REAL __1d ;

struct TrimVertex *__1__X40 ;

struct TrimVertex *__1__X41 ;

struct TrimVertex *__1__X42 ;

__1d = ( (__1__X40 = __1a ), ( (__1__X41 = __1b ), ( (__1__X42 = __1c ), ( ((((__1__X40 -> param__10TrimVertex [0 ])* ((__1__X41 ->
param__10TrimVertex [1 ])- (__1__X42 -> param__10TrimVertex [1 ])))+ ((__1__X41 -> param__10TrimVertex [0 ])* ((__1__X42 -> param__10TrimVertex [1 ])- (__1__X40 -> param__10TrimVertex [1 ]))))+ ((__1__X42 -> param__10TrimVertex [0 ])* ((__1__X40 -> param__10TrimVertex [1 ])- (__1__X41 ->
param__10TrimVertex [1 ]))))) ) ) ) ;
if (( ((__1d < 0.0 )?(- __1d ):__1d )) < 0.0001 )return -1;
return ((__1d < 0.0 )?0 :1 );
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\cachinge.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/cachingeval.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };




struct CachingEvaluator;
enum __Q2_16CachingEvaluator11ServiceMode { play__Q2_16CachingEvaluator11ServiceMode = 0, record__Q2_16CachingEvaluator11ServiceMode = 1, playAndRecord__Q2_16CachingEvaluator11ServiceMode = 2} ;

struct CachingEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

extern void *__nw__FUi (unsigned int );


extern struct __mptr* __ptbl_vec_____core_cachingeval_c___canRecord_[];

int __glcanRecord__16CachingEvalua0 (struct CachingEvaluator *__0this )
{ 
return 0 ;
}

int __glcanPlayAndRecord__16Cachin0 (struct CachingEvaluator *__0this )
{ 
return 0 ;
}

int __glcreateHandle__16CachingEva0 (struct CachingEvaluator *__0this , int __1__A2 )
{ 
return 0 ;
}

void __glbeginOutput__16CachingEval0 (struct CachingEvaluator *__0this , int __1__A3 , int __1__A4 )
{ 
}

void __glendOutput__16CachingEvalua0 (struct CachingEvaluator *__0this )
{ 
}

void __gldiscardRecording__16Cachin0 (struct CachingEvaluator *__0this , int
__1__A5 )
{ 
}

void __glplayRecording__16CachingEv0 (struct CachingEvaluator *__0this , int __1__A6 )
{ 
}
struct __mptr __gl__vtbl__16CachingEvaluator[] = {0,0,0,
0,0,(__vptp)__glcanRecord__16CachingEvalua0 ,
0,0,(__vptp)__glcanPlayAndRecord__16Cachin0 ,
0,0,(__vptp)__glcreateHandle__16CachingEva0 ,
0,0,(__vptp)__glbeginOutput__16CachingEval0 ,
0,0,(__vptp)__glendOutput__16CachingEvalua0 ,
0,0,(__vptp)__gldiscardRecording__16Cachin0 ,
0,0,(__vptp)__glplayRecording__16CachingEv0 ,
0,0,0};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\coveandt.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/coveandtiler.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);










struct Arc;

struct Backend;






typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;







struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};












struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};


struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;








struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};

struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;



struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;



struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};




extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

int __glMAXSTRIPSIZE__12CoveAndTil0 = 1000;

struct TrimRegion *__gl__ct__10TrimRegionFv (struct TrimRegion *);
extern struct __mptr* __ptbl_vec_____core_coveandtiler_c_____ct_[];

static void *__nw__FUi (size_t );

struct CoveAndTiler *__gl__ct__12CoveAndTilerFR7Bac0 (struct CoveAndTiler *__0this , struct TrimRegion *__0TrimRegion , struct Backend *__1b )
{ if (__0this || (__0this = (struct CoveAndTiler *)__nw__FUi ( sizeof (struct CoveAndTiler))
))( (__0this -> PTrimRegion= ((__0TrimRegion == 0 )?( (__0TrimRegion = (((struct TrimRegion *)((((char *)__0this ))+ 8)))), __gl__ct__10TrimRegionFv ( ((struct TrimRegion *)((((char *)__0this ))+
8))) ) :__0TrimRegion )), (__0this -> backend__12CoveAndTiler = __1b )) ;

return __0this ;

}



void __gl__dt__12CoveAndTilerFv (struct CoveAndTiler *__0this , 
int __0__free )
{ if (__0this )if (__0this ){ (__0__free & 2)?( (((void )( ((((struct TrimRegion *)((((char
*)__0this ))+ 8)))?( ((((struct TrimRegion *)((((char *)__0this ))+ 8)))?( ( __gl__dt__6UarrayFv ( (struct Uarray *)(& (((struct TrimRegion *)((((char *)__0this ))+ 8)))->
uarray__10TrimRegion ), 2) , ( __gl__dt__8TrimlineFv ( (struct Trimline *)(& (((struct TrimRegion *)((((char *)__0this ))+ 8)))-> right__10TrimRegion ), 2) ,
( __gl__dt__8TrimlineFv ( (struct Trimline *)(& (((struct TrimRegion *)((((char *)__0this ))+ 8)))-> left__10TrimRegion ), 2) , (( 0 ) ))
) ) , 0 ) :( 0 ) ), 0 ) :( 0 ) )) )), 0 ) :0 ;
if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) )) ;
} }

void __gltmeshvert__7BackendFP10Gri0 (struct Backend *, struct GridVertex *);

void __gltmeshvert__7BackendFP10Tri0 (struct Backend *, struct TrimVertex *);

void __gltmeshvert__7BackendFP14Gri0 (struct Backend *, struct GridTrimVertex *);

void __gltile__12CoveAndTilerFlN21 (struct CoveAndTiler *, long , long , long );

void __glcoveUpperLeft__12CoveAndTi0 (struct CoveAndTiler *);

void __glcoveLowerLeft__12CoveAndTi0 (struct CoveAndTiler *);

void __glcoveUpperRight__12CoveAndT0 (struct CoveAndTiler *);

void __glcoveLowerRight__12CoveAndT0 (struct CoveAndTiler *);






void __glcoveUpperLeftNoGrid__12Cov0 (struct CoveAndTiler *, struct TrimVertex *);



void __glcoveLowerLeftNoGrid__12Cov0 (struct CoveAndTiler *, struct TrimVertex *);






void __glcoveUpperRightNoGrid__12Co0 (struct CoveAndTiler *, struct TrimVertex *);



void __glcoveLowerRightNoGrid__12Co0 (struct CoveAndTiler *, struct TrimVertex *);

void __glbgntmesh__7BackendFPc (struct Backend *, char *);




void __glendtmesh__7BackendFv (struct Backend *);


void __glcoveAndTile__12CoveAndTile0 (struct CoveAndTiler *__0this )
{ 
long __1ustart ;
long __1uend ;

__1ustart = ((__0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline >= __0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline )?__0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline :__0this -> PTrimRegion-> bot__10TrimRegion .
ustart__8Gridline );
__1uend = ((__0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline <= __0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline )?__0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline :__0this -> PTrimRegion-> bot__10TrimRegion .
uend__8Gridline );
if (__1ustart <= __1uend ){ 
__gltile__12CoveAndTilerFlN21 ( __0this , __0this -> PTrimRegion-> bot__10TrimRegion . vindex__8Gridline , __1ustart , __1uend ) ;
if (__0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline >= __0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline )
__glcoveUpperLeft__12CoveAndTi0 ( __0this ) ;
else 
__glcoveLowerLeft__12CoveAndTi0 ( __0this ) ;

if (__0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline <= __0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline )
__glcoveUpperRight__12CoveAndT0 ( __0this ) ;
else 
__glcoveLowerRight__12CoveAndT0 ( __0this ) ;
}
else 
{ 
struct TrimVertex __2blv ;

struct TrimVertex __2tlv ;

struct TrimVertex *__2bl ;

struct TrimVertex *__2tl ;
struct GridTrimVertex __2bllv ;

struct GridTrimVertex __2tllv ;
struct TrimVertex *__2lf ;
struct TrimVertex *__2ll ;

void *__1__Xp00uzigaiaa ;

( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)(& __2bllv ))-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)(& __2bllv ))->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)(& __2bllv ))-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)(& __2bllv ))))) ) ) ;
( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)(& __2tllv ))-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)(& __2tllv ))->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)(& __2tllv ))-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)(& __2tllv ))))) ) ) ;

__2lf = ( (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))->
pts__8Trimline [((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ])) ;
__2ll = ( (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> numverts__8Trimline ),
(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline )])) ;
if ((__2lf -> param__10TrimVertex [0 ])>= (__2ll -> param__10TrimVertex [0 ])){ 
(__2blv . param__10TrimVertex [0 ])= (__2lf -> param__10TrimVertex [0 ]);
(__2blv . param__10TrimVertex [1 ])= (__2ll -> param__10TrimVertex [1 ]);
__2blv . nuid__10TrimVertex = 0 ;
((void )0 );
__2bl = (& __2blv );
__2tl = __2lf ;
( (((struct GridTrimVertex *)(& __2tllv ))-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)(& __2tllv ))-> t__14GridTrimVertex = __2lf )) ;
if ((__2ll -> param__10TrimVertex [0 ])> (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [(__0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline - 1 )])){ 
( (((struct GridTrimVertex *)(&
__2bllv ))-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)(& __2bllv ))-> t__14GridTrimVertex = __2ll )) ;
((void )0 );
}
else 
{ 
( (((struct GridTrimVertex *)(& __2bllv ))-> g__14GridTrimVertex = (& ((struct GridTrimVertex *)(& __2bllv ))-> dummyg__14GridTrimVertex )), ( ((((struct
GridTrimVertex *)(& __2bllv ))-> dummyg__14GridTrimVertex . gparam__10GridVertex [0 ])= (__0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline - 1 )), ((((struct GridTrimVertex *)(& __2bllv ))-> dummyg__14GridTrimVertex . gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> bot__10TrimRegion . vindex__8Gridline )) ) ;
}
__glcoveUpperLeftNoGrid__12Cov0 ( __0this , __2bl ) ;
}
else 
{ 
(__2tlv . param__10TrimVertex [0 ])= (__2ll -> param__10TrimVertex [0 ]);
(__2tlv . param__10TrimVertex [1 ])= (__2lf -> param__10TrimVertex [1 ]);
__2tlv . nuid__10TrimVertex = 0 ;
((void )0 );
__2tl = (& __2tlv );
__2bl = __2ll ;
( (((struct GridTrimVertex *)(& __2bllv ))-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)(& __2bllv ))-> t__14GridTrimVertex = __2ll )) ;
if ((__2lf -> param__10TrimVertex [0 ])> (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [(__0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline - 1 )])){ 
((void )0 );
( (((struct GridTrimVertex *)(& __2tllv ))-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)(& __2tllv ))-> t__14GridTrimVertex = __2lf )) ;
}
else 
{ 
( (((struct GridTrimVertex *)(& __2tllv ))-> g__14GridTrimVertex = (& ((struct GridTrimVertex *)(& __2tllv ))-> dummyg__14GridTrimVertex )), ( ((((struct
GridTrimVertex *)(& __2tllv ))-> dummyg__14GridTrimVertex . gparam__10GridVertex [0 ])= (__0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline - 1 )), ((((struct GridTrimVertex *)(& __2tllv ))-> dummyg__14GridTrimVertex . gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> top__10TrimRegion . vindex__8Gridline )) ) ;
}
__glcoveLowerLeftNoGrid__12Cov0 ( __0this , __2tl ) ;
}

{ struct TrimVertex __2brv ;

struct TrimVertex __2trv ;

struct TrimVertex *__2br ;

struct TrimVertex *__2tr ;
struct GridTrimVertex __2brrv ;

struct GridTrimVertex __2trrv ;
struct TrimVertex *__2rf ;
struct TrimVertex *__2rl ;

void *__1__Xp00uzigaiaa ;

( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)(& __2brrv ))-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)(& __2brrv ))->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)(& __2brrv ))-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)(& __2brrv ))))) ) ) ;
( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)(& __2trrv ))-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)(& __2trrv ))->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)(& __2trrv ))-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)(& __2trrv ))))) ) ) ;

__2rf = ( (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))->
pts__8Trimline [((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ])) ;
__2rl = ( (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> numverts__8Trimline ),
(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline )])) ;

if ((__2rf -> param__10TrimVertex [0 ])<= (__2rl -> param__10TrimVertex [0 ])){ 
(__2brv . param__10TrimVertex [0 ])= (__2rf -> param__10TrimVertex [0 ]);
(__2brv . param__10TrimVertex [1 ])= (__2rl -> param__10TrimVertex [1 ]);
__2brv . nuid__10TrimVertex = 0 ;
((void )0 );
__2br = (& __2brv );
__2tr = __2rf ;
( (((struct GridTrimVertex *)(& __2trrv ))-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)(& __2trrv ))-> t__14GridTrimVertex = __2rf )) ;
if ((__2rl -> param__10TrimVertex [0 ])< (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [(__0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline + 1 )])){ 
((void )0 );
( (((struct GridTrimVertex *)(& __2brrv ))-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)(& __2brrv ))-> t__14GridTrimVertex = __2rl )) ;
}
else 
{ 
( (((struct GridTrimVertex *)(& __2brrv ))-> g__14GridTrimVertex = (& ((struct GridTrimVertex *)(& __2brrv ))-> dummyg__14GridTrimVertex )), ( ((((struct
GridTrimVertex *)(& __2brrv ))-> dummyg__14GridTrimVertex . gparam__10GridVertex [0 ])= (__0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline + 1 )), ((((struct GridTrimVertex *)(& __2brrv ))-> dummyg__14GridTrimVertex . gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> bot__10TrimRegion . vindex__8Gridline )) ) ;
}
__glcoveUpperRightNoGrid__12Co0 ( __0this , __2br ) ;
}
else 
{ 
(__2trv . param__10TrimVertex [0 ])= (__2rl -> param__10TrimVertex [0 ]);
(__2trv . param__10TrimVertex [1 ])= (__2rf -> param__10TrimVertex [1 ]);
__2trv . nuid__10TrimVertex = 0 ;
((void )0 );
__2tr = (& __2trv );
__2br = __2rl ;
( (((struct GridTrimVertex *)(& __2brrv ))-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)(& __2brrv ))-> t__14GridTrimVertex = __2rl )) ;
if ((__2rf -> param__10TrimVertex [0 ])< (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [(__0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline + 1 )])){ 
((void )0 );
( (((struct GridTrimVertex *)(& __2trrv ))-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)(& __2trrv ))-> t__14GridTrimVertex = __2rf )) ;
}
else 
{ 
( (((struct GridTrimVertex *)(& __2trrv ))-> g__14GridTrimVertex = (& ((struct GridTrimVertex *)(& __2trrv ))-> dummyg__14GridTrimVertex )), ( ((((struct
GridTrimVertex *)(& __2trrv ))-> dummyg__14GridTrimVertex . gparam__10GridVertex [0 ])= (__0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline + 1 )), ((((struct GridTrimVertex *)(& __2trrv ))-> dummyg__14GridTrimVertex . gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> top__10TrimRegion . vindex__8Gridline )) ) ;
}
__glcoveLowerRightNoGrid__12Co0 ( __0this , __2tr ) ;
}

__glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__12CoveAndTiler , (char *)"doit") ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridTrimVertex *)(& __2trrv ))) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridTrimVertex *)(& __2tllv ))) ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __2tr ) ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __2tl ) ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __2br ) ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __2bl ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridTrimVertex *)(& __2brrv ))) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridTrimVertex *)(& __2bllv ))) ) ;
__glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;

((void )( (( (( ( (((void )( ((((struct PooledObj *)((struct GridTrimVertex *)(& __2trrv ))))?( ((((struct PooledObj *)((struct GridTrimVertex *)(&
__2trrv ))))?( (( 0 ) ), 0 ) :( 0 ) ), 0 ) :( 0 ) )) )), ((
0 ) )) , 0 ) ), 0 ) )) );

((void )( (( (( ( (((void )( ((((struct PooledObj *)((struct GridTrimVertex *)(& __2brrv ))))?( ((((struct PooledObj *)((struct GridTrimVertex *)(&
__2brrv ))))?( (( 0 ) ), 0 ) :( 0 ) ), 0 ) :( 0 ) )) )), ((
0 ) )) , 0 ) ), 0 ) )) );

}

((void )( (( (( ( (((void )( ((((struct PooledObj *)((struct GridTrimVertex *)(& __2tllv ))))?( ((((struct PooledObj *)((struct GridTrimVertex *)(&
__2tllv ))))?( (( 0 ) ), 0 ) :( 0 ) ), 0 ) :( 0 ) )) )), ((
0 ) )) , 0 ) ), 0 ) )) );

((void )( (( (( ( (((void )( ((((struct PooledObj *)((struct GridTrimVertex *)(& __2bllv ))))?( ((((struct PooledObj *)((struct GridTrimVertex *)(&
__2bllv ))))?( (( 0 ) ), 0 ) :( 0 ) ), 0 ) :( 0 ) )) )), ((
0 ) )) , 0 ) ), 0 ) )) );
}
}

void __glsurfmesh__7BackendFlN31 (struct Backend *, long , long , long , long );

void __gltile__12CoveAndTilerFlN21 (struct CoveAndTiler *__0this , long __1vindex , long __1ustart , long __1uend )
{ 
long __1numsteps ;

__1numsteps = (__1uend - __1ustart );

if (__1numsteps == 0 )return ;

if (__1numsteps > 1000){ 
long __2umid ;

__2umid = (__1ustart + ((__1uend - __1ustart )/ 2 ));
__gltile__12CoveAndTilerFlN21 ( __0this , __1vindex , __1ustart , __2umid ) ;
__gltile__12CoveAndTilerFlN21 ( __0this , __1vindex , __2umid , __1uend ) ;
}
else 
{ 
__glsurfmesh__7BackendFlN31 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1ustart , __1vindex - 1 , __1numsteps , (long )1 ) ;
}
}






void __glswaptmesh__7BackendFv (struct Backend *);


void __glcoveUR__12CoveAndTilerFv (struct CoveAndTiler *);

void __glcoveUpperRight__12CoveAndT0 (struct CoveAndTiler *__0this )
{ 
struct GridVertex __1tgv ;
struct GridVertex __1gv ;

struct TrimVertex *__1__X6 ;

void *__1__Xp00uzigaiaa ;

( (( ((((struct GridVertex *)(& __1tgv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline ), ((((struct GridVertex *)(& __1tgv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> top__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1tgv ))))) ;
( (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline ), ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> bot__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1gv ))))) ;

( (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [((struct
Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ])) ;
__glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__12CoveAndTiler , (char *)"coveUpperRight") ;
( (__1__X6 = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))->
numverts__8Trimline )?(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ),
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1__X6 ) ) ) ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1tgv ))) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1gv ))) ) ;
__glcoveUR__12CoveAndTilerFv ( __0this ) ;
__glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}





void __glcoveUpperRightNoGrid__12Co0 (struct CoveAndTiler *__0this , struct TrimVertex *__1br )
{ 
struct TrimVertex *__1__X7 ;

struct TrimVertex *__1__X8 ;

__glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__12CoveAndTiler , (char *)"coveUpperRight") ;
( (__1__X7 = ( (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> PTrimRegion->
right__10TrimRegion ))-> pts__8Trimline [((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ])) ), ( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1__X7 )
) ) ;
( (__1__X8 = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))->
numverts__8Trimline )?(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ),
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1__X8 ) ) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1br ) ) ;
__glcoveUR__12CoveAndTilerFv ( __0this ) ;
__glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}












void __glcoveUR__12CoveAndTilerFv (struct CoveAndTiler *__0this )
{ 
struct GridVertex __1gv ;
struct TrimVertex *__1vert ;

void *__1__Xp00uzigaiaa ;

( (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline ), ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> bot__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1gv ))))) ;
__1vert = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> numverts__8Trimline )?(((struct
Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ;
if (__1vert == 0 )return ;

((void )0 );

if (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])++ )) >= __0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline ){ 
for(;__1vert ;__1vert = (
((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> numverts__8Trimline )?(((struct Trimline *)(& __0this ->
PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ) { 
( __gltmeshvert__7BackendFP10Tri0 (
(struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}
}
else 
while (1 ){ 
if ((__1vert -> param__10TrimVertex [0 ])< (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [(__1gv . gparam__10GridVertex [0 ])])){ 
( __gltmeshvert__7BackendFP10Tri0 ( (struct
Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
__1vert = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> numverts__8Trimline )?(((struct
Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ;
if (__1vert == 0 )break ;
}
else 
{ 
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1gv ))) ) ;
if (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])++ )) == __0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline ){ 
for(;__1vert ;__1vert = (
((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> numverts__8Trimline )?(((struct Trimline *)(& __0this ->
PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ) { 
( __gltmeshvert__7BackendFP10Tri0 (
(struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}
break ;
}
}
}
}







void __glcoveUL__12CoveAndTilerFv (struct CoveAndTiler *);

void __glcoveUpperLeft__12CoveAndTi0 (struct CoveAndTiler *__0this )
{ 
struct GridVertex __1tgv ;
struct GridVertex __1gv ;

struct TrimVertex *__1__X9 ;

void *__1__Xp00uzigaiaa ;

( (( ((((struct GridVertex *)(& __1tgv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline ), ((((struct GridVertex *)(& __1tgv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> top__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1tgv ))))) ;
( (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline ), ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> bot__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1gv ))))) ;

( (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [((struct
Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ])) ;
__glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__12CoveAndTiler , (char *)"coveUpperLeft") ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1tgv ))) ) ;
( (__1__X9 = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))->
numverts__8Trimline )?(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ),
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1__X9 ) ) ) ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1gv ))) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
__glcoveUL__12CoveAndTilerFv ( __0this ) ;
__glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}





void __glcoveUpperLeftNoGrid__12Cov0 (struct CoveAndTiler *__0this , struct TrimVertex *__1bl )
{ 
struct TrimVertex *__1__X10 ;

struct TrimVertex *__1__X11 ;

__glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__12CoveAndTiler , (char *)"coveUpperLeftNoGrid") ;
( (__1__X10 = ( (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> PTrimRegion->
left__10TrimRegion ))-> pts__8Trimline [((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ])) ), ( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1__X10 )
) ) ;
( (__1__X11 = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))->
numverts__8Trimline )?(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ),
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1__X11 ) ) ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1bl ) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
__glcoveUL__12CoveAndTilerFv ( __0this ) ;
__glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}












void __glcoveUL__12CoveAndTilerFv (struct CoveAndTiler *__0this )
{ 
struct GridVertex __1gv ;
struct TrimVertex *__1vert ;

void *__1__Xp00uzigaiaa ;

( (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline ), ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> bot__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1gv ))))) ;
__1vert = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> numverts__8Trimline )?(((struct
Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ;
if (__1vert == 0 )return ;
((void )0 );

if (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])-- )) <= __0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline ){ 
for(;__1vert ;__1vert = (
((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> numverts__8Trimline )?(((struct Trimline *)(& __0this ->
PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ) { 
__glswaptmesh__7BackendFv ( (struct
Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
}
}
else 
while (1 ){ 
if ((__1vert -> param__10TrimVertex [0 ])> (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [(__1gv . gparam__10GridVertex [0 ])])){ 
__glswaptmesh__7BackendFv ( (struct Backend *)__0this ->
backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
__1vert = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> numverts__8Trimline )?(((struct
Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ;
if (__1vert == 0 )break ;
}
else 
{ 
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1gv ))) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
if (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])-- )) == __0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline ){ 
for(;__1vert ;__1vert = (
((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline < ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> numverts__8Trimline )?(((struct Trimline *)(& __0this ->
PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ) { 
__glswaptmesh__7BackendFv ( (struct
Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
}
break ;
}
}
}
}






void __glcoveLL__12CoveAndTilerFv (struct CoveAndTiler *);

void __glcoveLowerLeft__12CoveAndTi0 (struct CoveAndTiler *__0this )
{ 
struct GridVertex __1bgv ;
struct GridVertex __1gv ;

struct TrimVertex *__1__X12 ;

void *__1__Xp00uzigaiaa ;

( (( ((((struct GridVertex *)(& __1bgv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline ), ((((struct GridVertex *)(& __1bgv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> bot__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1bgv ))))) ;
( (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline ), ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> top__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1gv ))))) ;

( (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> numverts__8Trimline ), (((struct
Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline )])) ;
__glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__12CoveAndTiler , (char *)"coveLowerLeft") ;
( (__1__X12 = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))->
pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ), ( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler ,
__1__X12 ) ) ) ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1bgv ))) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1gv ))) ) ;
__glcoveLL__12CoveAndTilerFv ( __0this ) ;
__glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}





void __glcoveLowerLeftNoGrid__12Cov0 (struct CoveAndTiler *__0this , struct TrimVertex *__1tl )
{ 
struct TrimVertex *__1__X13 ;

struct TrimVertex *__1__X14 ;

__glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__12CoveAndTiler , (char *)"coveLowerLeft") ;
( (__1__X13 = ( (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))->
numverts__8Trimline ), (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline )])) ),
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1__X13 ) ) ) ;
( (__1__X14 = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))->
pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ), ( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler ,
__1__X14 ) ) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1tl ) ) ;
__glcoveLL__12CoveAndTilerFv ( __0this ) ;
__glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}












void __glcoveLL__12CoveAndTilerFv (struct CoveAndTiler *__0this )
{ 
struct GridVertex __1gv ;
struct TrimVertex *__1vert ;

void *__1__Xp00uzigaiaa ;

( (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline ), ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> top__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1gv ))))) ;
__1vert = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct
Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ;
if (__1vert == 0 )return ;
((void )0 );

if (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])-- )) <= __0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline ){ 
for(;__1vert ;__1vert = (
((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this ->
PTrimRegion-> left__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ) { 
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) )
;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}
}
else 
while (1 ){ 
if ((__1vert -> param__10TrimVertex [0 ])> (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [(__1gv . gparam__10GridVertex [0 ])])){ 
( __gltmeshvert__7BackendFP10Tri0 ( (struct
Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
__1vert = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct
Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ;
if (__1vert == 0 )break ;
}
else 
{ 
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1gv ))) ) ;
if (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])-- )) == __0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline ){ 
for(;__1vert ;__1vert = (
((((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this ->
PTrimRegion-> left__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ) { 
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) )
;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}
break ;
}
}
}
}







void __glcoveLR__12CoveAndTilerFv (struct CoveAndTiler *);

void __glcoveLowerRight__12CoveAndT0 (struct CoveAndTiler *__0this )
{ 
struct GridVertex __1bgv ;
struct GridVertex __1gv ;

struct TrimVertex *__1__X15 ;

void *__1__Xp00uzigaiaa ;

( (( ((((struct GridVertex *)(& __1bgv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline ), ((((struct GridVertex *)(& __1bgv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> bot__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1bgv ))))) ;
( (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline ), ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> top__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1gv ))))) ;

( (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> numverts__8Trimline ), (((struct
Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline )])) ;
__glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__12CoveAndTiler , (char *)"coveLowerRight") ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1bgv ))) ) ;
( (__1__X15 = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))->
pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ), ( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler ,
__1__X15 ) ) ) ;
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1gv ))) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
__glcoveLR__12CoveAndTilerFv ( __0this ) ;
__glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}





void __glcoveLowerRightNoGrid__12Co0 (struct CoveAndTiler *__0this , struct TrimVertex *__1tr )
{ 
struct TrimVertex *__1__X16 ;

struct TrimVertex *__1__X17 ;

__glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__12CoveAndTiler , (char *)"coveLowerRIght") ;
( (__1__X16 = ( (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))->
numverts__8Trimline ), (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline )])) ),
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1__X16 ) ) ) ;
( (__1__X17 = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))->
pts__8Trimline [(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ), ( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler ,
__1__X17 ) ) ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1tr ) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
__glcoveLR__12CoveAndTilerFv ( __0this ) ;
__glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
}












void __glcoveLR__12CoveAndTilerFv (struct CoveAndTiler *__0this )
{ 
struct GridVertex __1gv ;
struct TrimVertex *__1vert ;

void *__1__Xp00uzigaiaa ;

( (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])= __0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline ), ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [1 ])=
__0this -> PTrimRegion-> top__10TrimRegion . vindex__8Gridline )) ), ((((struct GridVertex *)(& __1gv ))))) ;
__1vert = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct
Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ;
if (__1vert == 0 )return ;
((void )0 );

if (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])++ )) >= __0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline ){ 
for(;__1vert ;__1vert = (
((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this ->
PTrimRegion-> right__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ) { 
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
}
}
else 
while (1 ){ 
if ((__1vert -> param__10TrimVertex [0 ])< (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [(__1gv . gparam__10GridVertex [0 ])])){ 
__glswaptmesh__7BackendFv ( (struct Backend *)__0this ->
backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
__1vert = ( ((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct
Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ;
if (__1vert == 0 )break ;
}
else 
{ 
( __gltmeshvert__7BackendFP10Gri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , ((struct GridVertex *)(& __1gv ))) ) ;
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
if (( ((((struct GridVertex *)(& __1gv ))-> gparam__10GridVertex [0 ])++ )) == __0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline ){ 
for(;__1vert ;__1vert = (
((((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline >= 0 )?(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(((struct Trimline *)(& __0this ->
PTrimRegion-> right__10TrimRegion ))-> i__8Trimline -- )]):(((struct TrimVertex *)0 )))) ) { 
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__12CoveAndTiler ) ;
( __gltmeshvert__7BackendFP10Tri0 ( (struct Backend *)__0this -> backend__12CoveAndTiler , __1vert ) ) ;
}
break ;
}
}
}
}

static void *__nw__FUi (
size_t __1s )
{ 
void *__1__Xp00uzigaiaa ;

__1__Xp00uzigaiaa = malloc ( __1s ) ;
if (__1__Xp00uzigaiaa ){ 
return __1__Xp00uzigaiaa ;
}
else 
{ 
return __1__Xp00uzigaiaa ;
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\curvelis.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/curvelist.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);











struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct Backend;

struct Mapdesc;

struct Flist;

struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;



struct Mapdesc;


struct Curve;

struct Curvelist;

struct Curvelist {	

struct Curve *curve__9Curvelist ;
float range__9Curvelist [3];
int needsSubdivision__9Curvelist ;
float stepsize__9Curvelist ;
};



struct Mapdesc;


struct Curve;

struct Curve {	

struct Curve *next__5Curve ;

struct Mapdesc *mapdesc__5Curve ;
int stride__5Curve ;
int order__5Curve ;
int cullval__5Curve ;
int needsSampling__5Curve ;
REAL cpts__5Curve [120];
REAL spts__5Curve [120];
REAL stepsize__5Curve ;
REAL minstepsize__5Curve ;
REAL range__5Curve [3];
};






struct Curve *__gl__ct__5CurveFP5QuiltfT2P5C0 (struct Curve *, struct Quilt *, REAL , REAL , struct Curve *);
extern struct __mptr* __ptbl_vec_____core_curvelist_c_____ct_[];


struct Curvelist *__gl__ct__9CurvelistFP5QuiltfT0 (struct Curvelist *__0this , struct Quilt *__1quilts , REAL __1pta , REAL __1ptb )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Curvelist *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Curvelist))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> curve__9Curvelist = 0 ;
{ { struct Quilt *__1q ;

struct Curve *__0__X5 ;

__1q = __1quilts ;

for(;__1q ;__1q = __1q -> next__5Quilt ) 
__0this -> curve__9Curvelist = __gl__ct__5CurveFP5QuiltfT2P5C0 ( (struct Curve *)0 , __1q , __1pta , __1ptb , __0this -> curve__9Curvelist ) ;

(__0this -> range__9Curvelist [0 ])= __1pta ;
(__0this -> range__9Curvelist [1 ])= __1ptb ;
(__0this -> range__9Curvelist [2 ])= (__1ptb - __1pta );

}

}
} return __0this ;

}

struct Curve *__gl__ct__5CurveFR5CurvefP5Cur0 (struct Curve *, struct Curve *, REAL , struct Curve *);


struct Curvelist *__gl__ct__9CurvelistFR9Curveli0 (struct Curvelist *__0this , struct Curvelist *__1upper , REAL __1value )
{ 
struct Curvelist *__1lower ;

void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Curvelist *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Curvelist))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__1lower = (struct Curvelist *)__0this ;
__0this -> curve__9Curvelist = 0 ;
{ { struct Curve *__1c ;

struct Curve *__0__X6 ;

__1c = ((*__1upper )). curve__9Curvelist ;

for(;__1c ;__1c = __1c -> next__5Curve ) 
__0this -> curve__9Curvelist = __gl__ct__5CurveFR5CurvefP5Cur0 ( (struct Curve *)0 , (struct Curve *)__1c , __1value , __0this -> curve__9Curvelist ) ;

(((*__1lower )). range__9Curvelist [0 ])= (((*__1upper )). range__9Curvelist [0 ]);
(((*__1lower )). range__9Curvelist [1 ])= __1value ;
(((*__1lower )). range__9Curvelist [2 ])= (__1value - (((*__1upper )). range__9Curvelist [0 ]));
(((*__1upper )). range__9Curvelist [0 ])= __1value ;
(((*__1upper )). range__9Curvelist [2 ])= ((((*__1upper )). range__9Curvelist [1 ])- __1value );

}

}
} return __0this ;

}


void __gl__dt__9CurvelistFv (struct Curvelist *__0this , 
int __0__free )
{ if (__0this ){ 
while (__0this -> curve__9Curvelist ){ 
struct Curve *__2c ;

__2c = __0this -> curve__9Curvelist ;
__0this -> curve__9Curvelist = __0this -> curve__9Curvelist -> next__5Curve ;
( (((void *)__2c )?( free ( ((void *)__2c )) , 0 ) :( 0 ) )) ;
}
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}

int __glcullCheck__5CurveFv (struct Curve *);

int __glcullCheck__9CurvelistFv (struct Curvelist *__0this )
{ 
{ { struct Curve *__1c ;

__1c = __0this -> curve__9Curvelist ;

for(;__1c ;__1c = __1c -> next__5Curve ) 
if (__glcullCheck__5CurveFv ( (struct Curve *)__1c ) == 0 )
return 0 ;
return 2 ;

}

}
}

void __glgetstepsize__5CurveFv (struct Curve *);

void __glclamp__5CurveFv (struct Curve *);

int __glneedsSamplingSubdivision__0 (struct Curve *);

void __glgetstepsize__9CurvelistFv (struct Curvelist *__0this )
{ 
__0this -> stepsize__9Curvelist = (__0this -> range__9Curvelist [2 ]);
{ { struct Curve *__1c ;

__1c = __0this -> curve__9Curvelist ;

for(;__1c ;__1c = __1c -> next__5Curve ) { 
__glgetstepsize__5CurveFv ( (struct Curve *)__1c ) ;
__glclamp__5CurveFv ( (struct Curve *)__1c ) ;
__0this -> stepsize__9Curvelist = ((__1c -> stepsize__5Curve < __0this -> stepsize__9Curvelist )?__1c -> stepsize__5Curve :__0this -> stepsize__9Curvelist );
if (__glneedsSamplingSubdivision__0 ( (struct Curve *)__1c ) )break ;
}
__0this -> needsSubdivision__9Curvelist = (__1c ?1 :0 );

}

}
}

int __glneedsSamplingSubdivision__1 (struct Curvelist *__0this )
{ 
return __0this -> needsSubdivision__9Curvelist ;
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\errinit.c ===
/******************************Module*Header*******************************\
* Module Name: errinit.c
*
* Initialize the NURBS error string tables.
*
* Created: 18-Feb-1994 00:06:53
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include "..\glu32\glstring.h"

static UINT auiNurbsErrors[] = {
    STR_NURB_00,    // " "
    STR_NURB_01,    // "spline order un-supported"
    STR_NURB_02,    // "too few knots"
    STR_NURB_03,    // "valid knot range is empty"
    STR_NURB_04,    // "decreasing knot sequence knot"
    STR_NURB_05,    // "knot multiplicity greater than order of spline"
    STR_NURB_06,    // "endcurve() must follow bgncurve()"
    STR_NURB_07,    // "bgncurve() must precede endcurve()"
    STR_NURB_08,    // "missing or extra geometric data"
    STR_NURB_09,    // "can't draw pwlcurves"
    STR_NURB_10,    // "missing or extra domain data"
    STR_NURB_11,    // "missing or extra domain data"
    STR_NURB_12,    // "endtrim() must precede endsurface()"
    STR_NURB_13,    // "bgnsurface() must precede endsurface()"
    STR_NURB_14,    // "curve of improper type passed as trim curve"
    STR_NURB_15,    // "bgnsurface() must precede bgntrim()"
    STR_NURB_16,    // "endtrim() must follow bgntrim()"
    STR_NURB_17,    // "bgntrim() must precede endtrim()"
    STR_NURB_18,    // "invalid or missing trim curve"
    STR_NURB_19,    // "bgntrim() must precede pwlcurve()"
    STR_NURB_20,    // "pwlcurve referenced twice"
    STR_NURB_21,    // "pwlcurve and nurbscurve mixed"
    STR_NURB_22,    // "improper usage of trim data type"
    STR_NURB_23,    // "nurbscurve referenced twice"
    STR_NURB_24,    // "nurbscurve and pwlcurve mixed"
    STR_NURB_25,    // "nurbssurface referenced twice"
    STR_NURB_26,    // "invalid property"
    STR_NURB_27,    // "endsurface() must follow bgnsurface()"
    STR_NURB_28,    // "intersecting or misoriented trim curves"
    STR_NURB_29,    // "intersecting trim curves"
    STR_NURB_30,    // "UNUSED"
    STR_NURB_31,    // "unconnected trim curves"
    STR_NURB_32,    // "unknown knot error"
    STR_NURB_33,    // "negative vertex count encountered"
    STR_NURB_34,    // "negative byte-stride encounteed"
    STR_NURB_35,    // "unknown type descriptor"
    STR_NURB_36,    // "null control point reference"
    STR_NURB_37     // "duplicate point on pwlcurve"
};

#define NERRORS ( sizeof(auiNurbsErrors)/sizeof(auiNurbsErrors[0]) )

char *__glNurbsErrors[NERRORS];
WCHAR *__glNurbsErrorsW[NERRORS];

VOID vInitNurbStrings(HINSTANCE hMod, BOOL bAnsi)
{
    int i;

    if (bAnsi)
    {
        for (i = 0; i < NERRORS; i++)
            __glNurbsErrors[i] = pszGetResourceStringA(hMod, auiNurbsErrors[i]);
    }
    else
    {
        for (i = 0; i < NERRORS; i++)
            __glNurbsErrorsW[i] = pwszGetResourceStringW(hMod, auiNurbsErrors[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\curvesub.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/curvesub.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct JumpBuffer;








struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};




struct Renderhints;

struct Renderhints {	

REAL display_method__11Renderhints ;
REAL errorchecking__11Renderhints ;
REAL subdivisions__11Renderhints ;
REAL tmp1__11Renderhints ;

int displaydomain__11Renderhints ;
int maxsubdivisions__11Renderhints ;
int wiretris__11Renderhints ;
int wirequads__11Renderhints ;
};






struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};






struct Mapdesc;


struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;



struct Mapdesc;


struct Curve;

struct Curvelist;

struct Curvelist {	

struct Curve *curve__9Curvelist ;
float range__9Curvelist [3];
int needsSubdivision__9Curvelist ;
float stepsize__9Curvelist ;
};




struct Mapdesc;


struct Curve;

struct Curve {	

struct Curve *next__5Curve ;

struct Mapdesc *mapdesc__5Curve ;
int stride__5Curve ;
int order__5Curve ;
int cullval__5Curve ;
int needsSampling__5Curve ;
REAL cpts__5Curve [120];
REAL spts__5Curve [120];
REAL stepsize__5Curve ;
REAL minstepsize__5Curve ;
REAL range__5Curve [3];
};



struct Flist *__gl__ct__5FlistFv (struct Flist *);

void __glgetRange__5QuiltFPfT1R5Fli1 (struct Quilt *, REAL *, REAL *, struct Flist *);

void __glinit__11RenderhintsFv (struct Renderhints *);

void __glbgncurv__7BackendFv (struct Backend *);

void __gldownloadAll__5QuiltFPfT1R70 (struct Quilt *, REAL *, REAL *, struct Backend *);

struct Curvelist *__gl__ct__9CurvelistFP5QuiltfT0 (struct Curvelist *, struct Quilt *, REAL , REAL );

void __glsamplingSplit__10Subdivide0 (struct Subdivider *, struct Curvelist *, int );

void __glendcurv__7BackendFv (struct Backend *);
extern struct __mptr* __ptbl_vec_____core_curvesub_c___drawCurves_[];

void __gl__dt__5FlistFv (struct Flist *, int );

void __gl__dt__9CurvelistFv (struct Curvelist *, int );

void __gldrawCurves__10SubdividerFv (struct Subdivider *__0this )
{ 
REAL __1from [1];

REAL __1to [1];
struct Flist __1bpts ;

__gl__ct__5FlistFv ( (struct Flist *)(& __1bpts )) ;
__glgetRange__5QuiltFPfT1R5Fli1 ( (struct Quilt *)__0this -> qlist__10Subdivider , (REAL *)__1from , (REAL *)__1to , (struct Flist *)(& __1bpts )) ;

__glinit__11RenderhintsFv ( (struct Renderhints *)__0this -> renderhints__10Subdivider ) ;

__glbgncurv__7BackendFv ( (struct Backend *)__0this -> backend__10Subdivider ) ;
{ { int __1i ;

__1i = __1bpts . start__5Flist ;

for(;__1i < (__1bpts . end__5Flist - 1 );__1i ++ ) { 
REAL __2pta ;

REAL __2ptb ;
__2pta = (__1bpts . pts__5Flist [__1i ]);
__2ptb = (__1bpts . pts__5Flist [(__1i + 1 )]);

__gldownloadAll__5QuiltFPfT1R70 ( (struct Quilt *)__0this -> qlist__10Subdivider , & __2pta , & __2ptb , __0this -> backend__10Subdivider ) ;

{ struct Curvelist __2curvelist ;

__gl__ct__9CurvelistFP5QuiltfT0 ( (struct Curvelist *)(& __2curvelist ), __0this -> qlist__10Subdivider , __2pta , __2ptb ) ;
__glsamplingSplit__10Subdivide0 ( __0this , (struct Curvelist *)(& __2curvelist ), ((*__0this -> renderhints__10Subdivider )). maxsubdivisions__11Renderhints ) ;

__gl__dt__9CurvelistFv ( (struct Curvelist *)(& __2curvelist ), 2) ;

}
}
__glendcurv__7BackendFv ( (struct Backend *)__0this -> backend__10Subdivider ) ;

}

}

__gl__dt__5FlistFv ( (struct Flist *)(& __1bpts ), 2) ;
}

int __glcullCheck__9CurvelistFv (struct Curvelist *);
void __glgetstepsize__9CurvelistFv (struct Curvelist *);
int __glneedsSamplingSubdivision__1 (struct Curvelist *);

struct Curvelist *__gl__ct__9CurvelistFR9Curveli0 (struct Curvelist *, struct Curvelist *, REAL );

void __glcurvgrid__7BackendFfT1l (struct Backend *, REAL , REAL , long );
void __glcurvmesh__7BackendFlT1 (struct Backend *, long , long );

void __glsamplingSplit__10Subdivide0 (struct Subdivider *__0this , struct Curvelist *__1curvelist , int __1subdivisions )
{ 
if (__glcullCheck__9CurvelistFv ( (struct Curvelist *)__1curvelist ) == 0 )return ;

__glgetstepsize__9CurvelistFv ( (struct Curvelist *)__1curvelist ) ;

if (__glneedsSamplingSubdivision__1 ( (struct Curvelist *)__1curvelist ) && (__1subdivisions > 0 )){ 
REAL __2mid ;
struct Curvelist __2lowerlist ;

__2mid = (((((*__1curvelist )). range__9Curvelist [0 ])+ (((*__1curvelist )). range__9Curvelist [1 ]))* 0.5 );
__gl__ct__9CurvelistFR9Curveli0 ( (struct Curvelist *)(& __2lowerlist ), __1curvelist , __2mid ) ;
__glsamplingSplit__10Subdivide0 ( __0this , (struct Curvelist *)(& __2lowerlist ), __1subdivisions - 1 ) ;
__glsamplingSplit__10Subdivide0 ( __0this , __1curvelist , __1subdivisions - 1 ) ;

__gl__dt__9CurvelistFv ( (struct Curvelist *)(& __2lowerlist ), 2) ;
}
else 
{ 
long __2nu ;

__2nu = (1 + (((long )((((*__1curvelist )). range__9Curvelist [2 ])/ ((*__1curvelist )). stepsize__9Curvelist ))));
__glcurvgrid__7BackendFfT1l ( (struct Backend *)__0this -> backend__10Subdivider , ((*__1curvelist )). range__9Curvelist [0 ], ((*__1curvelist )). range__9Curvelist [1 ], __2nu ) ;
__glcurvmesh__7BackendFlT1 ( (struct Backend *)__0this -> backend__10Subdivider , (long )0 , __2nu ) ;
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\curve.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <math.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/curve.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);












typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;




struct Mapdesc;

struct Quilt;

struct Curve;

struct Curve {	

struct Curve *next__5Curve ;

struct Mapdesc *mapdesc__5Curve ;
int stride__5Curve ;
int order__5Curve ;
int cullval__5Curve ;
int needsSampling__5Curve ;
REAL cpts__5Curve [120];
REAL spts__5Curve [120];
REAL stepsize__5Curve ;
REAL minstepsize__5Curve ;
REAL range__5Curve [3];
};





struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};








typedef REAL Maxmatrix [5][5];
struct Backend;



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};


void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);









struct Backend;


struct Flist;

struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;




void __glxformSampling__7MapdescFPf0 (struct Mapdesc *, REAL *, int , int , REAL *, int );

void __glxformCulling__7MapdescFPfi0 (struct Mapdesc *, REAL *, int , int , REAL *, int );

struct Curve *__gl__ct__5CurveFR5CurvefP5Cur0 (struct Curve *, struct Curve *, REAL , struct Curve *);
extern struct __mptr* __ptbl_vec_____core_curve_c_____ct_[];


struct Curve *__gl__ct__5CurveFP5QuiltfT2P5C0 (struct Curve *__0this , Quilt_ptr __1geo , REAL __1pta , REAL __1ptb , struct Curve *__1c )
{ 
struct Mapdesc *__0__X5 ;

void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Curve *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Curve))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> mapdesc__5Curve = __1geo -> mapdesc__5Quilt ;
__0this -> next__5Curve = __1c ;
__0this -> needsSampling__5Curve = (( (__0__X5 = (struct Mapdesc *)__0this -> mapdesc__5Curve ), ( ((( ((__0__X5 -> sampling_method__7Mapdesc == 5.0 )?1 :0 )) || (
((__0__X5 -> sampling_method__7Mapdesc == 6.0 )?1 :0 )) )|| ( ((__0__X5 -> sampling_method__7Mapdesc == 7.0 )?1 :0 )) )) ) ?1 :0 );
__0this -> cullval__5Curve = (( ((((struct Mapdesc *)__0this -> mapdesc__5Curve )-> culling_method__7Mapdesc != 0.0 )?1 :0 )) ?2 :1 );
__0this -> order__5Curve = (__1geo -> qspec__5Quilt [0 ]). order__9Quiltspec ;
__0this -> stride__5Curve = 5 ;

{ REAL *__1ps ;
Quiltspec_ptr __1qs ;

__1ps = __1geo -> cpts__5Quilt ;
__1qs = __1geo -> qspec__5Quilt ;
__1ps += __1qs -> offset__9Quiltspec ;
__1ps += ((__1qs -> index__9Quiltspec * __1qs -> order__9Quiltspec )* __1qs -> stride__9Quiltspec );
{ REAL *__1pend ;

__1pend = (__1ps + (__1qs -> order__9Quiltspec * __1qs -> stride__9Quiltspec ));

if (__0this -> needsSampling__5Curve )
__glxformSampling__7MapdescFPf0 ( (struct Mapdesc *)__0this -> mapdesc__5Curve , __1ps , __1qs -> order__9Quiltspec , __1qs -> stride__9Quiltspec , (float *)__0this -> spts__5Curve ,
__0this -> stride__5Curve ) ;

if (__0this -> cullval__5Curve == 2 )
__glxformCulling__7MapdescFPfi0 ( (struct Mapdesc *)__0this -> mapdesc__5Curve , __1ps , __1qs -> order__9Quiltspec , __1qs -> stride__9Quiltspec , (float *)__0this ->
cpts__5Curve , __0this -> stride__5Curve ) ;

(__0this -> range__5Curve [0 ])= (__1qs -> breakpoints__9Quiltspec [__1qs -> index__9Quiltspec ]);
(__0this -> range__5Curve [1 ])= (__1qs -> breakpoints__9Quiltspec [(__1qs -> index__9Quiltspec + 1 )]);
(__0this -> range__5Curve [2 ])= ((__0this -> range__5Curve [1 ])- (__0this -> range__5Curve [0 ]));

if ((__0this -> range__5Curve [0 ])!= __1pta ){ 
struct Curve __2lower ;

__gl__ct__5CurveFR5CurvefP5Cur0 ( (struct Curve *)(& __2lower ), (struct Curve *)__0this , __1pta , (struct Curve *)0 ) ;
__2lower . next__5Curve = __0this -> next__5Curve ;
((*__0this ))= __2lower ;
}
if ((__0this -> range__5Curve [1 ])!= __1ptb ){ 
struct Curve __2lower ;

__gl__ct__5CurveFR5CurvefP5Cur0 ( (struct Curve *)(& __2lower ), (struct Curve *)__0this , __1ptb , (struct Curve *)0 ) ;
}

}

}
} return __0this ;

}

void __glsubdivide__7MapdescFPfT1fi0 (struct Mapdesc *, REAL *, REAL *, REAL , int , int );


struct Curve *__gl__ct__5CurveFR5CurvefP5Cur0 (struct Curve *__0this , struct Curve *__1upper , REAL __1value , struct Curve *__1c )
{ 
struct Curve *__1lower ;

void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Curve *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Curve))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__1lower = (struct Curve *)__0this ;

((*__1lower )). next__5Curve = __1c ;
((*__1lower )). mapdesc__5Curve = ((*__1upper )). mapdesc__5Curve ;
((*__1lower )). needsSampling__5Curve = ((*__1upper )). needsSampling__5Curve ;
((*__1lower )). order__5Curve = ((*__1upper )). order__5Curve ;
((*__1lower )). stride__5Curve = ((*__1upper )). stride__5Curve ;
((*__1lower )). cullval__5Curve = ((*__1upper )). cullval__5Curve ;

{ REAL __1d ;

__1d = ((__1value - (((*__1upper )). range__5Curve [0 ]))/ (((*__1upper )). range__5Curve [2 ]));

if (__0this -> needsSampling__5Curve )
__glsubdivide__7MapdescFPfT1fi0 ( (struct Mapdesc *)__0this -> mapdesc__5Curve , (float *)((*__1upper )). spts__5Curve , (float *)((*__1lower )). spts__5Curve , __1d , ((*__1upper )).
stride__5Curve , ((*__1upper )). order__5Curve ) ;

if (__0this -> cullval__5Curve == 2 )
__glsubdivide__7MapdescFPfT1fi0 ( (struct Mapdesc *)__0this -> mapdesc__5Curve , (float *)((*__1upper )). cpts__5Curve , (float *)((*__1lower )). cpts__5Curve , __1d ,
((*__1upper )). stride__5Curve , ((*__1upper )). order__5Curve ) ;

(((*__1lower )). range__5Curve [0 ])= (((*__1upper )). range__5Curve [0 ]);
(((*__1lower )). range__5Curve [1 ])= __1value ;
(((*__1lower )). range__5Curve [2 ])= (__1value - (((*__1upper )). range__5Curve [0 ]));
(((*__1upper )). range__5Curve [0 ])= __1value ;
(((*__1upper )). range__5Curve [2 ])= ((((*__1upper )). range__5Curve [1 ])- __1value );

}
} return __0this ;

}

void __glclamp__5CurveFv (struct Curve *__0this )
{ 
if (__0this -> stepsize__5Curve < __0this -> minstepsize__5Curve )
__0this -> stepsize__5Curve = (__0this -> mapdesc__5Curve -> clampfactor__7Mapdesc * __0this -> minstepsize__5Curve );

}

void __glsetstepsize__5CurveFf (struct Curve *__0this , REAL __1max )
{ 
__0this -> stepsize__5Curve = ((__1max >= 1.0 )?((__0this -> range__5Curve [2 ])/ __1max ):(__0this -> range__5Curve [2 ]));
__0this -> minstepsize__5Curve = __0this -> stepsize__5Curve ;
}



int __glproject__7MapdescFPfiT1N22 (struct Mapdesc *, REAL *, int , REAL *, int , int );

REAL __glgetProperty__7MapdescFl (struct Mapdesc *, long );


REAL __glcalcPartialVelocity__7Mapd0 (struct Mapdesc *, REAL *, int , int , int , REAL );

// extern double sqrt (double );


void __glgetstepsize__5CurveFv (struct Curve *__0this )
{ 
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Curve )-> sampling_method__7Mapdesc == 3.0 )?1 :0 )) ){ 
__glsetstepsize__5CurveFf ( __0this , __0this ->
mapdesc__5Curve -> maxrate__7Mapdesc ) ;
}
else 
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Curve )-> sampling_method__7Mapdesc == 2.0 )?1 :0 )) ){ 
__glsetstepsize__5CurveFf ( __0this , __0this -> mapdesc__5Curve -> maxrate__7Mapdesc *
(__0this -> range__5Curve [2 ])) ;
}
else 
{ 
((void )0 );

{ REAL __2tmp [24][5];

int __2val ;

__2val = __glproject__7MapdescFPfiT1N22 ( (struct Mapdesc *)__0this -> mapdesc__5Curve , (float *)__0this -> spts__5Curve , __0this -> stride__5Curve , & ((__2tmp [0 ])[0 ]), (int )5,
__0this -> order__5Curve ) ;

if (__2val == 0 ){ 
__glsetstepsize__5CurveFf ( __0this , __0this -> mapdesc__5Curve -> maxrate__7Mapdesc ) ;
}
else 
{ 
REAL __3t ;

__3t = __glgetProperty__7MapdescFl ( (struct Mapdesc *)__0this -> mapdesc__5Curve , (long )1 ) ;
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Curve )-> sampling_method__7Mapdesc == 5.0 )?1 :0 )) ){ 
REAL __4d ;

__4d = __glcalcPartialVelocity__7Mapd0 ( (struct Mapdesc *)__0this -> mapdesc__5Curve , & ((__2tmp [0 ])[0 ]), (int )5, __0this -> order__5Curve , 2 , __0this -> range__5Curve [2 ])
;
__0this -> stepsize__5Curve = ((__4d > 0.0 )?sqrt ( (8.0 * __3t )/ __4d ) :(((double )(__0this -> range__5Curve [2 ]))));
__0this -> minstepsize__5Curve = ((__0this -> mapdesc__5Curve -> maxrate__7Mapdesc > 0.0 )?(((double )((__0this -> range__5Curve [2 ])/ __0this -> mapdesc__5Curve -> maxrate__7Mapdesc ))):0.0 );
}
else 
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Curve )-> sampling_method__7Mapdesc == 6.0 )?1 :0 )) ){ 
REAL __4d ;

__4d = __glcalcPartialVelocity__7Mapd0 ( (struct Mapdesc *)__0this -> mapdesc__5Curve , & ((__2tmp [0 ])[0 ]), (int )5, __0this -> order__5Curve , 1 , __0this -> range__5Curve [2 ])
;
__0this -> stepsize__5Curve = ((__4d > 0.0 )?(__3t / __4d ):(__0this -> range__5Curve [2 ]));
__0this -> minstepsize__5Curve = ((__0this -> mapdesc__5Curve -> maxrate__7Mapdesc > 0.0 )?(((double )((__0this -> range__5Curve [2 ])/ __0this -> mapdesc__5Curve -> maxrate__7Mapdesc ))):0.0 );
}
else 
{ 
__glsetstepsize__5CurveFf ( __0this , __0this -> mapdesc__5Curve -> maxrate__7Mapdesc ) ;
}
}

}
}
}

int __glneedsSamplingSubdivision__0 (struct Curve *__0this )
{ 
return ((__0this -> stepsize__5Curve < __0this -> minstepsize__5Curve )?1 :0 );
}

int __glcullCheck__7MapdescFPfiT2 (struct Mapdesc *, REAL *, int , int );

int __glcullCheck__5CurveFv (struct Curve *__0this )
{ 
if (__0this -> cullval__5Curve == 2 )
__0this -> cullval__5Curve = __glcullCheck__7MapdescFPfiT2 ( (struct Mapdesc *)__0this -> mapdesc__5Curve , (float *)__0this ->
cpts__5Curve , __0this -> order__5Curve , __0this -> stride__5Curve ) ;
return __0this -> cullval__5Curve ;
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\displayl.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/displaylist.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);





struct JumpBuffer;













struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};




struct Renderhints;

struct Renderhints {	

REAL display_method__11Renderhints ;
REAL errorchecking__11Renderhints ;
REAL subdivisions__11Renderhints ;
REAL tmp1__11Renderhints ;

int displaydomain__11Renderhints ;
int maxsubdivisions__11Renderhints ;
int wiretris__11Renderhints ;
int wirequads__11Renderhints ;
};






struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};






struct Mapdesc;

struct Maplist;

void __gl__dt__4PoolFv (struct Pool *, int );


struct Maplist {	

struct Pool mapdescPool__7Maplist ;
struct Mapdesc *maps__7Maplist ;
struct Mapdesc **lastmap__7Maplist ;
struct Backend *backend__7Maplist ;
};

struct Mapdesc *__gllocate__7MaplistFl (struct Maplist *, long );

void __glremove__7MaplistFP7Mapdesc (struct Maplist *, struct Mapdesc *);



enum Curvetype { ct_nurbscurve = 0, ct_pwlcurve = 1, ct_none = 2} ;
struct Property;

struct O_surface;

struct O_nurbssurface;

struct O_trim;

struct O_pwlcurve;

struct O_nurbscurve;

struct O_curve;

struct Quilt;


union __Q2_7O_curve4__C1;

union  __Q2_7O_curve4__C1 {	
struct O_nurbscurve *o_nurbscurve ;
struct O_pwlcurve *o_pwlcurve ;
};


struct O_curve;

struct O_curve {	

char __W3__9PooledObj ;

union  __Q2_7O_curve4__C1 curve__7O_curve ;
int curvetype__7O_curve ;
struct O_curve *next__7O_curve ;
struct O_surface *owner__7O_curve ;
int used__7O_curve ;
int save__7O_curve ;
long nuid__7O_curve ;
};






struct O_nurbscurve;

struct O_nurbscurve {	

char __W3__9PooledObj ;

struct Quilt *bezier_curves__12O_nurbscurve ;
long type__12O_nurbscurve ;
REAL tesselation__12O_nurbscurve ;
int method__12O_nurbscurve ;
struct O_nurbscurve *next__12O_nurbscurve ;
int used__12O_nurbscurve ;
int save__12O_nurbscurve ;
struct O_curve *owner__12O_nurbscurve ;
};






struct O_pwlcurve;



struct O_pwlcurve {	

char __W3__9PooledObj ;

struct TrimVertex *pts__10O_pwlcurve ;
int npts__10O_pwlcurve ;
struct O_pwlcurve *next__10O_pwlcurve ;
int used__10O_pwlcurve ;
int save__10O_pwlcurve ;
struct O_curve *owner__10O_pwlcurve ;
};



struct O_trim;

struct O_trim {	

char __W3__9PooledObj ;

struct O_curve *o_curve__6O_trim ;
struct O_trim *next__6O_trim ;
int save__6O_trim ;
};






struct O_nurbssurface;

struct O_nurbssurface {	

char __W3__9PooledObj ;

struct Quilt *bezier_patches__14O_nurbssurface ;
long type__14O_nurbssurface ;
struct O_surface *owner__14O_nurbssurface ;
struct O_nurbssurface *next__14O_nurbssurface ;
int save__14O_nurbssurface ;
int used__14O_nurbssurface ;
};






struct O_surface;

struct O_surface {	

char __W3__9PooledObj ;

struct O_nurbssurface *o_nurbssurface__9O_surface ;
struct O_trim *o_trim__9O_surface ;
int save__9O_surface ;
long nuid__9O_surface ;
};






struct Property;

struct Property {	

char __W3__9PooledObj ;

long type__8Property ;
long tag__8Property ;
REAL value__8Property ;
int save__8Property ;
};




struct NurbsTessellator;


struct Knotvector;

struct Quilt;

struct DisplayList;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct NurbsTessellator;

struct NurbsTessellator {	

struct Renderhints renderhints__16NurbsTessellator ;
struct Maplist maplist__16NurbsTessellator ;
struct Backend backend__16NurbsTessellator ;

struct Subdivider subdivider__16NurbsTessellator ;
struct JumpBuffer *jumpbuffer__16NurbsTessellator ;
struct Pool o_pwlcurvePool__16NurbsTessellator ;
struct Pool o_nurbscurvePool__16NurbsTessellator ;
struct Pool o_curvePool__16NurbsTessellator ;
struct Pool o_trimPool__16NurbsTessellator ;
struct Pool o_surfacePool__16NurbsTessellator ;
struct Pool o_nurbssurfacePool__16NurbsTessellator ;
struct Pool propertyPool__16NurbsTessellator ;
struct Pool quiltPool__16NurbsTessellator ;
struct TrimVertexPool extTrimVertexPool__16NurbsTessellator ;

int inSurface__16NurbsTessellator ;
int inCurve__16NurbsTessellator ;
int inTrim__16NurbsTessellator ;
int isCurveModified__16NurbsTessellator ;
int isTrimModified__16NurbsTessellator ;
int isSurfaceModified__16NurbsTessellator ;
int isDataValid__16NurbsTessellator ;
int numTrims__16NurbsTessellator ;
int playBack__16NurbsTessellator ;

struct O_trim **nextTrim__16NurbsTessellator ;
struct O_curve **nextCurve__16NurbsTessellator ;
struct O_nurbscurve **nextNurbscurve__16NurbsTessellator ;
struct O_pwlcurve **nextPwlcurve__16NurbsTessellator ;
struct O_nurbssurface **nextNurbssurface__16NurbsTessellator ;

struct O_surface *currentSurface__16NurbsTessellator ;
struct O_trim *currentTrim__16NurbsTessellator ;
struct O_curve *currentCurve__16NurbsTessellator ;

struct DisplayList *dl__16NurbsTessellator ;

struct __mptr *__vptr__16NurbsTessellator ;
};

extern char *__glNurbsErrors [];






typedef struct __mptr PFVS ;


struct Dlnode;



struct Dlnode {	

char __W3__9PooledObj ;

PFVS work__6Dlnode ;
void *arg__6Dlnode ;
PFVS cleanup__6Dlnode ;
struct Dlnode *next__6Dlnode ;
};

struct DisplayList;

struct DisplayList {	

struct Dlnode *nodes__11DisplayList ;
struct Pool dlnodePool__11DisplayList ;
struct Dlnode **lastNode__11DisplayList ;
struct NurbsTessellator *nt__11DisplayList ;
};



struct Pool *__gl__ct__4PoolFiT1Pc (struct Pool *, int , int , char *);
extern struct __mptr* __ptbl_vec_____core_displaylist_c_____ct_[];


struct DisplayList *__gl__ct__11DisplayListFP16Nur0 (struct DisplayList *__0this , struct NurbsTessellator *__1_nt )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct DisplayList *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct DisplayList))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){
__gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> dlnodePool__11DisplayList ), (int )(sizeof (struct Dlnode )), 1 , (char *)"dlnodepool")
;
__0this -> lastNode__11DisplayList = (& __0this -> nodes__11DisplayList );
__0this -> nt__11DisplayList = __1_nt ;
} return __0this ;

}


void __gl__dt__11DisplayListFv (struct DisplayList *__0this , 
int __0__free )
{ 
struct Dlnode *__1nextNode ;

if (__0this ){ 
{ ;

for(;__0this -> nodes__11DisplayList ;__0this -> nodes__11DisplayList = __1nextNode ) { 
__1nextNode = __0this -> nodes__11DisplayList -> next__6Dlnode ;
if (__0this -> nodes__11DisplayList -> cleanup__6Dlnode .i!= 0 )(__0this -> nodes__11DisplayList -> cleanup__6Dlnode .i< 0 )?((*(((void (*)(struct NurbsTessellator *, void *))__0this -> nodes__11DisplayList -> cleanup__6Dlnode .f))))(
(struct NurbsTessellator *)(((struct NurbsTessellator *)((((char *)__0this -> nt__11DisplayList ))+ __0this -> nodes__11DisplayList -> cleanup__6Dlnode .d))), __0this -> nodes__11DisplayList -> arg__6Dlnode ) :((*(((void (*)(struct NurbsTessellator *,
void *))(__0this -> nt__11DisplayList -> __vptr__16NurbsTessellator [__0this -> nodes__11DisplayList -> cleanup__6Dlnode .i]).f))))( (struct NurbsTessellator *)(((struct NurbsTessellator *)((((char *)__0this -> nt__11DisplayList ))+ (__0this -> nt__11DisplayList -> __vptr__16NurbsTessellator [__0this ->
nodes__11DisplayList -> cleanup__6Dlnode .i]).d))), __0this -> nodes__11DisplayList -> arg__6Dlnode ) ;

}

}
if (__0this ){ __gl__dt__4PoolFv ( (struct Pool *)(& __0this -> dlnodePool__11DisplayList ), 2) ;

if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) )) ;
} } }

void __glplay__11DisplayListFv (struct DisplayList *__0this )
{ 
{ { struct Dlnode *__1node ;

__1node = __0this -> nodes__11DisplayList ;

for(;__1node ;__1node = __1node -> next__6Dlnode ) 
if (__1node -> work__6Dlnode .i!= 0 )(__1node -> work__6Dlnode .i< 0 )?((*(((void (*)(struct NurbsTessellator *, void *))__1node -> work__6Dlnode .f))))(
(struct NurbsTessellator *)(((struct NurbsTessellator *)((((char *)__0this -> nt__11DisplayList ))+ __1node -> work__6Dlnode .d))), __1node -> arg__6Dlnode ) :((*(((void (*)(struct NurbsTessellator *, void *))(__0this ->
nt__11DisplayList -> __vptr__16NurbsTessellator [__1node -> work__6Dlnode .i]).f))))( (struct NurbsTessellator *)(((struct NurbsTessellator *)((((char *)__0this -> nt__11DisplayList ))+ (__0this -> nt__11DisplayList -> __vptr__16NurbsTessellator [__1node -> work__6Dlnode .i]).d))), __1node -> arg__6Dlnode )
;

}

}
}

void __glendList__11DisplayListFv (struct DisplayList *__0this )
{ 
((*__0this -> lastNode__11DisplayList ))= 0 ;
}



void __glappend__11DisplayListFM16N0 (struct DisplayList *__0this , PFVS __1work , void *__1arg , PFVS __1cleanup )
{ 
struct Dlnode *__1node ;

struct Dlnode *__0__X14 ;

void *__1__Xbuffer00eohgaiaa ;

struct __mptr __1__X15 ;

struct __mptr __1__X16 ;

__1node = ((__0__X14 = (struct Dlnode *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> dlnodePool__11DisplayList )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> dlnodePool__11DisplayList )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
dlnodePool__11DisplayList )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> dlnodePool__11DisplayList )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> dlnodePool__11DisplayList )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> dlnodePool__11DisplayList )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> dlnodePool__11DisplayList )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
dlnodePool__11DisplayList )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> dlnodePool__11DisplayList )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> dlnodePool__11DisplayList )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X15 =
__1work ), ( (__1__X16 = __1cleanup ), ( (((struct Dlnode *)__0__X14 )-> work__6Dlnode = __1__X15 ), ( (((struct Dlnode *)__0__X14 )-> arg__6Dlnode = __1arg ),
( (((struct Dlnode *)__0__X14 )-> cleanup__6Dlnode = __1__X16 ), ((((struct Dlnode *)__0__X14 )))) ) ) ) ) :0 );
((*__0this -> lastNode__11DisplayList ))= __1node ;
__0this -> lastNode__11DisplayList = (& __1node -> next__6Dlnode );
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\flist.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/flist.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);









typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;





struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};

extern struct __mptr* __ptbl_vec_____core_flist_c_____ct_[];

struct FlistSorter *__gl__ct__11FlistSorterFv (struct FlistSorter *);


struct Flist *__gl__ct__5FlistFv (struct Flist *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Flist *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Flist))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){
__gl__ct__11FlistSorterFv ( (struct FlistSorter *)(& __0this -> sorter__5Flist )) ;
__0this -> npts__5Flist = 0 ;
__0this -> pts__5Flist = 0 ;
__0this -> start__5Flist = (__0this -> end__5Flist = 0 );
} return __0this ;

}


void __gl__dt__5FlistFv (struct Flist *__0this , 
int __0__free )
{ 
void *__1__X5 ;

if (__0this ){ 
if (__0this -> npts__5Flist )( (__1__X5 = (void *)__0this -> pts__5Flist ), ( (__1__X5 ?( free ( __1__X5 ) ,
0 ) :( 0 ) )) ) ;
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}

void __gladd__5FlistFf (struct Flist *__0this , REAL __1x )
{ 
(__0this -> pts__5Flist [(__0this -> end__5Flist ++ )])= __1x ;
((void )0 );
}

void __glqsort__11FlistSorterFPfi (struct FlistSorter *, REAL *, int );

void __glfilter__5FlistFv (struct Flist *__0this )
{ 
__glqsort__11FlistSorterFPfi ( (struct FlistSorter *)(& __0this -> sorter__5Flist ), __0this -> pts__5Flist , __0this -> end__5Flist ) ;
__0this -> start__5Flist = 0 ;

{ int __1j ;

__1j = 0 ;
{ { int __1i ;

__1i = 1 ;

for(;__1i < __0this -> end__5Flist ;__1i ++ ) { 
if ((__0this -> pts__5Flist [__1i ])== (__0this -> pts__5Flist [((__1i - __1j )- 1 )]))
__1j ++ ;
(__0this -> pts__5Flist [(__1i - __1j )])= (__0this -> pts__5Flist [__1i ]);
}
__0this -> end__5Flist -= __1j ;

}

}

}
}



void __glgrow__5FlistFi (struct Flist *__0this , int __1maxpts )
{ 
if (__0this -> npts__5Flist < __1maxpts ){ 
void *__1__X6 ;

void *__1__Xp00uzigaiaa ;

if (__0this -> npts__5Flist )( (__1__X6 = (void *)__0this -> pts__5Flist ), ( (__1__X6 ?( free ( __1__X6 ) , 0 ) :(
0 ) )) ) ;
__0this -> npts__5Flist = (2 * __1maxpts );
__0this -> pts__5Flist = (((float *)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (float ))* __0this -> npts__5Flist )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void
*)__1__Xp00uzigaiaa )))) ));
((void )0 );
}
__0this -> start__5Flist = (__0this -> end__5Flist = 0 );
}

void __gltaper__5FlistFfT1 (struct Flist *__0this , REAL __1from , REAL __1to )
{ 
while ((__0this -> pts__5Flist [__0this -> start__5Flist ])!= __1from )
__0this -> start__5Flist ++ ;

while ((__0this -> pts__5Flist [(__0this -> end__5Flist - 1 )])!= __1to )
__0this -> end__5Flist -- ;
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\flistsor.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/flistsorter.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);





struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};




typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};


struct Sorter *__gl__ct__6SorterFi (struct Sorter *, int );
extern struct __mptr* __gl__ptbl_vec_____core_flists0[];


struct FlistSorter *__gl__ct__11FlistSorterFv (struct FlistSorter *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct FlistSorter *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct FlistSorter))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))(
(__0this = (struct FlistSorter *)__gl__ct__6SorterFi ( ((struct Sorter *)__0this ), (int )(sizeof (REAL ))) ), (__0this -> __vptr__6Sorter = (struct __mptr *) __gl__ptbl_vec_____core_flists0[0])) ;

return __0this ;

}

void __glqsort__11FlistSorterFPfi (struct FlistSorter *, REAL *, int );

void __glqsort__6SorterFPvi (struct Sorter *, void *, int );

void __glqsort__11FlistSorterFPfi (struct FlistSorter *__0this , REAL *__1p , int __1n )
{ 
__glqsort__6SorterFPvi ( (struct Sorter *)__0this , (void *)(((char *)__1p )), __1n ) ;

}

int __glqscmp__11FlistSorterFPcT1 (struct FlistSorter *__0this , char *__1i , char *__1j )
{ 
REAL __1f0 ;
REAL __1f1 ;

__1f0 = ((*(((REAL *)__1i ))));
__1f1 = ((*(((REAL *)__1j ))));
return ((__1f0 < __1f1 )?-1:1 );
}

void __glqsexc__11FlistSorterFPcT1 (struct FlistSorter *__0this , char *__1i , char *__1j )
{ 
REAL *__1f0 ;
REAL *__1f1 ;
REAL __1tmp ;

__1f0 = (((REAL *)__1i ));
__1f1 = (((REAL *)__1j ));
__1tmp = ((*__1f0 ));
((*__1f0 ))= ((*__1f1 ));
((*__1f1 ))= __1tmp ;
}

void __glqstexc__11FlistSorterFPcN20 (struct FlistSorter *__0this , char *__1i , char *__1j , char *__1k )
{ 
REAL *__1f0 ;
REAL *__1f1 ;
REAL *__1f2 ;
REAL __1tmp ;

__1f0 = (((REAL *)__1i ));
__1f1 = (((REAL *)__1j ));
__1f2 = (((REAL *)__1k ));
__1tmp = ((*__1f0 ));
((*__1f0 ))= ((*__1f2 ));
((*__1f2 ))= ((*__1f1 ));
((*__1f1 ))= __1tmp ;
}
struct __mptr __gl__vtbl__11FlistSorter[] = {0,0,0,
0,0,(__vptp)__glqscmp__11FlistSorterFPcT1 ,
0,0,(__vptp)__glqsexc__11FlistSorterFPcT1 ,
0,0,(__vptp)__glqstexc__11FlistSorterFPcN20 ,
0,0,0};
struct __mptr* __gl__ptbl_vec_____core_flists0[] = {
__gl__vtbl__11FlistSorter,

};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\glcurvev.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <windows.h>
#include <GL/gl.h>
#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../clients/glcurveval.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };



typedef unsigned int GLenum ;
typedef unsigned char GLboolean ;
typedef unsigned int GLbitfield ;
typedef signed char GLbyte ;
typedef short GLshort ;
typedef int GLint ;
typedef int GLsizei ;
typedef unsigned char GLubyte ;
typedef unsigned short GLushort ;
typedef unsigned int GLuint ;
typedef float GLfloat ;
typedef float GLclampf ;
typedef double GLdouble ;
typedef double GLclampd ;
typedef void GLvoid ;






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct CachingEvaluator;
enum __Q2_16CachingEvaluator11ServiceMode { play__Q2_16CachingEvaluator11ServiceMode = 0, record__Q2_16CachingEvaluator11ServiceMode = 1, playAndRecord__Q2_16CachingEvaluator11ServiceMode = 2} ;

struct CachingEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};



struct BasicCurveEvaluator;


struct BasicCurveEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

static void *__nw__FUi (size_t );


struct CurveMap;

struct OpenGLCurveEvaluator;

struct OpenGLCurveEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};





extern struct __mptr* __gl__ptbl_vec_____clients_glc0[];

struct OpenGLCurveEvaluator *__gl__ct__20OpenGLCurveEvaluat0 (struct OpenGLCurveEvaluator *__0this )
{ 
struct BasicCurveEvaluator *__0__X6 ;

struct CachingEvaluator *__0__X4 ;

void *__1__Xp0025pnaiaa ;

if (__0this || (__0this = (struct OpenGLCurveEvaluator *)__nw__FUi ( sizeof (struct OpenGLCurveEvaluator)) ))( (__0this = (struct OpenGLCurveEvaluator *)( (__0__X6 = (((struct BasicCurveEvaluator *)__0this ))),
( ((__0__X6 || (__0__X6 = (struct BasicCurveEvaluator *)__nw__FUi ( sizeof (struct BasicCurveEvaluator)) ))?( (__0__X6 = (struct BasicCurveEvaluator *)( (__0__X4 = (((struct CachingEvaluator *)__0__X6 ))),
( ((__0__X4 || (__0__X4 = (struct CachingEvaluator *)( (__1__Xp0025pnaiaa = malloc ( (sizeof (struct CachingEvaluator))) ), (__1__Xp0025pnaiaa ?(((void *)__1__Xp0025pnaiaa )):(((void *)__1__Xp0025pnaiaa )))) ))?(__0__X4 ->
__vptr__16CachingEvaluator = (struct __mptr *) __gl__ptbl_vec_____clients_glc0[0]):0 ), ((__0__X4 ))) ) ), (__0__X6 -> __vptr__16CachingEvaluator = (struct __mptr *) __gl__ptbl_vec_____clients_glc0[1])) :0 ), ((__0__X6 ))) ) ),
(__0this -> __vptr__16CachingEvaluator = (struct __mptr *) __gl__ptbl_vec_____clients_glc0[2])) ;
return __0this ;

}


void __gl__dt__20OpenGLCurveEvaluat0 (struct OpenGLCurveEvaluator *__0this , 
int __0__free )
{ if (__0this ){ 
__0this -> __vptr__16CachingEvaluator = (struct __mptr *) __gl__ptbl_vec_____clients_glc0[2];

if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}

void __gladdMap__20OpenGLCurveEvalu0 (struct OpenGLCurveEvaluator *__0this , struct CurveMap *__1m )
{ 
}

void __glrange1f__20OpenGLCurveEval0 (struct OpenGLCurveEvaluator *__0this , long __1type , REAL *__1from , REAL *__1to )
{ 
}

void
__gldomain1f__20OpenGLCurveEva0 (struct OpenGLCurveEvaluator *__0this , REAL __1ulo , REAL __1uhi )
{ 
}

// extern void glBegin (GLenum );

void __glbgnline__20OpenGLCurveEval0 (struct OpenGLCurveEvaluator *__0this )
{ 
glBegin ( (unsigned int )0x0003 ) ;
}

// extern void glEnd (void );

void __glendline__20OpenGLCurveEval0 (struct OpenGLCurveEvaluator *__0this )
{ 
glEnd ( ) ;
}

// extern void glDisable (GLenum );

void __gldisable__20OpenGLCurveEval0 (struct OpenGLCurveEvaluator *__0this , long __1type )
{ 
glDisable ( (unsigned int )__1type ) ;
}

// extern void glEnable (GLenum );

void __glenable__20OpenGLCurveEvalu0 (struct OpenGLCurveEvaluator *__0this , long __1type )
{ 
glEnable ( (unsigned int )__1type ) ;
}

// extern void glMapGrid1f (GLint , GLfloat , GLfloat );

void __glmapgrid1f__20OpenGLCurveEv0 (struct OpenGLCurveEvaluator *__0this , long __1nu , REAL __1u0 , REAL __1u1 )
{ 
glMapGrid1f ( (int )__1nu , __1u0 , __1u1 ) ;
}

// extern void glPushAttrib (GLbitfield );

void __glbgnmap1f__20OpenGLCurveEva0 (struct OpenGLCurveEvaluator *__0this , long __1__A7 )
{ 
glPushAttrib ( (unsigned int )0x00010000 ) ;
}

// extern void glPopAttrib (void );

void __glendmap1f__20OpenGLCurveEva0 (struct OpenGLCurveEvaluator *__0this )
{ 
glPopAttrib ( ) ;
}

// extern void glMap1f (GLenum , GLfloat , GLfloat , GLint , GLint , GLfloat *);

void __glmap1f__20OpenGLCurveEvalua0 (struct OpenGLCurveEvaluator *__0this , 
long __1type , 
REAL __1ulo , 
REAL __1uhi , 
long __1stride , 
long __1order , 
REAL *__1pts )
{ 
glMap1f ( (unsigned
int )__1type , __1ulo , __1uhi , (int )__1stride , (int )__1order , (float *)__1pts ) ;
}

// extern void glEvalMesh1 (GLenum , GLint , GLint );

void __glmapmesh1f__20OpenGLCurveEv0 (struct OpenGLCurveEvaluator *__0this , long __1style , long __1from , long __1to )
{ 
switch (__1style ){ 
default :
case 0 :
case
1 :
glEvalMesh1 ( (unsigned int )0x1B01 , (int )__1from , (int )__1to ) ;
break ;
case 2 :
glEvalMesh1 ( (unsigned int )0x1B00 , (int )__1from , (int )__1to ) ;
break ;
}
}

// extern void glEvalPoint1 (GLint );

void __glevalpoint1i__20OpenGLCurve0 (struct OpenGLCurveEvaluator *__0this , long __1i )
{ 
glEvalPoint1 ( (int )__1i ) ;
}

// extern void glEvalCoord1f (GLfloat );

void __glevalcoord1f__20OpenGLCurve0 (struct OpenGLCurveEvaluator *__0this , long __1__A8 , REAL __1u )
{ 
glEvalCoord1f ( __1u ) ;
}
int __glcanRecord__16CachingEvalua0 (struct CachingEvaluator *);
int __glcanPlayAndRecord__16Cachin0 (struct CachingEvaluator *);
int __glcreateHandle__16CachingEva0 (struct CachingEvaluator *, int );
void __glbeginOutput__16CachingEval0 (struct CachingEvaluator *, int , int );
void __glendOutput__16CachingEvalua0 (struct CachingEvaluator *);
void __gldiscardRecording__16Cachin0 (struct CachingEvaluator *, int );
void __glplayRecording__16CachingEv0 (struct CachingEvaluator *, int );
struct __mptr __gl__vtbl__20OpenGLCurveEvalu0[] = {0,0,0,
0,0,(__vptp)__glcanRecord__16CachingEvalua0 ,
0,0,(__vptp)__glcanPlayAndRecord__16Cachin0 ,
0,0,(__vptp)__glcreateHandle__16CachingEva0 ,
0,0,(__vptp)__glbeginOutput__16CachingEval0 ,
0,0,(__vptp)__glendOutput__16CachingEvalua0 ,
0,0,(__vptp)__gldiscardRecording__16Cachin0 ,
0,0,(__vptp)__glplayRecording__16CachingEv0 ,
0,0,(__vptp)__gldomain1f__20OpenGLCurveEva0 ,
0,0,(__vptp)__glrange1f__20OpenGLCurveEval0 ,
0,0,(__vptp)__glenable__20OpenGLCurveEvalu0 ,
0,0,(__vptp)__gldisable__20OpenGLCurveEval0 ,
0,0,(__vptp)__glbgnmap1f__20OpenGLCurveEva0 ,
0,0,(__vptp)__glmap1f__20OpenGLCurveEvalua0 ,
0,0,(__vptp)__glmapgrid1f__20OpenGLCurveEv0 ,
0,0,(__vptp)__glmapmesh1f__20OpenGLCurveEv0 ,
0,0,(__vptp)__glevalcoord1f__20OpenGLCurve0 ,
0,0,(__vptp)__glendmap1f__20OpenGLCurveEva0 ,
0,0,(__vptp)__glbgnline__20OpenGLCurveEval0 ,
0,0,(__vptp)__glendline__20OpenGLCurveEval0 ,
0,0,0};
extern struct __mptr __gl__vtbl__19BasicCurveEvalua0[];
extern struct __mptr __gl__vtbl__16CachingEvaluator[];

static void *__nw__FUi (
size_t __1s )
{ 
void *__1__Xp0025pnaiaa ;

__1__Xp0025pnaiaa = malloc ( __1s ) ;
if (__1__Xp0025pnaiaa ){ 
return __1__Xp0025pnaiaa ;
}
else 
{ 
return __1__Xp0025pnaiaa ;
}
}
struct __mptr* __gl__ptbl_vec_____clients_glc0[] = {
__gl__vtbl__16CachingEvaluator,
__gl__vtbl__19BasicCurveEvalua0,
__gl__vtbl__20OpenGLCurveEvalu0,

};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\glinterf.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../clients/glinterface.c++ > */


void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };


typedef unsigned int GLenum ;
typedef unsigned char GLboolean ;
typedef unsigned int GLbitfield ;
typedef signed char GLbyte ;
typedef short GLshort ;
typedef int GLint ;
typedef int GLsizei ;
typedef unsigned char GLubyte ;
typedef unsigned short GLushort ;
typedef unsigned int GLuint ;
typedef float GLfloat ;
typedef float GLclampf ;
typedef double GLdouble ;
typedef double GLclampd ;
typedef void GLvoid ;





typedef struct GLUquadricObj GLUquadricObj ;

typedef struct GLUtriangulatorObj GLUtriangulatorObj ;
struct GLUnurbsObj;







typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);









struct JumpBuffer;













struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};




struct Renderhints;

struct Renderhints {	

REAL display_method__11Renderhints ;
REAL errorchecking__11Renderhints ;
REAL subdivisions__11Renderhints ;
REAL tmp1__11Renderhints ;

int displaydomain__11Renderhints ;
int maxsubdivisions__11Renderhints ;
int wiretris__11Renderhints ;
int wirequads__11Renderhints ;
};






struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};






struct Mapdesc;

struct Maplist;

void __gl__dt__4PoolFv (struct Pool *, int );


struct Maplist {	

struct Pool mapdescPool__7Maplist ;
struct Mapdesc *maps__7Maplist ;
struct Mapdesc **lastmap__7Maplist ;
struct Backend *backend__7Maplist ;
};

struct Mapdesc *__gllocate__7MaplistFl (struct Maplist *, long );

void __glremove__7MaplistFP7Mapdesc (struct Maplist *, struct Mapdesc *);



enum Curvetype { ct_nurbscurve = 0, ct_pwlcurve = 1, ct_none = 2} ;
struct Property;

struct O_surface;

struct O_nurbssurface;

struct O_trim;

struct O_pwlcurve;

struct O_nurbscurve;

struct O_curve;

struct Quilt;


union __Q2_7O_curve4__C1;

union  __Q2_7O_curve4__C1 {	
struct O_nurbscurve *o_nurbscurve ;
struct O_pwlcurve *o_pwlcurve ;
};


struct O_curve;

struct O_curve {	

char __W3__9PooledObj ;

union  __Q2_7O_curve4__C1 curve__7O_curve ;
int curvetype__7O_curve ;
struct O_curve *next__7O_curve ;
struct O_surface *owner__7O_curve ;
int used__7O_curve ;
int save__7O_curve ;
long nuid__7O_curve ;
};






struct O_nurbscurve;

struct O_nurbscurve {	

char __W3__9PooledObj ;

struct Quilt *bezier_curves__12O_nurbscurve ;
long type__12O_nurbscurve ;
REAL tesselation__12O_nurbscurve ;
int method__12O_nurbscurve ;
struct O_nurbscurve *next__12O_nurbscurve ;
int used__12O_nurbscurve ;
int save__12O_nurbscurve ;
struct O_curve *owner__12O_nurbscurve ;
};






struct O_pwlcurve;



struct O_pwlcurve {	

char __W3__9PooledObj ;

struct TrimVertex *pts__10O_pwlcurve ;
int npts__10O_pwlcurve ;
struct O_pwlcurve *next__10O_pwlcurve ;
int used__10O_pwlcurve ;
int save__10O_pwlcurve ;
struct O_curve *owner__10O_pwlcurve ;
};



struct O_trim;

struct O_trim {	

char __W3__9PooledObj ;

struct O_curve *o_curve__6O_trim ;
struct O_trim *next__6O_trim ;
int save__6O_trim ;
};






struct O_nurbssurface;

struct O_nurbssurface {	

char __W3__9PooledObj ;

struct Quilt *bezier_patches__14O_nurbssurface ;
long type__14O_nurbssurface ;
struct O_surface *owner__14O_nurbssurface ;
struct O_nurbssurface *next__14O_nurbssurface ;
int save__14O_nurbssurface ;
int used__14O_nurbssurface ;
};






struct O_surface;

struct O_surface {	

char __W3__9PooledObj ;

struct O_nurbssurface *o_nurbssurface__9O_surface ;
struct O_trim *o_trim__9O_surface ;
int save__9O_surface ;
long nuid__9O_surface ;
};






struct Property;

struct Property {	

char __W3__9PooledObj ;

long type__8Property ;
long tag__8Property ;
REAL value__8Property ;
int save__8Property ;
};




struct NurbsTessellator;


struct Knotvector;

struct Quilt;

struct DisplayList;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct NurbsTessellator;

struct NurbsTessellator {	

struct Renderhints renderhints__16NurbsTessellator ;
struct Maplist maplist__16NurbsTessellator ;
struct Backend backend__16NurbsTessellator ;

struct Subdivider subdivider__16NurbsTessellator ;
struct JumpBuffer *jumpbuffer__16NurbsTessellator ;
struct Pool o_pwlcurvePool__16NurbsTessellator ;
struct Pool o_nurbscurvePool__16NurbsTessellator ;
struct Pool o_curvePool__16NurbsTessellator ;
struct Pool o_trimPool__16NurbsTessellator ;
struct Pool o_surfacePool__16NurbsTessellator ;
struct Pool o_nurbssurfacePool__16NurbsTessellator ;
struct Pool propertyPool__16NurbsTessellator ;
struct Pool quiltPool__16NurbsTessellator ;
struct TrimVertexPool extTrimVertexPool__16NurbsTessellator ;

int inSurface__16NurbsTessellator ;
int inCurve__16NurbsTessellator ;
int inTrim__16NurbsTessellator ;
int isCurveModified__16NurbsTessellator ;
int isTrimModified__16NurbsTessellator ;
int isSurfaceModified__16NurbsTessellator ;
int isDataValid__16NurbsTessellator ;
int numTrims__16NurbsTessellator ;
int playBack__16NurbsTessellator ;

struct O_trim **nextTrim__16NurbsTessellator ;
struct O_curve **nextCurve__16NurbsTessellator ;
struct O_nurbscurve **nextNurbscurve__16NurbsTessellator ;
struct O_pwlcurve **nextPwlcurve__16NurbsTessellator ;
struct O_nurbssurface **nextNurbssurface__16NurbsTessellator ;

struct O_surface *currentSurface__16NurbsTessellator ;
struct O_trim *currentTrim__16NurbsTessellator ;
struct O_curve *currentCurve__16NurbsTessellator ;

struct DisplayList *dl__16NurbsTessellator ;

struct __mptr *__vptr__16NurbsTessellator ;
};

extern char *__glNurbsErrors [];











struct CachingEvaluator;
enum __Q2_16CachingEvaluator11ServiceMode { play__Q2_16CachingEvaluator11ServiceMode = 0, record__Q2_16CachingEvaluator11ServiceMode = 1, playAndRecord__Q2_16CachingEvaluator11ServiceMode = 2} ;

struct CachingEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};



struct BasicSurfaceEvaluator;


struct BasicSurfaceEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

static void *__nw__FUi (size_t );


struct SurfaceMap;

struct OpenGLSurfaceEvaluator;

struct StoredVertex;

struct StoredVertex;

struct StoredVertex {	

int type__12StoredVertex ;
REAL coord__12StoredVertex [2];
long point__12StoredVertex [2];
};


struct OpenGLSurfaceEvaluator;

struct OpenGLSurfaceEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;

struct StoredVertex *vertexCache__22OpenGLSurfaceEvaluator [3];
int tmeshing__22OpenGLSurfaceEvaluator ;
int which__22OpenGLSurfaceEvaluator ;
int vcount__22OpenGLSurfaceEvaluator ;
};


void __glcoord2f__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *, REAL , REAL );
void __glpoint2i__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *, long , long );





struct BasicCurveEvaluator;


struct BasicCurveEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};


struct CurveMap;

struct OpenGLCurveEvaluator;

struct OpenGLCurveEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

struct GLUnurbsObj;

struct GLUnurbsObj {	

struct Renderhints renderhints__16NurbsTessellator ;
struct Maplist maplist__16NurbsTessellator ;
struct Backend backend__16NurbsTessellator ;

struct Subdivider subdivider__16NurbsTessellator ;
struct JumpBuffer *jumpbuffer__16NurbsTessellator ;
struct Pool o_pwlcurvePool__16NurbsTessellator ;
struct Pool o_nurbscurvePool__16NurbsTessellator ;
struct Pool o_curvePool__16NurbsTessellator ;
struct Pool o_trimPool__16NurbsTessellator ;
struct Pool o_surfacePool__16NurbsTessellator ;
struct Pool o_nurbssurfacePool__16NurbsTessellator ;
struct Pool propertyPool__16NurbsTessellator ;
struct Pool quiltPool__16NurbsTessellator ;
struct TrimVertexPool extTrimVertexPool__16NurbsTessellator ;

int inSurface__16NurbsTessellator ;
int inCurve__16NurbsTessellator ;
int inTrim__16NurbsTessellator ;
int isCurveModified__16NurbsTessellator ;
int isTrimModified__16NurbsTessellator ;
int isSurfaceModified__16NurbsTessellator ;
int isDataValid__16NurbsTessellator ;
int numTrims__16NurbsTessellator ;
int playBack__16NurbsTessellator ;

struct O_trim **nextTrim__16NurbsTessellator ;
struct O_curve **nextCurve__16NurbsTessellator ;
struct O_nurbscurve **nextNurbscurve__16NurbsTessellator ;
struct O_pwlcurve **nextPwlcurve__16NurbsTessellator ;
struct O_nurbssurface **nextNurbssurface__16NurbsTessellator ;

struct O_surface *currentSurface__16NurbsTessellator ;
struct O_trim *currentTrim__16NurbsTessellator ;
struct O_curve *currentCurve__16NurbsTessellator ;

struct DisplayList *dl__16NurbsTessellator ;

struct __mptr *__vptr__16NurbsTessellator ;

GLUnurbsErrorProc errorCallback__11GLUnurbsObj;

GLboolean autoloadmode__11GLUnurbsObj ;
struct OpenGLSurfaceEvaluator surfaceEvaluator__11GLUnurbsObj ;
struct OpenGLCurveEvaluator curveEvaluator__11GLUnurbsObj ;
};

void __gl__dt__22OpenGLSurfaceEvalu0 (struct OpenGLSurfaceEvaluator *, int );

void __gl__dt__20OpenGLCurveEvaluat0 (struct OpenGLCurveEvaluator *, int );

void __gl__dt__16NurbsTessellatorFv (struct NurbsTessellator *, int );




struct GLUnurbsObj *__gl__ct__11GLUnurbsObjFv (struct GLUnurbsObj *);
extern struct __mptr* __gl__ptbl_vec_____clients_gli0[];

struct GLUnurbsObj *gluNewNurbsRenderer (void )
{ 
struct GLUnurbsObj *__1t ;

struct GLUnurbsObj *__0__X23 ;

__1t = __gl__ct__11GLUnurbsObjFv ( (struct GLUnurbsObj *)0 ) ;
return __1t ;
}


void gluDeleteNurbsRenderer (struct GLUnurbsObj *__1r )
{ 
((void )( (((struct GLUnurbsObj *)__1r )?( ( (((struct GLUnurbsObj *)__1r )-> __vptr__16NurbsTessellator = (struct __mptr *) __gl__ptbl_vec_____clients_gli0[0]), (((struct
GLUnurbsObj *)__1r )?( ( __gl__dt__20OpenGLCurveEvaluat0 ( (struct OpenGLCurveEvaluator *)(& ((struct GLUnurbsObj *)__1r )-> curveEvaluator__11GLUnurbsObj ), 2) , ( __gl__dt__22OpenGLSurfaceEvalu0 ( (struct OpenGLSurfaceEvaluator *)(&
((struct GLUnurbsObj *)__1r )-> surfaceEvaluator__11GLUnurbsObj ), 2) , ( __gl__dt__16NurbsTessellatorFv ( ((struct NurbsTessellator *)((struct GLUnurbsObj *)__1r )), 0 ) , (( (
(((void *)((struct GLUnurbsObj *)__1r ))?( free ( ((void *)((struct GLUnurbsObj *)__1r ))) , 0 ) :( 0 ) )) , 0 )
)) ) ) , 0 ) :( 0 ) )) , 0 ) :( 0 ) )) );

}

void __glbgnsurface__16NurbsTessell0 (struct NurbsTessellator *, long );

void gluBeginSurface (struct GLUnurbsObj *__1r )
{ 
__glbgnsurface__16NurbsTessell0 ( (struct NurbsTessellator *)__1r , (long )0 ) ;
}

void __glbgncurve__16NurbsTessellat0 (struct NurbsTessellator *, long );

void gluBeginCurve (struct GLUnurbsObj *__1r )
{ 
__glbgncurve__16NurbsTessellat0 ( (struct NurbsTessellator *)__1r , (long )0 ) ;
}

void __glendcurve__16NurbsTessellat0 (struct NurbsTessellator *);

void gluEndCurve (struct GLUnurbsObj *__1r )
{ 
__glendcurve__16NurbsTessellat0 ( (struct NurbsTessellator *)__1r ) ;
}

void __glendsurface__16NurbsTessell0 (struct NurbsTessellator *);

void gluEndSurface (struct GLUnurbsObj *__1r )
{ 
__glendsurface__16NurbsTessell0 ( (struct NurbsTessellator *)__1r ) ;
}

void __glbgntrim__16NurbsTessellato0 (struct NurbsTessellator *);

void gluBeginTrim (struct GLUnurbsObj *__1r )
{ 
__glbgntrim__16NurbsTessellato0 ( (struct NurbsTessellator *)__1r ) ;
}

void __glendtrim__16NurbsTessellato0 (struct NurbsTessellator *);

void gluEndTrim (struct GLUnurbsObj *__1r )
{ 
__glendtrim__16NurbsTessellato0 ( (struct NurbsTessellator *)__1r ) ;
}

void __glpwlcurve__16NurbsTessellat0 (struct NurbsTessellator *, long , float *, long , long );

void gluPwlCurve (struct GLUnurbsObj *__1r , GLint __1count , float *__1array , 
GLint __1stride , GLenum __1type )
{ 
GLenum __1realType ;

switch (__1type ){ 
case 100210 :
__1realType = 0x8 ;
break ;
case 100211 :
__1realType = 0xd ;
break ;
default :
__1realType = __1type ;
break ;
}
__glpwlcurve__16NurbsTessellat0 ( (struct NurbsTessellator *)__1r , (long )__1count , __1array , (long )((sizeof (float ))* __1stride ), (long )__1realType ) ;

}

void __glnurbscurve__16NurbsTessell0 (struct NurbsTessellator *, long , float *, long , float *, long , long
);

void gluNurbsCurve (struct GLUnurbsObj *__1r , GLint __1nknots , float *__1knot , GLint __1stride , 
float *__1ctlarray , GLint __1order , GLenum __1type )
{ 
GLenum __1realType ;

switch (__1type ){ 
case 100210 :
__1realType = 0x8 ;
break ;
case 100211 :
__1realType = 0xd ;
break ;
default :
__1realType = __1type ;
break ;
}

__glnurbscurve__16NurbsTessell0 ( (struct NurbsTessellator *)__1r , (long )__1nknots , __1knot , (long )((sizeof (float ))* __1stride ), __1ctlarray , (long )__1order ,
(long )__1realType ) ;
}

void __glnurbssurface__16NurbsTesse0 (struct NurbsTessellator *, long , float *, long , float *, long , long
, float *, long , long , long );

void gluNurbsSurface (struct GLUnurbsObj *__1r , GLint __1sknot_count , GLfloat *__1sknot , 
GLint __1tknot_count , GLfloat *__1tknot , 
GLint __1s_stride , GLint __1t_stride , 
GLfloat *__1ctlarray , GLint __1sorder , GLint __1torder , 
GLenum __1type )
{ 
__glnurbssurface__16NurbsTesse0 (
(struct NurbsTessellator *)__1r , (long )__1sknot_count , __1sknot , (long )__1tknot_count , __1tknot , (long )((sizeof (float ))* __1s_stride ), (long
)((sizeof (float ))* __1t_stride ), __1ctlarray , (long )__1sorder , (long )__1torder , (long )__1type ) ;
}

void __gluseGLMatrices__11GLUnurbsO0 (struct GLUnurbsObj *, GLfloat *, GLfloat *, GLint *);

void gluLoadSamplingMatrices (struct GLUnurbsObj *__1r , GLfloat *__1modelMatrix , 
GLfloat *__1projMatrix , 
GLint *__1viewport )
{ 
__gluseGLMatrices__11GLUnurbsO0 ( (struct GLUnurbsObj *)__1r , __1modelMatrix , __1projMatrix , __1viewport ) ;
}


void __glsetnurbsproperty__16NurbsT1 (struct NurbsTessellator *, long , long , float );


void __glsetnurbsproperty__16NurbsT0 (struct NurbsTessellator *, long , float );


void gluNurbsProperty (struct GLUnurbsObj *__1r , GLenum __1property , GLfloat __1value )
{ 
GLfloat __1nurbsValue ;

switch (__1property ){ 
case 100200 :
( (__1value ?( (((struct GLUnurbsObj *)__1r )-> autoloadmode__11GLUnurbsObj = 1 ), 0 ) :(((struct GLUnurbsObj *)__1r )-> autoloadmode__11GLUnurbsObj = 0 )))
;
return ;
case 100201 :
if (__1value != 0.0 ){ 
__1nurbsValue = 1.0 ;
}
else 
{ 
__1nurbsValue = 0.0 ;
}
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0DB7 , (long )2 , __1nurbsValue ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0DB8 , (long )2 , __1nurbsValue ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0D97 , (long )2 , __1nurbsValue ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0D98 , (long )2 , __1nurbsValue ) ;
return ;
case 100203 :
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0DB7 , (long )1 , __1value ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0DB8 , (long )1 , __1value ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0D97 , (long )1 , __1value ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0D98 , (long )1 , __1value ) ;
return ;
case 100204 :
if (__1value == 100012 ){ 
__1nurbsValue = 1.0 ;
}
else 
if (__1value == 100240 ){ 
__1nurbsValue = 2.0 ;
}
else 
if (__1value == 100241 ){ 
__1nurbsValue = 5.0 ;
}
else 
{ 
( (((struct GLUnurbsObj *)__1r )-> errorCallback__11GLUnurbsObj ?( ((*((struct GLUnurbsObj *)__1r )-> errorCallback__11GLUnurbsObj ))( ((unsigned int )100901 )) , 0 )
:( 0 ) )) ;
return ;
}
__glsetnurbsproperty__16NurbsT0 ( (struct NurbsTessellator *)__1r , (long )3 , __1nurbsValue ) ;
break ;
default :
( (((struct GLUnurbsObj *)__1r )-> errorCallback__11GLUnurbsObj ?( ((*((struct GLUnurbsObj *)__1r )-> errorCallback__11GLUnurbsObj ))( ((unsigned int )100900 )) , 0 ) :(
0 ) )) ;
return ;
}
}


void __glgetnurbsproperty__16NurbsT1 (struct NurbsTessellator *, long , long , float *);

void __glgetnurbsproperty__16NurbsT0 (struct NurbsTessellator *, long , float *);


void gluGetNurbsProperty (struct GLUnurbsObj *__1r , GLenum __1property , GLfloat *__1value )
{ 
GLfloat __1nurbsValue ;

switch (__1property ){ 
case 100200 :
if (( ((struct GLUnurbsObj *)__1r )-> autoloadmode__11GLUnurbsObj ) ){ 
((*__1value ))= 1 ;
}
else 
{ 
((*__1value ))= 0 ;
}
break ;
case 100201 :
__glgetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0DB7 , (long )2 , & __1nurbsValue ) ;
if (__1nurbsValue == 1.0 ){ 
((*__1value ))= 1 ;
}
else 
{ 
((*__1value ))= 0 ;
}
break ;
case 100203 :
__glgetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__1r , (long )0x0DB7 , (long )1 , __1value ) ;
break ;
case 100204 :
__glgetnurbsproperty__16NurbsT0 ( (struct NurbsTessellator *)__1r , (long )3 , & __1nurbsValue ) ;
if (__1nurbsValue == 1.0 ){ 
((*__1value ))= 100012 ;
}
else 
if (__1nurbsValue == 2.0 ){ 
((*__1value ))= 100240 ;
}
else 
{ 
((*__1value ))= 100241 ;
}
break ;
default :
( (((struct GLUnurbsObj *)__1r )-> errorCallback__11GLUnurbsObj ?( ((*((struct GLUnurbsObj *)__1r )-> errorCallback__11GLUnurbsObj ))( ((unsigned int )100900 )) , 0 ) :(
0 ) )) ;
return ;
}
}


void gluNurbsCallback (struct GLUnurbsObj *__1r , GLenum __1which , void (CALLBACK*__1fn )())
{ 
switch (__1which ){ 
case 100103 :
__1r -> errorCallback__11GLUnurbsObj = (GLUnurbsErrorProc) __1fn ;

break ;
default :
( (((struct GLUnurbsObj *)__1r )-> errorCallback__11GLUnurbsObj ?( ((*((struct GLUnurbsObj *)__1r )-> errorCallback__11GLUnurbsObj ))( ((unsigned int )100900 )) , 0 ) :(
0 ) )) ;
return ;
}
}
extern struct __mptr __gl__vtbl__11GLUnurbsObj[];

static void *__nw__FUi (
size_t __1s )
{ 
void *__1__Xp00qshqaiaa ;

__1__Xp00qshqaiaa = malloc ( __1s ) ;
if (__1__Xp00qshqaiaa ){ 
return __1__Xp00qshqaiaa ;
}
else 
{ 
return __1__Xp00qshqaiaa ;
}
}
struct __mptr* __gl__ptbl_vec_____clients_gli0[] = {
__gl__vtbl__11GLUnurbsObj,

};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\hull.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/hull.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct Arc;

struct Backend;






typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;







struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};












struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};


struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;








struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};






struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};

struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};



struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;


struct TrimRegion *__gl__ct__10TrimRegionFv (struct TrimRegion *);
extern struct __mptr* __ptbl_vec_____core_hull_c_____ct_[];

struct Trimline *__gl__ct__8TrimlineFv (struct Trimline *);


struct Hull *__gl__ct__4HullFv (struct Hull *__0this , struct TrimRegion *__0TrimRegion )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Hull *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Hull))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))(
( (__0this -> PTrimRegion= ((__0TrimRegion == 0 )?( (__0TrimRegion = (((struct TrimRegion *)((((char *)__0this ))+ 156)))), __gl__ct__10TrimRegionFv ( ((struct TrimRegion *)((((char *)__0this ))+
156))) ) :__0TrimRegion )), __gl__ct__8TrimlineFv ( (struct Trimline *)(& __0this -> fakeleft__4Hull )) ) , __gl__ct__8TrimlineFv ( (struct Trimline *)(& __0this ->
fakeright__4Hull )) ) ;

return __0this ;

}



void __gl__dt__4HullFv (struct Hull *__0this , 
int __0__free )
{ if (__0this )if (__0this ){ __gl__dt__8TrimlineFv ( (struct Trimline *)(& __0this -> fakeright__4Hull ), 2)
;

__gl__dt__8TrimlineFv ( (struct Trimline *)(& __0this -> fakeleft__4Hull ), 2) ;

(__0__free & 2)?( (((void )( ((((struct TrimRegion *)((((char *)__0this ))+ 156)))?( ((((struct TrimRegion *)((((char *)__0this ))+ 156)))?( ( __gl__dt__6UarrayFv (
(struct Uarray *)(& (((struct TrimRegion *)((((char *)__0this ))+ 156)))-> uarray__10TrimRegion ), 2) , ( __gl__dt__8TrimlineFv ( (struct Trimline *)(& (((struct
TrimRegion *)((((char *)__0this ))+ 156)))-> right__10TrimRegion ), 2) , ( __gl__dt__8TrimlineFv ( (struct Trimline *)(& (((struct TrimRegion *)((((char *)__0this ))+ 156)))->
left__10TrimRegion ), 2) , (( 0 ) )) ) ) , 0 ) :( 0 ) ), 0 )
:( 0 ) )) )), 0 ) :0 ;

if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) )) ;
} }




void __glinit__8TrimlineFP10TrimVer0 (struct Trimline *, struct TrimVertex *);






void __glinit__4HullFv (struct Hull *__0this )
{ 
struct TrimVertex *__1lfirst ;
struct TrimVertex *__1llast ;

struct Trimline *__0__X6 ;

struct Trimline *__0__X7 ;

__1lfirst = ( (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))->
pts__8Trimline [((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline ])) ;
__1llast = ( (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> numverts__8Trimline ),
(((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline )])) ;
if ((__1lfirst -> param__10TrimVertex [0 ])<= (__1llast -> param__10TrimVertex [0 ])){ 
__glinit__8TrimlineFP10TrimVer0 ( (struct Trimline *)(& __0this -> fakeleft__4Hull ), ( (((struct Trimline *)(& __0this ->
PTrimRegion-> left__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))->
i__8Trimline ])) ) ;
__0this -> upper__4Hull . left__Q2_4Hull4Side = (& __0this -> fakeleft__4Hull );
__0this -> lower__4Hull . left__Q2_4Hull4Side = (& __0this -> PTrimRegion-> left__10TrimRegion );
}
else 
{ 
__glinit__8TrimlineFP10TrimVer0 ( (struct Trimline *)(& __0this -> fakeleft__4Hull ), ( (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline =
((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> numverts__8Trimline ), (((struct Trimline *)(& __0this -> PTrimRegion-> left__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(&
__0this -> PTrimRegion-> left__10TrimRegion ))-> i__8Trimline )])) ) ;
__0this -> lower__4Hull . left__Q2_4Hull4Side = (& __0this -> fakeleft__4Hull );
__0this -> upper__4Hull . left__Q2_4Hull4Side = (& __0this -> PTrimRegion-> left__10TrimRegion );
}
( (__0__X6 = (struct Trimline *)__0this -> upper__4Hull . left__Q2_4Hull4Side ), ( (__0__X6 -> i__8Trimline = __0__X6 -> numverts__8Trimline ), (__0__X6 -> pts__8Trimline [(-- __0__X6 ->
i__8Trimline )])) ) ;
( (__0__X7 = (struct Trimline *)__0this -> lower__4Hull . left__Q2_4Hull4Side ), ( (__0__X7 -> i__8Trimline = 0 ), (__0__X7 -> pts__8Trimline [__0__X7 -> i__8Trimline ])) )
;

if (__0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline <= __0this -> PTrimRegion-> top__10TrimRegion . uend__8Gridline ){ 
__0this -> upper__4Hull . line__Q2_4Hull4Side = (& __0this ->
PTrimRegion-> top__10TrimRegion );
__0this -> upper__4Hull . index__Q2_4Hull4Side = __0this -> PTrimRegion-> top__10TrimRegion . ustart__8Gridline ;
}
else __0this -> upper__4Hull . line__Q2_4Hull4Side = 0 ;

if (__0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline <= __0this -> PTrimRegion-> bot__10TrimRegion . uend__8Gridline ){ 
__0this -> lower__4Hull . line__Q2_4Hull4Side = (& __0this ->
PTrimRegion-> bot__10TrimRegion );
__0this -> lower__4Hull . index__Q2_4Hull4Side = __0this -> PTrimRegion-> bot__10TrimRegion . ustart__8Gridline ;
}
else __0this -> lower__4Hull . line__Q2_4Hull4Side = 0 ;

{ struct TrimVertex *__1rfirst ;
struct TrimVertex *__1rlast ;

struct Trimline *__0__X8 ;

struct Trimline *__0__X9 ;

__1rfirst = ( (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))->
pts__8Trimline [((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ])) ;
__1rlast = ( (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> numverts__8Trimline ),
(((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline )])) ;
if ((__1rfirst -> param__10TrimVertex [0 ])<= (__1rlast -> param__10TrimVertex [0 ])){ 
__glinit__8TrimlineFP10TrimVer0 ( (struct Trimline *)(& __0this -> fakeright__4Hull ), ( (((struct Trimline *)(& __0this ->
PTrimRegion-> right__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> numverts__8Trimline ), (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))->
pts__8Trimline [(-- ((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline )])) ) ;
__0this -> lower__4Hull . right__Q2_4Hull4Side = (& __0this -> fakeright__4Hull );
__0this -> upper__4Hull . right__Q2_4Hull4Side = (& __0this -> PTrimRegion-> right__10TrimRegion );
}
else 
{ 
__glinit__8TrimlineFP10TrimVer0 ( (struct Trimline *)(& __0this -> fakeright__4Hull ), ( (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline =
0 ), (((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> pts__8Trimline [((struct Trimline *)(& __0this -> PTrimRegion-> right__10TrimRegion ))-> i__8Trimline ])) ) ;

__0this -> upper__4Hull . right__Q2_4Hull4Side = (& __0this -> fakeright__4Hull );
__0this -> lower__4Hull . right__Q2_4Hull4Side = (& __0this -> PTrimRegion-> right__10TrimRegion );
}
( (__0__X8 = (struct Trimline *)__0this -> upper__4Hull . right__Q2_4Hull4Side ), ( (__0__X8 -> i__8Trimline = 0 ), (__0__X8 -> pts__8Trimline [__0__X8 -> i__8Trimline ])) )
;
( (__0__X9 = (struct Trimline *)__0this -> lower__4Hull . right__Q2_4Hull4Side ), ( (__0__X9 -> i__8Trimline = __0__X9 -> numverts__8Trimline ), (__0__X9 -> pts__8Trimline [(-- __0__X9 ->
i__8Trimline )])) ) ;

}
}









struct GridTrimVertex *__glnextupper__4HullFP14GridTr0 (struct Hull *__0this , struct GridTrimVertex *__1gv )
{ 
if (__0this -> upper__4Hull . left__Q2_4Hull4Side ){ 
struct Trimline *__0__X10 ;

struct TrimVertex *__1__X11 ;

( (__1__X11 = ( (__0__X10 = (struct Trimline *)__0this -> upper__4Hull . left__Q2_4Hull4Side ), ( ((__0__X10 -> i__8Trimline >= 0 )?(__0__X10 -> pts__8Trimline [(__0__X10 -> i__8Trimline --
)]):(((struct TrimVertex *)0 )))) ) ), ( (((struct GridTrimVertex *)__1gv )-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex = __1__X11 )) )
;
if (( (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex ?1 :0 )) )return __1gv ;
__0this -> upper__4Hull . left__Q2_4Hull4Side = 0 ;
}

if (__0this -> upper__4Hull . line__Q2_4Hull4Side ){ 
((void )0 );
( (((struct GridTrimVertex *)__1gv )-> g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex = (& ((struct GridTrimVertex *)__1gv )-> dummyt__14GridTrimVertex )), (
((((struct GridTrimVertex *)__1gv )-> dummyt__14GridTrimVertex . param__10TrimVertex [0 ])= (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [__0this -> upper__4Hull . index__Q2_4Hull4Side ])), ( ((((struct GridTrimVertex *)__1gv )-> dummyt__14GridTrimVertex .
param__10TrimVertex [1 ])= __0this -> upper__4Hull . line__Q2_4Hull4Side -> vval__8Gridline ), (((struct GridTrimVertex *)__1gv )-> dummyt__14GridTrimVertex . nuid__10TrimVertex = 0 )) ) ) ) ;

( (((struct GridTrimVertex *)__1gv )-> g__14GridTrimVertex = (& ((struct GridTrimVertex *)__1gv )-> dummyg__14GridTrimVertex )), ( ((((struct GridTrimVertex *)__1gv )-> dummyg__14GridTrimVertex . gparam__10GridVertex [0 ])= __0this ->
upper__4Hull . index__Q2_4Hull4Side ), ((((struct GridTrimVertex *)__1gv )-> dummyg__14GridTrimVertex . gparam__10GridVertex [1 ])= __0this -> upper__4Hull . line__Q2_4Hull4Side -> vindex__8Gridline )) ) ;
if ((__0this -> upper__4Hull . index__Q2_4Hull4Side ++ )== __0this -> upper__4Hull . line__Q2_4Hull4Side -> uend__8Gridline )__0this -> upper__4Hull . line__Q2_4Hull4Side = 0 ;
return __1gv ;
}

if (__0this -> upper__4Hull . right__Q2_4Hull4Side ){ 
struct Trimline *__0__X12 ;

struct TrimVertex *__1__X13 ;

( (__1__X13 = ( (__0__X12 = (struct Trimline *)__0this -> upper__4Hull . right__Q2_4Hull4Side ), ( ((__0__X12 -> i__8Trimline < __0__X12 -> numverts__8Trimline )?(__0__X12 -> pts__8Trimline [(__0__X12 ->
i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ) ), ( (((struct GridTrimVertex *)__1gv )-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex = __1__X13 ))
) ;
if (( (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex ?1 :0 )) )return __1gv ;
__0this -> upper__4Hull . right__Q2_4Hull4Side = 0 ;
}

return (struct GridTrimVertex *)0 ;
}









struct GridTrimVertex *__glnextlower__4HullFP14GridTr0 (struct Hull *__0this , register struct GridTrimVertex *__1gv )
{ 
if (__0this -> lower__4Hull . left__Q2_4Hull4Side ){ 
struct Trimline *__0__X14 ;

struct TrimVertex *__1__X15 ;

( (__1__X15 = ( (__0__X14 = (struct Trimline *)__0this -> lower__4Hull . left__Q2_4Hull4Side ), ( ((__0__X14 -> i__8Trimline < __0__X14 -> numverts__8Trimline )?(__0__X14 -> pts__8Trimline [(__0__X14 ->
i__8Trimline ++ )]):(((struct TrimVertex *)0 )))) ) ), ( (((struct GridTrimVertex *)__1gv )-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex = __1__X15 ))
) ;
if (( (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex ?1 :0 )) )return __1gv ;
__0this -> lower__4Hull . left__Q2_4Hull4Side = 0 ;
}

if (__0this -> lower__4Hull . line__Q2_4Hull4Side ){ 
( (((struct GridTrimVertex *)__1gv )-> g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex = (&
((struct GridTrimVertex *)__1gv )-> dummyt__14GridTrimVertex )), ( ((((struct GridTrimVertex *)__1gv )-> dummyt__14GridTrimVertex . param__10TrimVertex [0 ])= (__0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [__0this -> lower__4Hull . index__Q2_4Hull4Side ])),
( ((((struct GridTrimVertex *)__1gv )-> dummyt__14GridTrimVertex . param__10TrimVertex [1 ])= __0this -> lower__4Hull . line__Q2_4Hull4Side -> vval__8Gridline ), (((struct GridTrimVertex *)__1gv )-> dummyt__14GridTrimVertex . nuid__10TrimVertex = 0 ))
) ) ) ;
( (((struct GridTrimVertex *)__1gv )-> g__14GridTrimVertex = (& ((struct GridTrimVertex *)__1gv )-> dummyg__14GridTrimVertex )), ( ((((struct GridTrimVertex *)__1gv )-> dummyg__14GridTrimVertex . gparam__10GridVertex [0 ])= __0this ->
lower__4Hull . index__Q2_4Hull4Side ), ((((struct GridTrimVertex *)__1gv )-> dummyg__14GridTrimVertex . gparam__10GridVertex [1 ])= __0this -> lower__4Hull . line__Q2_4Hull4Side -> vindex__8Gridline )) ) ;
if ((__0this -> lower__4Hull . index__Q2_4Hull4Side ++ )== __0this -> lower__4Hull . line__Q2_4Hull4Side -> uend__8Gridline )__0this -> lower__4Hull . line__Q2_4Hull4Side = 0 ;
return __1gv ;
}

if (__0this -> lower__4Hull . right__Q2_4Hull4Side ){ 
struct Trimline *__0__X16 ;

struct TrimVertex *__1__X17 ;

( (__1__X17 = ( (__0__X16 = (struct Trimline *)__0this -> lower__4Hull . right__Q2_4Hull4Side ), ( ((__0__X16 -> i__8Trimline >= 0 )?(__0__X16 -> pts__8Trimline [(__0__X16 -> i__8Trimline --
)]):(((struct TrimVertex *)0 )))) ) ), ( (((struct GridTrimVertex *)__1gv )-> g__14GridTrimVertex = 0 ), (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex = __1__X17 )) )
;
if (( (((struct GridTrimVertex *)__1gv )-> t__14GridTrimVertex ?1 :0 )) )return __1gv ;
__0this -> lower__4Hull . right__Q2_4Hull4Side = 0 ;
}

return (struct GridTrimVertex *)0 ;
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\glue.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include <stdlib.h>
#include <setjmp.h>
#include <windef.h>

// void *malloc( size_t );

struct JumpBuffer *__glnewJumpBuffer( void )
{
    return (struct JumpBuffer *) malloc(sizeof(jmp_buf));
}

extern char *__glNurbsErrors [];
extern WCHAR *__glNurbsErrorsW [];

const char *__glNURBSErrorString( int errno )
{
    return __glNurbsErrors[errno];
}

const WCHAR *__glNURBSErrorStringW( int errno )
{
    return __glNurbsErrorsW[errno];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\glsurfev.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <windows.h>
#include <GL/gl.h>
#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../clients/glsurfeval.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };



typedef unsigned int GLenum ;
typedef unsigned char GLboolean ;
typedef unsigned int GLbitfield ;
typedef signed char GLbyte ;
typedef short GLshort ;
typedef int GLint ;
typedef int GLsizei ;
typedef unsigned char GLubyte ;
typedef unsigned short GLushort ;
typedef unsigned int GLuint ;
typedef float GLfloat ;
typedef float GLclampf ;
typedef double GLdouble ;
typedef double GLclampd ;
typedef void GLvoid ;






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct CachingEvaluator;
enum __Q2_16CachingEvaluator11ServiceMode { play__Q2_16CachingEvaluator11ServiceMode = 0, record__Q2_16CachingEvaluator11ServiceMode = 1, playAndRecord__Q2_16CachingEvaluator11ServiceMode = 2} ;

struct CachingEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};



struct BasicSurfaceEvaluator;


struct BasicSurfaceEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

static void *__nw__FUi (size_t );


struct SurfaceMap;

struct OpenGLSurfaceEvaluator;

struct StoredVertex;

struct StoredVertex;

struct StoredVertex {	

int type__12StoredVertex ;
REAL coord__12StoredVertex [2];
long point__12StoredVertex [2];
};


struct OpenGLSurfaceEvaluator;

struct OpenGLSurfaceEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;

struct StoredVertex *vertexCache__22OpenGLSurfaceEvaluator [3];
int tmeshing__22OpenGLSurfaceEvaluator ;
int which__22OpenGLSurfaceEvaluator ;
int vcount__22OpenGLSurfaceEvaluator ;
};


void __glcoord2f__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *, REAL , REAL );
void __glpoint2i__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *, long , long );






extern struct __mptr* __gl__ptbl_vec_____clients_gls0[];

struct OpenGLSurfaceEvaluator *__gl__ct__22OpenGLSurfaceEvalu0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
int __1i ;

struct BasicSurfaceEvaluator *__0__X7 ;

struct CachingEvaluator *__0__X4 ;

void *__1__Xp0025pnaiaa ;

if (__0this || (__0this = (struct OpenGLSurfaceEvaluator *)( (__1__Xp0025pnaiaa = malloc ( (sizeof (struct OpenGLSurfaceEvaluator))) ), (__1__Xp0025pnaiaa ?(((void *)__1__Xp0025pnaiaa )):(((void *)__1__Xp0025pnaiaa )))) )){
( (__0this = (struct OpenGLSurfaceEvaluator *)( (__0__X7 = (((struct BasicSurfaceEvaluator *)__0this ))), ( ((__0__X7 || (__0__X7 = (struct BasicSurfaceEvaluator *)__nw__FUi ( sizeof (struct BasicSurfaceEvaluator))
))?( (__0__X7 = (struct BasicSurfaceEvaluator *)( (__0__X4 = (((struct CachingEvaluator *)__0__X7 ))), ( ((__0__X4 || (__0__X4 = (struct CachingEvaluator *)( (__1__Xp0025pnaiaa = malloc (
(sizeof (struct CachingEvaluator))) ), (__1__Xp0025pnaiaa ?(((void *)__1__Xp0025pnaiaa )):(((void *)__1__Xp0025pnaiaa )))) ))?(__0__X4 -> __vptr__16CachingEvaluator = (struct __mptr *) __gl__ptbl_vec_____clients_gls0[0]):0 ), ((__0__X4 ))) ) ), (__0__X7 ->
__vptr__16CachingEvaluator = (struct __mptr *) __gl__ptbl_vec_____clients_gls0[1])) :0 ), ((__0__X7 ))) ) ), (__0this -> __vptr__16CachingEvaluator = (struct __mptr *) __gl__ptbl_vec_____clients_gls0[2])) ;

for(__1i = 0 ;__1i < 3 ;__1i ++ ) { 
struct StoredVertex *__0__X8 ;

struct StoredVertex *__0__X9 ;

void *__1__Xp0025pnaiaa ;

(__0this -> vertexCache__22OpenGLSurfaceEvaluator [__1i ])= ( (__0__X9 = 0 ), ( ((__0__X9 || (__0__X9 = (struct StoredVertex *)( (__1__Xp0025pnaiaa = malloc ( (sizeof (struct StoredVertex)))
), (__1__Xp0025pnaiaa ?(((void *)__1__Xp0025pnaiaa )):(((void *)__1__Xp0025pnaiaa )))) ))?( (__0__X9 -> type__12StoredVertex = 0 ), 0 ) :0 ), ((__0__X9 ))) ) ;
}
/* XXX Add the following 3 lines - hockl */
/* XXX tnurb.exe crashes if memory is not zero init'd */
__0this -> tmeshing__22OpenGLSurfaceEvaluator = 0;
__0this -> which__22OpenGLSurfaceEvaluator = 0;
__0this -> vcount__22OpenGLSurfaceEvaluator = 0;
} return __0this ;

}


void __gl__dt__22OpenGLSurfaceEvalu0 (struct OpenGLSurfaceEvaluator *__0this , 
int __0__free )
{ if (__0this ){ 
__0this -> __vptr__16CachingEvaluator = (struct __mptr *) __gl__ptbl_vec_____clients_gls0[2];

if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}

// extern void glDisable (GLenum );

void __gldisable__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *__0this , long __1type )
{ 
glDisable ( (unsigned int )__1type ) ;
}

// extern void glEnable (GLenum );

void __glenable__22OpenGLSurfaceEva0 (struct OpenGLSurfaceEvaluator *__0this , long __1type )
{ 
glEnable ( (unsigned int )__1type ) ;
}

// extern void glMapGrid2d (GLint , GLdouble , GLdouble , GLint , GLdouble , GLdouble );

void __glmapgrid2f__22OpenGLSurface0 (struct OpenGLSurfaceEvaluator *__0this , long __1nu , REAL __1u0 , REAL __1u1 , long __1nv , REAL __1v0 , REAL __1v1 )
{ 
glMapGrid2d ( (int )__1nu ,
(double )__1u0 , (double )__1u1 , (int )__1nv , (double )__1v0 , (double )__1v1 ) ;
}

// extern void glPolygonMode (GLenum , GLenum );

void __glpolymode__22OpenGLSurfaceE0 (struct OpenGLSurfaceEvaluator *__0this , long __1style )
{ 
switch (__1style ){ 
default :
case 0 :
glPolygonMode ( (unsigned int )0x0408 , (unsigned
int )0x1B02 ) ;
break ;
case 1 :
glPolygonMode ( (unsigned int )0x0408 , (unsigned int )0x1B01 ) ;
break ;
case 2 :
glPolygonMode ( (unsigned int )0x0408 , (unsigned int )0x1B00 ) ;
break ;
}
}

// extern void glBegin (GLenum );

void __glbgnline__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
glBegin ( (unsigned int )0x0003 ) ;
}

// extern void glEnd (void );

void __glendline__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
glEnd ( ) ;
}

void __glrange2f__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *__0this , long __1type , REAL *__1from , REAL *__1to )
{ 
}

void __gldomain2f__22OpenGLSurfaceE0 (struct OpenGLSurfaceEvaluator *__0this , REAL __1ulo , REAL __1uhi , REAL __1vlo , REAL __1vhi )
{

}

void __glbgnclosedline__22OpenGLSur0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
glBegin ( (unsigned int )0x0002 ) ;
}

void __glendclosedline__22OpenGLSur0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
glEnd ( ) ;
}

void __glbgntmesh__22OpenGLSurfaceE0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
__0this -> tmeshing__22OpenGLSurfaceEvaluator = 1 ;
__0this -> which__22OpenGLSurfaceEvaluator = 0 ;
__0this -> vcount__22OpenGLSurfaceEvaluator = 0 ;
glBegin ( (unsigned int )0x0004 ) ;
}

void __glswaptmesh__22OpenGLSurface0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
__0this -> which__22OpenGLSurfaceEvaluator = (1 - __0this -> which__22OpenGLSurfaceEvaluator );
}

void __glendtmesh__22OpenGLSurfaceE0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
__0this -> tmeshing__22OpenGLSurfaceEvaluator = 0 ;
glEnd ( ) ;
}

void __glbgnqstrip__22OpenGLSurface0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
glBegin ( (unsigned int )0x0008 ) ;
}

void __glendqstrip__22OpenGLSurface0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
glEnd ( ) ;
}

// extern void glPushAttrib (GLbitfield );

void __glbgnmap2f__22OpenGLSurfaceE0 (struct OpenGLSurfaceEvaluator *__0this , long __1__A10 )
{ 
glPushAttrib ( (unsigned int )0x00010000 ) ;
}

// extern void glPopAttrib (void );

void __glendmap2f__22OpenGLSurfaceE0 (struct OpenGLSurfaceEvaluator *__0this )
{ 
glPopAttrib ( ) ;
}

// extern void glMap2f (GLenum , GLfloat , GLfloat , GLint , GLint , GLfloat , GLfloat , GLint , GLint , GLfloat *);

void __glmap2f__22OpenGLSurfaceEval0 (struct OpenGLSurfaceEvaluator *__0this , 
long __1_type , 
REAL __1_ulower , 
REAL __1_uupper , 
long __1_ustride , 
long __1_uorder , 
REAL __1_vlower , 
REAL __1_vupper , 
long
__1_vstride , 
long __1_vorder , 
REAL *__1pts )
{ 
glMap2f ( (unsigned int )__1_type , __1_ulower , __1_uupper , (int )__1_ustride , (int )__1_uorder ,
__1_vlower , __1_vupper , (int )__1_vstride , (int )__1_vorder , (float *)__1pts ) ;
}

// extern void glEvalMesh2 (GLenum , GLint , GLint , GLint , GLint );

void __glmapmesh2f__22OpenGLSurface0 (struct OpenGLSurfaceEvaluator *__0this , long __1style , long __1umin , long __1umax , long __1vmin , long __1vmax )
{ 
switch
(__1style ){ 
default :
case 0 :
glEvalMesh2 ( (unsigned int )0x1B02 , (int )__1umin , (int )__1umax , (int )__1vmin , (int
)__1vmax ) ;
break ;
case 1 :
glEvalMesh2 ( (unsigned int )0x1B01 , (int )__1umin , (int )__1umax , (int )__1vmin , (int )__1vmax ) ;

break ;
case 2 :
glEvalMesh2 ( (unsigned int )0x1B00 , (int )__1umin , (int )__1umax , (int )__1vmin , (int )__1vmax ) ;

break ;
}
}

void __glnewtmeshvert__22OpenGLSurf1 (struct OpenGLSurfaceEvaluator *, REAL , REAL );

void __glevalcoord2f__22OpenGLSurfa0 (struct OpenGLSurfaceEvaluator *__0this , long __1__A11 , REAL __1u , REAL __1v )
{ 
__glnewtmeshvert__22OpenGLSurf1 ( __0this , __1u , __1v ) ;
}

void __glnewtmeshvert__22OpenGLSurf0 (struct OpenGLSurfaceEvaluator *, long , long );

void __glevalpoint2i__22OpenGLSurfa0 (struct OpenGLSurfaceEvaluator *__0this , long __1u , long __1v )
{ 
__glnewtmeshvert__22OpenGLSurf0 ( __0this , __1u , __1v ) ;
}

// extern void glEvalPoint2 (GLint , GLint );

void __glpoint2i__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *__0this , long __1u , long __1v )
{ 
glEvalPoint2 ( (int )__1u , (int )__1v ) ;
}

// extern void glEvalCoord2f (GLfloat , GLfloat );

void __glcoord2f__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *__0this , REAL __1u , REAL __1v )
{ 
glEvalCoord2f ( __1u , __1v ) ;
}



void __glnewtmeshvert__22OpenGLSurf0 (struct OpenGLSurfaceEvaluator *__0this , long __1u , long __1v )
{ 
if (__0this -> tmeshing__22OpenGLSurfaceEvaluator ){ 
struct StoredVertex *__0__X14 ;

if (__0this -> vcount__22OpenGLSurfaceEvaluator == 2 ){ 
struct StoredVertex *__0__X12 ;

struct StoredVertex *__0__X13 ;


{ 
__0__X12 = (struct StoredVertex *)(__0this -> vertexCache__22OpenGLSurfaceEvaluator [0 ]);

{ 
switch (__0__X12 -> type__12StoredVertex )
{ 
case 1 :
__glcoord2f__22OpenGLSurfaceEv0 ( (struct OpenGLSurfaceEvaluator *)((struct OpenGLSurfaceEvaluator *)__0this ), __0__X12 -> coord__12StoredVertex [0 ], __0__X12 -> coord__12StoredVertex [1 ]) ;

break ;

case 2 :
__glpoint2i__22OpenGLSurfaceEv0 ( (struct OpenGLSurfaceEvaluator *)((struct OpenGLSurfaceEvaluator *)__0this ), __0__X12 -> point__12StoredVertex [0 ], __0__X12 -> point__12StoredVertex [1 ]) ;

break ;

default :
break ;

}

}

}


{ 
__0__X13 = (struct StoredVertex *)(__0this -> vertexCache__22OpenGLSurfaceEvaluator [1 ]);

{ 
switch (__0__X13 -> type__12StoredVertex )
{ 
case 1 :
__glcoord2f__22OpenGLSurfaceEv0 ( (struct OpenGLSurfaceEvaluator *)((struct OpenGLSurfaceEvaluator *)__0this ), __0__X13 -> coord__12StoredVertex [0 ], __0__X13 -> coord__12StoredVertex [1 ]) ;

break ;

case 2 :
__glpoint2i__22OpenGLSurfaceEv0 ( (struct OpenGLSurfaceEvaluator *)((struct OpenGLSurfaceEvaluator *)__0this ), __0__X13 -> point__12StoredVertex [0 ], __0__X13 -> point__12StoredVertex [1 ]) ;

break ;

default :
break ;

}

}

}

glEvalPoint2 ( (int )__1u , (int )__1v ) ;
}
else 
{ 
__0this -> vcount__22OpenGLSurfaceEvaluator ++ ;
}
( (__0__X14 = (struct StoredVertex *)(__0this -> vertexCache__22OpenGLSurfaceEvaluator [__0this -> which__22OpenGLSurfaceEvaluator ])), ( ((__0__X14 -> point__12StoredVertex [0 ])= __1u ), ( ((__0__X14 -> point__12StoredVertex [1 ])= __1v ),
(__0__X14 -> type__12StoredVertex = 2 )) ) ) ;
__0this -> which__22OpenGLSurfaceEvaluator = (1 - __0this -> which__22OpenGLSurfaceEvaluator );
}
else 
{ 
glEvalPoint2 ( (int )__1u , (int )__1v ) ;
}
}



void __glnewtmeshvert__22OpenGLSurf1 (struct OpenGLSurfaceEvaluator *__0this , REAL __1u , REAL __1v )
{ 
if (__0this -> tmeshing__22OpenGLSurfaceEvaluator ){ 
struct StoredVertex *__0__X17 ;

if (__0this -> vcount__22OpenGLSurfaceEvaluator == 2 ){ 
struct StoredVertex *__0__X15 ;

struct StoredVertex *__0__X16 ;


{ 
__0__X15 = (struct StoredVertex *)(__0this -> vertexCache__22OpenGLSurfaceEvaluator [0 ]);

{ 
switch (__0__X15 -> type__12StoredVertex )
{ 
case 1 :
__glcoord2f__22OpenGLSurfaceEv0 ( (struct OpenGLSurfaceEvaluator *)((struct OpenGLSurfaceEvaluator *)__0this ), __0__X15 -> coord__12StoredVertex [0 ], __0__X15 -> coord__12StoredVertex [1 ]) ;

break ;

case 2 :
__glpoint2i__22OpenGLSurfaceEv0 ( (struct OpenGLSurfaceEvaluator *)((struct OpenGLSurfaceEvaluator *)__0this ), __0__X15 -> point__12StoredVertex [0 ], __0__X15 -> point__12StoredVertex [1 ]) ;

break ;

default :
break ;

}

}

}


{ 
__0__X16 = (struct StoredVertex *)(__0this -> vertexCache__22OpenGLSurfaceEvaluator [1 ]);

{ 
switch (__0__X16 -> type__12StoredVertex )
{ 
case 1 :
__glcoord2f__22OpenGLSurfaceEv0 ( (struct OpenGLSurfaceEvaluator *)((struct OpenGLSurfaceEvaluator *)__0this ), __0__X16 -> coord__12StoredVertex [0 ], __0__X16 -> coord__12StoredVertex [1 ]) ;

break ;

case 2 :
__glpoint2i__22OpenGLSurfaceEv0 ( (struct OpenGLSurfaceEvaluator *)((struct OpenGLSurfaceEvaluator *)__0this ), __0__X16 -> point__12StoredVertex [0 ], __0__X16 -> point__12StoredVertex [1 ]) ;

break ;

default :
break ;

}

}

}

glEvalCoord2f ( __1u , __1v ) ;
}
else 
{ 
__0this -> vcount__22OpenGLSurfaceEvaluator ++ ;
}
( (__0__X17 = (struct StoredVertex *)(__0this -> vertexCache__22OpenGLSurfaceEvaluator [__0this -> which__22OpenGLSurfaceEvaluator ])), ( ((__0__X17 -> coord__12StoredVertex [0 ])= __1u ), ( ((__0__X17 -> coord__12StoredVertex [1 ])= __1v ),
(__0__X17 -> type__12StoredVertex = 1 )) ) ) ;
__0this -> which__22OpenGLSurfaceEvaluator = (1 - __0this -> which__22OpenGLSurfaceEvaluator );
}
else 
{ 
glEvalCoord2f ( __1u , __1v ) ;
}
}
int __glcanRecord__16CachingEvalua0 (struct CachingEvaluator *);
int __glcanPlayAndRecord__16Cachin0 (struct CachingEvaluator *);
int __glcreateHandle__16CachingEva0 (struct CachingEvaluator *, int );
void __glbeginOutput__16CachingEval0 (struct CachingEvaluator *, int , int );
void __glendOutput__16CachingEvalua0 (struct CachingEvaluator *);
void __gldiscardRecording__16Cachin0 (struct CachingEvaluator *, int );
void __glplayRecording__16CachingEv0 (struct CachingEvaluator *, int );
struct __mptr __gl__vtbl__22OpenGLSurfaceEva0[] = {0,0,0,
0,0,(__vptp)__glcanRecord__16CachingEvalua0 ,
0,0,(__vptp)__glcanPlayAndRecord__16Cachin0 ,
0,0,(__vptp)__glcreateHandle__16CachingEva0 ,
0,0,(__vptp)__glbeginOutput__16CachingEval0 ,
0,0,(__vptp)__glendOutput__16CachingEvalua0 ,
0,0,(__vptp)__gldiscardRecording__16Cachin0 ,
0,0,(__vptp)__glplayRecording__16CachingEv0 ,
0,0,(__vptp)__glrange2f__22OpenGLSurfaceEv0 ,
0,0,(__vptp)__gldomain2f__22OpenGLSurfaceE0 ,
0,0,(__vptp)__glenable__22OpenGLSurfaceEva0 ,
0,0,(__vptp)__gldisable__22OpenGLSurfaceEv0 ,
0,0,(__vptp)__glbgnmap2f__22OpenGLSurfaceE0 ,
0,0,(__vptp)__glmap2f__22OpenGLSurfaceEval0 ,
0,0,(__vptp)__glmapgrid2f__22OpenGLSurface0 ,
0,0,(__vptp)__glmapmesh2f__22OpenGLSurface0 ,
0,0,(__vptp)__glevalcoord2f__22OpenGLSurfa0 ,
0,0,(__vptp)__glevalpoint2i__22OpenGLSurfa0 ,
0,0,(__vptp)__glendmap2f__22OpenGLSurfaceE0 ,
0,0,(__vptp)__glpolymode__22OpenGLSurfaceE0 ,
0,0,(__vptp)__glbgnline__22OpenGLSurfaceEv0 ,
0,0,(__vptp)__glendline__22OpenGLSurfaceEv0 ,
0,0,(__vptp)__glbgnclosedline__22OpenGLSur0 ,
0,0,(__vptp)__glendclosedline__22OpenGLSur0 ,
0,0,(__vptp)__glbgntmesh__22OpenGLSurfaceE0 ,
0,0,(__vptp)__glswaptmesh__22OpenGLSurface0 ,
0,0,(__vptp)__glendtmesh__22OpenGLSurfaceE0 ,
0,0,(__vptp)__glbgnqstrip__22OpenGLSurface0 ,
0,0,(__vptp)__glendqstrip__22OpenGLSurface0 ,
0,0,0};
extern struct __mptr __gl__vtbl__21BasicSurfaceEval0[];
extern struct __mptr __gl__vtbl__16CachingEvaluator[];

static void *__nw__FUi (
size_t __1s )
{ 
void *__1__Xp0025pnaiaa ;

__1__Xp0025pnaiaa = malloc ( __1s ) ;
if (__1__Xp0025pnaiaa ){ 
return __1__Xp0025pnaiaa ;
}
else 
{ 
return __1__Xp0025pnaiaa ;
}
}
struct __mptr* __gl__ptbl_vec_____clients_gls0[] = {
__gl__vtbl__16CachingEvaluator,
__gl__vtbl__21BasicSurfaceEval0,
__gl__vtbl__22OpenGLSurfaceEva0,

};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\glrender.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <windows.h>
#include <GL/glu.h>
#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../clients/glrenderer.c++ > */


void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };


typedef unsigned int GLenum ;
typedef unsigned char GLboolean ;
typedef unsigned int GLbitfield ;
typedef signed char GLbyte ;
typedef short GLshort ;
typedef int GLint ;
typedef int GLsizei ;
typedef unsigned char GLubyte ;
typedef unsigned short GLushort ;
typedef unsigned int GLuint ;
typedef float GLfloat ;
typedef float GLclampf ;
typedef double GLdouble ;
typedef double GLclampd ;
typedef void GLvoid ;





typedef struct GLUquadricObj GLUquadricObj ;

typedef struct GLUtriangulatorObj GLUtriangulatorObj ;
struct GLUnurbsObj;







typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);









struct JumpBuffer;













struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};




struct Renderhints;

struct Renderhints {	

REAL display_method__11Renderhints ;
REAL errorchecking__11Renderhints ;
REAL subdivisions__11Renderhints ;
REAL tmp1__11Renderhints ;

int displaydomain__11Renderhints ;
int maxsubdivisions__11Renderhints ;
int wiretris__11Renderhints ;
int wirequads__11Renderhints ;
};






struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};






struct Mapdesc;

struct Maplist;

void __gl__dt__4PoolFv (struct Pool *, int );


struct Maplist {	

struct Pool mapdescPool__7Maplist ;
struct Mapdesc *maps__7Maplist ;
struct Mapdesc **lastmap__7Maplist ;
struct Backend *backend__7Maplist ;
};

struct Mapdesc *__gllocate__7MaplistFl (struct Maplist *, long );

void __glremove__7MaplistFP7Mapdesc (struct Maplist *, struct Mapdesc *);



enum Curvetype { ct_nurbscurve = 0, ct_pwlcurve = 1, ct_none = 2} ;
struct Property;

struct O_surface;

struct O_nurbssurface;

struct O_trim;

struct O_pwlcurve;

struct O_nurbscurve;

struct O_curve;

struct Quilt;


union __Q2_7O_curve4__C1;

union  __Q2_7O_curve4__C1 {	
struct O_nurbscurve *o_nurbscurve ;
struct O_pwlcurve *o_pwlcurve ;
};


struct O_curve;

struct O_curve {	

char __W3__9PooledObj ;

union  __Q2_7O_curve4__C1 curve__7O_curve ;
int curvetype__7O_curve ;
struct O_curve *next__7O_curve ;
struct O_surface *owner__7O_curve ;
int used__7O_curve ;
int save__7O_curve ;
long nuid__7O_curve ;
};






struct O_nurbscurve;

struct O_nurbscurve {	

char __W3__9PooledObj ;

struct Quilt *bezier_curves__12O_nurbscurve ;
long type__12O_nurbscurve ;
REAL tesselation__12O_nurbscurve ;
int method__12O_nurbscurve ;
struct O_nurbscurve *next__12O_nurbscurve ;
int used__12O_nurbscurve ;
int save__12O_nurbscurve ;
struct O_curve *owner__12O_nurbscurve ;
};






struct O_pwlcurve;



struct O_pwlcurve {	

char __W3__9PooledObj ;

struct TrimVertex *pts__10O_pwlcurve ;
int npts__10O_pwlcurve ;
struct O_pwlcurve *next__10O_pwlcurve ;
int used__10O_pwlcurve ;
int save__10O_pwlcurve ;
struct O_curve *owner__10O_pwlcurve ;
};



struct O_trim;

struct O_trim {	

char __W3__9PooledObj ;

struct O_curve *o_curve__6O_trim ;
struct O_trim *next__6O_trim ;
int save__6O_trim ;
};






struct O_nurbssurface;

struct O_nurbssurface {	

char __W3__9PooledObj ;

struct Quilt *bezier_patches__14O_nurbssurface ;
long type__14O_nurbssurface ;
struct O_surface *owner__14O_nurbssurface ;
struct O_nurbssurface *next__14O_nurbssurface ;
int save__14O_nurbssurface ;
int used__14O_nurbssurface ;
};






struct O_surface;

struct O_surface {	

char __W3__9PooledObj ;

struct O_nurbssurface *o_nurbssurface__9O_surface ;
struct O_trim *o_trim__9O_surface ;
int save__9O_surface ;
long nuid__9O_surface ;
};






struct Property;

struct Property {	

char __W3__9PooledObj ;

long type__8Property ;
long tag__8Property ;
REAL value__8Property ;
int save__8Property ;
};




struct NurbsTessellator;


struct Knotvector;

struct Quilt;

struct DisplayList;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct NurbsTessellator;

struct NurbsTessellator {	

struct Renderhints renderhints__16NurbsTessellator ;
struct Maplist maplist__16NurbsTessellator ;
struct Backend backend__16NurbsTessellator ;

struct Subdivider subdivider__16NurbsTessellator ;
struct JumpBuffer *jumpbuffer__16NurbsTessellator ;
struct Pool o_pwlcurvePool__16NurbsTessellator ;
struct Pool o_nurbscurvePool__16NurbsTessellator ;
struct Pool o_curvePool__16NurbsTessellator ;
struct Pool o_trimPool__16NurbsTessellator ;
struct Pool o_surfacePool__16NurbsTessellator ;
struct Pool o_nurbssurfacePool__16NurbsTessellator ;
struct Pool propertyPool__16NurbsTessellator ;
struct Pool quiltPool__16NurbsTessellator ;
struct TrimVertexPool extTrimVertexPool__16NurbsTessellator ;

int inSurface__16NurbsTessellator ;
int inCurve__16NurbsTessellator ;
int inTrim__16NurbsTessellator ;
int isCurveModified__16NurbsTessellator ;
int isTrimModified__16NurbsTessellator ;
int isSurfaceModified__16NurbsTessellator ;
int isDataValid__16NurbsTessellator ;
int numTrims__16NurbsTessellator ;
int playBack__16NurbsTessellator ;

struct O_trim **nextTrim__16NurbsTessellator ;
struct O_curve **nextCurve__16NurbsTessellator ;
struct O_nurbscurve **nextNurbscurve__16NurbsTessellator ;
struct O_pwlcurve **nextPwlcurve__16NurbsTessellator ;
struct O_nurbssurface **nextNurbssurface__16NurbsTessellator ;

struct O_surface *currentSurface__16NurbsTessellator ;
struct O_trim *currentTrim__16NurbsTessellator ;
struct O_curve *currentCurve__16NurbsTessellator ;

struct DisplayList *dl__16NurbsTessellator ;

struct __mptr *__vptr__16NurbsTessellator ;
};

extern char *__glNurbsErrors [];











struct CachingEvaluator;
enum __Q2_16CachingEvaluator11ServiceMode { play__Q2_16CachingEvaluator11ServiceMode = 0, record__Q2_16CachingEvaluator11ServiceMode = 1, playAndRecord__Q2_16CachingEvaluator11ServiceMode = 2} ;

struct CachingEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};



struct BasicSurfaceEvaluator;


struct BasicSurfaceEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

static void *__nw__FUi (size_t );


struct SurfaceMap;

struct OpenGLSurfaceEvaluator;

struct StoredVertex;

struct StoredVertex;

struct StoredVertex {	

int type__12StoredVertex ;
REAL coord__12StoredVertex [2];
long point__12StoredVertex [2];
};


struct OpenGLSurfaceEvaluator;

struct OpenGLSurfaceEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;

struct StoredVertex *vertexCache__22OpenGLSurfaceEvaluator [3];
int tmeshing__22OpenGLSurfaceEvaluator ;
int which__22OpenGLSurfaceEvaluator ;
int vcount__22OpenGLSurfaceEvaluator ;
};


void __glcoord2f__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *, REAL , REAL );
void __glpoint2i__22OpenGLSurfaceEv0 (struct OpenGLSurfaceEvaluator *, long , long );





struct BasicCurveEvaluator;


struct BasicCurveEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};


struct CurveMap;

struct OpenGLCurveEvaluator;

struct OpenGLCurveEvaluator {	

struct __mptr *__vptr__16CachingEvaluator ;
};

struct GLUnurbsObj;

struct GLUnurbsObj {	

struct Renderhints renderhints__16NurbsTessellator ;
struct Maplist maplist__16NurbsTessellator ;
struct Backend backend__16NurbsTessellator ;

struct Subdivider subdivider__16NurbsTessellator ;
struct JumpBuffer *jumpbuffer__16NurbsTessellator ;
struct Pool o_pwlcurvePool__16NurbsTessellator ;
struct Pool o_nurbscurvePool__16NurbsTessellator ;
struct Pool o_curvePool__16NurbsTessellator ;
struct Pool o_trimPool__16NurbsTessellator ;
struct Pool o_surfacePool__16NurbsTessellator ;
struct Pool o_nurbssurfacePool__16NurbsTessellator ;
struct Pool propertyPool__16NurbsTessellator ;
struct Pool quiltPool__16NurbsTessellator ;
struct TrimVertexPool extTrimVertexPool__16NurbsTessellator ;

int inSurface__16NurbsTessellator ;
int inCurve__16NurbsTessellator ;
int inTrim__16NurbsTessellator ;
int isCurveModified__16NurbsTessellator ;
int isTrimModified__16NurbsTessellator ;
int isSurfaceModified__16NurbsTessellator ;
int isDataValid__16NurbsTessellator ;
int numTrims__16NurbsTessellator ;
int playBack__16NurbsTessellator ;

struct O_trim **nextTrim__16NurbsTessellator ;
struct O_curve **nextCurve__16NurbsTessellator ;
struct O_nurbscurve **nextNurbscurve__16NurbsTessellator ;
struct O_pwlcurve **nextPwlcurve__16NurbsTessellator ;
struct O_nurbssurface **nextNurbssurface__16NurbsTessellator ;

struct O_surface *currentSurface__16NurbsTessellator ;
struct O_trim *currentTrim__16NurbsTessellator ;
struct O_curve *currentCurve__16NurbsTessellator ;

struct DisplayList *dl__16NurbsTessellator ;

struct __mptr *__vptr__16NurbsTessellator ;

GLUnurbsErrorProc errorCallback__11GLUnurbsObj;

GLboolean autoloadmode__11GLUnurbsObj ;
struct OpenGLSurfaceEvaluator surfaceEvaluator__11GLUnurbsObj ;
struct OpenGLCurveEvaluator curveEvaluator__11GLUnurbsObj ;
};

void __gl__dt__22OpenGLSurfaceEvalu0 (struct OpenGLSurfaceEvaluator *, int );

void __gl__dt__20OpenGLCurveEvaluat0 (struct OpenGLCurveEvaluator *, int );

void __gl__dt__16NurbsTessellatorFv (struct NurbsTessellator *, int );




struct NurbsTessellator *__gl__ct__16NurbsTessellatorFR0 (struct NurbsTessellator *, struct BasicCurveEvaluator *, struct BasicSurfaceEvaluator *);

void __glredefineMaps__16NurbsTesse0 (struct NurbsTessellator *);

void __gldefineMap__16NurbsTessella0 (struct NurbsTessellator *, long , long , long );

void __glsetnurbsproperty__16NurbsT1 (struct NurbsTessellator *, long , long , float );
extern struct __mptr* __gl__ptbl_vec_____clients_glr0[];

struct OpenGLSurfaceEvaluator *__gl__ct__22OpenGLSurfaceEvalu0 (struct OpenGLSurfaceEvaluator *);

struct OpenGLCurveEvaluator *__gl__ct__20OpenGLCurveEvaluat0 (struct OpenGLCurveEvaluator *);

struct GLUnurbsObj *__gl__ct__11GLUnurbsObjFv (struct GLUnurbsObj *__0this )
{ 
void *__1__Xp00qshqaiaa ;

if (__0this || (__0this = (struct GLUnurbsObj *)( (__1__Xp00qshqaiaa = malloc ( (sizeof (struct GLUnurbsObj))) ), (__1__Xp00qshqaiaa ?(((void *)__1__Xp00qshqaiaa )):(((void *)__1__Xp00qshqaiaa )))) )){
( ( ( (__0this = (struct GLUnurbsObj *)__gl__ct__16NurbsTessellatorFR0 ( ((struct NurbsTessellator *)__0this ), (struct BasicCurveEvaluator *)(& __0this -> curveEvaluator__11GLUnurbsObj ), (struct BasicSurfaceEvaluator *)(&
__0this -> surfaceEvaluator__11GLUnurbsObj )) ), (__0this -> __vptr__16NurbsTessellator = (struct __mptr *) __gl__ptbl_vec_____clients_glr0[0])) , __gl__ct__22OpenGLSurfaceEvalu0 ( (struct OpenGLSurfaceEvaluator *)(& __0this -> surfaceEvaluator__11GLUnurbsObj )) )
, __gl__ct__20OpenGLCurveEvaluat0 ( (struct OpenGLCurveEvaluator *)(& __0this -> curveEvaluator__11GLUnurbsObj )) ) ;
__glredefineMaps__16NurbsTesse0 ( (struct NurbsTessellator *)__0this ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0DB2 , (long )0 , (long )3 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0D92 , (long )0 , (long )3 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0DB3 , (long )0 , (long )1 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0D93 , (long )0 , (long )1 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0DB4 , (long )0 , (long )2 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0D94 , (long )0 , (long )2 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0DB5 , (long )0 , (long )3 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0D95 , (long )0 , (long )3 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0DB6 , (long )1 , (long )4 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0D96 , (long )1 , (long )4 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0DB8 , (long )1 , (long )4 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0D98 , (long )1 , (long )4 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0DB7 , (long )0 , (long )3 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0D97 , (long )0 , (long )3 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0DB0 , (long )0 , (long )4 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0D90 , (long )0 , (long )4 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0DB1 , (long )0 , (long )1 ) ;
__gldefineMap__16NurbsTessella0 ( (struct NurbsTessellator *)__0this , (long )0x0D91 , (long )0 , (long )1 ) ;

__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0D97 , (long )10 , (float )6.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0D98 , (long )10 , (float )6.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0DB7 , (long )10 , (float )6.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0DB8 , (long )10 , (float )6.0 ) ;

__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0D97 , (long )1 , (float )50.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0D98 , (long )1 , (float )50.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0DB7 , (long )1 , (float )50.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0DB8 , (long )1 , (float )50.0 ) ;

__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0D97 , (long )6 , (float )100.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0D98 , (long )6 , (float )100.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0DB7 , (long )6 , (float )100.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0DB8 , (long )6 , (float )100.0 ) ;

__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0D97 , (long )7 , (float )100.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0D98 , (long )7 , (float )100.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0DB7 , (long )7 , (float )100.0 ) ;
__glsetnurbsproperty__16NurbsT1 ( (struct NurbsTessellator *)__0this , (long )0x0DB8 , (long )7 , (float )100.0 ) ;

__0this -> autoloadmode__11GLUnurbsObj = 1 ;
} return __0this ;

}

void __glloadGLMatrices__11GLUnurbs0 (struct GLUnurbsObj *);

void __glbgnrender__11GLUnurbsObjFv (struct GLUnurbsObj *__0this )
{ 
if (__0this -> autoloadmode__11GLUnurbsObj ){ 
__glloadGLMatrices__11GLUnurbs0 ( __0this ) ;
}
}

void __glendrender__11GLUnurbsObjFv (struct GLUnurbsObj *__0this )
{ 
}


void __glerrorHandler__11GLUnurbsOb0 (struct GLUnurbsObj *__0this , int __1i )
{ 
GLenum __1gluError ;

__1gluError = (__1i + 100250);
( (__0this -> errorCallback__11GLUnurbsObj ?( ((*__0this -> errorCallback__11GLUnurbsObj ))( __1gluError ) , 0 ) :( 0 ) )) ;
}

void __glgrabGLMatrix__11GLUnurbsOb0 (GLfloat (*)[4]);

void __glloadCullingMatrix__11GLUnu0 (struct GLUnurbsObj *, GLfloat (*)[4]);

// extern void glGetIntegerv (GLenum , int *);

void __glloadSamplingMatrix__11GLUn0 (struct GLUnurbsObj *, GLfloat (*)[4], GLint *);

void __glloadGLMatrices__11GLUnurbs0 (struct GLUnurbsObj *__0this )
{ 
GLfloat __1vmat [4][4];
GLint __1viewport [4];

__glgrabGLMatrix__11GLUnurbsOb0 ( (float (*)[4])__1vmat ) ;
__glloadCullingMatrix__11GLUnu0 ( __0this , (float (*)[4])__1vmat ) ;
glGetIntegerv ( (unsigned int )0x0BA2 , (int *)__1viewport ) ;
__glloadSamplingMatrix__11GLUn0 ( __0this , (float (*)[4])__1vmat , (int *)__1viewport ) ;
}

void __glmultmatrix4d__11GLUnurbsOb0 (float (*)[4], float (*)[4], float (*)[4]);

void __gluseGLMatrices__11GLUnurbsO0 (struct GLUnurbsObj *__0this , GLfloat *__1modelMatrix , 
GLfloat *__1projMatrix , 
GLint *__1viewport )
{ 
GLfloat __1vmat [4][4];

__glmultmatrix4d__11GLUnurbsOb0 ( (float (*)[4])__1vmat , (float (*)[4])(((float (*)[4])__1modelMatrix )), (float (*)[4])(((float (*)[4])__1projMatrix ))) ;
__glloadCullingMatrix__11GLUnu0 ( __0this , (float (*)[4])__1vmat ) ;
__glloadSamplingMatrix__11GLUn0 ( __0this , (float (*)[4])__1vmat , __1viewport ) ;
}

// extern void glGetFloatv (GLenum , GLfloat *);

void __glgrabGLMatrix__11GLUnurbsOb0 (GLfloat (*__1vmat )[4])
{ 
GLfloat __1m1 [4][4];

GLfloat __1m2 [4][4];

glGetFloatv ( (unsigned int )0x0BA6 , & ((__1m1 [0 ])[0 ])) ;
glGetFloatv ( (unsigned int )0x0BA7 , & ((__1m2 [0 ])[0 ])) ;
__glmultmatrix4d__11GLUnurbsOb0 ( __1vmat , (float (*)[4])__1m1 , (float (*)[4])__1m2 ) ;
}

void __glsetnurbsproperty__16NurbsT3 (struct NurbsTessellator *, long , long , float *, long , long );

void __glloadSamplingMatrix__11GLUn0 (struct GLUnurbsObj *__0this , GLfloat (*__1vmat )[4], 
GLint *__1viewport )
{ 
REAL __1xsize ;
REAL __1ysize ;

float __1smat [4][4];

__1xsize = (0.5 * (((float )(__1viewport [2 ]))));
__1ysize = (0.5 * (((float )(__1viewport [3 ]))));

((__1smat [0 ])[0 ])= (((__1vmat [0 ])[0 ])* __1xsize );
((__1smat [1 ])[0 ])= (((__1vmat [1 ])[0 ])* __1xsize );
((__1smat [2 ])[0 ])= (((__1vmat [2 ])[0 ])* __1xsize );
((__1smat [3 ])[0 ])= (((__1vmat [3 ])[0 ])* __1xsize );

((__1smat [0 ])[1 ])= (((__1vmat [0 ])[1 ])* __1ysize );
((__1smat [1 ])[1 ])= (((__1vmat [1 ])[1 ])* __1ysize );
((__1smat [2 ])[1 ])= (((__1vmat [2 ])[1 ])* __1ysize );
((__1smat [3 ])[1 ])= (((__1vmat [3 ])[1 ])* __1ysize );

((__1smat [0 ])[2 ])= 0.0 ;
((__1smat [1 ])[2 ])= 0.0 ;
((__1smat [2 ])[2 ])= 0.0 ;
((__1smat [3 ])[2 ])= 0.0 ;

((__1smat [0 ])[3 ])= ((__1vmat [0 ])[3 ]);
((__1smat [1 ])[3 ])= ((__1vmat [1 ])[3 ]);
((__1smat [2 ])[3 ])= ((__1vmat [2 ])[3 ]);
((__1smat [3 ])[3 ])= ((__1vmat [3 ])[3 ]);

{ 

__glsetnurbsproperty__16NurbsT3 ( (struct NurbsTessellator *)__0this , (long )0x0DB7 , (long )2 , & ((__1smat [0 ])[0 ]), (long )((long )4), (long
)((long )1)) ;

__glsetnurbsproperty__16NurbsT3 ( (struct NurbsTessellator *)__0this , (long )0x0DB8 , (long )2 , & ((__1smat [0 ])[0 ]), (long )((long )4), (long )((long
)1)) ;

}
}

void __glloadCullingMatrix__11GLUnu0 (struct GLUnurbsObj *__0this , GLfloat (*__1vmat )[4])
{ 
float __1cmat [4][4];

((__1cmat [0 ])[0 ])= ((__1vmat [0 ])[0 ]);
((__1cmat [0 ])[1 ])= ((__1vmat [0 ])[1 ]);
((__1cmat [0 ])[2 ])= ((__1vmat [0 ])[2 ]);
((__1cmat [0 ])[3 ])= ((__1vmat [0 ])[3 ]);

((__1cmat [1 ])[0 ])= ((__1vmat [1 ])[0 ]);
((__1cmat [1 ])[1 ])= ((__1vmat [1 ])[1 ]);
((__1cmat [1 ])[2 ])= ((__1vmat [1 ])[2 ]);
((__1cmat [1 ])[3 ])= ((__1vmat [1 ])[3 ]);

((__1cmat [2 ])[0 ])= ((__1vmat [2 ])[0 ]);
((__1cmat [2 ])[1 ])= ((__1vmat [2 ])[1 ]);
((__1cmat [2 ])[2 ])= ((__1vmat [2 ])[2 ]);
((__1cmat [2 ])[3 ])= ((__1vmat [2 ])[3 ]);

((__1cmat [3 ])[0 ])= ((__1vmat [3 ])[0 ]);
((__1cmat [3 ])[1 ])= ((__1vmat [3 ])[1 ]);
((__1cmat [3 ])[2 ])= ((__1vmat [3 ])[2 ]);
((__1cmat [3 ])[3 ])= ((__1vmat [3 ])[3 ]);

{ 

__glsetnurbsproperty__16NurbsT3 ( (struct NurbsTessellator *)__0this , (long )0x0DB7 , (long )1 , & ((__1cmat [0 ])[0 ]), (long )((long )4), (long
)((long )1)) ;

__glsetnurbsproperty__16NurbsT3 ( (struct NurbsTessellator *)__0this , (long )0x0DB8 , (long )1 , & ((__1cmat [0 ])[0 ]), (long )((long )4), (long )((long
)1)) ;

}
}

void __gltransform4d__11GLUnurbsObj0 (float *__1A , float *__1B , float (*__1mat )[4])
{ 
(__1A [0 ])= (((((__1B [0 ])* ((__1mat [0 ])[0 ]))+ ((__1B [1 ])* ((__1mat [1 ])[0 ])))+ ((__1B [2 ])* ((__1mat [2 ])[0 ])))+
((__1B [3 ])* ((__1mat [3 ])[0 ])));
(__1A [1 ])= (((((__1B [0 ])* ((__1mat [0 ])[1 ]))+ ((__1B [1 ])* ((__1mat [1 ])[1 ])))+ ((__1B [2 ])* ((__1mat [2 ])[1 ])))+ ((__1B [3 ])* ((__1mat [3 ])[1 ])));
(__1A [2 ])= (((((__1B [0 ])* ((__1mat [0 ])[2 ]))+ ((__1B [1 ])* ((__1mat [1 ])[2 ])))+ ((__1B [2 ])* ((__1mat [2 ])[2 ])))+ ((__1B [3 ])* ((__1mat [3 ])[2 ])));
(__1A [3 ])= (((((__1B [0 ])* ((__1mat [0 ])[3 ]))+ ((__1B [1 ])* ((__1mat [1 ])[3 ])))+ ((__1B [2 ])* ((__1mat [2 ])[3 ])))+ ((__1B [3 ])* ((__1mat [3 ])[3 ])));
}

void __glmultmatrix4d__11GLUnurbsOb0 (float (*__1n )[4], float (*__1left )[4], float (*__1right )[4])
{ 
__gltransform4d__11GLUnurbsObj0 ( (float *)(__1n [0 ]), (float *)(__1left [0 ]), __1right ) ;

__gltransform4d__11GLUnurbsObj0 ( (float *)(__1n [1 ]), (float *)(__1left [1 ]), __1right ) ;
__gltransform4d__11GLUnurbsObj0 ( (float *)(__1n [2 ]), (float *)(__1left [2 ]), __1right ) ;
__gltransform4d__11GLUnurbsObj0 ( (float *)(__1n [3 ]), (float *)(__1left [3 ]), __1right ) ;
}
void __glmakeobj__16NurbsTessellato0 (struct NurbsTessellator *, int );
void __glcloseobj__16NurbsTessellat0 (struct NurbsTessellator *);
struct __mptr __gl__vtbl__11GLUnurbsObj[] = {0,0,0,
0,0,(__vptp)__glbgnrender__11GLUnurbsObjFv ,
0,0,(__vptp)__glendrender__11GLUnurbsObjFv ,
0,0,(__vptp)__glmakeobj__16NurbsTessellato0 ,
0,0,(__vptp)__glcloseobj__16NurbsTessellat0 ,
0,0,(__vptp)__glerrorHandler__11GLUnurbsOb0 ,
0,0,0};

static void *__nw__FUi (
size_t __1s )
{ 
void *__1__Xp00qshqaiaa ;

__1__Xp00qshqaiaa = malloc ( __1s ) ;
if (__1__Xp00qshqaiaa ){ 
return __1__Xp00qshqaiaa ;
}
else 
{ 
return __1__Xp00qshqaiaa ;
}
}
struct __mptr* __gl__ptbl_vec_____clients_glr0[] = {
__gl__vtbl__11GLUnurbsObj,

};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\intersec.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/intersect.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct JumpBuffer;








struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};






struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};



enum i_result { INTERSECT_VERTEX = 0, INTERSECT_EDGE = 1} ;

struct Bin *__gl__ct__3BinFv (struct Bin *);





int __glarc_split__10SubdividerFP30 (struct Subdivider *, struct Arc *, int , REAL , int );



void __glclassify_headonleft_s__10S0 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, REAL );
void __glclassify_tailonleft_s__10S0 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, REAL );
void __glclassify_headonright_s__100 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, REAL );
void __glclassify_tailonright_s__100 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, REAL );
void __glclassify_headonleft_t__10S0 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, REAL );
void __glclassify_tailonleft_t__10S0 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, REAL );
void __glclassify_headonright_t__100 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, REAL );
void __glclassify_tailonright_t__100 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, REAL );
extern struct __mptr* __ptbl_vec_____core_intersect_c___partition_[];

void __gl__dt__3BinFv (struct Bin *, int );

void __glpartition__10SubdividerFR30 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1left , struct Bin *__1intersections , 
struct Bin *__1right , struct Bin *__1unknown , int
__1param , REAL __1value )
{ 
struct Bin __1headonleft ;

struct Bin __1headonright ;

struct Bin __1tailonleft ;

struct Bin __1tailonright ;

__gl__ct__3BinFv ( (struct Bin *)(& __1headonleft )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __1headonright )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __1tailonleft )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __1tailonright )) ;

{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00efckaice ;

__1jarc = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ), 0 )
:( 0 ) ), __1__Xjarc00efckaice ) ) ;

for(;__1jarc ;__1jarc = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ), 0 )
:( 0 ) ), __1__Xjarc00efckaice ) ) ) { 
REAL __2tdiff ;
REAL __2hdiff ;

__2tdiff = ((( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [__1param ])- __1value );
__2hdiff = ((( (((REAL *)(((struct Arc *)__1jarc )-> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [__1param ])- __1value );

if (__2tdiff > 0.0 ){ 
if (__2hdiff > 0.0 ){ 
( (__1jarc -> link__3Arc = ((struct Bin *)__1right )-> head__3Bin ), (((struct Bin *)__1right )->
head__3Bin = __1jarc )) ;
}
else 
if (__2hdiff == 0.0 ){ 
( (__1jarc -> link__3Arc = ((struct Bin *)(& __1tailonright ))-> head__3Bin ), (((struct Bin *)(& __1tailonright ))->
head__3Bin = __1jarc )) ;
}
else 
{ 
Arc_ptr __4jtemp ;
switch (__glarc_split__10SubdividerFP30 ( __0this , __1jarc , __1param , __1value , 0 ) ){ 
struct Arc *__1__X13 ;

struct Arc *__1__X14 ;

struct Arc *__1__X15 ;

struct Arc *__1__X16 ;

struct Arc *__1__X17 ;

struct Arc *__1__X18 ;

struct Arc *__1__X19 ;

struct Arc *__1__X20 ;

case 2 :
( (__1jarc -> link__3Arc = ((struct Bin *)(& __1tailonright ))-> head__3Bin ), (((struct Bin *)(& __1tailonright ))-> head__3Bin = __1jarc )) ;

( (__1__X13 = __1jarc -> next__3Arc ), ( (__1__X13 -> link__3Arc = ((struct Bin *)(& __1headonleft ))-> head__3Bin ), (((struct Bin *)(& __1headonleft ))->
head__3Bin = __1__X13 )) ) ;
break ;
case 31 :
((void )0 );
( (__1jarc -> link__3Arc = ((struct Bin *)__1right )-> head__3Bin ), (((struct Bin *)__1right )-> head__3Bin = __1jarc )) ;
( (__1__X14 = (__4jtemp = __1jarc -> next__3Arc )), ( (__1__X14 -> link__3Arc = ((struct Bin *)(& __1tailonright ))-> head__3Bin ), (((struct Bin *)(&
__1tailonright ))-> head__3Bin = __1__X14 )) ) ;
( (__1__X15 = __4jtemp -> next__3Arc ), ( (__1__X15 -> link__3Arc = ((struct Bin *)(& __1headonleft ))-> head__3Bin ), (((struct Bin *)(& __1headonleft ))->
head__3Bin = __1__X15 )) ) ;
break ;
case 32 :
((void )0 );
( (__1jarc -> link__3Arc = ((struct Bin *)(& __1tailonright ))-> head__3Bin ), (((struct Bin *)(& __1tailonright ))-> head__3Bin = __1jarc )) ;
( (__1__X16 = (__4jtemp = __1jarc -> next__3Arc )), ( (__1__X16 -> link__3Arc = ((struct Bin *)(& __1headonleft ))-> head__3Bin ), (((struct Bin *)(&
__1headonleft ))-> head__3Bin = __1__X16 )) ) ;
( (__1__X17 = __4jtemp -> next__3Arc ), ( (__1__X17 -> link__3Arc = ((struct Bin *)__1left )-> head__3Bin ), (((struct Bin *)__1left )-> head__3Bin = __1__X17 ))
) ;
break ;
case 4 :
( (__1jarc -> link__3Arc = ((struct Bin *)__1right )-> head__3Bin ), (((struct Bin *)__1right )-> head__3Bin = __1jarc )) ;
( (__1__X18 = (__4jtemp = __1jarc -> next__3Arc )), ( (__1__X18 -> link__3Arc = ((struct Bin *)(& __1tailonright ))-> head__3Bin ), (((struct Bin *)(&
__1tailonright ))-> head__3Bin = __1__X18 )) ) ;
( (__1__X19 = (__4jtemp = __4jtemp -> next__3Arc )), ( (__1__X19 -> link__3Arc = ((struct Bin *)(& __1headonleft ))-> head__3Bin ), (((struct Bin *)(&
__1headonleft ))-> head__3Bin = __1__X19 )) ) ;
( (__1__X20 = __4jtemp -> next__3Arc ), ( (__1__X20 -> link__3Arc = ((struct Bin *)__1left )-> head__3Bin ), (((struct Bin *)__1left )-> head__3Bin = __1__X20 ))
) ;
}
}
}
else 
if (__2tdiff == 0.0 ){ 
if (__2hdiff > 0.0 ){ 
( (__1jarc -> link__3Arc = ((struct Bin *)(& __1headonright ))-> head__3Bin ),
(((struct Bin *)(& __1headonright ))-> head__3Bin = __1jarc )) ;
}
else 
if (__2hdiff == 0.0 ){ 
( (__1jarc -> link__3Arc = ((struct Bin *)__1unknown )-> head__3Bin ), (((struct Bin *)__1unknown )-> head__3Bin = __1jarc ))
;
}
else 
{ 
( (__1jarc -> link__3Arc = ((struct Bin *)(& __1headonleft ))-> head__3Bin ), (((struct Bin *)(& __1headonleft ))-> head__3Bin = __1jarc ))
;
}
}
else 
{ 
if (__2hdiff > 0.0 ){ 
Arc_ptr __4jtemp ;
switch (__glarc_split__10SubdividerFP30 ( __0this , __1jarc , __1param , __1value , 1 ) ){ 
struct Arc *__1__X21 ;

struct Arc *__1__X22 ;

struct Arc *__1__X23 ;

struct Arc *__1__X24 ;

struct Arc *__1__X25 ;

struct Arc *__1__X26 ;

struct Arc *__1__X27 ;

struct Arc *__1__X28 ;

case 2 :
( (__1jarc -> link__3Arc = ((struct Bin *)(& __1tailonleft ))-> head__3Bin ), (((struct Bin *)(& __1tailonleft ))-> head__3Bin = __1jarc )) ;

( (__1__X21 = __1jarc -> next__3Arc ), ( (__1__X21 -> link__3Arc = ((struct Bin *)(& __1headonright ))-> head__3Bin ), (((struct Bin *)(& __1headonright ))->
head__3Bin = __1__X21 )) ) ;
break ;
case 31 :
((void )0 );
( (__1jarc -> link__3Arc = ((struct Bin *)__1left )-> head__3Bin ), (((struct Bin *)__1left )-> head__3Bin = __1jarc )) ;
( (__1__X22 = (__4jtemp = __1jarc -> next__3Arc )), ( (__1__X22 -> link__3Arc = ((struct Bin *)(& __1tailonleft ))-> head__3Bin ), (((struct Bin *)(&
__1tailonleft ))-> head__3Bin = __1__X22 )) ) ;
( (__1__X23 = __4jtemp -> next__3Arc ), ( (__1__X23 -> link__3Arc = ((struct Bin *)(& __1headonright ))-> head__3Bin ), (((struct Bin *)(& __1headonright ))->
head__3Bin = __1__X23 )) ) ;
break ;
case 32 :
((void )0 );
( (__1jarc -> link__3Arc = ((struct Bin *)(& __1tailonleft ))-> head__3Bin ), (((struct Bin *)(& __1tailonleft ))-> head__3Bin = __1jarc )) ;
( (__1__X24 = (__4jtemp = __1jarc -> next__3Arc )), ( (__1__X24 -> link__3Arc = ((struct Bin *)(& __1headonright ))-> head__3Bin ), (((struct Bin *)(&
__1headonright ))-> head__3Bin = __1__X24 )) ) ;
( (__1__X25 = __4jtemp -> next__3Arc ), ( (__1__X25 -> link__3Arc = ((struct Bin *)__1right )-> head__3Bin ), (((struct Bin *)__1right )-> head__3Bin = __1__X25 ))
) ;
break ;
case 4 :
( (__1jarc -> link__3Arc = ((struct Bin *)__1left )-> head__3Bin ), (((struct Bin *)__1left )-> head__3Bin = __1jarc )) ;
( (__1__X26 = (__4jtemp = __1jarc -> next__3Arc )), ( (__1__X26 -> link__3Arc = ((struct Bin *)(& __1tailonleft ))-> head__3Bin ), (((struct Bin *)(&
__1tailonleft ))-> head__3Bin = __1__X26 )) ) ;
( (__1__X27 = (__4jtemp = __4jtemp -> next__3Arc )), ( (__1__X27 -> link__3Arc = ((struct Bin *)(& __1headonright ))-> head__3Bin ), (((struct Bin *)(&
__1headonright ))-> head__3Bin = __1__X27 )) ) ;
( (__1__X28 = __4jtemp -> next__3Arc ), ( (__1__X28 -> link__3Arc = ((struct Bin *)__1right )-> head__3Bin ), (((struct Bin *)__1right )-> head__3Bin = __1__X28 ))
) ;
}
}
else 
if (__2hdiff == 0.0 ){ 
( (__1jarc -> link__3Arc = ((struct Bin *)(& __1tailonleft ))-> head__3Bin ), (((struct Bin *)(& __1tailonleft ))->
head__3Bin = __1jarc )) ;
}
else 
{ 
( (__1jarc -> link__3Arc = ((struct Bin *)__1left )-> head__3Bin ), (((struct Bin *)__1left )-> head__3Bin = __1jarc )) ;
}
}
}
if (__1param == 0 ){ 
__glclassify_headonleft_s__10S0 ( __0this , (struct Bin *)(& __1headonleft ), __1intersections , __1left , __1value ) ;
__glclassify_tailonleft_s__10S0 ( __0this , (struct Bin *)(& __1tailonleft ), __1intersections , __1left , __1value ) ;
__glclassify_headonright_s__100 ( __0this , (struct Bin *)(& __1headonright ), __1intersections , __1right , __1value ) ;
__glclassify_tailonright_s__100 ( __0this , (struct Bin *)(& __1tailonright ), __1intersections , __1right , __1value ) ;
}
else 
{ 
__glclassify_headonleft_t__10S0 ( __0this , (struct Bin *)(& __1headonleft ), __1intersections , __1left , __1value ) ;
__glclassify_tailonleft_t__10S0 ( __0this , (struct Bin *)(& __1tailonleft ), __1intersections , __1left , __1value ) ;
__glclassify_headonright_t__100 ( __0this , (struct Bin *)(& __1headonright ), __1intersections , __1right , __1value ) ;
__glclassify_tailonright_t__100 ( __0this , (struct Bin *)(& __1tailonright ), __1intersections , __1right , __1value ) ;
}

}

}

__gl__dt__3BinFv ( (struct Bin *)(& __1tailonright ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __1tailonleft ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __1headonright ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __1headonleft ), 2) ;
}

static int pwlarc_intersect__FP6PwlArcifT2Pi (struct PwlArc *, int , REAL , int , int *);



struct TrimVertex *__glget__14TrimVertexPoolFi (struct TrimVertexPool *, int );



void __gltriangle__7BackendFP10Trim0 (struct Backend *, struct TrimVertex *, struct TrimVertex *, struct TrimVertex *);

















static void *__nw__9PooledObjSFUiR4Pool (size_t , struct Pool *);

int __glarc_split__10SubdividerFP30 (struct Subdivider *__0this , Arc_ptr __1jarc , int __1param , REAL __1value , int __1dir )
{ 
int __1maxvertex ;
Arc_ptr __1jarc1 ;

Arc_ptr __1jarc2 ;

Arc_ptr __1jarc3 ;
struct TrimVertex *__1v ;

int __1loc [3];

__1maxvertex = __1jarc -> pwlArc__3Arc -> npts__6PwlArc ;

__1v = __1jarc -> pwlArc__3Arc -> pts__6PwlArc ;

switch (pwlarc_intersect__FP6PwlArcifT2Pi ( __1jarc -> pwlArc__3Arc , __1param , __1value , __1dir , (int *)__1loc ) ){ 
case 0:{ 
struct Arc *__0__X29 ;

void *__1__Xbuffer00eohgaiaa ;
struct PwlArc *__0__X30 ;

struct PwlArc *__1__X31 ;

__1jarc1 = ((__0__X29 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X31 =
((__0__X30 = (struct PwlArc *)__nw__9PooledObjSFUiR4Pool ( sizeof (struct PwlArc ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) )?( (((struct PwlArc *)__0__X30 )-> pts__6PwlArc =
(& (__1v [(__1loc [1 ])]))), ( (((struct PwlArc *)__0__X30 )-> npts__6PwlArc = (__1maxvertex - (__1loc [1 ]))), ( (((struct PwlArc *)__0__X30 )-> type__6PwlArc = 0x8 ), ((((struct
PwlArc *)__0__X30 )))) ) ) :0 )), ( (((struct Arc *)__0__X29 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X29 )-> pwlArc__3Arc = __1__X31 ),
( (((struct Arc *)__0__X29 )-> type__3Arc = __1jarc -> type__3Arc ), ( (((struct Arc *)__0__X29 )-> nuid__3Arc = __1jarc -> nuid__3Arc ), ((((struct Arc *)__0__X29 ))))
) ) ) ) :0 );
__1jarc -> pwlArc__3Arc -> npts__6PwlArc = ((__1loc [1 ])+ 1 );
__1jarc1 -> next__3Arc = __1jarc -> next__3Arc ;
__1jarc1 -> next__3Arc -> prev__3Arc = __1jarc1 ;
__1jarc -> next__3Arc = __1jarc1 ;
__1jarc1 -> prev__3Arc = __1jarc ;
((void )0 );
return 2 ;
}

case 1:{ 
int __3i ;

int __3j ;
if (__1dir == 0 ){ 
__3i = (__1loc [0 ]);
__3j = (__1loc [2 ]);
}
else 
{ 
__3i = (__1loc [2 ]);
__3j = (__1loc [0 ]);
}

{ struct TrimVertex *__3newjunk ;

struct TrimVertex *__1__X32 ;

struct TrimVertex *__1__X33 ;

struct TrimVertex *__1__X34 ;

float __2__Xratio002aztaiac ;

__3newjunk = __glget__14TrimVertexPoolFi ( (struct TrimVertexPool *)(& __0this -> trimvertexpool__10Subdivider ), 3 ) ;
(__1v [__3i ]). nuid__10TrimVertex = __1jarc -> nuid__3Arc ;
(__1v [__3j ]). nuid__10TrimVertex = __1jarc -> nuid__3Arc ;
(__3newjunk [0 ])= __1v [__3j ];
(__3newjunk [2 ])= __1v [__3i ];
( (__1__X32 = (& (__3newjunk [1 ]))), ( (__1__X33 = (& (__1v [(__1loc [0 ])]))), ( (__1__X34 = (& (__1v [(__1loc [2 ])]))), ( (((void
)0 )), ( (((void )0 )), ( (__1__X32 -> nuid__10TrimVertex = __1__X33 -> nuid__10TrimVertex ), ( ((__1__X32 -> param__10TrimVertex [__1param ])= __1value ), (((__1__X33 ->
param__10TrimVertex [(1 - __1param )])!= (__1__X34 -> param__10TrimVertex [(1 - __1param )]))?( (__2__Xratio002aztaiac = ((__1value - (__1__X33 -> param__10TrimVertex [__1param ]))/ ((__1__X34 -> param__10TrimVertex [__1param ])- (__1__X33 -> param__10TrimVertex [__1param ])))), ((__1__X32 ->
param__10TrimVertex [(1 - __1param )])= ((__1__X33 -> param__10TrimVertex [(1 - __1param )])+ (__2__Xratio002aztaiac * ((__1__X34 -> param__10TrimVertex [(1 - __1param )])- (__1__X33 -> param__10TrimVertex [(1 - __1param )])))))) :((__1__X32 -> param__10TrimVertex [(1 -
__1param )])= (__1__X33 -> param__10TrimVertex [(1 - __1param )])))) ) ) ) ) ) ) ;

if (( __0this -> showDegenerate__10Subdivider ) )
__gltriangle__7BackendFP10Trim0 ( (struct Backend *)__0this -> backend__10Subdivider , & (__3newjunk [2 ]), & (__3newjunk [1 ]), & (__3newjunk [0 ]))
;

if (__1maxvertex == 2 ){ 
struct Arc *__0__X35 ;

void *__1__Xbuffer00eohgaiaa ;

struct PwlArc *__0__X36 ;

struct PwlArc *__1__X37 ;

__1jarc1 = ((__0__X35 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X37 =
((__0__X36 = (struct PwlArc *)__nw__9PooledObjSFUiR4Pool ( sizeof (struct PwlArc ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) )?( (((struct PwlArc *)__0__X36 )-> pts__6PwlArc =
(__3newjunk + 1 )), ( (((struct PwlArc *)__0__X36 )-> npts__6PwlArc = 2 ), ( (((struct PwlArc *)__0__X36 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X36 ))))
) ) :0 )), ( (((struct Arc *)__0__X35 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X35 )-> pwlArc__3Arc = __1__X37 ), (
(((struct Arc *)__0__X35 )-> type__3Arc = __1jarc -> type__3Arc ), ( (((struct Arc *)__0__X35 )-> nuid__3Arc = __1jarc -> nuid__3Arc ), ((((struct Arc *)__0__X35 )))) )
) ) ) :0 );
__1jarc -> pwlArc__3Arc -> npts__6PwlArc = 2 ;
__1jarc -> pwlArc__3Arc -> pts__6PwlArc = __3newjunk ;
__1jarc1 -> next__3Arc = __1jarc -> next__3Arc ;
__1jarc1 -> next__3Arc -> prev__3Arc = __1jarc1 ;
__1jarc -> next__3Arc = __1jarc1 ;
__1jarc1 -> prev__3Arc = __1jarc ;
((void )0 );
return 2 ;
}
else 
if ((__1maxvertex - __3j )== 2 ){ 
struct Arc *__0__X38 ;

void *__1__Xbuffer00eohgaiaa ;

struct PwlArc *__0__X39 ;

struct PwlArc *__1__X40 ;

struct Arc *__0__X41 ;

struct PwlArc *__0__X42 ;

struct PwlArc *__1__X43 ;

__1jarc1 = ((__0__X38 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X40 =
((__0__X39 = (struct PwlArc *)__nw__9PooledObjSFUiR4Pool ( sizeof (struct PwlArc ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) )?( (((struct PwlArc *)__0__X39 )-> pts__6PwlArc =
__3newjunk ), ( (((struct PwlArc *)__0__X39 )-> npts__6PwlArc = 2 ), ( (((struct PwlArc *)__0__X39 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X39 )))) )
) :0 )), ( (((struct Arc *)__0__X38 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X38 )-> pwlArc__3Arc = __1__X40 ), ( (((struct
Arc *)__0__X38 )-> type__3Arc = __1jarc -> type__3Arc ), ( (((struct Arc *)__0__X38 )-> nuid__3Arc = __1jarc -> nuid__3Arc ), ((((struct Arc *)__0__X38 )))) ) )
) ) :0 );
__1jarc2 = ((__0__X41 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X43 =
((__0__X42 = (struct PwlArc *)__nw__9PooledObjSFUiR4Pool ( sizeof (struct PwlArc ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) )?( (((struct PwlArc *)__0__X42 )-> pts__6PwlArc =
(__3newjunk + 1 )), ( (((struct PwlArc *)__0__X42 )-> npts__6PwlArc = 2 ), ( (((struct PwlArc *)__0__X42 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X42 ))))
) ) :0 )), ( (((struct Arc *)__0__X41 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X41 )-> pwlArc__3Arc = __1__X43 ), (
(((struct Arc *)__0__X41 )-> type__3Arc = __1jarc -> type__3Arc ), ( (((struct Arc *)__0__X41 )-> nuid__3Arc = __1jarc -> nuid__3Arc ), ((((struct Arc *)__0__X41 )))) )
) ) ) :0 );
__1jarc -> pwlArc__3Arc -> npts__6PwlArc = (__1maxvertex - 1 );
__1jarc2 -> next__3Arc = __1jarc -> next__3Arc ;
__1jarc2 -> next__3Arc -> prev__3Arc = __1jarc2 ;
__1jarc -> next__3Arc = __1jarc1 ;
__1jarc1 -> prev__3Arc = __1jarc ;
__1jarc1 -> next__3Arc = __1jarc2 ;
__1jarc2 -> prev__3Arc = __1jarc1 ;
((void )0 );
return 31 ;
}
else 
if (__3i == 1 ){ 
struct Arc *__0__X44 ;

void *__1__Xbuffer00eohgaiaa ;

struct PwlArc *__0__X45 ;

struct PwlArc *__1__X46 ;

struct Arc *__0__X47 ;

struct PwlArc *__0__X48 ;

struct PwlArc *__1__X49 ;

__1jarc1 = ((__0__X44 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X46 =
((__0__X45 = (struct PwlArc *)__nw__9PooledObjSFUiR4Pool ( sizeof (struct PwlArc ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) )?( (((struct PwlArc *)__0__X45 )-> pts__6PwlArc =
(__3newjunk + 1 )), ( (((struct PwlArc *)__0__X45 )-> npts__6PwlArc = 2 ), ( (((struct PwlArc *)__0__X45 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X45 ))))
) ) :0 )), ( (((struct Arc *)__0__X44 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X44 )-> pwlArc__3Arc = __1__X46 ), (
(((struct Arc *)__0__X44 )-> type__3Arc = __1jarc -> type__3Arc ), ( (((struct Arc *)__0__X44 )-> nuid__3Arc = __1jarc -> nuid__3Arc ), ((((struct Arc *)__0__X44 )))) )
) ) ) :0 );

__1jarc2 = ((__0__X47 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X49 =
((__0__X48 = (struct PwlArc *)__nw__9PooledObjSFUiR4Pool ( sizeof (struct PwlArc ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) )?( (((struct PwlArc *)__0__X48 )-> pts__6PwlArc =
(& (__1jarc -> pwlArc__3Arc -> pts__6PwlArc [1 ]))), ( (((struct PwlArc *)__0__X48 )-> npts__6PwlArc = (__1maxvertex - 1 )), ( (((struct PwlArc *)__0__X48 )-> type__6PwlArc =
0x8 ), ((((struct PwlArc *)__0__X48 )))) ) ) :0 )), ( (((struct Arc *)__0__X47 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X47 )->
pwlArc__3Arc = __1__X49 ), ( (((struct Arc *)__0__X47 )-> type__3Arc = __1jarc -> type__3Arc ), ( (((struct Arc *)__0__X47 )-> nuid__3Arc = __1jarc -> nuid__3Arc ),
((((struct Arc *)__0__X47 )))) ) ) ) ) :0 );
__1jarc -> pwlArc__3Arc -> npts__6PwlArc = 2 ;
__1jarc -> pwlArc__3Arc -> pts__6PwlArc = __3newjunk ;
__1jarc2 -> next__3Arc = __1jarc -> next__3Arc ;
__1jarc2 -> next__3Arc -> prev__3Arc = __1jarc2 ;
__1jarc -> next__3Arc = __1jarc1 ;
__1jarc1 -> prev__3Arc = __1jarc ;
__1jarc1 -> next__3Arc = __1jarc2 ;
__1jarc2 -> prev__3Arc = __1jarc1 ;
((void )0 );
return 32 ;
}
else 
{ 
struct Arc *__0__X50 ;

void *__1__Xbuffer00eohgaiaa ;

struct PwlArc *__0__X51 ;

struct PwlArc *__1__X52 ;

struct Arc *__0__X53 ;

struct PwlArc *__0__X54 ;

struct PwlArc *__1__X55 ;

struct Arc *__0__X56 ;

struct PwlArc *__0__X57 ;

struct PwlArc *__1__X58 ;

__1jarc1 = ((__0__X50 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X52 =
((__0__X51 = (struct PwlArc *)__nw__9PooledObjSFUiR4Pool ( sizeof (struct PwlArc ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) )?( (((struct PwlArc *)__0__X51 )-> pts__6PwlArc =
__3newjunk ), ( (((struct PwlArc *)__0__X51 )-> npts__6PwlArc = 2 ), ( (((struct PwlArc *)__0__X51 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X51 )))) )
) :0 )), ( (((struct Arc *)__0__X50 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X50 )-> pwlArc__3Arc = __1__X52 ), ( (((struct
Arc *)__0__X50 )-> type__3Arc = __1jarc -> type__3Arc ), ( (((struct Arc *)__0__X50 )-> nuid__3Arc = __1jarc -> nuid__3Arc ), ((((struct Arc *)__0__X50 )))) ) )
) ) :0 );
__1jarc2 = ((__0__X53 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X55 =
((__0__X54 = (struct PwlArc *)__nw__9PooledObjSFUiR4Pool ( sizeof (struct PwlArc ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) )?( (((struct PwlArc *)__0__X54 )-> pts__6PwlArc =
(__3newjunk + 1 )), ( (((struct PwlArc *)__0__X54 )-> npts__6PwlArc = 2 ), ( (((struct PwlArc *)__0__X54 )-> type__6PwlArc = 0x8 ), ((((struct PwlArc *)__0__X54 ))))
) ) :0 )), ( (((struct Arc *)__0__X53 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X53 )-> pwlArc__3Arc = __1__X55 ), (
(((struct Arc *)__0__X53 )-> type__3Arc = __1jarc -> type__3Arc ), ( (((struct Arc *)__0__X53 )-> nuid__3Arc = __1jarc -> nuid__3Arc ), ((((struct Arc *)__0__X53 )))) )
) ) ) :0 );
__1jarc3 = ((__0__X56 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (__1__X58 =
((__0__X57 = (struct PwlArc *)__nw__9PooledObjSFUiR4Pool ( sizeof (struct PwlArc ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) )?( (((struct PwlArc *)__0__X57 )-> pts__6PwlArc =
(__1v + __3i )), ( (((struct PwlArc *)__0__X57 )-> npts__6PwlArc = (__1maxvertex - __3i )), ( (((struct PwlArc *)__0__X57 )-> type__6PwlArc = 0x8 ), ((((struct
PwlArc *)__0__X57 )))) ) ) :0 )), ( (((struct Arc *)__0__X56 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X56 )-> pwlArc__3Arc = __1__X58 ),
( (((struct Arc *)__0__X56 )-> type__3Arc = __1jarc -> type__3Arc ), ( (((struct Arc *)__0__X56 )-> nuid__3Arc = __1jarc -> nuid__3Arc ), ((((struct Arc *)__0__X56 ))))
) ) ) ) :0 );
__1jarc -> pwlArc__3Arc -> npts__6PwlArc = (__3j + 1 );
__1jarc3 -> next__3Arc = __1jarc -> next__3Arc ;
__1jarc3 -> next__3Arc -> prev__3Arc = __1jarc3 ;
__1jarc -> next__3Arc = __1jarc1 ;
__1jarc1 -> prev__3Arc = __1jarc ;
__1jarc1 -> next__3Arc = __1jarc2 ;
__1jarc2 -> prev__3Arc = __1jarc1 ;
__1jarc2 -> next__3Arc = __1jarc3 ;
__1jarc3 -> prev__3Arc = __1jarc2 ;
((void )0 );
return 4 ;
}

}
}
}
}

static int pwlarc_intersect__FP6PwlArcifT2Pi (
struct PwlArc *__1pwlArc , 
int __1param , 
REAL __1value , 
int __1dir , 
int *__1loc )
{ 
((void )0 );

if (__1dir ){ 
struct TrimVertex *__2v ;
int __2imin ;
int __2imax ;

__2v = __1pwlArc -> pts__6PwlArc ;
__2imin = 0 ;
__2imax = (__1pwlArc -> npts__6PwlArc - 1 );
((void )0 );
((void )0 );
while ((__2imax - __2imin )> 1 ){ 
int __3imid ;

__3imid = ((__2imax + __2imin )/ 2 );
if (((__2v [__3imid ]). param__10TrimVertex [__1param ])> __1value )
__2imax = __3imid ;
else if (((__2v [__3imid ]). param__10TrimVertex [__1param ])< __1value )
__2imin = __3imid ;
else { 
(__1loc [1 ])= __3imid ;
return (int )0;
}
}
(__1loc [0 ])= __2imin ;
(__1loc [2 ])= __2imax ;
return (int )1;
}
else 
{ 
struct TrimVertex *__2v ;
int __2imax ;
int __2imin ;

__2v = __1pwlArc -> pts__6PwlArc ;
__2imax = 0 ;
__2imin = (__1pwlArc -> npts__6PwlArc - 1 );
((void )0 );
((void )0 );
while ((__2imin - __2imax )> 1 ){ 
int __3imid ;

__3imid = ((__2imax + __2imin )/ 2 );
if (((__2v [__3imid ]). param__10TrimVertex [__1param ])> __1value )
__2imax = __3imid ;
else if (((__2v [__3imid ]). param__10TrimVertex [__1param ])< __1value )
__2imin = __3imid ;
else { 
(__1loc [1 ])= __3imid ;
return (int )0;
}
}
(__1loc [0 ])= __2imin ;
(__1loc [2 ])= __2imax ;
return (int )1;
}
}





static int arc_classify__FP3Arcif (Arc_ptr __1jarc , int __1param , REAL __1value )
{ 
REAL __1tdiff ;

REAL __1hdiff ;
if (__1param == 0 ){ 
__1tdiff = ((( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])- __1value );
__1hdiff = ((( (((REAL *)(((struct Arc *)__1jarc )-> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])- __1value );
}
else 
{ 
__1tdiff = ((( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])- __1value );
__1hdiff = ((( (((REAL *)(((struct Arc *)__1jarc )-> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])- __1value );
}

if (__1tdiff > 0.0 ){ 
if (__1hdiff > 0.0 ){ 
return 0x11 ;
}
else 
if (__1hdiff == 0.0 ){ 
return 0x12 ;
}
else 
{ 
return 0x10 ;
}
}
else 
if (__1tdiff == 0.0 ){ 
if (__1hdiff > 0.0 ){ 
return 0x21 ;
}
else 
if (__1hdiff == 0.0 ){ 
return 0x22 ;
}
else 
{ 
return 0x20 ;
}
}
else 
{ 
if (__1hdiff > 0.0 ){ 
return 0x01 ;
}
else 
if (__1hdiff == 0.0 ){ 
return 0x02 ;
}
else 
{ 
return 0 ;
}
}
}





int __glccwTurn_sl__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);





void __glclassify_tailonleft_s__10S0 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1in , struct Bin *__1out , REAL __1val )
{ 
Arc_ptr __1j ;

struct Arc *__1__Xjarc00efckaice ;

while (__1j = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ),
0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ){ 
((void )0 );
( (((struct Arc *)__1j )-> type__3Arc &= (~ __gltail_tag__3Arc ))) ;

{ REAL __2diff ;

struct Arc *__0__X61 ;

__2diff = ((( (__0__X61 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X61 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ])-
__1val );
if (__2diff > 0.0 ){ 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;

}
else 
if (__2diff < 0.0 ){ 
if (__glccwTurn_sl__10SubdividerFP0 ( __0this , __1j , __1j -> next__3Arc ) )
( (__1j -> link__3Arc = ((struct
Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}
else 
{ 
struct Arc *__0__X59 ;

struct Arc *__0__X60 ;

if ((( (__0__X59 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X59 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])> ((
(__0__X60 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X60 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ]))
( (__1j -> link__3Arc =
((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
}

}
}
}





int __glccwTurn_tl__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);





void __glclassify_tailonleft_t__10S0 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1in , struct Bin *__1out , REAL __1val )
{ 
Arc_ptr __1j ;

struct Arc *__1__Xjarc00efckaice ;

while (__1j = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ),
0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ){ 
((void )0 );
( (((struct Arc *)__1j )-> type__3Arc &= (~ __gltail_tag__3Arc ))) ;

{ REAL __2diff ;

struct Arc *__0__X64 ;

__2diff = ((( (__0__X64 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X64 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])-
__1val );
if (__2diff > 0.0 ){ 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;

}
else 
if (__2diff < 0.0 ){ 
if (__glccwTurn_tl__10SubdividerFP0 ( __0this , __1j , __1j -> next__3Arc ) )
( (__1j -> link__3Arc = ((struct
Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}
else 
{ 
struct Arc *__0__X62 ;

struct Arc *__0__X63 ;

if ((( (__0__X62 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X62 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ])> ((
(__0__X63 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X63 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ]))
( (__1j -> link__3Arc =
((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}

}
}
}








void __glclassify_headonleft_s__10S0 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1in , struct Bin *__1out , REAL __1val )
{ 
Arc_ptr __1j ;

struct Arc *__1__Xjarc00efckaice ;

while (__1j = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ),
0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ){ 
((void )0 );

( (((struct Arc *)__1j )-> type__3Arc |= __gltail_tag__3Arc )) ;

{ REAL __2diff ;

struct Arc *__0__X67 ;

__2diff = ((( (__0__X67 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X67 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ])- __1val );

if (__2diff > 0.0 ){ 
( (__1j -> link__3Arc = ((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;

}
else 
if (__2diff < 0.0 ){ 
if (__glccwTurn_sl__10SubdividerFP0 ( __0this , __1j -> prev__3Arc , __1j ) )
( (__1j -> link__3Arc = ((struct
Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}
else 
{ 
struct Arc *__0__X65 ;

struct Arc *__0__X66 ;

if ((( (__0__X65 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X65 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])> ((
(__0__X66 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X66 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ]))
( (__1j -> link__3Arc =
((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
}

}
}
}








void __glclassify_headonleft_t__10S0 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1in , struct Bin *__1out , REAL __1val )
{ 
Arc_ptr __1j ;

struct Arc *__1__Xjarc00efckaice ;

while (__1j = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ),
0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ){ 
((void )0 );
( (((struct Arc *)__1j )-> type__3Arc |= __gltail_tag__3Arc )) ;

{ REAL __2diff ;

struct Arc *__0__X70 ;

__2diff = ((( (__0__X70 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X70 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])- __1val );

if (__2diff > 0.0 ){ 
( (__1j -> link__3Arc = ((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;

}
else 
if (__2diff < 0.0 ){ 
if (__glccwTurn_tl__10SubdividerFP0 ( __0this , __1j -> prev__3Arc , __1j ) )
( (__1j -> link__3Arc = ((struct
Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}
else 
{ 
struct Arc *__0__X68 ;

struct Arc *__0__X69 ;

if ((( (__0__X68 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X68 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ])> ((
(__0__X69 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X69 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ]))
( (__1j -> link__3Arc =
((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}

}
}
}




int __glccwTurn_sr__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);





void __glclassify_tailonright_s__100 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1in , struct Bin *__1out , REAL __1val )
{ 
Arc_ptr __1j ;

struct Arc *__1__Xjarc00efckaice ;

while (__1j = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ),
0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ){ 
((void )0 );

( (((struct Arc *)__1j )-> type__3Arc &= (~ __gltail_tag__3Arc ))) ;

{ REAL __2diff ;

struct Arc *__0__X73 ;

__2diff = ((( (__0__X73 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X73 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ])-
__1val );
if (__2diff > 0.0 ){ 
if (__glccwTurn_sr__10SubdividerFP0 ( __0this , __1j , __1j -> next__3Arc ) )
( (__1j -> link__3Arc = ((struct Bin *)__1out )->
head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}
else 
if (__2diff < 0.0 ){ 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j ))
;
}
else 
{ 
struct Arc *__0__X71 ;

struct Arc *__0__X72 ;

if ((( (__0__X71 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X71 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])> ((
(__0__X72 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X72 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ]))
( (__1j -> link__3Arc =
((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}

}
}
}




int __glccwTurn_tr__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);





void __glclassify_tailonright_t__100 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1in , struct Bin *__1out , REAL __1val )
{ 
Arc_ptr __1j ;

struct Arc *__1__Xjarc00efckaice ;

while (__1j = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ),
0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ){ 
((void )0 );

( (((struct Arc *)__1j )-> type__3Arc &= (~ __gltail_tag__3Arc ))) ;

{ REAL __2diff ;

struct Arc *__0__X76 ;

__2diff = ((( (__0__X76 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X76 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])-
__1val );
if (__2diff > 0.0 ){ 
if (__glccwTurn_tr__10SubdividerFP0 ( __0this , __1j , __1j -> next__3Arc ) )
( (__1j -> link__3Arc = ((struct Bin *)__1out )->
head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}
else 
if (__2diff < 0.0 ){ 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j ))
;
}
else 
{ 
struct Arc *__0__X74 ;

struct Arc *__0__X75 ;

if ((( (__0__X74 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X74 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ])> ((
(__0__X75 = (struct Arc *)__1j -> next__3Arc ), ( (((REAL *)(__0__X75 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ]))
( (__1j -> link__3Arc =
((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
}

}
}
}








void __glclassify_headonright_s__100 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1in , struct Bin *__1out , REAL __1val )
{ 
Arc_ptr __1j ;

struct Arc *__1__Xjarc00efckaice ;

while (__1j = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ),
0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ){ 
((void )0 );

( (((struct Arc *)__1j )-> type__3Arc |= __gltail_tag__3Arc )) ;

{ REAL __2diff ;

struct Arc *__0__X79 ;

__2diff = ((( (__0__X79 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X79 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ])- __1val );

if (__2diff > 0.0 ){ 
if (__glccwTurn_sr__10SubdividerFP0 ( __0this , __1j -> prev__3Arc , __1j ) )
( (__1j -> link__3Arc = ((struct Bin *)__1out )->
head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}
else 
if (__2diff < 0.0 ){ 
( (__1j -> link__3Arc = ((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j ))
;
}
else 
{ 
struct Arc *__0__X77 ;

struct Arc *__0__X78 ;

if ((( (__0__X77 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X77 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])> ((
(__0__X78 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X78 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ]))
( (__1j -> link__3Arc =
((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}

}
}
}








void __glclassify_headonright_t__100 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1in , struct Bin *__1out , REAL __1val )
{ 
Arc_ptr __1j ;

struct Arc *__1__Xjarc00efckaice ;

while (__1j = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ),
0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ){ 
((void )0 );

( (((struct Arc *)__1j )-> type__3Arc |= __gltail_tag__3Arc )) ;

{ REAL __2diff ;

struct Arc *__0__X82 ;

__2diff = ((( (__0__X82 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X82 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])- __1val );

if (__2diff > 0.0 ){ 
if (__glccwTurn_tr__10SubdividerFP0 ( __0this , __1j -> prev__3Arc , __1j ) )
( (__1j -> link__3Arc = ((struct Bin *)__1out )->
head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
}
else 
if (__2diff < 0.0 ){ 
( (__1j -> link__3Arc = ((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j ))
;
}
else 
{ 
struct Arc *__0__X80 ;

struct Arc *__0__X81 ;

if ((( (__0__X80 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X80 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ])> ((
(__0__X81 = (struct Arc *)__1j -> prev__3Arc ), ( (((REAL *)(__0__X81 -> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [0 ]))
( (__1j -> link__3Arc =
((struct Bin *)__1in )-> head__3Bin ), (((struct Bin *)__1in )-> head__3Bin = __1j )) ;
else 
( (__1j -> link__3Arc = ((struct Bin *)__1out )-> head__3Bin ), (((struct Bin *)__1out )-> head__3Bin = __1j )) ;
}

}
}
}

static void *__nw__9PooledObjSFUiR4Pool (
size_t __1__A4 , 
struct Pool *__1pool )
{ 
void *__1__Xbuffer00eohgaiaa ;

return ( (((void )0 )), ( (((struct Pool *)__1pool )-> freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)__1pool )-> freelist__4Pool ))),
(((struct Pool *)__1pool )-> freelist__4Pool = ((struct Pool *)__1pool )-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)__1pool )->
nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)__1pool )) , 0 ) :( 0 ) ), ( (((struct Pool *)__1pool )-> nextfree__4Pool -= ((struct
Pool *)__1pool )-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)__1pool )-> curblock__4Pool + ((struct Pool *)__1pool )-> nextfree__4Pool ))))) ) ) ,
0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ;
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\mapdesc.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/mapdesc.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);

















typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;



struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};






struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};












typedef REAL Maxmatrix [5][5];



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};

void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);








void __glidentify__7MapdescFPA5_f (struct Mapdesc *, REAL (*)[5]);
extern struct __mptr* __ptbl_vec_____core_mapdesc_c_____ct_[];


struct Mapdesc *__gl__ct__7MapdescFliT2R7Backe0 (struct Mapdesc *__0this , long __1_type , int __1_israt , int __1_ncoords , struct Backend *__1b )
{ __0this -> backend__7Mapdesc = __1b ;

__0this -> type__7Mapdesc = __1_type ;
__0this -> isrational__7Mapdesc = __1_israt ;
__0this -> ncoords__7Mapdesc = __1_ncoords ;
__0this -> hcoords__7Mapdesc = (__1_ncoords + (__1_israt ?0 :1 ));
__0this -> inhcoords__7Mapdesc = (__1_ncoords - (__1_israt ?1 :0 ));
__0this -> mask__7Mapdesc = ((1 << (__0this -> inhcoords__7Mapdesc * 2 ))- 1 );
__0this -> next__7Mapdesc = 0 ;

((void )0 );
((void )0 );

__0this -> pixel_tolerance__7Mapdesc = 1.0 ;
__0this -> bbox_subdividing__7Mapdesc = 0.0 ;
__0this -> culling_method__7Mapdesc = 0.0 ;
__0this -> sampling_method__7Mapdesc = 0.0 ;
__0this -> clampfactor__7Mapdesc = 0.0 ;
__0this -> minsavings__7Mapdesc = 0.0 ;
__0this -> s_steps__7Mapdesc = 0.0 ;
__0this -> t_steps__7Mapdesc = 0.0 ;
__0this -> maxrate__7Mapdesc = ((__0this -> s_steps__7Mapdesc < 0.0 )?0.0 :(((double )__0this -> s_steps__7Mapdesc )));
__0this -> maxsrate__7Mapdesc = ((__0this -> s_steps__7Mapdesc < 0.0 )?0.0 :(((double )__0this -> s_steps__7Mapdesc )));
__0this -> maxtrate__7Mapdesc = ((__0this -> t_steps__7Mapdesc < 0.0 )?0.0 :(((double )__0this -> t_steps__7Mapdesc )));
__glidentify__7MapdescFPA5_f ( __0this , (float (*)[5])__0this -> bmat__7Mapdesc ) ;
__glidentify__7MapdescFPA5_f ( __0this , (float (*)[5])__0this -> cmat__7Mapdesc ) ;
__glidentify__7MapdescFPA5_f ( __0this , (float (*)[5])__0this -> smat__7Mapdesc ) ;
{ { int __1i ;

__1i = 0 ;

for(;__1i != __0this -> inhcoords__7Mapdesc ;__1i ++ ) 
(__0this -> bboxsize__7Mapdesc [__1i ])= 1.0 ;

}

}
return __0this ;

}

void __glsetBboxsize__7MapdescFPf (struct Mapdesc *__0this , float *__1mat )
{ 
{ { int __1i ;

__1i = 0 ;

for(;__1i != __0this -> inhcoords__7Mapdesc ;__1i ++ ) 
(__0this -> bboxsize__7Mapdesc [__1i ])= (((float )(__1mat [__1i ])));

}

}
}

// extern void *memset (void *, int , size_t );

void __glidentify__7MapdescFPA5_f (struct Mapdesc *__0this , REAL (*__1dest )[5])
{ 
memset ( (void *)__1dest , 0 , sizeof __1dest ) ;
{ { int __1i ;

__1i = 0 ;

for(;__1i != __0this -> hcoords__7Mapdesc ;__1i ++ ) 
((__1dest [__1i ])[__1i ])= 1.0 ;

}

}
}

void __glsurfbbox__7BackendFlPfT2 (struct Backend *, long , REAL *, REAL *);

void __glsurfbbox__7MapdescFPA5_f (struct Mapdesc *__0this , REAL (*__1bb )[5])
{ 
__glsurfbbox__7BackendFlPfT2 ( (struct Backend *)__0this -> backend__7Mapdesc , __0this -> type__7Mapdesc , (float *)(__1bb [0 ]), (float *)(__1bb [1 ]))
;
}

void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*__1dest )[5], long __1n , float *__1src , 
long __1rstride , long __1cstride )
{ 
((void )0 );
{ { int __1i ;

__1i = 0 ;

for(;__1i != __1n ;__1i ++ ) 
{ { int __1j ;

__1j = 0 ;

for(;__1j != __1n ;__1j ++ ) 
((__1dest [__1i ])[__1j ])= (__1src [((__1i * __1rstride )+ (__1j * __1cstride ))]);

}

}

}

}
}

// extern void *memcpy (void *, void *, size_t );

void __glcopyPt__7MapdescFPfT1 (struct Mapdesc *__0this , REAL *__1d , REAL *__1s )
{ 
((void )0 );
switch (__0this -> hcoords__7Mapdesc ){ 
case 4 :
(__1d [3 ])= (__1s [3 ]);
(__1d [2 ])= (__1s [2 ]);
(__1d [1 ])= (__1s [1 ]);
(__1d [0 ])= (__1s [0 ]);
break ;
case 3 :
(__1d [2 ])= (__1s [2 ]);
(__1d [1 ])= (__1s [1 ]);
(__1d [0 ])= (__1s [0 ]);
break ;
case 2 :
(__1d [1 ])= (__1s [1 ]);
(__1d [0 ])= (__1s [0 ]);
break ;
case 1 :
(__1d [0 ])= (__1s [0 ]);
break ;
case 5 :
(__1d [4 ])= (__1s [4 ]);
(__1d [3 ])= (__1s [3 ]);
(__1d [2 ])= (__1s [2 ]);
(__1d [1 ])= (__1s [1 ]);
(__1d [0 ])= (__1s [0 ]);
break ;
default :
memcpy ( (void *)__1d , (void *)__1s , __0this -> hcoords__7Mapdesc * (sizeof (REAL ))) ;
break ;
}
}

void __glsumPt__7MapdescFPfN21fT4 (struct Mapdesc *__0this , REAL *__1dst , REAL *__1src1 , REAL *__1src2 , register REAL __1alpha , register REAL __1beta )
{ 
((void )0 );
switch (__0this -> hcoords__7Mapdesc ){ 
case 4 :
(__1dst [3 ])= (((__1src1 [3 ])* __1alpha )+ ((__1src2 [3 ])* __1beta ));
(__1dst [2 ])= (((__1src1 [2 ])* __1alpha )+ ((__1src2 [2 ])* __1beta ));
(__1dst [1 ])= (((__1src1 [1 ])* __1alpha )+ ((__1src2 [1 ])* __1beta ));
(__1dst [0 ])= (((__1src1 [0 ])* __1alpha )+ ((__1src2 [0 ])* __1beta ));
break ;
case 3 :
(__1dst [2 ])= (((__1src1 [2 ])* __1alpha )+ ((__1src2 [2 ])* __1beta ));
(__1dst [1 ])= (((__1src1 [1 ])* __1alpha )+ ((__1src2 [1 ])* __1beta ));
(__1dst [0 ])= (((__1src1 [0 ])* __1alpha )+ ((__1src2 [0 ])* __1beta ));
break ;
case 2 :
(__1dst [1 ])= (((__1src1 [1 ])* __1alpha )+ ((__1src2 [1 ])* __1beta ));
(__1dst [0 ])= (((__1src1 [0 ])* __1alpha )+ ((__1src2 [0 ])* __1beta ));
break ;
case 1 :
(__1dst [0 ])= (((__1src1 [0 ])* __1alpha )+ ((__1src2 [0 ])* __1beta ));
break ;
case 5 :
(__1dst [4 ])= (((__1src1 [4 ])* __1alpha )+ ((__1src2 [4 ])* __1beta ));
(__1dst [3 ])= (((__1src1 [3 ])* __1alpha )+ ((__1src2 [3 ])* __1beta ));
(__1dst [2 ])= (((__1src1 [2 ])* __1alpha )+ ((__1src2 [2 ])* __1beta ));
(__1dst [1 ])= (((__1src1 [1 ])* __1alpha )+ ((__1src2 [1 ])* __1beta ));
(__1dst [0 ])= (((__1src1 [0 ])* __1alpha )+ ((__1src2 [0 ])* __1beta ));
break ;
default :{ 
{ { int __3i ;

__3i = 0 ;

for(;__3i != __0this -> hcoords__7Mapdesc ;__3i ++ ) 
(__1dst [__3i ])= (((__1src1 [__3i ])* __1alpha )+ ((__1src2 [__3i ])* __1beta ));

}

}
}
break ;
}
}

// extern void abort (void );

unsigned int __glclipbits__7MapdescFPf (struct Mapdesc *__0this , REAL *__1p )
{ 
((void )0 );
((void )0 );

{ register int __1nc ;
register REAL __1pw ;
register REAL __1nw ;
register unsigned int __1bits ;

__1nc = __0this -> inhcoords__7Mapdesc ;
__1pw = (__1p [__1nc ]);
__1nw = (- __1pw );
__1bits = 0 ;

if (__1pw == 0.0 )return (unsigned int )__0this -> mask__7Mapdesc ;

if (__1pw > 0.0 ){ 
switch (__1nc ){ 
case 3 :
if ((__1p [2 ])<= __1pw )__1bits |= 32;
if ((__1p [2 ])>= __1nw )__1bits |= 16;
if ((__1p [1 ])<= __1pw )__1bits |= 8;
if ((__1p [1 ])>= __1nw )__1bits |= 4;
if ((__1p [0 ])<= __1pw )__1bits |= 2;
if ((__1p [0 ])>= __1nw )__1bits |= 1;
return __1bits ;
case 2 :
if ((__1p [1 ])<= __1pw )__1bits |= 8;
if ((__1p [1 ])>= __1nw )__1bits |= 4;
if ((__1p [0 ])<= __1pw )__1bits |= 2;
if ((__1p [0 ])>= __1nw )__1bits |= 1;
return __1bits ;
case 1 :
if ((__1p [0 ])<= __1pw )__1bits |= 2;
if ((__1p [0 ])>= __1nw )__1bits |= 1;
return __1bits ;
default :{ 
int __4bit ;

__4bit = 1 ;
{ { int __4i ;

__4i = 0 ;

for(;__4i < __1nc ;__4i ++ ) { 
if ((__1p [__4i ])>= __1nw )__1bits |= __4bit ;
__4bit <<= 1 ;
if ((__1p [__4i ])<= __1pw )__1bits |= __4bit ;
__4bit <<= 1 ;
}
abort ( ) ;
break ;

}

}
}
}
}
else 
{ 
switch (__1nc ){ 
case 3 :
if ((__1p [2 ])<= __1nw )__1bits |= 32;
if ((__1p [2 ])>= __1pw )__1bits |= 16;
if ((__1p [1 ])<= __1nw )__1bits |= 8;
if ((__1p [1 ])>= __1pw )__1bits |= 4;
if ((__1p [0 ])<= __1nw )__1bits |= 2;
if ((__1p [0 ])>= __1pw )__1bits |= 1;
return __1bits ;
case 2 :
if ((__1p [1 ])<= __1nw )__1bits |= 8;
if ((__1p [1 ])>= __1pw )__1bits |= 4;
if ((__1p [0 ])<= __1nw )__1bits |= 2;
if ((__1p [0 ])>= __1pw )__1bits |= 1;
return __1bits ;
case 1 :
if ((__1p [0 ])<= __1nw )__1bits |= 2;
if ((__1p [0 ])>= __1pw )__1bits |= 1;
return __1bits ;
default :{ 
int __4bit ;

__4bit = 1 ;
{ { int __4i ;

__4i = 0 ;

for(;__4i < __1nc ;__4i ++ ) { 
if ((__1p [__4i ])>= __1pw )__1bits |= __4bit ;
__4bit <<= 1 ;
if ((__1p [__4i ])<= __1nw )__1bits |= __4bit ;
__4bit <<= 1 ;
}
abort ( ) ;
break ;

}

}
}
}
}
return __1bits ;

}
}

void __glxformRational__7MapdescFPA0 (struct Mapdesc *__0this , REAL (*__1mat )[5], REAL *__1d , REAL *__1s )
{ 
((void )0 );

if (__0this -> hcoords__7Mapdesc == 3 ){ 
REAL __2x ;
REAL __2y ;
REAL __2z ;

__2x = (__1s [0 ]);
__2y = (__1s [1 ]);
__2z = (__1s [2 ]);
(__1d [0 ])= (((__2x * ((__1mat [0 ])[0 ]))+ (__2y * ((__1mat [1 ])[0 ])))+ (__2z * ((__1mat [2 ])[0 ])));
(__1d [1 ])= (((__2x * ((__1mat [0 ])[1 ]))+ (__2y * ((__1mat [1 ])[1 ])))+ (__2z * ((__1mat [2 ])[1 ])));
(__1d [2 ])= (((__2x * ((__1mat [0 ])[2 ]))+ (__2y * ((__1mat [1 ])[2 ])))+ (__2z * ((__1mat [2 ])[2 ])));
}
else 
if (__0this -> hcoords__7Mapdesc == 4 ){ 
REAL __2x ;
REAL __2y ;
REAL __2z ;
REAL __2w ;

__2x = (__1s [0 ]);
__2y = (__1s [1 ]);
__2z = (__1s [2 ]);
__2w = (__1s [3 ]);
(__1d [0 ])= ((((__2x * ((__1mat [0 ])[0 ]))+ (__2y * ((__1mat [1 ])[0 ])))+ (__2z * ((__1mat [2 ])[0 ])))+ (__2w * ((__1mat [3 ])[0 ])));
(__1d [1 ])= ((((__2x * ((__1mat [0 ])[1 ]))+ (__2y * ((__1mat [1 ])[1 ])))+ (__2z * ((__1mat [2 ])[1 ])))+ (__2w * ((__1mat [3 ])[1 ])));
(__1d [2 ])= ((((__2x * ((__1mat [0 ])[2 ]))+ (__2y * ((__1mat [1 ])[2 ])))+ (__2z * ((__1mat [2 ])[2 ])))+ (__2w * ((__1mat [3 ])[2 ])));
(__1d [3 ])= ((((__2x * ((__1mat [0 ])[3 ]))+ (__2y * ((__1mat [1 ])[3 ])))+ (__2z * ((__1mat [2 ])[3 ])))+ (__2w * ((__1mat [3 ])[3 ])));
}
else 
{ 
{ { int __2i ;

__2i = 0 ;

for(;__2i != __0this -> hcoords__7Mapdesc ;__2i ++ ) { 
(__1d [__2i ])= 0 ;
{ { int __3j ;

__3j = 0 ;

for(;__3j != __0this -> hcoords__7Mapdesc ;__3j ++ ) 
(__1d [__2i ])+= ((__1s [__3j ])* ((__1mat [__3j ])[__2i ]));

}

}
}

}

}
}
}

void __glxformNonrational__7Mapdesc0 (struct Mapdesc *__0this , REAL (*__1mat )[5], REAL *__1d , REAL *__1s )
{ 
if (__0this -> inhcoords__7Mapdesc == 2 ){ 
REAL __2x ;
REAL __2y ;

__2x = (__1s [0 ]);
__2y = (__1s [1 ]);
(__1d [0 ])= (((__2x * ((__1mat [0 ])[0 ]))+ (__2y * ((__1mat [1 ])[0 ])))+ ((__1mat [2 ])[0 ]));
(__1d [1 ])= (((__2x * ((__1mat [0 ])[1 ]))+ (__2y * ((__1mat [1 ])[1 ])))+ ((__1mat [2 ])[1 ]));
(__1d [2 ])= (((__2x * ((__1mat [0 ])[2 ]))+ (__2y * ((__1mat [1 ])[2 ])))+ ((__1mat [2 ])[2 ]));
}
else 
if (__0this -> inhcoords__7Mapdesc == 3 ){ 
REAL __2x ;
REAL __2y ;
REAL __2z ;

__2x = (__1s [0 ]);
__2y = (__1s [1 ]);
__2z = (__1s [2 ]);
(__1d [0 ])= ((((__2x * ((__1mat [0 ])[0 ]))+ (__2y * ((__1mat [1 ])[0 ])))+ (__2z * ((__1mat [2 ])[0 ])))+ ((__1mat [3 ])[0 ]));
(__1d [1 ])= ((((__2x * ((__1mat [0 ])[1 ]))+ (__2y * ((__1mat [1 ])[1 ])))+ (__2z * ((__1mat [2 ])[1 ])))+ ((__1mat [3 ])[1 ]));
(__1d [2 ])= ((((__2x * ((__1mat [0 ])[2 ]))+ (__2y * ((__1mat [1 ])[2 ])))+ (__2z * ((__1mat [2 ])[2 ])))+ ((__1mat [3 ])[2 ]));
(__1d [3 ])= ((((__2x * ((__1mat [0 ])[3 ]))+ (__2y * ((__1mat [1 ])[3 ])))+ (__2z * ((__1mat [2 ])[3 ])))+ ((__1mat [3 ])[3 ]));
}
else 
{ 
((void )0 );
{ { int __2i ;

__2i = 0 ;

for(;__2i != __0this -> hcoords__7Mapdesc ;__2i ++ ) { 
(__1d [__2i ])= ((__1mat [__0this -> inhcoords__7Mapdesc ])[__2i ]);
{ { int __3j ;

__3j = 0 ;

for(;__3j < __0this -> inhcoords__7Mapdesc ;__3j ++ ) 
(__1d [__2i ])+= ((__1s [__3j ])* ((__1mat [__3j ])[__2i ]));

}

}
}

}

}
}
}


int __glxformAndCullCheck__7Mapdes0 (struct Mapdesc *__0this , 
REAL *__1pts , int __1uorder , int __1ustride , int __1vorder , int __1vstride )
{ 
((void )0 );

((void )0 );

{ unsigned int __1inbits ;
unsigned int __1outbits ;

REAL *__1p ;

__1inbits = __0this -> mask__7Mapdesc ;
__1outbits = 0 ;

__1p = __1pts ;
{ { REAL *__1pend ;

__1pend = (__1p + (__1uorder * __1ustride ));

for(;__1p != __1pend ;__1p += __1ustride ) { 
REAL *__2q ;

__2q = __1p ;
{ { REAL *__2qend ;

__2qend = (__2q + (__1vorder * __1vstride ));

for(;__2q != __2qend ;__2q += __1vstride ) { 
REAL __3cpts [5];

REAL *__1__X5 ;

REAL *__1__X6 ;

( (__1__X5 = __3cpts ), ( (__1__X6 = __2q ), ( (__0this -> isrational__7Mapdesc ?__glxformRational__7MapdescFPA0 ( __0this , (float (*)[5])__0this -> cmat__7Mapdesc , __1__X5 ,
__1__X6 ) :__glxformNonrational__7Mapdesc0 ( __0this , (float (*)[5])__0this -> cmat__7Mapdesc , __1__X5 , __1__X6 ) )) ) ) ;
{ unsigned int __3bits ;

__3bits = __glclipbits__7MapdescFPf ( __0this , (float *)__3cpts ) ;
__1outbits |= __3bits ;
__1inbits &= __3bits ;
if ((__1outbits == __0this -> mask__7Mapdesc )&& (__1inbits != __0this -> mask__7Mapdesc ))return 2 ;

}
}

}

}
}

if (__1outbits != __0this -> mask__7Mapdesc ){ 
return 0 ;
}
else 
if (__1inbits == __0this -> mask__7Mapdesc ){ 
return 1 ;
}
else 
{ 
return 2 ;
}

}

}

}
}

int __glcullCheck__7MapdescFPfiN32 (struct Mapdesc *__0this , REAL *__1pts , int __1uorder , int __1ustride , int __1vorder , int __1vstride )
{ 
unsigned int
__1inbits ;
unsigned int __1outbits ;

REAL *__1p ;

__1inbits = __0this -> mask__7Mapdesc ;
__1outbits = 0 ;

__1p = __1pts ;
{ { REAL *__1pend ;

__1pend = (__1p + (__1uorder * __1ustride ));

for(;__1p != __1pend ;__1p += __1ustride ) { 
REAL *__2q ;

__2q = __1p ;
{ { REAL *__2qend ;

__2qend = (__2q + (__1vorder * __1vstride ));

for(;__2q != __2qend ;__2q += __1vstride ) { 
unsigned int __3bits ;

__3bits = __glclipbits__7MapdescFPf ( __0this , __2q ) ;
__1outbits |= __3bits ;
__1inbits &= __3bits ;
if ((__1outbits == __0this -> mask__7Mapdesc )&& (__1inbits != __0this -> mask__7Mapdesc ))return 2 ;
}

}

}
}

if (__1outbits != __0this -> mask__7Mapdesc ){ 
return 0 ;
}
else 
if (__1inbits == __0this -> mask__7Mapdesc ){ 
return 1 ;
}
else 
{ 
return 2 ;
}

}

}
}

int __glcullCheck__7MapdescFPfiT2 (struct Mapdesc *__0this , REAL *__1pts , int __1order , int __1stride )
{ 
unsigned int __1inbits ;
unsigned int __1outbits ;

REAL *__1p ;

__1inbits = __0this -> mask__7Mapdesc ;
__1outbits = 0 ;

__1p = __1pts ;
{ { REAL *__1pend ;

__1pend = (__1p + (__1order * __1stride ));

for(;__1p != __1pend ;__1p += __1stride ) { 
unsigned int __2bits ;

__2bits = __glclipbits__7MapdescFPf ( __0this , __1p ) ;
__1outbits |= __2bits ;
__1inbits &= __2bits ;
if ((__1outbits == __0this -> mask__7Mapdesc )&& (__1inbits != __0this -> mask__7Mapdesc ))return 2 ;
}

if (__1outbits != __0this -> mask__7Mapdesc ){ 
return 0 ;
}
else 
if (__1inbits == __0this -> mask__7Mapdesc ){ 
return 1 ;
}
else 
{ 
return 2 ;
}

}

}
}

void __glxformMat__7MapdescFPA5_fPf0 (struct Mapdesc *, REAL (*)[5], REAL *, int , int , REAL *, int );

void __glxformSampling__7MapdescFPf0 (struct Mapdesc *__0this , REAL *__1pts , int __1order , int __1stride , REAL *__1sp , int __1outstride )
{ 
__glxformMat__7MapdescFPA5_fPf0 ( __0this , (float
(*)[5])__0this -> smat__7Mapdesc , __1pts , __1order , __1stride , __1sp , __1outstride ) ;
}

void __glxformBounding__7MapdescFPf0 (struct Mapdesc *__0this , REAL *__1pts , int __1order , int __1stride , REAL *__1sp , int __1outstride )
{ 
__glxformMat__7MapdescFPA5_fPf0 ( __0this , (float
(*)[5])__0this -> bmat__7Mapdesc , __1pts , __1order , __1stride , __1sp , __1outstride ) ;
}

void __glxformCulling__7MapdescFPfi0 (struct Mapdesc *__0this , REAL *__1pts , int __1order , int __1stride , REAL *__1cp , int __1outstride )
{ 
__glxformMat__7MapdescFPA5_fPf0 ( __0this , (float
(*)[5])__0this -> cmat__7Mapdesc , __1pts , __1order , __1stride , __1cp , __1outstride ) ;
}

void __glxformMat__7MapdescFPA5_fPf1 (struct Mapdesc *, REAL (*)[5], REAL *, int , int , int , int , REAL *,
int , int );

void __glxformCulling__7MapdescFPfi1 (struct Mapdesc *__0this , REAL *__1pts , 
int __1uorder , int __1ustride , 
int __1vorder , int __1vstride , 
REAL *__1cp , int
__1outustride , int __1outvstride )
{ 
__glxformMat__7MapdescFPA5_fPf1 ( __0this , (float (*)[5])__0this -> cmat__7Mapdesc , __1pts , __1uorder , __1ustride , __1vorder , __1vstride , __1cp ,
__1outustride , __1outvstride ) ;
}

void __glxformSampling__7MapdescFPf1 (struct Mapdesc *__0this , REAL *__1pts , 
int __1uorder , int __1ustride , 
int __1vorder , int __1vstride , 
REAL *__1sp , int
__1outustride , int __1outvstride )
{ 
__glxformMat__7MapdescFPA5_fPf1 ( __0this , (float (*)[5])__0this -> smat__7Mapdesc , __1pts , __1uorder , __1ustride , __1vorder , __1vstride , __1sp ,
__1outustride , __1outvstride ) ;
}

void __glxformBounding__7MapdescFPf1 (struct Mapdesc *__0this , REAL *__1pts , 
int __1uorder , int __1ustride , 
int __1vorder , int __1vstride , 
REAL *__1sp , int
__1outustride , int __1outvstride )
{ 
__glxformMat__7MapdescFPA5_fPf1 ( __0this , (float (*)[5])__0this -> bmat__7Mapdesc , __1pts , __1uorder , __1ustride , __1vorder , __1vstride , __1sp ,
__1outustride , __1outvstride ) ;
}

void __glxformMat__7MapdescFPA5_fPf0 (struct Mapdesc *__0this , 
REAL (*__1mat )[5], 
REAL *__1pts , 
int __1order , 
int __1stride , 
REAL *__1cp , 
int __1outstride )
{ 
if (__0this ->
isrational__7Mapdesc ){ 
REAL *__2pend ;

__2pend = (__1pts + (__1order * __1stride ));
{ { REAL *__2p ;

__2p = __1pts ;

for(;__2p != __2pend ;__2p += __1stride ) { 
__glxformRational__7MapdescFPA0 ( __0this , __1mat , __1cp , __2p ) ;
__1cp += __1outstride ;
}

}

}
}
else 
{ 
REAL *__2pend ;

__2pend = (__1pts + (__1order * __1stride ));
{ { REAL *__2p ;

__2p = __1pts ;

for(;__2p != __2pend ;__2p += __1stride ) { 
__glxformNonrational__7Mapdesc0 ( __0this , __1mat , __1cp , __2p ) ;
__1cp += __1outstride ;
}

}

}
}
}

void __glxformMat__7MapdescFPA5_fPf1 (struct Mapdesc *__0this , REAL (*__1mat )[5], REAL *__1pts , 
int __1uorder , int __1ustride , 
int __1vorder , int __1vstride , 
REAL *__1cp ,
int __1outustride , int __1outvstride )
{ 
if (__0this -> isrational__7Mapdesc ){ 
REAL *__2pend ;

__2pend = (__1pts + (__1uorder * __1ustride ));
{ { REAL *__2p ;

__2p = __1pts ;

for(;__2p != __2pend ;__2p += __1ustride ) { 
REAL *__3cpts2 ;
REAL *__3qend ;

__3cpts2 = __1cp ;
__3qend = (__2p + (__1vorder * __1vstride ));
{ { REAL *__3q ;

__3q = __2p ;

for(;__3q != __3qend ;__3q += __1vstride ) { 
__glxformRational__7MapdescFPA0 ( __0this , __1mat , __3cpts2 , __3q ) ;
__3cpts2 += __1outvstride ;
}
__1cp += __1outustride ;

}

}
}

}

}
}
else 
{ 
REAL *__2pend ;

__2pend = (__1pts + (__1uorder * __1ustride ));
{ { REAL *__2p ;

__2p = __1pts ;

for(;__2p != __2pend ;__2p += __1ustride ) { 
REAL *__3cpts2 ;
REAL *__3qend ;

__3cpts2 = __1cp ;
__3qend = (__2p + (__1vorder * __1vstride ));
{ { REAL *__3q ;

__3q = __2p ;

for(;__3q != __3qend ;__3q += __1vstride ) { 
__glxformNonrational__7Mapdesc0 ( __0this , __1mat , __3cpts2 , __3q ) ;
__3cpts2 += __1outvstride ;
}
__1cp += __1outustride ;

}

}
}

}

}
}
}

void __glsubdivide__7MapdescFPfT1fi0 (struct Mapdesc *__0this , REAL *__1src , REAL *__1dst , REAL __1v , int __1stride , int __1order )
{ 
REAL __1mv ;

__1mv = (1.0 - __1v );

{ { REAL *__1send ;

__1send = (__1src + (__1stride * __1order ));

for(;__1src != __1send ;( (__1send -= __1stride ), (__1dst += __1stride )) ) { 
__glcopyPt__7MapdescFPfT1 ( __0this , __1dst , __1src ) ;
{ REAL *__2qpnt ;

__2qpnt = (__1src + __1stride );
{ { REAL *__2qp ;

__2qp = __1src ;

for(;__2qpnt != __1send ;( (__2qp = __2qpnt ), (__2qpnt += __1stride )) ) 
__glsumPt__7MapdescFPfN21fT4 ( __0this , __2qp , __2qp , __2qpnt , __1mv , __1v )
;

}

}

}
}

}

}
}

void __glsubdivide__7MapdescFPfT1fi1 (struct Mapdesc *__0this , REAL *__1src , REAL *__1dst , REAL __1v , 
int __1so , int __1ss , int __1to , int __1ts )
{

REAL __1mv ;

__1mv = (1.0 - __1v );

{ { REAL *__1slast ;

__1slast = (__1src + (__1ss * __1so ));

for(;__1src != __1slast ;( (__1src += __1ss ), (__1dst += __1ss )) ) { 
REAL *__2sp ;
REAL *__2dp ;

__2sp = __1src ;
__2dp = __1dst ;
{ { REAL *__2send ;

__2send = (__1src + (__1ts * __1to ));

for(;__2sp != __2send ;( (__2send -= __1ts ), (__2dp += __1ts )) ) { 
__glcopyPt__7MapdescFPfT1 ( __0this , __2dp , __2sp ) ;
{ REAL *__3qp ;

__3qp = __2sp ;
{ { REAL *__3qpnt ;

__3qpnt = (__2sp + __1ts );

for(;__3qpnt != __2send ;( (__3qp = __3qpnt ), (__3qpnt += __1ts )) ) 
__glsumPt__7MapdescFPfN21fT4 ( __0this , __3qp , __3qp , __3qpnt , __1mv , __1v )
;

}

}

}
}

}

}
}

}

}
}

int __glproject__7MapdescFPfiT2T1N0 (struct Mapdesc *__0this , REAL *__1src , int __1rstride , int __1cstride , 
REAL *__1dest , int __1trstride , int __1tcstride , 
int
__1nrows , int __1ncols )
{ 
int __1s ;
REAL *__1rlast ;
REAL *__1trptr ;

__1s = (((__1src [__0this -> inhcoords__7Mapdesc ])> 0 )?1 :(((__1src [__0this -> inhcoords__7Mapdesc ])< 0.0 )?-1:0 ));
__1rlast = (__1src + (__1nrows * __1rstride ));
__1trptr = __1dest ;
{ { REAL *__1rptr ;

__1rptr = __1src ;

for(;__1rptr != __1rlast ;( (__1rptr += __1rstride ), (__1trptr += __1trstride )) ) { 
REAL *__2clast ;
REAL *__2tcptr ;

__2clast = (__1rptr + (__1ncols * __1cstride ));
__2tcptr = __1trptr ;
{ { REAL *__2cptr ;

__2cptr = __1rptr ;

for(;__2cptr != __2clast ;( (__2cptr += __1cstride ), (__2tcptr += __1tcstride )) ) { 
REAL *__3coordlast ;

__3coordlast = (__2cptr + __0this -> inhcoords__7Mapdesc );
if (((((*__3coordlast ))> 0 )?1 :((((*__3coordlast ))< 0.0 )?-1:0 ))!= __1s )return 0 ;
{ REAL *__3tcoord ;

__3tcoord = __2tcptr ;
{ { REAL *__3coord ;

__3coord = __2cptr ;

for(;__3coord != __3coordlast ;( (__3coord ++ ), (__3tcoord ++ )) ) { 
((*__3tcoord ))= (((*__3coord ))/ ((*__3coordlast )));
}

}

}

}
}

}

}
}
return 1 ;

}

}
}

int __glproject__7MapdescFPfiT1N22 (struct Mapdesc *__0this , REAL *__1src , int __1stride , REAL *__1dest , int __1tstride , int __1ncols )
{ 
int __1s ;

REAL *__1clast ;

__1s = (((__1src [__0this -> inhcoords__7Mapdesc ])> 0 )?1 :(((__1src [__0this -> inhcoords__7Mapdesc ])< 0.0 )?-1:0 ));

__1clast = (__1src + (__1ncols * __1stride ));
{ { REAL *__1cptr ;

REAL *__1tcptr ;

__1cptr = __1src ;

__1tcptr = __1dest ;

for(;__1cptr != __1clast ;( (__1cptr += __1stride ), (__1tcptr += __1tstride )) ) { 
REAL *__2coordlast ;

__2coordlast = (__1cptr + __0this -> inhcoords__7Mapdesc );
if (((((*__2coordlast ))> 0 )?1 :((((*__2coordlast ))< 0.0 )?-1:0 ))!= __1s )return 0 ;
{ { REAL *__2coord ;

REAL *__2tcoord ;

__2coord = __1cptr ;

__2tcoord = __1tcptr ;

for(;__2coord != __2coordlast ;( (__2coord ++ ), (__2tcoord ++ )) ) 
((*__2tcoord ))= (((*__2coord ))/ ((*__2coordlast )));

}

}
}

return 1 ;

}

}
}

void __glbbox__7MapdescFPA5_fPfiN33 (struct Mapdesc *, REAL (*)[5], REAL *, int , int , int , int );

extern float __glmyceilf (float );
extern float __glmyfloorf (float );

int __glbboxTooBig__7MapdescFPfiN30 (struct Mapdesc *__0this , 
REAL *__1p , 
int __1rstride , 
int __1cstride , 
int __1nrows , 
int __1ncols , 
REAL (*__1bb )[5])
{ 
REAL __1bbpts [24][24][5];



int __1val ;

__1val = __glproject__7MapdescFPfiT2T1N0 ( __0this , __1p , __1rstride , __1cstride , & (((__1bbpts [0 ])[0 ])[0 ]), (int )120, (int )5, __1nrows , __1ncols )
;

if (__1val == 0 )return -1;

__glbbox__7MapdescFPA5_fPfiN33 ( __0this , __1bb , & (((__1bbpts [0 ])[0 ])[0 ]), (int )120, (int )5, __1nrows , __1ncols ) ;

if (__0this -> bbox_subdividing__7Mapdesc == 2.0 ){ 
{ { int __2k ;

__2k = 0 ;

for(;__2k != __0this -> inhcoords__7Mapdesc ;__2k ++ ) 
if ((__glmyceilf ( (__1bb [1 ])[__2k ]) - __glmyfloorf ( (__1bb [0 ])[__2k ]) )> (__0this -> bboxsize__7Mapdesc [__2k ]))return 1 ;

}

}
}
else 
{ 
{ { int __2k ;

__2k = 0 ;

for(;__2k != __0this -> inhcoords__7Mapdesc ;__2k ++ ) 
if ((((__1bb [1 ])[__2k ])- ((__1bb [0 ])[__2k ]))> (__0this -> bboxsize__7Mapdesc [__2k ]))return 1 ;

}

}
}
return 0 ;
}

void __glbbox__7MapdescFPA5_fPfiN33 (struct Mapdesc *__0this , 
REAL (*__1bb )[5], 
REAL *__1p , 
int __1rstride , 
int __1cstride , 
int __1nrows , 
int __1ncols )
{ 
{
{ int __1k ;

__1k = 0 ;

for(;__1k != __0this -> inhcoords__7Mapdesc ;__1k ++ ) 
((__1bb [0 ])[__1k ])= (((__1bb [1 ])[__1k ])= (__1p [__1k ]));

{ { int __1i ;

__1i = 0 ;

for(;__1i != __1nrows ;__1i ++ ) 
{ { int __1j ;

__1j = 0 ;

for(;__1j != __1ncols ;__1j ++ ) 
for(__1k = 0 ;__1k != __0this -> inhcoords__7Mapdesc ;__1k ++ ) { 
REAL __2x ;

__2x = (__1p [(((__1i * __1rstride )+ (__1j * __1cstride ))+ __1k )]);
if (__2x < ((__1bb [0 ])[__1k ]))((__1bb [0 ])[__1k ])= __2x ;
else if (__2x > ((__1bb [1 ])[__1k ]))((__1bb [1 ])[__1k ])= __2x ;
}

}

}

}

}

}

}
}

REAL __glcalcPartialVelocity__7Mapd0 (struct Mapdesc *, REAL *, int , int , int , REAL );

REAL __glcalcVelocityRational__7Map0 (struct Mapdesc *__0this , REAL *__1p , int __1stride , int __1ncols )
{ 
REAL __1tmp [24][5];

((void )0 );

{ 
if (__glproject__7MapdescFPfiT1N22 ( __0this , __1p , __1stride , & ((__1tmp [0 ])[0 ]), (int )5, __1ncols ) ){ 
return __glcalcPartialVelocity__7Mapd0 (
__0this , & ((__1tmp [0 ])[0 ]), (int )5, __1ncols , 1 , (float )1.0 ) ;
}
else 
{ 
return __glcalcPartialVelocity__7Mapd0 ( __0this , & ((__1tmp [0 ])[0 ]), (int )5, __1ncols , 1 , (float )1.0 ) ;

}

}
}

REAL __glcalcVelocityNonrational__70 (struct Mapdesc *__0this , REAL *__1pts , int __1stride , int __1ncols )
{ 
return __glcalcPartialVelocity__7Mapd0 ( __0this , __1pts , __1stride , __1ncols , 1 ,
(float )1.0 ) ;
}

int __glisProperty__7MapdescFl (struct Mapdesc *__0this , long __1property )
{ 
switch (__1property ){ 
case 1 :
case 2 :
case 17 :
case 6 :
case 7 :
case 10 :
case
13 :
case 14 :
return 1 ;
default :
return 0 ;
}
}

REAL __glgetProperty__7MapdescFl (struct Mapdesc *__0this , long __1property )
{ 
switch (__1property ){ 
case 1 :
return __0this -> pixel_tolerance__7Mapdesc ;
case 2 :
return __0this -> culling_method__7Mapdesc ;
case 17 :
return __0this -> bbox_subdividing__7Mapdesc ;
case 6 :
return __0this -> s_steps__7Mapdesc ;
case 7 :
return __0this -> t_steps__7Mapdesc ;
case 10 :
return __0this -> sampling_method__7Mapdesc ;
case 13 :
return __0this -> clampfactor__7Mapdesc ;
case 14 :
return __0this -> minsavings__7Mapdesc ;
default :
abort ( ) ;
}
}

void __glsetProperty__7MapdescFlf (struct Mapdesc *__0this , long __1property , REAL __1value )
{ 
switch (__1property ){ 
case 1 :
__0this -> pixel_tolerance__7Mapdesc = __1value ;
break ;
case 2 :
__0this -> culling_method__7Mapdesc = __1value ;
break ;
case 17 :
if (__1value <= 0.0 )__1value = 0.0 ;
__0this -> bbox_subdividing__7Mapdesc = __1value ;
break ;
case 6 :
if (__1value < 0.0 )__1value = 0.0 ;
__0this -> s_steps__7Mapdesc = __1value ;
__0this -> maxrate__7Mapdesc = ((__1value < 0.0 )?0.0 :(((double )__1value )));
__0this -> maxsrate__7Mapdesc = ((__1value < 0.0 )?0.0 :(((double )__1value )));
break ;
case 7 :
if (__1value < 0.0 )__1value = 0.0 ;
__0this -> t_steps__7Mapdesc = __1value ;
__0this -> maxtrate__7Mapdesc = ((__1value < 0.0 )?0.0 :(((double )__1value )));
break ;
case 10 :
__0this -> sampling_method__7Mapdesc = __1value ;
break ;
case 13 :
if (__1value <= 0.0 )__1value = 0.0 ;
__0this -> clampfactor__7Mapdesc = __1value ;
break ;
case 14 :
if (__1value <= 0.0 )__1value = 0.0 ;
__0this -> minsavings__7Mapdesc = __1value ;
break ;
default :
abort ( ) ;
break ;
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\mapdescv.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <math.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/mapdescv.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);


















typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};





typedef REAL Maxmatrix [5][5];
struct Backend;



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};

void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);








// extern double sqrt (double );
extern struct __mptr* __ptbl_vec_____core_mapdescv_c___calcPartialVelocity_[];

REAL __glcalcPartialVelocity__7Mapd0 (struct Mapdesc *__0this , 
REAL *__1p , 
int __1stride , 
int __1ncols , 
int __1partial , 
REAL __1range )
{ 
REAL __1tmp [24][5];
REAL __1mag [24];

int __1j ;

int __1k ;

int __1t ;

((void )0 );

;

;

;

for(__1j = 0 ;__1j != __1ncols ;__1j ++ ) 
for(__1k = 0 ;__1k != __0this -> inhcoords__7Mapdesc ;__1k ++ ) 
((__1tmp [__1j ])[__1k ])= (__1p [((__1j * __1stride )+ __1k )]);

for(__1t = 0 ;__1t != __1partial ;__1t ++ ) 
for(__1j = 0 ;__1j != ((__1ncols - __1t )- 1 );__1j ++ ) 
for(__1k = 0 ;__1k != __0this -> inhcoords__7Mapdesc ;__1k ++
) 
((__1tmp [__1j ])[__1k ])= (((__1tmp [(__1j + 1 )])[__1k ])- ((__1tmp [__1j ])[__1k ]));

for(__1j = 0 ;__1j != (__1ncols - __1partial );__1j ++ ) { 
(__1mag [__1j ])= 0.0 ;
for(__1k = 0 ;__1k != __0this -> inhcoords__7Mapdesc ;__1k ++ ) 
(__1mag [__1j ])+= (((__1tmp [__1j ])[__1k ])* ((__1tmp [__1j ])[__1k ]));
}

{ REAL __1fac ;
REAL __1invt ;

__1fac = 1 ;
__1invt = (1.0 / __1range );
for(__1t = (__1ncols - 1 );__1t != ((__1ncols - 1 )- __1partial );__1t -- ) 
__1fac *= (__1t * __1invt );

{ REAL __1max ;

__1max = 0.0 ;
for(__1j = 0 ;__1j != (__1ncols - __1partial );__1j ++ ) 
if ((__1mag [__1j ])> __1max )__1max = (__1mag [__1j ]);
__1max = (__1fac * sqrt ( (double )(((float )__1max ))) );

return __1max ;

}

}
}

// extern void *memset (void *, int , size_t );

REAL __glcalcPartialVelocity__7Mapd1 (struct Mapdesc *__0this , 
REAL *__1dist , 
REAL *__1p , 
int __1rstride , 
int __1cstride , 
int __1nrows , 
int __1ncols , 
int __1spartial ,

int __1tpartial , 
REAL __1srange , 
REAL __1trange , 
int __1side )
{ 
REAL __1tmp [24][24][5];
REAL __1mag [24][24];

((void )0 );
((void )0 );

{ REAL *__1tp ;
REAL *__1mp ;





int __1idist ;
int __1jdist ;
int __1kdist ;
int __1id ;
int __1jd ;

__1tp = (& (((__1tmp [0 ])[0 ])[0 ]));
__1mp = (& ((__1mag [0 ])[0 ]));

__1idist = (__1nrows * 120);
__1jdist = (__1ncols * 5);
__1kdist = (__0this -> inhcoords__7Mapdesc * 1);
__1id = (__1idist - (__1spartial * 120));
__1jd = (__1jdist - (__1tpartial * 5));

{ 
REAL *__2ti ;
REAL *__2qi ;
REAL *__2til ;

__2ti = __1tp ;
__2qi = __1p ;
__2til = (__1tp + __1idist );
for(;__2ti != __2til ;) { 
REAL *__3tj ;
REAL *__3qj ;
REAL *__3tjl ;

__3tj = __2ti ;
__3qj = __2qi ;
__3tjl = (__2ti + __1jdist );
for(;__3tj != __3tjl ;) { 
{ { int __4k ;

__4k = 0 ;

for(;__4k != __0this -> inhcoords__7Mapdesc ;__4k ++ ) { 
(__3tj [__4k ])= (__3qj [__4k ]);
}
__3tj += 5;
__3qj += __1cstride ;

}

}
}
__2ti += 120;
__2qi += __1rstride ;
}
}

{ 
REAL *__2til ;
REAL *__2till ;

__2til = ((__1tp + __1idist )- 120);
__2till = (float *)(__2til - (__1spartial * 120));
for(;__2til != (float *)__2till ;__2til -= 120) 
{ { REAL *__2ti ;

__2ti = __1tp ;

for(;__2ti != __2til ;__2ti += 120) 
{ { REAL *__2tj ;

REAL *__2tjl ;

__2tj = __2ti ;

__2tjl = (__2tj + __1jdist );

for(;__2tj != __2tjl ;__2tj += 5) 
{ { int __2k ;

__2k = 0 ;

for(;__2k != __0this -> inhcoords__7Mapdesc ;__2k ++ ) 
(__2tj [__2k ])= ((__2tj [(__2k + 120)])- (__2tj [__2k ]));

}

}

}

}

}

}
}

{ 
REAL *__2tjl ;
REAL *__2tjll ;

__2tjl = ((__1tp + __1jdist )- 5);
__2tjll = (float *)(__2tjl - (__1tpartial * 5));
for(;__2tjl != (float *)__2tjll ;__2tjl -= 5) 
{ { REAL *__2tj ;

__2tj = __1tp ;

for(;__2tj != __2tjl ;__2tj += 5) 
{ { REAL *__2ti ;

REAL *__2til ;

__2ti = __2tj ;

__2til = (__2ti + __1id );

for(;__2ti != __2til ;__2ti += 120) 
{ { int __2k ;

__2k = 0 ;

for(;__2k != __0this -> inhcoords__7Mapdesc ;__2k ++ ) 
(__2ti [__2k ])= ((__2ti [(__2k + 5)])- (__2ti [__2k ]));

}

}

}

}

}

}

}

{ REAL __1max ;

int __1i ;

int __1j ;

REAL __1fac ;

__1max = 0.0 ;
{ 
memset ( ((void *)__1mp ), 0 , sizeof __1mag ) ;
{ { REAL *__2ti ;

REAL *__2mi ;

REAL *__2til ;

__2ti = __1tp ;

__2mi = __1mp ;

__2til = (__1tp + __1id );

for(;__2ti != __2til ;( (__2ti += 120), (__2mi += 24)) ) 
{ { REAL *__2tj ;

REAL *__2mj ;

REAL *__2tjl ;

__2tj = __2ti ;

__2mj = __2mi ;

__2tjl = (__2ti + __1jd );

for(;__2tj != __2tjl ;( (__2tj += 5), (__2mj += 1)) ) { 
{ { int __3k ;

__3k = 0 ;

for(;__3k != __0this -> inhcoords__7Mapdesc ;__3k ++ ) 
((*__2mj ))+= ((__2tj [__3k ])* (__2tj [__3k ]));
if (((*__2mj ))> __1max )__1max = ((*__2mj ));

}

}
}

}

}

}

}

}

;

;

__1fac = 1.0 ;
{ 
REAL __2invs ;
REAL __2invt ;

__2invs = (1.0 / __1srange );
__2invt = (1.0 / __1trange );
{ { int __2s ;

int __2slast ;

__2s = (__1nrows - 1 );

__2slast = (__2s - __1spartial );

for(;__2s != __2slast ;__2s -- ) 
__1fac *= (__2s * __2invs );
{ { int __2t ;

int __2tlast ;

__2t = (__1ncols - 1 );

__2tlast = (__2t - __1tpartial );

for(;__2t != __2tlast ;__2t -- ) 
__1fac *= (__2t * __2invt );

}

}

}

}
}

if (__1side == 0 ){ 
(__1dist [0 ])= 0.0 ;
(__1dist [1 ])= 0.0 ;
for(__1i = 0 ;__1i != (__1nrows - __1spartial );__1i ++ ) { 
__1j = 0 ;
if (((__1mag [__1i ])[__1j ])> (__1dist [0 ]))(__1dist [0 ])= ((__1mag [__1i ])[__1j ]);

__1j = ((__1ncols - __1tpartial )- 1 );
if (((__1mag [__1i ])[__1j ])> (__1dist [1 ]))(__1dist [1 ])= ((__1mag [__1i ])[__1j ]);
}
(__1dist [0 ])= (__1fac * sqrt ( (double )(__1dist [0 ])) );
(__1dist [1 ])= (__1fac * sqrt ( (double )(__1dist [1 ])) );
}
else 
if (__1side == 1 ){ 
(__1dist [0 ])= 0.0 ;
(__1dist [1 ])= 0.0 ;
for(__1j = 0 ;__1j != (__1ncols - __1tpartial );__1j ++ ) { 
__1i = 0 ;
if (((__1mag [__1i ])[__1j ])> (__1dist [0 ]))(__1dist [0 ])= ((__1mag [__1i ])[__1j ]);

__1i = ((__1nrows - __1spartial )- 1 );
if (((__1mag [__1i ])[__1j ])> (__1dist [1 ]))(__1dist [1 ])= ((__1mag [__1i ])[__1j ]);
}
(__1dist [0 ])= (__1fac * sqrt ( (double )(__1dist [0 ])) );
(__1dist [1 ])= (__1fac * sqrt ( (double )(__1dist [1 ])) );
}

__1max = (__1fac * sqrt ( (double )(((float )__1max ))) );

return __1max ;

}

}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\knotvect.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/knotvector.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);









typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct Knotvector;

struct Knotvector {	

long order__10Knotvector ;
long knotcount__10Knotvector ;
long stride__10Knotvector ;
Knot *knotlist__10Knotvector ;
};




extern struct __mptr* __ptbl_vec_____core_knotvector_c___init_[];


void __glinit__10KnotvectorFlN21Pf (struct Knotvector *__0this , long __1_knotcount , long __1_stride , long __1_order , float *__1_knotlist )
{ 
void *__1__Xp00uzigaiaa ;

__0this -> knotcount__10Knotvector = __1_knotcount ;
__0this -> stride__10Knotvector = __1_stride ;
__0this -> order__10Knotvector = __1_order ;
__0this -> knotlist__10Knotvector = (((float *)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (float ))* __1_knotcount )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa ))))
));
((void )0 );

{ { int __1i ;

__1i = 0 ;

for(;__1i != __1_knotcount ;__1i ++ ) 
(__0this -> knotlist__10Knotvector [__1i ])= (((float )(__1_knotlist [__1i ])));

}

}
}


struct Knotvector *__gl__ct__10KnotvectorFv (struct Knotvector *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Knotvector *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Knotvector))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))
__0this ->
knotlist__10Knotvector = 0 ;
return __0this ;

}


void __gl__dt__10KnotvectorFv (struct Knotvector *__0this , 
int __0__free )
{ 
void *__1__X2 ;

if (__0this ){ 
if (__0this -> knotlist__10Knotvector )( (__1__X2 = (void *)__0this -> knotlist__10Knotvector ), ( (__1__X2 ?( free ( __1__X2 ) ,
0 ) :( 0 ) )) ) ;
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}


int __glvalidate__10KnotvectorFv (struct Knotvector *__0this )
{ 
long __1kindex ;

__1kindex = (__0this -> knotcount__10Knotvector - 1 );

if ((__0this -> order__10Knotvector < 1 )|| (__0this -> order__10Knotvector > 24 )){ 
return 1 ;
}

if (__0this -> knotcount__10Knotvector < (2 * __0this -> order__10Knotvector )){ 
return 2 ;
}

if (( ((((__0this -> knotlist__10Knotvector [(__1kindex - (__0this -> order__10Knotvector - 1 ))])- (__0this -> knotlist__10Knotvector [(__0this -> order__10Knotvector - 1 )]))< 10.0e-5 )?1 :0 )) ){ 
return
3 ;
}

{ { long __1i ;

__1i = 0 ;

for(;__1i < __1kindex ;__1i ++ ) 
if ((__0this -> knotlist__10Knotvector [__1i ])> (__0this -> knotlist__10Knotvector [(__1i + 1 )])){ 
return 4 ;
}

{ long __1multi ;

__1multi = 1 ;
for(-- __1kindex ;__1kindex > 1 ;__1kindex -- ) { 
if (((__0this -> knotlist__10Knotvector [__1kindex ])- (__0this -> knotlist__10Knotvector [(__1kindex - 1 )]))< 10.0e-5 ){ 
__1multi ++ ;

continue ;
}
if (__1multi > __0this -> order__10Knotvector ){ 
return 5 ;
}
__1multi = 1 ;
}

if (__1multi > __0this -> order__10Knotvector ){ 
return 5 ;
}

return 0 ;

}

}

}
}

void __glshow__10KnotvectorFPc (struct Knotvector *__0this , char *__1msg )
{ 
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\maplist.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/maplist.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);















typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};




struct Backend;

struct Mapdesc;

struct Maplist;

void __gl__dt__4PoolFv (struct Pool *, int );


struct Maplist {	

struct Pool mapdescPool__7Maplist ;
struct Mapdesc *maps__7Maplist ;
struct Mapdesc **lastmap__7Maplist ;
struct Backend *backend__7Maplist ;
};

struct Mapdesc *__gllocate__7MaplistFl (struct Maplist *, long );

void __glremove__7MaplistFP7Mapdesc (struct Maplist *, struct Mapdesc *);




typedef REAL Maxmatrix [5][5];
struct Backend;



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};


void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);











struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;



struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};




struct Pool *__gl__ct__4PoolFiT1Pc (struct Pool *, int , int , char *);
extern struct __mptr* __ptbl_vec_____core_maplist_c_____ct_[];


struct Maplist *__gl__ct__7MaplistFR7Backend (struct Maplist *__0this , struct Backend *__1b )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Maplist *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Maplist))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){
( __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> mapdescPool__7Maplist ), (int )(sizeof (struct Mapdesc )), 10 , (char *)"mapdesc pool")
, (__0this -> backend__7Maplist = __1b )) ;
__0this -> maps__7Maplist = 0 ;

__0this -> lastmap__7Maplist = (& __0this -> maps__7Maplist );
} return __0this ;

}

void __glfreeMaps__7MaplistFv (struct Maplist *);

void __gldefine__7MaplistFliT2 (struct Maplist *, long , int , int );

void __glinitialize__7MaplistFv (struct Maplist *__0this )
{ 
__glfreeMaps__7MaplistFv ( __0this ) ;
__gldefine__7MaplistFliT2 ( __0this , (long )0x8 , 0 , 2 ) ;
__gldefine__7MaplistFliT2 ( __0this , (long )0xd , 1 , 3 ) ;
}

struct Mapdesc *__gl__ct__7MapdescFliT2R7Backe0 (struct Mapdesc *, long , int , int , struct Backend *);


void __gladd__7MaplistFliT2 (struct Maplist *__0this , long __1type , int __1israt , int __1ncoords )
{ 
struct Mapdesc *__0__X5 ;

void *__1__Xbuffer00idhgaiaa ;

((*__0this -> lastmap__7Maplist ))= ((__0__X5 = (struct Mapdesc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this ->
mapdescPool__7Maplist )))-> freelist__4Pool ?( ( (__1__Xbuffer00idhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> mapdescPool__7Maplist )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(&
__0this -> mapdescPool__7Maplist )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> mapdescPool__7Maplist )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( (
((! ((struct Pool *)((struct Pool *)(& __0this -> mapdescPool__7Maplist )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> mapdescPool__7Maplist )))) ,
0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> mapdescPool__7Maplist )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(&
__0this -> mapdescPool__7Maplist )))-> buffersize__4Pool ), ( (__1__Xbuffer00idhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> mapdescPool__7Maplist )))-> curblock__4Pool + ((struct Pool *)((struct
Pool *)(& __0this -> mapdescPool__7Maplist )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00idhgaiaa ))) ) ))) )?__gl__ct__7MapdescFliT2R7Backe0 (
(struct Mapdesc *)__0__X5 , __1type , __1israt , __1ncoords , __0this -> backend__7Maplist ) :0 );
__0this -> lastmap__7Maplist = (& ((*__0this -> lastmap__7Maplist ))-> next__7Mapdesc );
}

void __gldefine__7MaplistFliT2 (struct Maplist *__0this , long __1type , int __1israt , int __1ncoords )
{ 
struct Mapdesc *__1m ;

__1m = __gllocate__7MaplistFl ( __0this , __1type ) ;
((void )0 );
__gladd__7MaplistFliT2 ( __0this , __1type , __1israt , __1ncoords ) ;
}


// extern void abort (void );

void __glremove__7MaplistFP7Mapdesc (struct Maplist *__0this , struct Mapdesc *__1m )
{ 
{ { struct Mapdesc **__1curmap ;

__1curmap = (& __0this -> maps__7Maplist );

for(;(*__1curmap );__1curmap = (& ((*__1curmap ))-> next__7Mapdesc )) { 
if (((*__1curmap ))== __1m ){ 
((*__1curmap ))= __1m -> next__7Mapdesc ;
( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1m )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(&
__0this -> mapdescPool__7Maplist )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> mapdescPool__7Maplist )))-> freelist__4Pool = (((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1m )))))))))
) ) ;
return ;
}
}
abort ( ) ;

}

}
}

void __glclear__4PoolFv (struct Pool *);

void __glfreeMaps__7MaplistFv (struct Maplist *__0this )
{ 
__glclear__4PoolFv ( (struct Pool *)(& __0this -> mapdescPool__7Maplist )) ;
__0this -> maps__7Maplist = 0 ;
__0this -> lastmap__7Maplist = (& __0this -> maps__7Maplist );
}

struct Mapdesc *__glfind__7MaplistFl (struct Maplist *__0this , long __1type )
{ 
struct Mapdesc *__1val ;

__1val = __gllocate__7MaplistFl ( __0this , __1type ) ;
((void )0 );
return __1val ;
}


struct Mapdesc *__gllocate__7MaplistFl (struct Maplist *__0this , long __1type )
{ 
{ { struct Mapdesc *__1m ;

__1m = __0this -> maps__7Maplist ;

for(;__1m ;__1m = __1m -> next__7Mapdesc ) 
if (( ((struct Mapdesc *)__1m )-> type__7Mapdesc ) == __1type )break ;
return __1m ;

}

}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\monotoni.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/monotonizer.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;













struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];



struct Mapdesc;



struct BezierArc;



struct BezierArc {	

char __W3__9PooledObj ;

REAL *cpts__9BezierArc ;
int order__9BezierArc ;
int stride__9BezierArc ;
long type__9BezierArc ;
struct Mapdesc *mapdesc__9BezierArc ;
};




struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};






typedef REAL Maxmatrix [5][5];
struct Backend;



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};


void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);











struct JumpBuffer;








struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};





void __gltessellate__10SubdividerFP0 (struct Subdivider *, struct Arc *, REAL );

int __glisDisconnected__3ArcFv (struct Arc *);



void __glmonotonize__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Bin *);

extern struct __mptr* __ptbl_vec_____core_monotonizer_c___decompose_[];

int __gldecompose__10SubdividerFR30 (struct Subdivider *__0this , struct Bin *__1bin , REAL __1geo_stepsize )
{ 
{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc002hmkaiid ;

__1jarc = ( (((struct Bin *)__1bin )-> current__3Bin = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc002hmkaiid = ((struct Bin *)__1bin )-> current__3Bin ), (
(__1__Xjarc002hmkaiid ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc002hmkaiid -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc002hmkaiid ) ) ) ;
for(;__1jarc ;__1jarc = ( (__1__Xjarc002hmkaiid = ((struct Bin *)__1bin )-> current__3Bin ), ( (__1__Xjarc002hmkaiid ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc002hmkaiid -> link__3Arc ), 0 )
:( 0 ) ), __1__Xjarc002hmkaiid ) ) ) { 
if (! ( (((struct Arc *)__1jarc )-> pwlArc__3Arc ?1 :0 )) ){

__gltessellate__10SubdividerFP0 ( __0this , __1jarc , __1geo_stepsize ) ;
if (__glisDisconnected__3ArcFv ( (struct Arc *)__1jarc ) || __glisDisconnected__3ArcFv ( (struct Arc *)__1jarc -> next__3Arc ) )
return 1 ;
}
}

for(__1jarc = ( (((struct Bin *)__1bin )-> current__3Bin = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc002hmkaiid = ((struct Bin *)__1bin )-> current__3Bin ), (
(__1__Xjarc002hmkaiid ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc002hmkaiid -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc002hmkaiid ) ) ) ;__1jarc ;__1jarc =
( (__1__Xjarc002hmkaiid = ((struct Bin *)__1bin )-> current__3Bin ), ( (__1__Xjarc002hmkaiid ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc002hmkaiid -> link__3Arc ), 0 ) :(
0 ) ), __1__Xjarc002hmkaiid ) ) ) { 
__glmonotonize__10SubdividerFP0 ( __0this , __1jarc , __1bin ) ;
}

return 0 ;

}

}
}


REAL __glcalcVelocityRational__7Map0 (struct Mapdesc *, REAL *, int , int );

void __gltessellateNonlizNear__14Arc0 (struct ArcTessellator *, struct Arc *, REAL , REAL , int );

void __gltessellateLizNear__14ArcTes0 (struct ArcTessellator *, struct Arc *, REAL , REAL , int );

REAL __glcalcVelocityNonrational__70 (struct Mapdesc *, REAL *, int , int );

void __gltessellate__10SubdividerFP0 (struct Subdivider *__0this , Arc_ptr __1jarc , REAL __1geo_stepsize )
{ 
struct BezierArc *__1b ;
struct Mapdesc *__1mapdesc ;

__1b = __1jarc -> bezierArc__3Arc ;
__1mapdesc = __1b -> mapdesc__9BezierArc ;

if (( (((struct Mapdesc *)__1mapdesc )-> isrational__7Mapdesc ?1 :0 )) ){ 
REAL __2max ;
REAL __2arc_stepsize ;

__2max = __glcalcVelocityRational__7Map0 ( (struct Mapdesc *)__1mapdesc , __1b -> cpts__9BezierArc , __1b -> stride__9BezierArc , __1b -> order__9BezierArc ) ;
__2arc_stepsize = ((__2max > 1.0 )?(1.0 / __2max ):1.0 );
if (__1jarc -> bezierArc__3Arc -> order__9BezierArc != 2 )
__gltessellateNonlizNear__14Arc0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __1geo_stepsize , __2arc_stepsize , 1 ) ;
else 
{ 
__gltessellateLizNear__14ArcTes0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __1geo_stepsize , __2arc_stepsize , 1 ) ;
}
}
else 
{ 
REAL __2max ;
REAL __2arc_stepsize ;

__2max = __glcalcVelocityNonrational__70 ( (struct Mapdesc *)__1mapdesc , __1b -> cpts__9BezierArc , __1b -> stride__9BezierArc , __1b -> order__9BezierArc ) ;
__2arc_stepsize = ((__2max > 1.0 )?(1.0 / __2max ):1.0 );
if (__1jarc -> bezierArc__3Arc -> order__9BezierArc != 2 )
__gltessellateNonlizNear__14Arc0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __1geo_stepsize , __2arc_stepsize , 0 ) ;
else 
{ 
__gltessellateLizNear__14ArcTes0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __1geo_stepsize , __2arc_stepsize , 0 ) ;
}
}
}



Arc_ptr __glappend__3ArcFP3Arc (struct Arc *, Arc_ptr );



void __glremove_this_arc__3BinFP3Ar0 (struct Bin *, struct Arc *);



void __glmonotonize__10SubdividerFP0 (struct Subdivider *__0this , Arc_ptr __1jarc , struct Bin *__1bin )
{ 
struct TrimVertex *__1firstvert ;
struct TrimVertex *__1lastvert ;
long __1uid ;
int __1side ;
int __1sdir ;
int __1tdir ;
int __1degenerate ;

int __1nudegenerate ;
int __1change ;

__1firstvert = __1jarc -> pwlArc__3Arc -> pts__6PwlArc ;
__1lastvert = (__1firstvert + (__1jarc -> pwlArc__3Arc -> npts__6PwlArc - 1 ));
__1uid = __1jarc -> nuid__3Arc ;
__1side = ( (((int )((((struct Arc *)__1jarc )-> type__3Arc >> 8 )& 0x7 )))) ;
__1sdir = 3;
__1tdir = 3;
__1degenerate = 1 ;

{ { struct TrimVertex *__1vert ;

__1vert = __1firstvert ;

for(;__1vert != __1lastvert ;__1vert ++ ) { 
__1nudegenerate = 1 ;
__1change = 0 ;

{ REAL __2sdiff ;

__2sdiff = (((__1vert [1 ]). param__10TrimVertex [0 ])- ((__1vert [0 ]). param__10TrimVertex [0 ]));
if (__2sdiff == 0 ){ 
if (__1sdir != 1){ 
__1sdir = 1;
__1change = 1 ;
}
}
else 
if (__2sdiff < 0.0 ){ 
if (__1sdir != 0){ 
__1sdir = 0;
__1change = 1 ;
}
__1nudegenerate = 0 ;
}
else 
{ 
if (__1sdir != 2){ 
__1sdir = 2;
__1change = 1 ;
}
__1nudegenerate = 0 ;
}

{ REAL __2tdiff ;

__2tdiff = (((__1vert [1 ]). param__10TrimVertex [1 ])- ((__1vert [0 ]). param__10TrimVertex [1 ]));
if (__2tdiff == 0 ){ 
if (__1tdir != 1){ 
__1tdir = 1;
__1change = 1 ;
}
}
else 
if (__2tdiff < 0.0 ){ 
if (__1tdir != 0){ 
__1tdir = 0;
__1change = 1 ;
}
__1nudegenerate = 0 ;
}
else 
{ 
if (__1tdir != 2){ 
__1tdir = 2;
__1change = 1 ;
}
__1nudegenerate = 0 ;
}

if (__1change ){ 
if (! __1degenerate ){ 
struct Arc *__0__X13 ;

void *__1__Xbuffer00azhgaiaa ;

struct PwlArc *__0__X14 ;

__1jarc -> pwlArc__3Arc -> npts__6PwlArc = ((__1vert - __1firstvert )+ 1 );
__1jarc = __glappend__3ArcFP3Arc ( (struct Arc *)((__0__X13 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> freelist__4Pool ?( ( (__1__Xbuffer00azhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct
Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :(
( ((! ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider ))))
, 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct
Pool *)(& __0this -> arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00azhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct
Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00azhgaiaa ))) ) )))
)?( (((struct Arc *)__0__X13 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X13 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X13 )-> type__3Arc =
0 ), ( ( ( (((struct Arc *)__0__X13 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X13 )-> type__3Arc |= ((((long )__1side ))<<
8 ))) , ( (((struct Arc *)__0__X13 )-> nuid__3Arc = __1uid ), ((((struct Arc *)__0__X13 )))) ) ) ) ) :0 ),
__1jarc ) ;
__1jarc -> pwlArc__3Arc = ((__0__X14 = (struct PwlArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this ->
pwlarcpool__10Subdivider )))-> freelist__4Pool ?( ( (__1__Xbuffer00azhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(&
__0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( (
((! ((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))) ,
0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(&
__0this -> pwlarcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00azhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct
Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00azhgaiaa ))) ) ))) )?(
(((struct PwlArc *)__0__X14 )-> type__6PwlArc = 0x8 ), ( (((struct PwlArc *)__0__X14 )-> pts__6PwlArc = 0 ), ( (((struct PwlArc *)__0__X14 )-> npts__6PwlArc = -1),
((((struct PwlArc *)__0__X14 )))) ) ) :0 );
( (__1jarc -> link__3Arc = ((struct Bin *)__1bin )-> head__3Bin ), (((struct Bin *)__1bin )-> head__3Bin = __1jarc )) ;
}
__1firstvert = (__1jarc -> pwlArc__3Arc -> pts__6PwlArc = __1vert );
__1degenerate = __1nudegenerate ;
}

}

}
}
__1jarc -> pwlArc__3Arc -> npts__6PwlArc = ((__1vert - __1firstvert )+ 1 );

if (__1degenerate ){ 
struct PooledObj *__0__X15 ;

__1jarc -> prev__3Arc -> next__3Arc = __1jarc -> next__3Arc ;
__1jarc -> next__3Arc -> prev__3Arc = __1jarc -> prev__3Arc ;

((void )0 );
((void )0 );

__glremove_this_arc__3BinFP3Ar0 ( (struct Bin *)__1bin , __1jarc ) ;

( (__0__X15 = (struct PooledObj *)__1jarc -> pwlArc__3Arc ), ( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)__0__X15 ))))))->
next__6Buffer = ((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool = (((struct
Buffer *)(((struct Buffer *)(((void *)__0__X15 )))))))) ) ) ) ;

__1jarc -> pwlArc__3Arc = 0 ;
( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1jarc )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool = (((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1jarc )))))))))
) ) ;
}

}

}
}

int __glisMonotone__10SubdividerFP0 (struct Subdivider *__0this , Arc_ptr __1jarc )
{ 
struct TrimVertex *__1firstvert ;
struct TrimVertex *__1lastvert ;

__1firstvert = __1jarc -> pwlArc__3Arc -> pts__6PwlArc ;
__1lastvert = (__1firstvert + (__1jarc -> pwlArc__3Arc -> npts__6PwlArc - 1 ));

if (__1firstvert == __1lastvert )return 1 ;

{ struct TrimVertex *__1vert ;
int __1sdir ;
int __1tdir ;

REAL __1diff ;

__1vert = __1firstvert ;

__1diff = (((__1vert [1 ]). param__10TrimVertex [0 ])- ((__1vert [0 ]). param__10TrimVertex [0 ]));
if (__1diff == 0.0 )
__1sdir = 1;
else if (__1diff < 0.0 )
__1sdir = 0;
else 
__1sdir = 2;

__1diff = (((__1vert [1 ]). param__10TrimVertex [1 ])- ((__1vert [0 ]). param__10TrimVertex [1 ]));
if (__1diff == 0.0 )
__1tdir = 1;
else if (__1diff < 0.0 )
__1tdir = 0;
else 
__1tdir = 2;

if ((__1sdir == 1)&& (__1tdir == 1))return 0 ;

for(++ __1vert ;__1vert != __1lastvert ;__1vert ++ ) { 
__1diff = (((__1vert [1 ]). param__10TrimVertex [0 ])- ((__1vert [0 ]). param__10TrimVertex [0 ]));
if (__1diff == 0.0 ){ 
if (__1sdir != 1)return 0 ;
}
else 
if (__1diff < 0.0 ){ 
if (__1sdir != 0)return 0 ;
}
else 
{ 
if (__1sdir != 2)return 0 ;
}

__1diff = (((__1vert [1 ]). param__10TrimVertex [1 ])- ((__1vert [0 ]). param__10TrimVertex [1 ]));
if (__1diff == 0.0 ){ 
if (__1tdir != 1)return 0 ;
}
else 
if (__1diff < 0.0 ){ 
if (__1tdir != 0)return 0 ;
}
else 
{ 
if (__1tdir != 2)return 0 ;
}
}
return 1 ;

}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\nurbsint.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/nurbsinterfac.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct JumpBuffer;













struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;



struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};




struct Renderhints;

struct Renderhints {	

REAL display_method__11Renderhints ;
REAL errorchecking__11Renderhints ;
REAL subdivisions__11Renderhints ;
REAL tmp1__11Renderhints ;

int displaydomain__11Renderhints ;
int maxsubdivisions__11Renderhints ;
int wiretris__11Renderhints ;
int wirequads__11Renderhints ;
};






struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};






struct Mapdesc;

struct Maplist;

void __gl__dt__4PoolFv (struct Pool *, int );


struct Maplist {	

struct Pool mapdescPool__7Maplist ;
struct Mapdesc *maps__7Maplist ;
struct Mapdesc **lastmap__7Maplist ;
struct Backend *backend__7Maplist ;
};

struct Mapdesc *__gllocate__7MaplistFl (struct Maplist *, long );

void __glremove__7MaplistFP7Mapdesc (struct Maplist *, struct Mapdesc *);



enum Curvetype { ct_nurbscurve = 0, ct_pwlcurve = 1, ct_none = 2} ;
struct Property;

struct O_surface;

struct O_nurbssurface;

struct O_trim;

struct O_pwlcurve;

struct O_nurbscurve;

struct O_curve;

struct Quilt;


union __Q2_7O_curve4__C1;

union  __Q2_7O_curve4__C1 {	
struct O_nurbscurve *o_nurbscurve ;
struct O_pwlcurve *o_pwlcurve ;
};


struct O_curve;

struct O_curve {	

char __W3__9PooledObj ;

union  __Q2_7O_curve4__C1 curve__7O_curve ;
int curvetype__7O_curve ;
struct O_curve *next__7O_curve ;
struct O_surface *owner__7O_curve ;
int used__7O_curve ;
int save__7O_curve ;
long nuid__7O_curve ;
};






struct O_nurbscurve;

struct O_nurbscurve {	

char __W3__9PooledObj ;

struct Quilt *bezier_curves__12O_nurbscurve ;
long type__12O_nurbscurve ;
REAL tesselation__12O_nurbscurve ;
int method__12O_nurbscurve ;
struct O_nurbscurve *next__12O_nurbscurve ;
int used__12O_nurbscurve ;
int save__12O_nurbscurve ;
struct O_curve *owner__12O_nurbscurve ;
};






struct O_pwlcurve;



struct O_pwlcurve {	

char __W3__9PooledObj ;

struct TrimVertex *pts__10O_pwlcurve ;
int npts__10O_pwlcurve ;
struct O_pwlcurve *next__10O_pwlcurve ;
int used__10O_pwlcurve ;
int save__10O_pwlcurve ;
struct O_curve *owner__10O_pwlcurve ;
};



struct O_trim;

struct O_trim {	

char __W3__9PooledObj ;

struct O_curve *o_curve__6O_trim ;
struct O_trim *next__6O_trim ;
int save__6O_trim ;
};






struct O_nurbssurface;

struct O_nurbssurface {	

char __W3__9PooledObj ;

struct Quilt *bezier_patches__14O_nurbssurface ;
long type__14O_nurbssurface ;
struct O_surface *owner__14O_nurbssurface ;
struct O_nurbssurface *next__14O_nurbssurface ;
int save__14O_nurbssurface ;
int used__14O_nurbssurface ;
};






struct O_surface;

struct O_surface {	

char __W3__9PooledObj ;

struct O_nurbssurface *o_nurbssurface__9O_surface ;
struct O_trim *o_trim__9O_surface ;
int save__9O_surface ;
long nuid__9O_surface ;
};






struct Property;

struct Property {	

char __W3__9PooledObj ;

long type__8Property ;
long tag__8Property ;
REAL value__8Property ;
int save__8Property ;
};




struct NurbsTessellator;


struct Knotvector;

struct Quilt;

struct DisplayList;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct NurbsTessellator;

struct NurbsTessellator {	

struct Renderhints renderhints__16NurbsTessellator ;
struct Maplist maplist__16NurbsTessellator ;
struct Backend backend__16NurbsTessellator ;

struct Subdivider subdivider__16NurbsTessellator ;
struct JumpBuffer *jumpbuffer__16NurbsTessellator ;
struct Pool o_pwlcurvePool__16NurbsTessellator ;
struct Pool o_nurbscurvePool__16NurbsTessellator ;
struct Pool o_curvePool__16NurbsTessellator ;
struct Pool o_trimPool__16NurbsTessellator ;
struct Pool o_surfacePool__16NurbsTessellator ;
struct Pool o_nurbssurfacePool__16NurbsTessellator ;
struct Pool propertyPool__16NurbsTessellator ;
struct Pool quiltPool__16NurbsTessellator ;
struct TrimVertexPool extTrimVertexPool__16NurbsTessellator ;

int inSurface__16NurbsTessellator ;
int inCurve__16NurbsTessellator ;
int inTrim__16NurbsTessellator ;
int isCurveModified__16NurbsTessellator ;
int isTrimModified__16NurbsTessellator ;
int isSurfaceModified__16NurbsTessellator ;
int isDataValid__16NurbsTessellator ;
int numTrims__16NurbsTessellator ;
int playBack__16NurbsTessellator ;

struct O_trim **nextTrim__16NurbsTessellator ;
struct O_curve **nextCurve__16NurbsTessellator ;
struct O_nurbscurve **nextNurbscurve__16NurbsTessellator ;
struct O_pwlcurve **nextPwlcurve__16NurbsTessellator ;
struct O_nurbssurface **nextNurbssurface__16NurbsTessellator ;

struct O_surface *currentSurface__16NurbsTessellator ;
struct O_trim *currentTrim__16NurbsTessellator ;
struct O_curve *currentCurve__16NurbsTessellator ;

struct DisplayList *dl__16NurbsTessellator ;

struct __mptr *__vptr__16NurbsTessellator ;
};

extern char *__glNurbsErrors [];





struct Mapdesc;


struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;





typedef struct __mptr PFVS ;


struct Dlnode;



struct Dlnode {	

char __W3__9PooledObj ;

PFVS work__6Dlnode ;
void *arg__6Dlnode ;
PFVS cleanup__6Dlnode ;
struct Dlnode *next__6Dlnode ;
};

struct DisplayList;

struct DisplayList {	

struct Dlnode *nodes__11DisplayList ;
struct Pool dlnodePool__11DisplayList ;
struct Dlnode **lastNode__11DisplayList ;
struct NurbsTessellator *nt__11DisplayList ;
};




struct Knotvector;

struct Knotvector {	

long order__10Knotvector ;
long knotcount__10Knotvector ;
long stride__10Knotvector ;
Knot *knotlist__10Knotvector ;
};





typedef REAL Maxmatrix [5][5];



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};


void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);








struct Pool *__gl__ct__4PoolFiT1Pc (struct Pool *, int , int , char *);

struct Maplist *__gl__ct__7MaplistFR7Backend (struct Maplist *, struct Backend *);


struct Subdivider *__gl__ct__10SubdividerFR11Rend0 (struct Subdivider *, struct Renderhints *, struct Backend *);

extern struct JumpBuffer *__glnewJumpBuffer (void );

void __glsetJumpbuffer__10Subdivide0 (struct Subdivider *, struct JumpBuffer *);
extern struct __mptr* __gl__ptbl_vec_____core_nurbsi0[];

struct Renderhints *__gl__ct__11RenderhintsFv (struct Renderhints *);

struct TrimVertexPool *__gl__ct__14TrimVertexPoolFv (struct TrimVertexPool *);


struct NurbsTessellator *__gl__ct__16NurbsTessellatorFR0 (struct NurbsTessellator *__0this , struct BasicCurveEvaluator *__1c , struct BasicSurfaceEvaluator *__1e )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct NurbsTessellator *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct NurbsTessellator))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){
( ( ( ( ( ( ( ( ( ( ( ( ( (__0this ->
__vptr__16NurbsTessellator = (struct __mptr *) __gl__ptbl_vec_____core_nurbsi0[0]), __gl__ct__11RenderhintsFv ( (struct Renderhints *)(& __0this -> renderhints__16NurbsTessellator )) ) , __gl__ct__7MaplistFR7Backend ( (struct Maplist *)(& __0this ->
maplist__16NurbsTessellator ), (struct Backend *)(& __0this -> backend__16NurbsTessellator )) ) , ( (( ( (((struct Backend *)(& __0this -> backend__16NurbsTessellator ))->
curveEvaluator__7Backend = __1c ), (((struct Backend *)(& __0this -> backend__16NurbsTessellator ))-> surfaceEvaluator__7Backend = __1e )) , 0 ) ), ((((struct Backend *)(& __0this ->
backend__16NurbsTessellator ))))) ) , __gl__ct__10SubdividerFR11Rend0 ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator ), (struct Renderhints *)(& __0this -> renderhints__16NurbsTessellator ), (struct Backend *)(&
__0this -> backend__16NurbsTessellator )) ) , __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator ), (int )(sizeof (struct O_pwlcurve )), 32 ,
(char *)"o_pwlcurvePool") ) , __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator ), (int
)(sizeof (struct O_nurbscurve )), 32 , (char *)"o_nurbscurvePool") ) , __gl__ct__4PoolFiT1Pc ( (struct
Pool *)(& __0this -> o_curvePool__16NurbsTessellator ), (int )(sizeof (struct O_curve )), 32 , (char *)"o_curvePool")
) , __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator ), (int )(sizeof (struct O_trim )), 32 , (char *)"o_trimPool")
) , __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator ), (int )(sizeof (struct O_surface )), 1 , (char *)"o_surfacePool")
) , __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator ), (int )(sizeof (struct O_nurbssurface )), 4 , (char *)"o_nurbssurfacePool")
) , __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> propertyPool__16NurbsTessellator ), (int )(sizeof (struct Property )), 32 , (char *)"propertyPool")
) , __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> quiltPool__16NurbsTessellator ), (int )(sizeof (struct Quilt )), 32 , (char *)"quiltPool")
) , __gl__ct__14TrimVertexPoolFv ( (struct TrimVertexPool *)(& __0this -> extTrimVertexPool__16NurbsTessellator )) ) ;
__0this -> dl__16NurbsTessellator = 0 ;
__0this -> inSurface__16NurbsTessellator = 0 ;
__0this -> inCurve__16NurbsTessellator = 0 ;
__0this -> inTrim__16NurbsTessellator = 0 ;
__0this -> playBack__16NurbsTessellator = 0 ;
__0this -> jumpbuffer__16NurbsTessellator = __glnewJumpBuffer ( ) ;
__glsetJumpbuffer__10Subdivide0 ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator ), __0this -> jumpbuffer__16NurbsTessellator ) ;
} return __0this ;

}

void __gldo_nurbserror__16NurbsTess0 (struct NurbsTessellator *, int );

void __glendtrim__16NurbsTessellato0 (struct NurbsTessellator *);

void __gldo_freeall__16NurbsTessell0 (struct NurbsTessellator *);


void __gl__dt__10SubdividerFv (struct Subdivider *, int );

void __gl__dt__14TrimVertexPoolFv (struct TrimVertexPool *, int );


void __gl__dt__16NurbsTessellatorFv (struct NurbsTessellator *__0this , 
int __0__free )
{ if (__0this ){ 
__0this -> __vptr__16NurbsTessellator = (struct __mptr *) __gl__ptbl_vec_____core_nurbsi0[0];

if (__0this -> inTrim__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 12 ) ;
__glendtrim__16NurbsTessellato0 ( __0this ) ;
}

if (__0this -> inSurface__16NurbsTessellator ){ 
((*__0this -> nextNurbssurface__16NurbsTessellator ))= 0 ;
__gldo_freeall__16NurbsTessell0 ( __0this ) ;
}
if (__0this ){ __gl__dt__14TrimVertexPoolFv ( (struct TrimVertexPool *)(& __0this -> extTrimVertexPool__16NurbsTessellator ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> quiltPool__16NurbsTessellator ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> propertyPool__16NurbsTessellator ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator ), 2) ;

__gl__dt__10SubdividerFv ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator ), 2) ;

((void )( (( (( ( __gl__dt__4PoolFv ( (struct Pool *)(& ((struct Maplist *)(& __0this -> maplist__16NurbsTessellator ))-> mapdescPool__7Maplist ), 2)
, (( 0 ) )) , 0 ) ), 0 ) )) );

if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) )) ;
} } }


void __glappend__11DisplayListFM16N0 (struct DisplayList *, PFVS , void *, PFVS );

void __gldo_bgnsurface__16NurbsTess0 (struct NurbsTessellator *, struct O_surface *);

void __gldo_freebgnsurface__16Nurbs0 (struct NurbsTessellator *, struct O_surface *);


void __glbgnsurface__16NurbsTessell0 (struct NurbsTessellator *__0this , long __1nuid )
{ 
struct O_surface *__1o_surface ;

struct O_surface *__0__X16 ;

void *__1__Xbuffer00eohgaiaa ;

__1o_surface = ((__0__X16 = (struct O_surface *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
o_surfacePool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
o_surfacePool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> o_surfacePool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
O_surface *)__0__X16 )-> o_trim__9O_surface = 0 ), ( (((struct O_surface *)__0__X16 )-> o_nurbssurface__9O_surface = 0 ), ((((struct O_surface *)__0__X16 )))) ) :0 );
__1o_surface -> nuid__9O_surface = __1nuid ;
if (__0this -> dl__16NurbsTessellator ){ __1o_surface -> save__9O_surface = 1 ;

{ 
struct __mptr __0__A14 ;

struct __mptr __0__A15 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A14 .d= 0 ), ( (__0__A14 .i= -1), (__0__A14 .f= (((int (*)(void
))__gldo_bgnsurface__16NurbsTess0 )))) ) , __0__A14 ) , ((void *)__1o_surface ), ( ( (__0__A15 .d= 0 ), ( (__0__A15 .i= -1),
(__0__A15 .f= (((int (*)(void ))__gldo_freebgnsurface__16Nurbs0 )))) ) , __0__A15 ) ) ;
} 
}
else 
{ __1o_surface -> save__9O_surface = 0 ;

__gldo_bgnsurface__16NurbsTess0 ( __0this , __1o_surface ) ;

}
;

}


void __gldo_bgncurve__16NurbsTessel0 (struct NurbsTessellator *, struct O_curve *);

void __gldo_freebgncurve__16NurbsTe0 (struct NurbsTessellator *, struct O_curve *);


void __glbgncurve__16NurbsTessellat0 (struct NurbsTessellator *__0this , long __1nuid )
{ 
struct O_curve *__1o_curve ;

struct O_curve *__0__X19 ;

void *__1__Xbuffer00eohgaiaa ;

__1o_curve = ((__0__X19 = (struct O_curve *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
o_curvePool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
o_curvePool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> o_curvePool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
O_curve *)__0__X19 )-> next__7O_curve = 0 ), ( (((struct O_curve *)__0__X19 )-> used__7O_curve = 0 ), ( (((struct O_curve *)__0__X19 )-> owner__7O_curve = 0 ), (
(((struct O_curve *)__0__X19 )-> curve__7O_curve . o_pwlcurve = 0 ), ((((struct O_curve *)__0__X19 )))) ) ) ) :0 );
__1o_curve -> nuid__7O_curve = __1nuid ;
if (__0this -> dl__16NurbsTessellator ){ __1o_curve -> save__7O_curve = 1 ;

{ 
struct __mptr __0__A17 ;

struct __mptr __0__A18 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A17 .d= 0 ), ( (__0__A17 .i= -1), (__0__A17 .f= (((int (*)(void
))__gldo_bgncurve__16NurbsTessel0 )))) ) , __0__A17 ) , ((void *)__1o_curve ), ( ( (__0__A18 .d= 0 ), ( (__0__A18 .i= -1),
(__0__A18 .f= (((int (*)(void ))__gldo_freebgncurve__16NurbsTe0 )))) ) , __0__A18 ) ) ;
} 
}
else 
{ __1o_curve -> save__7O_curve = 0 ;

__gldo_bgncurve__16NurbsTessel0 ( __0this , __1o_curve ) ;

}
;

}

void __gldo_endcurve__16NurbsTessel0 (struct NurbsTessellator *);

void __glendcurve__16NurbsTessellat0 (struct NurbsTessellator *__0this )
{ 
if (__0this -> dl__16NurbsTessellator ){ { 
struct __mptr __0__A20 ;

struct __mptr __0__A21 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A20 .d= 0 ), ( (__0__A20 .i= -1), (__0__A20 .f= (((int (*)(void
))__gldo_endcurve__16NurbsTessel0 )))) ) , __0__A20 ) , (void *)0 , ( ( (__0__A21 .d= 0 ), ( (__0__A21 .i= 0 ),
(__0__A21 .f= 0 )) ) , __0__A21 ) ) ;
} 
}
else 
{ __gldo_endcurve__16NurbsTessel0 ( __0this ) ;

}
;

}

void __gldo_endsurface__16NurbsTess0 (struct NurbsTessellator *);

void __glendsurface__16NurbsTessell0 (struct NurbsTessellator *__0this )
{ 
if (__0this -> dl__16NurbsTessellator ){ { 
struct __mptr __0__A22 ;

struct __mptr __0__A23 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A22 .d= 0 ), ( (__0__A22 .i= -1), (__0__A22 .f= (((int (*)(void
))__gldo_endsurface__16NurbsTess0 )))) ) , __0__A22 ) , (void *)0 , ( ( (__0__A23 .d= 0 ), ( (__0__A23 .i= 0 ),
(__0__A23 .f= 0 )) ) , __0__A23 ) ) ;
} 
}
else 
{ __gldo_endsurface__16NurbsTess0 ( __0this ) ;

}
;

}


void __gldo_bgntrim__16NurbsTessell0 (struct NurbsTessellator *, struct O_trim *);

void __gldo_freebgntrim__16NurbsTes0 (struct NurbsTessellator *, struct O_trim *);


void __glbgntrim__16NurbsTessellato0 (struct NurbsTessellator *__0this )
{ 
struct O_trim *__1o_trim ;

struct O_trim *__0__X26 ;

void *__1__Xbuffer00eohgaiaa ;

__1o_trim = ((__0__X26 = (struct O_trim *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
o_trimPool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
o_trimPool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> o_trimPool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
O_trim *)__0__X26 )-> next__6O_trim = 0 ), ( (((struct O_trim *)__0__X26 )-> o_curve__6O_trim = 0 ), ((((struct O_trim *)__0__X26 )))) ) :0 );
if (__0this -> dl__16NurbsTessellator ){ __1o_trim -> save__6O_trim = 1 ;

{ 
struct __mptr __0__A24 ;

struct __mptr __0__A25 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A24 .d= 0 ), ( (__0__A24 .i= -1), (__0__A24 .f= (((int (*)(void
))__gldo_bgntrim__16NurbsTessell0 )))) ) , __0__A24 ) , ((void *)__1o_trim ), ( ( (__0__A25 .d= 0 ), ( (__0__A25 .i= -1),
(__0__A25 .f= (((int (*)(void ))__gldo_freebgntrim__16NurbsTes0 )))) ) , __0__A25 ) ) ;
} 
}
else 
{ __1o_trim -> save__6O_trim = 0 ;

__gldo_bgntrim__16NurbsTessell0 ( __0this , __1o_trim ) ;

}
;

}

void __gldo_endtrim__16NurbsTessell0 (struct NurbsTessellator *);

void __glendtrim__16NurbsTessellato0 (struct NurbsTessellator *__0this )
{ 
if (__0this -> dl__16NurbsTessellator ){ { 
struct __mptr __0__A27 ;

struct __mptr __0__A28 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A27 .d= 0 ), ( (__0__A27 .i= -1), (__0__A27 .f= (((int (*)(void
))__gldo_endtrim__16NurbsTessell0 )))) ) , __0__A27 ) , (void *)0 , ( ( (__0__A28 .d= 0 ), ( (__0__A28 .i= 0 ),
(__0__A28 .f= 0 )) ) , __0__A28 ) ) ;
} 
}
else 
{ __gldo_endtrim__16NurbsTessell0 ( __0this ) ;

}
;

}

struct TrimVertex *__glget__14TrimVertexPoolFi (struct TrimVertexPool *, int );

struct O_pwlcurve *__gl__ct__10O_pwlcurveFlT1PfT10 (struct O_pwlcurve *, long , long , float *, long , struct TrimVertex *);

void __gldo_pwlcurve__16NurbsTessel0 (struct NurbsTessellator *, struct O_pwlcurve *);

void __gldo_freepwlcurve__16NurbsTe0 (struct NurbsTessellator *, struct O_pwlcurve *);


void __glpwlcurve__16NurbsTessellat0 (struct NurbsTessellator *__0this , long __1count , float *__1array , long __1byte_stride , long __1type )
{ 
struct Mapdesc *__1mapdesc ;

__1mapdesc = __gllocate__7MaplistFl ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator ), __1type ) ;

if (__1mapdesc == 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 35 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

if ((__1type != 0x8 )&& (__1type != 0xd )){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 22 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}
if (__1count < 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 33 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}
if (__1byte_stride < 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 34 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

{ struct O_pwlcurve *__1o_pwlcurve ;

struct O_pwlcurve *__0__X31 ;

void *__1__Xbuffer00eohgaiaa ;

__1o_pwlcurve = ((__0__X31 = (struct O_pwlcurve *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
o_pwlcurvePool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
o_pwlcurvePool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> o_pwlcurvePool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?__gl__ct__10O_pwlcurveFlT1PfT10 ( (struct
O_pwlcurve *)__0__X31 , __1type , __1count , __1array , __1byte_stride , __glget__14TrimVertexPoolFi ( (struct TrimVertexPool *)(& __0this -> extTrimVertexPool__16NurbsTessellator ), ((int )__1count )) ) :0 );

if (__0this -> dl__16NurbsTessellator ){ __1o_pwlcurve -> save__10O_pwlcurve = 1 ;

{ 
struct __mptr __0__A29 ;

struct __mptr __0__A30 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A29 .d= 0 ), ( (__0__A29 .i= -1), (__0__A29 .f= (((int (*)(void
))__gldo_pwlcurve__16NurbsTessel0 )))) ) , __0__A29 ) , ((void *)__1o_pwlcurve ), ( ( (__0__A30 .d= 0 ), ( (__0__A30 .i= -1),
(__0__A30 .f= (((int (*)(void ))__gldo_freepwlcurve__16NurbsTe0 )))) ) , __0__A30 ) ) ;
} 
}
else 
{ __1o_pwlcurve -> save__10O_pwlcurve = 0 ;

__gldo_pwlcurve__16NurbsTessel0 ( __0this , __1o_pwlcurve ) ;

}
;
}

}

struct Knotvector *__gl__ct__10KnotvectorFv (struct Knotvector *);

void __glinit__10KnotvectorFlN21Pf (struct Knotvector *, long , long , long , float *);

int __gldo_check_knots__16NurbsTes0 (struct NurbsTessellator *, struct Knotvector *, char *);


struct Quilt *__gl__ct__5QuiltFP7Mapdesc (struct Quilt *, struct Mapdesc *);


void __gltoBezier__5QuiltFR10Knotve0 (struct Quilt *, struct Knotvector *, float *, long );

void __gldo_nurbscurve__16NurbsTess0 (struct NurbsTessellator *, struct O_nurbscurve *);

void __gldo_freenurbscurve__16Nurbs0 (struct NurbsTessellator *, struct O_nurbscurve *);

void __gl__dt__10KnotvectorFv (struct Knotvector *, int );


void __glnurbscurve__16NurbsTessell0 (struct NurbsTessellator *__0this , 
long __1nknots , 
float *__1knot , 
long __1byte_stride , 
float *__1ctlarray , 
long __1order , 
long
__1type )
{ 
struct Mapdesc *__1mapdesc ;

__1mapdesc = __gllocate__7MaplistFl ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator ), __1type ) ;

if (__1mapdesc == 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 35 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

if (__1ctlarray == 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 36 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

if (__1byte_stride < 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 34 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

{ struct Knotvector __1knots ;

__gl__ct__10KnotvectorFv ( (struct Knotvector *)(& __1knots )) ;

__glinit__10KnotvectorFlN21Pf ( (struct Knotvector *)(& __1knots ), __1nknots , __1byte_stride , __1order , __1knot ) ;
if (__gldo_check_knots__16NurbsTes0 ( __0this , & __1knots , (char *)"curve") ){ 
__gl__dt__10KnotvectorFv ( (struct
Knotvector *)(& __1knots ), 2) ;

return ;
} 
{ struct O_nurbscurve *__1o_nurbscurve ;

struct Quilt *__0__X34 ;

void *__1__Xbuffer00eohgaiaa ;

struct O_nurbscurve *__0__X35 ;

__1o_nurbscurve = ((__0__X35 = (struct O_nurbscurve *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
o_nurbscurvePool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
o_nurbscurvePool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> o_nurbscurvePool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
O_nurbscurve *)__0__X35 )-> type__12O_nurbscurve = __1type ), ( (((struct O_nurbscurve *)__0__X35 )-> owner__12O_nurbscurve = 0 ), ( (((struct O_nurbscurve *)__0__X35 )-> next__12O_nurbscurve = 0 ), (
(((struct O_nurbscurve *)__0__X35 )-> used__12O_nurbscurve = 0 ), ((((struct O_nurbscurve *)__0__X35 )))) ) ) ) :0 );
__1o_nurbscurve -> bezier_curves__12O_nurbscurve = ((__0__X34 = (struct Quilt *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this ->
quiltPool__16NurbsTessellator )))-> freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(&
__0this -> quiltPool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( (
((! ((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))) ,
0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(&
__0this -> quiltPool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct
Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?__gl__ct__5QuiltFP7Mapdesc (
(struct Quilt *)__0__X34 , __1mapdesc ) :0 );
__gltoBezier__5QuiltFR10Knotve0 ( (struct Quilt *)__1o_nurbscurve -> bezier_curves__12O_nurbscurve , (struct Knotvector *)(& __1knots ), __1ctlarray , (long )( ((struct Mapdesc *)__1mapdesc )-> ncoords__7Mapdesc ) )
;

if (__0this -> dl__16NurbsTessellator ){ __1o_nurbscurve -> save__12O_nurbscurve = 1 ;

{ 
struct __mptr __0__A32 ;

struct __mptr __0__A33 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A32 .d= 0 ), ( (__0__A32 .i= -1), (__0__A32 .f= (((int (*)(void
))__gldo_nurbscurve__16NurbsTess0 )))) ) , __0__A32 ) , ((void *)__1o_nurbscurve ), ( ( (__0__A33 .d= 0 ), ( (__0__A33 .i= -1),
(__0__A33 .f= (((int (*)(void ))__gldo_freenurbscurve__16Nurbs0 )))) ) , __0__A33 ) ) ;
} 
}
else 
{ __1o_nurbscurve -> save__12O_nurbscurve = 0 ;

__gldo_nurbscurve__16NurbsTess0 ( __0this , __1o_nurbscurve ) ;

}
;
}
__gl__dt__10KnotvectorFv ( (struct Knotvector *)(& __1knots ), 2) ;
}

}



void __gltoBezier__5QuiltFR10Knotve1 (struct Quilt *, struct Knotvector *, struct Knotvector *, float *, long );

void __gldo_nurbssurface__16NurbsTe0 (struct NurbsTessellator *, struct O_nurbssurface *);

void __gldo_freenurbssurface__16Nur0 (struct NurbsTessellator *, struct O_nurbssurface *);


void __glnurbssurface__16NurbsTesse0 (struct NurbsTessellator *__0this , 
long __1sknot_count , 
float *__1sknot , 
long __1tknot_count , 
float *__1tknot , 
long __1s_byte_stride , 
long
__1t_byte_stride , 
float *__1ctlarray , 
long __1sorder , 
long __1torder , 
long __1type )
{ 
struct Mapdesc *__1mapdesc ;

__1mapdesc = __gllocate__7MaplistFl ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator ), __1type ) ;

if (__1mapdesc == 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 35 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

if (__1s_byte_stride < 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 34 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

if (__1t_byte_stride < 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 34 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

{ struct Knotvector __1sknotvector ;

struct Knotvector __1tknotvector ;

__gl__ct__10KnotvectorFv ( (struct Knotvector *)(& __1sknotvector )) ;

__gl__ct__10KnotvectorFv ( (struct Knotvector *)(& __1tknotvector )) ;

__glinit__10KnotvectorFlN21Pf ( (struct Knotvector *)(& __1sknotvector ), __1sknot_count , __1s_byte_stride , __1sorder , __1sknot ) ;
if (__gldo_check_knots__16NurbsTes0 ( __0this , & __1sknotvector , (char *)"surface") ){ 
__gl__dt__10KnotvectorFv ( (struct
Knotvector *)(& __1tknotvector ), 2) ;

__gl__dt__10KnotvectorFv ( (struct Knotvector *)(& __1sknotvector ), 2) ;

return ;
} 
__glinit__10KnotvectorFlN21Pf ( (struct Knotvector *)(& __1tknotvector ), __1tknot_count , __1t_byte_stride , __1torder , __1tknot ) ;
if (__gldo_check_knots__16NurbsTes0 ( __0this , & __1tknotvector , (char *)"surface") ){ 
__gl__dt__10KnotvectorFv ( (struct
Knotvector *)(& __1tknotvector ), 2) ;

__gl__dt__10KnotvectorFv ( (struct Knotvector *)(& __1sknotvector ), 2) ;

return ;
} 
{ struct O_nurbssurface *__1o_nurbssurface ;

struct Quilt *__0__X38 ;

void *__1__Xbuffer00eohgaiaa ;

struct O_nurbssurface *__0__X39 ;

__1o_nurbssurface = ((__0__X39 = (struct O_nurbssurface *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
o_nurbssurfacePool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
o_nurbssurfacePool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> o_nurbssurfacePool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
O_nurbssurface *)__0__X39 )-> type__14O_nurbssurface = __1type ), ( (((struct O_nurbssurface *)__0__X39 )-> owner__14O_nurbssurface = 0 ), ( (((struct O_nurbssurface *)__0__X39 )-> next__14O_nurbssurface = 0 ), (
(((struct O_nurbssurface *)__0__X39 )-> used__14O_nurbssurface = 0 ), ((((struct O_nurbssurface *)__0__X39 )))) ) ) ) :0 );
__1o_nurbssurface -> bezier_patches__14O_nurbssurface = ((__0__X38 = (struct Quilt *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this ->
quiltPool__16NurbsTessellator )))-> freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(&
__0this -> quiltPool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( (
((! ((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))) ,
0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(&
__0this -> quiltPool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct
Pool *)(& __0this -> quiltPool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?__gl__ct__5QuiltFP7Mapdesc (
(struct Quilt *)__0__X38 , __1mapdesc ) :0 );

__gltoBezier__5QuiltFR10Knotve1 ( (struct Quilt *)__1o_nurbssurface -> bezier_patches__14O_nurbssurface , (struct Knotvector *)(& __1sknotvector ), (struct Knotvector *)(& __1tknotvector ), __1ctlarray , (long )( ((struct
Mapdesc *)__1mapdesc )-> ncoords__7Mapdesc ) ) ;
if (__0this -> dl__16NurbsTessellator ){ __1o_nurbssurface -> save__14O_nurbssurface = 1 ;

{ 
struct __mptr __0__A36 ;

struct __mptr __0__A37 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A36 .d= 0 ), ( (__0__A36 .i= -1), (__0__A36 .f= (((int (*)(void
))__gldo_nurbssurface__16NurbsTe0 )))) ) , __0__A36 ) , ((void *)__1o_nurbssurface ), ( ( (__0__A37 .d= 0 ), ( (__0__A37 .i= -1),
(__0__A37 .f= (((int (*)(void ))__gldo_freenurbssurface__16Nur0 )))) ) , __0__A37 ) ) ;
} 
}
else 
{ __1o_nurbssurface -> save__14O_nurbssurface = 0 ;

__gldo_nurbssurface__16NurbsTe0 ( __0this , __1o_nurbssurface ) ;

}
;
}
__gl__dt__10KnotvectorFv ( (struct Knotvector *)(& __1tknotvector ), 2) ;
__gl__dt__10KnotvectorFv ( (struct Knotvector *)(& __1sknotvector ), 2) ;
}

}

int __glisProperty__11RenderhintsF0 (struct Renderhints *, long );


void __gldo_setnurbsproperty__16Nur0 (struct NurbsTessellator *, struct Property *);

void __gldo_freenurbsproperty__16Nu0 (struct NurbsTessellator *, struct Property *);


void __glsetnurbsproperty__16NurbsT0 (struct NurbsTessellator *__0this , long __1tag , float __1value )
{ 
if (! __glisProperty__11RenderhintsF0 ( (struct Renderhints *)(& __0this -> renderhints__16NurbsTessellator ),
__1tag ) ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 26 ) ;
}
else 
{ 
struct Property *__2prop ;

struct Property *__0__X42 ;

void *__1__Xbuffer00eohgaiaa ;

__2prop = ((__0__X42 = (struct Property *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
propertyPool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
propertyPool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> propertyPool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Property *)__0__X42 )-> type__8Property = 0 ), ( (((struct Property *)__0__X42 )-> tag__8Property = __1tag ), ( (((struct Property *)__0__X42 )-> value__8Property = (((float )__1value ))),
((((struct Property *)__0__X42 )))) ) ) :0 );
if (__0this -> dl__16NurbsTessellator ){ __2prop -> save__8Property = 1 ;

{ 
struct __mptr __0__A40 ;

struct __mptr __0__A41 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A40 .d= 0 ), ( (__0__A40 .i= -1), (__0__A40 .f= (((int (*)(void
))__gldo_setnurbsproperty__16Nur0 )))) ) , __0__A40 ) , ((void *)__2prop ), ( ( (__0__A41 .d= 0 ), ( (__0__A41 .i= -1),
(__0__A41 .f= (((int (*)(void ))__gldo_freenurbsproperty__16Nu0 )))) ) , __0__A41 ) ) ;
} 
}
else 
{ __2prop -> save__8Property = 0 ;

__gldo_setnurbsproperty__16Nur0 ( __0this , __2prop ) ;

}
;

}
}

int __glisProperty__7MapdescFl (struct Mapdesc *, long );


void __gldo_setnurbsproperty2__16Nu0 (struct NurbsTessellator *, struct Property *);


void __glsetnurbsproperty__16NurbsT1 (struct NurbsTessellator *__0this , long __1type , long __1tag , float __1value )
{ 
struct Mapdesc *__1mapdesc ;

__1mapdesc = __gllocate__7MaplistFl ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator ), __1type ) ;

if (__1mapdesc == 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 35 ) ;
return ;
}

if (! __glisProperty__7MapdescFl ( (struct Mapdesc *)__1mapdesc , __1tag ) ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 26 ) ;
return ;
}

{ struct Property *__1prop ;

struct Property *__0__X45 ;

void *__1__Xbuffer00eohgaiaa ;

__1prop = ((__0__X45 = (struct Property *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
propertyPool__16NurbsTessellator )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
propertyPool__16NurbsTessellator )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> propertyPool__16NurbsTessellator )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Property *)__0__X45 )-> type__8Property = __1type ), ( (((struct Property *)__0__X45 )-> tag__8Property = __1tag ), ( (((struct Property *)__0__X45 )-> value__8Property = (((float )__1value ))),
((((struct Property *)__0__X45 )))) ) ) :0 );
if (__0this -> dl__16NurbsTessellator ){ __1prop -> save__8Property = 1 ;

{ 
struct __mptr __0__A43 ;

struct __mptr __0__A44 ;

__glappend__11DisplayListFM16N0 ( (struct DisplayList *)__0this -> dl__16NurbsTessellator , ( ( (__0__A43 .d= 0 ), ( (__0__A43 .i= -1), (__0__A43 .f= (((int (*)(void
))__gldo_setnurbsproperty2__16Nu0 )))) ) , __0__A43 ) , ((void *)__1prop ), ( ( (__0__A44 .d= 0 ), ( (__0__A44 .i= -1),
(__0__A44 .f= (((int (*)(void ))__gldo_freenurbsproperty__16Nu0 )))) ) , __0__A44 ) ) ;
} 
}
else 
{ __1prop -> save__8Property = 0 ;

__gldo_setnurbsproperty2__16Nu0 ( __0this , __1prop ) ;

}
;
}

}

REAL __glgetProperty__11Renderhints0 (struct Renderhints *, long );

void __glgetnurbsproperty__16NurbsT0 (struct NurbsTessellator *__0this , long __1tag , float *__1value )
{ 
if (__glisProperty__11RenderhintsF0 ( (struct Renderhints *)(& __0this -> renderhints__16NurbsTessellator ), __1tag )
){ 
((*__1value ))= __glgetProperty__11Renderhints0 ( (struct Renderhints *)(& __0this -> renderhints__16NurbsTessellator ), __1tag ) ;
}
else 
{ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 26 ) ;
}
}

REAL __glgetProperty__7MapdescFl (struct Mapdesc *, long );

void __glgetnurbsproperty__16NurbsT1 (struct NurbsTessellator *__0this , long __1type , long __1tag , float *__1value )
{ 
struct Mapdesc *__1mapdesc ;

__1mapdesc = __gllocate__7MaplistFl ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator ), __1type ) ;

if (__1mapdesc == 0 )
__gldo_nurbserror__16NurbsTess0 ( __0this , 35 ) ;

if (__glisProperty__7MapdescFl ( (struct Mapdesc *)__1mapdesc , __1tag ) ){ 
((*__1value ))= __glgetProperty__7MapdescFl ( (struct Mapdesc *)__1mapdesc , __1tag ) ;
}
else 
{ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 26 ) ;
}
}

void __glsetBboxsize__7MapdescFPf (struct Mapdesc *, float *);

void __glsetnurbsproperty__16NurbsT2 (struct NurbsTessellator *__0this , long __1type , long __1purpose , float *__1mat )
{ 
struct Mapdesc *__1mapdesc ;

__1mapdesc = __gllocate__7MaplistFl ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator ), __1type ) ;

if (__1mapdesc == 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 35 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
}
else 
if (__1purpose == 4 ){ 
__glsetBboxsize__7MapdescFPf ( (struct Mapdesc *)__1mapdesc , __1mat ) ;
}
else 
{ 
}
}




void __glsetnurbsproperty__16NurbsT3 (struct NurbsTessellator *__0this , long __1type , long __1purpose , float *__1mat , 
long __1rstride , long
__1cstride )
{ 
struct Mapdesc *__1mapdesc ;

__1mapdesc = __gllocate__7MaplistFl ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator ), __1type ) ;

if (__1mapdesc == 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 35 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
}
else 
if (__1purpose == 1 ){ 
( __glcopy__7MapdescSFPA5_flPfN20 ( (float (*)[5])((struct Mapdesc *)__1mapdesc )-> cmat__7Mapdesc , (long )((struct Mapdesc *)__1mapdesc )-> hcoords__7Mapdesc ,
__1mat , __1rstride , __1cstride ) ) ;
}
else 
if (__1purpose == 2 ){ 
( __glcopy__7MapdescSFPA5_flPfN20 ( (float (*)[5])((struct Mapdesc *)__1mapdesc )-> smat__7Mapdesc , (long )((struct Mapdesc *)__1mapdesc )-> hcoords__7Mapdesc ,
__1mat , __1rstride , __1cstride ) ) ;
}
else 
if (__1purpose == 3 ){ 
( __glcopy__7MapdescSFPA5_flPfN20 ( (float (*)[5])((struct Mapdesc *)__1mapdesc )-> bmat__7Mapdesc , (long )((struct Mapdesc *)__1mapdesc )-> hcoords__7Mapdesc ,
__1mat , __1rstride , __1cstride ) ) ;
}
else 
{ 
}
}

void __glinitialize__7MaplistFv (struct Maplist *);

void __glredefineMaps__16NurbsTesse0 (struct NurbsTessellator *__0this )
{ 
__glinitialize__7MaplistFv ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator )) ;
}

void __gldefine__7MaplistFliT2 (struct Maplist *, long , int , int );

void __gldefineMap__16NurbsTessella0 (struct NurbsTessellator *__0this , long __1type , long __1rational , long __1ncoords )
{ 
__gldefine__7MaplistFliT2 ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator ),
__1type , ((int )__1rational ), ((int )__1ncoords )) ;
}

void __gl__dt__11DisplayListFv (struct DisplayList *, int );

void __gldiscardRecording__16NurbsT0 (struct NurbsTessellator *__0this , void *__1_dl )
{ 
__gl__dt__11DisplayListFv ( (struct DisplayList *)(((struct DisplayList *)(((struct DisplayList *)__1_dl )))), 3) ;
}

struct DisplayList *__gl__ct__11DisplayListFP16Nur0 (struct DisplayList *, struct NurbsTessellator *);

void *__glbeginRecording__16NurbsTes0 (struct NurbsTessellator *__0this )
{ 
struct DisplayList *__0__X46 ;

__0this -> dl__16NurbsTessellator = __gl__ct__11DisplayListFP16Nur0 ( (struct DisplayList *)0 , (struct NurbsTessellator *)__0this ) ;
return (((void *)__0this -> dl__16NurbsTessellator ));
}

void __glendList__11DisplayListFv (struct DisplayList *);

void __glendRecording__16NurbsTesse0 (struct NurbsTessellator *__0this )
{ 
__glendList__11DisplayListFv ( (struct DisplayList *)__0this -> dl__16NurbsTessellator ) ;
__0this -> dl__16NurbsTessellator = 0 ;
}

void __glbgnrender__16NurbsTessella0 (struct NurbsTessellator *);

void __glplay__11DisplayListFv (struct DisplayList *);

void __glendrender__16NurbsTessella0 (struct NurbsTessellator *);

void __glplayRecording__16NurbsTess0 (struct NurbsTessellator *__0this , void *__1_dl )
{ 
__0this -> playBack__16NurbsTessellator = 1 ;
((*(((void (*)(struct NurbsTessellator *))(__0this -> __vptr__16NurbsTessellator [1]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [1]).d))) ;
__glplay__11DisplayListFv ( (struct DisplayList *)(((struct DisplayList *)(((struct DisplayList *)__1_dl ))))) ;
((*(((void (*)(struct NurbsTessellator *))(__0this -> __vptr__16NurbsTessellator [2]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [2]).d))) ;
__0this -> playBack__16NurbsTessellator = 0 ;
}
extern struct __mptr __gl__vtbl__16NurbsTessellator[];
struct __mptr* __gl__ptbl_vec_____core_nurbsi0[] = {
__gl__vtbl__16NurbsTessellator,

};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\patch.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <math.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/patch.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);















typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;




struct Quilt;

struct Mapdesc;

struct Pspec;

struct Pspec {	
REAL range__5Pspec [3];
REAL sidestep__5Pspec [2];
REAL stepsize__5Pspec ;
REAL minstepsize__5Pspec ;
int needsSubdivision__5Pspec ;
};
struct Patchspec;

struct Patchspec {	

REAL range__5Pspec [3];
REAL sidestep__5Pspec [2];
REAL stepsize__5Pspec ;
REAL minstepsize__5Pspec ;
int needsSubdivision__5Pspec ;

int order__9Patchspec ;
int stride__9Patchspec ;
};
struct Patch;

struct Patch {	

struct Mapdesc *mapdesc__5Patch ;
struct Patch *next__5Patch ;
int cullval__5Patch ;
int notInBbox__5Patch ;
int needsSampling__5Patch ;
REAL cpts__5Patch [2880];
REAL spts__5Patch [2880];
REAL bpts__5Patch [2880];
struct Patchspec pspec__5Patch [2];

REAL bb__5Patch [2][5];
};





struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};








typedef REAL Maxmatrix [5][5];
struct Backend;



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};


void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);









struct Backend;


struct Flist;

struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;





void __glselect__5QuiltFPfT1 (struct Quilt *, REAL *, REAL *);

void __glxformSampling__7MapdescFPf1 (struct Mapdesc *, REAL *, int , int , int , int , REAL *, int
, int );

void __glxformCulling__7MapdescFPfi1 (struct Mapdesc *, REAL *, int , int , int , int , REAL *, int
, int );

void __glxformBounding__7MapdescFPf1 (struct Mapdesc *, REAL *, int , int , int , int , REAL *, int
, int );

struct Patch *__gl__ct__5PatchFR5PatchifP5Pa0 (struct Patch *, struct Patch *, int , REAL , struct Patch *);

void __glcheckBboxConstraint__5Patc0 (struct Patch *);
extern struct __mptr* __ptbl_vec_____core_patch_c_____ct_[];


struct Patch *__gl__ct__5PatchFP5QuiltPfT2P50 (struct Patch *__0this , Quilt_ptr __1geo , REAL *__1pta , REAL *__1ptb , struct Patch *__1n )
{ 
struct Mapdesc *__0__X5 ;

void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Patch *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Patch))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> mapdesc__5Patch = __1geo -> mapdesc__5Quilt ;
__0this -> cullval__5Patch = (( ((((struct Mapdesc *)__0this -> mapdesc__5Patch )-> culling_method__7Mapdesc != 0.0 )?1 :0 )) ?2 :1 );
__0this -> notInBbox__5Patch = (( ((((struct Mapdesc *)__0this -> mapdesc__5Patch )-> bbox_subdividing__7Mapdesc != 0.0 )?1 :0 )) ?1 :0 );
__0this -> needsSampling__5Patch = (( (__0__X5 = (struct Mapdesc *)__0this -> mapdesc__5Patch ), ( ((( ((__0__X5 -> sampling_method__7Mapdesc == 5.0 )?1 :0 )) || (
((__0__X5 -> sampling_method__7Mapdesc == 6.0 )?1 :0 )) )|| ( ((__0__X5 -> sampling_method__7Mapdesc == 7.0 )?1 :0 )) )) ) ?1 :0 );
(__0this -> pspec__5Patch [0 ]). order__9Patchspec = (__1geo -> qspec__5Quilt [0 ]). order__9Quiltspec ;
(__0this -> pspec__5Patch [1 ]). order__9Patchspec = (__1geo -> qspec__5Quilt [1 ]). order__9Quiltspec ;
(__0this -> pspec__5Patch [0 ]). stride__9Patchspec = ((__0this -> pspec__5Patch [1 ]). order__9Patchspec * 5 );
(__0this -> pspec__5Patch [1 ]). stride__9Patchspec = 5 ;

{ REAL *__1ps ;

__1ps = __1geo -> cpts__5Quilt ;
__glselect__5QuiltFPfT1 ( (struct Quilt *)__1geo , __1pta , __1ptb ) ;
__1ps += (__1geo -> qspec__5Quilt [0 ]). offset__9Quiltspec ;
__1ps += (__1geo -> qspec__5Quilt [1 ]). offset__9Quiltspec ;
__1ps += (((__1geo -> qspec__5Quilt [0 ]). index__9Quiltspec * (__1geo -> qspec__5Quilt [0 ]). order__9Quiltspec )* (__1geo -> qspec__5Quilt [0 ]). stride__9Quiltspec );
__1ps += (((__1geo -> qspec__5Quilt [1 ]). index__9Quiltspec * (__1geo -> qspec__5Quilt [1 ]). order__9Quiltspec )* (__1geo -> qspec__5Quilt [1 ]). stride__9Quiltspec );

if (__0this -> needsSampling__5Patch ){ 
__glxformSampling__7MapdescFPf1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , __1ps , (__1geo -> qspec__5Quilt [0 ]). order__9Quiltspec , (__1geo -> qspec__5Quilt [0 ]). stride__9Quiltspec ,
(__1geo -> qspec__5Quilt [1 ]). order__9Quiltspec , (__1geo -> qspec__5Quilt [1 ]). stride__9Quiltspec , (float *)__0this -> spts__5Patch , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec , (__0this -> pspec__5Patch [1 ]).
stride__9Patchspec ) ;
}

if (__0this -> cullval__5Patch == 2 ){ 
__glxformCulling__7MapdescFPfi1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , __1ps , (__1geo -> qspec__5Quilt [0 ]). order__9Quiltspec , (__1geo -> qspec__5Quilt [0 ]).
stride__9Quiltspec , (__1geo -> qspec__5Quilt [1 ]). order__9Quiltspec , (__1geo -> qspec__5Quilt [1 ]). stride__9Quiltspec , (float *)__0this -> cpts__5Patch , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec , (__0this ->
pspec__5Patch [1 ]). stride__9Patchspec ) ;
}

if (__0this -> notInBbox__5Patch ){ 
__glxformBounding__7MapdescFPf1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , __1ps , (__1geo -> qspec__5Quilt [0 ]). order__9Quiltspec , (__1geo -> qspec__5Quilt [0 ]). stride__9Quiltspec ,
(__1geo -> qspec__5Quilt [1 ]). order__9Quiltspec , (__1geo -> qspec__5Quilt [1 ]). stride__9Quiltspec , (float *)__0this -> bpts__5Patch , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec , (__0this -> pspec__5Patch [1 ]).
stride__9Patchspec ) ;
}

((__0this -> pspec__5Patch [0 ]). range__5Pspec [0 ])= ((__1geo -> qspec__5Quilt [0 ]). breakpoints__9Quiltspec [(__1geo -> qspec__5Quilt [0 ]). index__9Quiltspec ]);
((__0this -> pspec__5Patch [0 ]). range__5Pspec [1 ])= ((__1geo -> qspec__5Quilt [0 ]). breakpoints__9Quiltspec [((__1geo -> qspec__5Quilt [0 ]). index__9Quiltspec + 1 )]);
((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])= (((__0this -> pspec__5Patch [0 ]). range__5Pspec [1 ])- ((__0this -> pspec__5Patch [0 ]). range__5Pspec [0 ]));

((__0this -> pspec__5Patch [1 ]). range__5Pspec [0 ])= ((__1geo -> qspec__5Quilt [1 ]). breakpoints__9Quiltspec [(__1geo -> qspec__5Quilt [1 ]). index__9Quiltspec ]);
((__0this -> pspec__5Patch [1 ]). range__5Pspec [1 ])= ((__1geo -> qspec__5Quilt [1 ]). breakpoints__9Quiltspec [((__1geo -> qspec__5Quilt [1 ]). index__9Quiltspec + 1 )]);
((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ])= (((__0this -> pspec__5Patch [1 ]). range__5Pspec [1 ])- ((__0this -> pspec__5Patch [1 ]). range__5Pspec [0 ]));

if (((__0this -> pspec__5Patch [0 ]). range__5Pspec [0 ])!= (__1pta [0 ])){ 
((void )0 );
{ struct Patch __2lower ;

__gl__ct__5PatchFR5PatchifP5Pa0 ( (struct Patch *)(& __2lower ), (struct Patch *)__0this , 0 , __1pta [0 ], (struct Patch *)0 ) ;
((*__0this ))= __2lower ;

}
}

if (((__0this -> pspec__5Patch [0 ]). range__5Pspec [1 ])!= (__1ptb [0 ])){ 
((void )0 );
{ struct Patch __2upper ;

__gl__ct__5PatchFR5PatchifP5Pa0 ( (struct Patch *)(& __2upper ), (struct Patch *)__0this , 0 , __1ptb [0 ], (struct Patch *)0 ) ;

}
}

if (((__0this -> pspec__5Patch [1 ]). range__5Pspec [0 ])!= (__1pta [1 ])){ 
((void )0 );
{ struct Patch __2lower ;

__gl__ct__5PatchFR5PatchifP5Pa0 ( (struct Patch *)(& __2lower ), (struct Patch *)__0this , 1 , __1pta [1 ], (struct Patch *)0 ) ;
((*__0this ))= __2lower ;

}
}

if (((__0this -> pspec__5Patch [1 ]). range__5Pspec [1 ])!= (__1ptb [1 ])){ 
((void )0 );
{ struct Patch __2upper ;

__gl__ct__5PatchFR5PatchifP5Pa0 ( (struct Patch *)(& __2upper ), (struct Patch *)__0this , 1 , __1ptb [1 ], (struct Patch *)0 ) ;

}
}
__glcheckBboxConstraint__5Patc0 ( __0this ) ;
__0this -> next__5Patch = __1n ;

}
} return __0this ;

}

void __glsubdivide__7MapdescFPfT1fi1 (struct Mapdesc *, REAL *, REAL *, REAL , int , int , int , int );


// extern void *memcpy (void *, void *, size_t );


struct Patch *__gl__ct__5PatchFR5PatchifP5Pa0 (struct Patch *__0this , struct Patch *__1upper , int __1param , REAL __1value , struct Patch *__1n )
{ 
struct Patch *__1lower ;

void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Patch *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Patch))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__1lower = (struct Patch *)__0this ;

((*__1lower )). cullval__5Patch = ((*__1upper )). cullval__5Patch ;
((*__1lower )). mapdesc__5Patch = ((*__1upper )). mapdesc__5Patch ;
((*__1lower )). notInBbox__5Patch = ((*__1upper )). notInBbox__5Patch ;
((*__1lower )). needsSampling__5Patch = ((*__1upper )). needsSampling__5Patch ;
(((*__1lower )). pspec__5Patch [0 ]). order__9Patchspec = (((*__1upper )). pspec__5Patch [0 ]). order__9Patchspec ;
(((*__1lower )). pspec__5Patch [1 ]). order__9Patchspec = (((*__1upper )). pspec__5Patch [1 ]). order__9Patchspec ;
(((*__1lower )). pspec__5Patch [0 ]). stride__9Patchspec = (((*__1upper )). pspec__5Patch [0 ]). stride__9Patchspec ;
(((*__1lower )). pspec__5Patch [1 ]). stride__9Patchspec = (((*__1upper )). pspec__5Patch [1 ]). stride__9Patchspec ;
((*__1lower )). next__5Patch = __1n ;

switch (__1param ){ 
case 0 :{ 
REAL __3d ;

__3d = ((__1value - ((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [0 ]))/ ((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [2 ]));
if (__0this -> needsSampling__5Patch )
__glsubdivide__7MapdescFPfT1fi1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)((*__1upper )). spts__5Patch , (float *)((*__1lower )). spts__5Patch , __3d , (__0this ->
pspec__5Patch [1 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). stride__9Patchspec , (__0this -> pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec ) ;

if (__0this -> cullval__5Patch == 2 )
__glsubdivide__7MapdescFPfT1fi1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)((*__1upper )). cpts__5Patch , (float *)((*__1lower )). cpts__5Patch , __3d ,
(__0this -> pspec__5Patch [1 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). stride__9Patchspec , (__0this -> pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec ) ;

if (__0this -> notInBbox__5Patch )
__glsubdivide__7MapdescFPfT1fi1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)((*__1upper )). bpts__5Patch , (float *)((*__1lower )). bpts__5Patch , __3d , (__0this ->
pspec__5Patch [1 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). stride__9Patchspec , (__0this -> pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec ) ;

((((*__1lower )). pspec__5Patch [0 ]). range__5Pspec [0 ])= ((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [0 ]);
((((*__1lower )). pspec__5Patch [0 ]). range__5Pspec [1 ])= __1value ;
((((*__1lower )). pspec__5Patch [0 ]). range__5Pspec [2 ])= (__1value - ((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [0 ]));
((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [0 ])= __1value ;
((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [2 ])= (((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [1 ])- __1value );

((((*__1lower )). pspec__5Patch [1 ]). range__5Pspec [0 ])= ((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [0 ]);
((((*__1lower )). pspec__5Patch [1 ]). range__5Pspec [1 ])= ((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [1 ]);
((((*__1lower )). pspec__5Patch [1 ]). range__5Pspec [2 ])= ((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [2 ]);
break ;
}
case 1 :{ 
REAL __3d ;

__3d = ((__1value - ((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [0 ]))/ ((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [2 ]));
if (__0this -> needsSampling__5Patch )
__glsubdivide__7MapdescFPfT1fi1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)((*__1upper )). spts__5Patch , (float *)((*__1lower )). spts__5Patch , __3d , (__0this ->
pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). stride__9Patchspec ) ;
if (__0this -> cullval__5Patch == 2 )
__glsubdivide__7MapdescFPfT1fi1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)((*__1upper )). cpts__5Patch , (float *)((*__1lower )). cpts__5Patch , __3d ,
(__0this -> pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). stride__9Patchspec ) ;
if (__0this -> notInBbox__5Patch )
__glsubdivide__7MapdescFPfT1fi1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)((*__1upper )). bpts__5Patch , (float *)((*__1lower )). bpts__5Patch , __3d , (__0this ->
pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). stride__9Patchspec ) ;
((((*__1lower )). pspec__5Patch [0 ]). range__5Pspec [0 ])= ((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [0 ]);
((((*__1lower )). pspec__5Patch [0 ]). range__5Pspec [1 ])= ((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [1 ]);
((((*__1lower )). pspec__5Patch [0 ]). range__5Pspec [2 ])= ((((*__1upper )). pspec__5Patch [0 ]). range__5Pspec [2 ]);

((((*__1lower )). pspec__5Patch [1 ]). range__5Pspec [0 ])= ((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [0 ]);
((((*__1lower )). pspec__5Patch [1 ]). range__5Pspec [1 ])= __1value ;
((((*__1lower )). pspec__5Patch [1 ]). range__5Pspec [2 ])= (__1value - ((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [0 ]));
((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [0 ])= __1value ;
((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [2 ])= (((((*__1upper )). pspec__5Patch [1 ]). range__5Pspec [1 ])- __1value );
break ;
}
}

if (( ((((struct Mapdesc *)__0this -> mapdesc__5Patch )-> bbox_subdividing__7Mapdesc != 0.0 )?1 :0 )) && (! __0this -> notInBbox__5Patch ))
memcpy ( (void *)((*__1lower )). bb__5Patch ,
(void *)((*__1upper )). bb__5Patch , sizeof __0this -> bb__5Patch ) ;

__glcheckBboxConstraint__5Patc0 ( (struct Patch *)__1lower ) ;
__glcheckBboxConstraint__5Patc0 ( (struct Patch *)__1upper ) ;
} return __0this ;

}

void __glclamp__9PatchspecFf (struct Patchspec *, REAL );

void __glclamp__5PatchFv (struct Patch *__0this )
{ 
if (__0this -> mapdesc__5Patch -> clampfactor__7Mapdesc != 0.0 ){ 
__glclamp__9PatchspecFf ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ])), __0this ->
mapdesc__5Patch -> clampfactor__7Mapdesc ) ;
__glclamp__9PatchspecFf ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ])), __0this -> mapdesc__5Patch -> clampfactor__7Mapdesc ) ;
}
}

void __glclamp__9PatchspecFf (struct Patchspec *__0this , REAL __1clampfactor )
{ 
if ((__0this -> sidestep__5Pspec [0 ])< __0this -> minstepsize__5Pspec )
(__0this -> sidestep__5Pspec [0 ])= (__1clampfactor * __0this -> minstepsize__5Pspec );
if ((__0this -> sidestep__5Pspec [1 ])< __0this -> minstepsize__5Pspec )
(__0this -> sidestep__5Pspec [1 ])= (__1clampfactor * __0this -> minstepsize__5Pspec );
if (__0this -> stepsize__5Pspec < __0this -> minstepsize__5Pspec )
__0this -> stepsize__5Pspec = (__1clampfactor * __0this -> minstepsize__5Pspec );
}

int __glbboxTooBig__7MapdescFPfiN30 (struct Mapdesc *, REAL *, int , int , int , int , REAL (*)[5]);

void __glcheckBboxConstraint__5Patc0 (struct Patch *__0this )
{ 
if (__0this -> notInBbox__5Patch && (__glbboxTooBig__7MapdescFPfiN30 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)__0this -> bpts__5Patch , (__0this ->
pspec__5Patch [0 ]). stride__9Patchspec , (__0this -> pspec__5Patch [1 ]). stride__9Patchspec , (__0this -> pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , (float (*)[5])__0this -> bb__5Patch )
!= 1 ))
{ 
__0this -> notInBbox__5Patch = 0 ;
}
}


void __glsurfbbox__7MapdescFPA5_f (struct Mapdesc *, REAL (*)[5]);

void __glbbox__5PatchFv (struct Patch *__0this )
{ 
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Patch )-> bbox_subdividing__7Mapdesc != 0.0 )?1 :0 )) )
__glsurfbbox__7MapdescFPA5_f ( (struct Mapdesc *)__0this -> mapdesc__5Patch ,
(float (*)[5])__0this -> bb__5Patch ) ;
}


void __glgetstepsize__9PatchspecFf (struct Patchspec *, REAL );


void __glsingleStep__9PatchspecFv (struct Patchspec *);

int __glproject__7MapdescFPfiT2T1N0 (struct Mapdesc *, REAL *, int , int , REAL *, int , int , int
, int );

REAL __glgetProperty__7MapdescFl (struct Mapdesc *, long );


REAL __glcalcPartialVelocity__7Mapd1 (struct Mapdesc *, REAL *, REAL *, int , int , int , int , int ,
int , REAL , REAL , int );

// extern double sqrt (double );



int __glneedsSamplingSubdivision__2 (struct Patch *);

void __glgetstepsize__5PatchFv (struct Patch *__0this )
{ 
(__0this -> pspec__5Patch [0 ]). needsSubdivision__5Pspec = ((__0this -> pspec__5Patch [1 ]). needsSubdivision__5Pspec = 0 );

if (( ((((struct Mapdesc *)__0this -> mapdesc__5Patch )-> sampling_method__7Mapdesc == 3.0 )?1 :0 )) ){ 
__glgetstepsize__9PatchspecFf ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ])), __0this ->
mapdesc__5Patch -> maxsrate__7Mapdesc ) ;
__glgetstepsize__9PatchspecFf ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ])), __0this -> mapdesc__5Patch -> maxtrate__7Mapdesc ) ;

}
else 
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Patch )-> sampling_method__7Mapdesc == 2.0 )?1 :0 )) ){ 
__glgetstepsize__9PatchspecFf ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ])),
__0this -> mapdesc__5Patch -> maxsrate__7Mapdesc * ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])) ;
__glgetstepsize__9PatchspecFf ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ])), __0this -> mapdesc__5Patch -> maxtrate__7Mapdesc * ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ])) ;

}
else 
if (! __0this -> needsSampling__5Patch ){ 
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ]))) ;
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ]))) ;
}
else 
{ 
REAL __2tmp [24][24][5];


((void )0 );

{ int __2val ;

__2val = __glproject__7MapdescFPfiT2T1N0 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)__0this -> spts__5Patch , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec , (__0this -> pspec__5Patch [1 ]). stride__9Patchspec ,
& (((__2tmp [0 ])[0 ])[0 ]), (int )120, (int )5, (__0this -> pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec ) ;

if (__2val == 0 ){ 
__glgetstepsize__9PatchspecFf ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ])), __0this -> mapdesc__5Patch -> maxsrate__7Mapdesc ) ;
__glgetstepsize__9PatchspecFf ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ])), __0this -> mapdesc__5Patch -> maxtrate__7Mapdesc ) ;
}
else 
{ 
REAL __3t ;

__3t = __glgetProperty__7MapdescFl ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (long )1 ) ;

(__0this -> pspec__5Patch [0 ]). minstepsize__5Pspec = ((__0this -> mapdesc__5Patch -> maxsrate__7Mapdesc > 0.0 )?(((double )(((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])/ __0this -> mapdesc__5Patch -> maxsrate__7Mapdesc ))):0.0 );

(__0this -> pspec__5Patch [1 ]). minstepsize__5Pspec = ((__0this -> mapdesc__5Patch -> maxtrate__7Mapdesc > 0.0 )?(((double )(((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ])/ __0this -> mapdesc__5Patch -> maxtrate__7Mapdesc ))):0.0 );
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Patch )-> sampling_method__7Mapdesc == 5.0 )?1 :0 )) ){ 
REAL __4ssv [2];

REAL __4ttv [2];
REAL __4ss ;
REAL __4st ;
REAL __4tt ;

__4ss = __glcalcPartialVelocity__7Mapd1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)__4ssv , & (((__2tmp [0 ])[0 ])[0 ]), (int )120, (int )5, (__0this ->
pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , 2 , 0 , (__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ], (__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ], 0 )
;
__4st = __glcalcPartialVelocity__7Mapd1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)0 , & (((__2tmp [0 ])[0 ])[0 ]), (int )120, (int )5, (__0this ->
pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , 1 , 1 , (__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ], (__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ], -1)
;
__4tt = __glcalcPartialVelocity__7Mapd1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)__4ttv , & (((__2tmp [0 ])[0 ])[0 ]), (int )120, (int )5, (__0this ->
pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , 0 , 2 , (__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ], (__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ], 1 )
;

if ((__4ss != 0.0 )&& (__4tt != 0.0 )){ 
REAL __5ttq ;
REAL __5ssq ;
REAL __5ds ;
REAL __5dt ;

__5ttq = sqrt ( (double )(((float )__4ss ))) ;
__5ssq = sqrt ( (double )(((float )__4tt ))) ;
__5ds = sqrt ( (double )(((4 * __3t )* __5ttq )/ ((__4ss * __5ttq )+ (__4st * __5ssq )))) ;
__5dt = sqrt ( (double )(((4 * __3t )* __5ssq )/ ((__4tt * __5ssq )+ (__4st * __5ttq )))) ;
(__0this -> pspec__5Patch [0 ]). stepsize__5Pspec = ((__5ds < ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))?__5ds :((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));
{ REAL __5scutoff ;

__5scutoff = ((2.0 * __3t )/ (((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])* ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [0 ])= (((__4ssv [0 ])> __5scutoff )?sqrt ( (2.0 * __3t )/ (__4ssv [0 ])) :(((double )((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [1 ])= (((__4ssv [1 ])> __5scutoff )?sqrt ( (2.0 * __3t )/ (__4ssv [1 ])) :(((double )((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))));

(__0this -> pspec__5Patch [1 ]). stepsize__5Pspec = ((__5dt < ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))?__5dt :((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
{ REAL __5tcutoff ;

__5tcutoff = ((2.0 * __3t )/ (((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ])* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ])));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [0 ])= (((__4ttv [0 ])> __5tcutoff )?sqrt ( (2.0 * __3t )/ (__4ttv [0 ])) :(((double )((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [1 ])= (((__4ttv [1 ])> __5tcutoff )?sqrt ( (2.0 * __3t )/ (__4ttv [1 ])) :(((double )((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))));

}

}
}
else 
if (__4ss != 0.0 ){ 
REAL __5x ;
REAL __5ds ;

__5x = (((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ])* __4st );
__5ds = ((sqrt ( (__5x * __5x )+ ((8.0 * __3t )* __4ss )) - __5x )/ __4ss );
(__0this -> pspec__5Patch [0 ]). stepsize__5Pspec = ((__5ds < ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))?__5ds :((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));
{ REAL __5scutoff ;

__5scutoff = ((2.0 * __3t )/ (((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])* ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [0 ])= (((__4ssv [0 ])> __5scutoff )?sqrt ( (2.0 * __3t )/ (__4ssv [0 ])) :(((double )((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [1 ])= (((__4ssv [1 ])> __5scutoff )?sqrt ( (2.0 * __3t )/ (__4ssv [1 ])) :(((double )((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))));
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ]))) ;

}
}
else 
if (__4tt != 0.0 ){ 
REAL __5x ;
REAL __5dt ;

__5x = (((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])* __4st );
__5dt = ((sqrt ( (__5x * __5x )+ ((8.0 * __3t )* __4tt )) - __5x )/ __4tt );
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ]))) ;
{ REAL __5tcutoff ;

__5tcutoff = ((2.0 * __3t )/ (((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ])* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ])));
(__0this -> pspec__5Patch [1 ]). stepsize__5Pspec = ((__5dt < ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))?__5dt :((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [0 ])= (((__4ttv [0 ])> __5tcutoff )?sqrt ( (2.0 * __3t )/ (__4ttv [0 ])) :(((double )((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [1 ])= (((__4ttv [1 ])> __5tcutoff )?sqrt ( (2.0 * __3t )/ (__4ttv [1 ])) :(((double )((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))));

}
}
else 
{ 
if ((4.0 * __3t )> ((__4st * ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))){ 
__glsingleStep__9PatchspecFv ( (struct
Patchspec *)(& (__0this -> pspec__5Patch [0 ]))) ;
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ]))) ;
}
else 
{ 
REAL __6area ;
REAL __6ds ;
REAL __6dt ;

__6area = ((4.0 * __3t )/ __4st );
__6ds = sqrt ( (double )((__6area * ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))/ ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))) ;
__6dt = sqrt ( (double )((__6area * ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))/ ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))) ;
(__0this -> pspec__5Patch [0 ]). stepsize__5Pspec = ((__6ds < ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))?__6ds :((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [0 ])= ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]);
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [1 ])= ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]);

(__0this -> pspec__5Patch [1 ]). stepsize__5Pspec = ((__6dt < ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))?__6dt :((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [0 ])= ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]);
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [1 ])= ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]);
}
}
}
else 
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Patch )-> sampling_method__7Mapdesc == 6.0 )?1 :0 )) ){ 
REAL __4msv [2];

REAL __4mtv [2];
REAL __4ms ;
REAL __4mt ;

__4ms = __glcalcPartialVelocity__7Mapd1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)__4msv , & (((__2tmp [0 ])[0 ])[0 ]), (int )120, (int )5, (__0this ->
pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , 1 , 0 , (__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ], (__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ], 0 )
;
__4mt = __glcalcPartialVelocity__7Mapd1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)__4mtv , & (((__2tmp [0 ])[0 ])[0 ]), (int )120, (int )5, (__0this ->
pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , 0 , 1 , (__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ], (__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ], 1 )
;
if (__4ms != 0.0 ){ 
if (__4mt != 0.0 ){ 
REAL __6d ;
REAL __6ds ;
REAL __6dt ;

__6d = (__3t / ((__4ms * __4ms )+ (__4mt * __4mt )));
__6ds = (__4mt * __6d );
__6dt = (__4ms * __6d );
(__0this -> pspec__5Patch [0 ]). stepsize__5Pspec = ((__6ds < ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))?__6ds :((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [0 ])= ((((__4msv [0 ])* ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4msv [0 ])):((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [1 ])= ((((__4msv [1 ])* ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4msv [1 ])):((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));

(__0this -> pspec__5Patch [1 ]). stepsize__5Pspec = ((__6dt < ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))?__6dt :((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [0 ])= ((((__4mtv [0 ])* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4mtv [0 ])):((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [1 ])= ((((__4mtv [1 ])* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4mtv [1 ])):((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
}
else 
{ 
(__0this -> pspec__5Patch [0 ]). stepsize__5Pspec = ((__3t < (__4ms * ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])))?(__3t / __4ms ):((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [0 ])= ((((__4msv [0 ])* ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4msv [0 ])):((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [1 ])= ((((__4msv [1 ])* ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4msv [1 ])):((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));

__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ]))) ;
}
}
else 
{ 
if (__4mt != 0.0 ){ 
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ]))) ;

(__0this -> pspec__5Patch [1 ]). stepsize__5Pspec = ((__3t < (__4mt * ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ])))?(__3t / __4mt ):((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [0 ])= ((((__4mtv [0 ])* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4mtv [0 ])):((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [1 ])= ((((__4mtv [1 ])* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4mtv [1 ])):((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
}
else 
{ 
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ]))) ;
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ]))) ;
}
}
}
else 
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Patch )-> sampling_method__7Mapdesc == 7.0 )?1 :0 )) ){ 
REAL __4msv [2];

REAL __4mtv [2];
REAL __4ms ;
REAL __4mt ;

__4ms = __glcalcPartialVelocity__7Mapd1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)__4msv , & (((__2tmp [0 ])[0 ])[0 ]), (int )120, (int )5, (__0this ->
pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , 1 , 0 , (__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ], (__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ], 0 )
;
__4mt = __glcalcPartialVelocity__7Mapd1 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)__4mtv , & (((__2tmp [0 ])[0 ])[0 ]), (int )120, (int )5, (__0this ->
pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , 0 , 1 , (__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ], (__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ], 1 )
;
if ((__4ms != 0.0 )&& (__4mt != 0.0 )){ 
REAL __5d ;

__5d = (1.0 / (__4ms * __4mt ));
__3t *= 1.41421356237309504880 ;
{ REAL __5ds ;
REAL __5dt ;

__5ds = (__3t * sqrt ( (double )((__5d * ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))/ ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))) );
__5dt = (__3t * sqrt ( (double )((__5d * ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))/ ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))) );
(__0this -> pspec__5Patch [0 ]). stepsize__5Pspec = ((__5ds < ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))?__5ds :((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [0 ])= ((((__4msv [0 ])* ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4msv [0 ])):((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [1 ])= ((((__4msv [1 ])* ((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4msv [1 ])):((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ]));

(__0this -> pspec__5Patch [1 ]). stepsize__5Pspec = ((__5dt < ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))?__5dt :((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [0 ])= ((((__4mtv [0 ])* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4mtv [0 ])):((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [1 ])= ((((__4mtv [1 ])* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]))> __3t )?(__3t / (__4mtv [1 ])):((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));

}
}
else 
{ 
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ]))) ;
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ]))) ;
}
}
else 
{ 
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [0 ]))) ;
__glsingleStep__9PatchspecFv ( (struct Patchspec *)(& (__0this -> pspec__5Patch [1 ]))) ;
}
}

}
}

if (__0this -> mapdesc__5Patch -> minsavings__7Mapdesc != 0.0 ){ 
REAL __2savings ;

__2savings = (1. / ((__0this -> pspec__5Patch [0 ]). stepsize__5Pspec * (__0this -> pspec__5Patch [1 ]). stepsize__5Pspec ));

__2savings -= ((2. / (((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [0 ])+ ((__0this -> pspec__5Patch [0 ]). sidestep__5Pspec [1 ])))* (2. / (((__0this -> pspec__5Patch [1 ]). sidestep__5Pspec [0 ])+ ((__0this -> pspec__5Patch [1 ]).
sidestep__5Pspec [1 ]))));

__2savings *= (((__0this -> pspec__5Patch [0 ]). range__5Pspec [2 ])* ((__0this -> pspec__5Patch [1 ]). range__5Pspec [2 ]));
if (__2savings > __0this -> mapdesc__5Patch -> minsavings__7Mapdesc ){ 
(__0this -> pspec__5Patch [0 ]). needsSubdivision__5Pspec = ((__0this -> pspec__5Patch [1 ]). needsSubdivision__5Pspec = 1 );
}
}

if ((__0this -> pspec__5Patch [0 ]). stepsize__5Pspec < (__0this -> pspec__5Patch [0 ]). minstepsize__5Pspec )(__0this -> pspec__5Patch [0 ]). needsSubdivision__5Pspec = 1 ;
if ((__0this -> pspec__5Patch [1 ]). stepsize__5Pspec < (__0this -> pspec__5Patch [1 ]). minstepsize__5Pspec )(__0this -> pspec__5Patch [1 ]). needsSubdivision__5Pspec = 1 ;
__0this -> needsSampling__5Patch = (__0this -> needsSampling__5Patch ?__glneedsSamplingSubdivision__2 ( __0this ) :0 );
}

void __glsingleStep__9PatchspecFv (struct Patchspec *__0this )
{ 
__0this -> stepsize__5Pspec = ((__0this -> sidestep__5Pspec [0 ])= ((__0this -> sidestep__5Pspec [1 ])= (__0this -> range__5Pspec [2 ])));
}

void __glgetstepsize__9PatchspecFf (struct Patchspec *__0this , REAL __1max )
{ 
__0this -> stepsize__5Pspec = ((__1max >= 1.0 )?((__0this -> range__5Pspec [2 ])/ __1max ):(__0this -> range__5Pspec [2 ]));
(__0this -> sidestep__5Pspec [0 ])= ((__0this -> sidestep__5Pspec [1 ])= (__0this -> minstepsize__5Pspec = __0this -> stepsize__5Pspec ));
}

int __glneedsSamplingSubdivision__2 (struct Patch *__0this )
{ 
return (((__0this -> pspec__5Patch [0 ]). needsSubdivision__5Pspec || (__0this -> pspec__5Patch [1 ]). needsSubdivision__5Pspec )?1 :0 );
}

int __glneedsNonSamplingSubdivisio0 (struct Patch *__0this )
{ 
return __0this -> notInBbox__5Patch ;
}

int __glneedsSubdivision__5PatchFi (struct Patch *__0this , int __1param )
{ 
return (__0this -> pspec__5Patch [__1param ]). needsSubdivision__5Pspec ;
}

int __glcullCheck__7MapdescFPfiN32 (struct Mapdesc *, REAL *, int , int , int , int );

int __glcullCheck__5PatchFv (struct Patch *__0this )
{ 
if (__0this -> cullval__5Patch == 2 )
__0this -> cullval__5Patch = __glcullCheck__7MapdescFPfiN32 ( (struct Mapdesc *)__0this -> mapdesc__5Patch , (float *)__0this ->
cpts__5Patch , (__0this -> pspec__5Patch [0 ]). order__9Patchspec , (__0this -> pspec__5Patch [0 ]). stride__9Patchspec , (__0this -> pspec__5Patch [1 ]). order__9Patchspec , (__0this -> pspec__5Patch [1 ]). stride__9Patchspec ) ;

return __0this -> cullval__5Patch ;
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\patchlis.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/patchlist.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);











struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct Backend;

struct Mapdesc;

struct Flist;

struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;






struct Mapdesc;

struct Pspec;

struct Pspec {	
REAL range__5Pspec [3];
REAL sidestep__5Pspec [2];
REAL stepsize__5Pspec ;
REAL minstepsize__5Pspec ;
int needsSubdivision__5Pspec ;
};
struct Patchspec;

struct Patchspec {	

REAL range__5Pspec [3];
REAL sidestep__5Pspec [2];
REAL stepsize__5Pspec ;
REAL minstepsize__5Pspec ;
int needsSubdivision__5Pspec ;

int order__9Patchspec ;
int stride__9Patchspec ;
};
struct Patch;

struct Patch {	

struct Mapdesc *mapdesc__5Patch ;
struct Patch *next__5Patch ;
int cullval__5Patch ;
int notInBbox__5Patch ;
int needsSampling__5Patch ;
REAL cpts__5Patch [2880];
REAL spts__5Patch [2880];
REAL bpts__5Patch [2880];
struct Patchspec pspec__5Patch [2];

REAL bb__5Patch [2][5];
};


struct Patchlist;

struct Patchlist {	

struct Patch *patch__9Patchlist ;
int notInBbox__9Patchlist ;
int needsSampling__9Patchlist ;
struct Pspec pspec__9Patchlist [2];
};





struct Patch *__gl__ct__5PatchFP5QuiltPfT2P50 (struct Patch *, struct Quilt *, REAL *, REAL *, struct Patch *);
extern struct __mptr* __ptbl_vec_____core_patchlist_c_____ct_[];


struct Patchlist *__gl__ct__9PatchlistFP5QuiltPf0 (struct Patchlist *__0this , struct Quilt *__1quilts , REAL *__1pta , REAL *__1ptb )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Patchlist *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Patchlist))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> patch__9Patchlist = 0 ;
{ { struct Quilt *__1q ;

struct Patch *__0__X5 ;

__1q = __1quilts ;

for(;__1q ;__1q = __1q -> next__5Quilt ) 
__0this -> patch__9Patchlist = __gl__ct__5PatchFP5QuiltPfT2P50 ( (struct Patch *)0 , __1q , __1pta , __1ptb , __0this -> patch__9Patchlist ) ;

((__0this -> pspec__9Patchlist [0 ]). range__5Pspec [0 ])= (__1pta [0 ]);
((__0this -> pspec__9Patchlist [0 ]). range__5Pspec [1 ])= (__1ptb [0 ]);
((__0this -> pspec__9Patchlist [0 ]). range__5Pspec [2 ])= ((__1ptb [0 ])- (__1pta [0 ]));

((__0this -> pspec__9Patchlist [1 ]). range__5Pspec [0 ])= (__1pta [1 ]);
((__0this -> pspec__9Patchlist [1 ]). range__5Pspec [1 ])= (__1ptb [1 ]);
((__0this -> pspec__9Patchlist [1 ]). range__5Pspec [2 ])= ((__1ptb [1 ])- (__1pta [1 ]));

}

}
} return __0this ;

}

struct Patch *__gl__ct__5PatchFR5PatchifP5Pa0 (struct Patch *, struct Patch *, int , REAL , struct Patch *);


struct Patchlist *__gl__ct__9PatchlistFR9Patchli0 (struct Patchlist *__0this , struct Patchlist *__1upper , int __1param , REAL __1value )
{ 
struct Patchlist *__1lower ;

void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Patchlist *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Patchlist))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__1lower = (struct Patchlist *)__0this ;
__0this -> patch__9Patchlist = 0 ;
{ { struct Patch *__1p ;

struct Patch *__0__X6 ;

__1p = ((*__1upper )). patch__9Patchlist ;

for(;__1p ;__1p = __1p -> next__5Patch ) 
__0this -> patch__9Patchlist = __gl__ct__5PatchFR5PatchifP5Pa0 ( (struct Patch *)0 , (struct Patch *)__1p , __1param , __1value , __0this -> patch__9Patchlist )
;

if (__1param == 0 ){ 
((((*__1lower )). pspec__9Patchlist [0 ]). range__5Pspec [0 ])= ((((*__1upper )). pspec__9Patchlist [0 ]). range__5Pspec [0 ]);
((((*__1lower )). pspec__9Patchlist [0 ]). range__5Pspec [1 ])= __1value ;
((((*__1lower )). pspec__9Patchlist [0 ]). range__5Pspec [2 ])= (__1value - ((((*__1upper )). pspec__9Patchlist [0 ]). range__5Pspec [0 ]));
((((*__1upper )). pspec__9Patchlist [0 ]). range__5Pspec [0 ])= __1value ;
((((*__1upper )). pspec__9Patchlist [0 ]). range__5Pspec [2 ])= (((((*__1upper )). pspec__9Patchlist [0 ]). range__5Pspec [1 ])- __1value );
(((*__1lower )). pspec__9Patchlist [1 ])= ((*__1upper )). pspec__9Patchlist [1 ];
}
else 
{ 
(((*__1lower )). pspec__9Patchlist [0 ])= ((*__1upper )). pspec__9Patchlist [0 ];
((((*__1lower )). pspec__9Patchlist [1 ]). range__5Pspec [0 ])= ((((*__1upper )). pspec__9Patchlist [1 ]). range__5Pspec [0 ]);
((((*__1lower )). pspec__9Patchlist [1 ]). range__5Pspec [1 ])= __1value ;
((((*__1lower )). pspec__9Patchlist [1 ]). range__5Pspec [2 ])= (__1value - ((((*__1upper )). pspec__9Patchlist [1 ]). range__5Pspec [0 ]));
((((*__1upper )). pspec__9Patchlist [1 ]). range__5Pspec [0 ])= __1value ;
((((*__1upper )). pspec__9Patchlist [1 ]). range__5Pspec [2 ])= (((((*__1upper )). pspec__9Patchlist [1 ]). range__5Pspec [1 ])- __1value );
}

}

}
} return __0this ;

}


void __gl__dt__9PatchlistFv (struct Patchlist *__0this , 
int __0__free )
{ if (__0this ){ 
while (__0this -> patch__9Patchlist ){ 
struct Patch *__2p ;

__2p = __0this -> patch__9Patchlist ;
__0this -> patch__9Patchlist = __0this -> patch__9Patchlist -> next__5Patch ;
( (((void *)__2p )?( free ( ((void *)__2p )) , 0 ) :( 0 ) )) ;
}
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}

int __glcullCheck__5PatchFv (struct Patch *);

int __glcullCheck__9PatchlistFv (struct Patchlist *__0this )
{ 
{ { struct Patch *__1p ;

__1p = __0this -> patch__9Patchlist ;

for(;__1p ;__1p = __1p -> next__5Patch ) 
if (__glcullCheck__5PatchFv ( (struct Patch *)__1p ) == 0 )
return 0 ;
return 2 ;

}

}
}

void __glgetstepsize__5PatchFv (struct Patch *);

void __glclamp__5PatchFv (struct Patch *);

void __glgetstepsize__9PatchlistFv (struct Patchlist *__0this )
{ 
(__0this -> pspec__9Patchlist [0 ]). stepsize__5Pspec = ((__0this -> pspec__9Patchlist [0 ]). range__5Pspec [2 ]);
((__0this -> pspec__9Patchlist [0 ]). sidestep__5Pspec [0 ])= ((__0this -> pspec__9Patchlist [0 ]). range__5Pspec [2 ]);
((__0this -> pspec__9Patchlist [0 ]). sidestep__5Pspec [1 ])= ((__0this -> pspec__9Patchlist [0 ]). range__5Pspec [2 ]);

(__0this -> pspec__9Patchlist [1 ]). stepsize__5Pspec = ((__0this -> pspec__9Patchlist [1 ]). range__5Pspec [2 ]);
((__0this -> pspec__9Patchlist [1 ]). sidestep__5Pspec [0 ])= ((__0this -> pspec__9Patchlist [1 ]). range__5Pspec [2 ]);
((__0this -> pspec__9Patchlist [1 ]). sidestep__5Pspec [1 ])= ((__0this -> pspec__9Patchlist [1 ]). range__5Pspec [2 ]);

{ { struct Patch *__1p ;

__1p = __0this -> patch__9Patchlist ;

for(;__1p ;__1p = __1p -> next__5Patch ) { 
__glgetstepsize__5PatchFv ( (struct Patch *)__1p ) ;
__glclamp__5PatchFv ( (struct Patch *)__1p ) ;
(__0this -> pspec__9Patchlist [0 ]). stepsize__5Pspec = (((__1p -> pspec__5Patch [0 ]). stepsize__5Pspec < (__0this -> pspec__9Patchlist [0 ]). stepsize__5Pspec )?(__1p -> pspec__5Patch [0 ]). stepsize__5Pspec :(__0this -> pspec__9Patchlist [0 ]). stepsize__5Pspec );
((__0this -> pspec__9Patchlist [0 ]). sidestep__5Pspec [0 ])= ((((__1p -> pspec__5Patch [0 ]). sidestep__5Pspec [0 ])< ((__0this -> pspec__9Patchlist [0 ]). sidestep__5Pspec [0 ]))?((__1p -> pspec__5Patch [0 ]). sidestep__5Pspec [0 ]):((__0this -> pspec__9Patchlist [0 ]). sidestep__5Pspec [0 ]));
((__0this -> pspec__9Patchlist [0 ]). sidestep__5Pspec [1 ])= ((((__1p -> pspec__5Patch [0 ]). sidestep__5Pspec [1 ])< ((__0this -> pspec__9Patchlist [0 ]). sidestep__5Pspec [1 ]))?((__1p -> pspec__5Patch [0 ]). sidestep__5Pspec [1 ]):((__0this -> pspec__9Patchlist [0 ]). sidestep__5Pspec [1 ]));
(__0this -> pspec__9Patchlist [1 ]). stepsize__5Pspec = (((__1p -> pspec__5Patch [1 ]). stepsize__5Pspec < (__0this -> pspec__9Patchlist [1 ]). stepsize__5Pspec )?(__1p -> pspec__5Patch [1 ]). stepsize__5Pspec :(__0this -> pspec__9Patchlist [1 ]). stepsize__5Pspec );
((__0this -> pspec__9Patchlist [1 ]). sidestep__5Pspec [0 ])= ((((__1p -> pspec__5Patch [1 ]). sidestep__5Pspec [0 ])< ((__0this -> pspec__9Patchlist [1 ]). sidestep__5Pspec [0 ]))?((__1p -> pspec__5Patch [1 ]). sidestep__5Pspec [0 ]):((__0this -> pspec__9Patchlist [1 ]). sidestep__5Pspec [0 ]));
((__0this -> pspec__9Patchlist [1 ]). sidestep__5Pspec [1 ])= ((((__1p -> pspec__5Patch [1 ]). sidestep__5Pspec [1 ])< ((__0this -> pspec__9Patchlist [1 ]). sidestep__5Pspec [1 ]))?((__1p -> pspec__5Patch [1 ]). sidestep__5Pspec [1 ]):((__0this -> pspec__9Patchlist [1 ]). sidestep__5Pspec [1 ]));
}

}

}
}

void __glbbox__5PatchFv (struct Patch *);

void __glbbox__9PatchlistFv (struct Patchlist *__0this )
{ 
{ { struct Patch *__1p ;

__1p = __0this -> patch__9Patchlist ;

for(;__1p ;__1p = __1p -> next__5Patch ) 
__glbbox__5PatchFv ( (struct Patch *)__1p ) ;

}

}
}

int __glneedsNonSamplingSubdivisio0 (struct Patch *);

int __glneedsNonSamplingSubdivisio1 (struct Patchlist *__0this )
{ 
__0this -> notInBbox__9Patchlist = 0 ;
{ { struct Patch *__1p ;

__1p = __0this -> patch__9Patchlist ;

for(;__1p ;__1p = __1p -> next__5Patch ) 
__0this -> notInBbox__9Patchlist |= __glneedsNonSamplingSubdivisio0 ( (struct Patch *)__1p ) ;
return __0this -> notInBbox__9Patchlist ;

}

}
}

int __glneedsSamplingSubdivision__3 (struct Patchlist *__0this )
{ 
(__0this -> pspec__9Patchlist [0 ]). needsSubdivision__5Pspec = 0 ;
(__0this -> pspec__9Patchlist [1 ]). needsSubdivision__5Pspec = 0 ;

{ { struct Patch *__1p ;

__1p = __0this -> patch__9Patchlist ;

for(;__1p ;__1p = __1p -> next__5Patch ) { 
(__0this -> pspec__9Patchlist [0 ]). needsSubdivision__5Pspec |= (__1p -> pspec__5Patch [0 ]). needsSubdivision__5Pspec ;
(__0this -> pspec__9Patchlist [1 ]). needsSubdivision__5Pspec |= (__1p -> pspec__5Patch [0 ]). needsSubdivision__5Pspec ;
}
return (((__0this -> pspec__9Patchlist [0 ]). needsSubdivision__5Pspec || (__0this -> pspec__9Patchlist [1 ]). needsSubdivision__5Pspec )?1 :0 );

}

}
}

int __glneedsSubdivision__9Patchli0 (struct Patchlist *__0this , int __1param )
{ 
return (__0this -> pspec__9Patchlist [__1param ]). needsSubdivision__5Pspec ;
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\mycode.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/mycode.c++ > */


void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };



extern struct __mptr* __ptbl_vec_____core_mycode_c___myceilf_[];

float __glmyceilf (float __1x )
{ 
if (__1x < 0 ){ 
float __2nx ;
int __2ix ;

__2nx = (- __1x );
__2ix = (((int )__2nx ));
return (((float )(- __2ix )));
}
else 
{ 
int __2ix ;

__2ix = (((int )__1x ));
if (__1x == (((float )__2ix )))return __1x ;
return (((float )(__2ix + 1 )));
}
}

float __glmyfloorf (float __1x )
{ 
if (__1x < 0 ){ 
float __2nx ;
int __2ix ;

__2nx = (- __1x );
__2ix = (((int )__2nx ));
if (__2nx == (((float )__2ix )))return __1x ;
return (((float )(- (__2ix + 1 ))));
}
else 
{ 
int __2ix ;

__2ix = (((int )__1x ));
return (((float )__2ix ));
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\mesher.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/mesher.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);










struct Arc;

struct Backend;






typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;







struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};












struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};


struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;








struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};






struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};

struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;



struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};




extern float __glZERO__6Mesher ;
float __glZERO__6Mesher = 0.0 ;
extern struct __mptr* __ptbl_vec_____core_mesher_c___ZERO_[];

struct Pool *__gl__ct__4PoolFiT1Pc (struct Pool *, int , int , char *);

struct Hull *__gl__ct__4HullFv (struct Hull *, struct TrimRegion *);

struct TrimRegion *__gl__ct__10TrimRegionFv (struct TrimRegion *);


struct Mesher *__gl__ct__6MesherFR7Backend (struct Mesher *__0this , struct TrimRegion *__0TrimRegion , struct Backend *__1b )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Mesher *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Mesher))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){
( ( ( ((__0TrimRegion == 0 )?( (__0TrimRegion = (((struct TrimRegion *)((((char *)__0this ))+ 348)))), __gl__ct__10TrimRegionFv ( ((struct TrimRegion *)((((char *)__0this ))+
348))) ) :__0TrimRegion ), __gl__ct__4HullFv ( ((struct Hull *)__0this ), __0TrimRegion ) ) , (__0this -> backend__6Mesher = __1b )) , __gl__ct__4PoolFiT1Pc (
(struct Pool *)(& __0this -> p__6Mesher ), (int )(sizeof (struct GridTrimVertex )), 100 , (char *)"GridTrimVertexPool")
) ;
__0this -> stacksize__6Mesher = 0 ;
__0this -> vdata__6Mesher = 0 ;
} return __0this ;

}

void __gl__dt__4PoolFv (struct Pool *, int );


void __gl__dt__4HullFv (struct Hull *, int );


void __gl__dt__6MesherFv (struct Mesher *__0this , 
int __0__free )
{ 
void *__1__X7 ;

if (__0this ){ 
if (__0this -> vdata__6Mesher )( (__1__X7 = (void *)__0this -> vdata__6Mesher ), ( (__1__X7 ?( free ( __1__X7 ) ,
0 ) :( 0 ) )) ) ;
if (__0this ){ __gl__dt__4PoolFv ( (struct Pool *)(& __0this -> p__6Mesher ), 2) ;

( __gl__dt__4HullFv ( ((struct Hull *)__0this ), 0 ) , ((__0__free & 2)?( (((void )( ((((struct TrimRegion *)((((char *)__0this ))+ 348)))?(
((((struct TrimRegion *)((((char *)__0this ))+ 348)))?( ( __gl__dt__6UarrayFv ( (struct Uarray *)(& (((struct TrimRegion *)((((char *)__0this ))+ 348)))-> uarray__10TrimRegion ), 2)
, ( __gl__dt__8TrimlineFv ( (struct Trimline *)(& (((struct TrimRegion *)((((char *)__0this ))+ 348)))-> right__10TrimRegion ), 2) , ( __gl__dt__8TrimlineFv (
(struct Trimline *)(& (((struct TrimRegion *)((((char *)__0this ))+ 348)))-> left__10TrimRegion ), 2) , (( 0 ) )) ) )
, 0 ) :( 0 ) ), 0 ) :( 0 ) )) )), 0 ) :0 )) ;

if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) )) ;
} } }

void __glclear__4PoolFv (struct Pool *);



void __glinit__6MesherFUi (struct Mesher *__0this , unsigned int __1npts )
{ 
__glclear__4PoolFv ( (struct Pool *)(& __0this -> p__6Mesher )) ;
if (__0this -> stacksize__6Mesher < __1npts ){ 
void *__1__X8 ;

void *__1__Xp00uzigaiaa ;

__0this -> stacksize__6Mesher = (2 * __1npts );
if (__0this -> vdata__6Mesher )( (__1__X8 = (void *)__0this -> vdata__6Mesher ), ( (__1__X8 ?( free ( __1__X8 ) , 0 ) :(
0 ) )) ) ;
__0this -> vdata__6Mesher = (struct GridTrimVertex **)(((struct GridTrimVertex **)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (struct GridTrimVertex *))* __0this -> stacksize__6Mesher )) ), (__1__Xp00uzigaiaa ?(((void
*)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ));
}
}

void __glbgntmesh__7BackendFPc (struct Backend *, char *);
void __glendtmesh__7BackendFv (struct Backend *);
void __glswaptmesh__7BackendFv (struct Backend *);


struct GridTrimVertex *__glnextlower__4HullFP14GridTr0 (struct Hull *, struct GridTrimVertex *);


void __gladdLower__6MesherFv (struct Mesher *);


void __gladdLast__6MesherFv (struct Mesher *);


void __glfinishLower__6MesherFP14Gr0 (struct Mesher *__0this , struct GridTrimVertex *__1gtlower )
{ 
struct GridTrimVertex *__0__X10 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

for(( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtlower )) ;__glnextlower__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtlower = ((__0__X10 = (struct
GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa =
(((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))) , 0 ) :( 0 ) ),
( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), (
(__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )))))
) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa ))) ) ))) )?( ( (0 ), ((((struct GridVertex *)(&
((struct GridTrimVertex *)__0__X10 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X10 )-> g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X10 )-> t__14GridTrimVertex = 0 ),
((((struct GridTrimVertex *)__0__X10 )))) ) ) :0 )) ;( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtlower )) )

__gladdLower__6MesherFv ( __0this ) ;
__gladdLast__6MesherFv ( __0this ) ;
}


struct GridTrimVertex *__glnextupper__4HullFP14GridTr0 (struct Hull *, struct GridTrimVertex *);


void __gladdUpper__6MesherFv (struct Mesher *);



void __glfinishUpper__6MesherFP14Gr0 (struct Mesher *__0this , struct GridTrimVertex *__1gtupper )
{ 
struct GridTrimVertex *__0__X11 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

for(( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtupper )) ;__glnextupper__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtupper = ((__0__X11 = (struct
GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa =
(((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))) , 0 ) :( 0 ) ),
( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), (
(__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )))))
) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa ))) ) ))) )?( ( (0 ), ((((struct GridVertex *)(&
((struct GridTrimVertex *)__0__X11 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X11 )-> g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X11 )-> t__14GridTrimVertex = 0 ),
((((struct GridTrimVertex *)__0__X11 )))) ) ) :0 )) ;( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtupper )) )

__gladdUpper__6MesherFv ( __0this ) ;
__gladdLast__6MesherFv ( __0this ) ;
}

void __glinit__4HullFv (struct Hull *);























void __glmesh__6MesherFv (struct Mesher *__0this )
{ 
struct GridTrimVertex *__1gtlower ;

struct GridTrimVertex *__1gtupper ;

struct GridTrimVertex *__0__X12 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

struct GridTrimVertex *__0__X13 ;

struct GridTrimVertex *__0__X14 ;

__glinit__4HullFv ( (struct Hull *)__0this ) ;
__glnextupper__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtupper = ((__0__X12 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct
Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))), (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) , 0 )
:( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this ->
p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -= ((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> curblock__4Pool +
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa ))) )
))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X12 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X12 )-> g__14GridTrimVertex =
0 ), ( (((struct GridTrimVertex *)__0__X12 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X12 )))) ) ) :0 )) ;
__glnextlower__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtlower = ((__0__X13 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct
Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))), (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) , 0 )
:( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this ->
p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -= ((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> curblock__4Pool +
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa ))) )
))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X13 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X13 )-> g__14GridTrimVertex =
0 ), ( (((struct GridTrimVertex *)__0__X13 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X13 )))) ) ) :0 )) ;

( (__0this -> itop__6Mesher = -1), ((__0this -> last__6Mesher [0 ])= 0 )) ;
( __glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__6Mesher , (char *)"addedge") ) ;
( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtupper )) ;

__glnextupper__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtupper = ((__0__X14 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct
Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))), (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) , 0 )
:( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this ->
p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -= ((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> curblock__4Pool +
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa ))) )
))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X14 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X14 )-> g__14GridTrimVertex =
0 ), ( (((struct GridTrimVertex *)__0__X14 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X14 )))) ) ) :0 )) ;
__glnextlower__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtlower ) ;

((void )0 );

if ((__1gtupper -> t__14GridTrimVertex -> param__10TrimVertex [0 ])< (__1gtlower -> t__14GridTrimVertex -> param__10TrimVertex [0 ])){ 
struct GridTrimVertex *__0__X15 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtupper )) ;
__0this -> lastedge__6Mesher = 1 ;
if (__glnextupper__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtupper = ((__0__X15 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))),
(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) ,
0 ) :( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -=
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))->
curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa )))
) ))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X15 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X15 )->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X15 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X15 )))) ) ) :0 )) == 0 ){

__glfinishLower__6MesherFP14Gr0 ( __0this , __1gtlower ) ;
return ;
}
}
else 
if ((__1gtupper -> t__14GridTrimVertex -> param__10TrimVertex [0 ])> (__1gtlower -> t__14GridTrimVertex -> param__10TrimVertex [0 ])){ 
struct GridTrimVertex *__0__X16 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtlower )) ;
__0this -> lastedge__6Mesher = 0 ;
if (__glnextlower__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtlower = ((__0__X16 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))),
(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) ,
0 ) :( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -=
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))->
curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa )))
) ))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X16 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X16 )->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X16 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X16 )))) ) ) :0 )) == 0 ){

__glfinishUpper__6MesherFP14Gr0 ( __0this , __1gtupper ) ;
return ;
}
}
else 
{ 
if (__0this -> lastedge__6Mesher == 0 ){ 
struct GridTrimVertex *__0__X17 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtupper )) ;
__0this -> lastedge__6Mesher = 1 ;
if (__glnextupper__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtupper = ((__0__X17 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))),
(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) ,
0 ) :( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -=
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))->
curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa )))
) ))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X17 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X17 )->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X17 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X17 )))) ) ) :0 )) == 0 ){

__glfinishLower__6MesherFP14Gr0 ( __0this , __1gtlower ) ;
return ;
}
}
else 
{ 
struct GridTrimVertex *__0__X18 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtlower )) ;
__0this -> lastedge__6Mesher = 0 ;
if (__glnextlower__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtlower = ((__0__X18 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))),
(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) ,
0 ) :( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -=
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))->
curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa )))
) ))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X18 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X18 )->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X18 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X18 )))) ) ) :0 )) == 0 ){

__glfinishUpper__6MesherFP14Gr0 ( __0this , __1gtupper ) ;
return ;
}
}
}

while (1 ){ 
if ((__1gtupper -> t__14GridTrimVertex -> param__10TrimVertex [0 ])< (__1gtlower -> t__14GridTrimVertex -> param__10TrimVertex [0 ])){ 
struct GridTrimVertex *__0__X19 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtupper )) ;
__gladdUpper__6MesherFv ( __0this ) ;
if (__glnextupper__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtupper = ((__0__X19 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))),
(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) ,
0 ) :( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -=
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))->
curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa )))
) ))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X19 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X19 )->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X19 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X19 )))) ) ) :0 )) == 0 ){

__glfinishLower__6MesherFP14Gr0 ( __0this , __1gtlower ) ;
return ;
}
}
else 
if ((__1gtupper -> t__14GridTrimVertex -> param__10TrimVertex [0 ])> (__1gtlower -> t__14GridTrimVertex -> param__10TrimVertex [0 ])){ 
struct GridTrimVertex *__0__X20 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtlower )) ;
__gladdLower__6MesherFv ( __0this ) ;
if (__glnextlower__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtlower = ((__0__X20 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))),
(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) ,
0 ) :( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -=
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))->
curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa )))
) ))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X20 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X20 )->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X20 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X20 )))) ) ) :0 )) == 0 ){

__glfinishUpper__6MesherFP14Gr0 ( __0this , __1gtupper ) ;
return ;
}
}
else 
{ 
if (__0this -> lastedge__6Mesher == 0 ){ 
struct GridTrimVertex *__0__X21 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtupper )) ;
__gladdUpper__6MesherFv ( __0this ) ;
if (__glnextupper__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtupper = ((__0__X21 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))),
(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) ,
0 ) :( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -=
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))->
curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa )))
) ))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X21 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X21 )->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X21 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X21 )))) ) ) :0 )) == 0 ){

__glfinishLower__6MesherFP14Gr0 ( __0this , __1gtlower ) ;
return ;
}
}
else 
{ 
struct GridTrimVertex *__0__X22 ;

void *__1__Xbuffer00qkhgaiaa ;

void *__1__Xp00uzigaiaa ;

( (((void )0 )), ((__0this -> vdata__6Mesher [(++ __0this -> itop__6Mesher )])= __1gtlower )) ;
__gladdLower__6MesherFv ( __0this ) ;
if (__glnextlower__4HullFP14GridTr0 ( (struct Hull *)__0this , __1gtlower = ((__0__X22 = (struct GridTrimVertex *)( (((void *)( (((void )0 )), ( (((struct
Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ?( ( (__1__Xbuffer00qkhgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool ))),
(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> freelist__4Pool -> next__6Buffer )) ,
0 ) :( ( ((! ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(&
__0this -> p__6Mesher )))) , 0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool -=
((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> buffersize__4Pool ), ( (__1__Xbuffer00qkhgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))->
curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this -> p__6Mesher )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00qkhgaiaa )))
) ))) )?( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)__0__X22 )-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)__0__X22 )->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)__0__X22 )-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)__0__X22 )))) ) ) :0 )) == 0 ){

__glfinishUpper__6MesherFP14Gr0 ( __0this , __1gtupper ) ;
return ;
}
}
}
}
}


void __gltmeshvert__7BackendFP14Gri0 (struct Backend *, struct GridTrimVertex *);

































void __gladdLast__6MesherFv (struct Mesher *__0this )
{ 
register int __1ilast ;

__1ilast = __0this -> itop__6Mesher ;

if (__0this -> lastedge__6Mesher == 0 ){ 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [0 ]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [1 ]))))
){ 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
{ { register int __3i ;

__3i = 2 ;

for(;__3i < __1ilast ;__3i ++ ) { 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [__1ilast ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )]))) ;

}

}
}
else 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [(__1ilast - 2 )]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [(__1ilast - 1 )])))) ){

( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
{ { register int __3i ;

__3i = (__1ilast - 3 );

for(;__3i >= 0 ;__3i -- ) { 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [0 ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;

}

}
}
else 
{ 
( __glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;

( __glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__6Mesher , (char *)"addedge") ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [0 ]) ) ;
{ { register int __3i ;

__3i = 1 ;

for(;__3i < __1ilast ;__3i ++ ) { 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [__1ilast ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )]))) ;

}

}
}
}
else 
{ 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [1 ]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [0 ])))) ){ 
(
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
{ { register int __3i ;

__3i = 2 ;

for(;__3i < __1ilast ;__3i ++ ) { 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;

}

}
}
else 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [(__1ilast - 1 )]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [(__1ilast - 2 )])))) ){

( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
{ { register int __3i ;

__3i = (__1ilast - 3 );

for(;__3i >= 0 ;__3i -- ) { 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [__1ilast ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [0 ]))) ;

}

}
}
else 
{ 
( __glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;

( __glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__6Mesher , (char *)"addedge") ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [0 ]) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
{ { register int __3i ;

__3i = 1 ;

for(;__3i < __1ilast ;__3i ++ ) { 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;

}

}
}
}
( __glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;

}




































void __gladdUpper__6MesherFv (struct Mesher *__0this )
{ 
register int __1ilast ;

__1ilast = __0this -> itop__6Mesher ;

if (__0this -> lastedge__6Mesher == 0 ){ 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [0 ]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [1 ]))))
){ 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
{ { register int __3i ;

__3i = 2 ;

for(;__3i < __1ilast ;__3i ++ ) { 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [__1ilast ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )]))) ;

}

}
}
else 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [(__1ilast - 2 )]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [(__1ilast - 1 )])))) ){

( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
{ { register int __3i ;

__3i = (__1ilast - 3 );

for(;__3i >= 0 ;__3i -- ) { 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [0 ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;

}

}
}
else 
{ 
( __glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;

( __glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__6Mesher , (char *)"addedge") ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [0 ]) ) ;
{ { register int __3i ;

__3i = 1 ;

for(;__3i < __1ilast ;__3i ++ ) { 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [__1ilast ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )]))) ;

}

}
}
__0this -> lastedge__6Mesher = 1 ;

( ((__0this -> vdata__6Mesher [0 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )]))) ;
( ((__0this -> vdata__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;
__0this -> itop__6Mesher = 1 ;
}
else 
{ 
float __1__Xarea00qyumaile ;

struct TrimVertex *__1__X23 ;

struct TrimVertex *__1__X24 ;

struct TrimVertex *__1__X25 ;

if (! ( (__1__Xarea00qyumaile = ( (__1__X23 = (__0this -> vdata__6Mesher [__1ilast ])-> t__14GridTrimVertex ), ( (__1__X24 = (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher -
1 )])-> t__14GridTrimVertex ), ( (__1__X25 = (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 2 )])-> t__14GridTrimVertex ), ( ((((__1__X23 -> param__10TrimVertex [0 ])* ((__1__X24 -> param__10TrimVertex [1 ])-
(__1__X25 -> param__10TrimVertex [1 ])))+ ((__1__X24 -> param__10TrimVertex [0 ])* ((__1__X25 -> param__10TrimVertex [1 ])- (__1__X23 -> param__10TrimVertex [1 ]))))+ ((__1__X25 -> param__10TrimVertex [0 ])* ((__1__X23 -> param__10TrimVertex [1 ])- (__1__X24 -> param__10TrimVertex [1 ])))))
) ) ) ), ((__1__Xarea00qyumaile < __glZERO__6Mesher )?0 :1 )) )return ;
do { 
__0this -> itop__6Mesher -- ;
}
while ((__0this -> itop__6Mesher > 1 )&& ( (__1__Xarea00qyumaile = ( (__1__X23 = (__0this -> vdata__6Mesher [__1ilast ])-> t__14GridTrimVertex ), ( (__1__X24 = (__0this ->
vdata__6Mesher [(__0this -> itop__6Mesher - 1 )])-> t__14GridTrimVertex ), ( (__1__X25 = (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 2 )])-> t__14GridTrimVertex ), ( ((((__1__X23 -> param__10TrimVertex [0 ])*
((__1__X24 -> param__10TrimVertex [1 ])- (__1__X25 -> param__10TrimVertex [1 ])))+ ((__1__X24 -> param__10TrimVertex [0 ])* ((__1__X25 -> param__10TrimVertex [1 ])- (__1__X23 -> param__10TrimVertex [1 ]))))+ ((__1__X25 -> param__10TrimVertex [0 ])* ((__1__X23 -> param__10TrimVertex [1 ])-
(__1__X24 -> param__10TrimVertex [1 ]))))) ) ) ) ), ((__1__Xarea00qyumaile < __glZERO__6Mesher )?0 :1 )) );
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [(__1ilast - 1 )]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [(__1ilast - 2 )])))) ){ 
(
__gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
{ { register int __3i ;

__3i = (__1ilast - 3 );

for(;__3i >= (__0this -> itop__6Mesher - 1 );__3i -- ) { 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [__1ilast ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 1 )]))) ;

}

}
}
else 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [__0this -> itop__6Mesher ]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 1 )]))))
){ 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
{ { register int __3i ;

__3i = (__0this -> itop__6Mesher + 1 );

for(;__3i < __1ilast ;__3i ++ ) { 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;

}

}
}
else 
{ 
( __glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;

( __glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__6Mesher , (char *)"addedge") ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [(__1ilast - 1 )]) ) ;
{ { register int __3i ;

__3i = (__1ilast - 2 );

for(;__3i >= (__0this -> itop__6Mesher - 1 );__3i -- ) { 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [__1ilast ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 1 )]))) ;

}

}
}

( ((__0this -> vdata__6Mesher [__0this -> itop__6Mesher ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;
}
}


































void __gladdLower__6MesherFv (struct Mesher *__0this )
{ 
register int __1ilast ;

__1ilast = __0this -> itop__6Mesher ;

if (__0this -> lastedge__6Mesher == 1 ){ 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [1 ]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [0 ]))))
){ 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
{ { register int __3i ;

__3i = 2 ;

for(;__3i < __1ilast ;__3i ++ ) { 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;

}

}
}
else 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [(__1ilast - 1 )]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [(__1ilast - 2 )])))) ){

( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
{ { register int __3i ;

__3i = (__1ilast - 3 );

for(;__3i >= 0 ;__3i -- ) { 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [__1ilast ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [0 ]))) ;

}

}
}
else 
{ 
( __glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;

( __glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__6Mesher , (char *)"addedge") ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [0 ]) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
{ { register int __3i ;

__3i = 1 ;

for(;__3i < __1ilast ;__3i ++ ) { 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;

}

}
}

__0this -> lastedge__6Mesher = 0 ;

( ((__0this -> vdata__6Mesher [0 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )]))) ;
( ((__0this -> vdata__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;
__0this -> itop__6Mesher = 1 ;
}
else 
{ 
float __1__Xarea002uumaige ;

struct TrimVertex *__1__X26 ;

struct TrimVertex *__1__X27 ;

struct TrimVertex *__1__X28 ;

if (! ( (__1__Xarea002uumaige = ( (__1__X26 = (__0this -> vdata__6Mesher [__1ilast ])-> t__14GridTrimVertex ), ( (__1__X27 = (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher -
1 )])-> t__14GridTrimVertex ), ( (__1__X28 = (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 2 )])-> t__14GridTrimVertex ), ( ((((__1__X26 -> param__10TrimVertex [0 ])* ((__1__X27 -> param__10TrimVertex [1 ])-
(__1__X28 -> param__10TrimVertex [1 ])))+ ((__1__X27 -> param__10TrimVertex [0 ])* ((__1__X28 -> param__10TrimVertex [1 ])- (__1__X26 -> param__10TrimVertex [1 ]))))+ ((__1__X28 -> param__10TrimVertex [0 ])* ((__1__X26 -> param__10TrimVertex [1 ])- (__1__X27 -> param__10TrimVertex [1 ])))))
) ) ) ), ((__1__Xarea002uumaige > (- __glZERO__6Mesher ))?0 :1 )) )return ;
do { 
__0this -> itop__6Mesher -- ;
}
while ((__0this -> itop__6Mesher > 1 )&& ( (__1__Xarea002uumaige = ( (__1__X26 = (__0this -> vdata__6Mesher [__1ilast ])-> t__14GridTrimVertex ), ( (__1__X27 = (__0this ->
vdata__6Mesher [(__0this -> itop__6Mesher - 1 )])-> t__14GridTrimVertex ), ( (__1__X28 = (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 2 )])-> t__14GridTrimVertex ), ( ((((__1__X26 -> param__10TrimVertex [0 ])*
((__1__X27 -> param__10TrimVertex [1 ])- (__1__X28 -> param__10TrimVertex [1 ])))+ ((__1__X27 -> param__10TrimVertex [0 ])* ((__1__X28 -> param__10TrimVertex [1 ])- (__1__X26 -> param__10TrimVertex [1 ]))))+ ((__1__X28 -> param__10TrimVertex [0 ])* ((__1__X26 -> param__10TrimVertex [1 ])-
(__1__X27 -> param__10TrimVertex [1 ]))))) ) ) ) ), ((__1__Xarea002uumaige > (- __glZERO__6Mesher ))?0 :1 )) );
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [(__1ilast - 2 )]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [(__1ilast - 1 )])))) ){ 
(
__glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
{ { register int __3i ;

__3i = (__1ilast - 3 );

for(;__3i >= (__0this -> itop__6Mesher - 1 );__3i -- ) { 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) )
;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 1 )])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;

}

}
}
else 
if (( (((__0this -> last__6Mesher [0 ])== (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 1 )]))&& ((__0this -> last__6Mesher [1 ])== (__0this -> vdata__6Mesher [__0this -> itop__6Mesher ]))))
){ 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
{ { register int __3i ;

__3i = (__0this -> itop__6Mesher + 1 );

for(;__3i < __1ilast ;__3i ++ ) { 
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [__1ilast ])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [(__1ilast - 1 )]))) ;

}

}
}
else 
{ 
( __glendtmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;

( __glbgntmesh__7BackendFPc ( (struct Backend *)__0this -> backend__6Mesher , (char *)"addedge") ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [(__1ilast - 1 )]) ) ;
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__1ilast ]) ) ;
{ { register int __3i ;

__3i = (__1ilast - 2 );

for(;__3i >= (__0this -> itop__6Mesher - 1 );__3i -- ) { 
( __gltmeshvert__7BackendFP14Gri0 ( (struct Backend *)__0this -> backend__6Mesher , __0this -> vdata__6Mesher [__3i ]) )
;
( __glswaptmesh__7BackendFv ( (struct Backend *)__0this -> backend__6Mesher ) ) ;
}
( ((__0this -> last__6Mesher [0 ])= (__0this -> vdata__6Mesher [(__0this -> itop__6Mesher - 1 )])), ((__0this -> last__6Mesher [1 ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;

}

}
}

( ((__0this -> vdata__6Mesher [__0this -> itop__6Mesher ])= (__0this -> vdata__6Mesher [__1ilast ]))) ;
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\nurbstes.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>
#include <windef.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/nurbstess.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);






struct JumpBuffer;















struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;



struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};




struct Renderhints;

struct Renderhints {	

REAL display_method__11Renderhints ;
REAL errorchecking__11Renderhints ;
REAL subdivisions__11Renderhints ;
REAL tmp1__11Renderhints ;

int displaydomain__11Renderhints ;
int maxsubdivisions__11Renderhints ;
int wiretris__11Renderhints ;
int wirequads__11Renderhints ;
};






struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};






struct Mapdesc;

struct Maplist;

void __gl__dt__4PoolFv (struct Pool *, int );


struct Maplist {	

struct Pool mapdescPool__7Maplist ;
struct Mapdesc *maps__7Maplist ;
struct Mapdesc **lastmap__7Maplist ;
struct Backend *backend__7Maplist ;
};

struct Mapdesc *__gllocate__7MaplistFl (struct Maplist *, long );

void __glremove__7MaplistFP7Mapdesc (struct Maplist *, struct Mapdesc *);



enum Curvetype { ct_nurbscurve = 0, ct_pwlcurve = 1, ct_none = 2} ;
struct Property;

struct O_surface;

struct O_nurbssurface;

struct O_trim;

struct O_pwlcurve;

struct O_nurbscurve;

struct O_curve;

struct Quilt;


union __Q2_7O_curve4__C1;

union  __Q2_7O_curve4__C1 {	
struct O_nurbscurve *o_nurbscurve ;
struct O_pwlcurve *o_pwlcurve ;
};


struct O_curve;

struct O_curve {	

char __W3__9PooledObj ;

union  __Q2_7O_curve4__C1 curve__7O_curve ;
int curvetype__7O_curve ;
struct O_curve *next__7O_curve ;
struct O_surface *owner__7O_curve ;
int used__7O_curve ;
int save__7O_curve ;
long nuid__7O_curve ;
};






struct O_nurbscurve;

struct O_nurbscurve {	

char __W3__9PooledObj ;

struct Quilt *bezier_curves__12O_nurbscurve ;
long type__12O_nurbscurve ;
REAL tesselation__12O_nurbscurve ;
int method__12O_nurbscurve ;
struct O_nurbscurve *next__12O_nurbscurve ;
int used__12O_nurbscurve ;
int save__12O_nurbscurve ;
struct O_curve *owner__12O_nurbscurve ;
};






struct O_pwlcurve;



struct O_pwlcurve {	

char __W3__9PooledObj ;

struct TrimVertex *pts__10O_pwlcurve ;
int npts__10O_pwlcurve ;
struct O_pwlcurve *next__10O_pwlcurve ;
int used__10O_pwlcurve ;
int save__10O_pwlcurve ;
struct O_curve *owner__10O_pwlcurve ;
};



struct O_trim;

struct O_trim {	

char __W3__9PooledObj ;

struct O_curve *o_curve__6O_trim ;
struct O_trim *next__6O_trim ;
int save__6O_trim ;
};






struct O_nurbssurface;

struct O_nurbssurface {	

char __W3__9PooledObj ;

struct Quilt *bezier_patches__14O_nurbssurface ;
long type__14O_nurbssurface ;
struct O_surface *owner__14O_nurbssurface ;
struct O_nurbssurface *next__14O_nurbssurface ;
int save__14O_nurbssurface ;
int used__14O_nurbssurface ;
};






struct O_surface;

struct O_surface {	

char __W3__9PooledObj ;

struct O_nurbssurface *o_nurbssurface__9O_surface ;
struct O_trim *o_trim__9O_surface ;
int save__9O_surface ;
long nuid__9O_surface ;
};






struct Property;

struct Property {	

char __W3__9PooledObj ;

long type__8Property ;
long tag__8Property ;
REAL value__8Property ;
int save__8Property ;
};




struct NurbsTessellator;


struct Knotvector;

struct Quilt;

struct DisplayList;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct NurbsTessellator;

struct NurbsTessellator {	

struct Renderhints renderhints__16NurbsTessellator ;
struct Maplist maplist__16NurbsTessellator ;
struct Backend backend__16NurbsTessellator ;

struct Subdivider subdivider__16NurbsTessellator ;
struct JumpBuffer *jumpbuffer__16NurbsTessellator ;
struct Pool o_pwlcurvePool__16NurbsTessellator ;
struct Pool o_nurbscurvePool__16NurbsTessellator ;
struct Pool o_curvePool__16NurbsTessellator ;
struct Pool o_trimPool__16NurbsTessellator ;
struct Pool o_surfacePool__16NurbsTessellator ;
struct Pool o_nurbssurfacePool__16NurbsTessellator ;
struct Pool propertyPool__16NurbsTessellator ;
struct Pool quiltPool__16NurbsTessellator ;
struct TrimVertexPool extTrimVertexPool__16NurbsTessellator ;

int inSurface__16NurbsTessellator ;
int inCurve__16NurbsTessellator ;
int inTrim__16NurbsTessellator ;
int isCurveModified__16NurbsTessellator ;
int isTrimModified__16NurbsTessellator ;
int isSurfaceModified__16NurbsTessellator ;
int isDataValid__16NurbsTessellator ;
int numTrims__16NurbsTessellator ;
int playBack__16NurbsTessellator ;

struct O_trim **nextTrim__16NurbsTessellator ;
struct O_curve **nextCurve__16NurbsTessellator ;
struct O_nurbscurve **nextNurbscurve__16NurbsTessellator ;
struct O_pwlcurve **nextPwlcurve__16NurbsTessellator ;
struct O_nurbssurface **nextNurbssurface__16NurbsTessellator ;

struct O_surface *currentSurface__16NurbsTessellator ;
struct O_trim *currentTrim__16NurbsTessellator ;
struct O_curve *currentCurve__16NurbsTessellator ;

struct DisplayList *dl__16NurbsTessellator ;

struct __mptr *__vptr__16NurbsTessellator ;
};






struct Mapdesc;


struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;



struct Knotvector;

struct Knotvector {	

long order__10Knotvector ;
long knotcount__10Knotvector ;
long stride__10Knotvector ;
Knot *knotlist__10Knotvector ;
};





typedef REAL Maxmatrix [5][5];



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};


void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);








void __glclear__10SubdividerFv (struct Subdivider *);
extern struct __mptr* __ptbl_vec_____core_nurbstess_c___resetObjects_[];

void __glresetObjects__16NurbsTesse0 (struct NurbsTessellator *__0this )
{ 
__glclear__10SubdividerFv ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator )) ;
}

void __glmakeobj__16NurbsTessellato0 (struct NurbsTessellator *__0this , int __1__A14 )
{ 
}

void __glcloseobj__16NurbsTessellat0 (struct NurbsTessellator *__0this )
{ 
}

void __glbgnrender__16NurbsTessella0 (struct NurbsTessellator *__0this )
{ 
}

void __glendrender__16NurbsTessella0 (struct NurbsTessellator *__0this )
{

}


void __gldo_freebgnsurface__16Nurbs0 (struct NurbsTessellator *__0this , struct O_surface *__1o_surface )
{ 
( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct
PooledObj *)__1o_surface )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> o_surfacePool__16NurbsTessellator )))-> freelist__4Pool =
(((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1o_surface ))))))))) ) ) ;
}

void __gldo_nurbserror__16NurbsTess0 (struct NurbsTessellator *, int );

void __glendsurface__16NurbsTessell0 (struct NurbsTessellator *);

void __gldo_bgnsurface__16NurbsTess0 (struct NurbsTessellator *__0this , struct O_surface *__1o_surface )
{ 
if (__0this -> inSurface__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 27 ) ;
__glendsurface__16NurbsTessell0 ( __0this ) ;
}
__0this -> inSurface__16NurbsTessellator = 1 ;

if (! __0this -> playBack__16NurbsTessellator )((*(((void (*)(struct NurbsTessellator *))(__0this -> __vptr__16NurbsTessellator [1]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [1]).d))) ;

__0this -> isTrimModified__16NurbsTessellator = 0 ;
__0this -> isSurfaceModified__16NurbsTessellator = 0 ;
__0this -> isDataValid__16NurbsTessellator = 1 ;
__0this -> numTrims__16NurbsTessellator = 0 ;
__0this -> currentSurface__16NurbsTessellator = __1o_surface ;
__0this -> nextTrim__16NurbsTessellator = (& __0this -> currentSurface__16NurbsTessellator -> o_trim__9O_surface );
__0this -> nextNurbssurface__16NurbsTessellator = (& __0this -> currentSurface__16NurbsTessellator -> o_nurbssurface__9O_surface );
}

void __glendcurve__16NurbsTessellat0 (struct NurbsTessellator *);

void __gldo_bgncurve__16NurbsTessel0 (struct NurbsTessellator *__0this , struct O_curve *__1o_curve )
{ 
if (__0this -> inCurve__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 6 ) ;
__glendcurve__16NurbsTessellat0 ( __0this ) ;
}

__0this -> inCurve__16NurbsTessellator = 1 ;
__0this -> currentCurve__16NurbsTessellator = __1o_curve ;
__0this -> currentCurve__16NurbsTessellator -> curvetype__7O_curve = 2;

if (__0this -> inTrim__16NurbsTessellator ){ 
if (((*__0this -> nextCurve__16NurbsTessellator ))!= __1o_curve ){ 
__0this -> isCurveModified__16NurbsTessellator = 1 ;
((*__0this -> nextCurve__16NurbsTessellator ))= __1o_curve ;
}
}
else 
{ 
if (! __0this -> playBack__16NurbsTessellator )((*(((void (*)(struct NurbsTessellator *))(__0this -> __vptr__16NurbsTessellator [1]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [1]).d)))
;
__0this -> isDataValid__16NurbsTessellator = 1 ;
}
__0this -> nextCurve__16NurbsTessellator = (& __1o_curve -> next__7O_curve );
__0this -> nextPwlcurve__16NurbsTessellator = (& __1o_curve -> curve__7O_curve . o_pwlcurve );
__0this -> nextNurbscurve__16NurbsTessellator = (& __1o_curve -> curve__7O_curve . o_nurbscurve );
}

void __gldo_freecurveall__16NurbsTe0 (struct NurbsTessellator *, struct O_curve *);


void __glbeginQuilts__10SubdividerF0 (struct Subdivider *);
void __gladdQuilt__10SubdividerFP5Q0 (struct Subdivider *, struct Quilt *);

void __gldrawCurves__10SubdividerFv (struct Subdivider *);

void __gldo_endcurve__16NurbsTessel0 (struct NurbsTessellator *__0this )
{ 
if (! __0this -> inCurve__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 7 ) ;
return ;
}
__0this -> inCurve__16NurbsTessellator = 0 ;

((*__0this -> nextCurve__16NurbsTessellator ))= 0 ;
if (__0this -> currentCurve__16NurbsTessellator -> curvetype__7O_curve == 0)
((*__0this -> nextNurbscurve__16NurbsTessellator ))= 0 ;
else 
((*__0this -> nextPwlcurve__16NurbsTessellator ))= 0 ;

if (! __0this -> inTrim__16NurbsTessellator ){ 
int __2errval ;

if (! __0this -> isDataValid__16NurbsTessellator ){ 
__gldo_freecurveall__16NurbsTe0 ( __0this , __0this -> currentCurve__16NurbsTessellator ) ;
return ;
}

;
if ((__2errval = mysetjmp ( __0this -> jumpbuffer__16NurbsTessellator ) )== 0 ){ 
if (__0this -> currentCurve__16NurbsTessellator -> curvetype__7O_curve == 0){ 
__glbeginQuilts__10SubdividerF0 ( (struct
Subdivider *)(& __0this -> subdivider__16NurbsTessellator )) ;
{ { struct O_nurbscurve *__4n ;

__4n = __0this -> currentCurve__16NurbsTessellator -> curve__7O_curve . o_nurbscurve ;

for(;__4n != 0 ;__4n = __4n -> next__12O_nurbscurve ) 
__gladdQuilt__10SubdividerFP5Q0 ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator ), __4n -> bezier_curves__12O_nurbscurve ) ;
( 0 ) ;
__gldrawCurves__10SubdividerFv ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator )) ;
if (! __0this -> playBack__16NurbsTessellator )((*(((void (*)(struct NurbsTessellator *))(__0this -> __vptr__16NurbsTessellator [2]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [2]).d))) ;

}

}
}
else 
{ 
if (! __0this -> playBack__16NurbsTessellator )((*(((void (*)(struct NurbsTessellator *))(__0this -> __vptr__16NurbsTessellator [2]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [2]).d)))
;
;
__gldo_nurbserror__16NurbsTess0 ( __0this , 9 ) ;
}
}
else 
{ 
if (! __0this -> playBack__16NurbsTessellator )((*(((void (*)(struct NurbsTessellator *))(__0this -> __vptr__16NurbsTessellator [2]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [2]).d)))
;
__gldo_nurbserror__16NurbsTess0 ( __0this , __2errval ) ;
}
__gldo_freecurveall__16NurbsTe0 ( __0this , __0this -> currentCurve__16NurbsTessellator ) ;
__glresetObjects__16NurbsTesse0 ( __0this ) ;
}
}

void __glendtrim__16NurbsTessellato0 (struct NurbsTessellator *);

void __gldo_freeall__16NurbsTessell0 (struct NurbsTessellator *);



void __gladdArc__10SubdividerFiP10T0 (struct Subdivider *, int , struct TrimVertex *, long );

void __gladdArc__10SubdividerFPfP5Q0 (struct Subdivider *, REAL *, struct Quilt *, long );




void __gldrawSurfaces__10Subdivider0 (struct Subdivider *, long );

void __gldo_endsurface__16NurbsTess0 (struct NurbsTessellator *__0this )
{ 
int __1errval ;

if (__0this -> inTrim__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 12 ) ;
__glendtrim__16NurbsTessellato0 ( __0this ) ;
}

if (! __0this -> inSurface__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 13 ) ;
return ;
}
__0this -> inSurface__16NurbsTessellator = 0 ;

((*__0this -> nextNurbssurface__16NurbsTessellator ))= 0 ;

if (! __0this -> isDataValid__16NurbsTessellator ){ 
__gldo_freeall__16NurbsTessell0 ( __0this ) ;
return ;
}

if (((*__0this -> nextTrim__16NurbsTessellator ))!= 0 ){ 
__0this -> isTrimModified__16NurbsTessellator = 1 ;
((*__0this -> nextTrim__16NurbsTessellator ))= 0 ;
}

;

if ((__1errval = mysetjmp ( __0this -> jumpbuffer__16NurbsTessellator ) )== 0 ){ 
if (__0this -> numTrims__16NurbsTessellator > 0 ){ 
( 0 ) ;

{ { struct O_trim *__3trim ;

__3trim = __0this -> currentSurface__16NurbsTessellator -> o_trim__9O_surface ;

for(;__3trim ;__3trim = __3trim -> next__6O_trim ) { 
( (((struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator ))-> pjarc__10Subdivider = 0 )) ;
{ { struct O_curve *__4curve ;

__4curve = __3trim -> o_curve__6O_trim ;

for(;__4curve ;__4curve = __4curve -> next__7O_curve ) { 
__4curve -> used__7O_curve = 0 ;
((void )0 );
if (__4curve -> curvetype__7O_curve == 1){ 
struct O_pwlcurve *__6c ;

__6c = __4curve -> curve__7O_curve . o_pwlcurve ;
__gladdArc__10SubdividerFiP10T0 ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator ), __6c -> npts__10O_pwlcurve , __6c -> pts__10O_pwlcurve , __4curve -> nuid__7O_curve ) ;
}
else 
{ 
struct Quilt *__6quilt ;
struct Quiltspec *__6qspec ;
REAL *__6cpts ;
REAL *__6cptsend ;

__6quilt = __4curve -> curve__7O_curve . o_nurbscurve -> bezier_curves__12O_nurbscurve ;
__6qspec = __6quilt -> qspec__5Quilt ;
__6cpts = (__6quilt -> cpts__5Quilt + __6qspec -> offset__9Quiltspec );
__6cptsend = (__6cpts + ((__6qspec -> width__9Quiltspec * __6qspec -> order__9Quiltspec )* __6qspec -> stride__9Quiltspec ));
for(;__6cpts != __6cptsend ;__6cpts += (__6qspec -> order__9Quiltspec * __6qspec -> stride__9Quiltspec )) 
__gladdArc__10SubdividerFPfP5Q0 ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator ), __6cpts , __6quilt , __4curve ->
nuid__7O_curve ) ;
}
}
( 0 ) ;

}

}
}
( 0 ) ;

}

}
}

__glbeginQuilts__10SubdividerF0 ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator )) ;
{ { struct O_nurbssurface *__2n ;

__2n = __0this -> currentSurface__16NurbsTessellator -> o_nurbssurface__9O_surface ;

for(;__2n ;__2n = __2n -> next__14O_nurbssurface ) 
__gladdQuilt__10SubdividerFP5Q0 ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator ), __2n -> bezier_patches__14O_nurbssurface ) ;
( 0 ) ;
__gldrawSurfaces__10Subdivider0 ( (struct Subdivider *)(& __0this -> subdivider__16NurbsTessellator ), __0this -> currentSurface__16NurbsTessellator -> nuid__9O_surface ) ;
if (! __0this -> playBack__16NurbsTessellator )((*(((void (*)(struct NurbsTessellator *))(__0this -> __vptr__16NurbsTessellator [2]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [2]).d))) ;

}

}
}
else 
{ 
if (! __0this -> playBack__16NurbsTessellator )((*(((void (*)(struct NurbsTessellator *))(__0this -> __vptr__16NurbsTessellator [2]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [2]).d)))
;
__gldo_nurbserror__16NurbsTess0 ( __0this , __1errval ) ;
}

__gldo_freeall__16NurbsTessell0 ( __0this ) ;
__glresetObjects__16NurbsTesse0 ( __0this ) ;
}

void __gldo_freebgntrim__16NurbsTes0 (struct NurbsTessellator *, struct O_trim *);

void __gldo_freenurbssurface__16Nur0 (struct NurbsTessellator *, struct O_nurbssurface *);

void __gldo_freeall__16NurbsTessell0 (struct NurbsTessellator *__0this )
{ 
{ { struct O_trim *__1o_trim ;

struct O_nurbssurface *__1nurbss ;

struct O_nurbssurface *__1next_nurbss ;

__1o_trim = __0this -> currentSurface__16NurbsTessellator -> o_trim__9O_surface ;

for(;__1o_trim ;) { 
struct O_trim *__2next_o_trim ;

__2next_o_trim = __1o_trim -> next__6O_trim ;
{ { struct O_curve *__2curve ;

__2curve = __1o_trim -> o_curve__6O_trim ;

for(;__2curve ;) { 
struct O_curve *__3next_o_curve ;

__3next_o_curve = __2curve -> next__7O_curve ;
__gldo_freecurveall__16NurbsTe0 ( __0this , __2curve ) ;
__2curve = __3next_o_curve ;
}
if (__1o_trim -> save__6O_trim == 0 )__gldo_freebgntrim__16NurbsTes0 ( __0this , __1o_trim ) ;
__1o_trim = __2next_o_trim ;

}

}
}

;

;
for(__1nurbss = __0this -> currentSurface__16NurbsTessellator -> o_nurbssurface__9O_surface ;__1nurbss ;__1nurbss = __1next_nurbss ) { 
__1next_nurbss = __1nurbss -> next__14O_nurbssurface ;
if (__1nurbss -> save__14O_nurbssurface == 0 )
__gldo_freenurbssurface__16Nur0 ( __0this , __1nurbss ) ;
else 
__1nurbss -> used__14O_nurbssurface = 0 ;
}

if (__0this -> currentSurface__16NurbsTessellator -> save__9O_surface == 0 )__gldo_freebgnsurface__16Nurbs0 ( __0this , __0this -> currentSurface__16NurbsTessellator ) ;

}

}
}

void __gldo_freenurbscurve__16Nurbs0 (struct NurbsTessellator *, struct O_nurbscurve *);

void __gldo_freepwlcurve__16NurbsTe0 (struct NurbsTessellator *, struct O_pwlcurve *);

void __gldo_freebgncurve__16NurbsTe0 (struct NurbsTessellator *, struct O_curve *);

void __gldo_freecurveall__16NurbsTe0 (struct NurbsTessellator *__0this , struct O_curve *__1curve )
{ 
((void )0 );

if (__1curve -> curvetype__7O_curve == 0){ 
struct O_nurbscurve *__2ncurve ;

struct O_nurbscurve *__2next_ncurve ;
for(__2ncurve = __1curve -> curve__7O_curve . o_nurbscurve ;__2ncurve ;__2ncurve = __2next_ncurve ) { 
__2next_ncurve = __2ncurve -> next__12O_nurbscurve ;
if (__2ncurve -> save__12O_nurbscurve == 0 )
__gldo_freenurbscurve__16Nurbs0 ( __0this , __2ncurve ) ;
else 
__2ncurve -> used__12O_nurbscurve = 0 ;
}
}
else 
{ 
struct O_pwlcurve *__2pcurve ;

struct O_pwlcurve *__2next_pcurve ;
for(__2pcurve = __1curve -> curve__7O_curve . o_pwlcurve ;__2pcurve ;__2pcurve = __2next_pcurve ) { 
__2next_pcurve = __2pcurve -> next__10O_pwlcurve ;
if (__2pcurve -> save__10O_pwlcurve == 0 )
__gldo_freepwlcurve__16NurbsTe0 ( __0this , __2pcurve ) ;
else 
__2pcurve -> used__10O_pwlcurve = 0 ;
}
}
if (__1curve -> save__7O_curve == 0 )
__gldo_freebgncurve__16NurbsTe0 ( __0this , __1curve ) ;
}


void __gldo_freebgntrim__16NurbsTes0 (struct NurbsTessellator *__0this , struct O_trim *__1o_trim )
{ 
( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct
PooledObj *)__1o_trim )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> o_trimPool__16NurbsTessellator )))-> freelist__4Pool =
(((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1o_trim ))))))))) ) ) ;
}

void __glbgnsurface__16NurbsTessell0 (struct NurbsTessellator *, long );

void __gldo_bgntrim__16NurbsTessell0 (struct NurbsTessellator *__0this , struct O_trim *__1o_trim )
{ 
if (! __0this -> inSurface__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 15 ) ;
__glbgnsurface__16NurbsTessell0 ( __0this , (long )0 ) ;
__0this -> inSurface__16NurbsTessellator = 2 ;
}

if (__0this -> inTrim__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 16 ) ;
__glendtrim__16NurbsTessellato0 ( __0this ) ;
}
__0this -> inTrim__16NurbsTessellator = 1 ;

if (((*__0this -> nextTrim__16NurbsTessellator ))!= __1o_trim ){ 
__0this -> isTrimModified__16NurbsTessellator = 1 ;
((*__0this -> nextTrim__16NurbsTessellator ))= __1o_trim ;
}

__0this -> currentTrim__16NurbsTessellator = __1o_trim ;
__0this -> nextTrim__16NurbsTessellator = (& __1o_trim -> next__6O_trim );
__0this -> nextCurve__16NurbsTessellator = (& __1o_trim -> o_curve__6O_trim );
}

void __gldo_endtrim__16NurbsTessell0 (struct NurbsTessellator *__0this )
{ 
if (! __0this -> inTrim__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 17 ) ;
return ;
}
__0this -> inTrim__16NurbsTessellator = 0 ;

if (__0this -> currentTrim__16NurbsTessellator -> o_curve__6O_trim == 0 ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 18 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
}

__0this -> numTrims__16NurbsTessellator ++ ;

if (((*__0this -> nextCurve__16NurbsTessellator ))!= 0 ){ 
__0this -> isTrimModified__16NurbsTessellator = 1 ;
((*__0this -> nextCurve__16NurbsTessellator ))= 0 ;
}
}


void __gldo_freepwlcurve__16NurbsTe0 (struct NurbsTessellator *__0this , struct O_pwlcurve *__1o_pwlcurve )
{ 
( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct
PooledObj *)__1o_pwlcurve )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> o_pwlcurvePool__16NurbsTessellator )))-> freelist__4Pool =
(((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1o_pwlcurve ))))))))) ) ) ;
}


void __gldo_freebgncurve__16NurbsTe0 (struct NurbsTessellator *__0this , struct O_curve *__1o_curve )
{ 
( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct
PooledObj *)__1o_curve )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> o_curvePool__16NurbsTessellator )))-> freelist__4Pool =
(((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1o_curve ))))))))) ) ) ;
}

void __glbgncurve__16NurbsTessellat0 (struct NurbsTessellator *, long );

void __gldo_pwlcurve__16NurbsTessel0 (struct NurbsTessellator *__0this , struct O_pwlcurve *__1o_pwlcurve )
{ 
if (! __0this -> inTrim__16NurbsTessellator ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 19 ) ;
if (__1o_pwlcurve -> save__10O_pwlcurve == 0 )
__gldo_freepwlcurve__16NurbsTe0 ( __0this , __1o_pwlcurve ) ;
return ;
}

if (! __0this -> inCurve__16NurbsTessellator ){ 
__glbgncurve__16NurbsTessellat0 ( __0this , (long )0 ) ;
__0this -> inCurve__16NurbsTessellator = 2 ;
}

if (__1o_pwlcurve -> used__10O_pwlcurve ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 20 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}
else __1o_pwlcurve -> used__10O_pwlcurve = 1 ;

if (__0this -> currentCurve__16NurbsTessellator -> curvetype__7O_curve == 2){ 
__0this -> currentCurve__16NurbsTessellator -> curvetype__7O_curve = 1;
}
else 
if (__0this -> currentCurve__16NurbsTessellator -> curvetype__7O_curve != 1){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 21 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

if (((*__0this -> nextPwlcurve__16NurbsTessellator ))!= __1o_pwlcurve ){ 
__0this -> isCurveModified__16NurbsTessellator = 1 ;
((*__0this -> nextPwlcurve__16NurbsTessellator ))= __1o_pwlcurve ;
}
__0this -> nextPwlcurve__16NurbsTessellator = (& __1o_pwlcurve -> next__10O_pwlcurve );

if (__1o_pwlcurve -> owner__10O_pwlcurve != __0this -> currentCurve__16NurbsTessellator ){ 
__0this -> isCurveModified__16NurbsTessellator = 1 ;
__1o_pwlcurve -> owner__10O_pwlcurve = __0this -> currentCurve__16NurbsTessellator ;
}

if (__0this -> inCurve__16NurbsTessellator == 2 )
__glendcurve__16NurbsTessellat0 ( __0this ) ;
}

void __gldeleteMe__5QuiltFR4Pool (struct Quilt *, struct Pool *);


void __gldo_freenurbscurve__16Nurbs0 (struct NurbsTessellator *__0this , struct O_nurbscurve *__1o_nurbscurve )
{ 
__gldeleteMe__5QuiltFR4Pool ( (struct Quilt *)__1o_nurbscurve -> bezier_curves__12O_nurbscurve , (struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )) ;

( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1o_nurbscurve )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(&
__0this -> o_nurbscurvePool__16NurbsTessellator )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> o_nurbscurvePool__16NurbsTessellator )))-> freelist__4Pool = (((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1o_nurbscurve )))))))))
) ) ;
}

void __gldo_nurbscurve__16NurbsTess0 (struct NurbsTessellator *__0this , struct O_nurbscurve *__1o_nurbscurve )
{ 
if (! __0this -> inCurve__16NurbsTessellator ){ 
__glbgncurve__16NurbsTessellat0 ( __0this , (long )0 ) ;

__0this -> inCurve__16NurbsTessellator = 2 ;
}

if (__1o_nurbscurve -> used__12O_nurbscurve ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 23 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}
else __1o_nurbscurve -> used__12O_nurbscurve = 1 ;

if (__0this -> currentCurve__16NurbsTessellator -> curvetype__7O_curve == 2){ 
__0this -> currentCurve__16NurbsTessellator -> curvetype__7O_curve = 0;
}
else 
if (__0this -> currentCurve__16NurbsTessellator -> curvetype__7O_curve != 0){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 24 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}

if (((*__0this -> nextNurbscurve__16NurbsTessellator ))!= __1o_nurbscurve ){ 
__0this -> isCurveModified__16NurbsTessellator = 1 ;
((*__0this -> nextNurbscurve__16NurbsTessellator ))= __1o_nurbscurve ;
}

__0this -> nextNurbscurve__16NurbsTessellator = (& __1o_nurbscurve -> next__12O_nurbscurve );

if (__1o_nurbscurve -> owner__12O_nurbscurve != __0this -> currentCurve__16NurbsTessellator ){ 
__0this -> isCurveModified__16NurbsTessellator = 1 ;
__1o_nurbscurve -> owner__12O_nurbscurve = __0this -> currentCurve__16NurbsTessellator ;
}

if (__1o_nurbscurve -> owner__12O_nurbscurve == 0 )
__0this -> isCurveModified__16NurbsTessellator = 1 ;

if (__0this -> inCurve__16NurbsTessellator == 2 )
__glendcurve__16NurbsTessellat0 ( __0this ) ;
}


void __gldo_freenurbssurface__16Nur0 (struct NurbsTessellator *__0this , struct O_nurbssurface *__1o_nurbssurface )
{ 
__gldeleteMe__5QuiltFR4Pool ( (struct Quilt *)__1o_nurbssurface -> bezier_patches__14O_nurbssurface , (struct Pool *)(& __0this -> quiltPool__16NurbsTessellator )) ;

( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1o_nurbssurface )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(&
__0this -> o_nurbssurfacePool__16NurbsTessellator )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> o_nurbssurfacePool__16NurbsTessellator )))-> freelist__4Pool = (((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1o_nurbssurface )))))))))
) ) ;
}

void __gldo_nurbssurface__16NurbsTe0 (struct NurbsTessellator *__0this , struct O_nurbssurface *__1o_nurbssurface )
{ 
if (! __0this -> inSurface__16NurbsTessellator ){ 
__glbgnsurface__16NurbsTessell0 ( __0this , (long )0 ) ;

__0this -> inSurface__16NurbsTessellator = 2 ;
}

if (__1o_nurbssurface -> used__14O_nurbssurface ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , 25 ) ;
__0this -> isDataValid__16NurbsTessellator = 0 ;
return ;
}
else __1o_nurbssurface -> used__14O_nurbssurface = 1 ;

if (((*__0this -> nextNurbssurface__16NurbsTessellator ))!= __1o_nurbssurface ){ 
__0this -> isSurfaceModified__16NurbsTessellator = 1 ;
((*__0this -> nextNurbssurface__16NurbsTessellator ))= __1o_nurbssurface ;
}

if (__1o_nurbssurface -> owner__14O_nurbssurface != __0this -> currentSurface__16NurbsTessellator ){ 
__0this -> isSurfaceModified__16NurbsTessellator = 1 ;
__1o_nurbssurface -> owner__14O_nurbssurface = __0this -> currentSurface__16NurbsTessellator ;
}
__0this -> nextNurbssurface__16NurbsTessellator = (& __1o_nurbssurface -> next__14O_nurbssurface );

if (__0this -> inSurface__16NurbsTessellator == 2 )
__glendsurface__16NurbsTessell0 ( __0this ) ;
}


void __gldo_freenurbsproperty__16Nu0 (struct NurbsTessellator *__0this , struct Property *__1prop )
{ 
( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct
PooledObj *)__1prop )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> propertyPool__16NurbsTessellator )))-> freelist__4Pool =
(((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1prop ))))))))) ) ) ;
}

void __glsetProperty__11Renderhints0 (struct Renderhints *, long , REAL );

void __gldo_setnurbsproperty__16Nur0 (struct NurbsTessellator *__0this , struct Property *__1prop )
{ 
__glsetProperty__11Renderhints0 ( (struct Renderhints *)(& __0this -> renderhints__16NurbsTessellator ), __1prop -> tag__8Property , __1prop -> value__8Property )
;
if (__1prop -> save__8Property == 0 )
__gldo_freenurbsproperty__16Nu0 ( __0this , __1prop ) ;
}

struct Mapdesc *__glfind__7MaplistFl (struct Maplist *, long );

void __glsetProperty__7MapdescFlf (struct Mapdesc *, long , REAL );

void __gldo_setnurbsproperty2__16Nu0 (struct NurbsTessellator *__0this , struct Property *__1prop )
{ 
struct Mapdesc *__1mapdesc ;

__1mapdesc = __glfind__7MaplistFl ( (struct Maplist *)(& __0this -> maplist__16NurbsTessellator ), __1prop -> type__8Property ) ;

__glsetProperty__7MapdescFlf ( (struct Mapdesc *)__1mapdesc , __1prop -> tag__8Property , __1prop -> value__8Property ) ;
if (__1prop -> save__8Property == 0 )
__gldo_freenurbsproperty__16Nu0 ( __0this , __1prop ) ;
}


void __glerrorHandler__16NurbsTesse0 (struct NurbsTessellator *__0this , int __1__A15 )
{ 
}

void __gldo_nurbserror__16NurbsTess0 (struct NurbsTessellator *__0this , int __1msg )
{ 
((*(((void (*)(struct NurbsTessellator *, int
))(__0this -> __vptr__16NurbsTessellator [5]).f))))( ((struct NurbsTessellator *)((((char *)__0this ))+ (__0this -> __vptr__16NurbsTessellator [5]).d)), __1msg ) ;
}

int __glvalidate__10KnotvectorFv (struct Knotvector *);
void __glshow__10KnotvectorFPc (struct Knotvector *, char *);

int __gldo_check_knots__16NurbsTes0 (struct NurbsTessellator *__0this , struct Knotvector *__1knots , char *__1msg )
{ 
int __1status ;

__1status = __glvalidate__10KnotvectorFv ( (struct Knotvector *)__1knots ) ;
if (__1status ){ 
__gldo_nurbserror__16NurbsTess0 ( __0this , __1status ) ;
if (__0this -> renderhints__16NurbsTessellator . errorchecking__11Renderhints != 0.0 )__glshow__10KnotvectorFPc ( (struct Knotvector *)__1knots , __1msg ) ;
}
return __1status ;
}
struct __mptr __gl__vtbl__16NurbsTessellator[] = {0,0,0,
0,0,(__vptp)__glbgnrender__16NurbsTessella0 ,
0,0,(__vptp)__glendrender__16NurbsTessella0 ,
0,0,(__vptp)__glmakeobj__16NurbsTessellato0 ,
0,0,(__vptp)__glcloseobj__16NurbsTessellat0 ,
0,0,(__vptp)__glerrorHandler__16NurbsTesse0 ,
0,0,0};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\reader.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/reader.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);











struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

enum Curvetype { ct_nurbscurve = 0, ct_pwlcurve = 1, ct_none = 2} ;
struct Property;

struct O_surface;

struct O_nurbssurface;

struct O_trim;

struct O_pwlcurve;

struct O_nurbscurve;

struct O_curve;

struct Quilt;

struct TrimVertex;

union __Q2_7O_curve4__C1;

union  __Q2_7O_curve4__C1 {	
struct O_nurbscurve *o_nurbscurve ;
struct O_pwlcurve *o_pwlcurve ;
};


struct O_curve;

struct O_curve {	

char __W3__9PooledObj ;

union  __Q2_7O_curve4__C1 curve__7O_curve ;
int curvetype__7O_curve ;
struct O_curve *next__7O_curve ;
struct O_surface *owner__7O_curve ;
int used__7O_curve ;
int save__7O_curve ;
long nuid__7O_curve ;
};






struct O_nurbscurve;

struct O_nurbscurve {	

char __W3__9PooledObj ;

struct Quilt *bezier_curves__12O_nurbscurve ;
long type__12O_nurbscurve ;
REAL tesselation__12O_nurbscurve ;
int method__12O_nurbscurve ;
struct O_nurbscurve *next__12O_nurbscurve ;
int used__12O_nurbscurve ;
int save__12O_nurbscurve ;
struct O_curve *owner__12O_nurbscurve ;
};






struct O_pwlcurve;



struct O_pwlcurve {	

char __W3__9PooledObj ;

struct TrimVertex *pts__10O_pwlcurve ;
int npts__10O_pwlcurve ;
struct O_pwlcurve *next__10O_pwlcurve ;
int used__10O_pwlcurve ;
int save__10O_pwlcurve ;
struct O_curve *owner__10O_pwlcurve ;
};



struct O_trim;

struct O_trim {	

char __W3__9PooledObj ;

struct O_curve *o_curve__6O_trim ;
struct O_trim *next__6O_trim ;
int save__6O_trim ;
};






struct O_nurbssurface;

struct O_nurbssurface {	

char __W3__9PooledObj ;

struct Quilt *bezier_patches__14O_nurbssurface ;
long type__14O_nurbssurface ;
struct O_surface *owner__14O_nurbssurface ;
struct O_nurbssurface *next__14O_nurbssurface ;
int save__14O_nurbssurface ;
int used__14O_nurbssurface ;
};






struct O_surface;

struct O_surface {	

char __W3__9PooledObj ;

struct O_nurbssurface *o_nurbssurface__9O_surface ;
struct O_trim *o_trim__9O_surface ;
int save__9O_surface ;
long nuid__9O_surface ;
};






struct Property;

struct Property {	

char __W3__9PooledObj ;

long type__8Property ;
long tag__8Property ;
REAL value__8Property ;
int save__8Property ;
};




struct NurbsTessellator;




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

extern struct __mptr* __ptbl_vec_____core_reader_c_____ct_[];


struct O_pwlcurve *__gl__ct__10O_pwlcurveFlT1PfT10 (struct O_pwlcurve *__0this , long __1_type , long __1count , float *__1array , long __1byte_stride , struct TrimVertex *__1trimpts )
{ 
__0this ->
next__10O_pwlcurve = 0 ;
__0this -> used__10O_pwlcurve = 0 ;
__0this -> owner__10O_pwlcurve = 0 ;
__0this -> pts__10O_pwlcurve = __1trimpts ;
__0this -> npts__10O_pwlcurve = (((int )__1count ));

switch (__1_type ){ 
case 0x8 :{ 
struct TrimVertex *__3v ;

__3v = __0this -> pts__10O_pwlcurve ;
{ { struct TrimVertex *__3lastv ;

__3lastv = (__3v + __1count );

for(;__3v != __3lastv ;__3v ++ ) { 
(__3v -> param__10TrimVertex [0 ])= (((float )(__1array [0 ])));
(__3v -> param__10TrimVertex [1 ])= (((float )(__1array [1 ])));
__1array = (((float *)((((char *)__1array ))+ __1byte_stride )));
}
break ;

}

}
}
case 0xd :{ 
struct TrimVertex *__3v ;

__3v = __0this -> pts__10O_pwlcurve ;
{ { struct TrimVertex *__3lastv ;

__3lastv = (__3v + __1count );

for(;__3v != __3lastv ;__3v ++ ) { 
(__3v -> param__10TrimVertex [0 ])= ((((float )(__1array [0 ])))/ (((float )(__1array [2 ]))));
(__3v -> param__10TrimVertex [1 ])= ((((float )(__1array [1 ])))/ (((float )(__1array [2 ]))));
__1array = (((float *)((((char *)__1array ))+ __1byte_stride )));
}
break ;

}

}
}
}
return __0this ;

}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\quilt.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/quilt.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);











struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct Backend;

struct Mapdesc;

struct Flist;

struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;





struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;



struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};









typedef REAL Maxmatrix [5][5];



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};


void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);













struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};




struct Knotvector;

struct Knotvector {	

long order__10Knotvector ;
long knotcount__10Knotvector ;
long stride__10Knotvector ;
Knot *knotlist__10Knotvector ;
};








struct Pspec;

struct Pspec {	
REAL range__5Pspec [3];
REAL sidestep__5Pspec [2];
REAL stepsize__5Pspec ;
REAL minstepsize__5Pspec ;
int needsSubdivision__5Pspec ;
};
struct Patchspec;

struct Patchspec {	

REAL range__5Pspec [3];
REAL sidestep__5Pspec [2];
REAL stepsize__5Pspec ;
REAL minstepsize__5Pspec ;
int needsSubdivision__5Pspec ;

int order__9Patchspec ;
int stride__9Patchspec ;
};
struct Patch;

struct Patch {	

struct Mapdesc *mapdesc__5Patch ;
struct Patch *next__5Patch ;
int cullval__5Patch ;
int notInBbox__5Patch ;
int needsSampling__5Patch ;
REAL cpts__5Patch [2880];
REAL spts__5Patch [2880];
REAL bpts__5Patch [2880];
struct Patchspec pspec__5Patch [2];

REAL bb__5Patch [2][5];
};


struct Patchlist;

struct Patchlist {	

struct Patch *patch__9Patchlist ;
int notInBbox__9Patchlist ;
int needsSampling__9Patchlist ;
struct Pspec pspec__9Patchlist [2];
};

extern struct __mptr* __ptbl_vec_____core_quilt_c_____ct_[];


struct Quilt *__gl__ct__5QuiltFP7Mapdesc (struct Quilt *__0this , struct Mapdesc *__1_mapdesc )
{ 
__0this -> mapdesc__5Quilt = __1_mapdesc ;
return __0this ;

}

void __gldeleteMe__5QuiltFR4Pool (struct Quilt *, struct Pool *);



void __gldeleteMe__5QuiltFR4Pool (struct Quilt *__0this , struct Pool *__1p )
{ 
{ { struct Quiltspec *__1q ;

void *__1__X9 ;

__1q = __0this -> qspec__5Quilt ;

for(;__1q != __0this -> eqspec__5Quilt ;__1q ++ ) { 
void *__1__X8 ;

if (__1q -> breakpoints__9Quiltspec )( (__1__X8 = (void *)__1q -> breakpoints__9Quiltspec ), ( (__1__X8 ?( free ( __1__X8 ) , 0 ) :(
0 ) )) ) ;

__1q -> breakpoints__9Quiltspec = 0 ;
}
if (__0this -> cpts__5Quilt )( (__1__X9 = (void *)__0this -> cpts__5Quilt ), ( (__1__X9 ?( free ( __1__X9 ) , 0 ) :(
0 ) )) ) ;
__0this -> cpts__5Quilt = 0 ;
( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__0this )))))))-> next__6Buffer = ((struct Pool *)__1p )-> freelist__4Pool ),
(((struct Pool *)__1p )-> freelist__4Pool = (((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__0this ))))))))) ) ) ;

}

}
}

void __glshow__5QuiltFv (struct Quilt *__0this )
{ 
}

void __glselect__5QuiltFPfT1 (struct Quilt *__0this , REAL *__1pta , REAL *__1ptb )
{ 
int __1dim ;

__1dim = (__0this -> eqspec__5Quilt - __0this -> qspec__5Quilt );
{ { int __1i ;

__1i = 0 ;

for(;__1i < __1dim ;__1i ++ ) { 
{ { int __2j ;

__2j = ((__0this -> qspec__5Quilt [__1i ]). width__9Quiltspec - 1 );

for(;__2j >= 0 ;__2j -- ) 
if ((((__0this -> qspec__5Quilt [__1i ]). breakpoints__9Quiltspec [__2j ])<= (__1pta [__1i ]))&& ((__1ptb [__1i ])<= ((__0this -> qspec__5Quilt [__1i ]). breakpoints__9Quiltspec [(__2j + 1 )])))
break ;

((void )0 );
(__0this -> qspec__5Quilt [__1i ]). index__9Quiltspec = __2j ;

}

}
}

}

}
}


void __glsurfpts__7BackendFlPfN21iT0 (struct Backend *, long , REAL *, long , long , int , int ,
REAL , REAL , REAL , REAL );


void __glcurvpts__7BackendFlPfT1ifT0 (struct Backend *, long , REAL *, long , int , REAL , REAL );


void __gldownload__5QuiltFR7Backend (struct Quilt *__0this , struct Backend *__1backend )
{ 
if (( (__0this -> eqspec__5Quilt - __0this -> qspec__5Quilt )) == 2 ){ 
REAL *__2ps ;
__2ps = __0this -> cpts__5Quilt ;
__2ps += (__0this -> qspec__5Quilt [0 ]). offset__9Quiltspec ;
__2ps += (__0this -> qspec__5Quilt [1 ]). offset__9Quiltspec ;
__2ps += (((__0this -> qspec__5Quilt [0 ]). index__9Quiltspec * (__0this -> qspec__5Quilt [0 ]). order__9Quiltspec )* (__0this -> qspec__5Quilt [0 ]). stride__9Quiltspec );
__2ps += (((__0this -> qspec__5Quilt [1 ]). index__9Quiltspec * (__0this -> qspec__5Quilt [1 ]). order__9Quiltspec )* (__0this -> qspec__5Quilt [1 ]). stride__9Quiltspec );

__glsurfpts__7BackendFlPfN21iT0 ( (struct Backend *)__1backend , ( ((struct Mapdesc *)__0this -> mapdesc__5Quilt )-> type__7Mapdesc ) , __2ps , (long )(__0this -> qspec__5Quilt [0 ]). stride__9Quiltspec ,
(long )(__0this -> qspec__5Quilt [1 ]). stride__9Quiltspec , (__0this -> qspec__5Quilt [0 ]). order__9Quiltspec , (__0this -> qspec__5Quilt [1 ]). order__9Quiltspec , (__0this -> qspec__5Quilt [0 ]). breakpoints__9Quiltspec [(__0this -> qspec__5Quilt [0 ]).
index__9Quiltspec ], (__0this -> qspec__5Quilt [0 ]). breakpoints__9Quiltspec [((__0this -> qspec__5Quilt [0 ]). index__9Quiltspec + 1 )], (__0this -> qspec__5Quilt [1 ]). breakpoints__9Quiltspec [(__0this -> qspec__5Quilt [1 ]). index__9Quiltspec ], (__0this -> qspec__5Quilt [1 ]).
breakpoints__9Quiltspec [((__0this -> qspec__5Quilt [1 ]). index__9Quiltspec + 1 )]) ;
}
else 
{ 
REAL *__2ps ;

__2ps = __0this -> cpts__5Quilt ;
__2ps += (__0this -> qspec__5Quilt [0 ]). offset__9Quiltspec ;
__2ps += (((__0this -> qspec__5Quilt [0 ]). index__9Quiltspec * (__0this -> qspec__5Quilt [0 ]). order__9Quiltspec )* (__0this -> qspec__5Quilt [0 ]). stride__9Quiltspec );

__glcurvpts__7BackendFlPfT1ifT0 ( (struct Backend *)__1backend , ( ((struct Mapdesc *)__0this -> mapdesc__5Quilt )-> type__7Mapdesc ) , __2ps , (long )(__0this -> qspec__5Quilt [0 ]). stride__9Quiltspec ,
(__0this -> qspec__5Quilt [0 ]). order__9Quiltspec , (__0this -> qspec__5Quilt [0 ]). breakpoints__9Quiltspec [(__0this -> qspec__5Quilt [0 ]). index__9Quiltspec ], (__0this -> qspec__5Quilt [0 ]). breakpoints__9Quiltspec [((__0this -> qspec__5Quilt [0 ]). index__9Quiltspec + 1 )])
;
}
}

void __gldownloadAll__5QuiltFPfT1R70 (struct Quilt *__0this , REAL *__1pta , REAL *__1ptb , struct Backend *__1backend )
{ 
{ { struct Quilt *__1m ;

__1m = (struct Quilt *)__0this ;

for(;__1m ;__1m = __1m -> next__5Quilt ) { 
__glselect__5QuiltFPfT1 ( (struct Quilt *)__1m , __1pta , __1ptb ) ;
__gldownload__5QuiltFR7Backend ( (struct Quilt *)__1m , __1backend ) ;
}

}

}
}


int __glxformAndCullCheck__7Mapdes0 (struct Mapdesc *, REAL *, int , int , int , int );

int __glisCulled__5QuiltFv (struct Quilt *__0this )
{ 
if (( ((((struct Mapdesc *)__0this -> mapdesc__5Quilt )-> culling_method__7Mapdesc != 0.0 )?1 :0 )) )
return __glxformAndCullCheck__7Mapdes0 ( (struct Mapdesc *)__0this ->
mapdesc__5Quilt , (__0this -> cpts__5Quilt + (__0this -> qspec__5Quilt [0 ]). offset__9Quiltspec )+ (__0this -> qspec__5Quilt [1 ]). offset__9Quiltspec , (__0this -> qspec__5Quilt [0 ]). order__9Quiltspec * (__0this -> qspec__5Quilt [0 ]).
width__9Quiltspec , (__0this -> qspec__5Quilt [0 ]). stride__9Quiltspec , (__0this -> qspec__5Quilt [1 ]). order__9Quiltspec * (__0this -> qspec__5Quilt [1 ]). width__9Quiltspec , (__0this -> qspec__5Quilt [1 ]). stride__9Quiltspec ) ;
else 
return 2 ;
}

void __glgetRange__5QuiltFPfT1iR5Fl0 (struct Quilt *, REAL *, REAL *, int , struct Flist *);

void __glgetRange__5QuiltFPfT1R5Fli0 (struct Quilt *__0this , REAL *__1from , REAL *__1to , struct Flist *__1slist , struct Flist *__1tlist )
{ 
__glgetRange__5QuiltFPfT1iR5Fl0 ( __0this , __1from , __1to , 0 ,
__1slist ) ;
__glgetRange__5QuiltFPfT1iR5Fl0 ( __0this , __1from , __1to , 1 , __1tlist ) ;
}

void __glgrow__5FlistFi (struct Flist *, int );

void __gladd__5FlistFf (struct Flist *, REAL );
void __glfilter__5FlistFv (struct Flist *);

void __gltaper__5FlistFfT1 (struct Flist *, REAL , REAL );

void __glgetRange__5QuiltFPfT1iR5Fl0 (struct Quilt *__0this , REAL *__1from , REAL *__1to , int __1i , struct Flist *__1list )
{ 
struct Quilt *__1maps ;

__1maps = (struct Quilt *)__0this ;
(__1from [__1i ])= ((__1maps -> qspec__5Quilt [__1i ]). breakpoints__9Quiltspec [0 ]);
(__1to [__1i ])= ((__1maps -> qspec__5Quilt [__1i ]). breakpoints__9Quiltspec [(__1maps -> qspec__5Quilt [__1i ]). width__9Quiltspec ]);
{ int __1maxpts ;

__1maxpts = 0 ;
{ { Quilt_ptr __1m ;

__1m = __1maps ;

for(;__1m ;__1m = __1m -> next__5Quilt ) { 
if (((__1m -> qspec__5Quilt [__1i ]). breakpoints__9Quiltspec [0 ])> (__1from [__1i ]))
(__1from [__1i ])= ((__1m -> qspec__5Quilt [__1i ]). breakpoints__9Quiltspec [0 ]);
if (((__1m -> qspec__5Quilt [__1i ]). breakpoints__9Quiltspec [(__1m -> qspec__5Quilt [__1i ]). width__9Quiltspec ])< (__1to [__1i ]))
(__1to [__1i ])= ((__1m -> qspec__5Quilt [__1i ]). breakpoints__9Quiltspec [(__1m -> qspec__5Quilt [__1i ]). width__9Quiltspec ]);
__1maxpts += ((__1m -> qspec__5Quilt [__1i ]). width__9Quiltspec + 1 );
}

__glgrow__5FlistFi ( (struct Flist *)__1list , __1maxpts ) ;

for(__1m = __1maps ;__1m ;__1m = __1m -> next__5Quilt ) 
{ { int __1j ;

__1j = 0 ;

for(;__1j <= (__1m -> qspec__5Quilt [__1i ]). width__9Quiltspec ;__1j ++ ) { 
__gladd__5FlistFf ( (struct Flist *)__1list , (__1m -> qspec__5Quilt [__1i ]). breakpoints__9Quiltspec [__1j ]) ;
}

}

}

__glfilter__5FlistFv ( (struct Flist *)__1list ) ;
__gltaper__5FlistFfT1 ( (struct Flist *)__1list , __1from [__1i ], __1to [__1i ]) ;

}

}

}
}

void __glgetRange__5QuiltFPfT1R5Fli1 (struct Quilt *__0this , REAL *__1from , REAL *__1to , struct Flist *__1slist )
{ 
__glgetRange__5QuiltFPfT1iR5Fl0 ( __0this , __1from , __1to , 0 , __1slist ) ;

}

void __glfindSampleRates__5QuiltFR50 (struct Quilt *, struct Flist *, struct Flist *);

void __glfindRates__5QuiltFR5FlistT0 (struct Quilt *__0this , struct Flist *__1slist , struct Flist *__1tlist , REAL *__1rate )
{ 
__glfindSampleRates__5QuiltFR50 ( __0this , __1slist , __1tlist ) ;
(__1rate [0 ])= (__0this -> qspec__5Quilt [0 ]). step_size__9Quiltspec ;
(__1rate [1 ])= (__0this -> qspec__5Quilt [1 ]). step_size__9Quiltspec ;

{ { struct Quilt *__1q ;

__1q = __0this -> next__5Quilt ;

for(;__1q ;__1q = __1q -> next__5Quilt ) { 
__glfindSampleRates__5QuiltFR50 ( (struct Quilt *)__1q , __1slist , __1tlist ) ;
if ((__1q -> qspec__5Quilt [0 ]). step_size__9Quiltspec < (__1rate [0 ]))
(__1rate [0 ])= (__1q -> qspec__5Quilt [0 ]). step_size__9Quiltspec ;
if ((__1q -> qspec__5Quilt [1 ]). step_size__9Quiltspec < (__1rate [1 ]))
(__1rate [1 ])= (__1q -> qspec__5Quilt [1 ]). step_size__9Quiltspec ;
}

}

}
}

struct Patchlist *__gl__ct__9PatchlistFP5QuiltPf0 (struct Patchlist *, struct Quilt *, REAL *, REAL *);

void __glgetstepsize__9PatchlistFv (struct Patchlist *);


void __gl__dt__9PatchlistFv (struct Patchlist *, int );

void __glfindSampleRates__5QuiltFR50 (struct Quilt *__0this , struct Flist *__1slist , struct Flist *__1tlist )
{ 
(__0this -> qspec__5Quilt [0 ]). step_size__9Quiltspec = (.2 * (((__0this -> qspec__5Quilt [0 ]). breakpoints__9Quiltspec [(__0this ->
qspec__5Quilt [0 ]). width__9Quiltspec ])- ((__0this -> qspec__5Quilt [0 ]). breakpoints__9Quiltspec [0 ])));

(__0this -> qspec__5Quilt [1 ]). step_size__9Quiltspec = (.2 * (((__0this -> qspec__5Quilt [1 ]). breakpoints__9Quiltspec [(__0this -> qspec__5Quilt [1 ]). width__9Quiltspec ])- ((__0this -> qspec__5Quilt [1 ]). breakpoints__9Quiltspec [0 ])));

{ { int __1i ;

__1i = ((*__1slist )). start__5Flist ;

for(;__1i < (((*__1slist )). end__5Flist - 1 );__1i ++ ) { 
{ { int __2j ;

__2j = ((*__1tlist )). start__5Flist ;

for(;__2j < (((*__1tlist )). end__5Flist - 1 );__2j ++ ) { 
REAL __3pta [2];

REAL __3ptb [2];
(__3pta [0 ])= (((*__1slist )). pts__5Flist [__1i ]);
(__3ptb [0 ])= (((*__1slist )). pts__5Flist [(__1i + 1 )]);
(__3pta [1 ])= (((*__1tlist )). pts__5Flist [__2j ]);
(__3ptb [1 ])= (((*__1tlist )). pts__5Flist [(__2j + 1 )]);
{ struct Patchlist __3patchlist ;

__gl__ct__9PatchlistFP5QuiltPf0 ( (struct Patchlist *)(& __3patchlist ), (struct Quilt *)__0this , (float *)__3pta , (float *)__3ptb ) ;
__glgetstepsize__9PatchlistFv ( (struct Patchlist *)(& __3patchlist )) ;

if (( (((struct Patchlist *)(& __3patchlist ))-> pspec__9Patchlist [0 ]). stepsize__5Pspec ) < (__0this -> qspec__5Quilt [0 ]). step_size__9Quiltspec )
(__0this -> qspec__5Quilt [0 ]). step_size__9Quiltspec = (
(((struct Patchlist *)(& __3patchlist ))-> pspec__9Patchlist [0 ]). stepsize__5Pspec ) ;
if (( (((struct Patchlist *)(& __3patchlist ))-> pspec__9Patchlist [1 ]). stepsize__5Pspec ) < (__0this -> qspec__5Quilt [1 ]). step_size__9Quiltspec )
(__0this -> qspec__5Quilt [1 ]). step_size__9Quiltspec = (
(((struct Patchlist *)(& __3patchlist ))-> pspec__9Patchlist [1 ]). stepsize__5Pspec ) ;

__gl__dt__9PatchlistFv ( (struct Patchlist *)(& __3patchlist ), 2) ;

}
}

}

}
}

}

}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\renderhi.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/renderhints.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);






typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct Renderhints;

struct Renderhints {	

REAL display_method__11Renderhints ;
REAL errorchecking__11Renderhints ;
REAL subdivisions__11Renderhints ;
REAL tmp1__11Renderhints ;

int displaydomain__11Renderhints ;
int maxsubdivisions__11Renderhints ;
int wiretris__11Renderhints ;
int wirequads__11Renderhints ;
};







extern struct __mptr* __ptbl_vec_____core_renderhints_c_____ct_[];


struct Renderhints *__gl__ct__11RenderhintsFv (struct Renderhints *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Renderhints *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Renderhints))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> display_method__11Renderhints = 1.0 ;
__0this -> errorchecking__11Renderhints = 1.0 ;
__0this -> subdivisions__11Renderhints = 6.0 ;
__0this -> tmp1__11Renderhints = 0.0 ;
} return __0this ;

}

void __glinit__11RenderhintsFv (struct Renderhints *__0this )
{ 
__0this -> maxsubdivisions__11Renderhints = (((int )__0this -> subdivisions__11Renderhints ));
if (__0this -> maxsubdivisions__11Renderhints < 0 )__0this -> maxsubdivisions__11Renderhints = 0 ;

if (__0this -> display_method__11Renderhints == 1.0 ){ 
__0this -> wiretris__11Renderhints = 0 ;
__0this -> wirequads__11Renderhints = 0 ;
}
else 
if (__0this -> display_method__11Renderhints == 3.0 ){ 
__0this -> wiretris__11Renderhints = 1 ;
__0this -> wirequads__11Renderhints = 0 ;
}
else 
if (__0this -> display_method__11Renderhints == 4.0 ){ 
__0this -> wiretris__11Renderhints = 0 ;
__0this -> wirequads__11Renderhints = 1 ;
}
else 
{ 
__0this -> wiretris__11Renderhints = 1 ;
__0this -> wirequads__11Renderhints = 1 ;
}
}

int __glisProperty__11RenderhintsF0 (struct Renderhints *__0this , long __1property )
{ 
switch (__1property ){ 
case 3 :
case 4 :
case 5 :
case 9 :
return 1 ;
default :
return 0 ;
}
}

// extern void abort (void );

REAL __glgetProperty__11Renderhints0 (struct Renderhints *__0this , long __1property )
{ 
switch (__1property ){ 
case 3 :
return __0this -> display_method__11Renderhints ;
case 4 :
return __0this -> errorchecking__11Renderhints ;
case 5 :
return __0this -> subdivisions__11Renderhints ;
case 9 :
return __0this -> tmp1__11Renderhints ;
default :
abort ( ) ;
break ;

}
}

void __glsetProperty__11Renderhints0 (struct Renderhints *__0this , long __1property , REAL __1value )
{ 
switch (__1property ){ 
case 3 :
__0this -> display_method__11Renderhints = __1value ;
break ;
case 4 :
__0this -> errorchecking__11Renderhints = __1value ;
break ;
case 5 :
__0this -> subdivisions__11Renderhints = __1value ;
break ;
case 9 :
__0this -> tmp1__11Renderhints = __1value ;
break ;
default :
abort ( ) ;
break ;
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\sorter.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/sorter.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);



struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

extern struct __mptr* __gl__ptbl_vec_____core_sorter0[];


struct Sorter *__gl__ct__6SorterFi (struct Sorter *__0this , int __1_es )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Sorter *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Sorter))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){
__0this -> __vptr__6Sorter = (struct __mptr *) __gl__ptbl_vec_____core_sorter0[0];
__0this -> es__6Sorter = __1_es ;
} return __0this ;

}

void __glqs1__6SorterFPcT1 (struct Sorter *, char *, char *);

void __glqsort__6SorterFPvi (struct Sorter *__0this , void *__1a , int __1n )
{ 
__glqs1__6SorterFPcT1 ( __0this , ((char *)__1a ), (((char *)__1a ))+ (__1n *
__0this -> es__6Sorter )) ;
}


int __glqscmp__6SorterFPcT1 (struct Sorter *__0this , char *__1__A3 , char *__1__A4 )
{ 
( 0 ) ;
return 0 ;
}


void __glqsexc__6SorterFPcT1 (struct Sorter *__0this , char *__1__A5 , char *__1__A6 )
{ 
( 0 ) ;
}


void __glqstexc__6SorterFPcN21 (struct Sorter *__0this , char *__1__A7 , char *__1__A8 , char *__1__A9 )
{ 
( 0 ) ;
}

void __glqs1__6SorterFPcT1 (struct Sorter *__0this , char *__1a , char *__1l )
{ 
char *__1i ;

char *__1j ;
char *__1lp ;

char *__1hp ;
int __1c ;
unsigned int __1n ;

start :
if ((__1n = (__1l - __1a ))<= __0this -> es__6Sorter )
return ;
__1n = (__0this -> es__6Sorter * (__1n / (2 * __0this -> es__6Sorter )));
__1hp = (__1lp = (__1a + __1n ));
__1i = __1a ;
__1j = (__1l - __0this -> es__6Sorter );
while (1 ){ 
if (__1i < __1lp ){ 
if ((__1c = ((*(((int (*)(struct Sorter *, char *, char *))(__0this ->
__vptr__6Sorter [1]).f))))( ((struct Sorter *)((((char *)__0this ))+ (__0this -> __vptr__6Sorter [1]).d)), __1i , __1lp ) )== 0 ){ 
((*(((void (*)(struct Sorter *, char
*, char *))(__0this -> __vptr__6Sorter [2]).f))))( ((struct Sorter *)((((char *)__0this ))+ (__0this -> __vptr__6Sorter [2]).d)), __1i , __1lp -= __0this -> es__6Sorter ) ;

continue ;
}
if (__1c < 0 ){ 
__1i += __0this -> es__6Sorter ;
continue ;
}
}

loop :
if (__1j > __1hp ){ 
if ((__1c = ((*(((int (*)(struct Sorter *, char *, char *))(__0this -> __vptr__6Sorter [1]).f))))( ((struct
Sorter *)((((char *)__0this ))+ (__0this -> __vptr__6Sorter [1]).d)), __1hp , __1j ) )== 0 ){ 
((*(((void (*)(struct Sorter *, char *, char
*))(__0this -> __vptr__6Sorter [2]).f))))( ((struct Sorter *)((((char *)__0this ))+ (__0this -> __vptr__6Sorter [2]).d)), __1hp += __0this -> es__6Sorter , __1j ) ;
goto loop ;
}
if (__1c > 0 ){ 
if (__1i == __1lp ){ 
((*(((void (*)(struct Sorter *, char *, char *, char
*))(__0this -> __vptr__6Sorter [3]).f))))( ((struct Sorter *)((((char *)__0this ))+ (__0this -> __vptr__6Sorter [3]).d)), __1i , __1hp += __0this -> es__6Sorter , __1j ) ;
__1i = (__1lp += __0this -> es__6Sorter );
goto loop ;
}
((*(((void (*)(struct Sorter *, char *, char *))(__0this -> __vptr__6Sorter [2]).f))))( ((struct Sorter *)((((char *)__0this ))+ (__0this -> __vptr__6Sorter [2]).d)), __1i ,
__1j ) ;
__1j -= __0this -> es__6Sorter ;
__1i += __0this -> es__6Sorter ;
continue ;
}
__1j -= __0this -> es__6Sorter ;
goto loop ;
}

if (__1i == __1lp ){ 
if ((__1lp - __1a )>= (__1l - __1hp )){ 
__glqs1__6SorterFPcT1 ( __0this , __1hp + __0this -> es__6Sorter , __1l )
;
__1l = __1lp ;
}
else 
{ 
__glqs1__6SorterFPcT1 ( __0this , __1a , __1lp ) ;
__1a = (__1hp + __0this -> es__6Sorter );
}
goto start ;
}

((*(((void (*)(struct Sorter *, char *, char *, char *))(__0this -> __vptr__6Sorter [3]).f))))( ((struct Sorter *)((((char *)__0this ))+ (__0this ->
__vptr__6Sorter [3]).d)), __1j , __1lp -= __0this -> es__6Sorter , __1i ) ;
__1j = (__1hp -= __0this -> es__6Sorter );
}
}
struct __mptr __gl__vtbl__6Sorter[] = {0,0,0,
0,0,(__vptp)__glqscmp__6SorterFPcT1 ,
0,0,(__vptp)__glqsexc__6SorterFPcT1 ,
0,0,(__vptp)__glqstexc__6SorterFPcN21 ,
0,0,0};
struct __mptr* __gl__ptbl_vec_____core_sorter0[] = {
__gl__vtbl__6Sorter,

};


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\subdivid.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/subdivider.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct JumpBuffer;








struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};




struct Mapdesc;



struct BezierArc;



struct BezierArc {	

char __W3__9PooledObj ;

REAL *cpts__9BezierArc ;
int order__9BezierArc ;
int stride__9BezierArc ;
long type__9BezierArc ;
struct Mapdesc *mapdesc__9BezierArc ;
};




struct Renderhints;

struct Renderhints {	

REAL display_method__11Renderhints ;
REAL errorchecking__11Renderhints ;
REAL subdivisions__11Renderhints ;
REAL tmp1__11Renderhints ;

int displaydomain__11Renderhints ;
int maxsubdivisions__11Renderhints ;
int wiretris__11Renderhints ;
int wirequads__11Renderhints ;
};






struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};






typedef REAL Maxmatrix [5][5];



struct Mapdesc;



struct Mapdesc {	

char __W3__9PooledObj ;

REAL pixel_tolerance__7Mapdesc ;
REAL clampfactor__7Mapdesc ;
REAL minsavings__7Mapdesc ;
REAL maxrate__7Mapdesc ;
REAL maxsrate__7Mapdesc ;
REAL maxtrate__7Mapdesc ;
REAL bboxsize__7Mapdesc [5];

long type__7Mapdesc ;
int isrational__7Mapdesc ;
int ncoords__7Mapdesc ;
int hcoords__7Mapdesc ;
int inhcoords__7Mapdesc ;
int mask__7Mapdesc ;
Maxmatrix bmat__7Mapdesc ;
Maxmatrix cmat__7Mapdesc ;
Maxmatrix smat__7Mapdesc ;
REAL s_steps__7Mapdesc ;
REAL t_steps__7Mapdesc ;
REAL sampling_method__7Mapdesc ;
REAL culling_method__7Mapdesc ;
REAL bbox_subdividing__7Mapdesc ;
struct Mapdesc *next__7Mapdesc ;
struct Backend *backend__7Mapdesc ;
};


void __glcopy__7MapdescSFPA5_flPfN20 (REAL (*)[5], long , float *, long , long );

void __glxformRational__7MapdescFPA0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);
void __glxformNonrational__7Mapdesc0 (struct Mapdesc *, REAL (*)[5], REAL *, REAL *);












struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;







struct Pspec;

struct Pspec {	
REAL range__5Pspec [3];
REAL sidestep__5Pspec [2];
REAL stepsize__5Pspec ;
REAL minstepsize__5Pspec ;
int needsSubdivision__5Pspec ;
};
struct Patchspec;

struct Patchspec {	

REAL range__5Pspec [3];
REAL sidestep__5Pspec [2];
REAL stepsize__5Pspec ;
REAL minstepsize__5Pspec ;
int needsSubdivision__5Pspec ;

int order__9Patchspec ;
int stride__9Patchspec ;
};
struct Patch;

struct Patch {	

struct Mapdesc *mapdesc__5Patch ;
struct Patch *next__5Patch ;
int cullval__5Patch ;
int notInBbox__5Patch ;
int needsSampling__5Patch ;
REAL cpts__5Patch [2880];
REAL spts__5Patch [2880];
REAL bpts__5Patch [2880];
struct Patchspec pspec__5Patch [2];

REAL bb__5Patch [2][5];
};


struct Patchlist;

struct Patchlist {	

struct Patch *patch__9Patchlist ;
int notInBbox__9Patchlist ;
int needsSampling__9Patchlist ;
struct Pspec pspec__9Patchlist [2];
};






struct Slicer *__gl__ct__6SlicerFR7Backend (struct Slicer *, struct TrimRegion *, struct Backend *);

struct ArcTessellator *__gl__ct__14ArcTessellatorFR140 (struct ArcTessellator *, struct TrimVertexPool *, struct Pool *);

struct Pool *__gl__ct__4PoolFiT1Pc (struct Pool *, int , int , char *);
extern struct __mptr* __ptbl_vec_____core_subdivider_c_____ct_[];

struct TrimVertexPool *__gl__ct__14TrimVertexPoolFv (struct TrimVertexPool *);

struct Bin *__gl__ct__3BinFv (struct Bin *);

struct Flist *__gl__ct__5FlistFv (struct Flist *);


struct Subdivider *__gl__ct__10SubdividerFR11Rend0 (struct Subdivider *__0this , struct Renderhints *__1r , struct Backend *__1b )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Subdivider *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Subdivider))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))(
( ( ( ( ( ( ( ( ( ( ( __gl__ct__6SlicerFR7Backend ( (struct Slicer *)(&
__0this -> slicer__10Subdivider ), (struct TrimRegion *)0 , __1b ) , __gl__ct__14ArcTessellatorFR140 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), (struct TrimVertexPool *)(& __0this ->
trimvertexpool__10Subdivider ), (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) ) , __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> arcpool__10Subdivider ), (int )(sizeof
(struct Arc )), 1 , (char *)"arcpool") ) , __gl__ct__4PoolFiT1Pc ( (struct Pool *)(&
__0this -> bezierarcpool__10Subdivider ), (int )(sizeof (struct BezierArc )), 1 , (char *)"Bezarcpool") )
, __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> pwlarcpool__10Subdivider ), (int )(sizeof (struct PwlArc )), 1 , (char *)"Pwlarcpool")
) , __gl__ct__14TrimVertexPoolFv ( (struct TrimVertexPool *)(& __0this -> trimvertexpool__10Subdivider )) ) , (__0this -> renderhints__10Subdivider = __1r )) , (__0this ->
backend__10Subdivider = __1b )) , __gl__ct__3BinFv ( (struct Bin *)(& __0this -> initialbin__10Subdivider )) ) , __gl__ct__5FlistFv ( (struct Flist *)(& __0this ->
spbrkpts__10Subdivider )) ) , __gl__ct__5FlistFv ( (struct Flist *)(& __0this -> tpbrkpts__10Subdivider )) ) , __gl__ct__5FlistFv ( (struct Flist *)(& __0this ->
smbrkpts__10Subdivider )) ) , __gl__ct__5FlistFv ( (struct Flist *)(& __0this -> tmbrkpts__10Subdivider )) ) ;
return __0this ;

}

void __glsetJumpbuffer__10Subdivide0 (struct Subdivider *__0this , struct JumpBuffer *__1j )
{ 
__0this -> jumpbuffer__10Subdivider = __1j ;
}

void __glclear__14TrimVertexPoolFv (struct TrimVertexPool *);

void __glclear__4PoolFv (struct Pool *);

void __glclear__10SubdividerFv (struct Subdivider *__0this )
{ 
__glclear__14TrimVertexPoolFv ( (struct TrimVertexPool *)(& __0this -> trimvertexpool__10Subdivider )) ;
__glclear__4PoolFv ( (struct Pool *)(& __0this -> arcpool__10Subdivider )) ;
__glclear__4PoolFv ( (struct Pool *)(& __0this -> pwlarcpool__10Subdivider )) ;
__glclear__4PoolFv ( (struct Pool *)(& __0this -> bezierarcpool__10Subdivider )) ;
}

void __gl__dt__6SlicerFv (struct Slicer *, int );

void __gl__dt__14ArcTessellatorFv (struct ArcTessellator *, int );

void __gl__dt__4PoolFv (struct Pool *, int );

void __gl__dt__14TrimVertexPoolFv (struct TrimVertexPool *, int );

void __gl__dt__3BinFv (struct Bin *, int );

void __gl__dt__5FlistFv (struct Flist *, int );


void __gl__dt__10SubdividerFv (struct Subdivider *__0this , 
int __0__free )
{ if (__0this )
if (__0this ){ __gl__dt__5FlistFv ( (struct Flist *)(& __0this -> tmbrkpts__10Subdivider ), 2)
;

__gl__dt__5FlistFv ( (struct Flist *)(& __0this -> smbrkpts__10Subdivider ), 2) ;

__gl__dt__5FlistFv ( (struct Flist *)(& __0this -> tpbrkpts__10Subdivider ), 2) ;

__gl__dt__5FlistFv ( (struct Flist *)(& __0this -> spbrkpts__10Subdivider ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __0this -> initialbin__10Subdivider ), 2) ;

__gl__dt__14TrimVertexPoolFv ( (struct TrimVertexPool *)(& __0this -> trimvertexpool__10Subdivider ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> pwlarcpool__10Subdivider ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> bezierarcpool__10Subdivider ), 2) ;

__gl__dt__4PoolFv ( (struct Pool *)(& __0this -> arcpool__10Subdivider ), 2) ;

__gl__dt__14ArcTessellatorFv ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), 2) ;

__gl__dt__6SlicerFv ( (struct Slicer *)(& __0this -> slicer__10Subdivider ), 2) ;

if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) )) ;
} }



Arc_ptr __glappend__3ArcFP3Arc (struct Arc *, Arc_ptr );


void __gladdArc__10SubdividerFPfP5Q0 (struct Subdivider *__0this , REAL *__1cpts , struct Quilt *__1quilt , long __1_nuid )
{ 
struct BezierArc *__1bezierArc ;
struct Arc *__1jarc ;

struct BezierArc *__0__X13 ;

void *__1__Xbuffer00eohgaiaa ;

struct Arc *__0__X14 ;

__1bezierArc = (((struct BezierArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))-> freelist__4Pool ?(
( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))->
freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct
Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))) , 0 ) :(
0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))->
buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(& __0this ->
bezierarcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) ));
__1jarc = ((__0__X14 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X14 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X14 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X14 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X14 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X14 )-> type__3Arc |= ((((long )((int )0)))<< 8 )))
, ( (((struct Arc *)__0__X14 )-> nuid__3Arc = __1_nuid ), ((((struct Arc *)__0__X14 )))) ) ) ) ) :0 );
__1jarc -> pwlArc__3Arc = 0 ;
__1jarc -> bezierArc__3Arc = __1bezierArc ;
__1bezierArc -> order__9BezierArc = __1quilt -> qspec__5Quilt -> order__9Quiltspec ;
__1bezierArc -> stride__9BezierArc = __1quilt -> qspec__5Quilt -> stride__9Quiltspec ;
__1bezierArc -> mapdesc__9BezierArc = __1quilt -> mapdesc__5Quilt ;
__1bezierArc -> cpts__9BezierArc = __1cpts ;
( (__1jarc -> link__3Arc = ((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin ), (((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin = __1jarc ))
;
__0this -> pjarc__10Subdivider = __glappend__3ArcFP3Arc ( (struct Arc *)__1jarc , __0this -> pjarc__10Subdivider ) ;
}





void __gladdArc__10SubdividerFiP10T0 (struct Subdivider *__0this , int __1npts , struct TrimVertex *__1pts , long __1_nuid )
{ 
struct Arc *__1jarc ;

struct PwlArc *__0__X15 ;

void *__1__Xbuffer00eohgaiaa ;

struct Arc *__0__X16 ;

__1jarc = ((__0__X16 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X16 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X16 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X16 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X16 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X16 )-> type__3Arc |= ((((long )((int )0)))<< 8 )))
, ( (((struct Arc *)__0__X16 )-> nuid__3Arc = __1_nuid ), ((((struct Arc *)__0__X16 )))) ) ) ) ) :0 );
__1jarc -> pwlArc__3Arc = ((__0__X15 = (struct PwlArc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this ->
pwlarcpool__10Subdivider )))-> freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(&
__0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( (
((! ((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))) ,
0 ) :( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(&
__0this -> pwlarcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct
Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?(
(((struct PwlArc *)__0__X15 )-> pts__6PwlArc = __1pts ), ( (((struct PwlArc *)__0__X15 )-> npts__6PwlArc = __1npts ), ( (((struct PwlArc *)__0__X15 )-> type__6PwlArc = 0x8 ),
((((struct PwlArc *)__0__X15 )))) ) ) :0 );
( (__1jarc -> link__3Arc = ((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin ), (((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin = __1jarc ))
;
__0this -> pjarc__10Subdivider = __glappend__3ArcFP3Arc ( (struct Arc *)__1jarc , __0this -> pjarc__10Subdivider ) ;
}

void __glbeginQuilts__10SubdividerF0 (struct Subdivider *__0this )
{ 
__0this -> qlist__10Subdivider = 0 ;
}

void __gladdQuilt__10SubdividerFP5Q0 (struct Subdivider *__0this , struct Quilt *__1quilt )
{ 
__1quilt -> next__5Quilt = __0this -> qlist__10Subdivider ;
__0this -> qlist__10Subdivider = __1quilt ;
}

void __glinit__11RenderhintsFv (struct Renderhints *);

int __glisCulled__5QuiltFv (struct Quilt *);

void __glfreejarcs__10SubdividerFR30 (struct Subdivider *, struct Bin *);

void __glgetRange__5QuiltFPfT1R5Fli0 (struct Quilt *, REAL *, REAL *, struct Flist *, struct Flist *);


void __glmakeBorderTrim__10Subdivid0 (struct Subdivider *, REAL *, REAL *);

void __glfindRates__5QuiltFR5FlistT0 (struct Quilt *, struct Flist *, struct Flist *, REAL *);

int __gldecompose__10SubdividerFR30 (struct Subdivider *, struct Bin *, REAL );



void __glbgnsurf__7BackendFiT1l (struct Backend *, int , int , long );

void __glsubdivideInS__10Subdivider0 (struct Subdivider *, struct Bin *);

void __glendsurf__7BackendFv (struct Backend *);

void __gldrawSurfaces__10Subdivider0 (struct Subdivider *__0this , long __1nuid )
{ 
__glinit__11RenderhintsFv ( (struct Renderhints *)__0this -> renderhints__10Subdivider ) ;

if (__0this -> qlist__10Subdivider == 0 )return ;
{ { struct Quilt *__1q ;

__1q = __0this -> qlist__10Subdivider ;

for(;__1q ;__1q = __1q -> next__5Quilt ) { 
if (__glisCulled__5QuiltFv ( (struct Quilt *)__1q ) == 0 ){ 
__glfreejarcs__10SubdividerFR30 ( __0this , (struct Bin *)(&
__0this -> initialbin__10Subdivider )) ;
return ;
}
}

{ REAL __1from [2];

REAL __1to [2];
__glgetRange__5QuiltFPfT1R5Fli0 ( (struct Quilt *)__0this -> qlist__10Subdivider , (float *)__1from , (float *)__1to , (struct Flist *)(& __0this -> spbrkpts__10Subdivider ), (struct Flist *)(&
__0this -> tpbrkpts__10Subdivider )) ;

if (! ( (((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin ?1 :0 )) ){ 
__glmakeBorderTrim__10Subdivid0 ( __0this , (float *)__1from , (float
*)__1to ) ;
}
else 
{ 
REAL __2rate [2];
__glfindRates__5QuiltFR5FlistT0 ( (struct Quilt *)__0this -> qlist__10Subdivider , (struct Flist *)(& __0this -> spbrkpts__10Subdivider ), (struct Flist *)(& __0this -> tpbrkpts__10Subdivider ), (float *)__2rate )
;

if (__gldecompose__10SubdividerFR30 ( __0this , (struct Bin *)(& __0this -> initialbin__10Subdivider ), ( (((__2rate [0 ])> (__2rate [1 ]))?(__2rate [1 ]):(__2rate [0 ]))) ) )
mylongjmp ( __0this -> jumpbuffer__10Subdivider ,
31 ) ;
}

__glbgnsurf__7BackendFiT1l ( (struct Backend *)__0this -> backend__10Subdivider , ((*__0this -> renderhints__10Subdivider )). wiretris__11Renderhints , ((*__0this -> renderhints__10Subdivider )). wirequads__11Renderhints , __1nuid ) ;
__glsubdivideInS__10Subdivider0 ( __0this , (struct Bin *)(& __0this -> initialbin__10Subdivider )) ;
__glendsurf__7BackendFv ( (struct Backend *)__0this -> backend__10Subdivider ) ;

}

}

}
}

void __gloutline__10SubdividerFR3Bi0 (struct Subdivider *, struct Bin *);



void __glsplitInS__10SubdividerFR3B0 (struct Subdivider *, struct Bin *, int , int );

void __glsubdivideInS__10Subdivider0 (struct Subdivider *__0this , struct Bin *__1source )
{ 
if (((*__0this -> renderhints__10Subdivider )). display_method__11Renderhints == 6.0 ){ 
__gloutline__10SubdividerFR3Bi0 ( __0this , __1source ) ;

__glfreejarcs__10SubdividerFR30 ( __0this , __1source ) ;
}
else 
{ 
( (__0this -> isArcTypeBezier__10Subdivider = 1 )) ;
( (__0this -> showDegenerate__10Subdivider = 0 )) ;
__glsplitInS__10SubdividerFR3B0 ( __0this , __1source , __0this -> spbrkpts__10Subdivider . start__5Flist , __0this -> spbrkpts__10Subdivider . end__5Flist ) ;
}
}


void __glsplit__10SubdividerFR3BinN0 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, int , REAL );



void __glsplitInT__10SubdividerFR3B0 (struct Subdivider *, struct Bin *, int , int );

void __glsplitInS__10SubdividerFR3B0 (struct Subdivider *__0this , struct Bin *__1source , int __1start , int __1end )
{ 
if (( (((struct Bin *)__1source )-> head__3Bin ?1 :0 ))
){ 
if (__1start != __1end ){ 
int __3i ;
struct Bin __3left ;

struct Bin __3right ;

__3i = (__1start + ((__1end - __1start )/ 2 ));
__gl__ct__3BinFv ( (struct Bin *)(& __3left )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __3right )) ;
__glsplit__10SubdividerFR3BinN0 ( __0this , __1source , (struct Bin *)(& __3left ), (struct Bin *)(& __3right ), 0 , __0this -> spbrkpts__10Subdivider . pts__5Flist [__3i ]) ;

__glsplitInS__10SubdividerFR3B0 ( __0this , (struct Bin *)(& __3left ), __1start , __3i ) ;
__glsplitInS__10SubdividerFR3B0 ( __0this , (struct Bin *)(& __3right ), __3i + 1 , __1end ) ;

__gl__dt__3BinFv ( (struct Bin *)(& __3right ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __3left ), 2) ;
}
else 
{ 
if ((__1start == __0this -> spbrkpts__10Subdivider . start__5Flist )|| (__1start == __0this -> spbrkpts__10Subdivider . end__5Flist )){ 
__glfreejarcs__10SubdividerFR30 ( __0this , __1source )
;
}
else 
if (((*__0this -> renderhints__10Subdivider )). display_method__11Renderhints == 7.0 ){ 
__gloutline__10SubdividerFR3Bi0 ( __0this , __1source ) ;
__glfreejarcs__10SubdividerFR30 ( __0this , __1source ) ;
}
else 
{ 
( (__0this -> isArcTypeBezier__10Subdivider = 1 )) ;
( (__0this -> showDegenerate__10Subdivider = 0 )) ;
__0this -> s_index__10Subdivider = __1start ;
__glsplitInT__10SubdividerFR3B0 ( __0this , __1source , __0this -> tpbrkpts__10Subdivider . start__5Flist , __0this -> tpbrkpts__10Subdivider . end__5Flist ) ;
}
}
}
}




void __gldownloadAll__5QuiltFPfT1R70 (struct Quilt *, REAL *, REAL *, struct Backend *);

struct Patchlist *__gl__ct__9PatchlistFP5QuiltPf0 (struct Patchlist *, struct Quilt *, REAL *, REAL *);

void __glsamplingSplit__10Subdivide1 (struct Subdivider *, struct Bin *, struct Patchlist *, int , int );



void __gl__dt__9PatchlistFv (struct Patchlist *, int );

void __glsplitInT__10SubdividerFR3B0 (struct Subdivider *__0this , struct Bin *__1source , int __1start , int __1end )
{ 
if (( (((struct Bin *)__1source )-> head__3Bin ?1 :0 ))
){ 
if (__1start != __1end ){ 
int __3i ;
struct Bin __3left ;

struct Bin __3right ;

__3i = (__1start + ((__1end - __1start )/ 2 ));
__gl__ct__3BinFv ( (struct Bin *)(& __3left )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __3right )) ;
__glsplit__10SubdividerFR3BinN0 ( __0this , __1source , (struct Bin *)(& __3left ), (struct Bin *)(& __3right ), 1 , __0this -> tpbrkpts__10Subdivider . pts__5Flist [__3i ]) ;

__glsplitInT__10SubdividerFR3B0 ( __0this , (struct Bin *)(& __3left ), __1start , __3i ) ;
__glsplitInT__10SubdividerFR3B0 ( __0this , (struct Bin *)(& __3right ), __3i + 1 , __1end ) ;

__gl__dt__3BinFv ( (struct Bin *)(& __3right ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __3left ), 2) ;
}
else 
{ 
if ((__1start == __0this -> tpbrkpts__10Subdivider . start__5Flist )|| (__1start == __0this -> tpbrkpts__10Subdivider . end__5Flist )){ 
__glfreejarcs__10SubdividerFR30 ( __0this , __1source )
;
}
else 
if (((*__0this -> renderhints__10Subdivider )). display_method__11Renderhints == 8.0 ){ 
__gloutline__10SubdividerFR3Bi0 ( __0this , __1source ) ;
__glfreejarcs__10SubdividerFR30 ( __0this , __1source ) ;
}
else 
{ 
__0this -> t_index__10Subdivider = __1start ;
( (__0this -> isArcTypeBezier__10Subdivider = 1 )) ;
( (__0this -> showDegenerate__10Subdivider = 1 )) ;

{ REAL __4pta [2];

REAL __4ptb [2];
(__4pta [0 ])= (__0this -> spbrkpts__10Subdivider . pts__5Flist [(__0this -> s_index__10Subdivider - 1 )]);
(__4pta [1 ])= (__0this -> tpbrkpts__10Subdivider . pts__5Flist [(__0this -> t_index__10Subdivider - 1 )]);

(__4ptb [0 ])= (__0this -> spbrkpts__10Subdivider . pts__5Flist [__0this -> s_index__10Subdivider ]);
(__4ptb [1 ])= (__0this -> tpbrkpts__10Subdivider . pts__5Flist [__0this -> t_index__10Subdivider ]);
__gldownloadAll__5QuiltFPfT1R70 ( (struct Quilt *)__0this -> qlist__10Subdivider , (float *)__4pta , (float *)__4ptb , __0this -> backend__10Subdivider ) ;

{ struct Patchlist __4patchlist ;

__gl__ct__9PatchlistFP5QuiltPf0 ( (struct Patchlist *)(& __4patchlist ), __0this -> qlist__10Subdivider , (float *)__4pta , (float *)__4ptb ) ;
__glsamplingSplit__10Subdivide1 ( __0this , __1source , (struct Patchlist *)(& __4patchlist ), ((*__0this -> renderhints__10Subdivider )). maxsubdivisions__11Renderhints , 0 ) ;
( (__0this -> showDegenerate__10Subdivider = 0 )) ;
( (__0this -> isArcTypeBezier__10Subdivider = 1 )) ;

__gl__dt__9PatchlistFv ( (struct Patchlist *)(& __4patchlist ), 2) ;

}

}
}
}
}
}


int __glcullCheck__9PatchlistFv (struct Patchlist *);
void __glgetstepsize__9PatchlistFv (struct Patchlist *);

void __gltessellation__10Subdivider0 (struct Subdivider *, struct Bin *, struct Patchlist *);

int __glneedsSamplingSubdivision__3 (struct Patchlist *);
int __glneedsSubdivision__9Patchli0 (struct Patchlist *, int );

struct Patchlist *__gl__ct__9PatchlistFR9Patchli0 (struct Patchlist *, struct Patchlist *, int , REAL );



void __glnonSamplingSplit__10Subdiv0 (struct Subdivider *, struct Bin *, struct Patchlist *, int , int );



void __glsamplingSplit__10Subdivide1 (struct Subdivider *__0this , 
struct Bin *__1source , 
struct Patchlist *__1patchlist , 
int __1subdivisions , 
int __1param )
{ 
if (! (
(((struct Bin *)__1source )-> head__3Bin ?1 :0 )) )return ;

if (__glcullCheck__9PatchlistFv ( (struct Patchlist *)__1patchlist ) == 0 ){ 
__glfreejarcs__10SubdividerFR30 ( __0this , __1source ) ;
return ;
}

__glgetstepsize__9PatchlistFv ( (struct Patchlist *)__1patchlist ) ;

if (((*__0this -> renderhints__10Subdivider )). display_method__11Renderhints == 5.0 ){ 
__gltessellation__10Subdivider0 ( __0this , __1source , __1patchlist ) ;
__gloutline__10SubdividerFR3Bi0 ( __0this , __1source ) ;
__glfreejarcs__10SubdividerFR30 ( __0this , __1source ) ;
return ;
}

__gltessellation__10Subdivider0 ( __0this , __1source , __1patchlist ) ;

if (__glneedsSamplingSubdivision__3 ( (struct Patchlist *)__1patchlist ) && (__1subdivisions > 0 )){ 
if (! __glneedsSubdivision__9Patchli0 ( (struct Patchlist *)__1patchlist , 0 ) )
__1param =
1 ;
else if (! __glneedsSubdivision__9Patchli0 ( (struct Patchlist *)__1patchlist , 1 ) )
__1param = 0 ;
else 
__1param = (1 - __1param );

{ struct Bin __2left ;

struct Bin __2right ;
REAL __2mid ;

__gl__ct__3BinFv ( (struct Bin *)(& __2left )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __2right )) ;
__2mid = ((((((*__1patchlist )). pspec__9Patchlist [__1param ]). range__5Pspec [0 ])+ ((((*__1patchlist )). pspec__9Patchlist [__1param ]). range__5Pspec [1 ]))* 0.5 );

__glsplit__10SubdividerFR3BinN0 ( __0this , __1source , (struct Bin *)(& __2left ), (struct Bin *)(& __2right ), __1param , __2mid ) ;
{ struct Patchlist __2subpatchlist ;

__gl__ct__9PatchlistFR9Patchli0 ( (struct Patchlist *)(& __2subpatchlist ), __1patchlist , __1param , __2mid ) ;
__glsamplingSplit__10Subdivide1 ( __0this , (struct Bin *)(& __2left ), (struct Patchlist *)(& __2subpatchlist ), __1subdivisions - 1 , __1param ) ;
__glsamplingSplit__10Subdivide1 ( __0this , (struct Bin *)(& __2right ), __1patchlist , __1subdivisions - 1 , __1param ) ;

__gl__dt__9PatchlistFv ( (struct Patchlist *)(& __2subpatchlist ), 2) ;

}

__gl__dt__3BinFv ( (struct Bin *)(& __2right ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __2left ), 2) ;

}
}
else 
{ 
( (__0this -> isArcTypeBezier__10Subdivider = 0 )) ;
( (__0this -> showDegenerate__10Subdivider = 1 )) ;
__glnonSamplingSplit__10Subdiv0 ( __0this , __1source , __1patchlist , __1subdivisions , __1param ) ;
( (__0this -> showDegenerate__10Subdivider = 1 )) ;
( (__0this -> isArcTypeBezier__10Subdivider = 1 )) ;
}
}

int __glneedsNonSamplingSubdivisio1 (struct Patchlist *);


void __glbbox__9PatchlistFv (struct Patchlist *);

void __glpatch__7BackendFfN31 (struct Backend *, REAL , REAL , REAL , REAL );



void __glfindIrregularS__10Subdivid0 (struct Subdivider *, struct Bin *);

void __glmonosplitInS__10Subdivider0 (struct Subdivider *, struct Bin *, int , int );

void __glnonSamplingSplit__10Subdiv0 (struct Subdivider *__0this , 
struct Bin *__1source , 
struct Patchlist *__1patchlist , 
int __1subdivisions , 
int __1param )
{ 
if (__glneedsNonSamplingSubdivisio1 ( (struct
Patchlist *)__1patchlist ) && (__1subdivisions > 0 )){ 
__1param = (1 - __1param );

{ struct Bin __2left ;

struct Bin __2right ;
REAL __2mid ;

__gl__ct__3BinFv ( (struct Bin *)(& __2left )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __2right )) ;
__2mid = ((((((*__1patchlist )). pspec__9Patchlist [__1param ]). range__5Pspec [0 ])+ ((((*__1patchlist )). pspec__9Patchlist [__1param ]). range__5Pspec [1 ]))* 0.5 );

__glsplit__10SubdividerFR3BinN0 ( __0this , __1source , (struct Bin *)(& __2left ), (struct Bin *)(& __2right ), __1param , __2mid ) ;
{ struct Patchlist __2subpatchlist ;

__gl__ct__9PatchlistFR9Patchli0 ( (struct Patchlist *)(& __2subpatchlist ), __1patchlist , __1param , __2mid ) ;
if (( (((struct Bin *)(& __2left ))-> head__3Bin ?1 :0 )) )
if (__glcullCheck__9PatchlistFv ( (struct Patchlist *)(& __2subpatchlist )) == 0 )
__glfreejarcs__10SubdividerFR30 ( __0this ,
(struct Bin *)(& __2left )) ;
else 
__glnonSamplingSplit__10Subdiv0 ( __0this , (struct Bin *)(& __2left ), (struct Patchlist *)(& __2subpatchlist ), __1subdivisions - 1 , __1param ) ;
if (( (((struct Bin *)(& __2right ))-> head__3Bin ?1 :0 )) )
if (__glcullCheck__9PatchlistFv ( (struct Patchlist *)__1patchlist ) == 0 )
__glfreejarcs__10SubdividerFR30 ( __0this , (struct
Bin *)(& __2right )) ;
else 
__glnonSamplingSplit__10Subdiv0 ( __0this , (struct Bin *)(& __2right ), __1patchlist , __1subdivisions - 1 , __1param ) ;

__gl__dt__9PatchlistFv ( (struct Patchlist *)(& __2subpatchlist ), 2) ;

}

__gl__dt__3BinFv ( (struct Bin *)(& __2right ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __2left ), 2) ;

}

}
else 
{ 
__glbbox__9PatchlistFv ( (struct Patchlist *)__1patchlist ) ;

__glpatch__7BackendFfN31 ( (struct Backend *)__0this -> backend__10Subdivider , (((*__1patchlist )). pspec__9Patchlist [0 ]). range__5Pspec [0 ], (((*__1patchlist )). pspec__9Patchlist [0 ]). range__5Pspec [1 ], (((*__1patchlist )). pspec__9Patchlist [1 ]). range__5Pspec [0 ], (((*__1patchlist )).
pspec__9Patchlist [1 ]). range__5Pspec [1 ]) ;

if (((*__0this -> renderhints__10Subdivider )). display_method__11Renderhints == 9.0 ){ 
__gloutline__10SubdividerFR3Bi0 ( __0this , __1source ) ;
__glfreejarcs__10SubdividerFR30 ( __0this , __1source ) ;
}
else 
{ 
( (__0this -> isArcTypeBezier__10Subdivider = 0 )) ;
( (__0this -> showDegenerate__10Subdivider = 1 )) ;
__glfindIrregularS__10Subdivid0 ( __0this , __1source ) ;
__glmonosplitInS__10Subdivider0 ( __0this , __1source , __0this -> smbrkpts__10Subdivider . start__5Flist , __0this -> smbrkpts__10Subdivider . end__5Flist ) ;
}
}
}

void __gltessellate__10SubdividerFR0 (struct Subdivider *, struct Bin *, REAL , REAL , REAL , REAL );

void __glsetstriptessellation__6Sli0 (struct Slicer *, REAL , REAL );

void __gltessellation__10Subdivider0 (struct Subdivider *__0this , struct Bin *__1bin , struct Patchlist *__1patchlist )
{ 
__gltessellate__10SubdividerFR0 ( __0this , __1bin , (((*__1patchlist )). pspec__9Patchlist [1 ]). sidestep__5Pspec [1 ], (((*__1patchlist )).
pspec__9Patchlist [0 ]). sidestep__5Pspec [1 ], (((*__1patchlist )). pspec__9Patchlist [1 ]). sidestep__5Pspec [0 ], (((*__1patchlist )). pspec__9Patchlist [0 ]). sidestep__5Pspec [0 ]) ;

__glsetstriptessellation__6Sli0 ( (struct Slicer *)(& __0this -> slicer__10Subdivider ), (((*__1patchlist )). pspec__9Patchlist [0 ]). stepsize__5Pspec , (((*__1patchlist )). pspec__9Patchlist [1 ]). stepsize__5Pspec ) ;

(__0this -> stepsizes__10Subdivider [0 ])= (((*__1patchlist )). pspec__9Patchlist [1 ]). stepsize__5Pspec ;
(__0this -> stepsizes__10Subdivider [1 ])= (((*__1patchlist )). pspec__9Patchlist [0 ]). stepsize__5Pspec ;
(__0this -> stepsizes__10Subdivider [2 ])= (((*__1patchlist )). pspec__9Patchlist [1 ]). stepsize__5Pspec ;
(__0this -> stepsizes__10Subdivider [3 ])= (((*__1patchlist )). pspec__9Patchlist [0 ]). stepsize__5Pspec ;
}




void __glfindIrregularT__10Subdivid0 (struct Subdivider *, struct Bin *);

void __glmonosplitInT__10Subdivider0 (struct Subdivider *, struct Bin *, int , int );

void __glmonosplitInS__10Subdivider0 (struct Subdivider *__0this , struct Bin *__1source , int __1start , int __1end )
{ 
if (( (((struct Bin *)__1source )-> head__3Bin ?1 :0 ))
){ 
if (__1start != __1end ){ 
int __3i ;
struct Bin __3left ;

struct Bin __3right ;

__3i = (__1start + ((__1end - __1start )/ 2 ));
__gl__ct__3BinFv ( (struct Bin *)(& __3left )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __3right )) ;
__glsplit__10SubdividerFR3BinN0 ( __0this , __1source , (struct Bin *)(& __3left ), (struct Bin *)(& __3right ), 0 , __0this -> smbrkpts__10Subdivider . pts__5Flist [__3i ]) ;

__glmonosplitInS__10Subdivider0 ( __0this , (struct Bin *)(& __3left ), __1start , __3i ) ;
__glmonosplitInS__10Subdivider0 ( __0this , (struct Bin *)(& __3right ), __3i + 1 , __1end ) ;

__gl__dt__3BinFv ( (struct Bin *)(& __3right ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __3left ), 2) ;
}
else 
{ 
if (((*__0this -> renderhints__10Subdivider )). display_method__11Renderhints == 10.0 ){ 
__gloutline__10SubdividerFR3Bi0 ( __0this , __1source ) ;
__glfreejarcs__10SubdividerFR30 ( __0this , __1source ) ;
}
else 
{ 
( (__0this -> isArcTypeBezier__10Subdivider = 0 )) ;
( (__0this -> showDegenerate__10Subdivider = 1 )) ;
__glfindIrregularT__10Subdivid0 ( __0this , __1source ) ;
__glmonosplitInT__10Subdivider0 ( __0this , __1source , __0this -> tmbrkpts__10Subdivider . start__5Flist , __0this -> tmbrkpts__10Subdivider . end__5Flist ) ;
}
}
}
}


void __glrender__10SubdividerFR3Bin (struct Subdivider *, struct Bin *);

void __glmonosplitInT__10Subdivider0 (struct Subdivider *__0this , struct Bin *__1source , int __1start , int __1end )
{ 
if (( (((struct Bin *)__1source )-> head__3Bin ?1 :0 ))
){ 
if (__1start != __1end ){ 
int __3i ;
struct Bin __3left ;

struct Bin __3right ;

__3i = (__1start + ((__1end - __1start )/ 2 ));
__gl__ct__3BinFv ( (struct Bin *)(& __3left )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __3right )) ;
__glsplit__10SubdividerFR3BinN0 ( __0this , __1source , (struct Bin *)(& __3left ), (struct Bin *)(& __3right ), 1 , __0this -> tmbrkpts__10Subdivider . pts__5Flist [__3i ]) ;

__glmonosplitInT__10Subdivider0 ( __0this , (struct Bin *)(& __3left ), __1start , __3i ) ;
__glmonosplitInT__10Subdivider0 ( __0this , (struct Bin *)(& __3right ), __3i + 1 , __1end ) ;

__gl__dt__3BinFv ( (struct Bin *)(& __3right ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __3left ), 2) ;
}
else 
{ 
if (((*__0this -> renderhints__10Subdivider )). display_method__11Renderhints == 11.0 ){ 
__gloutline__10SubdividerFR3Bi0 ( __0this , __1source ) ;
__glfreejarcs__10SubdividerFR30 ( __0this , __1source ) ;
}
else 
{ 
__glrender__10SubdividerFR3Bin ( __0this , __1source ) ;
__glfreejarcs__10SubdividerFR30 ( __0this , __1source ) ;
}
}
}
}

void __glgrow__5FlistFi (struct Flist *, int );

int __glnumarcs__3BinFv (struct Bin *);




int __glccwTurn_tr__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);

void __gladd__5FlistFf (struct Flist *, REAL );

int __glccwTurn_tl__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);


void __glfilter__5FlistFv (struct Flist *);

void __glfindIrregularS__10Subdivid0 (struct Subdivider *__0this , struct Bin *__1bin )
{ 
((void )0 );

__glgrow__5FlistFi ( (struct Flist *)(& __0this -> smbrkpts__10Subdivider ), __glnumarcs__3BinFv ( (struct Bin *)__1bin ) ) ;

{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00qbckaice ;

__1jarc = ( (((struct Bin *)__1bin )-> current__3Bin = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), (
(__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc00qbckaice ) ) ) ;
for(;__1jarc ;__1jarc = ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), ( (__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 )
:( 0 ) ), __1__Xjarc00qbckaice ) ) ) { 
REAL *__2a ;
REAL *__2b ;
REAL *__2c ;

struct Arc *__0__X17 ;

__2a = ( (__0__X17 = (struct Arc *)__1jarc -> prev__3Arc ), ( (((REAL *)(__0__X17 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) ;
__2b = ( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ;
__2c = ( (((REAL *)(((struct Arc *)__1jarc )-> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ;

if (((__2b [1 ])== (__2a [1 ]))&& ((__2b [1 ])== (__2c [1 ])))continue ;

if (((__2b [1 ])<= (__2a [1 ]))&& ((__2b [1 ])<= (__2c [1 ]))){ 
if (! __glccwTurn_tr__10SubdividerFP0 ( __0this , __1jarc -> prev__3Arc , __1jarc ) )
__gladd__5FlistFf ( (struct
Flist *)(& __0this -> smbrkpts__10Subdivider ), __2b [0 ]) ;
}
else 
if (((__2b [1 ])>= (__2a [1 ]))&& ((__2b [1 ])>= (__2c [1 ]))){ 
if (! __glccwTurn_tl__10SubdividerFP0 ( __0this , __1jarc -> prev__3Arc , __1jarc ) )
__gladd__5FlistFf (
(struct Flist *)(& __0this -> smbrkpts__10Subdivider ), __2b [0 ]) ;
}
}

__glfilter__5FlistFv ( (struct Flist *)(& __0this -> smbrkpts__10Subdivider )) ;

}

}
}




int __glccwTurn_sr__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);

int __glccwTurn_sl__10SubdividerFP0 (struct Subdivider *, struct Arc *, struct Arc *);


void __glfindIrregularT__10Subdivid0 (struct Subdivider *__0this , struct Bin *__1bin )
{ 
((void )0 );

__glgrow__5FlistFi ( (struct Flist *)(& __0this -> tmbrkpts__10Subdivider ), __glnumarcs__3BinFv ( (struct Bin *)__1bin ) ) ;

{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00qbckaice ;

__1jarc = ( (((struct Bin *)__1bin )-> current__3Bin = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), (
(__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc00qbckaice ) ) ) ;
for(;__1jarc ;__1jarc = ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), ( (__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 )
:( 0 ) ), __1__Xjarc00qbckaice ) ) ) { 
REAL *__2a ;
REAL *__2b ;
REAL *__2c ;

struct Arc *__0__X18 ;

__2a = ( (__0__X18 = (struct Arc *)__1jarc -> prev__3Arc ), ( (((REAL *)(__0__X18 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) ;
__2b = ( (((REAL *)(((struct Arc *)__1jarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ;
__2c = ( (((REAL *)(((struct Arc *)__1jarc )-> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ;

if (((__2b [0 ])== (__2a [0 ]))&& ((__2b [0 ])== (__2c [0 ])))continue ;

if (((__2b [0 ])<= (__2a [0 ]))&& ((__2b [0 ])<= (__2c [0 ]))){ 
if (((__2a [1 ])!= (__2b [1 ]))&& ((__2b [1 ])!= (__2c [1 ])))continue ;
if (! __glccwTurn_sr__10SubdividerFP0 ( __0this , __1jarc -> prev__3Arc , __1jarc ) )
__gladd__5FlistFf ( (struct Flist *)(& __0this -> tmbrkpts__10Subdivider ), __2b [1 ]) ;

}
else 
if (((__2b [0 ])>= (__2a [0 ]))&& ((__2b [0 ])>= (__2c [0 ]))){ 
if (((__2a [1 ])!= (__2b [1 ]))&& ((__2b [1 ])!= (__2c [1 ])))continue ;
if (! __glccwTurn_sl__10SubdividerFP0 ( __0this , __1jarc -> prev__3Arc , __1jarc ) )
__gladd__5FlistFf ( (struct Flist *)(& __0this -> tmbrkpts__10Subdivider ), __2b [1 ]) ;

}
}
__glfilter__5FlistFv ( (struct Flist *)(& __0this -> tmbrkpts__10Subdivider )) ;

}

}
}


void __glbezier__14ArcTessellatorFP0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );









void __glmakeBorderTrim__10Subdivid0 (struct Subdivider *__0this , REAL *__1from , REAL *__1to )
{ 
REAL __1smin ;
REAL __1smax ;
REAL __1tmin ;
REAL __1tmax ;

__1smin = (__1from [0 ]);
__1smax = (__1to [0 ]);
__1tmin = (__1from [1 ]);
__1tmax = (__1to [1 ]);

__0this -> pjarc__10Subdivider = 0 ;

{ Arc_ptr __1jarc ;

struct Arc *__0__X19 ;

void *__1__Xbuffer00eohgaiaa ;

struct Arc *__0__X20 ;

struct Arc *__0__X21 ;

struct Arc *__0__X22 ;

__1jarc = ((__0__X22 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X22 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X22 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X22 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X22 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X22 )-> type__3Arc |= ((((long )((int )4)))<< 8 )))
, ( (((struct Arc *)__0__X22 )-> nuid__3Arc = ((long )0.0 )), ((((struct Arc *)__0__X22 )))) ) ) ) ) :0 );

__glbezier__14ArcTessellatorFP0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __1smin , __1smax , __1tmin , __1tmin ) ;
( (__1jarc -> link__3Arc = ((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin ), (((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin = __1jarc ))
;
__0this -> pjarc__10Subdivider = __glappend__3ArcFP3Arc ( (struct Arc *)__1jarc , __0this -> pjarc__10Subdivider ) ;

__1jarc = ((__0__X19 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X19 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X19 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X19 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X19 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X19 )-> type__3Arc |= ((((long )((int )1)))<< 8 )))
, ( (((struct Arc *)__0__X19 )-> nuid__3Arc = ((long )0.0 )), ((((struct Arc *)__0__X19 )))) ) ) ) ) :0 );

__glbezier__14ArcTessellatorFP0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __1smax , __1smax , __1tmin , __1tmax ) ;
( (__1jarc -> link__3Arc = ((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin ), (((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin = __1jarc ))
;
__0this -> pjarc__10Subdivider = __glappend__3ArcFP3Arc ( (struct Arc *)__1jarc , __0this -> pjarc__10Subdivider ) ;

__1jarc = ((__0__X20 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X20 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X20 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X20 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X20 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X20 )-> type__3Arc |= ((((long )((int )2)))<< 8 )))
, ( (((struct Arc *)__0__X20 )-> nuid__3Arc = ((long )0.0 )), ((((struct Arc *)__0__X20 )))) ) ) ) ) :0 );

__glbezier__14ArcTessellatorFP0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __1smax , __1smin , __1tmax , __1tmax ) ;
( (__1jarc -> link__3Arc = ((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin ), (((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin = __1jarc ))
;
__0this -> pjarc__10Subdivider = __glappend__3ArcFP3Arc ( (struct Arc *)__1jarc , __0this -> pjarc__10Subdivider ) ;

__1jarc = ((__0__X21 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X21 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X21 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X21 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X21 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X21 )-> type__3Arc |= ((((long )((int )3)))<< 8 )))
, ( (((struct Arc *)__0__X21 )-> nuid__3Arc = ((long )0.0 )), ((((struct Arc *)__0__X21 )))) ) ) ) ) :0 );

__glbezier__14ArcTessellatorFP0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __1smin , __1smin , __1tmax , __1tmin ) ;
( (__1jarc -> link__3Arc = ((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin ), (((struct Bin *)(& __0this -> initialbin__10Subdivider ))-> head__3Bin = __1jarc ))
;
__glappend__3ArcFP3Arc ( (struct Arc *)__1jarc , __0this -> pjarc__10Subdivider ) ;

((void )0 );

}
}

void __glmarkall__3BinFv (struct Bin *);

void __glsetisolines__6SlicerFi (struct Slicer *, int );




void __glslice__6SlicerFP3Arc (struct Slicer *, struct Arc *);


void __glrender__10SubdividerFR3Bin (struct Subdivider *__0this , struct Bin *__1bin )
{ 
__glmarkall__3BinFv ( (struct Bin *)__1bin ) ;

__glsetisolines__6SlicerFi ( (struct Slicer *)(& __0this -> slicer__10Subdivider ), (((*__0this -> renderhints__10Subdivider )). display_method__11Renderhints == 12.0 )?1 :0 ) ;

{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00qbckaice ;

__1jarc = ( (((struct Bin *)__1bin )-> current__3Bin = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), (
(__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc00qbckaice ) ) ) ;
for(;__1jarc ;__1jarc = ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), ( (__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 )
:( 0 ) ), __1__Xjarc00qbckaice ) ) ) { 
if (( (((struct Arc *)__1jarc )-> type__3Arc & __glarc_tag__3Arc )) ){

((void )0 );
{ Arc_ptr __3jarchead ;

__3jarchead = __1jarc ;
do { 
( (((struct Arc *)__1jarc )-> type__3Arc &= (~ __glarc_tag__3Arc ))) ;
__1jarc = __1jarc -> next__3Arc ;
}
while (__1jarc != __3jarchead );

__glslice__6SlicerFP3Arc ( (struct Slicer *)(& __0this -> slicer__10Subdivider ), __1jarc ) ;

}
}
}

}

}
}



void __gloutline__6SlicerFP3Arc (struct Slicer *, struct Arc *);



void __gloutline__10SubdividerFR3Bi0 (struct Subdivider *__0this , struct Bin *__1bin )
{ 
__glmarkall__3BinFv ( (struct Bin *)__1bin ) ;
{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00qbckaice ;

__1jarc = ( (((struct Bin *)__1bin )-> current__3Bin = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), (
(__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc00qbckaice ) ) ) ;
for(;__1jarc ;__1jarc = ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), ( (__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 )
:( 0 ) ), __1__Xjarc00qbckaice ) ) ) { 
if (( (((struct Arc *)__1jarc )-> type__3Arc & __glarc_tag__3Arc )) ){

((void )0 );
{ Arc_ptr __3jarchead ;

__3jarchead = __1jarc ;
do { 
__gloutline__6SlicerFP3Arc ( (struct Slicer *)(& __0this -> slicer__10Subdivider ), __1jarc ) ;
( (((struct Arc *)__1jarc )-> type__3Arc &= (~ __glarc_tag__3Arc ))) ;
__1jarc = __1jarc -> prev__3Arc ;
}
while (__1jarc != __3jarchead );

}
}
}

}

}
}

void __gladopt__3BinFv (struct Bin *);



void __glfreejarcs__10SubdividerFR30 (struct Subdivider *__0this , struct Bin *__1bin )
{ 
Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00efckaice ;

__gladopt__3BinFv ( (struct Bin *)__1bin ) ;

;
while (__1jarc = ( (__1__Xjarc00efckaice = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)__1bin )-> head__3Bin = __1__Xjarc00efckaice -> link__3Arc ),
0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ){ 
struct PooledObj *__0__X23 ;

struct PooledObj *__0__X24 ;

if (__1jarc -> pwlArc__3Arc )( (__0__X23 = (struct PooledObj *)__1jarc -> pwlArc__3Arc ), ( ( (((void )0 )), ( ((((struct Buffer *)(((struct
Buffer *)(((void *)__0__X23 ))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))->
freelist__4Pool = (((struct Buffer *)(((struct Buffer *)(((void *)__0__X23 )))))))) ) ) ) ;

__1jarc -> pwlArc__3Arc = 0 ;
if (__1jarc -> bezierArc__3Arc )( (__0__X24 = (struct PooledObj *)__1jarc -> bezierArc__3Arc ), ( ( (((void )0 )), ( ((((struct Buffer *)(((struct
Buffer *)(((void *)__0__X24 ))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> bezierarcpool__10Subdivider )))->
freelist__4Pool = (((struct Buffer *)(((struct Buffer *)(((void *)__0__X24 )))))))) ) ) ) ;

__1jarc -> bezierArc__3Arc = 0 ;
( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1jarc )))))))-> next__6Buffer = ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool = (((struct Buffer *)(((struct Buffer *)(((void *)((struct PooledObj *)__1jarc )))))))))
) ) ;
}
}





void __glpwl_left__14ArcTessellator0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );
void __glpwl_right__14ArcTessellato0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );
void __glpwl_top__14ArcTessellatorF0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );
void __glpwl_bottom__14ArcTessellat0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );

// extern void abort (void );


void __gltessellate__10SubdividerFR0 (struct Subdivider *__0this , struct Bin *__1bin , REAL __1rrate , REAL __1trate , REAL __1lrate , REAL __1brate )
{ 
{ { Arc_ptr __1jarc ;

struct Arc *__1__Xjarc00qbckaice ;

__1jarc = ( (((struct Bin *)__1bin )-> current__3Bin = ((struct Bin *)__1bin )-> head__3Bin ), ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), (
(__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc00qbckaice ) ) ) ;
for(;__1jarc ;__1jarc = ( (__1__Xjarc00qbckaice = ((struct Bin *)__1bin )-> current__3Bin ), ( (__1__Xjarc00qbckaice ?( (((struct Bin *)__1bin )-> current__3Bin = __1__Xjarc00qbckaice -> link__3Arc ), 0 )
:( 0 ) ), __1__Xjarc00qbckaice ) ) ) { 
if (( (((struct Arc *)__1jarc )-> type__3Arc & __glbezier_tag__3Arc )) ){

((void )0 );
{ struct TrimVertex *__3pts ;
REAL __3s1 ;
REAL __3t1 ;
REAL __3s2 ;
REAL __3t2 ;

struct PooledObj *__0__X25 ;

__3pts = __1jarc -> pwlArc__3Arc -> pts__6PwlArc ;
__3s1 = ((__3pts [0 ]). param__10TrimVertex [0 ]);
__3t1 = ((__3pts [0 ]). param__10TrimVertex [1 ]);
__3s2 = ((__3pts [1 ]). param__10TrimVertex [0 ]);
__3t2 = ((__3pts [1 ]). param__10TrimVertex [1 ]);

( (__0__X25 = (struct PooledObj *)__1jarc -> pwlArc__3Arc ), ( ( (((void )0 )), ( ((((struct Buffer *)(((struct Buffer *)(((void *)__0__X25 ))))))->
next__6Buffer = ((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool ), (((struct Pool *)((struct Pool *)(& __0this -> pwlarcpool__10Subdivider )))-> freelist__4Pool = (((struct
Buffer *)(((struct Buffer *)(((void *)__0__X25 )))))))) ) ) ) ;

__1jarc -> pwlArc__3Arc = 0 ;

switch (( (((int )((((struct Arc *)__1jarc )-> type__3Arc >> 8 )& 0x7 )))) ){ 
case 3:
((void )0 );
__glpwl_left__14ArcTessellator0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __3s1 , __3t1 , __3t2 , __1lrate ) ;
break ;
case 1:
((void )0 );
__glpwl_right__14ArcTessellato0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __3s1 , __3t1 , __3t2 , __1rrate ) ;
break ;
case 2:
((void )0 );
__glpwl_top__14ArcTessellatorF0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __3t1 , __3s1 , __3s2 , __1trate ) ;
break ;
case 4:
((void )0 );
__glpwl_bottom__14ArcTessellat0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __1jarc , __3t1 , __3s1 , __3s2 , __1brate ) ;
break ;
case 0:
(abort ( ) );
break ;
}
((void )0 );
((void )0 );

}
}
}

}

}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\splitarc.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/splitarcs.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);






struct JumpBuffer;










struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;






struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;











struct Bin;

struct Bin {	

struct Arc *head__3Bin ;
struct Arc *current__3Bin ;
};









struct Sorter;

struct Sorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct FlistSorter;

struct FlistSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;
};

struct Flist;

struct Flist {	

REAL *pts__5Flist ;
int npts__5Flist ;
int start__5Flist ;
int end__5Flist ;

struct FlistSorter sorter__5Flist ;
};








struct Backend;



struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};



struct BezierArc;


struct TrimVertexPool;

struct ArcTessellator;

struct ArcTessellator {	

struct Pool *pwlarcpool__14ArcTessellator ;
struct TrimVertexPool *trimvertexpool__14ArcTessellator ;
};

extern REAL __glgl_Bernstein__14ArcTessell0 [][24][24];




struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};




struct Renderhints;

struct Backend;

struct Quilt;

struct Patchlist;

struct Curvelist;

struct JumpBuffer;

struct Subdivider;
enum __Q2_10Subdivider3dir { down__Q2_10Subdivider3dir = 0, same__Q2_10Subdivider3dir = 1, up__Q2_10Subdivider3dir = 2, none__Q2_10Subdivider3dir = 3} ;

struct Subdivider {	

struct Slicer slicer__10Subdivider ;
struct ArcTessellator arctessellator__10Subdivider ;
struct Pool arcpool__10Subdivider ;
struct Pool bezierarcpool__10Subdivider ;
struct Pool pwlarcpool__10Subdivider ;
struct TrimVertexPool trimvertexpool__10Subdivider ;

struct JumpBuffer *jumpbuffer__10Subdivider ;
struct Renderhints *renderhints__10Subdivider ;
struct Backend *backend__10Subdivider ;

struct Bin initialbin__10Subdivider ;
struct Arc *pjarc__10Subdivider ;
int s_index__10Subdivider ;
int t_index__10Subdivider ;
struct Quilt *qlist__10Subdivider ;
struct Flist spbrkpts__10Subdivider ;
struct Flist tpbrkpts__10Subdivider ;
struct Flist smbrkpts__10Subdivider ;
struct Flist tmbrkpts__10Subdivider ;
REAL stepsizes__10Subdivider [4];
int showDegenerate__10Subdivider ;
int isArcTypeBezier__10Subdivider ;
};






struct ArcSorter;

struct ArcSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;

struct Subdivider *subdivider__9ArcSorter ;
};
struct ArcSdirSorter;

struct ArcSdirSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;

struct Subdivider *subdivider__9ArcSorter ;
};
struct ArcTdirSorter;

struct ArcTdirSorter {	

int es__6Sorter ;
struct __mptr *__vptr__6Sorter ;

struct Subdivider *subdivider__9ArcSorter ;
};


struct Bin *__gl__ct__3BinFv (struct Bin *);

void __glpartition__10SubdividerFR30 (struct Subdivider *, struct Bin *, struct Bin *, struct Bin *, struct Bin *, struct Bin *, int
, REAL );

int __glnumarcs__3BinFv (struct Bin *);



struct ArcSdirSorter *__gl__ct__13ArcSdirSorterFR10S0 (struct ArcSdirSorter *, struct Subdivider *);

void __glqsort__9ArcSorterFPP3Arci (struct ArcSorter *, struct Arc **, int );

void __glcheck_s__10SubdividerFP3Ar0 (struct Subdivider *, struct Arc *, struct Arc *);

void __gljoin_s__10SubdividerFR3Bin0 (struct Subdivider *, struct Bin *, struct Bin *, struct Arc *, struct Arc *);




struct ArcTdirSorter *__gl__ct__13ArcTdirSorterFR10S0 (struct ArcTdirSorter *, struct Subdivider *);

void __glcheck_t__10SubdividerFP3Ar0 (struct Subdivider *, struct Arc *, struct Arc *);

void __gljoin_t__10SubdividerFR3Bin0 (struct Subdivider *, struct Bin *, struct Bin *, struct Arc *, struct Arc *);




void __gladopt__3BinFv (struct Bin *);
extern struct __mptr* __ptbl_vec_____core_splitarcs_c___split_[];

void __gl__dt__3BinFv (struct Bin *, int );



void __glsplit__10SubdividerFR3BinN0 (struct Subdivider *__0this , struct Bin *__1bin , struct Bin *__1left , struct Bin *__1right , int __1param , REAL __1value )
{ 
struct Bin __1intersections ;
struct Bin __1unknown ;

__gl__ct__3BinFv ( (struct Bin *)(& __1intersections )) ;

__gl__ct__3BinFv ( (struct Bin *)(& __1unknown )) ;

__glpartition__10SubdividerFR30 ( __0this , __1bin , __1left , (struct Bin *)(& __1intersections ), __1right , (struct Bin *)(& __1unknown ), __1param , __1value ) ;

{ int __1count ;

__1count = __glnumarcs__3BinFv ( (struct Bin *)(& __1intersections )) ;
if (__1count % 2 ){ 
mylongjmp ( __0this -> jumpbuffer__10Subdivider , 29 ) ;
}

{ Arc_ptr __1arclist [10];

Arc_ptr *__1list ;

Arc_ptr __1jarc ;

if (__1count >= 10 ){ 
void *__1__Xp00uzigaiaa ;

__1list = (((struct Arc **)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (struct Arc *))* __1count )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ));

}
else 
{ 
__1list = __1arclist ;
}

;
{ { Arc_ptr *__1last ;

struct Arc *__1__Xjarc00efckaice ;

__1last = __1list ;

for(;__1jarc = ( (__1__Xjarc00efckaice = ((struct Bin *)(& __1intersections ))-> head__3Bin ), ( (__1__Xjarc00efckaice ?( (((struct Bin *)(& __1intersections ))-> head__3Bin = __1__Xjarc00efckaice ->
link__3Arc ), 0 ) :( 0 ) ), __1__Xjarc00efckaice ) ) ;__1last ++ ) 
((*__1last ))= __1jarc ;

if (__1param == 0 ){ 
struct ArcSdirSorter __2sorter ;

__gl__ct__13ArcSdirSorterFR10S0 ( (struct ArcSdirSorter *)(& __2sorter ), (struct Subdivider *)__0this ) ;
__glqsort__9ArcSorterFPP3Arci ( (struct ArcSorter *)(& __2sorter ), __1list , __1count ) ;

{ { Arc_ptr *__2lptr ;

__2lptr = __1list ;

for(;__2lptr < __1last ;__2lptr += 2 ) 
__glcheck_s__10SubdividerFP3Ar0 ( __0this , __2lptr [0 ], __2lptr [1 ]) ;
for(__2lptr = __1list ;__2lptr < __1last ;__2lptr += 2 ) 
__gljoin_s__10SubdividerFR3Bin0 ( __0this , __1left , __1right , __2lptr [0 ], __2lptr [1 ]) ;
for(__2lptr = __1list ;__2lptr != __1last ;__2lptr ++ ) { 
if (((( (((REAL *)(((struct Arc *)((*__2lptr )))-> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])<=
__1value )&& ((( (((REAL *)(((struct Arc *)((*__2lptr )))-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])<= __1value ))
( (((*__2lptr ))-> link__3Arc = ((struct Bin *)__1left )-> head__3Bin ),
(((struct Bin *)__1left )-> head__3Bin = ((*__2lptr )))) ;
else 
( (((*__2lptr ))-> link__3Arc = ((struct Bin *)__1right )-> head__3Bin ), (((struct Bin *)__1right )-> head__3Bin = ((*__2lptr )))) ;
}

}

}
}
else 
{ 
struct ArcTdirSorter __2sorter ;

__gl__ct__13ArcTdirSorterFR10S0 ( (struct ArcTdirSorter *)(& __2sorter ), (struct Subdivider *)__0this ) ;
__glqsort__9ArcSorterFPP3Arci ( (struct ArcSorter *)(& __2sorter ), __1list , __1count ) ;

{ { Arc_ptr *__2lptr ;

__2lptr = __1list ;

for(;__2lptr < __1last ;__2lptr += 2 ) 
__glcheck_t__10SubdividerFP3Ar0 ( __0this , __2lptr [0 ], __2lptr [1 ]) ;
for(__2lptr = __1list ;__2lptr < __1last ;__2lptr += 2 ) 
__gljoin_t__10SubdividerFR3Bin0 ( __0this , __1left , __1right , __2lptr [0 ], __2lptr [1 ]) ;
for(__2lptr = __1list ;__2lptr != __1last ;__2lptr ++ ) { 
if (((( (((REAL *)(((struct Arc *)((*__2lptr )))-> next__3Arc -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])<=
__1value )&& ((( (((REAL *)(((struct Arc *)((*__2lptr )))-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])<= __1value ))
( (((*__2lptr ))-> link__3Arc = ((struct Bin *)__1left )-> head__3Bin ),
(((struct Bin *)__1left )-> head__3Bin = ((*__2lptr )))) ;
else 
( (((*__2lptr ))-> link__3Arc = ((struct Bin *)__1right )-> head__3Bin ), (((struct Bin *)__1right )-> head__3Bin = ((*__2lptr )))) ;
}

}

}
}

if (__1list != __1arclist )( (((void *)__1list )?( free ( ((void *)__1list )) , 0 ) :( 0 ) )) ;

__gladopt__3BinFv ( (struct Bin *)(& __1unknown )) ;

}

}

}

}

__gl__dt__3BinFv ( (struct Bin *)(& __1unknown ), 2) ;

__gl__dt__3BinFv ( (struct Bin *)(& __1intersections ), 2) ;
}





void __glcheck_s__10SubdividerFP3Ar0 (struct Subdivider *__0this , Arc_ptr __1jarc1 , Arc_ptr __1jarc2 )
{ 
((void )0 );
((void )0 );
((void )0 );
((void )0 );
((void )0 );

if (! ((( (((REAL *)(((struct Arc *)__1jarc1 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])< (( (((REAL *)(((struct Arc *)__1jarc1 )-> next__3Arc -> pwlArc__3Arc ->
pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ]))){ 
mylongjmp ( __0this -> jumpbuffer__10Subdivider , 28 ) ;
}

if (! ((( (((REAL *)(((struct Arc *)__1jarc2 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])> (( (((REAL *)(((struct Arc *)__1jarc2 )-> next__3Arc -> pwlArc__3Arc ->
pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ]))){ 
mylongjmp ( __0this -> jumpbuffer__10Subdivider , 28 ) ;
}
}






void __glbezier__14ArcTessellatorFP0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );

void __glpwl_right__14ArcTessellato0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );

void __glpwl_left__14ArcTessellator0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );




void __gljoin_s__10SubdividerFR3Bin0 (struct Subdivider *__0this , struct Bin *__1left , struct Bin *__1right , Arc_ptr __1jarc1 , Arc_ptr __1jarc2 )
{ 
((void )0 );
((void )0 );
((void )0 );

if (! ( (((int )(((struct Arc *)__1jarc1 )-> type__3Arc & __gltail_tag__3Arc )))) )
__1jarc1 = __1jarc1 -> next__3Arc ;

if (! ( (((int )(((struct Arc *)__1jarc2 )-> type__3Arc & __gltail_tag__3Arc )))) )
__1jarc2 = __1jarc2 -> next__3Arc ;

{ REAL __1s ;
REAL __1t1 ;
REAL __1t2 ;

__1s = (( (((REAL *)(((struct Arc *)__1jarc1 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ]);
__1t1 = (( (((REAL *)(((struct Arc *)__1jarc1 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ]);
__1t2 = (( (((REAL *)(((struct Arc *)__1jarc2 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ]);

if (__1t1 == __1t2 ){ 
struct Arc *__1__X16 ;

struct Arc *__1__X17 ;

struct Arc *__1__Xtmp002o1qailf ;

( (__1__X16 = __1jarc1 ), ( (__1__X17 = __1jarc2 ), ( (__1__Xtmp002o1qailf = __1__X17 -> prev__3Arc ), ( (__1__X17 -> prev__3Arc = __1__X16 ->
prev__3Arc ), ( (__1__X16 -> prev__3Arc = __1__Xtmp002o1qailf ), ( (__1__X17 -> prev__3Arc -> next__3Arc = __1__X17 ), (__1__X16 -> prev__3Arc -> next__3Arc = __1__X16 ))
) ) ) ) ) ;
}
else 
{ 
Arc_ptr __2newright ;
Arc_ptr __2newleft ;

struct Arc *__1__X18 ;

struct Arc *__1__X19 ;

struct Arc *__1__X20 ;

struct Arc *__1__X21 ;

struct Arc *__0__X22 ;

void *__1__Xbuffer00eohgaiaa ;

struct Arc *__0__X23 ;

__2newright = ((__0__X22 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X22 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X22 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X22 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X22 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X22 )-> type__3Arc |= ((((long )((int )1)))<< 8 )))
, ( (((struct Arc *)__0__X22 )-> nuid__3Arc = ((long )0.0 )), ((((struct Arc *)__0__X22 )))) ) ) ) ) :0 );

__2newleft = ((__0__X23 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X23 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X23 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X23 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X23 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X23 )-> type__3Arc |= ((((long )((int )3)))<< 8 )))
, ( (((struct Arc *)__0__X23 )-> nuid__3Arc = ((long )0.0 )), ((((struct Arc *)__0__X23 )))) ) ) ) ) :0 );

((void )0 );
if (( __0this -> isArcTypeBezier__10Subdivider ) ){ 
__glbezier__14ArcTessellatorFP0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __2newright , __1s , __1s , __1t1 ,
__1t2 ) ;
__glbezier__14ArcTessellatorFP0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __2newleft , __1s , __1s , __1t2 , __1t1 ) ;
}
else 
{ 
__glpwl_right__14ArcTessellato0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __2newright , __1s , __1t1 , __1t2 , __0this -> stepsizes__10Subdivider [0 ]) ;

__glpwl_left__14ArcTessellator0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __2newleft , __1s , __1t2 , __1t1 , __0this -> stepsizes__10Subdivider [2 ]) ;
}
( (__1__X18 = __1jarc1 ), ( (__1__X19 = __1jarc2 ), ( (__1__X20 = __2newright ), ( (__1__X21 = __2newleft ), ( (__1__X20 ->
nuid__3Arc = (__1__X21 -> nuid__3Arc = 0 )), ( (__1__X20 -> next__3Arc = __1__X19 ), ( (__1__X21 -> next__3Arc = __1__X18 ), ( (__1__X20 ->
prev__3Arc = __1__X18 -> prev__3Arc ), ( (__1__X21 -> prev__3Arc = __1__X19 -> prev__3Arc ), ( (__1__X21 -> next__3Arc -> prev__3Arc = __1__X21 ), (
(__1__X20 -> next__3Arc -> prev__3Arc = __1__X20 ), ( (__1__X21 -> prev__3Arc -> next__3Arc = __1__X21 ), (__1__X20 -> prev__3Arc -> next__3Arc = __1__X20 )) )
) ) ) ) ) ) ) ) ) ) ;
( (__2newright -> link__3Arc = ((struct Bin *)__1left )-> head__3Bin ), (((struct Bin *)__1left )-> head__3Bin = __2newright )) ;
( (__2newleft -> link__3Arc = ((struct Bin *)__1right )-> head__3Bin ), (((struct Bin *)__1right )-> head__3Bin = __2newleft )) ;
}

((void )0 );
((void )0 );
((void )0 );
((void )0 );

}
}





void __glcheck_t__10SubdividerFP3Ar0 (struct Subdivider *__0this , Arc_ptr __1jarc1 , Arc_ptr __1jarc2 )
{ 
((void )0 );
((void )0 );
((void )0 );
((void )0 );
((void )0 );

if (! ((( (((REAL *)(((struct Arc *)__1jarc1 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])< (( (((REAL *)(((struct Arc *)__1jarc1 )-> next__3Arc -> pwlArc__3Arc ->
pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ]))){ 
mylongjmp ( __0this -> jumpbuffer__10Subdivider , 28 ) ;
}

if (! ((( (((REAL *)(((struct Arc *)__1jarc2 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])> (( (((REAL *)(((struct Arc *)__1jarc2 )-> next__3Arc -> pwlArc__3Arc ->
pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ]))){ 
mylongjmp ( __0this -> jumpbuffer__10Subdivider , 28 ) ;
}
}






void __glpwl_top__14ArcTessellatorF0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );
void __glpwl_bottom__14ArcTessellat0 (struct ArcTessellator *, struct Arc *, REAL , REAL , REAL , REAL );




void __gljoin_t__10SubdividerFR3Bin0 (struct Subdivider *__0this , struct Bin *__1bottom , struct Bin *__1top , Arc_ptr __1jarc1 , Arc_ptr __1jarc2 )
{ 
((void )0 );
((void )0 );
((void )0 );
((void )0 );
((void )0 );

if (! ( (((int )(((struct Arc *)__1jarc1 )-> type__3Arc & __gltail_tag__3Arc )))) )
__1jarc1 = __1jarc1 -> next__3Arc ;

if (! ( (((int )(((struct Arc *)__1jarc2 )-> type__3Arc & __gltail_tag__3Arc )))) )
__1jarc2 = __1jarc2 -> next__3Arc ;

{ REAL __1s1 ;
REAL __1s2 ;
REAL __1t ;

__1s1 = (( (((REAL *)(((struct Arc *)__1jarc1 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ]);
__1s2 = (( (((REAL *)(((struct Arc *)__1jarc2 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ]);
__1t = (( (((REAL *)(((struct Arc *)__1jarc1 )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ]);

if (__1s1 == __1s2 ){ 
struct Arc *__1__X24 ;

struct Arc *__1__X25 ;

struct Arc *__1__Xtmp002o1qailf ;

( (__1__X24 = __1jarc1 ), ( (__1__X25 = __1jarc2 ), ( (__1__Xtmp002o1qailf = __1__X25 -> prev__3Arc ), ( (__1__X25 -> prev__3Arc = __1__X24 ->
prev__3Arc ), ( (__1__X24 -> prev__3Arc = __1__Xtmp002o1qailf ), ( (__1__X25 -> prev__3Arc -> next__3Arc = __1__X25 ), (__1__X24 -> prev__3Arc -> next__3Arc = __1__X24 ))
) ) ) ) ) ;
}
else 
{ 
Arc_ptr __2newtop ;
Arc_ptr __2newbot ;

struct Arc *__1__X26 ;

struct Arc *__1__X27 ;

struct Arc *__1__X28 ;

struct Arc *__1__X29 ;

struct Arc *__0__X30 ;

void *__1__Xbuffer00eohgaiaa ;

struct Arc *__0__X31 ;

__2newtop = ((__0__X30 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X30 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X30 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X30 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X30 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X30 )-> type__3Arc |= ((((long )((int )2)))<< 8 )))
, ( (((struct Arc *)__0__X30 )-> nuid__3Arc = ((long )0.0 )), ((((struct Arc *)__0__X30 )))) ) ) ) ) :0 );

__2newbot = ((__0__X31 = (struct Arc *)( (((void *)( (((void )0 )), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))->
freelist__4Pool ?( ( (__1__Xbuffer00eohgaiaa = (((void *)((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool ))), (((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> freelist__4Pool = ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((!
((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool )?( __glgrow__4PoolFv ( ((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))) , 0 )
:( 0 ) ), ( (((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> nextfree__4Pool -= ((struct Pool *)((struct Pool *)(& __0this ->
arcpool__10Subdivider )))-> buffersize__4Pool ), ( (__1__Xbuffer00eohgaiaa = (((void *)(((struct Pool *)((struct Pool *)(& __0this -> arcpool__10Subdivider )))-> curblock__4Pool + ((struct Pool *)((struct Pool *)(&
__0this -> arcpool__10Subdivider )))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00eohgaiaa ))) ) ))) )?( (((struct
Arc *)__0__X31 )-> bezierArc__3Arc = 0 ), ( (((struct Arc *)__0__X31 )-> pwlArc__3Arc = 0 ), ( (((struct Arc *)__0__X31 )-> type__3Arc = 0 ), (
( ( (((struct Arc *)__0__X31 )-> type__3Arc &= -1793)) , (((struct Arc *)__0__X31 )-> type__3Arc |= ((((long )((int )4)))<< 8 )))
, ( (((struct Arc *)__0__X31 )-> nuid__3Arc = ((long )0.0 )), ((((struct Arc *)__0__X31 )))) ) ) ) ) :0 );

((void )0 );
if (( __0this -> isArcTypeBezier__10Subdivider ) ){ 
__glbezier__14ArcTessellatorFP0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __2newtop , __1s1 , __1s2 , __1t ,
__1t ) ;
__glbezier__14ArcTessellatorFP0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __2newbot , __1s2 , __1s1 , __1t , __1t ) ;
}
else 
{ 
__glpwl_top__14ArcTessellatorF0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __2newtop , __1t , __1s1 , __1s2 , __0this -> stepsizes__10Subdivider [1 ]) ;

__glpwl_bottom__14ArcTessellat0 ( (struct ArcTessellator *)(& __0this -> arctessellator__10Subdivider ), __2newbot , __1t , __1s2 , __1s1 , __0this -> stepsizes__10Subdivider [3 ]) ;
}
( (__1__X26 = __1jarc1 ), ( (__1__X27 = __1jarc2 ), ( (__1__X28 = __2newtop ), ( (__1__X29 = __2newbot ), ( (__1__X28 ->
nuid__3Arc = (__1__X29 -> nuid__3Arc = 0 )), ( (__1__X28 -> next__3Arc = __1__X27 ), ( (__1__X29 -> next__3Arc = __1__X26 ), ( (__1__X28 ->
prev__3Arc = __1__X26 -> prev__3Arc ), ( (__1__X29 -> prev__3Arc = __1__X27 -> prev__3Arc ), ( (__1__X29 -> next__3Arc -> prev__3Arc = __1__X29 ), (
(__1__X28 -> next__3Arc -> prev__3Arc = __1__X28 ), ( (__1__X29 -> prev__3Arc -> next__3Arc = __1__X29 ), (__1__X28 -> prev__3Arc -> next__3Arc = __1__X28 )) )
) ) ) ) ) ) ) ) ) ) ;
( (__2newtop -> link__3Arc = ((struct Bin *)__1bottom )-> head__3Bin ), (((struct Bin *)__1bottom )-> head__3Bin = __2newtop )) ;
( (__2newbot -> link__3Arc = ((struct Bin *)__1top )-> head__3Bin ), (((struct Bin *)__1top )-> head__3Bin = __2newbot )) ;
}

((void )0 );
((void )0 );
((void )0 );
((void )0 );

}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\slicer.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/slicer.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);






struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};










struct Arc;

struct Backend;






typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;













struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};


struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;








struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridTrimVertex;



struct __Q2_4Hull4Side;

struct  __Q2_4Hull4Side {	
struct Trimline *left__Q2_4Hull4Side ;
struct Gridline *line__Q2_4Hull4Side ;
struct Trimline *right__Q2_4Hull4Side ;
long index__Q2_4Hull4Side ;
};
struct Hull;

struct Hull {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};


struct Backend;


struct GridTrimVertex;

struct Mesher;

struct Mesher {	

struct  __Q2_4Hull4Side lower__4Hull ;
struct  __Q2_4Hull4Side upper__4Hull ;
struct Trimline fakeleft__4Hull ;
struct Trimline fakeright__4Hull ;
struct TrimRegion *PTrimRegion;

struct Backend *backend__6Mesher ;

struct Pool p__6Mesher ;
unsigned int stacksize__6Mesher ;
struct GridTrimVertex **vdata__6Mesher ;
struct GridTrimVertex *last__6Mesher [2];
int itop__6Mesher ;
int lastedge__6Mesher ;
struct TrimRegion OTrimRegion;
};

extern float __glZERO__6Mesher ;



struct Backend;


struct GridVertex;

struct GridTrimVertex;

struct CoveAndTiler;

struct CoveAndTiler {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct TrimRegion OTrimRegion;
};

extern int __glMAXSTRIPSIZE__12CoveAndTil0 ;

struct Backend;



struct Slicer;

struct Slicer {	

struct Backend *backend__12CoveAndTiler ;
struct TrimRegion *PTrimRegion;
struct Mesher OMesher;

struct Backend *backend__6Slicer ;
REAL oneOverDu__6Slicer ;
REAL du__6Slicer ;

REAL dv__6Slicer ;
int isolines__6Slicer ;
};





struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};






struct Varray;

struct Varray {	

REAL *varray__6Varray ;
REAL vval__6Varray [1000];
long voffset__6Varray [1000];
long numquads__6Varray ;

long size__6Varray ;
};


struct Mesher *__gl__ct__6MesherFR7Backend (struct Mesher *, struct TrimRegion *, struct Backend *);

struct CoveAndTiler *__gl__ct__12CoveAndTilerFR7Bac0 (struct CoveAndTiler *, struct TrimRegion *, struct Backend *);

struct TrimRegion *__gl__ct__10TrimRegionFv (struct TrimRegion *);
extern struct __mptr* __ptbl_vec_____core_slicer_c_____ct_[];


struct Slicer *__gl__ct__6SlicerFR7Backend (struct Slicer *__0this , struct TrimRegion *__0TrimRegion , struct Backend *__1b )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Slicer *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Slicer))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))(
( ( ((__0TrimRegion == 0 )?( (__0TrimRegion = (((struct TrimRegion *)((((char *)__0this ))+ 356)))), __gl__ct__10TrimRegionFv ( ((struct TrimRegion *)((((char *)__0this ))+ 356)))
) :__0TrimRegion ), __gl__ct__12CoveAndTilerFR7Bac0 ( ((struct CoveAndTiler *)__0this ), __0TrimRegion , __1b ) ) , __gl__ct__6MesherFR7Backend ( ((struct Mesher *)((((char *)__0this ))+ 8)),
__0TrimRegion , __1b ) ) , (__0this -> backend__6Slicer = __1b )) ;
return __0this ;

}


void __gl__dt__12CoveAndTilerFv (struct CoveAndTiler *, int );

void __gl__dt__6MesherFv (struct Mesher *, int );


void __gl__dt__6SlicerFv (struct Slicer *__0this , 
int __0__free )
{ if (__0this )
if (__0this ){ ( __gl__dt__6MesherFv ( ((struct Mesher *)((((char *)__0this ))+ 8)),
0 ) , ( __gl__dt__12CoveAndTilerFv ( ((struct CoveAndTiler *)__0this ), 0 ) , ((__0__free & 2)?( (((void )( ((((struct TrimRegion *)((((char
*)__0this ))+ 356)))?( ((((struct TrimRegion *)((((char *)__0this ))+ 356)))?( ( __gl__dt__6UarrayFv ( (struct Uarray *)(& (((struct TrimRegion *)((((char *)__0this ))+ 356)))->
uarray__10TrimRegion ), 2) , ( __gl__dt__8TrimlineFv ( (struct Trimline *)(& (((struct TrimRegion *)((((char *)__0this ))+ 356)))-> right__10TrimRegion ), 2) ,
( __gl__dt__8TrimlineFv ( (struct Trimline *)(& (((struct TrimRegion *)((((char *)__0this ))+ 356)))-> left__10TrimRegion ), 2) , (( 0 ) ))
) ) , 0 ) :( 0 ) ), 0 ) :( 0 ) )) )), 0 ) :0 ))
) ;

if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) )) ;
} }

void __glsetisolines__6SlicerFi (struct Slicer *__0this , int __1x )
{ 
__0this -> isolines__6Slicer = __1x ;
}

void __glsetDu__10TrimRegionFf (struct TrimRegion *, REAL );

void __glsetstriptessellation__6Sli0 (struct Slicer *__0this , REAL __1x , REAL __1y )
{ 
((void )0 );
__0this -> du__6Slicer = __1x ;
__0this -> dv__6Slicer = __1y ;
__glsetDu__10TrimRegionFf ( (struct TrimRegion *)__0this -> PTrimRegion, __0this -> du__6Slicer ) ;
}

void __glmarkverts__3ArcFv (struct Arc *);
void __glgetextrema__3ArcFPP3Arc (struct Arc *, Arc_ptr *);

int __glnumpts__3ArcFv (struct Arc *);

void __glinit__6MesherFUi (struct Mesher *, unsigned int );

void __glinit__4HullFv (struct Hull *);

void __glinit__10TrimRegionFlP3Arc (struct TrimRegion *, long , struct Arc *);

long __glinit__6UarrayFfP3ArcT2 (struct Uarray *, REAL , struct Arc *, struct Arc *);

struct Varray *__gl__ct__6VarrayFv (struct Varray *);

long __glinit__6VarrayFfP3ArcT2 (struct Varray *, REAL , struct Arc *, struct Arc *);


void __glgetGridExtent__10TrimRegio1 (struct TrimRegion *, struct TrimVertex *, struct TrimVertex *);

void __glsurfgrid__7BackendFfT1lN210 (struct Backend *, REAL , REAL , long , REAL , REAL , long );


void __glgetPts__10TrimRegionFP3Arc (struct TrimRegion *, struct Arc *);
void __glgetPts__10TrimRegionFR7Bac0 (struct TrimRegion *, struct Backend *);

void __glgetGridExtent__10TrimRegio0 (struct TrimRegion *);

void __gloutline__6SlicerFv (struct Slicer *);

int __glcanTile__10TrimRegionFv (struct TrimRegion *);

void __glcoveAndTile__12CoveAndTile0 (struct CoveAndTiler *);

void __glmesh__6MesherFv (struct Mesher *);

void __gl__dt__6VarrayFv (struct Varray *, int );

void __glslice__6SlicerFP3Arc (struct Slicer *__0this , Arc_ptr __1loop )
{ 
__glmarkverts__3ArcFv ( (struct Arc *)__1loop ) ;

{ Arc_ptr __1extrema [4];
__glgetextrema__3ArcFPP3Arc ( (struct Arc *)__1loop , (struct Arc **)__1extrema ) ;

{ unsigned int __1npts ;

__1npts = __glnumpts__3ArcFv ( (struct Arc *)__1loop ) ;
__glinit__10TrimRegionFlP3Arc ( (struct TrimRegion *)__0this -> PTrimRegion, (long )__1npts , __1extrema [0 ]) ;

__glinit__6MesherFUi ( (struct Mesher *)(&(__0this -> OMesher)), __1npts ) ;

{ long __1ulines ;

struct Varray __1varray ;
long __1vlines ;
long __1botv ;
long __1topv ;

__1ulines = __glinit__6UarrayFfP3ArcT2 ( (struct Uarray *)(& __0this -> PTrimRegion-> uarray__10TrimRegion ), __0this -> du__6Slicer , __1extrema [1 ], __1extrema [3 ]) ;

__gl__ct__6VarrayFv ( (struct Varray *)(& __1varray )) ;
__1vlines = __glinit__6VarrayFfP3ArcT2 ( (struct Varray *)(& __1varray ), __0this -> dv__6Slicer , __1extrema [0 ], __1extrema [2 ]) ;
__1botv = 0 ;

( (((struct TrimRegion *)__0this -> PTrimRegion)-> bot__10TrimRegion . vval__8Gridline = (__1varray . varray__6Varray [__1botv ]))) ;
__glgetGridExtent__10TrimRegio1 ( (struct TrimRegion *)__0this -> PTrimRegion, & ((__1extrema [0 ])-> pwlArc__3Arc -> pts__6PwlArc [0 ]), & ((__1extrema [0 ])-> pwlArc__3Arc -> pts__6PwlArc [0 ])) ;

{ { long __1quad ;

__1quad = 0 ;

for(;__1quad < __1varray . numquads__6Varray ;__1quad ++ ) { 
__glsurfgrid__7BackendFfT1lN210 ( (struct Backend *)__0this -> backend__6Slicer , __0this -> PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [0 ], __0this ->
PTrimRegion-> uarray__10TrimRegion . uarray__6Uarray [(__1ulines - 1 )], __1ulines - 1 , __1varray . vval__6Varray [__1quad ], __1varray . vval__6Varray [(__1quad + 1 )], (__1varray . voffset__6Varray [(__1quad + 1 )])-
(__1varray . voffset__6Varray [__1quad ])) ;

{ { long __2i ;

__2i = ((__1varray . voffset__6Varray [__1quad ])+ 1 );

for(;__2i <= (__1varray . voffset__6Varray [(__1quad + 1 )]);__2i ++ ) { 
__1topv = (__1botv ++ );

( (((struct TrimRegion *)__0this -> PTrimRegion)-> top__10TrimRegion . vindex__8Gridline = ((float )(__1topv - (__1varray . voffset__6Varray [__1quad ])))), ( (((struct TrimRegion *)__0this -> PTrimRegion)->
bot__10TrimRegion . vindex__8Gridline = ((float )(__1botv - (__1varray . voffset__6Varray [__1quad ])))), ( (((struct TrimRegion *)__0this -> PTrimRegion)-> top__10TrimRegion . vval__8Gridline = ((struct TrimRegion *)__0this ->
PTrimRegion)-> bot__10TrimRegion . vval__8Gridline ), ( (((struct TrimRegion *)__0this -> PTrimRegion)-> bot__10TrimRegion . vval__8Gridline = (__1varray . varray__6Varray [__1botv ])), ( (((struct TrimRegion *)__0this ->
PTrimRegion)-> top__10TrimRegion . ustart__8Gridline = ((struct TrimRegion *)__0this -> PTrimRegion)-> bot__10TrimRegion . ustart__8Gridline ), (((struct TrimRegion *)__0this -> PTrimRegion)-> top__10TrimRegion . uend__8Gridline = ((struct
TrimRegion *)__0this -> PTrimRegion)-> bot__10TrimRegion . uend__8Gridline )) ) ) ) ) ;
if (__2i == __1vlines )
__glgetPts__10TrimRegionFP3Arc ( (struct TrimRegion *)__0this -> PTrimRegion, __1extrema [2 ]) ;
else 
__glgetPts__10TrimRegionFR7Bac0 ( (struct TrimRegion *)__0this -> PTrimRegion, __0this -> backend__6Slicer ) ;
__glgetGridExtent__10TrimRegio0 ( (struct TrimRegion *)__0this -> PTrimRegion) ;
if (__0this -> isolines__6Slicer ){ 
__gloutline__6SlicerFv ( __0this ) ;
}
else 
{ 
if (__glcanTile__10TrimRegionFv ( (struct TrimRegion *)__0this -> PTrimRegion) )
__glcoveAndTile__12CoveAndTile0 ( (struct CoveAndTiler *)__0this ) ;
else 
__glmesh__6MesherFv ( (struct Mesher *)(&(__0this -> OMesher))) ;
}
}

}

}
}

}

}

__gl__dt__6VarrayFv ( (struct Varray *)(& __1varray ), 2) ;

}

}

}
}


void __glbgnoutline__7BackendFv (struct Backend *);

struct GridTrimVertex *__glnextupper__4HullFP14GridTr0 (struct Hull *, struct GridTrimVertex *);


void __gllinevert__7BackendFP10Grid0 (struct Backend *, struct GridVertex *);

void __gllinevert__7BackendFP10Trim0 (struct Backend *, struct TrimVertex *);

void __glendoutline__7BackendFv (struct Backend *);

struct GridTrimVertex *__glnextlower__4HullFP14GridTr0 (struct Hull *, struct GridTrimVertex *);



void __gloutline__6SlicerFv (struct Slicer *__0this )
{ 
struct GridTrimVertex __1upper ;

struct GridTrimVertex __1lower ;

void *__1__Xp00uzigaiaa ;

( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)(& __1upper ))-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)(& __1upper ))->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)(& __1upper ))-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)(& __1upper ))))) ) ) ;
( ( (0 ), ((((struct GridVertex *)(& ((struct GridTrimVertex *)(& __1lower ))-> dummyg__14GridTrimVertex ))))) , ( (((struct GridTrimVertex *)(& __1lower ))->
g__14GridTrimVertex = 0 ), ( (((struct GridTrimVertex *)(& __1lower ))-> t__14GridTrimVertex = 0 ), ((((struct GridTrimVertex *)(& __1lower ))))) ) ) ;

__glinit__4HullFv ( (struct Hull *)(&(__0this -> OMesher))) ;

__glbgnoutline__7BackendFv ( (struct Backend *)__0this -> backend__6Slicer ) ;
while (__glnextupper__4HullFP14GridTr0 ( (struct Hull *)(&(__0this -> OMesher)), & __1upper ) ){ 
if (( (((struct GridTrimVertex *)(& __1upper ))-> g__14GridTrimVertex ?1 :0 ))
)
__gllinevert__7BackendFP10Grid0 ( (struct Backend *)__0this -> backend__6Slicer , __1upper . g__14GridTrimVertex ) ;
else 
__gllinevert__7BackendFP10Trim0 ( (struct Backend *)__0this -> backend__6Slicer , __1upper . t__14GridTrimVertex ) ;
}
__glendoutline__7BackendFv ( (struct Backend *)__0this -> backend__6Slicer ) ;

__glbgnoutline__7BackendFv ( (struct Backend *)__0this -> backend__6Slicer ) ;
while (__glnextlower__4HullFP14GridTr0 ( (struct Hull *)(&(__0this -> OMesher)), & __1lower ) ){ 
if (( (((struct GridTrimVertex *)(& __1lower ))-> g__14GridTrimVertex ?1 :0 ))
)
__gllinevert__7BackendFP10Grid0 ( (struct Backend *)__0this -> backend__6Slicer , __1lower . g__14GridTrimVertex ) ;
else 
__gllinevert__7BackendFP10Trim0 ( (struct Backend *)__0this -> backend__6Slicer , __1lower . t__14GridTrimVertex ) ;
}
__glendoutline__7BackendFv ( (struct Backend *)__0this -> backend__6Slicer ) ;

((void )( (( (( ( (((void )( ((((struct PooledObj *)((struct GridTrimVertex *)(& __1lower ))))?( ((((struct PooledObj *)((struct GridTrimVertex *)(&
__1lower ))))?( (( 0 ) ), 0 ) :( 0 ) ), 0 ) :( 0 ) )) )), ((
0 ) )) , 0 ) ), 0 ) )) );

((void )( (( (( ( (((void )( ((((struct PooledObj *)((struct GridTrimVertex *)(& __1upper ))))?( ((((struct PooledObj *)((struct GridTrimVertex *)(&
__1upper ))))?( (( 0 ) ), 0 ) :( 0 ) ), 0 ) :( 0 ) )) )), ((
0 ) )) , 0 ) ), 0 ) )) );
}

void __gloutline__6SlicerFP3Arc (struct Slicer *__0this , Arc_ptr __1jarc )
{ 
__glmarkverts__3ArcFv ( (struct Arc *)__1jarc ) ;

if (__1jarc -> pwlArc__3Arc -> npts__6PwlArc >= 2 ){ 
__glbgnoutline__7BackendFv ( (struct Backend *)__0this -> backend__6Slicer ) ;
{ { int __2j ;

__2j = (__1jarc -> pwlArc__3Arc -> npts__6PwlArc - 1 );

for(;__2j >= 0 ;__2j -- ) 
__gllinevert__7BackendFP10Trim0 ( (struct Backend *)__0this -> backend__6Slicer , & (__1jarc -> pwlArc__3Arc -> pts__6PwlArc [__2j ])) ;
__glendoutline__7BackendFv ( (struct Backend *)__0this -> backend__6Slicer ) ;

}

}
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\tobezier.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/tobezier.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);














struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};







typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct Backend;

struct Mapdesc;

struct Flist;

struct Knotvector;

struct Quiltspec;

struct Quiltspec {	
int stride__9Quiltspec ;
int width__9Quiltspec ;
int offset__9Quiltspec ;
int order__9Quiltspec ;
int index__9Quiltspec ;
int bdry__9Quiltspec [2];
REAL step_size__9Quiltspec ;
Knot *breakpoints__9Quiltspec ;
};

typedef struct Quiltspec *Quiltspec_ptr ;


struct Quilt;

struct Quilt {	

char __W3__9PooledObj ;

struct Mapdesc *mapdesc__5Quilt ;
REAL *cpts__5Quilt ;
struct Quiltspec qspec__5Quilt [2];
Quiltspec_ptr eqspec__5Quilt ;
struct Quilt *next__5Quilt ;
};




typedef struct Quilt *Quilt_ptr ;



struct Knotvector;

struct Knotvector {	

long order__10Knotvector ;
long knotcount__10Knotvector ;
long stride__10Knotvector ;
Knot *knotlist__10Knotvector ;
};


struct Breakpt;

struct Breakpt {	
Knot value__7Breakpt ;
int multi__7Breakpt ;
int def__7Breakpt ;
};
struct Knotspec;

struct Knotspec {	
long order__8Knotspec ;
Knot_ptr inkbegin__8Knotspec ;
Knot_ptr inkend__8Knotspec ;
Knot_ptr outkbegin__8Knotspec ;
Knot_ptr outkend__8Knotspec ;
Knot_ptr kleft__8Knotspec ;
Knot_ptr kright__8Knotspec ;
Knot_ptr kfirst__8Knotspec ;
Knot_ptr klast__8Knotspec ;
Knot_ptr sbegin__8Knotspec ;
struct Breakpt *bbegin__8Knotspec ;
struct Breakpt *bend__8Knotspec ;
int ncoords__8Knotspec ;
int prestride__8Knotspec ;
int poststride__8Knotspec ;
int preoffset__8Knotspec ;
int postoffset__8Knotspec ;
int prewidth__8Knotspec ;
int postwidth__8Knotspec ;
int istransformed__8Knotspec ;
struct Knotspec *next__8Knotspec ;
struct Knotspec *kspectotrans__8Knotspec ;
};
struct Splinespec;

struct Splinespec {	

struct Knotspec *kspec__10Splinespec ;
int dim__10Splinespec ;
REAL *outcpts__10Splinespec ;
};

struct Splinespec *__gl__ct__10SplinespecFi (struct Splinespec *, int );

void __glkspecinit__10SplinespecFR10 (struct Splinespec *, struct Knotvector *);

void __glselect__10SplinespecFv (struct Splinespec *);
void __gllayout__10SplinespecFl (struct Splinespec *, long );
void __glsetupquilt__10SplinespecFP0 (struct Splinespec *, Quilt_ptr );
void __glcopy__10SplinespecFPf (struct Splinespec *, float *);
void __gltransform__10SplinespecFv (struct Splinespec *);
extern struct __mptr* __ptbl_vec_____core_tobezier_c___toBezier_[];

void __gltoBezier__5QuiltFR10Knotve0 (struct Quilt *__0this , 
struct Knotvector *__1knotvector , 
float *__1ctlpts , 
long __1ncoords )
{ 
struct Splinespec __1spline ;

__gl__ct__10SplinespecFi ( (struct Splinespec *)(& __1spline ), 1 ) ;
__glkspecinit__10SplinespecFR10 ( (struct Splinespec *)(& __1spline ), __1knotvector ) ;
__glselect__10SplinespecFv ( (struct Splinespec *)(& __1spline )) ;
__gllayout__10SplinespecFl ( (struct Splinespec *)(& __1spline ), __1ncoords ) ;
__glsetupquilt__10SplinespecFP0 ( (struct Splinespec *)(& __1spline ), (struct Quilt *)__0this ) ;
__glcopy__10SplinespecFPf ( (struct Splinespec *)(& __1spline ), __1ctlpts ) ;
__gltransform__10SplinespecFv ( (struct Splinespec *)(& __1spline )) ;
}

void __glkspecinit__10SplinespecFR11 (struct Splinespec *, struct Knotvector *, struct Knotvector *);

void __gltoBezier__5QuiltFR10Knotve1 (struct Quilt *__0this , 
struct Knotvector *__1sknotvector , 
struct Knotvector *__1tknotvector , 
float *__1ctlpts , 
long __1ncoords )
{ 
struct Splinespec __1spline ;

__gl__ct__10SplinespecFi ( (struct Splinespec *)(& __1spline ), 2 ) ;
__glkspecinit__10SplinespecFR11 ( (struct Splinespec *)(& __1spline ), __1sknotvector , __1tknotvector ) ;
__glselect__10SplinespecFv ( (struct Splinespec *)(& __1spline )) ;
__gllayout__10SplinespecFl ( (struct Splinespec *)(& __1spline ), __1ncoords ) ;
__glsetupquilt__10SplinespecFP0 ( (struct Splinespec *)(& __1spline ), (struct Quilt *)__0this ) ;
__glcopy__10SplinespecFPf ( (struct Splinespec *)(& __1spline ), __1ctlpts ) ;
__gltransform__10SplinespecFv ( (struct Splinespec *)(& __1spline )) ;
}


struct Splinespec *__gl__ct__10SplinespecFi (struct Splinespec *__0this , int __1dimen )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Splinespec *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Splinespec))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ))
__0this ->
dim__10Splinespec = __1dimen ;
return __0this ;

}

struct Knotspec *__gl__ct__8KnotspecFv (struct Knotspec *);

void __glkspecinit__10SplinespecFR10 (struct Splinespec *__0this , struct Knotvector *__1knotvector )
{ 
struct Knotspec *__0__X5 ;

__0this -> kspec__10Splinespec = __gl__ct__8KnotspecFv ( (struct Knotspec *)0 ) ;
__0this -> kspec__10Splinespec -> inkbegin__8Knotspec = ((*__1knotvector )). knotlist__10Knotvector ;
__0this -> kspec__10Splinespec -> inkend__8Knotspec = (((*__1knotvector )). knotlist__10Knotvector + ((*__1knotvector )). knotcount__10Knotvector );
__0this -> kspec__10Splinespec -> prestride__8Knotspec = (((int )((*__1knotvector )). stride__10Knotvector ));
__0this -> kspec__10Splinespec -> order__8Knotspec = ((*__1knotvector )). order__10Knotvector ;
__0this -> kspec__10Splinespec -> next__8Knotspec = 0 ;
}

void __glkspecinit__10SplinespecFR11 (struct Splinespec *__0this , struct Knotvector *__1sknotvector , struct Knotvector *__1tknotvector )
{ 
struct Knotspec *__0__X6 ;

__0this -> kspec__10Splinespec = __gl__ct__8KnotspecFv ( (struct Knotspec *)0 ) ;
{ struct Knotspec *__1tkspec ;

struct Knotspec *__0__X7 ;

__1tkspec = __gl__ct__8KnotspecFv ( (struct Knotspec *)0 ) ;

__0this -> kspec__10Splinespec -> inkbegin__8Knotspec = ((*__1sknotvector )). knotlist__10Knotvector ;
__0this -> kspec__10Splinespec -> inkend__8Knotspec = (((*__1sknotvector )). knotlist__10Knotvector + ((*__1sknotvector )). knotcount__10Knotvector );
__0this -> kspec__10Splinespec -> prestride__8Knotspec = (((int )((*__1sknotvector )). stride__10Knotvector ));
__0this -> kspec__10Splinespec -> order__8Knotspec = ((*__1sknotvector )). order__10Knotvector ;
__0this -> kspec__10Splinespec -> next__8Knotspec = __1tkspec ;

__1tkspec -> inkbegin__8Knotspec = ((*__1tknotvector )). knotlist__10Knotvector ;
__1tkspec -> inkend__8Knotspec = (((*__1tknotvector )). knotlist__10Knotvector + ((*__1tknotvector )). knotcount__10Knotvector );
__1tkspec -> prestride__8Knotspec = (((int )((*__1tknotvector )). stride__10Knotvector ));
__1tkspec -> order__8Knotspec = ((*__1tknotvector )). order__10Knotvector ;
__1tkspec -> next__8Knotspec = 0 ;

}
}

void __glpreselect__8KnotspecFv (struct Knotspec *);
void __glselect__8KnotspecFv (struct Knotspec *);

void __glselect__10SplinespecFv (struct Splinespec *__0this )
{ 
{ { struct Knotspec *__1knotspec ;

__1knotspec = __0this -> kspec__10Splinespec ;

for(;__1knotspec ;__1knotspec = __1knotspec -> next__8Knotspec ) { 
__glpreselect__8KnotspecFv ( (struct Knotspec *)__1knotspec ) ;
__glselect__8KnotspecFv ( (struct Knotspec *)__1knotspec ) ;
}

}

}
}


void __gllayout__10SplinespecFl (struct Splinespec *__0this , long __1ncoords )
{ 
long __1stride ;

__1stride = __1ncoords ;
{ { struct Knotspec *__1knotspec ;

void *__1__Xp00uzigaiaa ;

__1knotspec = __0this -> kspec__10Splinespec ;

for(;__1knotspec ;__1knotspec = __1knotspec -> next__8Knotspec ) { 
__1knotspec -> poststride__8Knotspec = (((int )__1stride ));
__1stride *= (((__1knotspec -> bend__8Knotspec - __1knotspec -> bbegin__8Knotspec )* __1knotspec -> order__8Knotspec )+ __1knotspec -> postoffset__8Knotspec );
__1knotspec -> preoffset__8Knotspec *= __1knotspec -> prestride__8Knotspec ;
__1knotspec -> prewidth__8Knotspec *= __1knotspec -> poststride__8Knotspec ;
__1knotspec -> postwidth__8Knotspec *= __1knotspec -> poststride__8Knotspec ;
__1knotspec -> postoffset__8Knotspec *= __1knotspec -> poststride__8Knotspec ;
__1knotspec -> ncoords__8Knotspec = (((int )__1ncoords ));
}
__0this -> outcpts__10Splinespec = (((float *)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (float ))* __1stride )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa ))))
));
((void )0 );

}

}
}

void __glcopy__8KnotspecFPfT1 (struct Knotspec *, float *, REAL *);

void __glcopy__10SplinespecFPf (struct Splinespec *__0this , float *__1incpts )
{ 
__glcopy__8KnotspecFPfT1 ( (struct Knotspec *)__0this -> kspec__10Splinespec , __1incpts , __0this -> outcpts__10Splinespec ) ;
}


void __glsetupquilt__10SplinespecFP0 (struct Splinespec *__0this , Quilt_ptr __1quilt )
{ 
Quiltspec_ptr __1qspec ;

__1qspec = __1quilt -> qspec__5Quilt ;
__1quilt -> eqspec__5Quilt = (__1qspec + __0this -> dim__10Splinespec );
{ { struct Knotspec *__1knotspec ;

__1knotspec = __0this -> kspec__10Splinespec ;

for(;__1knotspec ;( (__1knotspec = __1knotspec -> next__8Knotspec ), (__1qspec ++ )) ) { 
void *__1__Xp00uzigaiaa ;

__1qspec -> stride__9Quiltspec = __1knotspec -> poststride__8Knotspec ;
__1qspec -> width__9Quiltspec = (__1knotspec -> bend__8Knotspec - __1knotspec -> bbegin__8Knotspec );
__1qspec -> order__9Quiltspec = (((int )__1knotspec -> order__8Knotspec ));
__1qspec -> offset__9Quiltspec = __1knotspec -> postoffset__8Knotspec ;
__1qspec -> index__9Quiltspec = 0 ;
(__1qspec -> bdry__9Quiltspec [0 ])= ((__1knotspec -> kleft__8Knotspec == __1knotspec -> kfirst__8Knotspec )?1 :0 );
(__1qspec -> bdry__9Quiltspec [1 ])= ((__1knotspec -> kright__8Knotspec == __1knotspec -> klast__8Knotspec )?1 :0 );
__1qspec -> breakpoints__9Quiltspec = (((float *)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (float ))* (__1qspec -> width__9Quiltspec + 1 ))) ), (__1__Xp00uzigaiaa ?(((void
*)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ));
{ Knot_ptr __2k ;

__2k = __1qspec -> breakpoints__9Quiltspec ;
{ { struct Breakpt *__2bk ;

__2bk = __1knotspec -> bbegin__8Knotspec ;

for(;__2bk <= __1knotspec -> bend__8Knotspec ;__2bk ++ ) 
((*(__2k ++ )))= __2bk -> value__7Breakpt ;

}

}

}
}
__1quilt -> cpts__5Quilt = __0this -> outcpts__10Splinespec ;
__1quilt -> next__5Quilt = 0 ;

}

}
}

void __gltransform__8KnotspecFPf (struct Knotspec *, REAL *);

void __gltransform__10SplinespecFv (struct Splinespec *__0this )
{ 
{ { struct Knotspec *__1knotspec ;

__1knotspec = __0this -> kspec__10Splinespec ;

for(;__1knotspec ;__1knotspec = __1knotspec -> next__8Knotspec ) 
__1knotspec -> istransformed__8Knotspec = 0 ;

for(__1knotspec = __0this -> kspec__10Splinespec ;__1knotspec ;__1knotspec = __1knotspec -> next__8Knotspec ) { 
{ { struct Knotspec *__2kspec2 ;

__2kspec2 = __0this -> kspec__10Splinespec ;

for(;__2kspec2 ;__2kspec2 = __2kspec2 -> next__8Knotspec ) 
__2kspec2 -> kspectotrans__8Knotspec = __1knotspec ;
__gltransform__8KnotspecFPf ( (struct Knotspec *)__0this -> kspec__10Splinespec , __0this -> outcpts__10Splinespec ) ;
__1knotspec -> istransformed__8Knotspec = 1 ;

}

}
}

}

}
}


struct Knotspec *__gl__ct__8KnotspecFv (struct Knotspec *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Knotspec *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Knotspec))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> bbegin__8Knotspec = 0 ;
__0this -> sbegin__8Knotspec = 0 ;
__0this -> outkbegin__8Knotspec = 0 ;
} return __0this ;

}

void __glpt_io_copy__8KnotspecFPfT1 (struct Knotspec *, REAL *, float *);

void __glcopy__8KnotspecFPfT1 (struct Knotspec *__0this , float *__1inpt , REAL *__1outpt )
{ 
__1inpt = (((float *)((((long )__1inpt ))+ __0this -> preoffset__8Knotspec )));

if (__0this -> next__8Knotspec ){ 
{ { REAL *__2lpt ;

__2lpt = (__1outpt + __0this -> prewidth__8Knotspec );

for(;__1outpt != __2lpt ;__1outpt += __0this -> poststride__8Knotspec ) { 
__glcopy__8KnotspecFPfT1 ( (struct Knotspec *)__0this -> next__8Knotspec , __1inpt , __1outpt ) ;
__1inpt = (((float *)((((long )__1inpt ))+ __0this -> prestride__8Knotspec )));
}

}

}
}
else 
{ 
{ { REAL *__2lpt ;

__2lpt = (__1outpt + __0this -> prewidth__8Knotspec );

for(;__1outpt != __2lpt ;__1outpt += __0this -> poststride__8Knotspec ) { 
__glpt_io_copy__8KnotspecFPfT1 ( __0this , __1outpt , __1inpt ) ;
__1inpt = (((float *)((((long )__1inpt ))+ __0this -> prestride__8Knotspec )));
}

}

}
}
}

void __glshowpts__8KnotspecFPf (struct Knotspec *, REAL *);


void __glshowpts__8KnotspecFPf (struct Knotspec *__0this , REAL *__1outpt )
{ 
if (__0this -> next__8Knotspec ){ 
{ { REAL *__2lpt ;

__2lpt = (__1outpt + __0this -> prewidth__8Knotspec );

for(;__1outpt != __2lpt ;__1outpt += __0this -> poststride__8Knotspec ) 
__glshowpts__8KnotspecFPf ( (struct Knotspec *)__0this -> next__8Knotspec , __1outpt ) ;

}

}
}
else 
{ 
{ { REAL *__2lpt ;

__2lpt = (__1outpt + __0this -> prewidth__8Knotspec );

for(;__1outpt != __2lpt ;__1outpt += __0this -> poststride__8Knotspec ) 
( 0 ) ;

}

}
}
}

void __glfactors__8KnotspecFv (struct Knotspec *__0this )
{ 
Knot *__1mid ;
Knot_ptr __1fptr ;

__1mid = (((__0this -> outkend__8Knotspec - 1 )- __0this -> order__8Knotspec )+ __0this -> bend__8Knotspec -> multi__7Breakpt );
__1fptr = __0this -> sbegin__8Knotspec ;

{ { struct Breakpt *__1bpt ;

__1bpt = __0this -> bend__8Knotspec ;

for(;__1bpt >= __0this -> bbegin__8Knotspec ;__1bpt -- ) { 
__1mid -= __1bpt -> multi__7Breakpt ;
{ int __2def ;

__2def = (__1bpt -> def__7Breakpt - 1 );
if (__2def <= 0 )continue ;
{ Knot __2kv ;

Knot *__2kf ;

__2kv = __1bpt -> value__7Breakpt ;

__2kf = ((__1mid - __2def )+ (__0this -> order__8Knotspec - 1 ));
{ { Knot *__2kl ;

__2kl = (__2kf + __2def );

for(;__2kl != __2kf ;__2kl -- ) { 
Knot *__3kh ;

Knot *__3kt ;
for(( (__3kt = __2kl ), (__3kh = __1mid )) ;__3kt != __2kf ;( (__3kh -- ), (__3kt -- )) ) 
((*(__1fptr ++ )))=
((__2kv - ((*__3kh )))/ (((*__3kt ))- ((*__3kh ))));
((*__2kl ))= __2kv ;
}

}

}

}

}
}

}

}
}

void __glpt_oo_sum__8KnotspecFPfN210 (struct Knotspec *, REAL *, REAL *, REAL *, Knot , Knot );

void __glpt_oo_copy__8KnotspecFPfT1 (struct Knotspec *, REAL *, REAL *);

void __glinsert__8KnotspecFPf (struct Knotspec *__0this , REAL *__1p )
{ 
Knot_ptr __1fptr ;
REAL *__1srcpt ;
REAL *__1dstpt ;
struct Breakpt *__1bpt ;

__1fptr = __0this -> sbegin__8Knotspec ;
__1srcpt = ((__1p + __0this -> prewidth__8Knotspec )- __0this -> poststride__8Knotspec );
__1dstpt = (((__1p + __0this -> postwidth__8Knotspec )+ __0this -> postoffset__8Knotspec )- __0this -> poststride__8Knotspec );
__1bpt = __0this -> bend__8Knotspec ;

{ { REAL *__1pend ;

__1pend = (__1srcpt - (__0this -> poststride__8Knotspec * __1bpt -> def__7Breakpt ));

for(;__1srcpt != __1pend ;__1pend += __0this -> poststride__8Knotspec ) { 
REAL *__2p1 ;

__2p1 = __1srcpt ;
{ { REAL *__2p2 ;

__2p2 = (__1srcpt - __0this -> poststride__8Knotspec );

for(;__2p2 != __1pend ;( (__2p1 = __2p2 ), (__2p2 -= __0this -> poststride__8Knotspec )) ) { 
__glpt_oo_sum__8KnotspecFPfN210 ( __0this , __2p1 , __2p1 , __2p2 ,
(*__1fptr ), (float )(1.0 - ((*__1fptr )))) ;
__1fptr ++ ;
}

}

}
}

for(-- __1bpt ;__1bpt >= __0this -> bbegin__8Knotspec ;__1bpt -- ) { 
{ { int __2multi ;

__2multi = __1bpt -> multi__7Breakpt ;

for(;__2multi > 0 ;__2multi -- ) { 
__glpt_oo_copy__8KnotspecFPfT1 ( __0this , __1dstpt , __1srcpt ) ;
__1dstpt -= __0this -> poststride__8Knotspec ;
__1srcpt -= __0this -> poststride__8Knotspec ;
}

{ { REAL *__2pend ;

__2pend = (__1srcpt - (__0this -> poststride__8Knotspec * __1bpt -> def__7Breakpt ));

for(;__1srcpt != __2pend ;( (__2pend += __0this -> poststride__8Knotspec ), (__1dstpt -= __0this -> poststride__8Knotspec )) ) { 
__glpt_oo_copy__8KnotspecFPfT1 ( __0this , __1dstpt , __1srcpt )
;
{ REAL *__3p1 ;

__3p1 = __1srcpt ;
{ { REAL *__3p2 ;

__3p2 = (__1srcpt - __0this -> poststride__8Knotspec );

for(;__3p2 != __2pend ;( (__3p1 = __3p2 ), (__3p2 -= __0this -> poststride__8Knotspec )) ) { 
__glpt_oo_sum__8KnotspecFPfN210 ( __0this , __3p1 , __3p1 , __3p2 ,
(*__1fptr ), (float )(1.0 - ((*__1fptr )))) ;
__1fptr ++ ;
}

}

}

}
}

}

}

}

}
}

}

}
}



void __glpreselect__8KnotspecFv (struct Knotspec *__0this )
{ 
Knot __1kval ;

for(( (__0this -> klast__8Knotspec = (__0this -> inkend__8Knotspec - __0this -> order__8Knotspec )), (__1kval = ((*__0this -> klast__8Knotspec )))) ;__0this -> klast__8Knotspec != __0this -> inkend__8Knotspec ;__0this ->
klast__8Knotspec ++ ) 
if (! ( (((((*__0this -> klast__8Knotspec ))- __1kval )< 10.0e-5 )?1 :0 )) )break ;

for(( (__0this -> kfirst__8Knotspec = ((__0this -> inkbegin__8Knotspec + __0this -> order__8Knotspec )- 1 )), (__1kval = ((*__0this -> kfirst__8Knotspec )))) ;__0this -> kfirst__8Knotspec != __0this ->
inkend__8Knotspec ;__0this -> kfirst__8Knotspec ++ ) 
if (! ( (((((*__0this -> kfirst__8Knotspec ))- __1kval )< 10.0e-5 )?1 :0 )) )break ;

{ { Knot_ptr __1k ;

unsigned int __0__X8 ;

struct Breakpt *__0__X9 ;

unsigned int __1__X10 ;

void *__1__Xp00uzigaiaa ;

__1k = (__0this -> kfirst__8Knotspec - 1 );

for(;__1k >= __0this -> inkbegin__8Knotspec ;__1k -- ) 
if (! ( (((__1kval - ((*__1k )))< 10.0e-5 )?1 :0 )) )break ;
__1k ++ ;

__0this -> bbegin__8Knotspec = ( (__0__X9 = (struct Breakpt *)( (__1__X10 = ((sizeof (struct Breakpt ))* (__0__X8 = ((__0this -> klast__8Knotspec - __0this ->
kfirst__8Knotspec )+ 1 )))), ( (__1__Xp00uzigaiaa = malloc ( __1__X10 ) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ) ), __0__X9 ) ;

__0this -> bbegin__8Knotspec -> multi__7Breakpt = (__0this -> kfirst__8Knotspec - __1k );
__0this -> bbegin__8Knotspec -> value__7Breakpt = __1kval ;
__0this -> bend__8Knotspec = __0this -> bbegin__8Knotspec ;

__0this -> kleft__8Knotspec = (__0this -> kright__8Knotspec = __0this -> kfirst__8Knotspec );

}

}
}

void __glbreakpoints__8KnotspecFv (struct Knotspec *);
void __glknots__8KnotspecFv (struct Knotspec *);

void __glselect__8KnotspecFv (struct Knotspec *__0this )
{ 
__glbreakpoints__8KnotspecFv ( __0this ) ;
__glknots__8KnotspecFv ( __0this ) ;
__glfactors__8KnotspecFv ( __0this ) ;

__0this -> preoffset__8Knotspec = (__0this -> kleft__8Knotspec - (__0this -> inkbegin__8Knotspec + __0this -> order__8Knotspec ));
__0this -> postwidth__8Knotspec = (((int )((__0this -> bend__8Knotspec - __0this -> bbegin__8Knotspec )* __0this -> order__8Knotspec )));
__0this -> prewidth__8Knotspec = (((int )((__0this -> outkend__8Knotspec - __0this -> outkbegin__8Knotspec )- __0this -> order__8Knotspec )));
__0this -> postoffset__8Knotspec = ((__0this -> bbegin__8Knotspec -> def__7Breakpt > 1 )?(__0this -> bbegin__8Knotspec -> def__7Breakpt - 1 ):0 );
}



void __glbreakpoints__8KnotspecFv (struct Knotspec *__0this )
{ 
struct Breakpt *__1ubpt ;
struct Breakpt *__1ubend ;
long __1nfactors ;

__1ubpt = __0this -> bbegin__8Knotspec ;
__1ubend = __0this -> bend__8Knotspec ;
__1nfactors = 0 ;

__1ubpt -> value__7Breakpt = __1ubend -> value__7Breakpt ;
__1ubpt -> multi__7Breakpt = __1ubend -> multi__7Breakpt ;

__0this -> kleft__8Knotspec = __0this -> kright__8Knotspec ;

for(;__0this -> kright__8Knotspec != __0this -> klast__8Knotspec ;__0this -> kright__8Knotspec ++ ) { 
if (( (((((*__0this -> kright__8Knotspec ))- __1ubpt -> value__7Breakpt )< 10.0e-5 )?1 :0 ))
){ 
__1ubpt -> multi__7Breakpt ++ ;
}
else 
{ 
__1ubpt -> def__7Breakpt = (((int )(__0this -> order__8Knotspec - __1ubpt -> multi__7Breakpt )));
__1nfactors += ((__1ubpt -> def__7Breakpt * (__1ubpt -> def__7Breakpt - 1 ))/ 2 );
(++ __1ubpt )-> value__7Breakpt = ((*__0this -> kright__8Knotspec ));
__1ubpt -> multi__7Breakpt = 1 ;
}
}
__1ubpt -> def__7Breakpt = (((int )(__0this -> order__8Knotspec - __1ubpt -> multi__7Breakpt )));
__1nfactors += ((__1ubpt -> def__7Breakpt * (__1ubpt -> def__7Breakpt - 1 ))/ 2 );

__0this -> bend__8Knotspec = __1ubpt ;

if (__1nfactors ){ 
void *__1__Xp00uzigaiaa ;

__0this -> sbegin__8Knotspec = (float *)(((float *)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (float ))* __1nfactors )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void
*)__1__Xp00uzigaiaa )))) ));
}
else 
{ 
__0this -> sbegin__8Knotspec = 0 ;
}
}


void __glknots__8KnotspecFv (struct Knotspec *__0this )
{ 
Knot_ptr __1inkpt ;
Knot_ptr __1inkend ;

void *__1__Xp00uzigaiaa ;

__1inkpt = (__0this -> kleft__8Knotspec - __0this -> order__8Knotspec );
__1inkend = (__0this -> kright__8Knotspec + __0this -> bend__8Knotspec -> def__7Breakpt );

__0this -> outkbegin__8Knotspec = (float *)(((float *)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (float ))* (__1inkend - __1inkpt ))) ), (__1__Xp00uzigaiaa ?(((void
*)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ));
{ { Knot_ptr __1outkpt ;

__1outkpt = __0this -> outkbegin__8Knotspec ;

for(;__1inkpt != __1inkend ;( (__1inkpt ++ ), (__1outkpt ++ )) ) 
((*__1outkpt ))= ((*__1inkpt ));

__0this -> outkend__8Knotspec = __1outkpt ;

}

}
}

void __gltransform__8KnotspecFPf (struct Knotspec *__0this , REAL *__1p )
{ 
if (__0this -> next__8Knotspec ){ 
if (__0this == (struct Knotspec *)__0this -> kspectotrans__8Knotspec ){ 
__gltransform__8KnotspecFPf ( (struct
Knotspec *)__0this -> next__8Knotspec , __1p ) ;
}
else 
{ 
if (__0this -> istransformed__8Knotspec ){ 
__1p += __0this -> postoffset__8Knotspec ;
{ { REAL *__4pend ;

__4pend = (__1p + __0this -> postwidth__8Knotspec );

for(;__1p != __4pend ;__1p += __0this -> poststride__8Knotspec ) 
__gltransform__8KnotspecFPf ( (struct Knotspec *)__0this -> next__8Knotspec , __1p ) ;

}

}
}
else 
{ 
REAL *__4pend ;

__4pend = (__1p + __0this -> prewidth__8Knotspec );
for(;__1p != __4pend ;__1p += __0this -> poststride__8Knotspec ) 
__gltransform__8KnotspecFPf ( (struct Knotspec *)__0this -> next__8Knotspec , __1p ) ;
}
}
}
else 
{ 
if (__0this == (struct Knotspec *)__0this -> kspectotrans__8Knotspec ){ 
__glinsert__8KnotspecFPf ( __0this , __1p ) ;
}
else 
{ 
if (__0this -> istransformed__8Knotspec ){ 
__1p += __0this -> postoffset__8Knotspec ;
{ { REAL *__4pend ;

__4pend = (__1p + __0this -> postwidth__8Knotspec );

for(;__1p != __4pend ;__1p += __0this -> poststride__8Knotspec ) 
__glinsert__8KnotspecFPf ( (struct Knotspec *)__0this -> kspectotrans__8Knotspec , __1p ) ;

}

}
}
else 
{ 
REAL *__4pend ;

__4pend = (__1p + __0this -> prewidth__8Knotspec );
for(;__1p != __4pend ;__1p += __0this -> poststride__8Knotspec ) 
__glinsert__8KnotspecFPf ( (struct Knotspec *)__0this -> kspectotrans__8Knotspec , __1p ) ;
}
}
}
}


void __gl__dt__8KnotspecFv (struct Knotspec *__0this , 
int __0__free )
{ 
void *__1__X11 ;

void *__1__X12 ;

void *__1__X13 ;

if (__0this ){ 
if (__0this -> bbegin__8Knotspec )( (__1__X11 = (void *)__0this -> bbegin__8Knotspec ), ( (__1__X11 ?( free ( __1__X11 ) ,
0 ) :( 0 ) )) ) ;
if (__0this -> sbegin__8Knotspec )( (__1__X12 = (void *)__0this -> sbegin__8Knotspec ), ( (__1__X12 ?( free ( __1__X12 ) , 0 ) :(
0 ) )) ) ;
if (__0this -> outkbegin__8Knotspec )( (__1__X13 = (void *)__0this -> outkbegin__8Knotspec ), ( (__1__X13 ?( free ( __1__X13 ) , 0 ) :(
0 ) )) ) ;
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}

void __glpt_io_copy__8KnotspecFPfT1 (struct Knotspec *__0this , REAL *__1topt , float *__1frompt )
{ 
switch (__0this -> ncoords__8Knotspec ){ 
case 4 :
(__1topt [3 ])= (((float )(__1frompt [3 ])));

case 3 :
(__1topt [2 ])= (((float )(__1frompt [2 ])));
case 2 :
(__1topt [1 ])= (((float )(__1frompt [1 ])));
case 1 :
(__1topt [0 ])= (((float )(__1frompt [0 ])));
break ;
default :{ 
{ { int __3i ;

__3i = 0 ;

for(;__3i < __0this -> ncoords__8Knotspec ;__3i ++ ) 
((*(__1topt ++ )))= (((float )((*(__1frompt ++ )))));

}

}
}
}
}

// extern void *memcpy (void *, void *, size_t );

void __glpt_oo_copy__8KnotspecFPfT1 (struct Knotspec *__0this , REAL *__1topt , REAL *__1frompt )
{ 
switch (__0this -> ncoords__8Knotspec ){ 
case 4 :
(__1topt [3 ])= (__1frompt [3 ]);
case 3 :
(__1topt [2 ])= (__1frompt [2 ]);
case 2 :
(__1topt [1 ])= (__1frompt [1 ]);
case 1 :
(__1topt [0 ])= (__1frompt [0 ]);
break ;
default :
memcpy ( (void *)__1topt , (void *)__1frompt , __0this -> ncoords__8Knotspec * (sizeof (REAL ))) ;
}
}

void __glpt_oo_sum__8KnotspecFPfN210 (struct Knotspec *__0this , REAL *__1x , REAL *__1y , REAL *__1z , Knot __1a , Knot __1b )
{ 
switch (__0this -> ncoords__8Knotspec ){ 
case 4 :
(__1x [3 ])= ((__1a *
(__1y [3 ]))+ (__1b * (__1z [3 ])));
case 3 :
(__1x [2 ])= ((__1a * (__1y [2 ]))+ (__1b * (__1z [2 ])));
case 2 :
(__1x [1 ])= ((__1a * (__1y [1 ]))+ (__1b * (__1z [1 ])));
case 1 :
(__1x [0 ])= ((__1a * (__1y [0 ]))+ (__1b * (__1z [0 ])));
break ;
default :{ 
{ { int __3i ;

__3i = 0 ;

for(;__3i < __0this -> ncoords__8Knotspec ;__3i ++ ) 
((*(__1x ++ )))= ((__1a * ((*(__1y ++ ))))+ (__1b * ((*(__1z ++ )))));

}

}
}
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\trimline.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/trimline.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);






struct Arc;

struct Backend;






typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;







struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};












struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};


struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;








struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};






struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};



extern struct __mptr* __ptbl_vec_____core_trimline_c_____ct_[];


struct Trimline *__gl__ct__8TrimlineFv (struct Trimline *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Trimline *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Trimline))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> size__8Trimline = 0 ;

__0this -> pts__8Trimline = 0 ;

__0this -> numverts__8Trimline = 0 ;
__0this -> tinterp__8Trimline = (& __0this -> t__8Trimline );

__0this -> binterp__8Trimline = (& __0this -> b__8Trimline );
} return __0this ;

}


void __gl__dt__8TrimlineFv (struct Trimline *__0this , 
int __0__free )
{ 
void *__1__X5 ;

if (__0this ){ 
if (__0this -> pts__8Trimline )( (__1__X5 = (void *)__0this -> pts__8Trimline ), ( (__1__X5 ?( free ( __1__X5 ) ,
0 ) :( 0 ) )) ) ;
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}




static void grow__8TrimlineFl (struct Trimline *, long );

static void append__8TrimlineFP10TrimVertex (struct Trimline *, struct TrimVertex *);

void __glinit__8TrimlineFP10TrimVer0 (struct Trimline *__0this , struct TrimVertex *__1v )
{ 
( (__0this -> numverts__8Trimline = 0 )) ;
grow__8TrimlineFl ( __0this , (long )1 ) ;
append__8TrimlineFP10TrimVertex ( __0this , __1v ) ;
}




void __glinit__8TrimlineFlP3ArcT1 (struct Trimline *__0this , long __1npts , Arc_ptr __1jarc , long __1last )
{ 
void *__1__X6 ;

void *__1__Xp00uzigaiaa ;

( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = __1jarc ), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (&
(__1jarc -> pwlArc__3Arc -> pts__6PwlArc [((long )0 )]))), (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (__1jarc -> pwlArc__3Arc -> pts__6PwlArc [__1last ])))) )
;
( ((__0this -> size__8Trimline < (__1npts + 2 ))?( ( (__0this -> size__8Trimline = (2 * (__1npts + 2 ))), ( (__0this -> pts__8Trimline ?(
( (__1__X6 = (void *)__0this -> pts__8Trimline ), ( (__1__X6 ?( free ( __1__X6 ) , 0 ) :( 0 ) ))
) , 0 ) :( 0 ) ), (__0this -> pts__8Trimline = (struct TrimVertex **)(((struct TrimVertex **)( (__1__Xp00uzigaiaa = malloc ( ((sizeof
(struct TrimVertex *))* __0this -> size__8Trimline )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )))) ) , 0 ) :( 0 )
)) ;
}


void __glgetNextPt__8TrimlineFv (struct Trimline *__0this )
{ 
((*__0this -> binterp__8Trimline ))= (*( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc ==
((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc )?( ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> arc__7Jarcloc -> next__3Arc ), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), (((void )0 ))) ) )
, 0 ) :( 0 ) ), (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc ++ )) ) );
}


void __glgetPrevPt__8TrimlineFv (struct Trimline *__0this )
{ 
((*__0this -> binterp__8Trimline ))= (*( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc ==
((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc )?( ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> arc__7Jarcloc -> prev__3Arc ), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), ( (((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), (((void )0 ))) ) )
, 0 ) :( 0 ) ), (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc -- )) ) );
}




long __glinterpvert__8TrimlineSFP100 (struct TrimVertex *, struct TrimVertex *, struct TrimVertex *, REAL );


void __gltriangle__7BackendFP10Trim0 (struct Backend *, struct TrimVertex *, struct TrimVertex *, struct TrimVertex *);





void __glgetNextPts__8TrimlineFfR7B0 (struct Trimline *__0this , REAL __1vval , struct Backend *__1backend )
{ 
register struct TrimVertex *__1p ;

struct TrimVertex *__1__Xtmp00aesmaigk ;

( (__0this -> numverts__8Trimline = 0 )) ;

( (__1__Xtmp00aesmaigk = __0this -> tinterp__8Trimline ), ( (__0this -> tinterp__8Trimline = __0this -> binterp__8Trimline ), (__0this -> binterp__8Trimline = __1__Xtmp00aesmaigk )) ) ;
( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __0this -> tinterp__8Trimline )) ;
((void )0 );

;
for(__1p = ( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
plast__7Jarcloc )?( ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> next__3Arc ), (
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), (
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(&
__0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), (((void )0 ))) ) ) , 0 ) :( 0 )
), (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc ++ )) ) ;(__1p -> param__10TrimVertex [1 ])>= __1vval ;__1p = ( (((void )0 )),
( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc )?( ( (((struct Jarcloc *)(&
__0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> next__3Arc ), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc ->
npts__6PwlArc - 1 )]))), (((void )0 ))) ) ) , 0 ) :( 0 ) ), (((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> p__7Jarcloc ++ )) ) ) { 
( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __1p ))
;
}

if (__glinterpvert__8TrimlineSFP100 ( ( (__0this -> i__8Trimline = __0this -> numverts__8Trimline ), (__0this -> pts__8Trimline [(-- __0this -> i__8Trimline )])) , __1p , __0this ->
binterp__8Trimline , __1vval ) ){ 
__0this -> binterp__8Trimline -> nuid__10TrimVertex = __1p -> nuid__10TrimVertex ;
__gltriangle__7BackendFP10Trim0 ( (struct Backend *)__1backend , __1p , __0this -> binterp__8Trimline , ( (__0this -> i__8Trimline = __0this -> numverts__8Trimline ), (__0this -> pts__8Trimline [(-- __0this ->
i__8Trimline )])) ) ;
( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __0this -> binterp__8Trimline )) ;
}
( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc == (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ])))?(((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))):(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))))) ;
(( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc )?(
( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> prev__3Arc ), ( (((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(&
__0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), (((void )0 ))) ) ) , 0 ) :( 0 ) ),
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc -- )) ) );
( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc == (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ])))?(((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))):(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))))) ;
}








void __glgetPrevPts__8TrimlineFfR7B0 (struct Trimline *__0this , REAL __1vval , struct Backend *__1backend )
{ 
register struct TrimVertex *__1q ;

struct TrimVertex *__1__Xtmp00aesmaigk ;

( (__0this -> numverts__8Trimline = 0 )) ;

( (__1__Xtmp00aesmaigk = __0this -> tinterp__8Trimline ), ( (__0this -> tinterp__8Trimline = __0this -> binterp__8Trimline ), (__0this -> binterp__8Trimline = __1__Xtmp00aesmaigk )) ) ;
( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __0this -> tinterp__8Trimline )) ;
((void )0 );

;
for(__1q = ( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
plast__7Jarcloc )?( ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> prev__3Arc ), (
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(&
__0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), (((void )0 ))) ) ) , 0 ) :( 0 )
), (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc -- )) ) ;(__1q -> param__10TrimVertex [1 ])>= __1vval ;__1q = ( (((void )0 )),
( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc )?( ( (((struct Jarcloc *)(&
__0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> prev__3Arc ), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc ->
npts__6PwlArc - 1 )]))), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc ->
pwlArc__3Arc -> pts__6PwlArc [0 ]))), (((void )0 ))) ) ) , 0 ) :( 0 ) ), (((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> p__7Jarcloc -- )) ) ) { 
( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __1q ))
;
}

if (__glinterpvert__8TrimlineSFP100 ( __1q , ( (__0this -> i__8Trimline = __0this -> numverts__8Trimline ), (__0this -> pts__8Trimline [(-- __0this -> i__8Trimline )])) , __0this ->
binterp__8Trimline , __1vval ) ){ 
__0this -> binterp__8Trimline -> nuid__10TrimVertex = __1q -> nuid__10TrimVertex ;
__gltriangle__7BackendFP10Trim0 ( (struct Backend *)__1backend , ( (__0this -> i__8Trimline = __0this -> numverts__8Trimline ), (__0this -> pts__8Trimline [(-- __0this -> i__8Trimline )])) , __0this ->
binterp__8Trimline , __1q ) ;
( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __0this -> binterp__8Trimline )) ;
}
( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc == (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ])))?(((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))):(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))))) ;
(( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc )?(
( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> next__3Arc ), ( (((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), ( (((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), (((void )0 ))) ) ) , 0 ) :( 0 ) ),
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc ++ )) ) );
( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc == (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ])))?(((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(& __0this ->
jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))):(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))))) ;
}




void __glgetNextPts__8TrimlineFP3Ar0 (struct Trimline *__0this , Arc_ptr __1botarc )
{ 
struct TrimVertex *__1__Xtmp00aesmaigk ;

( (__0this -> numverts__8Trimline = 0 )) ;

( (__1__Xtmp00aesmaigk = __0this -> tinterp__8Trimline ), ( (__0this -> tinterp__8Trimline = __0this -> binterp__8Trimline ), (__0this -> binterp__8Trimline = __1__Xtmp00aesmaigk )) ) ;
( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __0this -> tinterp__8Trimline )) ;

{ struct PwlArc *__1lastpwl ;
struct TrimVertex *__1lastpt1 ;
struct TrimVertex *__1lastpt2 ;

register struct TrimVertex *__1p ;

__1lastpwl = __1botarc -> prev__3Arc -> pwlArc__3Arc ;
__1lastpt1 = (& (__1lastpwl -> pts__6PwlArc [(__1lastpwl -> npts__6PwlArc - 1 )]));
__1lastpt2 = __1botarc -> pwlArc__3Arc -> pts__6PwlArc ;

__1p = ( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
plast__7Jarcloc )?( ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> next__3Arc ), (
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), (
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(&
__0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), (((void )0 ))) ) ) , 0 ) :( 0 )
), (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc ++ )) ) ;
for(( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __1p )) ;__1p != __1lastpt2 ;( (((void )0 )), ((__0this -> pts__8Trimline [(__0this ->
numverts__8Trimline ++ )])= __1p )) ) { 
((void )0 );
__1p = ( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
plast__7Jarcloc )?( ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> next__3Arc ), (
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), (
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(&
__0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), (((void )0 ))) ) ) , 0 ) :( 0 )
), (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc ++ )) ) ;
}

}
}




void __glgetPrevPts__8TrimlineFP3Ar0 (struct Trimline *__0this , Arc_ptr __1botarc )
{ 
struct TrimVertex *__1__Xtmp00aesmaigk ;

( (__0this -> numverts__8Trimline = 0 )) ;

( (__1__Xtmp00aesmaigk = __0this -> tinterp__8Trimline ), ( (__0this -> tinterp__8Trimline = __0this -> binterp__8Trimline ), (__0this -> binterp__8Trimline = __1__Xtmp00aesmaigk )) ) ;
( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __0this -> tinterp__8Trimline )) ;

{ struct PwlArc *__1lastpwl ;
struct TrimVertex *__1lastpt1 ;
struct TrimVertex *__1lastpt2 ;

register struct TrimVertex *__1q ;

__1lastpwl = __1botarc -> prev__3Arc -> pwlArc__3Arc ;
__1lastpt1 = (& (__1lastpwl -> pts__6PwlArc [(__1lastpwl -> npts__6PwlArc - 1 )]));
__1lastpt2 = __1botarc -> pwlArc__3Arc -> pts__6PwlArc ;

__1q = ( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
plast__7Jarcloc )?( ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> prev__3Arc ), (
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(&
__0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), (((void )0 ))) ) ) , 0 ) :( 0 )
), (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc -- )) ) ;
for(( (((void )0 )), ((__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __1q )) ;__1q != __1lastpt1 ;( (((void )0 )), ((__0this -> pts__8Trimline [(__0this ->
numverts__8Trimline ++ )])= __1q )) ) { 
((void )0 );
__1q = ( (((void )0 )), ( ((((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc == ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))->
plast__7Jarcloc )?( ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc = ((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> prev__3Arc ), (
(((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc = (& (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [(((struct Jarcloc *)(&
__0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> npts__6PwlArc - 1 )]))), ( (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> plast__7Jarcloc = (& (((struct
Jarcloc *)(& __0this -> jarcl__8Trimline ))-> arc__7Jarcloc -> pwlArc__3Arc -> pts__6PwlArc [0 ]))), (((void )0 ))) ) ) , 0 ) :( 0 )
), (((struct Jarcloc *)(& __0this -> jarcl__8Trimline ))-> p__7Jarcloc -- )) ) ;
}

}
}

long __glinterpvert__8TrimlineSFP100 (struct TrimVertex *__1a , struct TrimVertex *__1b , struct TrimVertex *__1c , REAL __1vval )
{ 
REAL __1denom ;

__1denom = ((__1a -> param__10TrimVertex [1 ])- (__1b -> param__10TrimVertex [1 ]));

if (__1denom != 0 ){ 
if (__1vval == (__1a -> param__10TrimVertex [1 ])){ 
(__1c -> param__10TrimVertex [0 ])= (__1a -> param__10TrimVertex [0 ]);
(__1c -> param__10TrimVertex [1 ])= (__1a -> param__10TrimVertex [1 ]);
__1c -> nuid__10TrimVertex = __1a -> nuid__10TrimVertex ;
return (long )0 ;
}
else 
if (__1vval == (__1b -> param__10TrimVertex [1 ])){ 
(__1c -> param__10TrimVertex [0 ])= (__1b -> param__10TrimVertex [0 ]);
(__1c -> param__10TrimVertex [1 ])= (__1b -> param__10TrimVertex [1 ]);
__1c -> nuid__10TrimVertex = __1b -> nuid__10TrimVertex ;
return (long )0 ;
}
else 
{ 
REAL __3r ;

__3r = (((__1a -> param__10TrimVertex [1 ])- __1vval )/ __1denom );
(__1c -> param__10TrimVertex [0 ])= ((__1a -> param__10TrimVertex [0 ])- (__3r * ((__1a -> param__10TrimVertex [0 ])- (__1b -> param__10TrimVertex [0 ]))));
(__1c -> param__10TrimVertex [1 ])= __1vval ;
return (long )1 ;
}
}
else 
{ 
(__1c -> param__10TrimVertex [0 ])= (__1a -> param__10TrimVertex [0 ]);
(__1c -> param__10TrimVertex [1 ])= (__1a -> param__10TrimVertex [1 ]);
__1c -> nuid__10TrimVertex = __1a -> nuid__10TrimVertex ;
return (long )0 ;
}
}

static void append__8TrimlineFP10TrimVertex (struct Trimline *__0this , 
struct TrimVertex *__1v )
{ 
((void )0 );
(__0this -> pts__8Trimline [(__0this -> numverts__8Trimline ++ )])= __1v ;
}

static void grow__8TrimlineFl (struct Trimline *__0this , 
long __1npts )
{ 
void *__1__X6 ;

void *__1__Xp00uzigaiaa ;

if (__0this -> size__8Trimline < __1npts ){ 
void *__1__X6 ;

void *__1__Xp00uzigaiaa ;

__0this -> size__8Trimline = (2 * __1npts );
if (__0this -> pts__8Trimline )( (__1__X6 = (void *)__0this -> pts__8Trimline ), ( (__1__X6 ?( free ( __1__X6 ) , 0 ) :(
0 ) )) ) ;
__0this -> pts__8Trimline = (struct TrimVertex **)(((struct TrimVertex **)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (struct TrimVertex *))* __0this -> size__8Trimline )) ), (__1__Xp00uzigaiaa ?(((void
*)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ));
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\uarray.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/uarray.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);









typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct Arc;

struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};





struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};









struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;








extern struct __mptr* __ptbl_vec_____core_uarray_c_____ct_[];


struct Uarray *__gl__ct__6UarrayFv (struct Uarray *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Uarray *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Uarray))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> uarray__6Uarray = 0 ;
__0this -> size__6Uarray = 0 ;
} return __0this ;

}


void __gl__dt__6UarrayFv (struct Uarray *__0this , 
int __0__free )
{ 
void *__1__X5 ;

if (__0this ){ 
if (__0this -> uarray__6Uarray )( (__1__X5 = (void *)__0this -> uarray__6Uarray ), ( (__1__X5 ?( free ( __1__X5 ) ,
0 ) :( 0 ) )) ) ;
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}




long __glinit__6UarrayFfP3ArcT2 (struct Uarray *__0this , REAL __1delta , Arc_ptr __1lo , Arc_ptr __1hi )
{ 
__0this -> ulines__6Uarray = ((((long )(((( (((REAL *)(((struct Arc *)__1hi )-> pwlArc__3Arc ->
pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])- (( (((REAL *)(((struct Arc *)__1lo )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ]))/ __1delta )))+ 3 );
if (__0this -> size__6Uarray < __0this -> ulines__6Uarray ){ 
void *__1__X6 ;

void *__1__Xp00uzigaiaa ;

__0this -> size__6Uarray = (__0this -> ulines__6Uarray * 2 );
if (__0this -> uarray__6Uarray )( (__1__X6 = (void *)__0this -> uarray__6Uarray ), ( (__1__X6 ?( free ( __1__X6 ) , 0 ) :(
0 ) )) ) ;
__0this -> uarray__6Uarray = (((float *)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (float ))* __0this -> size__6Uarray )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void
*)__1__Xp00uzigaiaa )))) ));
((void )0 );
}
(__0this -> uarray__6Uarray [0 ])= ((( (((REAL *)(((struct Arc *)__1lo )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])- (__1delta / 2.0 ));
{ { long __1i ;

__1i = 1 ;

for(;__1i != __0this -> ulines__6Uarray ;__1i ++ ) 
(__0this -> uarray__6Uarray [__1i ])= ((__0this -> uarray__6Uarray [0 ])+ (__1i * __1delta ));
return __0this -> ulines__6Uarray ;

}

}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\varray.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/varray.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);









typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct Arc;

struct Varray;

struct Varray {	

REAL *varray__6Varray ;
REAL vval__6Varray [1000];
long voffset__6Varray [1000];
long numquads__6Varray ;

long size__6Varray ;
};





struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};









struct TrimVertex;



struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};




struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};


typedef struct TrimVertex *TrimVertex_p ;

struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;








extern struct __mptr* __ptbl_vec_____core_varray_c_____ct_[];


struct Varray *__gl__ct__6VarrayFv (struct Varray *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct Varray *)( (__1__Xp00uzigaiaa = malloc ( (sizeof (struct Varray))) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) )){

__0this -> varray__6Varray = 0 ;
__0this -> size__6Varray = 0 ;
} return __0this ;

}


void __gl__dt__6VarrayFv (struct Varray *__0this , 
int __0__free )
{ 
void *__1__X5 ;

if (__0this ){ 
if (__0this -> varray__6Varray )( (__1__X5 = (void *)__0this -> varray__6Varray ), ( (__1__X5 ?( free ( __1__X5 ) ,
0 ) :( 0 ) )) ) ;
if (__0this )if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) ))
;
} 
}






static REAL *tail__3ArcFv (struct Arc *);



void __glgrow__6VarrayFl (struct Varray *__0this , long __1guess )
{ 
if (__0this -> size__6Varray < __1guess ){ 
void *__1__X8 ;

void *__1__Xp00uzigaiaa ;

__0this -> size__6Varray = (__1guess * 2 );
if (__0this -> varray__6Varray )( (__1__X8 = (void *)__0this -> varray__6Varray ), ( (__1__X8 ?( free ( __1__X8 ) , 0 ) :(
0 ) )) ) ;
__0this -> varray__6Varray = (((float *)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (float ))* __0this -> size__6Varray )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void
*)__1__Xp00uzigaiaa )))) ));
((void )0 );
}
}




long __glinit__6VarrayFfP3ArcT2 (struct Varray *__0this , REAL __1delta , Arc_ptr __1toparc , Arc_ptr __1botarc )
{ 
Arc_ptr __1left ;
Arc_ptr __1right ;
long __1ldir [2];

long __1rdir [2];

float __1__X9 ;

float __1__X10 ;

float __1__X11 ;

float __1__X12 ;

float __1__X17 ;

__1left = __1toparc -> next__3Arc ;
__1right = __1toparc ;

(__1ldir [0 ])= ( (__1__X9 = ((( (((REAL *)(((struct Arc *)__1left )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])- (tail__3ArcFv ( (struct Arc *)__1left -> prev__3Arc )
[0 ]))), ( (((long )((__1__X9 < 0.0 )?-1:((__1__X9 > 0.0 )?1 :0 ))))) ) ;
(__1ldir [1 ])= ( (__1__X10 = ((( (((REAL *)(((struct Arc *)__1left )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])- (tail__3ArcFv ( (struct Arc *)__1left -> prev__3Arc )
[1 ]))), ( (((long )((__1__X10 < 0.0 )?-1:((__1__X10 > 0.0 )?1 :0 ))))) ) ;
(__1rdir [0 ])= ( (__1__X11 = ((( (((REAL *)(((struct Arc *)__1right )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])- (tail__3ArcFv ( (struct Arc *)__1right -> prev__3Arc )
[0 ]))), ( (((long )((__1__X11 < 0.0 )?-1:((__1__X11 > 0.0 )?1 :0 ))))) ) ;
(__1rdir [1 ])= ( (__1__X12 = ((( (((REAL *)(((struct Arc *)__1right )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])- (tail__3ArcFv ( (struct Arc *)__1right -> prev__3Arc )
[1 ]))), ( (((long )((__1__X12 < 0.0 )?-1:((__1__X12 > 0.0 )?1 :0 ))))) ) ;

(__0this -> vval__6Varray [0 ])= (( (((REAL *)(((struct Arc *)__1toparc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ]);
__0this -> numquads__6Varray = 0 ;

while (1 ){ 
float __1__X13 ;

switch (( (__1__X13 = ((( (((REAL *)(((struct Arc *)__1left )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])- (tail__3ArcFv ( (struct Arc *)__1right -> prev__3Arc )
[1 ]))), ( (((long )((__1__X13 < 0.0 )?-1:((__1__X13 > 0.0 )?1 :0 ))))) ) ){ 
struct Arc *__0__X14 ;

float __1__X15 ;

register long __1__Xds00a4bkaimc ;

register long __1__Xdt00a4bkaimc ;

float __1__X6 ;

float __1__X7 ;

float __1__X16 ;

case 1 :
__1left = __1left -> next__3Arc ;
( (__1__X15 = (( (__0__X14 = (struct Arc *)__1left -> prev__3Arc ), ( (((REAL *)(__0__X14 -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) ) [1 ])),
( (__1__Xds00a4bkaimc = ( (__1__X6 = ((( (((REAL *)(((struct Arc *)__1left )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])- (tail__3ArcFv ( (struct Arc *)__1left ->
prev__3Arc ) [0 ]))), ( (((long )((__1__X6 < 0.0 )?-1:((__1__X6 > 0.0 )?1 :0 ))))) ) ), ( (__1__Xdt00a4bkaimc = ( (__1__X7 = (((
(((REAL *)(((struct Arc *)__1left )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])- (tail__3ArcFv ( (struct Arc *)__1left -> prev__3Arc ) [1 ]))), ( (((long )((__1__X7 <
0.0 )?-1:((__1__X7 > 0.0 )?1 :0 ))))) ) ), ((((((long *)__1ldir )[0 ])!= __1__Xds00a4bkaimc )|| ((((long *)__1ldir )[1 ])!= __1__Xdt00a4bkaimc ))?( ( ((((long *)__1ldir )[0 ])= __1__Xds00a4bkaimc ),
( ((((long *)__1ldir )[1 ])= __1__Xdt00a4bkaimc ), ( ((__1__X15 != (__0this -> vval__6Varray [__0this -> numquads__6Varray ]))?( ((__0this -> vval__6Varray [(++ __0this -> numquads__6Varray )])= __1__X15 ),
0 ) :0 )) ) ) , 0 ) :( 0 ) )) ) ) ;
break ;
case -1:
__1right = __1right -> prev__3Arc ;
( (__1__X16 = (( (((REAL *)(((struct Arc *)__1right )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])), ( (__1__Xds00a4bkaimc = ( (__1__X6 = (((
(((REAL *)(((struct Arc *)__1right )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [0 ])- (tail__3ArcFv ( (struct Arc *)__1right -> prev__3Arc ) [0 ]))), ( (((long )((__1__X6 <
0.0 )?-1:((__1__X6 > 0.0 )?1 :0 ))))) ) ), ( (__1__Xdt00a4bkaimc = ( (__1__X7 = ((( (((REAL *)(((struct Arc *)__1right )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex )))
[1 ])- (tail__3ArcFv ( (struct Arc *)__1right -> prev__3Arc ) [1 ]))), ( (((long )((__1__X7 < 0.0 )?-1:((__1__X7 > 0.0 )?1 :0 ))))) ) ), ((((((long
*)__1rdir )[0 ])!= __1__Xds00a4bkaimc )|| ((((long *)__1rdir )[1 ])!= __1__Xdt00a4bkaimc ))?( ( ((((long *)__1rdir )[0 ])= __1__Xds00a4bkaimc ), ( ((((long *)__1rdir )[1 ])= __1__Xdt00a4bkaimc ), (
((__1__X16 != (__0this -> vval__6Varray [__0this -> numquads__6Varray ]))?( ((__0this -> vval__6Varray [(++ __0this -> numquads__6Varray )])= __1__X16 ), 0 ) :0 )) ) ) ,
0 ) :( 0 ) )) ) ) ;
break ;
case 0 :
if ((( (((REAL *)(((struct Arc *)__1left )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])== (( (((REAL *)(((struct Arc *)__1botarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]).
param__10TrimVertex ))) [1 ]))goto end ;
__1left = __1left -> next__3Arc ;
break ;
}
}

end :
( (__1__X17 = (( (((REAL *)(((struct Arc *)__1botarc )-> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ))) [1 ])), ( ((__1__X17 != (__0this -> vval__6Varray [__0this -> numquads__6Varray ]))?(
((__0this -> vval__6Varray [(++ __0this -> numquads__6Varray )])= __1__X17 ), 0 ) :0 )) ) ;

__glgrow__6VarrayFl ( __0this , ((((long )(((__0this -> vval__6Varray [0 ])- (__0this -> vval__6Varray [__0this -> numquads__6Varray ]))/ __1delta )))+ __0this -> numquads__6Varray )+ 2 ) ;

{ long __1index ;

__1index = 0 ;
{ { long __1i ;

__1i = 0 ;

for(;__1i < __0this -> numquads__6Varray ;__1i ++ ) { 
(__0this -> voffset__6Varray [__1i ])= __1index ;
(__0this -> varray__6Varray [(__1index ++ )])= (__0this -> vval__6Varray [__1i ]);
{ REAL __2dist ;

__2dist = ((__0this -> vval__6Varray [__1i ])- (__0this -> vval__6Varray [(__1i + 1 )]));
if (__2dist > __1delta ){ 
long __3steps ;
float __3deltav ;

__3steps = ((((long )(__2dist / __1delta )))+ 1 );
__3deltav = ((- __2dist )/ (((float )__3steps )));
{ { long __3j ;

__3j = 1 ;

for(;__3j < __3steps ;__3j ++ ) 
(__0this -> varray__6Varray [(__1index ++ )])= ((__0this -> vval__6Varray [__1i ])+ (__3j * __3deltav ));

}

}
}

}
}
(__0this -> voffset__6Varray [__1i ])= __1index ;
(__0this -> varray__6Varray [__1index ])= (__0this -> vval__6Varray [__1i ]);
return __1index ;

}

}

}
}

static REAL *tail__3ArcFv (struct Arc *__0this ){ return (__0this -> pwlArc__3Arc -> pts__6PwlArc [0 ]). param__10TrimVertex ;

}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\trimregi.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/trimregion.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);








struct Arc;

struct Backend;






typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;







struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};












struct PwlArc;



struct PwlArc {	

char __W3__9PooledObj ;

struct TrimVertex *pts__6PwlArc ;
int npts__6PwlArc ;
long type__6PwlArc ;
};


struct Bin;

struct Arc;

struct BezierArc;


typedef struct Arc *Arc_ptr ;
enum arc_side { arc_none = 0, arc_right = 1, arc_top = 2, arc_left = 3, arc_bottom = 4} ;


struct Arc;

struct Arc {	

char __W3__9PooledObj ;

Arc_ptr prev__3Arc ;
Arc_ptr next__3Arc ;
Arc_ptr link__3Arc ;
struct BezierArc *bezierArc__3Arc ;
struct PwlArc *pwlArc__3Arc ;
long type__3Arc ;
long nuid__3Arc ;
};

extern int __glbezier_tag__3Arc ;
extern int __glarc_tag__3Arc ;
extern int __gltail_tag__3Arc ;








struct Jarcloc;

struct Jarcloc {	

struct Arc *arc__7Jarcloc ;
struct TrimVertex *p__7Jarcloc ;
struct TrimVertex *plast__7Jarcloc ;
};


struct Trimline;

struct Trimline {	

struct TrimVertex **pts__8Trimline ;
long numverts__8Trimline ;
long i__8Trimline ;
long size__8Trimline ;
struct Jarcloc jarcl__8Trimline ;
struct TrimVertex t__8Trimline ;

struct TrimVertex b__8Trimline ;
struct TrimVertex *tinterp__8Trimline ;

struct TrimVertex *binterp__8Trimline ;
};




struct Gridline;

struct Gridline {	
long v__8Gridline ;
REAL vval__8Gridline ;
long vindex__8Gridline ;
long ustart__8Gridline ;
long uend__8Gridline ;
};




struct Uarray;

struct Uarray {	

long size__6Uarray ;
long ulines__6Uarray ;

REAL *uarray__6Uarray ;
};


struct Backend;

struct TrimRegion;

void __gl__dt__8TrimlineFv (struct Trimline *, int );

void __gl__dt__6UarrayFv (struct Uarray *, int );


struct TrimRegion {	

struct Trimline left__10TrimRegion ;
struct Trimline right__10TrimRegion ;
struct Gridline top__10TrimRegion ;
struct Gridline bot__10TrimRegion ;
struct Uarray uarray__10TrimRegion ;

REAL oneOverDu__10TrimRegion ;
};





struct GridVertex;

struct GridVertex {	
long gparam__10GridVertex [2];
};







struct GridTrimVertex;

struct GridTrimVertex {	

char __W3__9PooledObj ;

struct TrimVertex dummyt__14GridTrimVertex ;
struct GridVertex dummyg__14GridTrimVertex ;

struct TrimVertex *t__14GridTrimVertex ;
struct GridVertex *g__14GridTrimVertex ;
};






typedef struct GridTrimVertex *GridTrimVertex_p ;

struct BasicCurveEvaluator;

struct BasicSurfaceEvaluator;

struct Backend;

struct Backend {	

struct BasicCurveEvaluator *curveEvaluator__7Backend ;
struct BasicSurfaceEvaluator *surfaceEvaluator__7Backend ;

int wireframetris__7Backend ;
int wireframequads__7Backend ;
int npts__7Backend ;
REAL mesh__7Backend [3][4];
int meshindex__7Backend ;
};



extern struct __mptr* __ptbl_vec_____core_trimregion_c_____ct_[];

struct Trimline *__gl__ct__8TrimlineFv (struct Trimline *);

struct Uarray *__gl__ct__6UarrayFv (struct Uarray *);

static void *__nw__FUi (size_t );

struct TrimRegion *__gl__ct__10TrimRegionFv (struct TrimRegion *__0this )
{ if (__0this || (__0this = (struct TrimRegion *)__nw__FUi ( sizeof (struct TrimRegion)) ))( ( __gl__ct__8TrimlineFv ( (struct
Trimline *)(& __0this -> left__10TrimRegion )) , __gl__ct__8TrimlineFv ( (struct Trimline *)(& __0this -> right__10TrimRegion )) ) , __gl__ct__6UarrayFv ( (struct Uarray *)(&
__0this -> uarray__10TrimRegion )) ) ;
return __0this ;

}

void __glsetDu__10TrimRegionFf (struct TrimRegion *__0this , REAL __1du )
{ 
__0this -> oneOverDu__10TrimRegion = (1.0 / __1du );
}

void __glinit__8TrimlineFlP3ArcT1 (struct Trimline *, long , struct Arc *, long );
void __glgetNextPt__8TrimlineFv (struct Trimline *);
void __glgetPrevPt__8TrimlineFv (struct Trimline *);

void __glinit__10TrimRegionFlP3Arc (struct TrimRegion *__0this , long __1npts , Arc_ptr __1extrema )
{ 
__glinit__8TrimlineFlP3ArcT1 ( (struct Trimline *)(& __0this -> left__10TrimRegion ), __1npts , __1extrema , (long
)(__1extrema -> pwlArc__3Arc -> npts__6PwlArc - 1 )) ;
__glgetNextPt__8TrimlineFv ( (struct Trimline *)(& __0this -> left__10TrimRegion )) ;

__glinit__8TrimlineFlP3ArcT1 ( (struct Trimline *)(& __0this -> right__10TrimRegion ), __1npts , __1extrema , (long )0 ) ;
__glgetPrevPt__8TrimlineFv ( (struct Trimline *)(& __0this -> right__10TrimRegion )) ;
}

void __glgetNextPts__8TrimlineFP3Ar0 (struct Trimline *, struct Arc *);
void __glgetPrevPts__8TrimlineFP3Ar0 (struct Trimline *, struct Arc *);

void __glgetPts__10TrimRegionFP3Arc (struct TrimRegion *__0this , Arc_ptr __1extrema )
{ 
__glgetNextPts__8TrimlineFP3Ar0 ( (struct Trimline *)(& __0this -> left__10TrimRegion ), __1extrema ) ;
__glgetPrevPts__8TrimlineFP3Ar0 ( (struct Trimline *)(& __0this -> right__10TrimRegion ), __1extrema ) ;
}

void __glgetNextPts__8TrimlineFfR7B0 (struct Trimline *, REAL , struct Backend *);
void __glgetPrevPts__8TrimlineFfR7B0 (struct Trimline *, REAL , struct Backend *);

void __glgetPts__10TrimRegionFR7Bac0 (struct TrimRegion *__0this , struct Backend *__1backend )
{ 
__glgetNextPts__8TrimlineFfR7B0 ( (struct Trimline *)(& __0this -> left__10TrimRegion ), __0this -> bot__10TrimRegion . vval__8Gridline , __1backend )
;
__glgetPrevPts__8TrimlineFfR7B0 ( (struct Trimline *)(& __0this -> right__10TrimRegion ), __0this -> bot__10TrimRegion . vval__8Gridline , __1backend ) ;
}


void __glgetGridExtent__10TrimRegio1 (struct TrimRegion *, struct TrimVertex *, struct TrimVertex *);

void __glgetGridExtent__10TrimRegio0 (struct TrimRegion *__0this )
{ 
__glgetGridExtent__10TrimRegio1 ( __0this , ( (((struct Trimline *)(& __0this -> left__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this ->
left__10TrimRegion ))-> numverts__8Trimline ), (((struct Trimline *)(& __0this -> left__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> left__10TrimRegion ))-> i__8Trimline )])) , (
(((struct Trimline *)(& __0this -> right__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> right__10TrimRegion ))-> numverts__8Trimline ), (((struct Trimline *)(& __0this -> right__10TrimRegion ))->
pts__8Trimline [(-- ((struct Trimline *)(& __0this -> right__10TrimRegion ))-> i__8Trimline )])) ) ;
}

void __glgetGridExtent__10TrimRegio1 (struct TrimRegion *__0this , struct TrimVertex *__1l , struct TrimVertex *__1r )
{ 
__0this -> bot__10TrimRegion . ustart__8Gridline = (((long )(((__1l -> param__10TrimVertex [0 ])- (__0this ->
uarray__10TrimRegion . uarray__6Uarray [0 ]))* __0this -> oneOverDu__10TrimRegion )));
if ((__1l -> param__10TrimVertex [0 ])>= (__0this -> uarray__10TrimRegion . uarray__6Uarray [__0this -> bot__10TrimRegion . ustart__8Gridline ]))__0this -> bot__10TrimRegion . ustart__8Gridline ++ ;

((void )0 );
((void )0 );

__0this -> bot__10TrimRegion . uend__8Gridline = (((__1r -> param__10TrimVertex [0 ])- (__0this -> uarray__10TrimRegion . uarray__6Uarray [0 ]))* __0this -> oneOverDu__10TrimRegion );
if ((__0this -> uarray__10TrimRegion . uarray__6Uarray [__0this -> bot__10TrimRegion . uend__8Gridline ])>= (__1r -> param__10TrimVertex [0 ]))__0this -> bot__10TrimRegion . uend__8Gridline -- ;

((void )0 );
((void )0 );
}





int __glcanTile__10TrimRegionFv (struct TrimRegion *__0this )
{ 
struct TrimVertex *__1lf ;
struct TrimVertex *__1ll ;
struct TrimVertex *__1l ;

struct TrimVertex *__1rf ;
struct TrimVertex *__1rl ;
struct TrimVertex *__1r ;

__1lf = ( (((struct Trimline *)(& __0this -> left__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> left__10TrimRegion ))-> pts__8Trimline [((struct Trimline *)(&
__0this -> left__10TrimRegion ))-> i__8Trimline ])) ;
__1ll = ( (((struct Trimline *)(& __0this -> left__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> left__10TrimRegion ))-> numverts__8Trimline ), (((struct Trimline *)(&
__0this -> left__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> left__10TrimRegion ))-> i__8Trimline )])) ;
__1l = (((__1ll -> param__10TrimVertex [0 ])> (__1lf -> param__10TrimVertex [0 ]))?__1ll :__1lf );

__1rf = ( (((struct Trimline *)(& __0this -> right__10TrimRegion ))-> i__8Trimline = 0 ), (((struct Trimline *)(& __0this -> right__10TrimRegion ))-> pts__8Trimline [((struct Trimline *)(&
__0this -> right__10TrimRegion ))-> i__8Trimline ])) ;
__1rl = ( (((struct Trimline *)(& __0this -> right__10TrimRegion ))-> i__8Trimline = ((struct Trimline *)(& __0this -> right__10TrimRegion ))-> numverts__8Trimline ), (((struct Trimline *)(&
__0this -> right__10TrimRegion ))-> pts__8Trimline [(-- ((struct Trimline *)(& __0this -> right__10TrimRegion ))-> i__8Trimline )])) ;
__1r = (((__1rl -> param__10TrimVertex [0 ])< (__1rf -> param__10TrimVertex [0 ]))?__1rl :__1rf );
return (((__1l -> param__10TrimVertex [0 ])<= (__1r -> param__10TrimVertex [0 ]))?1 :0 );
}

static void *__nw__FUi (
size_t __1s )
{ 
void *__1__Xp00uzigaiaa ;

__1__Xp00uzigaiaa = malloc ( __1s ) ;
if (__1__Xp00uzigaiaa ){ 
return __1__Xp00uzigaiaa ;
}
else 
{ 
return __1__Xp00uzigaiaa ;
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libnurbs\trimvert.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

#include <stdlib.h>
#include <setjmp.h>

struct JumpBuffer {
    jmp_buf     buf;
};

#define mysetjmp(x) setjmp((x)->buf)
#define mylongjmp(x,y) longjmp((x)->buf, y)

/* <<AT&T USL C++ Language System <3.0.1> 02/03/92>> */
/* < ../core/trimvertpool.c++ > */

void *__vec_new (void *, int , int , void *);

void __vec_ct (void *, int , int , void *);

void __vec_dt (void *, int , int , void *);

void __vec_delete (void *, int , int , void *, int , int );
typedef int (*__vptp)(void);
struct __mptr {short d; short i; __vptp f; };






typedef unsigned int size_t ;





// extern void *malloc (size_t );
// extern void free (void *);












typedef float REAL ;
typedef void (*Pfvv )(void );
typedef void (*Pfvf )(float *);
typedef int (*cmpfunc )(void *, void *);
typedef REAL Knot ;

typedef REAL *Knot_ptr ;

struct TrimVertex;

struct TrimVertex {	
REAL param__10TrimVertex [2];
long nuid__10TrimVertex ;
};

typedef struct TrimVertex *TrimVertex_p ;





struct Buffer;

struct Buffer {	

struct Buffer *next__6Buffer ;
};
struct Pool;

enum __Q2_4Pool5Magic { is_allocated__Q2_4Pool5Magic = 62369, is_free__Q2_4Pool5Magic = 61858} ;

struct Pool {	

struct Buffer *freelist__4Pool ;
char *blocklist__4Pool [32];
int nextblock__4Pool ;
char *curblock__4Pool ;
int buffersize__4Pool ;
int nextsize__4Pool ;
int nextfree__4Pool ;
int initsize__4Pool ;

char *name__4Pool ;
int magic__4Pool ;
};

void __glgrow__4PoolFv (struct Pool *);


struct PooledObj;

struct PooledObj {	

char __W3__9PooledObj ;
};





struct TrimVertexPool;

struct TrimVertexPool {	

struct Pool pool__14TrimVertexPool ;
struct TrimVertex **vlist__14TrimVertexPool ;
int nextvlistslot__14TrimVertexPool ;
int vlistsize__14TrimVertexPool ;
};


struct Pool *__gl__ct__4PoolFiT1Pc (struct Pool *, int , int , char *);
extern struct __mptr* __ptbl_vec_____core_trimvertpool_c_____ct_[];

static void *__nw__FUi (size_t );

struct TrimVertexPool *__gl__ct__14TrimVertexPoolFv (struct TrimVertexPool *__0this )
{ 
void *__1__Xp00uzigaiaa ;

if (__0this || (__0this = (struct TrimVertexPool *)__nw__FUi ( sizeof (struct TrimVertexPool)) )){ __gl__ct__4PoolFiT1Pc ( (struct Pool *)(& __0this -> pool__14TrimVertexPool ), (int
)((sizeof (struct TrimVertex ))* 3 ), 32 , (char *)"Threevertspool") ;

__0this -> nextvlistslot__14TrimVertexPool = 0 ;
__0this -> vlistsize__14TrimVertexPool = 200 ;
__0this -> vlist__14TrimVertexPool = (struct TrimVertex **)(((struct TrimVertex **)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (struct TrimVertex *))* __0this -> vlistsize__14TrimVertexPool )) ), (__1__Xp00uzigaiaa ?(((void
*)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ));
} return __0this ;

}

void __gl__dt__4PoolFv (struct Pool *, int );


void __gl__dt__14TrimVertexPoolFv (struct TrimVertexPool *__0this , 
int __0__free )
{ 
void *__1__X6 ;

if (__0this ){ 
while (__0this -> nextvlistslot__14TrimVertexPool ){ 
void *__1__X5 ;

( (__1__X5 = (void *)(__0this -> vlist__14TrimVertexPool [(-- __0this -> nextvlistslot__14TrimVertexPool )])), ( (__1__X5 ?( free ( __1__X5 ) , 0 ) :(
0 ) )) ) ;
}

if (__0this -> vlist__14TrimVertexPool )( (__1__X6 = (void *)__0this -> vlist__14TrimVertexPool ), ( (__1__X6 ?( free ( __1__X6 ) , 0 ) :(
0 ) )) ) ;
if (__0this ){ __gl__dt__4PoolFv ( (struct Pool *)(& __0this -> pool__14TrimVertexPool ), 2) ;

if (__0__free & 1)( (((void *)__0this )?( free ( ((void *)__0this )) , 0 ) :( 0 ) )) ;
} } }

void __glclear__4PoolFv (struct Pool *);


void __glclear__14TrimVertexPoolFv (struct TrimVertexPool *__0this )
{ 
void *__1__X8 ;

void *__1__Xp00uzigaiaa ;

__glclear__4PoolFv ( (struct Pool *)(& __0this -> pool__14TrimVertexPool )) ;

while (__0this -> nextvlistslot__14TrimVertexPool ){ 
void *__1__X7 ;

( (__1__X7 = (void *)(__0this -> vlist__14TrimVertexPool [(-- __0this -> nextvlistslot__14TrimVertexPool )])), ( (__1__X7 ?( free ( __1__X7 ) , 0 ) :(
0 ) )) ) ;
(__0this -> vlist__14TrimVertexPool [__0this -> nextvlistslot__14TrimVertexPool ])= 0 ;
}

if (__0this -> vlist__14TrimVertexPool )( (__1__X8 = (void *)__0this -> vlist__14TrimVertexPool ), ( (__1__X8 ?( free ( __1__X8 ) , 0 ) :(
0 ) )) ) ;
__0this -> vlist__14TrimVertexPool = (struct TrimVertex **)(((struct TrimVertex **)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (struct TrimVertex *))* __0this -> vlistsize__14TrimVertexPool )) ), (__1__Xp00uzigaiaa ?(((void
*)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ));
}


// extern void *memcpy (void *, void *, size_t );


struct TrimVertex *__glget__14TrimVertexPoolFi (struct TrimVertexPool *__0this , int __1n )
{ 
struct TrimVertex *__1v ;
if (__1n == 3 ){ 
void *__1__Xbuffer00idhgaiaa ;

__1v = (((struct TrimVertex *)(((struct TrimVertex *)( (((void )0 )), ( (((struct Pool *)(& __0this -> pool__14TrimVertexPool ))-> freelist__4Pool ?( ( (__1__Xbuffer00idhgaiaa =
(((void *)((struct Pool *)(& __0this -> pool__14TrimVertexPool ))-> freelist__4Pool ))), (((struct Pool *)(& __0this -> pool__14TrimVertexPool ))-> freelist__4Pool = ((struct Pool *)(& __0this ->
pool__14TrimVertexPool ))-> freelist__4Pool -> next__6Buffer )) , 0 ) :( ( ((! ((struct Pool *)(& __0this -> pool__14TrimVertexPool ))-> nextfree__4Pool )?( __glgrow__4PoolFv (
((struct Pool *)(& __0this -> pool__14TrimVertexPool ))) , 0 ) :( 0 ) ), ( (((struct Pool *)(& __0this -> pool__14TrimVertexPool ))->
nextfree__4Pool -= ((struct Pool *)(& __0this -> pool__14TrimVertexPool ))-> buffersize__4Pool ), ( (__1__Xbuffer00idhgaiaa = (((void *)(((struct Pool *)(& __0this -> pool__14TrimVertexPool ))-> curblock__4Pool +
((struct Pool *)(& __0this -> pool__14TrimVertexPool ))-> nextfree__4Pool ))))) ) ) , 0 ) ), (((void *)__1__Xbuffer00idhgaiaa ))) ) ))));

}
else 
{ 
unsigned int __0__X10 ;

struct TrimVertex *__0__X11 ;

unsigned int __1__X12 ;

void *__1__Xp00uzigaiaa ;

if (__0this -> nextvlistslot__14TrimVertexPool == __0this -> vlistsize__14TrimVertexPool ){ 
__0this -> vlistsize__14TrimVertexPool *= 2 ;
{ TrimVertex_p *__3nvlist ;

void *__1__X9 ;

void *__1__Xp00uzigaiaa ;

__3nvlist = (((struct TrimVertex **)( (__1__Xp00uzigaiaa = malloc ( ((sizeof (struct TrimVertex *))* __0this -> vlistsize__14TrimVertexPool )) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa ))))
));
memcpy ( (void *)__3nvlist , (void *)__0this -> vlist__14TrimVertexPool , __0this -> nextvlistslot__14TrimVertexPool * (sizeof (TrimVertex_p ))) ;
if (__0this -> vlist__14TrimVertexPool )( (__1__X9 = (void *)__0this -> vlist__14TrimVertexPool ), ( (__1__X9 ?( free ( __1__X9 ) , 0 ) :(
0 ) )) ) ;
__0this -> vlist__14TrimVertexPool = __3nvlist ;

}
}
__1v = ((__0this -> vlist__14TrimVertexPool [(__0this -> nextvlistslot__14TrimVertexPool ++ )])= ( (__0__X11 = (struct TrimVertex *)( (__1__X12 = ((sizeof (struct TrimVertex ))* (__0__X10 =
__1n ))), ( (__1__Xp00uzigaiaa = malloc ( __1__X12 ) ), (__1__Xp00uzigaiaa ?(((void *)__1__Xp00uzigaiaa )):(((void *)__1__Xp00uzigaiaa )))) ) ), __0__X11 ) );
}
return __1v ;
}

static void *__nw__FUi (
size_t __1s )
{ 
void *__1__Xp00uzigaiaa ;

__1__Xp00uzigaiaa = malloc ( __1s ) ;
if (__1__Xp00uzigaiaa ){ 
return __1__Xp00uzigaiaa ;
}
else 
{ 
return __1__Xp00uzigaiaa ;
}
}


/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\dict-lis.h ===
#ifndef __dict_list_h_
#define __dict_list_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

/* Use #define's so that another heap implementation can use this one */

#define DictKey		DictListKey
#define Dict		DictList
#define DictNode	DictListNode

#define dictNewDict(frame,leq)		__gl_dictListNewDict(frame,leq)
#define dictDeleteDict(dict)		__gl_dictListDeleteDict(dict)

#define dictSearch(dict,key)		__gl_dictListSearch(dict,key)
#define dictInsert(dict,key)		__gl_dictListInsert(dict,key)
#define dictInsertBefore(dict,node,key)	__gl_dictListInsertBefore(dict,node,key)
#define dictDelete(dict,node)		__gl_dictListDelete(dict,node)

#define dictKey(n)			__gl_dictListKey(n)
#define dictSucc(n)			__gl_dictListSucc(n)
#define dictPred(n)			__gl_dictListPred(n)
#define dictMin(d)			__gl_dictListMin(d)
#define dictMax(d)			__gl_dictListMax(d)



typedef void *DictKey;
typedef struct Dict Dict;
typedef struct DictNode DictNode;

Dict		*dictNewDict(
			void *frame,
			int (*leq)(void *frame, DictKey key1, DictKey key2) );
			
void		dictDeleteDict( Dict *dict );

/* Search returns the node with the smallest key greater than or equal
 * to the given key.  If there is no such key, returns a node whose
 * key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
 */
DictNode	*dictSearch( Dict *dict, DictKey key );
DictNode	*dictInsertBefore( Dict *dict, DictNode *node, DictKey key );
void		dictDelete( Dict *dict, DictNode *node );

#define		__gl_dictListKey(n)	((n)->key)
#define		__gl_dictListSucc(n)	((n)->next)
#define		__gl_dictListPred(n)	((n)->prev)
#define		__gl_dictListMin(d)	((d)->head.next)
#define		__gl_dictListMax(d)	((d)->head.prev)
#define	       __gl_dictListInsert(d,k) (dictInsertBefore((d),&(d)->head,(k)))


/*** Private data structures ***/

struct DictNode {
  DictKey	key;
  DictNode	*next;
  DictNode	*prev;
};

struct Dict {
  DictNode	head;
  void		*frame;
  int		(*leq)(void *frame, DictKey key1, DictKey key2);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\dict.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <stddef.h>
#ifdef NT
#include "dict-lis.h"
#else
#include "dict-list.h"
#endif
#include "memalloc.h"


Dict *dictNewDict( void *frame,
		   int (*leq)(void *frame, DictKey key1, DictKey key2) )
{
  Dict *dict = (Dict *) memAlloc( sizeof( Dict ));
  DictNode *head = &dict->head;

  head->key = NULL;
  head->next = head;
  head->prev = head;

  dict->frame = frame;
  dict->leq = leq;

  return dict;
}


void dictDeleteDict( Dict *dict )
{
  DictNode *node;

  for( node = dict->head.next; node != &dict->head; node = node->next ) {
    memFree( node );
  }
  memFree( dict );
}


DictNode *dictInsertBefore( Dict *dict, DictNode *node, DictKey key )
{
  DictNode *newNode;

  do {
    node = node->prev;
  } while( node->key != NULL && ! (*dict->leq)(dict->frame, node->key, key));

  newNode = (DictNode *) memAlloc( sizeof( DictNode ));
  newNode->key = key;
  newNode->next = node->next;
  node->next->prev = newNode;
  newNode->prev = node;
  node->next = newNode;

  return newNode;
}

void dictDelete( Dict *dict, DictNode *node ) /*ARGSUSED*/
{
  node->next->prev = node->prev;
  node->prev->next = node->next;
  memFree( node );
}

DictNode *dictSearch( Dict *dict, DictKey key )
{
  DictNode *node = &dict->head;

  do {
    node = node->next;
  } while( node->key != NULL && ! (*dict->leq)(dict->frame, key, node->key));

  return node;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\dict.h ===
#ifndef __dict_list_h_
#define __dict_list_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

/* Use #define's so that another heap implementation can use this one */

#define DictKey		DictListKey
#define Dict		DictList
#define DictNode	DictListNode

#define dictNewDict(frame,leq)		__gl_dictListNewDict(frame,leq)
#define dictDeleteDict(dict)		__gl_dictListDeleteDict(dict)

#define dictSearch(dict,key)		__gl_dictListSearch(dict,key)
#define dictInsert(dict,key)		__gl_dictListInsert(dict,key)
#define dictInsertBefore(dict,node,key)	__gl_dictListInsertBefore(dict,node,key)
#define dictDelete(dict,node)		__gl_dictListDelete(dict,node)

#define dictKey(n)			__gl_dictListKey(n)
#define dictSucc(n)			__gl_dictListSucc(n)
#define dictPred(n)			__gl_dictListPred(n)
#define dictMin(d)			__gl_dictListMin(d)
#define dictMax(d)			__gl_dictListMax(d)



typedef void *DictKey;
typedef struct Dict Dict;
typedef struct DictNode DictNode;

Dict		*dictNewDict(
			void *frame,
			int (*leq)(void *frame, DictKey key1, DictKey key2) );
			
void		dictDeleteDict( Dict *dict );

/* Search returns the node with the smallest key greater than or equal
 * to the given key.  If there is no such key, returns a node whose
 * key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
 */
DictNode	*dictSearch( Dict *dict, DictKey key );
DictNode	*dictInsertBefore( Dict *dict, DictNode *node, DictKey key );
void		dictDelete( Dict *dict, DictNode *node );

#define		__gl_dictListKey(n)	((n)->key)
#define		__gl_dictListSucc(n)	((n)->next)
#define		__gl_dictListPred(n)	((n)->prev)
#define		__gl_dictListMin(d)	((d)->head.next)
#define		__gl_dictListMax(d)	((d)->head.prev)
#define	       __gl_dictListInsert(d,k) (dictInsertBefore((d),&(d)->head,(k)))


/*** Private data structures ***/

struct DictNode {
  DictKey	key;
  DictNode	*next;
  DictNode	*prev;
};

struct Dict {
  DictNode	head;
  void		*frame;
  int		(*leq)(void *frame, DictKey key1, DictKey key2);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\errorstr.c ===
#include <glos.h>

#ifdef NT
#include "glstring.h"
#endif

#ifndef NT

static const char *errors[] = {
    "missing gluTessBeginPolygon",
    "missing gluTessBeginContour",
    "missing gluTessEndPolygon",
    "missing gluTessEndContour",
    "tesselation coordinate too large",
    "need combine callback"
};

#else

static UINT auiTessErrors[] = {
    STR_TESS_BEGIN_POLY           ,   // "missing gluTessBeginPolygon",
    STR_TESS_BEGIN_CONTOUR        ,   // "missing gluTessBeginContour",
    STR_TESS_END_POLY             ,   // "missing gluTessEndPolygon",
    STR_TESS_END_CONTOUR          ,   // "missing gluTessEndContour",
    STR_TESS_COORD_TOO_LARGE      ,   // "tesselation coordinate too large",
    STR_TESS_NEED_COMBINE_CALLBACK    // "need combine callback"
};

#define NERRORS ( sizeof(auiTessErrors)/sizeof(auiTessErrors[0]) )

static char *errors[NERRORS];
static WCHAR *errorsW[NERRORS];

#endif

const char *__glTessErrorString(int errno)
{
    return (const char *) errors[errno];
}


#ifdef NT

const WCHAR *__glTessErrorStringW(int errno)
{
    return (const WCHAR *) errorsW[errno];
}

VOID vInitTessStrings(HINSTANCE hMod, BOOL bAnsi)
{
    int i;

    if (bAnsi)
    {
        for (i = 0; i < NERRORS; i++)
            errors[i] = pszGetResourceStringA(hMod, auiTessErrors[i]);
    }
    else
    {
        for (i = 0; i < NERRORS; i++)
            errorsW[i] = pwszGetResourceStringW(hMod, auiTessErrors[i]);
    }
}

#endif /* NT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\geom.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <assert.h>
#include "mesh.h"
#include "geom.h"

int __gl_vertLeq( GLUvertex *u, GLUvertex *v )
{
  /* Returns TRUE if u is lexicographically <= v. */

  return VertLeq( u, v );
}

GLdouble __gl_edgeEval( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
   * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
   * Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
   * If uw is vertical (and thus passes thru v), the result is zero.
   *
   * The calculation is extremely accurate and stable, even when v
   * is very close to u or w.  In particular if we set v->t = 0 and
   * let r be the negated result (this evaluates (uw)(v->s)), then
   * r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
   */
  GLdouble gapL, gapR;

  assert( VertLeq( u, v ) && VertLeq( v, w ));
  
  gapL = v->s - u->s;
  gapR = w->s - v->s;

  if( gapL + gapR > 0 ) {
    if( gapL < gapR ) {
      return (v->t - u->t) + (u->t - w->t) * (gapL / (gapL + gapR));
    } else {
      return (v->t - w->t) + (w->t - u->t) * (gapR / (gapL + gapR));
    }
  }
  /* vertical line */
  return 0;
}

GLdouble __gl_edgeSign( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* Returns a number whose sign matches EdgeEval(u,v,w) but which
   * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
   * as v is above, on, or below the edge uw.
   */
  GLdouble gapL, gapR;

  assert( VertLeq( u, v ) && VertLeq( v, w ));
  
  gapL = v->s - u->s;
  gapR = w->s - v->s;

  if( gapL + gapR > 0 ) {
    return (v->t - w->t) * gapL + (v->t - u->t) * gapR;
  }
  /* vertical line */
  return 0;
}


/***********************************************************************
 * Define versions of EdgeSign, EdgeEval with s and t transposed.
 */

GLdouble __gl_transEval( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),
   * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
   * Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.
   * If uw is vertical (and thus passes thru v), the result is zero.
   *
   * The calculation is extremely accurate and stable, even when v
   * is very close to u or w.  In particular if we set v->s = 0 and
   * let r be the negated result (this evaluates (uw)(v->t)), then
   * r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).
   */
  GLdouble gapL, gapR;

  assert( TransLeq( u, v ) && TransLeq( v, w ));
  
  gapL = v->t - u->t;
  gapR = w->t - v->t;

  if( gapL + gapR > 0 ) {
    if( gapL < gapR ) {
      return (v->s - u->s) + (u->s - w->s) * (gapL / (gapL + gapR));
    } else {
      return (v->s - w->s) + (w->s - u->s) * (gapR / (gapL + gapR));
    }
  }
  /* vertical line */
  return 0;
}

GLdouble __gl_transSign( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* Returns a number whose sign matches TransEval(u,v,w) but which
   * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
   * as v is above, on, or below the edge uw.
   */
  GLdouble gapL, gapR;

  assert( TransLeq( u, v ) && TransLeq( v, w ));
  
  gapL = v->t - u->t;
  gapR = w->t - v->t;

  if( gapL + gapR > 0 ) {
    return (v->s - w->s) * gapL + (v->s - u->s) * gapR;
  }
  /* vertical line */
  return 0;
}


int __gl_vertCCW( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* For almost-degenerate situations, the results are not reliable.
   * Unless the floating-point arithmetic can be performed without
   * rounding errors, *any* implementation will give incorrect results
   * on some degenerate inputs, so the client must have some way to
   * handle this situation.
   */
  return (u->s*(v->t - w->t) + v->s*(w->t - u->t) + w->s*(u->t - v->t)) >= 0;
}

/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
 * or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
 * this in the rare case that one argument is slightly negative.
 * The implementation is extremely stable numerically.
 * In particular it guarantees that the result r satisfies
 * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
 * even when a and b differ greatly in magnitude.
 */
#define RealInterpolate(a,x,b,y)			\
  (a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b,		\
  ((a <= b) ? ((b == 0) ? ((x+y) / 2)			\
                        : (x + (y-x) * (a/(a+b))))	\
            : (y + (x-y) * (b/(a+b)))))

#ifndef DEBUG
#define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
#else

/* Claim: the ONLY property the sweep algorithm relies on is that
 * MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
 */
#include <stdlib.h>
extern int RandomInterpolate;

GLdouble Interpolate( GLdouble a, GLdouble x, GLdouble b, GLdouble y)
{
#ifndef NT
printf("*********************%d\n",RandomInterpolate);
#endif
  if( RandomInterpolate ) {
    a = 1.2 * drand48() - 0.1;
    a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
    b = 1.0 - a;
  }
  return RealInterpolate(a,x,b,y);
}

#endif

#define Swap(a,b)	if (1) { GLUvertex *t = a; a = b; b = t; } else

void __gl_edgeIntersect( GLUvertex *o1, GLUvertex *d1,
			 GLUvertex *o2, GLUvertex *d2,
			 GLUvertex *v )
/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.
 * The computed point is guaranteed to lie in the intersection of the
 * bounding rectangles defined by each edge.
 */
{
  GLdouble z1, z2;

  /* This is certainly not the most efficient way to find the intersection
   * of two line segments, but it is very numerically stable.
   *
   * Strategy: find the two middle vertices in the VertLeq ordering,
   * and interpolate the intersection s-value from these.  Then repeat
   * using the TransLeq ordering to find the intersection t-value.
   */

  if( ! VertLeq( o1, d1 )) { Swap( o1, d1 ); }
  if( ! VertLeq( o2, d2 )) { Swap( o2, d2 ); }
  if( ! VertLeq( o1, o2 )) { Swap( o1, o2 ); Swap( d1, d2 ); }

  if( ! VertLeq( o2, d1 )) {
    /* Technically, no intersection -- do our best */
    v->s = (o2->s + d1->s) / 2;
  } else if( VertLeq( d1, d2 )) {
    /* Interpolate between o2 and d1 */
    z1 = EdgeEval( o1, o2, d1 );
    z2 = EdgeEval( o2, d1, d2 );
    if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
    v->s = Interpolate( z1, o2->s, z2, d1->s );
  } else {
    /* Interpolate between o2 and d2 */
    z1 = EdgeSign( o1, o2, d1 );
    z2 = -EdgeSign( o1, d2, d1 );
    if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
    v->s = Interpolate( z1, o2->s, z2, d2->s );
  }

  /* Now repeat the process for t */

  if( ! TransLeq( o1, d1 )) { Swap( o1, d1 ); }
  if( ! TransLeq( o2, d2 )) { Swap( o2, d2 ); }
  if( ! TransLeq( o1, o2 )) { Swap( o1, o2 ); Swap( d1, d2 ); }

  if( ! TransLeq( o2, d1 )) {
    /* Technically, no intersection -- do our best */
    v->t = (o2->t + d1->t) / 2;
  } else if( TransLeq( d1, d2 )) {
    /* Interpolate between o2 and d1 */
    z1 = TransEval( o1, o2, d1 );
    z2 = TransEval( o2, d1, d2 );
    if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
    v->t = Interpolate( z1, o2->t, z2, d1->t );
  } else {
    /* Interpolate between o2 and d2 */
    z1 = TransSign( o1, o2, d1 );
    z2 = -TransSign( o1, d2, d1 );
    if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
    v->t = Interpolate( z1, o2->t, z2, d2->t );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\geom.h ===
#ifndef __geom_h_
#define __geom_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "mesh.h"

#ifdef NO_BRANCH_CONDITIONS
/* MIPS architecture has special instructions to evaluate boolean
 * conditions -- more efficient than branching, IF you can get the
 * compiler to generate the right instructions (SGI compiler doesn't)
 */
#define VertEq(u,v)	(((u)->s == (v)->s) & ((u)->t == (v)->t))
#define VertLeq(u,v)	(((u)->s < (v)->s) | \
                         ((u)->s == (v)->s & (u)->t <= (v)->t))
#else
#define VertEq(u,v)	((u)->s == (v)->s && (u)->t == (v)->t)
#define VertLeq(u,v)	(((u)->s < (v)->s) || \
                         ((u)->s == (v)->s && (u)->t <= (v)->t))
#endif

#define EdgeEval(u,v,w)	__gl_edgeEval(u,v,w)
#define EdgeSign(u,v,w)	__gl_edgeSign(u,v,w)

/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */

#define TransLeq(u,v)	(((u)->t < (v)->t) || \
                         ((u)->t == (v)->t && (u)->s <= (v)->s))
#define TransEval(u,v,w)	__gl_transEval(u,v,w)
#define TransSign(u,v,w)	__gl_transSign(u,v,w)


#define EdgeGoesLeft(e)		VertLeq( (e)->Dst, (e)->Org )
#define EdgeGoesRight(e)	VertLeq( (e)->Org, (e)->Dst )

#define ABS(x)	((x) < 0 ? -(x) : (x))
#define VertL1dist(u,v)	(ABS(u->s - v->s) + ABS(u->t - v->t))

#define VertCCW(u,v,w)	__gl_vertCCW(u,v,w)

int		__gl_vertLeq( GLUvertex *u, GLUvertex *v );
GLdouble	__gl_edgeEval( GLUvertex *u, GLUvertex *v, GLUvertex *w );
GLdouble	__gl_edgeSign( GLUvertex *u, GLUvertex *v, GLUvertex *w );
GLdouble	__gl_transEval( GLUvertex *u, GLUvertex *v, GLUvertex *w );
GLdouble	__gl_transSign( GLUvertex *u, GLUvertex *v, GLUvertex *w );
int		__gl_vertCCW( GLUvertex *u, GLUvertex *v, GLUvertex *w );
void		__gl_edgeIntersect( GLUvertex *o1, GLUvertex *d1,
				    GLUvertex *o2, GLUvertex *d2,
				    GLUvertex *v );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\mem-mf.h ===
#ifndef __memalloc_simple_h_
#define __memalloc_simple_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
//#include "winmem.h"
#else
#include "malloc.h"
#endif

#include <windows.h>

// MF memory defines
#define memAlloc(size)        mfmemAlloc(size)
#if 0
//mf: calloc not appear to be used
#define calloc(nobj, size)  LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, (UINT)((nobj) * (size)))
#endif
#define memRealloc(p, size)   mfmemRealloc(p, size)
#define memFree(p)            mfmemFree(p) 
#define memInit(size)	      mfmemInit(size)	

// MF memory function externs
extern void mfmemInit( size_t maxFast );
extern void *mfmemAlloc( size_t size );
extern void *mfmemRealloc( void *p, size_t size );
extern void mfmemFree( void *p );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\mem-simp.h ===
#ifndef __memalloc_simple_h_
#define __memalloc_simple_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include "winmem.h"
#else
#include "malloc.h"
#endif

#define memRealloc	realloc
#define memFree		free

#define memInit		__gl_memInit
/*extern void		__gl_memInit( size_t );*/
extern int      __gl_memInit( size_t );

#ifndef MEMORY_DEBUG
#define memAlloc	malloc
#else
#define memAlloc	__gl_memAlloc
extern void *		__gl_memAlloc( size_t );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\mem-fast.h ===
#ifndef __memalloc_fast_h_
#define __memalloc_fast_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include "winmem.h"
#else
#include "malloc.h"
#endif

#define memAlloc	__gl_memAlloc
#define memRealloc	__gl_memRealloc
#define memFree		__gl_memFree
#define memInit		__gl_memInit

extern void *__gl_memAlloc( size_t );
extern void *__gl_memRealloc( void *, size_t );
extern void __gl_memFree( void * );
extern void __gl_memInit( size_t );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\mem-simp.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "memalloc.h"
#include "string.h"

int __gl_memInit( size_t maxFast )
{
#ifndef NO_MALLOPT
/*  mallopt( M_MXFAST, maxFast );*/
#ifdef MEMORY_DEBUG
  mallopt( M_DEBUG, 1 );
#endif
#endif
   return 1;
}

#ifdef MEMORY_DEBUG
void *__gl_memAlloc( size_t n )
{
  return memset( malloc( n ), 0xa5, n );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\mem-mf.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <stdio.h>
#include <glos.h>
#include <GL/gl.h>
#include "memalloc.h"
#include "string.h"

// mf!
//#define MF_DEBUG 1
#define MEM_DEBUG 1
#ifdef MEM_DEBUG
ULONG DbgPrint(PSZ Format, ...);
#include "\nt\private\windows\gdi\opengl\client\debug.h"
#endif

static GLuint  AllocCount = 0;
static GLuint  FreeCount = 0;
static BOOL    bFree = TRUE;
extern GLuint EdgeAlloc;
extern GLuint VertexAlloc;
extern GLuint FaceAlloc;
extern GLuint MeshAlloc;
extern GLuint RegionAlloc;
extern GLuint EdgeFree;
extern GLuint VertexFree;
extern GLuint FaceFree;
extern GLuint MeshFree;
extern GLuint RegionFree;

void mfmemInit( size_t maxFast )
{
#ifdef MF_DEBUG
    DBGPRINT1( "Init    %p\n", maxFast );
#endif
#ifndef NO_MALLOPT
  mallopt( M_MXFAST, maxFast );
#ifdef MEMORY_DEBUG
  mallopt( M_DEBUG, 1 );
#endif
#endif
//#ifdef MF_DEBUG
#if 1
    DBGPRINT2( "AllocCount = %d, FreeCount = %d\n", AllocCount, FreeCount );
    DBGPRINT2( "EdgeAlloc = %d, EdgeFree = %d\n", EdgeAlloc, EdgeFree );
    DBGPRINT2( "VertexAlloc = %d, VertexFree = %d\n", VertexAlloc, VertexFree );
    DBGPRINT2( "FaceAlloc = %d, FaceFree = %d\n", FaceAlloc, FaceFree );
    DBGPRINT2( "MeshAlloc = %d, MeshFree = %d\n", MeshAlloc, MeshFree );
    DBGPRINT2( "RegionAlloc = %d, RegionFree = %d\n", RegionAlloc, RegionFree );
#endif
    AllocCount = 0;
    FreeCount = 0;
    EdgeAlloc = EdgeFree = VertexAlloc = VertexFree = FaceAlloc = FaceFree = 0;
    MeshAlloc = MeshFree = 0;
    RegionAlloc = RegionFree = 0;
}

void *mfmemAlloc( size_t size )
{
    void *p;

    p = (void *) LocalAlloc(LMEM_FIXED, (UINT)(size));
#ifdef MF_DEBUG
    DBGPRINT2( "Alloc   %p, %d\n", p, size );
#endif
    AllocCount++;
    return p;
}

void *mfmemRealloc( void *p, size_t size )
{
    p = (void *) LocalReAlloc((HLOCAL)(p), (UINT)(size), LMEM_MOVEABLE);
#ifdef MF_DEBUG
    DBGPRINT2( "Realloc %p, %d\n", p, size );
#endif
    return p;
}

void mfmemFree( void *p )
{
#ifdef MF_DEBUG
    DBGPRINT1( "Free    %p\n", p );
#endif
    if( bFree )
        LocalFree((HLOCAL)(p));
    FreeCount++;
}

//mf: calloc not appear to be used
#if 0
#define calloc(nobj, size)  LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, (UINT)((nobj) * (size)))
#endif

/******************************Public*Routine******************************\
* DbgPrint()
*
*  go to the user mode debugger in checked builds
*
* Effects:
*
* Warnings:
*
* History:
*  09-Aug-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#if DBG

VOID DoRip(PSZ psz)
{
    DbgPrint("GDI Assertion Failure: ");
    DbgPrint(psz);
    DbgPrint("\n");
    DbgBreakPoint();
}


ULONG
DbgPrint(
    PCH DebugMessage,
    ...
    )
{
    va_list ap;
    char buffer[256];

    va_start(ap, DebugMessage);

    vsprintf(buffer, DebugMessage, ap);

    OutputDebugStringA(buffer);

    va_end(ap);

    return(0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\memalloc.h ===
#ifndef __memalloc_fast_h_
#define __memalloc_fast_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

//mf: ! this switch controls memalloc scheme !
#if 1
// slow alloc
#include "winmem.h"

#define memAlloc      	malloc
#define memRealloc      realloc
#define memFree         free
#define memInit(a)      1
#else
// fast alloc (used to be buggy, but fixed with v1.2)
// Still not thread-safe, though
#include "malloc.h"

#define memAlloc	__gl_memAlloc
#define memRealloc	__gl_memRealloc
#define memFree		__gl_memFree
#define memInit		__gl_memInit

extern void *__gl_memAlloc( size_t );
extern void *__gl_memRealloc( void *, size_t );
extern void __gl_memFree( void * );
extern int __gl_memInit( size_t );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\memalloc.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include <glos.h>
#endif
#include "memalloc.h"
#include <assert.h>

#ifdef NO_MALLOPT
#define memalign(a,n)	malloc(n)
#define mallopt(t,v)
#endif

#define Pool mPool

typedef struct Pool {
  char *prevAlloc;
  char *lastAlloc;
  int usedCount;
  int chunkSize;
} Pool;

typedef struct Chunk {
  Pool *pool;
} Chunk;

static Pool **Pools;
static size_t MaxFast;

#define POOL_SIZE	200
#define CHUNK_PAD	sizeof(Chunk)

#define ALIGN_SHIFT	3
#define ALIGN		(1 << ALIGN_SHIFT)

#define CHUNK_SIZE(n)	(((n) + CHUNK_PAD + ALIGN - 1) & (-ALIGN))
#define ALIGNED_CHUNK_PAD	((CHUNK_PAD + ALIGN - 1) & (-ALIGN))

static int NewPool( size_t n, int poolSize )
{
  Pool *p;
  char *base;

  /* We want the *returned* chunks to be aligned on ALIGN boundaries.
   * The Chunk structures will be located just before these boundaries.
   */
  p = (Pool *)malloc( CHUNK_SIZE(sizeof(Pool)) + poolSize * n );
  if (p == NULL) {
     return 0;
  }
  base = (char *)p + CHUNK_SIZE(sizeof(Pool)) - CHUNK_PAD;
  p->prevAlloc = base - n;
  p->lastAlloc = base + (poolSize-1) * n;
  p->usedCount = poolSize;
  p->chunkSize = n;
  Pools[n>>ALIGN_SHIFT] = p;

  return 1;
}

int __gl_memInit( size_t maxFast )
{
  int i, numPools;

  if( Pools == NULL ) {
#ifdef MEMORY_DEBUG
    mallopt( M_DEBUG, 1 );
#endif
    MaxFast = CHUNK_SIZE(maxFast) - CHUNK_PAD;
    numPools = ((MaxFast + CHUNK_PAD) >> ALIGN_SHIFT) + 1;
    Pools = (struct Pool **)malloc( numPools * sizeof(Pools[0]) );
    if (Pools == NULL)
       return 0;

    /* Create a tiny pool for every size, to avoid a check for NULL
     * in memAlloc().
     */
    for( i = 1; i < numPools; ++i ) {
      if (NewPool( i << ALIGN_SHIFT, 1 ) == 0) {
         return 0;
      }
    }
  }
  return 1;
}

void *__gl_memAlloc( size_t n )
{
  Pool *p;
  Chunk *c;

  if( n <= MaxFast ) {
    n = CHUNK_SIZE( n );
    p = Pools[n >> ALIGN_SHIFT];
    assert ( p->chunkSize == n );
    c = (Chunk *)(p->prevAlloc + n);
    p->prevAlloc = (char *) c;
    c->pool = p;
    if( c >= (Chunk *) p->lastAlloc ) {
      if (NewPool( n, POOL_SIZE ) == 0) {
         return 0;
      }
    }
    assert( ((size_t)(c + 1) & (ALIGN - 1)) == 0 );
  } else {
    char* v;
/*    v = (char*) malloc( n + ALIGNED_CHUNK_PAD ) + ALIGNED_CHUNK_PAD;*/
    v = (char*) malloc( n + ALIGNED_CHUNK_PAD );
    if (v == NULL) {
       return 0;
    }
    v = v + ALIGNED_CHUNK_PAD;

    c = ((Chunk*) v) - 1;
    c->pool = NULL;
    assert( ((size_t)(c + 1) & (ALIGN - 1)) == 0 );
  }
  return (c + 1);
}

extern void *__gl_memRealloc( void *v1, size_t n )
{
  Chunk *c = ((Chunk *) v1) - 1;
  Pool *p = c->pool;
  void *v2;
#ifdef NT
  size_t len;
#else
  int len;
#endif

  if( p == NULL ) {
    char* v;
/*    v = (char*) realloc( (char*)v1 - ALIGNED_CHUNK_PAD, n + ALIGNED_CHUNK_PAD )
      + ALIGNED_CHUNK_PAD; */
    v = (char*) realloc( (char*)v1 - ALIGNED_CHUNK_PAD, n + ALIGNED_CHUNK_PAD);
    if (v == NULL) {
       return 0;
    }
    v = v + ALIGNED_CHUNK_PAD;
    c = ((Chunk*) v) - 1;
    assert( ((size_t)(c + 1) & (ALIGN - 1)) == 0 );
    return (c+1);
  }
  len = p->chunkSize - CHUNK_PAD;
  if( n <= len ) { return v1; }

  v2 = memAlloc( n );
  if (v2 == NULL) {
     return 0;
  }
  (void) memcpy( v2, v1, len );
  memFree( v1 );
  return v2;
}

extern void __gl_memFree( void *v )
{
  Chunk *c = ((Chunk *) v) - 1;
  Pool *p = c->pool;

  if( p == NULL ) {
    free( ((char*) v) - ALIGNED_CHUNK_PAD );
  } else {
    if( --p->usedCount <= 0 ) {
      free( p );
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\norm-sim.h ===
#ifndef __normal_h_
#define __normal_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "tess.h"

/* __gl_projectPolygon( tess ) determines the polygon normal
 * and project vertices onto the plane of the polygon.
 */
void __gl_projectPolygon( GLUtesselator *tess );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\mesh.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/


#include <assert.h>
#include "mesh.h"
#include "memalloc.h"

#define TRUE 1
#define FALSE 0

/************************ Utility Routines ************************/

/* Allocate and free half-edges in pairs for efficiency.
 * The *only* place that should use this fact is allocation/free.
 */
typedef struct { GLUhalfEdge e, eSym; } EdgePair;

/* MakeEdge creates a new pair of half-edges which form their own loop.
 * No vertex or face structures are allocated, but these must be assigned
 * before the current edge operation is completed.
 */
static GLUhalfEdge *MakeEdge( GLUhalfEdge *eNext )
{
  EdgePair *pair = (EdgePair *)memAlloc( sizeof( EdgePair ));
  GLUhalfEdge *e = &pair->e;
  GLUhalfEdge *eSym = &pair->eSym;
  GLUhalfEdge *ePrev;

  /* Make sure eNext points to the first edge of the edge pair */
  if( eNext->Sym < eNext ) { eNext = eNext->Sym; }

  /* Insert in circular doubly-linked list before eNext.
   * Note that the prev pointer is stored in Sym->next.
   */
  ePrev = eNext->Sym->next;
  eSym->next = ePrev;
  ePrev->Sym->next = e;
  e->next = eNext;
  eNext->Sym->next = eSym;

  e->Sym = eSym;
  e->Onext = e;
  e->Lnext = eSym;
  e->Org = NULL;
  e->Lface = NULL;
  e->winding = 0;
  e->activeRegion = NULL;

  eSym->Sym = e;
  eSym->Onext = eSym;
  eSym->Lnext = e;
  eSym->Org = NULL;
  eSym->Lface = NULL;
  eSym->winding = 0;
  eSym->activeRegion = NULL;

  return e;
}

/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
 * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
 * a->Onext and b->Onext are exchanged.  This can have various effects
 * depending on whether a and b belong to different face or vertex rings.
 * For more explanation see __gl_meshSplice() below.
 */
static void Splice( GLUhalfEdge *a, GLUhalfEdge *b )
{
  GLUhalfEdge *aOnext = a->Onext;
  GLUhalfEdge *bOnext = b->Onext;

  aOnext->Sym->Lnext = b;
  bOnext->Sym->Lnext = a;
  a->Onext = bOnext;
  b->Onext = aOnext;
}

/* MakeVertex( eOrig, vNext ) creates a new vertex and makes it the origin
 * of all edges in the vertex loop to which eOrig belongs.  "vNext" gives
 * a place to insert the new vertex in the global vertex list.  We insert
 * the new vertex *before* vNext so that algorithms which walk the vertex
 * list will not see the newly created vertices.
 */
static void MakeVertex( GLUhalfEdge *eOrig, GLUvertex *vNext )
{
  GLUvertex *vNew = (GLUvertex *)memAlloc( sizeof( GLUvertex ));
  GLUhalfEdge *e;
  GLUvertex *vPrev;

  /* insert in circular doubly-linked list before vNext */
  vPrev = vNext->prev;
  vNew->prev = vPrev;
  vPrev->next = vNew;
  vNew->next = vNext;
  vNext->prev = vNew;

  vNew->anEdge = eOrig;
  vNew->data = NULL;
  /* leave coords, s, t undefined */

  /* fix other edges on this vertex loop */
  e = eOrig;
  do {
    e->Org = vNew;
    e = e->Onext;
  } while( e != eOrig );
}

/* MakeFace( eOrig, fNext ) creates a new face and makes it the left face
 * of all edges in the face loop to which eOrig belongs.  "fNext" gives
 * a place to insert the new face in the global face list.  We insert
 * the new face *before* fNext so that algorithms which walk the face
 * list will not see the newly created faces.
 */
static void MakeFace( GLUhalfEdge *eOrig, GLUface *fNext )
{
  GLUface *fNew = (GLUface *)memAlloc( sizeof( GLUface ));
  GLUhalfEdge *e;
  GLUface *fPrev;

  /* insert in circular doubly-linked list before fNext */
  fPrev = fNext->prev;
  fNew->prev = fPrev;
  fPrev->next = fNew;
  fNew->next = fNext;
  fNext->prev = fNew;

  fNew->anEdge = eOrig;
  fNew->data = NULL;
  fNew->trail = NULL;
  fNew->marked = FALSE;

  /* The new face is marked "inside" if the old one was.  This is a
   * convenience for the common case where a face has been split in two.
   */
  fNew->inside = fNext->inside;

  /* fix other edges on this face loop */
  e = eOrig;
  do {
    e->Lface = fNew;
    e = e->Lnext;
  } while( e != eOrig );
}

/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
 * and removes from the global edge list.
 */
static void KillEdge( GLUhalfEdge *eDel )
{
  GLUhalfEdge *ePrev, *eNext;

  /* Half-edges are allocated in pairs, see EdgePair above */
  if( eDel->Sym < eDel ) { eDel = eDel->Sym; }

  /* delete from circular doubly-linked list */
  eNext = eDel->next;
  ePrev = eDel->Sym->next;
  eNext->Sym->next = ePrev;
  ePrev->Sym->next = eNext;

  memFree( eDel );
}


/* KillVertex( vDel ) destroys a vertex and removes it from the global
 * vertex list.  It updates the vertex loop to point to a given new vertex.
 */
static void KillVertex( GLUvertex *vDel, GLUvertex *newOrg )
{
  GLUhalfEdge *e, *eStart = vDel->anEdge;
  GLUvertex *vPrev, *vNext;

  /* change the origin of all affected edges */
  e = eStart;
  do {
    e->Org = newOrg;
    e = e->Onext;
  } while( e != eStart );

  /* delete from circular doubly-linked list */
  vPrev = vDel->prev;
  vNext = vDel->next;
  vNext->prev = vPrev;
  vPrev->next = vNext;

  memFree( vDel );
}

/* KillFace( fDel ) destroys a face and removes it from the global face
 * list.  It updates the face loop to point to a given new face.
 */
static void KillFace( GLUface *fDel, GLUface *newLface )
{
  GLUhalfEdge *e, *eStart = fDel->anEdge;
  GLUface *fPrev, *fNext;

  /* change the left face of all affected edges */
  e = eStart;
  do {
    e->Lface = newLface;
    e = e->Lnext;
  } while( e != eStart );

  /* delete from circular doubly-linked list */
  fPrev = fDel->prev;
  fNext = fDel->next;
  fNext->prev = fPrev;
  fPrev->next = fNext;

  memFree( fDel );
}


/****************** Basic Edge Operations **********************/

/* __gl_meshMakeEdge creates one edge, two vertices, and a loop (face).
 * The loop consists of the two new half-edges.
 */
GLUhalfEdge *__gl_meshMakeEdge( GLUmesh *mesh )
{
  GLUhalfEdge *e = MakeEdge( &mesh->eHead );

  MakeVertex( e, &mesh->vHead );
  MakeVertex( e->Sym, &mesh->vHead );
  MakeFace( e, &mesh->fHead );
  return e;
}
  

/* __gl_meshSplice( eOrg, eDst ) is the basic operation for changing the
 * mesh connectivity and topology.  It changes the mesh so that
 *	eOrg->Onext <- OLD( eDst->Onext )
 *	eDst->Onext <- OLD( eOrg->Onext )
 * where OLD(...) means the value before the meshSplice operation.
 *
 * This can have two effects on the vertex structure:
 *  - if eOrg->Org != eDst->Org, the two vertices are merged together
 *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
 * In both cases, eDst->Org is changed and eOrg->Org is untouched.
 *
 * Similarly (and independently) for the face structure,
 *  - if eOrg->Lface == eDst->Lface, one loop is split into two
 *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
 * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
 *
 * Some special cases:
 * If eDst == eOrg, the operation has no effect.
 * If eDst == eOrg->Lnext, the new face will have a single edge.
 * If eDst == eOrg->Lprev, the old face will have a single edge.
 * If eDst == eOrg->Onext, the new vertex will have a single edge.
 * If eDst == eOrg->Oprev, the old vertex will have a single edge.
 */
void __gl_meshSplice( GLUhalfEdge *eOrg, GLUhalfEdge *eDst )
{
  int joiningLoops = FALSE;
  int joiningVertices = FALSE;

  if( eOrg == eDst ) return;

  if( eDst->Org != eOrg->Org ) {
    /* We are merging two disjoint vertices -- destroy eDst->Org */
    joiningVertices = TRUE;
    KillVertex( eDst->Org, eOrg->Org );
  }
  if( eDst->Lface != eOrg->Lface ) {
    /* We are connecting two disjoint loops -- destroy eDst->Lface */
    joiningLoops = TRUE;
    KillFace( eDst->Lface, eOrg->Lface );
  }

  /* Change the edge structure */
  Splice( eDst, eOrg );

  if( ! joiningVertices ) {
    /* We split one vertex into two -- the new vertex is eDst->Org.
     * Make sure the old vertex points to a valid half-edge.
     */
    MakeVertex( eDst, eOrg->Org );
    eOrg->Org->anEdge = eOrg;
  }
  if( ! joiningLoops ) {
    /* We split one loop into two -- the new loop is eDst->Lface.
     * Make sure the old face points to a valid half-edge.
     */
    MakeFace( eDst, eOrg->Lface );
    eOrg->Lface->anEdge = eOrg;
  }
}


/* __gl_meshDelete( eDel ) removes the edge eDel.  There are several cases:
 * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
 * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
 * the newly created loop will contain eDel->Dst.  If the deletion of eDel
 * would create isolated vertices, those are deleted as well.
 *
 * This function could be implemented as two calls to __gl_meshSplice
 * plus a few calls to memFree, but this would allocate and delete
 * unnecessary vertices and faces.
 */
void __gl_meshDelete( GLUhalfEdge *eDel )
{
  GLUhalfEdge *eDelSym = eDel->Sym;
  int joiningLoops = FALSE;

  /* First step: disconnect the origin vertex eDel->Org.  We make all
   * changes to get a consistent mesh in this "intermediate" state.
   */
  if( eDel->Lface != eDel->Rface ) {
    /* We are joining two loops into one -- remove the left face */
    joiningLoops = TRUE;
    KillFace( eDel->Lface, eDel->Rface );
  }

  if( eDel->Onext == eDel ) {
    KillVertex( eDel->Org, NULL );
  } else {
    /* Make sure that eDel->Org and eDel->Rface point to valid half-edges */
    eDel->Rface->anEdge = eDel->Oprev;
    eDel->Org->anEdge = eDel->Onext;

    Splice( eDel, eDel->Oprev );
    if( ! joiningLoops ) {
      /* We are splitting one loop into two -- create a new loop for eDel. */
      MakeFace( eDel, eDel->Lface );
    }
  }

  /* Claim: the mesh is now in a consistent state, except that eDel->Org
   * may have been deleted.  Now we disconnect eDel->Dst.
   */
  if( eDelSym->Onext == eDelSym ) {
    KillVertex( eDelSym->Org, NULL );
    KillFace( eDelSym->Lface, NULL );
  } else {
    /* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */
    eDel->Lface->anEdge = eDelSym->Oprev;
    eDelSym->Org->anEdge = eDelSym->Onext;
    Splice( eDelSym, eDelSym->Oprev );
  }

  /* Any isolated vertices or faces have already been freed. */
  KillEdge( eDel );
}


/******************** Other Edge Operations **********************/

/* All these routines can be implemented with the basic edge
 * operations above.  They are provided for convenience and efficiency.
 */


/* __gl_meshAddEdgeVertex( eOrg ) creates a new edge eNew such that
 * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
 * eOrg and eNew will have the same left face.
 */
GLUhalfEdge *__gl_meshAddEdgeVertex( GLUhalfEdge *eOrg )
{
  GLUhalfEdge *eNew = MakeEdge( eOrg );
  GLUhalfEdge *eNewSym = eNew->Sym;

  /* Connect the new edge appropriately */
  Splice( eNew, eOrg->Lnext );

  /* Set the vertex and face information */
  eNew->Org = eOrg->Dst;
  MakeVertex( eNewSym, eNew->Org );
  eNew->Lface = eNewSym->Lface = eOrg->Lface;

  return eNew;
}


/* __gl_meshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
 * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
 * eOrg and eNew will have the same left face.
 */
GLUhalfEdge *__gl_meshSplitEdge( GLUhalfEdge *eOrg )
{
  GLUhalfEdge *eNew = __gl_meshAddEdgeVertex( eOrg )->Sym;

  /* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */
  Splice( eOrg->Sym, eOrg->Sym->Oprev );
  Splice( eOrg->Sym, eNew );

  /* Set the vertex and face information */
  eOrg->Dst = eNew->Org;
  eNew->Dst->anEdge = eNew->Sym;	/* may have pointed to eOrg->Sym */
  eNew->Rface = eOrg->Rface;
  eNew->winding = eOrg->winding;	/* copy old winding information */
  eNew->Sym->winding = eOrg->Sym->winding;

  return eNew;
}


/* __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
 * to eDst->Org, and returns the corresponding half-edge eNew.
 * If eOrg->Lface == eDst->Lface, this splits one loop into two,
 * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
 * loops are merged into one, and the loop eDst->Lface is destroyed.
 *
 * If (eOrg == eDst), the new face will have only two edges.
 * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
 * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
 */
GLUhalfEdge *__gl_meshConnect( GLUhalfEdge *eOrg, GLUhalfEdge *eDst )
{
  GLUhalfEdge *eNew = MakeEdge( eOrg );
  GLUhalfEdge *eNewSym = eNew->Sym;
  int joiningLoops = FALSE;

  if( eDst->Lface != eOrg->Lface ) {
    /* We are connecting two disjoint loops -- destroy eDst->Lface */
    joiningLoops = TRUE;
    KillFace( eDst->Lface, eOrg->Lface );
  }

  /* Connect the new edge appropriately */
  Splice( eNew, eOrg->Lnext );
  Splice( eNewSym, eDst );

  /* Set the vertex and face information */
  eNew->Org = eOrg->Dst;
  eNewSym->Org = eDst->Org;
  eNew->Lface = eNewSym->Lface = eOrg->Lface;

  /* Make sure the old face points to a valid half-edge */
  eOrg->Lface->anEdge = eNewSym;

  if( ! joiningLoops ) {
    /* We split one loop into two -- the new loop is eNew->Lface */
    MakeFace( eNew, eOrg->Lface );
  }
  return eNew;
}


/******************** Other Operations **********************/

/* __gl_meshZapFace( fZap ) destroys a face and removes it from the
 * global face list.  All edges of fZap will have a NULL pointer as their
 * left face.  Any edges which also have a NULL pointer as their right face
 * are deleted entirely (along with any isolated vertices this produces).
 * An entire mesh can be deleted by zapping its faces, one at a time,
 * in any order.  Zapped faces cannot be used in further mesh operations!
 */
void __gl_meshZapFace( GLUface *fZap )
{
  GLUhalfEdge *eStart = fZap->anEdge;
  GLUhalfEdge *e, *eNext, *eSym;
  GLUface *fPrev, *fNext;

  /* walk around face, deleting edges whose right face is also NULL */
  eNext = eStart->Lnext;
  do {
    e = eNext;
    eNext = e->Lnext;

    e->Lface = NULL;
    if( e->Rface == NULL ) {
      /* delete the edge -- see __gl_MeshDelete above */

      if( e->Onext == e ) {
	KillVertex( e->Org, NULL );
      } else {
	/* Make sure that e->Org points to a valid half-edge */
	e->Org->anEdge = e->Onext;
	Splice( e, e->Oprev );
      }
      eSym = e->Sym;
      if( eSym->Onext == eSym ) {
	KillVertex( eSym->Org, NULL );
      } else {
	/* Make sure that eSym->Org points to a valid half-edge */
	eSym->Org->anEdge = eSym->Onext;
	Splice( eSym, eSym->Oprev );
      }
      KillEdge( e );
    }
  } while( e != eStart );

  /* delete from circular doubly-linked list */
  fPrev = fZap->prev;
  fNext = fZap->next;
  fNext->prev = fPrev;
  fPrev->next = fNext;

  memFree( fZap );
}


/* __gl_meshNewMesh() creates a new mesh with no edges, no vertices,
 * and no loops (what we usually call a "face").
 */
GLUmesh *__gl_meshNewMesh( void )
{
  GLUmesh *mesh = (GLUmesh *)memAlloc( sizeof( GLUmesh ));
  GLUvertex *v = &mesh->vHead;
  GLUface *f = &mesh->fHead;
  GLUhalfEdge *e = &mesh->eHead;
  GLUhalfEdge *eSym = &mesh->eHeadSym;

  v->next = v->prev = v;
  v->anEdge = NULL;
  v->data = NULL;

  f->next = f->prev = f;
  f->anEdge = NULL;
  f->data = NULL;
  f->trail = NULL;
  f->marked = FALSE;
  f->inside = FALSE;

  e->next = e;
  e->Sym = eSym;
  e->Onext = NULL;
  e->Lnext = NULL;
  e->Org = NULL;
  e->Lface = NULL;
  e->winding = 0;
  e->activeRegion = NULL;

  eSym->next = eSym;
  eSym->Sym = e;
  eSym->Onext = NULL;
  eSym->Lnext = NULL;
  eSym->Org = NULL;
  eSym->Lface = NULL;
  eSym->winding = 0;
  eSym->activeRegion = NULL;

  return mesh;
}


/* __gl_meshUnion( mesh1, mesh2 ) forms the union of all structures in
 * both meshes, and returns the new mesh (the old meshes are destroyed).
 */
GLUmesh *__gl_meshUnion( GLUmesh *mesh1, GLUmesh *mesh2 )
{
  GLUface *f1 = &mesh1->fHead;
  GLUvertex *v1 = &mesh1->vHead;
  GLUhalfEdge *e1 = &mesh1->eHead;
  GLUface *f2 = &mesh2->fHead;
  GLUvertex *v2 = &mesh2->vHead;
  GLUhalfEdge *e2 = &mesh2->eHead;

  /* Add the faces, vertices, and edges of mesh2 to those of mesh1 */
  if( f2->next != f2 ) {
    f1->prev->next = f2->next;
    f2->next->prev = f1->prev;
    f2->prev->next = f1;
    f1->prev = f2->prev;
  }

  if( v2->next != v2 ) {
    v1->prev->next = v2->next;
    v2->next->prev = v1->prev;
    v2->prev->next = v1;
    v1->prev = v2->prev;
  }

  if( e2->next != e2 ) {
    e1->Sym->next->Sym->next = e2->next;
    e2->next->Sym->next = e1->Sym->next;
    e2->Sym->next->Sym->next = e1;
    e1->Sym->next = e2->Sym->next;
  }

  memFree( mesh2 );
  return mesh1;
}


#ifdef DELETE_BY_ZAPPING

/* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.
 */
void __gl_meshDeleteMesh( GLUmesh *mesh )
{
  GLUface *fHead = &mesh->fHead;

  while( fHead->next != fHead ) {
    __gl_meshZapFace( fHead->next );
  }
  assert( mesh->vHead.next == &mesh->vHead );

  memFree( mesh );
}

#else

/* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.
 */
void __gl_meshDeleteMesh( GLUmesh *mesh )
{
  GLUface *f, *fNext;
  GLUvertex *v, *vNext;
  GLUhalfEdge *e, *eNext;

  for( f = mesh->fHead.next; f != &mesh->fHead; f = fNext ) {
    fNext = f->next;
    memFree( f );
  }

  for( v = mesh->vHead.next; v != &mesh->vHead; v = vNext ) {
    vNext = v->next;
    memFree( v );
  }

  for( e = mesh->eHead.next; e != &mesh->eHead; e = eNext ) {
    /* One call frees both e and e->Sym (see EdgePair above) */
    eNext = e->next;
    memFree( e );
  }

  memFree( mesh );
}

#endif

#ifndef NDEBUG

/* __gl_meshCheckMesh( mesh ) checks a mesh for self-consistency.
 */
void __gl_meshCheckMesh( GLUmesh *mesh )
{
  GLUface *fHead = &mesh->fHead;
  GLUvertex *vHead = &mesh->vHead;
  GLUhalfEdge *eHead = &mesh->eHead;
  GLUface *f, *fPrev;
  GLUvertex *v, *vPrev;
  GLUhalfEdge *e, *ePrev;

  fPrev = fHead;
  for( fPrev = fHead ; (f = fPrev->next) != fHead; fPrev = f) {
    assert( f->prev == fPrev );
    e = f->anEdge;
    do {
      assert( e->Sym != e );
      assert( e->Sym->Sym == e );
      assert( e->Lnext->Onext->Sym == e );
      assert( e->Onext->Sym->Lnext == e );
      assert( e->Lface == f );
      e = e->Lnext;
    } while( e != f->anEdge );
  }
  assert( f->prev == fPrev && f->anEdge == NULL && f->data == NULL );

  vPrev = vHead;
  for( vPrev = vHead ; (v = vPrev->next) != vHead; vPrev = v) {
    assert( v->prev == vPrev );
    e = v->anEdge;
    do {
      assert( e->Sym != e );
      assert( e->Sym->Sym == e );
      assert( e->Lnext->Onext->Sym == e );
      assert( e->Onext->Sym->Lnext == e );
      assert( e->Org == v );
      e = e->Onext;
    } while( e != v->anEdge );
  }
  assert( v->prev == vPrev && v->anEdge == NULL && v->data == NULL );

  ePrev = eHead;
  for( ePrev = eHead ; (e = ePrev->next) != eHead; ePrev = e) {
    assert( e->Sym->next == ePrev->Sym );
    assert( e->Sym != e );
    assert( e->Sym->Sym == e );
    assert( e->Org != NULL );
    assert( e->Dst != NULL );
    assert( e->Lnext->Onext->Sym == e );
    assert( e->Onext->Sym->Lnext == e );
  }
  assert( e->Sym->next == ePrev->Sym
       && e->Sym == &mesh->eHeadSym
       && e->Sym->Sym == e
       && e->Org == NULL && e->Dst == NULL
       && e->Lface == NULL && e->Rface == NULL );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\mesh.h ===
#ifndef __mesh_h_
#define __mesh_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include <glos.h>
#endif
#include <GL/glu.h>

typedef struct GLUmesh GLUmesh;

typedef struct GLUvertex GLUvertex;
typedef struct GLUface GLUface;
typedef struct GLUhalfEdge GLUhalfEdge;

typedef struct ActiveRegion ActiveRegion;	/* Internal data */

/* The mesh structure is similar in spirit, notation, and operations
 * to the "quad-edge" structure (see L. Guibas and J. Stolfi, Primitives
 * for the manipulation of general subdivisions and the computation of
 * Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).
 * For a simplified description, see the course notes for CS348a,
 * "Mathematical Foundations of Computer Graphics", available at the
 * Stanford bookstore (and taught during the fall quarter).
 * The implementation also borrows a tiny subset of the graph-based approach
 * use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction
 * to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).
 *
 * The fundamental data structure is the "half-edge".  Two half-edges
 * go together to make an edge, but they point in opposite directions.
 * Each half-edge has a pointer to its mate (the "symmetric" half-edge Sym),
 * its origin vertex (Org), the face on its left side (Lface), and the
 * adjacent half-edges in the CCW direction around the origin vertex
 * (Onext) and around the left face (Lnext).  There is also a "next"
 * pointer for the global edge list (see below).
 *
 * The notation used for mesh navigation:
 *	Sym   = the mate of a half-edge (same edge, but opposite direction)
 *	Onext = edge CCW around origin vertex (keep same origin)
 *	Dnext = edge CCW around destination vertex (keep same dest)
 *	Lnext = edge CCW around left face (dest becomes new origin)
 *	Rnext = edge CCW around right face (origin becomes new dest)
 *
 * "prev" means to substitute CW for CCW in the definitions above.
 *
 * The mesh keeps global lists of all vertices, faces, and edges,
 * stored as doubly-linked circular lists with a dummy header node.
 * The mesh stores pointers to these dummy headers (vHead, fHead, eHead).
 *
 * The circular edge list is special; since half-edges always occur
 * in pairs (e and e->Sym), each half-edge stores a pointer in only
 * one direction.  Starting at eHead and following the e->next pointers
 * will visit each *edge* once (ie. e or e->Sym, but not both).
 * e->Sym stores a pointer in the opposite direction, thus it is
 * always true that e->Sym->next->Sym->next == e.
 *
 * Each vertex has a pointer to next and previous vertices in the
 * circular list, and a pointer to a half-edge with this vertex as
 * the origin (NULL if this is the dummy header).  There is also a
 * field "data" for client data.
 *
 * Each face has a pointer to the next and previous faces in the
 * circular list, and a pointer to a half-edge with this face as
 * the left face (NULL if this is the dummy header).  There is also
 * a field "data" for client data.
 *
 * Note that what we call a "face" is really a loop; faces may consist
 * of more than one loop (ie. not simply connected), but there is no
 * record of this in the data structure.  The mesh may consist of
 * several disconnected regions, so it may not be possible to visit
 * the entire mesh by starting at a half-edge and traversing the edge
 * structure.
 *
 * The mesh does NOT support isolated vertices; a vertex is deleted along
 * with its last edge.  Similarly when two faces are merged, one of the
 * faces is deleted (see __gl_meshDelete below).  For mesh operations,
 * all face (loop) and vertex pointers must not be NULL.  However, once
 * mesh manipulation is finished, __gl_MeshZapFace can be used to delete
 * faces of the mesh, one at a time.  All external faces can be "zapped"
 * before the mesh is returned to the client; then a NULL face indicates
 * a region which is not part of the output polygon.
 */

struct GLUvertex {
  GLUvertex	*next;		/* next vertex (never NULL) */
  GLUvertex	*prev;		/* previous vertex (never NULL) */
  GLUhalfEdge	*anEdge;	/* a half-edge with this origin */
  void		*data;		/* client's data */

  /* Internal data (keep hidden) */
  GLdouble  coords[3];	/* vertex location in 3D */
  GLdouble  s, t;		/* projection onto the sweep plane */
  long		pqHandle;	/* to allow deletion from priority queue */
};

struct GLUface {
  GLUface	*next;		/* next face (never NULL) */
  GLUface	*prev;		/* previous face (never NULL) */
  GLUhalfEdge	*anEdge;	/* a half edge with this left face */
  void		*data;		/* room for client's data */

  /* Internal data (keep hidden) */
  GLUface	*trail;		/* "stack" for conversion to strips */
  GLboolean	marked;		/* flag for conversion to strips */
  GLboolean	inside;		/* this face is in the polygon interior */
};

struct GLUhalfEdge {
  GLUhalfEdge	*next;		/* doubly-linked list (prev==Sym->next) */
  GLUhalfEdge	*Sym;		/* same edge, opposite direction */
  GLUhalfEdge	*Onext;		/* next edge CCW around origin */
  GLUhalfEdge	*Lnext;		/* next edge CCW around left face */
  GLUvertex	*Org;		/* origin vertex (Overtex too long) */
  GLUface	*Lface;		/* left face */

  /* Internal data (keep hidden) */
  ActiveRegion	*activeRegion;	/* a region with this upper edge (sweep.c) */
  int		winding;	/* change in winding number when crossing
                                   from the right face to the left face */
};

#define	Rface	Sym->Lface
#define Dst	Sym->Org

#define Oprev	Sym->Lnext
#define Lprev   Onext->Sym
#define Dprev	Lnext->Sym
#define Rprev	Sym->Onext
#define Dnext	Rprev->Sym	/* 3 pointers */
#define Rnext	Oprev->Sym	/* 3 pointers */


struct GLUmesh {
  GLUvertex	vHead;		/* dummy header for vertex list */
  GLUface	fHead;		/* dummy header for face list */
  GLUhalfEdge	eHead;		/* dummy header for edge list */
  GLUhalfEdge	eHeadSym;	/* and its symmetric counterpart */
};

/* The mesh operations below have three motivations: completeness,
 * convenience, and efficiency.  The basic mesh operations are MakeEdge,
 * Splice, and Delete.  All the other edge operations can be implemented
 * in terms of these.  The other operations are provided for convenience
 * and/or efficiency.
 *
 * When a face is split or a vertex is added, they are inserted into the
 * global list *before* the existing vertex or face (ie. e->Org or e->Lface).
 * This makes it easier to process all vertices or faces in the global lists
 * without worrying about processing the same data twice.  As a convenience,
 * when a face is split, the "inside" flag is copied from the old face.
 * Other internal data (v->data, v->activeRegion, f->data, f->marked,
 * f->trail, e->winding) is set to zero.
 *
 * ********************** Basic Edge Operations **************************
 *
 * __gl_meshMakeEdge( mesh ) creates one edge, two vertices, and a loop.
 * The loop (face) consists of the two new half-edges.
 *
 * __gl_meshSplice( eOrg, eDst ) is the basic operation for changing the
 * mesh connectivity and topology.  It changes the mesh so that
 *	eOrg->Onext <- OLD( eDst->Onext )
 *	eDst->Onext <- OLD( eOrg->Onext )
 * where OLD(...) means the value before the meshSplice operation.
 *
 * This can have two effects on the vertex structure:
 *  - if eOrg->Org != eDst->Org, the two vertices are merged together
 *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
 * In both cases, eDst->Org is changed and eOrg->Org is untouched.
 *
 * Similarly (and independently) for the face structure,
 *  - if eOrg->Lface == eDst->Lface, one loop is split into two
 *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
 * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
 *
 * __gl_meshDelete( eDel ) removes the edge eDel.  There are several cases:
 * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
 * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
 * the newly created loop will contain eDel->Dst.  If the deletion of eDel
 * would create isolated vertices, those are deleted as well.
 *
 * ********************** Other Edge Operations **************************
 *
 * __gl_meshAddEdgeVertex( eOrg ) creates a new edge eNew such that
 * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
 * eOrg and eNew will have the same left face.
 *
 * __gl_meshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
 * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
 * eOrg and eNew will have the same left face.
 *
 * __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
 * to eDst->Org, and returns the corresponding half-edge eNew.
 * If eOrg->Lface == eDst->Lface, this splits one loop into two,
 * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
 * loops are merged into one, and the loop eDst->Lface is destroyed.
 *
 * ************************ Other Operations *****************************
 *
 * __gl_meshNewMesh() creates a new mesh with no edges, no vertices,
 * and no loops (what we usually call a "face").
 *
 * __gl_meshUnion( mesh1, mesh2 ) forms the union of all structures in
 * both meshes, and returns the new mesh (the old meshes are destroyed).
 *
 * __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.
 *
 * __gl_meshZapFace( fZap ) destroys a face and removes it from the
 * global face list.  All edges of fZap will have a NULL pointer as their
 * left face.  Any edges which also have a NULL pointer as their right face
 * are deleted entirely (along with any isolated vertices this produces).
 * An entire mesh can be deleted by zapping its faces, one at a time,
 * in any order.  Zapped faces cannot be used in further mesh operations!
 *
 * __gl_meshCheckMesh( mesh ) checks a mesh for self-consistency.
 */

GLUhalfEdge	*__gl_meshMakeEdge( GLUmesh *mesh );
void		__gl_meshSplice( GLUhalfEdge *eOrg, GLUhalfEdge *eDst );
void		__gl_meshDelete( GLUhalfEdge *eDel );

GLUhalfEdge	*__gl_meshAddEdgeVertex( GLUhalfEdge *eOrg );
GLUhalfEdge	*__gl_meshSplitEdge( GLUhalfEdge *eOrg );
GLUhalfEdge	*__gl_meshConnect( GLUhalfEdge *eOrg, GLUhalfEdge *eDst );

GLUmesh		*__gl_meshNewMesh( void );
GLUmesh		*__gl_meshUnion( GLUmesh *mesh1, GLUmesh *mesh2 );
void		__gl_meshDeleteMesh( GLUmesh *mesh );
void		__gl_meshZapFace( GLUface *fZap );

#ifdef NDEBUG
#define		__gl_meshCheckMesh( mesh )
#else
void		__gl_meshCheckMesh( GLUmesh *mesh );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\normal.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "mesh.h"
#include "tess.h"
#include "normal.h"
#include <math.h>
#include <assert.h>

#define TRUE 1
#define FALSE 0

#define Dot(u,v)	(u[0]*v[0] + u[1]*v[1] + u[2]*v[2])

static void Normalize( GLdouble v[3] )
{
  GLdouble len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];

  assert( len > 0 );
  len = sqrt( len );
  v[0] /= len;
  v[1] /= len;
  v[2] /= len;
}

#define ABS(x)	((x) < 0 ? -(x) : (x))

static int LongAxis( GLdouble v[3] )
{
  int i = 0;

  if( ABS(v[1]) > ABS(v[0]) ) { i = 1; }
  if( ABS(v[2]) > ABS(v[i]) ) { i = 2; }
  return i;
}

static void ComputeNormal( GLUtesselator *tess, GLdouble norm[3] )
{
  GLUvertex *v, *v1, *v2;
  GLdouble c, tLen2, maxLen2;
  GLdouble maxVal[3], minVal[3], d1[3], d2[3], tNorm[3];
  GLUvertex *maxVert[3], *minVert[3];
  GLUvertex *vHead = &tess->mesh->vHead;
  int i;

  maxVal[0] = maxVal[1] = maxVal[2] = -2 * GLU_TESS_MAX_COORD;
  minVal[0] = minVal[1] = minVal[2] = 2 * GLU_TESS_MAX_COORD;

  for( v = vHead->next; v != vHead; v = v->next ) {
    for( i = 0; i < 3; ++i ) {
      c = v->coords[i];
      if( c < minVal[i] ) { minVal[i] = c; minVert[i] = v; }
      if( c > maxVal[i] ) { maxVal[i] = c; maxVert[i] = v; }
    }
  }

  /* Find two vertices separated by at least 1/sqrt(3) of the maximum
   * distance between any two vertices
   */
  i = 0;
  if( maxVal[1] - minVal[1] > maxVal[0] - minVal[0] ) { i = 1; }
  if( maxVal[2] - minVal[2] > maxVal[i] - minVal[i] ) { i = 2; }
  if( minVal[i] >= maxVal[i] ) {
    /* All vertices are the same -- normal doesn't matter */
    norm[0] = 0; norm[1] = 0; norm[2] = 1;
    return;
  }

  /* Look for a third vertex which forms the triangle with maximum area
   * (Length of normal == twice the triangle area)
   */
  maxLen2 = 0;
  v1 = minVert[i];
  v2 = maxVert[i];
  d1[0] = v1->coords[0] - v2->coords[0];
  d1[1] = v1->coords[1] - v2->coords[1];
  d1[2] = v1->coords[2] - v2->coords[2];
  for( v = vHead->next; v != vHead; v = v->next ) {
    d2[0] = v->coords[0] - v2->coords[0];
    d2[1] = v->coords[1] - v2->coords[1];
    d2[2] = v->coords[2] - v2->coords[2];
    tNorm[0] = d1[1]*d2[2] - d1[2]*d2[1];
    tNorm[1] = d1[2]*d2[0] - d1[0]*d2[2];
    tNorm[2] = d1[0]*d2[1] - d1[1]*d2[0];
    tLen2 = tNorm[0]*tNorm[0] + tNorm[1]*tNorm[1] + tNorm[2]*tNorm[2];
    if( tLen2 > maxLen2 ) {
      maxLen2 = tLen2;
      norm[0] = tNorm[0];
      norm[1] = tNorm[1];
      norm[2] = tNorm[2];
    }
  }

  if( maxLen2 <= 0 ) {
    /* All points lie on a single line -- any decent normal will do */
    norm[0] = norm[1] = norm[2] = 0;
    norm[LongAxis(d1)] = 1;
  }
}
  

static void CheckOrientation( GLUtesselator *tess )
{
  GLdouble area;
  GLUface *f, *fHead = &tess->mesh->fHead;
  GLUvertex *v, *vHead = &tess->mesh->vHead;
  GLUhalfEdge *e;

  /* When we compute the normal automatically, we choose the orientation
   * so that the the sum of the signed areas of all contours is non-negative.
   */
  area = 0;
  for( f = fHead->next; f != fHead; f = f->next ) {
    e = f->anEdge;
    if( e->winding <= 0 ) continue;
    do {
      area += (e->Org->s - e->Dst->s) * (e->Org->t + e->Dst->t);
      e = e->Lnext;
    } while( e != f->anEdge );
  }
  if( area < 0 ) {
    /* Reverse the orientation by flipping all the t-coordinates */
    for( v = vHead->next; v != vHead; v = v->next ) {
      v->t = - v->t;
    }
    tess->tUnit[0] = - tess->tUnit[0];
    tess->tUnit[1] = - tess->tUnit[1];
    tess->tUnit[2] = - tess->tUnit[2];
  }
}

#ifdef DEBUG
#include <stdlib.h>
extern int RandomSweep;
#define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
#define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
#else
#if defined(SLANTED_SWEEP) 
/* The "feature merging" is not intended to be complete.  There are
 * special cases where edges are nearly parallel to the sweep line
 * which are not implemented.  The algorithm should still behave
 * robustly (ie. produce a reasonable tesselation) in the presence
 * of such edges, however it may miss features which could have been
 * merged.  We could minimize this effect by choosing the sweep line
 * direction to be something unusual (ie. not parallel to one of the
 * coordinate axes).
 */
#define S_UNIT_X	0.50941539564955385	/* Pre-normalized */
#define S_UNIT_Y	0.86052074622010633
#else
#define S_UNIT_X	1.0
#define S_UNIT_Y	0.0
#endif
#endif

/* Determine the polygon normal and project vertices onto the plane
 * of the polygon.
 */
void __gl_projectPolygon( GLUtesselator *tess )
{
  GLUvertex *v, *vHead = &tess->mesh->vHead;
  GLdouble w, norm[3];
  GLdouble *sUnit, *tUnit;
  int i, computedNormal = FALSE;

  norm[0] = tess->normal[0];
  norm[1] = tess->normal[1];
  norm[2] = tess->normal[2];
  if( norm[0] == 0 && norm[1] == 0 && norm[2] == 0 ) {
    ComputeNormal( tess, norm );
    computedNormal = TRUE;
  }
  sUnit = tess->sUnit;
  tUnit = tess->tUnit;
  i = LongAxis( norm );

#if defined(DEBUG) || defined(TRUE_PROJECT)
  /* Choose the initial sUnit vector to be approximately perpendicular
   * to the normal.
   */
  Normalize( norm );

  sUnit[i] = 0;
  sUnit[(i+1)%3] = S_UNIT_X;
  sUnit[(i+2)%3] = S_UNIT_Y;

  /* Now make it exactly perpendicular */
  w = Dot( sUnit, norm );
  sUnit[0] -= w * norm[0];
  sUnit[1] -= w * norm[1];
  sUnit[2] -= w * norm[2];
  Normalize( sUnit );

  /* Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame */
  tUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];
  tUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];
  tUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];
  Normalize( tUnit );
#else
  /* Project perpendicular to a coordinate axis -- better numerically */
  sUnit[i] = 0;
  sUnit[(i+1)%3] = S_UNIT_X;
  sUnit[(i+2)%3] = S_UNIT_Y;
  
  tUnit[i] = 0;
  tUnit[(i+1)%3] = (norm[i] > 0) ? -S_UNIT_Y : S_UNIT_Y;
  tUnit[(i+2)%3] = (norm[i] > 0) ? S_UNIT_X : -S_UNIT_X;
#endif

  /* Project the vertices onto the sweep plane */
  for( v = vHead->next; v != vHead; v = v->next ) {
    v->s = Dot( v->coords, sUnit );
    v->t = Dot( v->coords, tUnit );
  }
  if( computedNormal ) {
    CheckOrientation( tess );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\priority.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <stddef.h>
#include <assert.h>
#include "memalloc.h"

/* Include all the code for the regular heap-based queue here. */

#ifdef NT
#include "prq-heap.c"
#else
#include "priorityq-heap.c"
#endif

/* Now redefine all the function names to map to their "Sort" versions. */

#ifdef NT
#include "prq-sort.h"
#else
#include "priorityq-sort.h"
#endif


PriorityQ *pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) )
{
  PriorityQ *pq = (PriorityQ *)memAlloc( sizeof( PriorityQ ));

  pq->heap = __gl_pqHeapNewPriorityQ( leq );
  pq->keys = (PQHeapKey *)memAlloc( INIT_SIZE * sizeof(pq->keys[0]) );
  pq->size = 0;
  pq->max = INIT_SIZE;
  pq->initialized = FALSE;
  pq->leq = leq;
  return pq;
}


void pqDeletePriorityQ( PriorityQ *pq )
{
  __gl_pqHeapDeletePriorityQ( pq->heap );
#ifdef NT
  memFree( pq->order );
#endif
  memFree( pq->keys );
  memFree( pq );
}


#define LT(x,y)		(! LEQ(y,x))
#define GT(x,y)		(! LEQ(x,y))
#define Swap(a,b)	if(1){PQkey *tmp = *a; *a = *b; *b = tmp;}else

void pqInit( PriorityQ *pq )
{
  PQkey **p, **r, **i, **j, *piv;
  struct { PQkey **p, **r; } Stack[50], *top = Stack;
  unsigned long seed = 2016473283;

  /* Create an array of indirect pointers to the keys, so that we
   * the handles we have returned are still valid.
   */
  pq->order = (PQHeapKey **)memAlloc( (size_t) 
	                                  (pq->size * sizeof(pq->order[0])) );
  p = pq->order;
  r = p + pq->size - 1;
  for( piv = pq->keys, i = p; i <= r; ++piv, ++i ) {
    *i = piv;
  }

  /* Sort the indirect pointers in descending order,
   * using randomized Quicksort
   */
  top->p = p; top->r = r; ++top;
  while( --top >= Stack ) {
    p = top->p;
    r = top->r;
    while( r > p + 10 ) {
      seed = seed * 1539415821 + 1;
      i = p + seed % (r - p + 1);
      piv = *i;
      *i = *p;
      *p = piv;
      i = p - 1;
      j = r + 1;
      do {
	do { ++i; } while( GT( **i, *piv ));
	do { --j; } while( LT( **j, *piv ));
	Swap( i, j );
      } while( i < j );
      Swap( i, j );	/* Undo last swap */
      if( i - p < r - j ) {
	top->p = j+1; top->r = r; ++top;
	r = i-1;
      } else {
	top->p = p; top->r = i-1; ++top;
	p = j+1;
      }
    }
    /* Insertion sort small lists */
    for( i = p+1; i <= r; ++i ) {
      piv = *i;
      for( j = i; j > p && LT( **(j-1), *piv ); --j ) {
	*j = *(j-1);
      }
      *j = piv;
    }
  }
  pq->max = pq->size;
  pq->initialized = TRUE;
  __gl_pqHeapInit( pq->heap );

#ifndef NDEBUG
  p = pq->order;
  r = p + pq->size - 1;
  for( i = p; i < r; ++i ) {
    assert( LEQ( **(i+1), **i ));
  }
#endif
}


PQhandle pqInsert( PriorityQ *pq, PQkey keyNew )
{
  long curr;

  if( pq->initialized ) {
    return __gl_pqHeapInsert( pq->heap, keyNew );
  }
  curr = pq->size;
  if( ++ pq->size >= pq->max ) {
    /* If the heap overflows, double its size. */
    pq->max <<= 1;
    pq->keys = (PQHeapKey *)memRealloc( pq->keys, 
	 	                        (size_t)
	                                 (pq->max * sizeof( pq->keys[0] )));
  }
  pq->keys[curr] = keyNew;

  /* Negative handles index the sorted array. */
  return -(curr+1);
}


PQkey pqExtractMin( PriorityQ *pq )
{
  PQkey sortMin, heapMin;

  if( pq->size == 0 ) {
    return __gl_pqHeapExtractMin( pq->heap );
  }
  sortMin = *(pq->order[pq->size-1]);
  if( ! __gl_pqHeapIsEmpty( pq->heap )) {
    heapMin = __gl_pqHeapMinimum( pq->heap );
    if( LEQ( heapMin, sortMin )) {
      return __gl_pqHeapExtractMin( pq->heap );
    }
  }
  do {
    -- pq->size;
  } while( pq->size > 0 && *(pq->order[pq->size-1]) == NULL );
  return sortMin;
}


PQkey pqMinimum( PriorityQ *pq )
{
  PQkey sortMin, heapMin;

  if( pq->size == 0 ) {
    return __gl_pqHeapMinimum( pq->heap );
  }
  sortMin = *(pq->order[pq->size-1]);
  if( ! __gl_pqHeapIsEmpty( pq->heap )) {
    heapMin = __gl_pqHeapMinimum( pq->heap );
    if( LEQ( heapMin, sortMin )) {
      return heapMin;
    }
  }
  return sortMin;
}


int pqIsEmpty( PriorityQ *pq )
{
  return (pq->size == 0) && __gl_pqHeapIsEmpty( pq->heap );
}


void pqDelete( PriorityQ *pq, PQhandle curr )
{
  if( curr >= 0 ) {
    __gl_pqHeapDelete( pq->heap, curr );
    return;
  }
  curr = -(curr+1);
  assert( curr < pq->max && pq->keys[curr] != NULL );

  pq->keys[curr] = NULL;
  while( pq->size > 0 && *(pq->order[pq->size-1]) == NULL ) {
    -- pq->size;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\normal.h ===
#ifndef __normal_h_
#define __normal_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "tess.h"

/* __gl_projectPolygon( tess ) determines the polygon normal
 * and project vertices onto the plane of the polygon.
 */
void __gl_projectPolygon( GLUtesselator *tess );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\prq-heap.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <stddef.h>
#include <assert.h>
#ifdef NT
#include "prq-heap.h"
#else
#include "priorityq-heap.h"
#endif
#include "memalloc.h"

#define INIT_SIZE	32

#define TRUE 1
#define FALSE 0

#ifdef DEBUG
#define LEQ(x,y)	(*pq->leq)(x,y)
#else
/* Violates modularity, but a little faster */
#include "geom.h"
#define LEQ(x,y)	VertLeq((GLUvertex *)x, (GLUvertex *)y)
#endif

PriorityQ *pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) )
{
  PriorityQ *pq = (PriorityQ *)memAlloc( sizeof( PriorityQ ));

  pq->size = 0;
  pq->max = INIT_SIZE;
  pq->nodes = (PQnode *)memAlloc( (INIT_SIZE + 1) * sizeof(pq->nodes[0]) );
  pq->handles = (PQhandleElem *)memAlloc( (INIT_SIZE + 1) * sizeof(pq->handles[0]) );
  pq->initialized = FALSE;
  pq->freeList = 0;
  pq->leq = leq;

  pq->nodes[1].handle = 1;	/* so that Minimum() returns NULL */
  pq->handles[1].key = NULL;
  return pq;
}


void pqDeletePriorityQ( PriorityQ *pq )
{
  memFree( pq->handles );
  memFree( pq->nodes );
  memFree( pq );
}


static void FloatDown( PriorityQ *pq, long curr )
{
  PQnode *n = pq->nodes;
  PQhandleElem *h = pq->handles;
  PQhandle hCurr, hChild;
  long child;

  hCurr = n[curr].handle;
  for( ;; ) {
    child = curr << 1;
    if( child < pq->size && LEQ( h[n[child+1].handle].key,
				 h[n[child].handle].key )) {
      ++child;
    }
    hChild = n[child].handle;
    if( child > pq->size || LEQ( h[hCurr].key, h[hChild].key )) {
      n[curr].handle = hCurr;
      h[hCurr].node = curr;
      break;
    }
    n[curr].handle = hChild;
    h[hChild].node = curr;
    curr = child;
  }
}


static void FloatUp( PriorityQ *pq, long curr )
{
  PQnode *n = pq->nodes;
  PQhandleElem *h = pq->handles;
  PQhandle hCurr, hParent;
  long parent;

  hCurr = n[curr].handle;
  for( ;; ) {
    parent = curr >> 1;
    hParent = n[parent].handle;
    if( parent == 0 || LEQ( h[hParent].key, h[hCurr].key )) {
      n[curr].handle = hCurr;
      h[hCurr].node = curr;
      break;
    }
    n[curr].handle = hParent;
    h[hParent].node = curr;
    curr = parent;
  }
}


void pqInit( PriorityQ *pq )
{
  long i;

  /* This method of building a heap is O(n), rather than O(n lg n). */

  for( i = pq->size; i >= 1; --i ) {
    FloatDown( pq, i );
  }
  pq->initialized = TRUE;
}


PQhandle pqInsert( PriorityQ *pq, PQkey keyNew )
{
  long curr;
  PQhandle free;

  curr = ++ pq->size;
  if( curr > pq->max ) {
    /* If the heap overflows, double its size. */
    pq->max <<= 1;
    pq->nodes = (PQnode *)memRealloc( pq->nodes, 
				     (size_t) 
				     ((pq->max + 1) * sizeof( pq->nodes[0] )));
    pq->handles = (PQhandleElem *)memRealloc( pq->handles,
			                     (size_t)
			                      ((pq->max + 1) * 
					       sizeof( pq->handles[0] )));
  }

  if( pq->freeList == 0 ) {
    free = curr;
  } else {
    free = pq->freeList;
    pq->freeList = pq->handles[free].node;
  }

  pq->nodes[curr].handle = free;
  pq->handles[free].node = curr;
  pq->handles[free].key = keyNew;

  if( pq->initialized ) {
    FloatUp( pq, curr );
  }
  return free;
}


PQkey pqExtractMin( PriorityQ *pq )
{
  PQnode *n = pq->nodes;
  PQhandleElem *h = pq->handles;
  PQhandle hMin = n[1].handle;
  PQkey min = h[hMin].key;

  if( pq->size > 0 ) {
    n[1].handle = n[pq->size].handle;
    h[n[1].handle].node = 1;

    h[hMin].key = NULL;
    h[hMin].node = pq->freeList;
    pq->freeList = hMin;

    if( -- pq->size > 0 ) {
      FloatDown( pq, 1 );
    }
  }
  return min;
}


void pqDelete( PriorityQ *pq, PQhandle hCurr )
{
  PQnode *n = pq->nodes;
  PQhandleElem *h = pq->handles;
  long curr;

  assert( hCurr >= 1 && hCurr <= pq->max && h[hCurr].key != NULL );

  curr = h[hCurr].node;
  n[curr].handle = n[pq->size].handle;
  h[n[curr].handle].node = curr;

  if( curr <= -- pq->size ) {
    if( curr <= 1 || LEQ( h[n[curr>>1].handle].key, h[n[curr].handle].key )) {
      FloatDown( pq, curr );
    } else {
      FloatUp( pq, curr );
    }
  }
  h[hCurr].key = NULL;
  h[hCurr].node = pq->freeList;
  pq->freeList = hCurr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\prq-heap.h ===
#ifndef __priorityq_heap_h_
#define __priorityq_heap_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

/* Use #define's so that another heap implementation can use this one */

#define PQkey			PQHeapKey
#define PQhandle		PQHeapHandle
#define PriorityQ		PriorityQHeap

#define pqNewPriorityQ(leq)	__gl_pqHeapNewPriorityQ(leq)
#define pqDeletePriorityQ(pq)	__gl_pqHeapDeletePriorityQ(pq)

/* The basic operations are insertion of a new key (pqInsert),
 * and examination/extraction of a key whose value is minimum
 * (pqMinimum/pqExtractMin).  Deletion is also allowed (pqDelete);
 * for this purpose pqInsert returns a "handle" which is supplied
 * as the argument.
 *
 * An initial heap may be created efficiently by calling pqInsert
 * repeatedly, then calling pqInit.  In any case pqInit must be called
 * before any operations other than pqInsert are used.
 *
 * If the heap is empty, pqMinimum/pqExtractMin will return a NULL key.
 * This may also be tested with pqIsEmpty.
 */
#define pqInit(pq)		__gl_pqHeapInit(pq)
#define pqInsert(pq,key)	__gl_pqHeapInsert(pq,key)
#define pqMinimum(pq)		__gl_pqHeapMinimum(pq)
#define pqExtractMin(pq)	__gl_pqHeapExtractMin(pq)
#define pqDelete(pq,handle)	__gl_pqHeapDelete(pq,handle)
#define pqIsEmpty(pq)		__gl_pqHeapIsEmpty(pq)


/* Since we support deletion the data structure is a little more
 * complicated than an ordinary heap.  "nodes" is the heap itself;
 * active nodes are stored in the range 1..pq->size.  When the
 * heap exceeds its allocated size (pq->max), its size doubles.
 * The children of node i are nodes 2i and 2i+1.
 *
 * Each node stores an index into an array "handles".  Each handle
 * stores a key, plus a pointer back to the node which currently
 * represents that key (ie. nodes[handles[i].node].handle == i).
 */

typedef void *PQkey;
typedef long PQhandle;
typedef struct PriorityQ PriorityQ;

typedef struct { PQhandle handle; } PQnode;
typedef struct { PQkey key; PQhandle node; } PQhandleElem;

struct PriorityQ {
  PQnode	*nodes;
  PQhandleElem	*handles;
  long		size, max;
  PQhandle	freeList;
  int		initialized;
  int		(*leq)(PQkey key1, PQkey key2);
};
  
PriorityQ	*pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) );
void		pqDeletePriorityQ( PriorityQ *pq );

void		pqInit( PriorityQ *pq );
PQhandle	pqInsert( PriorityQ *pq, PQkey key );
PQkey		pqExtractMin( PriorityQ *pq );
void		pqDelete( PriorityQ *pq, PQhandle handle );


#define __gl_pqHeapMinimum(pq)	((pq)->handles[(pq)->nodes[1].handle].key)
#define __gl_pqHeapIsEmpty(pq)	((pq)->size == 0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\priority.h ===
#ifndef __priorityq_sort_h_
#define __priorityq_sort_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include "prq-heap.h"
#else
#include "priorityq-heap.h"
#endif

#undef PQkey
#undef PQhandle
#undef PriorityQ
#undef pqNewPriorityQ
#undef pqDeletePriorityQ
#undef pqInit
#undef pqInsert
#undef pqMinimum
#undef pqExtractMin
#undef pqDelete
#undef pqIsEmpty

/* Use #define's so that another heap implementation can use this one */

#define PQkey			PQSortKey
#define PQhandle		PQSortHandle
#define PriorityQ		PriorityQSort

#define pqNewPriorityQ(leq)	__gl_pqSortNewPriorityQ(leq)
#define pqDeletePriorityQ(pq)	__gl_pqSortDeletePriorityQ(pq)

/* The basic operations are insertion of a new key (pqInsert),
 * and examination/extraction of a key whose value is minimum
 * (pqMinimum/pqExtractMin).  Deletion is also allowed (pqDelete);
 * for this purpose pqInsert returns a "handle" which is supplied
 * as the argument.
 *
 * An initial heap may be created efficiently by calling pqInsert
 * repeatedly, then calling pqInit.  In any case pqInit must be called
 * before any operations other than pqInsert are used.
 *
 * If the heap is empty, pqMinimum/pqExtractMin will return a NULL key.
 * This may also be tested with pqIsEmpty.
 */
#define pqInit(pq)		__gl_pqSortInit(pq)
#define pqInsert(pq,key)	__gl_pqSortInsert(pq,key)
#define pqMinimum(pq)		__gl_pqSortMinimum(pq)
#define pqExtractMin(pq)	__gl_pqSortExtractMin(pq)
#define pqDelete(pq,handle)	__gl_pqSortDelete(pq,handle)
#define pqIsEmpty(pq)		__gl_pqSortIsEmpty(pq)


/* Since we support deletion the data structure is a little more
 * complicated than an ordinary heap.  "nodes" is the heap itself;
 * active nodes are stored in the range 1..pq->size.  When the
 * heap exceeds its allocated size (pq->max), its size doubles.
 * The children of node i are nodes 2i and 2i+1.
 *
 * Each node stores an index into an array "handles".  Each handle
 * stores a key, plus a pointer back to the node which currently
 * represents that key (ie. nodes[handles[i].node].handle == i).
 */

typedef PQHeapKey PQkey;
typedef PQHeapHandle PQhandle;
typedef struct PriorityQ PriorityQ;

struct PriorityQ {
  PriorityQHeap	*heap;
  PQkey		*keys;
  PQkey		**order;
  PQhandle	size, max;
  int		initialized;
  int		(*leq)(PQkey key1, PQkey key2);
};
  
PriorityQ	*pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) );
void		pqDeletePriorityQ( PriorityQ *pq );

void		pqInit( PriorityQ *pq );
PQhandle	pqInsert( PriorityQ *pq, PQkey key );
PQkey		pqExtractMin( PriorityQ *pq );
void		pqDelete( PriorityQ *pq, PQhandle handle );

PQkey		pqMinimum( PriorityQ *pq );
int		pqIsEmpty( PriorityQ *pq );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\prq-sort.h ===
#ifndef __priorityq_sort_h_
#define __priorityq_sort_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include "prq-heap.h"
#else
#include "priorityq-heap.h"
#endif

#undef PQkey
#undef PQhandle
#undef PriorityQ
#undef pqNewPriorityQ
#undef pqDeletePriorityQ
#undef pqInit
#undef pqInsert
#undef pqMinimum
#undef pqExtractMin
#undef pqDelete
#undef pqIsEmpty

/* Use #define's so that another heap implementation can use this one */

#define PQkey			PQSortKey
#define PQhandle		PQSortHandle
#define PriorityQ		PriorityQSort

#define pqNewPriorityQ(leq)	__gl_pqSortNewPriorityQ(leq)
#define pqDeletePriorityQ(pq)	__gl_pqSortDeletePriorityQ(pq)

/* The basic operations are insertion of a new key (pqInsert),
 * and examination/extraction of a key whose value is minimum
 * (pqMinimum/pqExtractMin).  Deletion is also allowed (pqDelete);
 * for this purpose pqInsert returns a "handle" which is supplied
 * as the argument.
 *
 * An initial heap may be created efficiently by calling pqInsert
 * repeatedly, then calling pqInit.  In any case pqInit must be called
 * before any operations other than pqInsert are used.
 *
 * If the heap is empty, pqMinimum/pqExtractMin will return a NULL key.
 * This may also be tested with pqIsEmpty.
 */
#define pqInit(pq)		__gl_pqSortInit(pq)
#define pqInsert(pq,key)	__gl_pqSortInsert(pq,key)
#define pqMinimum(pq)		__gl_pqSortMinimum(pq)
#define pqExtractMin(pq)	__gl_pqSortExtractMin(pq)
#define pqDelete(pq,handle)	__gl_pqSortDelete(pq,handle)
#define pqIsEmpty(pq)		__gl_pqSortIsEmpty(pq)


/* Since we support deletion the data structure is a little more
 * complicated than an ordinary heap.  "nodes" is the heap itself;
 * active nodes are stored in the range 1..pq->size.  When the
 * heap exceeds its allocated size (pq->max), its size doubles.
 * The children of node i are nodes 2i and 2i+1.
 *
 * Each node stores an index into an array "handles".  Each handle
 * stores a key, plus a pointer back to the node which currently
 * represents that key (ie. nodes[handles[i].node].handle == i).
 */

typedef PQHeapKey PQkey;
typedef PQHeapHandle PQhandle;
typedef struct PriorityQ PriorityQ;

struct PriorityQ {
  PriorityQHeap	*heap;
  PQkey		*keys;
  PQkey		**order;
  PQhandle	size, max;
  int		initialized;
  int		(*leq)(PQkey key1, PQkey key2);
};
  
PriorityQ	*pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) );
void		pqDeletePriorityQ( PriorityQ *pq );

void		pqInit( PriorityQ *pq );
PQhandle	pqInsert( PriorityQ *pq, PQkey key );
PQkey		pqExtractMin( PriorityQ *pq );
void		pqDelete( PriorityQ *pq, PQhandle handle );

PQkey		pqMinimum( PriorityQ *pq );
int		pqIsEmpty( PriorityQ *pq );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\render.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/


#include <assert.h>
#include <stddef.h>
#include "mesh.h"
#include "tess.h"
#include "render.h"

#define TRUE 1
#define FALSE 0

/* This structure remembers the information we need about a primitive
 * to be able to render it later, once we have determined which
 * primitive is able to use the most triangles.
 */
struct FaceCount {
  long		size;		/* number of triangles used */
  GLUhalfEdge	*eStart;	/* edge where this primitive starts */
  void		(*render)(GLUtesselator *, GLUhalfEdge *, long);
                                /* routine to render this primitive */
};

static struct FaceCount MaximumFan( GLUhalfEdge *eOrig );
static struct FaceCount MaximumStrip( GLUhalfEdge *eOrig );

static void RenderFan( GLUtesselator *tess, GLUhalfEdge *eStart, long size );
static void RenderStrip( GLUtesselator *tess, GLUhalfEdge *eStart, long size );
static void RenderTriangle( GLUtesselator *tess, GLUhalfEdge *eStart,
			    long size );

static void RenderMaximumFaceGroup( GLUtesselator *tess, GLUface *fOrig );
static void RenderLonelyTriangles( GLUtesselator *tess, GLUface *head );



/************************ Strips and Fans decomposition ******************/

/* __gl_renderMesh( tess, mesh ) takes a mesh and breaks it into triangle
 * fans, strips, and separate triangles.  A substantial effort is made
 * to use as few rendering primitives as possible (ie. to make the fans
 * and strips as large as possible).
 *
 * The rendering output is provided as callbacks (see the api).
 */
void __gl_renderMesh( GLUtesselator *tess, GLUmesh *mesh )
{
  GLUface *f;

  /* Make a list of separate triangles so we can render them all at once */
  tess->lonelyTriList = NULL;

  for( f = mesh->fHead.next; f != &mesh->fHead; f = f->next ) {
    f->marked = FALSE;
  }
  for( f = mesh->fHead.next; f != &mesh->fHead; f = f->next ) {

    /* We examine all faces in an arbitrary order.  Whenever we find
     * an unprocessed face F, we output a group of faces including F
     * whose size is maximum.
     */
    if( f->inside && ! f->marked ) {
      RenderMaximumFaceGroup( tess, f );
      assert( f->marked );
    }
  }
  if( tess->lonelyTriList != NULL ) {
    RenderLonelyTriangles( tess, tess->lonelyTriList );
    tess->lonelyTriList = NULL;
  }
}


static void RenderMaximumFaceGroup( GLUtesselator *tess, GLUface *fOrig )
{
  /* We want to find the largest triangle fan or strip of unmarked faces
   * which includes the given face fOrig.  There are 3 possible fans
   * passing through fOrig (one centered at each vertex), and 3 possible
   * strips (one for each CCW permutation of the vertices).  Our strategy
   * is to try all of these, and take the primitive which uses the most
   * triangles (a greedy approach).
   */
  GLUhalfEdge *e = fOrig->anEdge;
  struct FaceCount max, newFace;

  max.size = 1;
  max.eStart = e;
  max.render = &RenderTriangle;

  if( ! tess->flagBoundary ) {
    newFace = MaximumFan( e ); if( newFace.size > max.size ) { max = newFace; }
    newFace = MaximumFan( e->Lnext ); if( newFace.size > max.size ) { max = newFace; }
    newFace = MaximumFan( e->Lprev ); if( newFace.size > max.size ) { max = newFace; }

    newFace = MaximumStrip( e ); if( newFace.size > max.size ) { max = newFace; }
    newFace = MaximumStrip( e->Lnext ); if( newFace.size > max.size ) { max = newFace; }
    newFace = MaximumStrip( e->Lprev ); if( newFace.size > max.size ) { max = newFace; }
  }
  (*(max.render))( tess, max.eStart, max.size );
}


/* Macros which keep track of faces we have marked temporarily, and allow
 * us to backtrack when necessary.  With triangle fans, this is not
 * really necessary, since the only awkward case is a loop of triangles
 * around a single origin vertex.  However with strips the situation is
 * more complicated, and we need a general tracking method like the
 * one here.
 */
#define Marked(f)	(! (f)->inside || (f)->marked)

#define AddToTrail(f,t)	((f)->trail = (t), (t) = (f), (f)->marked = TRUE)

#define FreeTrail(t)	if( 1 ) { \
			  while( (t) != NULL ) { \
			    (t)->marked = FALSE; t = (t)->trail; \
			  } \
			} else /* absorb trailing semicolon */



static struct FaceCount MaximumFan( GLUhalfEdge *eOrig )
{
  /* eOrig->Lface is the face we want to render.  We want to find the size
   * of a maximal fan around eOrig->Org.  To do this we just walk around
   * the origin vertex as far as possible in both directions.
   */
  struct FaceCount newFace = { 0, NULL, &RenderFan };
  GLUface *trail = NULL;
  GLUhalfEdge *e;

  for( e = eOrig; ! Marked( e->Lface ); e = e->Onext ) {
    AddToTrail( e->Lface, trail );
    ++newFace.size;
  }
  for( e = eOrig; ! Marked( e->Rface ); e = e->Oprev ) {
    AddToTrail( e->Rface, trail );
    ++newFace.size;
  }
  newFace.eStart = e;
  /*LINTED*/
  FreeTrail( trail );
  return newFace;
}


#define IsEven(n)	(((n) & 1) == 0)

static struct FaceCount MaximumStrip( GLUhalfEdge *eOrig )
{
  /* Here we are looking for a maximal strip that contains the vertices
   * eOrig->Org, eOrig->Dst, eOrig->Lnext->Dst (in that order or the
   * reverse, such that all triangles are oriented CCW).
   *
   * Again we walk forward and backward as far as possible.  However for
   * strips there is a twist: to get CCW orientations, there must be
   * an *even* number of triangles in the strip on one side of eOrig.
   * We walk the strip starting on a side with an even number of triangles;
   * if both side have an odd number, we are forced to shorten one side.
   */
  struct FaceCount newFace = { 0, NULL, &RenderStrip };
  long headSize = 0, tailSize = 0;
  GLUface *trail = NULL;
  GLUhalfEdge *e, *eTail, *eHead;

  for( e = eOrig; ! Marked( e->Lface ); ++tailSize, e = e->Onext ) {
    AddToTrail( e->Lface, trail );
    ++tailSize;
    e = e->Dprev;
    if( Marked( e->Lface )) break;
    AddToTrail( e->Lface, trail );
  }
  eTail = e;

  for( e = eOrig; ! Marked( e->Rface ); ++headSize, e = e->Dnext ) {
    AddToTrail( e->Rface, trail );
    ++headSize;
    e = e->Oprev;
    if( Marked( e->Rface )) break;
    AddToTrail( e->Rface, trail );
  }
  eHead = e;

  newFace.size = tailSize + headSize;
  if( IsEven( tailSize )) {
    newFace.eStart = eTail->Sym;
  } else if( IsEven( headSize )) {
    newFace.eStart = eHead;
  } else {
    /* Both sides have odd length, we must shorten one of them.  In fact,
     * we must start from eHead to guarantee inclusion of eOrig->Lface.
     */
    --newFace.size;
    newFace.eStart = eHead->Onext;
  }
  /*LINTED*/
  FreeTrail( trail );
  return newFace;
}


static void RenderTriangle( GLUtesselator *tess, GLUhalfEdge *e, long size )
{
  /* Just add the triangle to a triangle list, so we can render all
   * the separate triangles at once.
   */
  assert( size == 1 );
  AddToTrail( e->Lface, tess->lonelyTriList );
}


static void RenderLonelyTriangles( GLUtesselator *tess, GLUface *f )
{
  /* Now we render all the separate triangles which could not be
   * grouped into a triangle fan or strip.
   */
  GLUhalfEdge *e;
  int newState;
  int edgeState = -1;	/* force edge state output for first vertex */

  CALL_BEGIN_OR_BEGIN_DATA( GL_TRIANGLES );

  for( ; f != NULL; f = f->trail ) {
    /* Loop once for each edge (there will always be 3 edges) */

    e = f->anEdge;
    do {
      if( tess->flagBoundary ) {
	/* Set the "edge state" to TRUE just before we output the
	 * first vertex of each edge on the polygon boundary.
	 */
	newState = ! e->Rface->inside;
	if( edgeState != newState ) {
	  edgeState = newState;
          CALL_EDGE_FLAG_OR_EDGE_FLAG_DATA( (GLboolean)edgeState );
	}
      }
      CALL_VERTEX_OR_VERTEX_DATA( e->Org->data );

      e = e->Lnext;
    } while( e != f->anEdge );
  }
  CALL_END_OR_END_DATA();
}


static void RenderFan( GLUtesselator *tess, GLUhalfEdge *e, long size )
{
  /* Render as many CCW triangles as possible in a fan starting from
   * edge "e".  The fan *should* contain exactly "size" triangles
   * (otherwise we've goofed up somewhere).
   */
  CALL_BEGIN_OR_BEGIN_DATA( GL_TRIANGLE_FAN ); 
  CALL_VERTEX_OR_VERTEX_DATA( e->Org->data ); 
  CALL_VERTEX_OR_VERTEX_DATA( e->Dst->data ); 

  while( ! Marked( e->Lface )) {
    e->Lface->marked = TRUE;
    --size;
    e = e->Onext;
    CALL_VERTEX_OR_VERTEX_DATA( e->Dst->data ); 
  }

  assert( size == 0 );
  CALL_END_OR_END_DATA();
}


static void RenderStrip( GLUtesselator *tess, GLUhalfEdge *e, long size )
{
  /* Render as many CCW triangles as possible in a strip starting from
   * edge "e".  The strip *should* contain exactly "size" triangles
   * (otherwise we've goofed up somewhere).
   */
  CALL_BEGIN_OR_BEGIN_DATA( GL_TRIANGLE_STRIP );
  CALL_VERTEX_OR_VERTEX_DATA( e->Org->data ); 
  CALL_VERTEX_OR_VERTEX_DATA( e->Dst->data ); 

  while( ! Marked( e->Lface )) {
    e->Lface->marked = TRUE;
    --size;
    e = e->Dprev;
    CALL_VERTEX_OR_VERTEX_DATA( e->Org->data ); 
    if( Marked( e->Lface )) break;

    e->Lface->marked = TRUE;
    --size;
    e = e->Onext;
    CALL_VERTEX_OR_VERTEX_DATA( e->Dst->data ); 
  }

  assert( size == 0 );
  CALL_END_OR_END_DATA();
}


/************************ Boundary contour decomposition ******************/

/* __gl_renderBoundary( tess, mesh ) takes a mesh, and outputs one
 * contour for each face marked "inside".  The rendering output is
 * provided as callbacks (see the api).
 */
void __gl_renderBoundary( GLUtesselator *tess, GLUmesh *mesh )
{
  GLUface *f;
  GLUhalfEdge *e;

  for( f = mesh->fHead.next; f != &mesh->fHead; f = f->next ) {
    if( f->inside ) {
      CALL_BEGIN_OR_BEGIN_DATA( GL_LINE_LOOP );
      e = f->anEdge;
      do {
        CALL_VERTEX_OR_VERTEX_DATA( e->Org->data ); 
	e = e->Lnext;
      } while( e != f->anEdge );
      CALL_END_OR_END_DATA();
    }
  }
}


/************************ Quick-and-dirty decomposition ******************/

#define SIGN_INCONSISTENT 2

static int ComputeNormal( GLUtesselator *tess, GLdouble norm[3], int check )
/*
 * If check==FALSE, we compute the polygon normal and place it in norm[].
 * If check==TRUE, we check that each triangle in the fan from v0 has a
 * consistent orientation with respect to norm[].  If triangles are
 * consistently oriented CCW, return 1; if CW, return -1; if all triangles
 * are degenerate return 0; otherwise (no consistent orientation) return
 * SIGN_INCONSISTENT.
 */
{
  CachedVertex *v0 = tess->cache;
  CachedVertex *vn = v0 + tess->cacheCount;
  CachedVertex *vc;
  GLdouble dot, xc, yc, zc, xp, yp, zp, n[3];
  int sign = 0;

  /* Find the polygon normal.  It is important to get a reasonable
   * normal even when the polygon is self-intersecting (eg. a bowtie).
   * Otherwise, the computed normal could be very tiny, but perpendicular
   * to the true plane of the polygon due to numerical noise.  Then all
   * the triangles would appear to be degenerate and we would incorrectly
   * decompose the polygon as a fan (or simply not render it at all).
   *
   * We use a sum-of-triangles normal algorithm rather than the more
   * efficient sum-of-trapezoids method (used in CheckOrientation()
   * in normal.c).  This lets us explicitly reverse the signed area
   * of some triangles to get a reasonable normal in the self-intersecting
   * case.
   */
  if( ! check ) {
    norm[0] = norm[1] = norm[2] = 0.0;
  }

  vc = v0 + 1;
  xc = vc->coords[0] - v0->coords[0];
  yc = vc->coords[1] - v0->coords[1];
  zc = vc->coords[2] - v0->coords[2];
  while( ++vc < vn ) {
    xp = xc; yp = yc; zp = zc;
    xc = vc->coords[0] - v0->coords[0];
    yc = vc->coords[1] - v0->coords[1];
    zc = vc->coords[2] - v0->coords[2];

    /* Compute (vp - v0) cross (vc - v0) */
    n[0] = yp*zc - zp*yc;
    n[1] = zp*xc - xp*zc;
    n[2] = xp*yc - yp*xc;

    dot = n[0]*norm[0] + n[1]*norm[1] + n[2]*norm[2];
    if( ! check ) {
      /* Reverse the contribution of back-facing triangles to get
       * a reasonable normal for self-intersecting polygons (see above)
       */
      if( dot >= 0 ) {
	norm[0] += n[0]; norm[1] += n[1]; norm[2] += n[2];
      } else {
	norm[0] -= n[0]; norm[1] -= n[1]; norm[2] -= n[2];
      }
    } else if( dot != 0 ) {
      /* Check the new orientation for consistency with previous triangles */
      if( dot > 0 ) {
	if( sign < 0 ) return SIGN_INCONSISTENT;
	sign = 1;
      } else {
	if( sign > 0 ) return SIGN_INCONSISTENT;
	sign = -1;
      }
    }
  }
  return sign;
}

/* __gl_renderCache( tess ) takes a single contour and tries to render it
 * as a triangle fan.  This handles convex polygons, as well as some
 * non-convex polygons if we get lucky.
 *
 * Returns TRUE if the polygon was successfully rendered.  The rendering
 * output is provided as callbacks (see the api).
 */
GLboolean __gl_renderCache( GLUtesselator *tess )
{
  CachedVertex *v0 = tess->cache;
  CachedVertex *vn = v0 + tess->cacheCount;
  CachedVertex *vc;
  GLdouble norm[3];
  int sign;

  if( tess->cacheCount < 3 ) {
    /* Degenerate contour -- no output */
    return TRUE;
  }

  norm[0] = tess->normal[0];
  norm[1] = tess->normal[1];
  norm[2] = tess->normal[2];
  if( norm[0] == 0 && norm[1] == 0 && norm[2] == 0 ) {
    ComputeNormal( tess, norm, FALSE );
  }

  sign = ComputeNormal( tess, norm, TRUE );
  if( sign == SIGN_INCONSISTENT ) {
    /* Fan triangles did not have a consistent orientation */
    return FALSE;
  }
  if( sign == 0 ) {
    /* All triangles were degenerate */
    return TRUE;
  }

  /* Make sure we do the right thing for each winding rule */
  switch( tess->windingRule ) {
  case GLU_TESS_WINDING_ODD:
  case GLU_TESS_WINDING_NONZERO:
    break;
  case GLU_TESS_WINDING_POSITIVE:
    if( sign < 0 ) return TRUE;
    break;
  case GLU_TESS_WINDING_NEGATIVE:
    if( sign > 0 ) return TRUE;
    break;
  case GLU_TESS_WINDING_ABS_GEQ_TWO:
    return TRUE;
  }

  CALL_BEGIN_OR_BEGIN_DATA( tess->boundaryOnly ? GL_LINE_LOOP
			  : (tess->cacheCount > 3) ? GL_TRIANGLE_FAN
			  : GL_TRIANGLES );

  CALL_VERTEX_OR_VERTEX_DATA( v0->data ); 
  if( sign > 0 ) {
    for( vc = v0+1; vc < vn; ++vc ) {
      CALL_VERTEX_OR_VERTEX_DATA( vc->data ); 
    }
  } else {
    for( vc = vn-1; vc > v0; --vc ) {
      CALL_VERTEX_OR_VERTEX_DATA( vc->data ); 
    }
  }
  CALL_END_OR_END_DATA();
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\render.h ===
#ifndef __render_h_
#define __render_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "mesh.h"

/* __gl_renderMesh( tess, mesh ) takes a mesh and breaks it into triangle
 * fans, strips, and separate triangles.  A substantial effort is made
 * to use as few rendering primitives as possible (ie. to make the fans
 * and strips as large as possible).
 *
 * The rendering output is provided as callbacks (see the api).
 */
void __gl_renderMesh( GLUtesselator *tess, GLUmesh *mesh );
void __gl_renderBoundary( GLUtesselator *tess, GLUmesh *mesh );

GLboolean __gl_renderCache( GLUtesselator *tess );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\sweep.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <assert.h>
#include <stddef.h>

#include "mesh.h"
#include "geom.h"
#include "tess.h"
#include "dict.h"
#ifdef NT
#include "priority.h"
#else
#include "priorityq.h"
#endif
#include "memalloc.h"
#include "sweep.h"

#define TRUE 1
#define FALSE 0

#ifdef DEBUG
extern void DebugEvent( GLUtesselator *tess );
#else
#define DebugEvent( tess )
#endif

/*
 * Invariants for the Edge Dictionary.
 * - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
 *   at any valid location of the sweep event
 * - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
 *   share a common endpoint
 * - for each e, e->Dst has been processed, but not e->Org
 * - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
 *   where "event" is the current sweep line event.
 * - no edge e has zero length
 *
 * Invariants for the Mesh (the processed portion).
 * - the portion of the mesh left of the sweep line is a planar graph,
 *   ie. there is *some* way to embed it in the plane
 * - no processed edge has zero length
 * - no two processed vertices have identical coordinates
 * - each "inside" region is monotone, ie. can be broken into two chains
 *   of monotonically increasing vertices according to VertLeq(v1,v2)
 *   - a non-invariant: these chains may intersect (very slightly)
 *
 * Invariants for the Sweep.
 * - if none of the edges incident to the event vertex have an activeRegion
 *   (ie. none of these edges are in the edge dictionary), then the vertex
 *   has only right-going edges.
 * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
 *   by ConnectRightVertex), then it is the only right-going edge from
 *   its associated vertex.  (This says that these edges exist only
 *   when it is necessary.)
 */

#define MAX(x,y)	((x) >= (y) ? (x) : (y))
#define MIN(x,y)	((x) <= (y) ? (x) : (y))

/* When we merge two edges into one, we need to compute the combined
 * winding of the new edge.
 */
#define AddWinding(eDst,eSrc)	(eDst->winding += eSrc->winding, \
				 eDst->Sym->winding += eSrc->Sym->winding)

static void SweepEvent( GLUtesselator *tess, GLUvertex *vEvent );
static void WalkDirtyRegions( GLUtesselator *tess, ActiveRegion *regUp );
static int CheckForRightSplice( GLUtesselator *tess, ActiveRegion *regUp );

static int EdgeLeq( GLUtesselator *tess, ActiveRegion *reg1,
		    ActiveRegion *reg2 )
/*
 * Both edges must be directed from right to left (this is the canonical
 * direction for the upper edge of each region).
 *
 * The strategy is to evaluate a "t" value for each edge at the
 * current sweep line position, given by tess->event.  The calculations
 * are designed to be very stable, but of course they are not perfect.
 *
 * Special case: if both edge destinations are at the sweep event,
 * we sort the edges by slope (they would otherwise compare equally).
 */
{
  GLUvertex *event = tess->event;
  GLUhalfEdge *e1, *e2;
  GLdouble t1, t2;

  e1 = reg1->eUp;
  e2 = reg2->eUp;

  if( e1->Dst == event ) {
    if( e2->Dst == event ) {
      /* Two edges right of the sweep line which meet at the sweep event.
       * Sort them by slope.
       */
      if( VertLeq( e1->Org, e2->Org )) {
	return EdgeSign( e2->Dst, e1->Org, e2->Org ) <= 0;
      }
      return EdgeSign( e1->Dst, e2->Org, e1->Org ) >= 0;
    }
    return EdgeSign( e2->Dst, event, e2->Org ) <= 0;
  }
  if( e2->Dst == event ) {
    return EdgeSign( e1->Dst, event, e1->Org ) >= 0;
  }

  /* General case - compute signed distance *from* e1, e2 to event */
  t1 = EdgeEval( e1->Dst, event, e1->Org );
  t2 = EdgeEval( e2->Dst, event, e2->Org );
  return (t1 >= t2);
}


static void DeleteRegion( GLUtesselator *tess, ActiveRegion *reg )
{
  if( reg->fixUpperEdge ) {
    /* It was created with zero winding number, so it better be
     * deleted with zero winding number (ie. it better not get merged
     * with a real edge).
     */
    assert( reg->eUp->winding == 0 );
  }
  reg->eUp->activeRegion = NULL;
  dictDelete( tess->dict, reg->nodeUp );
  memFree( reg );
}


static void FixUpperEdge( ActiveRegion *reg, GLUhalfEdge *newEdge )
/*
 * Replace an upper edge which needs fixing (see ConnectRightVertex).
 */
{
  assert( reg->fixUpperEdge );
  __gl_meshDelete( reg->eUp );
  reg->fixUpperEdge = FALSE;
  reg->eUp = newEdge;
  newEdge->activeRegion = reg;
}

static ActiveRegion *TopLeftRegion( ActiveRegion *reg )
{
  GLUvertex *org = reg->eUp->Org;
  GLUhalfEdge *e;

  /* Find the region above the uppermost edge with the same origin */
  do {
    reg = RegionAbove( reg );
  } while( reg->eUp->Org == org );

  /* If the edge above was a temporary edge introduced by ConnectRightVertex,
   * now is the time to fix it.
   */
  if( reg->fixUpperEdge ) {
    e = __gl_meshConnect( RegionBelow(reg)->eUp->Sym, reg->eUp->Lnext );
    FixUpperEdge( reg, e );
    reg = RegionAbove( reg );
  }
  return reg;
}

static ActiveRegion *TopRightRegion( ActiveRegion *reg )
{
  GLUvertex *dst = reg->eUp->Dst;

  /* Find the region above the uppermost edge with the same destination */
  do {
    reg = RegionAbove( reg );
  } while( reg->eUp->Dst == dst );
  return reg;
}

static ActiveRegion *AddRegionBelow( GLUtesselator *tess,
				     ActiveRegion *regAbove,
				     GLUhalfEdge *eNewUp )
/*
 * Add a new active region to the sweep line, *somewhere* below "regAbove"
 * (according to where the new edge belongs in the sweep-line dictionary).
 * The upper edge of the new region will be "eNewUp".
 * Winding number and "inside" flag are not updated.
 */
{
  ActiveRegion *regNew = (ActiveRegion *)memAlloc( sizeof( ActiveRegion ));

  regNew->eUp = eNewUp;
  regNew->nodeUp = dictInsertBefore( tess->dict, regAbove->nodeUp, regNew );
  regNew->fixUpperEdge = FALSE;
  regNew->sentinel = FALSE;
  regNew->dirty = FALSE;

  eNewUp->activeRegion = regNew;
  return regNew;
}

static GLboolean IsWindingInside( GLUtesselator *tess, int n )
{
  switch( tess->windingRule ) {
  case GLU_TESS_WINDING_ODD:
    return (n & 1);
  case GLU_TESS_WINDING_NONZERO:
    return (n != 0);
  case GLU_TESS_WINDING_POSITIVE:
    return (n > 0);
  case GLU_TESS_WINDING_NEGATIVE:
    return (n < 0);
  case GLU_TESS_WINDING_ABS_GEQ_TWO:
    return (n >= 2) || (n <= -2);
  }
  /*LINTED*/
  assert( FALSE );
  return 0;
  /*NOTREACHED*/
}


static void ComputeWinding( GLUtesselator *tess, ActiveRegion *reg )
{
  reg->windingNumber = RegionAbove(reg)->windingNumber + reg->eUp->winding;
  reg->inside = IsWindingInside( tess, reg->windingNumber );
}


static void FinishRegion( GLUtesselator *tess, ActiveRegion *reg )
/*
 * Delete a region from the sweep line.  This happens when the upper
 * and lower chains of a region meet (at a vertex on the sweep line).
 * The "inside" flag is copied to the appropriate mesh face (we could
 * not do this before -- since the structure of the mesh is always
 * changing, this face may not have even existed until now).
 */
{
  GLUhalfEdge *e = reg->eUp;
  GLUface *f = e->Lface;

  f->inside = reg->inside;
  f->anEdge = e;   /* optimization for __gl_meshTesselateMonoRegion() */
  DeleteRegion( tess, reg );
}


static GLUhalfEdge *FinishLeftRegions( GLUtesselator *tess,
	       ActiveRegion *regFirst, ActiveRegion *regLast )
/*
 * We are given a vertex with one or more left-going edges.  All affected
 * edges should be in the edge dictionary.  Starting at regFirst->eUp,
 * we walk down deleting all regions where both edges have the same
 * origin vOrg.  At the same time we copy the "inside" flag from the
 * active region to the face, since at this point each face will belong
 * to at most one region (this was not necessarily true until this point
 * in the sweep).  The walk stops at the region above regLast; if regLast
 * is NULL we walk as far as possible.  At the same time we relink the
 * mesh if necessary, so that the ordering of edges around vOrg is the
 * same as in the dictionary.
 */
{
  ActiveRegion *reg, *regPrev;
  GLUhalfEdge *e, *ePrev;

  regPrev = regFirst;
  ePrev = regFirst->eUp;
  while( regPrev != regLast ) {
    regPrev->fixUpperEdge = FALSE;	/* placement was OK */
    reg = RegionBelow( regPrev );
    e = reg->eUp;
    if( e->Org != ePrev->Org ) {
      if( ! reg->fixUpperEdge ) {
	/* Remove the last left-going edge.  Even though there are no further
	 * edges in the dictionary with this origin, there may be further
	 * such edges in the mesh (if we are adding left edges to a vertex
	 * that has already been processed).  Thus it is important to call
	 * FinishRegion rather than just DeleteRegion.
	 */
	FinishRegion( tess, regPrev );
	break;
      }
      /* If the edge below was a temporary edge introduced by
       * ConnectRightVertex, now is the time to fix it.
       */
      e = __gl_meshConnect( ePrev->Lprev, e->Sym );
      FixUpperEdge( reg, e );
    }

    /* Relink edges so that ePrev->Onext == e */
    if( ePrev->Onext != e ) {
      __gl_meshSplice( e->Oprev, e );
      __gl_meshSplice( ePrev, e );
    }
    FinishRegion( tess, regPrev );	/* may change reg->eUp */
    ePrev = reg->eUp;
    regPrev = reg;
  }
  return ePrev;
}


static void AddRightEdges( GLUtesselator *tess, ActiveRegion *regUp,
       GLUhalfEdge *eFirst, GLUhalfEdge *eLast, GLUhalfEdge *eTopLeft,
       GLboolean cleanUp )
/*
 * Purpose: insert right-going edges into the edge dictionary, and update
 * winding numbers and mesh connectivity appropriately.  All right-going
 * edges share a common origin vOrg.  Edges are inserted CCW starting at
 * eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any
 * left-going edges already processed, then eTopLeft must be the edge
 * such that an imaginary upward vertical segment from vOrg would be
 * contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft
 * should be NULL.
 */
{
  ActiveRegion *reg, *regPrev;
  GLUhalfEdge *e, *ePrev;
  int firstTime = TRUE;

  /* Insert the new right-going edges in the dictionary */
  e = eFirst;
  do {
    assert( VertLeq( e->Org, e->Dst ));
    AddRegionBelow( tess, regUp, e->Sym );
    e = e->Onext;
  } while ( e != eLast );

  /* Walk *all* right-going edges from e->Org, in the dictionary order,
   * updating the winding numbers of each region, and re-linking the mesh
   * edges to match the dictionary ordering (if necessary).
   */
  if( eTopLeft == NULL ) {
    eTopLeft = RegionBelow( regUp )->eUp->Rprev;
  }
  regPrev = regUp;
  ePrev = eTopLeft;
  for( ;; ) {
    reg = RegionBelow( regPrev );
    e = reg->eUp->Sym;
    if( e->Org != ePrev->Org ) break;

    if( e->Onext != ePrev ) {
      /* Unlink e from its current position, and relink below ePrev */
      __gl_meshSplice( e->Oprev, e );
      __gl_meshSplice( ePrev->Oprev, e );
    }
    /* Compute the winding number and "inside" flag for the new regions */
    reg->windingNumber = regPrev->windingNumber - e->winding;
    reg->inside = IsWindingInside( tess, reg->windingNumber );

    /* Check for two outgoing edges with same slope -- process these
     * before any intersection tests (see example in __gl_computeInterior).
     */
    regPrev->dirty = TRUE;
    if( ! firstTime && CheckForRightSplice( tess, regPrev )) {
      AddWinding( e, ePrev );
      DeleteRegion( tess, regPrev );
      __gl_meshDelete( ePrev );
    }
    firstTime = FALSE;
    regPrev = reg;
    ePrev = e;
  }
  regPrev->dirty = TRUE;
  assert( regPrev->windingNumber - e->winding == reg->windingNumber );

  if( cleanUp ) {
    /* Check for intersections between newly adjacent edges. */
    WalkDirtyRegions( tess, regPrev );
  }
}


static void CallCombine( GLUtesselator *tess, GLUvertex *isect,
			 void *data[4], GLfloat weights[4], int needed )
{
  GLdouble coords[3];

  /* Copy coord data in case the callback changes it. */
  coords[0] = isect->coords[0];
  coords[1] = isect->coords[1];
  coords[2] = isect->coords[2];

  isect->data = NULL;
  CALL_COMBINE_OR_COMBINE_DATA( coords, data, weights, &isect->data );
  if( isect->data == NULL ) {
    if( ! needed ) {
      isect->data = data[0];
    } else if( ! tess->fatalError ) {
      /* The only way fatal error is when two edges are found to intersect,
       * but the user has not provided the callback necessary to handle
       * generated intersection points.
       */
      CALL_ERROR_OR_ERROR_DATA( GLU_TESS_NEED_COMBINE_CALLBACK );
      tess->fatalError = TRUE;
    }
  }
}

static void SpliceMergeVertices( GLUtesselator *tess, GLUhalfEdge *e1,
				 GLUhalfEdge *e2 )
/*
 * Two vertices with idential coordinates are combined into one.
 * e1->Org is kept, while e2->Org is discarded.
 */
{
  void *data[4] = { NULL, NULL, NULL, NULL };
  GLfloat weights[4] = { 0.5, 0.5, 0.0, 0.0 };

  data[0] = e1->Org->data;
  data[1] = e2->Org->data;
  CallCombine( tess, e1->Org, data, weights, FALSE );
  __gl_meshSplice( e1, e2 );
}

static void VertexWeights( GLUvertex *isect, GLUvertex *org, GLUvertex *dst,
                           GLfloat *weights )
/*
 * Find some weights which describe how the intersection vertex is
 * a linear combination of "org" and "dest".  Each of the two edges
 * which generated "isect" is allocated 50% of the weight; each edge
 * splits the weight between its org and dst according to the
 * relative distance to "isect".
 */
{
  GLdouble t1 = VertL1dist( org, isect );
  GLdouble t2 = VertL1dist( dst, isect );

  weights[0] = 0.5 * t2 / (t1 + t2);
  weights[1] = 0.5 * t1 / (t1 + t2);
  isect->coords[0] += weights[0]*org->coords[0] + weights[1]*dst->coords[0];
  isect->coords[1] += weights[0]*org->coords[1] + weights[1]*dst->coords[1];
  isect->coords[2] += weights[0]*org->coords[2] + weights[1]*dst->coords[2];
}


static void GetIntersectData( GLUtesselator *tess, GLUvertex *isect,
       GLUvertex *orgUp, GLUvertex *dstUp,
       GLUvertex *orgLo, GLUvertex *dstLo )
/*
 * We've computed a new intersection point, now we need a "data" pointer
 * from the user so that we can refer to this new vertex in the
 * rendering callbacks.
 */
{
  void *data[4];
  GLfloat weights[4];

  data[0] = orgUp->data;
  data[1] = dstUp->data;
  data[2] = orgLo->data;
  data[3] = dstLo->data;

  isect->coords[0] = isect->coords[1] = isect->coords[2] = 0;
  VertexWeights( isect, orgUp, dstUp, &weights[0] );
  VertexWeights( isect, orgLo, dstLo, &weights[2] );

  CallCombine( tess, isect, data, weights, TRUE );
}

static int CheckForRightSplice( GLUtesselator *tess, ActiveRegion *regUp )
/*
 * Check the upper and lower edge of "regUp", to make sure that the
 * eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
 * origin is leftmost).
 *
 * The main purpose is to splice right-going edges with the same
 * dest vertex and nearly identical slopes (ie. we can't distinguish
 * the slopes numerically).  However the splicing can also help us
 * to recover from numerical errors.  For example, suppose at one
 * point we checked eUp and eLo, and decided that eUp->Org is barely
 * above eLo.  Then later, we split eLo into two edges (eg. from
 * a splice operation like this one).  This can change the result of
 * our test so that now eUp->Org is incident to eLo, or barely below it.
 * We must correct this condition to maintain the dictionary invariants.
 *
 * One possibility is to check these edges for intersection again
 * (ie. CheckForIntersect).  This is what we do if possible.  However
 * CheckForIntersect requires that tess->event lies between eUp and eLo,
 * so that it has something to fall back on when the intersection
 * calculation gives us an unusable answer.  So, for those cases where
 * we can't check for intersection, this routine fixes the problem
 * by just splicing the offending vertex into the other edge.
 * This is a guaranteed solution, no matter how degenerate things get.
 * Basically this is a combinatorial solution to a numerical problem.
 */
{
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp = regUp->eUp;
  GLUhalfEdge *eLo = regLo->eUp;

  if( VertLeq( eUp->Org, eLo->Org )) {
    if( EdgeSign( eLo->Dst, eUp->Org, eLo->Org ) > 0 ) return FALSE;

    /* eUp->Org appears to be below eLo */
    if( ! VertEq( eUp->Org, eLo->Org )) {
      /* Splice eUp->Org into eLo */
      __gl_meshSplitEdge( eLo->Sym );
      __gl_meshSplice( eUp, eLo->Oprev );
      regUp->dirty = regLo->dirty = TRUE;

    } else if( eUp->Org != eLo->Org ) {
      /* merge the two vertices, discarding eUp->Org */
      pqDelete( tess->pq, eUp->Org->pqHandle );
      SpliceMergeVertices( tess, eLo->Oprev, eUp );
    }
  } else {
    if( EdgeSign( eUp->Dst, eLo->Org, eUp->Org ) < 0 ) return FALSE;

    /* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */
    RegionAbove(regUp)->dirty = regUp->dirty = TRUE;
    __gl_meshSplitEdge( eUp->Sym );
    __gl_meshSplice( eLo->Oprev, eUp );
  }
  return TRUE;
}

static int CheckForLeftSplice( GLUtesselator *tess, ActiveRegion *regUp )
/*
 * Check the upper and lower edge of "regUp", to make sure that the
 * eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
 * destination is rightmost).
 *
 * Theoretically, this should always be true.  However, splitting an edge
 * into two pieces can change the results of previous tests.  For example,
 * suppose at one point we checked eUp and eLo, and decided that eUp->Dst
 * is barely above eLo.  Then later, we split eLo into two edges (eg. from
 * a splice operation like this one).  This can change the result of
 * the test so that now eUp->Dst is incident to eLo, or barely below it.
 * We must correct this condition to maintain the dictionary invariants
 * (otherwise new edges might get inserted in the wrong place in the
 * dictionary, and bad stuff will happen).
 *
 * We fix the problem by just splicing the offending vertex into the
 * other edge.
 */
{
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp = regUp->eUp;
  GLUhalfEdge *eLo = regLo->eUp;
  GLUhalfEdge *e;

  assert( ! VertEq( eUp->Dst, eLo->Dst ));

  if( VertLeq( eUp->Dst, eLo->Dst )) {
    if( EdgeSign( eUp->Dst, eLo->Dst, eUp->Org ) < 0 ) return FALSE;

    /* eLo->Dst is above eUp, so splice eLo->Dst into eUp */
    RegionAbove(regUp)->dirty = regUp->dirty = TRUE;
    e = __gl_meshSplitEdge( eUp );
    __gl_meshSplice( eLo->Sym, e );
    e->Lface->inside = regUp->inside;
  } else {
    if( EdgeSign( eLo->Dst, eUp->Dst, eLo->Org ) > 0 ) return FALSE;

    /* eUp->Dst is below eLo, so splice eUp->Dst into eLo */
    regUp->dirty = regLo->dirty = TRUE;
    e = __gl_meshSplitEdge( eLo );
    __gl_meshSplice( eUp->Lnext, eLo->Sym );
    e->Rface->inside = regUp->inside;
  }
  return TRUE;
}


static int CheckForIntersect( GLUtesselator *tess, ActiveRegion *regUp )
/*
 * Check the upper and lower edges of the given region to see if
 * they intersect.  If so, create the intersection and add it
 * to the data structures.
 *
 * Returns TRUE if adding the new intersection resulted in a recursive
 * call to AddRightEdges(); in this case all "dirty" regions have been
 * checked for intersections, and possibly regUp has been deleted.
 */
{
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp = regUp->eUp;
  GLUhalfEdge *eLo = regLo->eUp;
  GLUvertex *orgUp = eUp->Org;
  GLUvertex *orgLo = eLo->Org;
  GLUvertex *dstUp = eUp->Dst;
  GLUvertex *dstLo = eLo->Dst;
  GLdouble tMinUp, tMaxLo;
  GLUvertex isect, *orgMin;
  GLUhalfEdge *e;

  assert( ! VertEq( dstLo, dstUp ));
  assert( EdgeSign( dstUp, tess->event, orgUp ) <= 0 );
  assert( EdgeSign( dstLo, tess->event, orgLo ) >= 0 );
  assert( orgUp != tess->event && orgLo != tess->event );
  assert( ! regUp->fixUpperEdge && ! regLo->fixUpperEdge );

  if( orgUp == orgLo ) return FALSE;	/* right endpoints are the same */

  tMinUp = MIN( orgUp->t, dstUp->t );
  tMaxLo = MAX( orgLo->t, dstLo->t );
  if( tMinUp > tMaxLo ) return FALSE;	/* t ranges do not overlap */

  if( VertLeq( orgUp, orgLo )) {
    if( EdgeSign( dstLo, orgUp, orgLo ) > 0 ) return FALSE;
  } else {
    if( EdgeSign( dstUp, orgLo, orgUp ) < 0 ) return FALSE;
  }

  /* At this point the edges intersect, at least marginally */
  DebugEvent( tess );

  __gl_edgeIntersect( dstUp, orgUp, dstLo, orgLo, &isect );
  /* The following properties are guaranteed: */
  assert( MIN( orgUp->t, dstUp->t ) <= isect.t );
  assert( isect.t <= MAX( orgLo->t, dstLo->t ));
  assert( MIN( dstLo->s, dstUp->s ) <= isect.s );
  assert( isect.s <= MAX( orgLo->s, orgUp->s ));

  if( VertLeq( &isect, tess->event )) {
    /* The intersection point lies slightly to the left of the sweep line,
     * so move it until it''s slightly to the right of the sweep line.
     * (If we had perfect numerical precision, this would never happen
     * in the first place).  The easiest and safest thing to do is
     * replace the intersection by tess->event.
     */
    isect.s = tess->event->s;
    isect.t = tess->event->t;
  }
  /* Similarly, if the computed intersection lies to the right of the
   * rightmost origin (which should rarely happen), it can cause
   * unbelievable inefficiency on sufficiently degenerate inputs.
   * (If you have the test program, try running test54.d with the
   * "X zoom" option turned on).
   */
  orgMin = VertLeq( orgUp, orgLo ) ? orgUp : orgLo;
  if( VertLeq( orgMin, &isect )) {
    isect.s = orgMin->s;
    isect.t = orgMin->t;
  }

  if( VertEq( &isect, orgUp ) || VertEq( &isect, orgLo )) {
    /* Easy case -- intersection at one of the right endpoints */
    (void) CheckForRightSplice( tess, regUp );
    return FALSE;
  }

  if(    (! VertEq( dstUp, tess->event )
	  && EdgeSign( dstUp, tess->event, &isect ) >= 0)
      || (! VertEq( dstLo, tess->event )
	  && EdgeSign( dstLo, tess->event, &isect ) <= 0 ))
  {
    /* Very unusual -- the new upper or lower edge would pass on the
     * wrong side of the sweep event, or through it.  This can happen
     * due to very small numerical errors in the intersection calculation.
     */
    if( dstLo == tess->event ) {
      /* Splice dstLo into eUp, and process the new region(s) */
      __gl_meshSplitEdge( eUp->Sym );
      __gl_meshSplice( eLo->Sym, eUp );
      regUp = TopLeftRegion( regUp );
      eUp = RegionBelow(regUp)->eUp;
      FinishLeftRegions( tess, RegionBelow(regUp), regLo );
      AddRightEdges( tess, regUp, eUp->Oprev, eUp, eUp, TRUE );
      return TRUE;
    }
    if( dstUp == tess->event ) {
      /* Splice dstUp into eLo, and process the new region(s) */
      __gl_meshSplitEdge( eLo->Sym );
      __gl_meshSplice( eUp->Lnext, eLo->Oprev );
      regLo = regUp;
      regUp = TopRightRegion( regUp );
      e = RegionBelow(regUp)->eUp->Rprev;
      regLo->eUp = eLo->Oprev;
      eLo = FinishLeftRegions( tess, regLo, NULL );
      AddRightEdges( tess, regUp, eLo->Onext, eUp->Rprev, e, TRUE );
      return TRUE;
    }
    /* Special case: called from ConnectRightVertex.  If either
     * edge passes on the wrong side of tess->event, split it
     * (and wait for ConnectRightVertex to splice it appropriately).
     */
    if( EdgeSign( dstUp, tess->event, &isect ) >= 0 ) {
      RegionAbove(regUp)->dirty = regUp->dirty = TRUE;
      __gl_meshSplitEdge( eUp->Sym );
      eUp->Org->s = tess->event->s;
      eUp->Org->t = tess->event->t;
    }
    if( EdgeSign( dstLo, tess->event, &isect ) <= 0 ) {
      regUp->dirty = regLo->dirty = TRUE;
      __gl_meshSplitEdge( eLo->Sym );
      eLo->Org->s = tess->event->s;
      eLo->Org->t = tess->event->t;
    }
    /* leave the rest for ConnectRightVertex */
    return FALSE;
  }

  /* General case -- split both edges, splice into new vertex.
   * When we do the splice operation, the order of the arguments is
   * arbitrary as far as correctness goes.  However, when the operation
   * creates a new face, the work done is proportional to the size of
   * the new face.  We expect the faces in the processed part of
   * the mesh (ie. eUp->Lface) to be smaller than the faces in the
   * unprocessed original contours (which will be eLo->Oprev->Lface).
   */
  __gl_meshSplitEdge( eUp->Sym );
  __gl_meshSplitEdge( eLo->Sym );
  __gl_meshSplice( eLo->Oprev, eUp );
  eUp->Org->s = isect.s;
  eUp->Org->t = isect.t;
  eUp->Org->pqHandle = pqInsert( tess->pq, eUp->Org );
  GetIntersectData( tess, eUp->Org, orgUp, dstUp, orgLo, dstLo );
  RegionAbove(regUp)->dirty = regUp->dirty = regLo->dirty = TRUE;
  return FALSE;
}

static void WalkDirtyRegions( GLUtesselator *tess, ActiveRegion *regUp )
/*
 * When the upper or lower edge of any region changes, the region is
 * marked "dirty".  This routine walks through all the dirty regions
 * and makes sure that the dictionary invariants are satisfied
 * (see the comments at the beginning of this file).  Of course
 * new dirty regions can be created as we make changes to restore
 * the invariants.
 */
{
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp, *eLo;

  for( ;; ) {
    /* Find the lowest dirty region (we walk from the bottom up). */
    while( regLo->dirty ) {
      regUp = regLo;
      regLo = RegionBelow(regLo);
    }
    if( ! regUp->dirty ) {
      regLo = regUp;
      regUp = RegionAbove( regUp );
      if( regUp == NULL || ! regUp->dirty ) {
	/* We've walked all the dirty regions */
	return;
      }
    }
    regUp->dirty = FALSE;
    eUp = regUp->eUp;
    eLo = regLo->eUp;

    if( eUp->Dst != eLo->Dst ) {
      /* Check that the edge ordering is obeyed at the Dst vertices. */
      if( CheckForLeftSplice( tess, regUp )) {

	/* If the upper or lower edge was marked fixUpperEdge, then
	 * we no longer need it (since these edges are needed only for
	 * vertices which otherwise have no right-going edges).
	 */
	if( regLo->fixUpperEdge ) {
	  DeleteRegion( tess, regLo );
	  __gl_meshDelete( eLo );
	  regLo = RegionBelow( regUp );
	  eLo = regLo->eUp;
	} else if( regUp->fixUpperEdge ) {
	  DeleteRegion( tess, regUp );
	  __gl_meshDelete( eUp );
	  regUp = RegionAbove( regLo );
	  eUp = regUp->eUp;
	}
      }
    }
    if( eUp->Org != eLo->Org ) {
      if(    eUp->Dst != eLo->Dst
	  && ! regUp->fixUpperEdge && ! regLo->fixUpperEdge
          && (eUp->Dst == tess->event || eLo->Dst == tess->event) )
      {
	/* When all else fails in CheckForIntersect(), it uses tess->event
	 * as the intersection location.  To make this possible, it requires
	 * that tess->event lie between the upper and lower edges, and also
	 * that neither of these is marked fixUpperEdge (since in the worst
	 * case it might splice one of these edges into tess->event, and
	 * violate the invariant that fixable edges are the only right-going
	 * edge from their associated vertex).
         */
	if( CheckForIntersect( tess, regUp )) {
	  /* WalkDirtyRegions() was called recursively; we're done */
	  return;
	}
      } else {
	/* Even though we can't use CheckForIntersect(), the Org vertices
	 * may violate the dictionary edge ordering.  Check and correct this.
	 */
	(void) CheckForRightSplice( tess, regUp );
      }
    }
    if( eUp->Org == eLo->Org && eUp->Dst == eLo->Dst ) {
      /* A degenerate loop consisting of only two edges -- delete it. */
      AddWinding( eLo, eUp );
      DeleteRegion( tess, regUp );
      __gl_meshDelete( eUp );
      regUp = RegionAbove( regLo );
    }
  }
}


static void ConnectRightVertex( GLUtesselator *tess, ActiveRegion *regUp,
			        GLUhalfEdge *eBottomLeft )
/*
 * Purpose: connect a "right" vertex vEvent (one where all edges go left)
 * to the unprocessed portion of the mesh.  Since there are no right-going
 * edges, two regions (one above vEvent and one below) are being merged
 * into one.  "regUp" is the upper of these two regions.
 *
 * There are two reasons for doing this (adding a right-going edge):
 *  - if the two regions being merged are "inside", we must add an edge
 *    to keep them separated (the combined region would not be monotone).
 *  - in any case, we must leave some record of vEvent in the dictionary,
 *    so that we can merge vEvent with features that we have not seen yet.
 *    For example, maybe there is a vertical edge which passes just to
 *    the right of vEvent; we would like to splice vEvent into this edge.
 *
 * However, we don't want to connect vEvent to just any vertex.  We don''t
 * want the new edge to cross any other edges; otherwise we will create
 * intersection vertices even when the input data had no self-intersections.
 * (This is a bad thing; if the user's input data has no intersections,
 * we don't want to generate any false intersections ourselves.)
 *
 * Our eventual goal is to connect vEvent to the leftmost unprocessed
 * vertex of the combined region (the union of regUp and regLo).
 * But because of unseen vertices with all right-going edges, and also
 * new vertices which may be created by edge intersections, we don''t
 * know where that leftmost unprocessed vertex is.  In the meantime, we
 * connect vEvent to the closest vertex of either chain, and mark the region
 * as "fixUpperEdge".  This flag says to delete and reconnect this edge
 * to the next processed vertex on the boundary of the combined region.
 * Quite possibly the vertex we connected to will turn out to be the
 * closest one, in which case we won''t need to make any changes.
 */
{
  GLUhalfEdge *eNew;
  GLUhalfEdge *eTopLeft = eBottomLeft->Onext;
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp = regUp->eUp;
  GLUhalfEdge *eLo = regLo->eUp;
  int degenerate = FALSE;

  if( eUp->Dst != eLo->Dst ) {
    (void) CheckForIntersect( tess, regUp );
  }

  /* Possible new degeneracies: upper or lower edge of regUp may pass
   * through vEvent, or may coincide with new intersection vertex
   */
  if( VertEq( eUp->Org, tess->event )) {
    __gl_meshSplice( eTopLeft->Oprev, eUp );
    regUp = TopLeftRegion( regUp );
    eTopLeft = RegionBelow( regUp )->eUp;
    FinishLeftRegions( tess, RegionBelow(regUp), regLo );
    degenerate = TRUE;
  }
  if( VertEq( eLo->Org, tess->event )) {
    __gl_meshSplice( eBottomLeft, eLo->Oprev );
    eBottomLeft = FinishLeftRegions( tess, regLo, NULL );
    degenerate = TRUE;
  }
  if( degenerate ) {
    AddRightEdges( tess, regUp, eBottomLeft->Onext, eTopLeft, eTopLeft, TRUE );
    return;
  }

  /* Non-degenerate situation -- need to add a temporary, fixable edge.
   * Connect to the closer of eLo->Org, eUp->Org.
   */
  if( VertLeq( eLo->Org, eUp->Org )) {
    eNew = eLo->Oprev;
  } else {
    eNew = eUp;
  }
  eNew = __gl_meshConnect( eBottomLeft->Lprev, eNew );

  /* Prevent cleanup, otherwise eNew might disappear before we've even
   * had a chance to mark it as a temporary edge.
   */
  AddRightEdges( tess, regUp, eNew, eNew->Onext, eNew->Onext, FALSE );
  eNew->Sym->activeRegion->fixUpperEdge = TRUE;
  WalkDirtyRegions( tess, regUp );
}

/* Because vertices at exactly the same location are merged together
 * before we process the sweep event, some degenerate cases can't occur.
 * However if someone eventually makes the modifications required to
 * merge features which are close together, the cases below marked
 * TOLERANCE_NONZERO will be useful.  They were debugged before the
 * code to merge identical vertices in the main loop was added.
 */
#define TOLERANCE_NONZERO	FALSE

static void ConnectLeftDegenerate( GLUtesselator *tess,
				   ActiveRegion *regUp, GLUvertex *vEvent )
/*
 * The event vertex lies exacty on an already-processed edge or vertex.
 * Adding the new vertex involves splicing it into the already-processed
 * part of the mesh.
 */
{
  GLUhalfEdge *e, *eTopLeft, *eTopRight, *eLast;
  ActiveRegion *reg;

  e = regUp->eUp;
  if( VertEq( e->Org, vEvent )) {
    /* e->Org is an unprocessed vertex - just combine them, and wait
     * for e->Org to be pulled from the queue
     */
    assert( TOLERANCE_NONZERO );
    SpliceMergeVertices( tess, e, vEvent->anEdge );
    return;
  }
  
  if( ! VertEq( e->Dst, vEvent )) {
    /* General case -- splice vEvent into edge e which passes through it */
    __gl_meshSplitEdge( e->Sym );
    if( regUp->fixUpperEdge ) {
      /* This edge was fixable -- delete unused portion of original edge */
      __gl_meshDelete( e->Onext );
      regUp->fixUpperEdge = FALSE;
    }
    __gl_meshSplice( vEvent->anEdge, e );
    SweepEvent( tess, vEvent );	/* recurse */
    return;
  }

  /* vEvent coincides with e->Dst, which has already been processed.
   * Splice in the additional right-going edges.
   */
  assert( TOLERANCE_NONZERO );
  regUp = TopRightRegion( regUp );
  reg = RegionBelow( regUp );
  eTopRight = reg->eUp->Sym;
  eTopLeft = eLast = eTopRight->Onext;
  if( reg->fixUpperEdge ) {
    /* Here e->Dst has only a single fixable edge going right.
     * We can delete it since now we have some real right-going edges.
     */
    assert( eTopLeft != eTopRight );   /* there are some left edges too */
    DeleteRegion( tess, reg );
    __gl_meshDelete( eTopRight );
    eTopRight = eTopLeft->Oprev;
  }
  __gl_meshSplice( vEvent->anEdge, eTopRight );
  if( ! EdgeGoesLeft( eTopLeft )) {
    /* e->Dst had no left-going edges -- indicate this to AddRightEdges() */
    eTopLeft = NULL;
  }
  AddRightEdges( tess, regUp, eTopRight->Onext, eLast, eTopLeft, TRUE );
}


static void ConnectLeftVertex( GLUtesselator *tess, GLUvertex *vEvent )
/*
 * Purpose: connect a "left" vertex (one where both edges go right)
 * to the processed portion of the mesh.  Let R be the active region
 * containing vEvent, and let U and L be the upper and lower edge
 * chains of R.  There are two possibilities:
 *
 * - the normal case: split R into two regions, by connecting vEvent to
 *   the rightmost vertex of U or L lying to the left of the sweep line
 *
 * - the degenerate case: if vEvent is close enough to U or L, we
 *   merge vEvent into that edge chain.  The subcases are:
 *	- merging with the rightmost vertex of U or L
 *	- merging with the active edge of U or L
 *	- merging with an already-processed portion of U or L
 */
{
  ActiveRegion *regUp, *regLo, *reg;
  GLUhalfEdge *eUp, *eLo, *eNew;
  ActiveRegion tmp;

  /* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */

  /* Get a pointer to the active region containing vEvent */
  tmp.eUp = vEvent->anEdge->Sym;
  regUp = (ActiveRegion *)dictKey( dictSearch( tess->dict, &tmp ));
  regLo = RegionBelow( regUp );
  eUp = regUp->eUp;
  eLo = regLo->eUp;

  /* Try merging with U or L first */
  if( EdgeSign( eUp->Dst, vEvent, eUp->Org ) == 0 ) {
    ConnectLeftDegenerate( tess, regUp, vEvent );
    return;
  }

  /* Connect vEvent to rightmost processed vertex of either chain.
   * e->Dst is the vertex that we will connect to vEvent.
   */
  reg = VertLeq( eLo->Dst, eUp->Dst ) ? regUp : regLo;

  if( regUp->inside || reg->fixUpperEdge) {
    if( reg == regUp ) {
      eNew = __gl_meshConnect( vEvent->anEdge->Sym, eUp->Lnext );
    } else {
      eNew = __gl_meshConnect( eLo->Dnext, vEvent->anEdge )->Sym;
    }
    if( reg->fixUpperEdge ) {
      FixUpperEdge( reg, eNew );
    } else {
      ComputeWinding( tess, AddRegionBelow( tess, regUp, eNew ));
    }
    SweepEvent( tess, vEvent );
  } else {
    /* The new vertex is in a region which does not belong to the polygon.
     * We don''t need to connect this vertex to the rest of the mesh.
     */
    AddRightEdges( tess, regUp, vEvent->anEdge, vEvent->anEdge, NULL, TRUE );
  }
}


static void SweepEvent( GLUtesselator *tess, GLUvertex *vEvent )
/*
 * Does everything necessary when the sweep line crosses a vertex.
 * Updates the mesh and the edge dictionary.
 */
{
  ActiveRegion *regUp, *reg;
  GLUhalfEdge *e, *eTopLeft, *eBottomLeft;

  tess->event = vEvent;		/* for access in EdgeLeq() */
  DebugEvent( tess );
  
  /* Check if this vertex is the right endpoint of an edge that is
   * already in the dictionary.  In this case we don't need to waste
   * time searching for the location to insert new edges.
   */
  e = vEvent->anEdge;
  while( e->activeRegion == NULL ) {
    e = e->Onext;
    if( e == vEvent->anEdge ) {
      /* All edges go right -- not incident to any processed edges */
      ConnectLeftVertex( tess, vEvent );
      return;
    }
  }

  /* Processing consists of two phases: first we "finish" all the
   * active regions where both the upper and lower edges terminate
   * at vEvent (ie. vEvent is closing off these regions).
   * We mark these faces "inside" or "outside" the polygon according
   * to their winding number, and delete the edges from the dictionary.
   * This takes care of all the left-going edges from vEvent.
   */
  regUp = TopLeftRegion( e->activeRegion );
  reg = RegionBelow( regUp );
  eTopLeft = reg->eUp;
  eBottomLeft = FinishLeftRegions( tess, reg, NULL );

  /* Next we process all the right-going edges from vEvent.  This
   * involves adding the edges to the dictionary, and creating the
   * associated "active regions" which record information about the
   * regions between adjacent dictionary edges.
   */
  if( eBottomLeft->Onext == eTopLeft ) {
    /* No right-going edges -- add a temporary "fixable" edge */
    ConnectRightVertex( tess, regUp, eBottomLeft );
  } else {
    AddRightEdges( tess, regUp, eBottomLeft->Onext, eTopLeft, eTopLeft, TRUE );
  }
}


/* Make the sentinel coordinates big enough that they will never be
 * merged with real input features.  (Even with the largest possible
 * input contour and the maximum tolerance of 1.0, no merging will be
 * done with coordinates larger than 3 * GLU_TESS_MAX_COORD).
 */
#define SENTINEL_COORD	(4 * GLU_TESS_MAX_COORD)

static void AddSentinel( GLUtesselator *tess, GLdouble t )
/*
 * We add two sentinel edges above and below all other edges,
 * to avoid special cases at the top and bottom.
 */
{
  ActiveRegion *reg = (ActiveRegion *)memAlloc( sizeof( ActiveRegion ));
  GLUhalfEdge *e = __gl_meshMakeEdge( tess->mesh );

  e->Org->s = SENTINEL_COORD;
  e->Org->t = t;
  e->Dst->s = -SENTINEL_COORD;
  e->Dst->t = t;
  tess->event = e->Dst;		/* initialize it */

  reg->eUp = e;
  reg->windingNumber = 0;
  reg->inside = FALSE;
  reg->fixUpperEdge = FALSE;
  reg->sentinel = TRUE;
  reg->dirty = FALSE;
  reg->nodeUp = dictInsert( tess->dict, reg );
}


static void InitEdgeDict( GLUtesselator *tess )
/*
 * We maintain an ordering of edge intersections with the sweep line.
 * This order is maintained in a dynamic dictionary.
 */
{
  tess->dict = dictNewDict( tess, (int (*)(void *, DictKey, DictKey)) EdgeLeq );
  AddSentinel( tess, -SENTINEL_COORD );
  AddSentinel( tess, SENTINEL_COORD );
}


static void DoneEdgeDict( GLUtesselator *tess )
{
  ActiveRegion *reg;
  int fixedEdges = 0;

  while( (reg = (ActiveRegion *)dictKey( dictMin( tess->dict ))) != NULL ) {
    /*
     * At the end of all processing, the dictionary should contain
     * only the two sentinel edges, plus at most one "fixable" edge
     * created by ConnectRightVertex().
     */
    if( ! reg->sentinel ) {
      assert( reg->fixUpperEdge );
      assert( ++fixedEdges == 1 );
    }
    assert( reg->windingNumber == 0 );
    DeleteRegion( tess, reg );
/*    __gl_meshDelete( reg->eUp );*/
  }
  dictDeleteDict( tess->dict );
}


static void RemoveDegenerateEdges( GLUtesselator *tess )
/*
 * Remove zero-length edges, and contours with fewer than 3 vertices.
 */
{
  GLUhalfEdge *e, *eNext, *eLnext;
  GLUhalfEdge *eHead = &tess->mesh->eHead;

  /*LINTED*/
  for( e = eHead->next; e != eHead; e = eNext ) {
    eNext = e->next;
    eLnext = e->Lnext;
    
    if( VertEq( e->Org, e->Dst ) && e->Lnext->Lnext != e ) {
      /* Zero-length edge, contour has at least 3 edges */
      
      SpliceMergeVertices( tess, eLnext, e );	/* deletes e->Org */
      __gl_meshDelete( e );			/* e is a self-loop */
      e = eLnext;
      eLnext = e->Lnext;
    }
    if( eLnext->Lnext == e ) {
      /* Degenerate contour (one or two edges) */
      
      if( eLnext != e ) {
	if( eLnext == eNext || eLnext == eNext->Sym ) { eNext = eNext->next; }
	__gl_meshDelete( eLnext );
      }
      if( e == eNext || e == eNext->Sym ) { eNext = eNext->next; }
      __gl_meshDelete( e );
    }
  }
}

static void InitPriorityQ( GLUtesselator *tess )
/*
 * Insert all vertices into the priority queue which determines the
 * order in which vertices cross the sweep line.
 */
{
  PriorityQ *pq;
  GLUvertex *v, *vHead;

  pq = tess->pq = pqNewPriorityQ( (int (*)(PQkey, PQkey)) __gl_vertLeq );

  vHead = &tess->mesh->vHead;
  for( v = vHead->next; v != vHead; v = v->next ) {
    v->pqHandle = pqInsert( pq, v );
  }
  pqInit( pq );
}


static void DonePriorityQ( GLUtesselator *tess )
{
  pqDeletePriorityQ( tess->pq );
}


static void RemoveDegenerateFaces( GLUmesh *mesh )
/*
 * Delete any degenerate faces with only two edges.  WalkDirtyRegions()
 * will catch almost all of these, but it won't catch degenerate faces
 * produced by splice operations on already-processed edges.
 * The two places this can happen are in FinishLeftRegions(), when
 * we splice in a "temporary" edge produced by ConnectRightVertex(),
 * and in CheckForLeftSplice(), where we splice already-processed
 * edges to ensure that our dictionary invariants are not violated
 * by numerical errors.
 *
 * In both these cases it is *very* dangerous to delete the offending
 * edge at the time, since one of the routines further up the stack
 * will sometimes be keeping a pointer to that edge.
 */
{
  GLUface *f, *fNext;
  GLUhalfEdge *e;

  /*LINTED*/
  for( f = mesh->fHead.next; f != &mesh->fHead; f = fNext ) {
    fNext = f->next;
    e = f->anEdge;
    assert( e->Lnext != e );

    if( e->Lnext->Lnext == e ) {
      /* A face with only two edges */
      AddWinding( e->Onext, e );
      __gl_meshDelete( e );
    }
  }
}

void __gl_computeInterior( GLUtesselator *tess )
/*
 * __gl_computeInterior( tess ) computes the planar arrangement specified
 * by the given contours, and further subdivides this arrangement
 * into regions.  Each region is marked "inside" if it belongs
 * to the polygon, according to the rule given by tess->windingRule.
 * Each interior region is guaranteed be monotone.
 */
{
  GLUvertex *v, *vNext;

  tess->fatalError = FALSE;

  /* Each vertex defines an event for our sweep line.  Start by inserting
   * all the vertices in a priority queue.  Events are processed in
   * lexicographic order, ie.
   *
   *	e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
   */
  RemoveDegenerateEdges( tess );
  InitPriorityQ( tess );
  InitEdgeDict( tess );

  while( (v = (GLUvertex *)pqExtractMin( tess->pq )) != NULL ) {
    for( ;; ) {
      vNext = (GLUvertex *)pqMinimum( tess->pq );
      if( vNext == NULL || ! VertEq( vNext, v )) break;
      
      /* Merge together all vertices at exactly the same location.
       * This is more efficient than processing them one at a time,
       * simplifies the code (see ConnectLeftDegenerate), and is also
       * important for correct handling of certain degenerate cases.
       * For example, suppose there are two identical edges A and B
       * that belong to different contours (so without this code they would
       * be processed by separate sweep events).  Suppose another edge C
       * crosses A and B from above.  When A is processed, we split it
       * at its intersection point with C.  However this also splits C,
       * so when we insert B we may compute a slightly different
       * intersection point.  This might leave two edges with a small
       * gap between them.  This kind of error is especially obvious
       * when using boundary extraction (GLU_TESS_BOUNDARY_ONLY).
       */
      vNext = (GLUvertex *)pqExtractMin( tess->pq );
      SpliceMergeVertices( tess, v->anEdge, vNext->anEdge );
    }
    SweepEvent( tess, v );
  }

  /* Set tess->event for debugging purposes */
  tess->event = ((ActiveRegion *) dictKey( dictMin( tess->dict )))->eUp->Org;
  DebugEvent( tess );
  DoneEdgeDict( tess );
  DonePriorityQ( tess );

  RemoveDegenerateFaces( tess->mesh );
  __gl_meshCheckMesh( tess->mesh );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\stack.h ===
#ifndef __stack_h_
#define __stack_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/


typedef struct Stack Stack;

struct Stack {
  int	size;
  int	max;
  void	**data;
};

Stack	*__gl_StackNew( void );
void	__gl_StackGrow( Stack *s );
void	__gl_StackFree( Stack *s );

#define StackNew()	__gl_StackNew()
#define StackFree(s)	__gl_StackFree( s )

#define StackSize(s)	((s)->size)
#define StackPush(s,d)	{ if ((s)->size >= (s)->max) __gl_StackGrow( s ); \
			    (s)->data[((s)->size)++] = (d); }
#define StackPop(s)	((s)->data[--((s)->size)])
#define StackTop(s)	((s)->data[(s)->size - 1])
#define StackNth(s,n)	((s)->data[(s)->size - (n) - 1])

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\sweep.h ===
#ifndef __sweep_h_
#define __sweep_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "mesh.h"

/* __gl_computeInterior( tess ) computes the planar arrangement specified
 * by the given contours, and further subdivides this arrangement
 * into regions.  Each region is marked "inside" if it belongs
 * to the polygon, according to the rule given by tess->windingRule.
 * Each interior region is guaranteed be monotone.
 */
void __gl_computeInterior( GLUtesselator *tess );


/* The following is here *only* for access by debugging routines */

#include "dict.h"

/* For each pair of adjacent edges crossing the sweep line, there is
 * an ActiveRegion to represent the region between them.  The active
 * regions are kept in sorted order in a dynamic dictionary.  As the
 * sweep line crosses each vertex, we update the affected regions.
 */

struct ActiveRegion {
  GLUhalfEdge	*eUp;		/* upper edge, directed right to left */
  DictNode	*nodeUp;	/* dictionary node corresponding to eUp */
  int		windingNumber;	/* used to determine which regions are
                                 * inside the polygon */
  GLboolean	inside;		/* is this region inside the polygon? */
  GLboolean	sentinel;	/* marks fake edges at t = +/-infinity */
  GLboolean	dirty;		/* marks regions where the upper or lower
                                 * edge has changed, but we haven't checked
                                 * whether they intersect yet */
  GLboolean	fixUpperEdge;	/* marks temporary edges introduced when
                                 * we process a "right vertex" (one without
                                 * any edges leaving to the right) */
};

#define RegionBelow(r)	((ActiveRegion *) dictKey(dictPred((r)->nodeUp)))
#define RegionAbove(r)	((ActiveRegion *) dictKey(dictSucc((r)->nodeUp)))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\tesselat.h ===
#ifndef __tesselator_h_
#define __tesselator_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

/* General polygon tesselation.
 *
 * Tesselates polygons consisting of one or more contours, which can
 * be concave, self-intersecting, or degenerate.
 */

#include <stddef.h>
#ifdef NT
#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#else
#include "GL/gl.h"
#endif

/* GLU_TESS_MAX_COORD must be small enough that we can multiply
 * and add coordinates without overflow.
 */

#ifdef GLU_TESS_API_FLOAT
typedef float  GLUcoord;
#define GLU_TESS_MAX_COORD		1.0e18
#define GLU_TESS_DEFAULT_TOLERANCE	0.0

#else
typedef GLdouble GLUcoord;
#define GLU_TESS_MAX_COORD		1.0e150
#define GLU_TESS_DEFAULT_TOLERANCE	0.0

#endif

// mesh stuff that is not included in glu.h:
typedef struct GLUmesh GLUmesh;
// void    gluTessDeleteMesh(  GLUmesh *mesh );
// #define GLU_TESS_MESH		100106	/* void (*)(GLUmesh *mesh) */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\tess.h ===
#ifndef __tess_h_
#define __tess_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include <glos.h>
#endif
#include <GL/glu.h>
#include "mesh.h"
#include "dict.h"
#ifdef NT
#include "priority.h"
#else
#include "priorityq.h"
#endif

/* The begin/end calls must be properly nested.  We keep track of
 * the current state to enforce the ordering.
 */
enum TessState { T_DORMANT, T_IN_POLYGON, T_IN_CONTOUR };

/* We cache vertex data for single-contour polygons so that we can
 * try a quick-and-dirty decomposition first.
 */
#define TESS_MAX_CACHE	100

typedef struct CachedVertex {
  GLdouble	coords[3];
  void		*data;
} CachedVertex;

struct GLUtesselator {

  /*** state needed for collecting the input data ***/

  GLenum	state;		/* what begin/end calls have we seen? */

  GLUhalfEdge	*lastEdge;	/* lastEdge->Org is the most recent vertex */
  GLUmesh	*mesh;		/* stores the input contours, and eventually
                                   the tesselation itself */

  void		(*callError)( GLenum errno );

  /*** state needed for projecting onto the sweep plane ***/

  GLdouble	normal[3];	/* user-specified normal (if provided) */
  GLdouble	sUnit[3];	/* unit vector in s-direction (debugging) */
  GLdouble	tUnit[3];	/* unit vector in t-direction (debugging) */

  /*** state needed for the line sweep ***/

  GLdouble	relTolerance;	/* tolerance for merging features */
  GLenum	windingRule;	/* rule for determining polygon interior */
  GLboolean	fatalError;	/* fatal error: needed combine callback */

  Dict		*dict;		/* edge dictionary for sweep line */
  PriorityQ	*pq;		/* priority queue of vertex events */
  GLUvertex	*event;		/* current sweep event being processed */

  void		(*callCombine)( GLdouble coords[3], void *data[4],
			        GLfloat weight[4], void **outData );

  /*** state needed for rendering callbacks (see render.c) ***/

  GLboolean	flagBoundary;	/* mark boundary edges (use EdgeFlag) */
  GLboolean	boundaryOnly;	/* Extract contours, not triangles */
  GLUface	*lonelyTriList;
    /* list of triangles which could not be rendered as strips or fans */

  void		(*callBegin)( GLenum type );
  void		(*callEdgeFlag)( GLboolean boundaryEdge );
  void		(*callVertex)( void *data );
  void		(*callEnd)( void );
  void      (*callMesh)( GLUmesh *mesh );  // not part of NT api

  /*** state needed to cache single-contour polygons for renderCache() */

  GLboolean	emptyCache;		/* empty cache on next vertex() call */
  int		cacheCount;		/* number of cached vertices */
  CachedVertex	cache[TESS_MAX_CACHE];	/* the vertex data */

  /*** rendering callbacks that also pass polygon data  ***/ 
  void		(*callBeginData)( GLenum type, void *polygonData );
  void		(*callEdgeFlagData)( GLboolean boundaryEdge, 
				     void *polygonData );
  void		(*callVertexData)( void *data, void *polygonData );
  void		(*callEndData)( void *polygonData );
  void		(*callErrorData)( GLenum errno, void *polygonData );
  void		(*callCombineData)( GLdouble coords[3], void *data[4],
				    GLfloat weight[4], void **outData,
				    void *polygonData );

  void *polygonData;		/* client data for current polygon */
};

void __gl_noBeginData( GLenum type, void *polygonData );
void __gl_noEdgeFlagData( GLboolean boundaryEdge, void *polygonData );
void __gl_noVertexData( void *data, void *polygonData );
void __gl_noEndData( void *polygonData );
void __gl_noErrorData( GLenum errno, void *polygonData );
void __gl_noCombineData( GLdouble coords[3], void *data[4],
			 GLfloat weight[4], void **outData,
			 void *polygonData );

#define CALL_BEGIN_OR_BEGIN_DATA(a) \
   if (tess->callBeginData != &__gl_noBeginData) \
      (*tess->callBeginData)((a),tess->polygonData); \
   else (*tess->callBegin)((a));

#define CALL_VERTEX_OR_VERTEX_DATA(a) \
   if (tess->callVertexData != &__gl_noVertexData) \
      (*tess->callVertexData)((a),tess->polygonData); \
   else (*tess->callVertex)((a));

#define CALL_EDGE_FLAG_OR_EDGE_FLAG_DATA(a) \
   if (tess->callEdgeFlagData != &__gl_noEdgeFlagData) \
      (*tess->callEdgeFlagData)((a),tess->polygonData); \
   else (*tess->callEdgeFlag)((a));

#define CALL_END_OR_END_DATA() \
   if (tess->callEndData != &__gl_noEndData) \
      (*tess->callEndData)(tess->polygonData); \
   else (*tess->callEnd)();

#define CALL_COMBINE_OR_COMBINE_DATA(a,b,c,d) \
   if (tess->callCombineData != &__gl_noCombineData) \
      (*tess->callCombineData)((a),(b),(c),(d),tess->polygonData); \
   else (*tess->callCombine)((a),(b),(c),(d));

#define CALL_ERROR_OR_ERROR_DATA(a) \
   if (tess->callErrorData != &__gl_noErrorData) \
      (*tess->callErrorData)((a),tess->polygonData); \
   else (*tess->callError)((a));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\tessmono.h ===
#ifndef __tessmono_h_
#define __tessmono_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/


/* __gl_meshTesselateMonoRegion( face ) tesselates a monotone region
 * (what else would it do??)  The region must consist of a single
 * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
 * case means that any vertical line intersects the interior of the
 * region in a single interval.  
 *
 * Tesselation consists of adding interior edges (actually pairs of
 * half-edges), to split the region into non-overlapping triangles.
 *
 * __gl_meshTesselateInterior( mesh ) tesselates each region of
 * the mesh which is marked "inside" the polygon.  Each such region
 * must be monotone.
 *
 * __gl_meshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
 * which are not marked "inside" the polygon.  Since further mesh operations
 * on NULL faces are not allowed, the main purpose is to clean up the
 * mesh so that exterior loops are not represented in the data structure.
 *
 * __gl_meshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
 * winding numbers on all edges so that regions marked "inside" the
 * polygon have a winding number of "value", and regions outside
 * have a winding number of 0.
 *
 * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
 * separate an interior region from an exterior one.
 */

void __gl_meshTesselateMonoRegion( GLUface *face );
void __gl_meshTesselateInterior( GLUmesh *mesh );
void __gl_meshDiscardExterior( GLUmesh *mesh );
void __gl_meshSetWindingNumber( GLUmesh *mesh, int value,
			        GLboolean keepOnlyBoundary );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\tessmono.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "geom.h"
#include "mesh.h"
#include "tessmono.h"
#include <assert.h>

#define AddWinding(eDst,eSrc)	(eDst->winding += eSrc->winding, \
				 eDst->Sym->winding += eSrc->Sym->winding)

/* __gl_meshTesselateMonoRegion( face ) tesselates a monotone region
 * (what else would it do??)  The region must consist of a single
 * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
 * case means that any vertical line intersects the interior of the
 * region in a single interval.  
 *
 * Tesselation consists of adding interior edges (actually pairs of
 * half-edges), to split the region into non-overlapping triangles.
 *
 * The basic idea is explained in Preparata and Shamos (which I don''t
 * have handy right now), although their implementation is more
 * complicated than this one.  The are two edge chains, an upper chain
 * and a lower chain.  We process all vertices from both chains in order,
 * from right to left.
 *
 * The algorithm ensures that the following invariant holds after each
 * vertex is processed: the untesselated region consists of two
 * chains, where one chain (say the upper) is a single edge, and
 * the other chain is concave.  The left vertex of the single edge
 * is always to the left of all vertices in the concave chain.
 *
 * Each step consists of adding the rightmost unprocessed vertex to one
 * of the two chains, and forming a fan of triangles from the rightmost
 * of two chain endpoints.  Determining whether we can add each triangle
 * to the fan is a simple orientation test.  By making the fan as large
 * as possible, we restore the invariant (check it yourself).
 */
void __gl_meshTesselateMonoRegion( GLUface *face )
{
  GLUhalfEdge *up, *lo;

  /* All edges are oriented CCW around the boundary of the region.
   * First, find the half-edge whose origin vertex is rightmost.
   * Since the sweep goes from left to right, face->anEdge should
   * be close to the edge we want.
   */
  up = face->anEdge;
  assert( up->Lnext != up && up->Lnext->Lnext != up );

  for( ; VertLeq( up->Dst, up->Org ); up = up->Lprev )
    ;
  for( ; VertLeq( up->Org, up->Dst ); up = up->Lnext )
    ;
  lo = up->Lprev;

  while( up->Lnext != lo ) {
    if( VertLeq( up->Dst, lo->Org )) {
      /* up->Dst is on the left.  It is safe to form triangles from lo->Org.
       * The EdgeGoesLeft test guarantees progress even when some triangles
       * are CW, given that the upper and lower chains are truly monotone.
       */
      while( lo->Lnext != up && (EdgeGoesLeft( lo->Lnext )
	     || EdgeSign( lo->Org, lo->Dst, lo->Lnext->Dst ) <= 0 )) {
	lo = __gl_meshConnect( lo->Lnext, lo )->Sym;
      }
      lo = lo->Lprev;
    } else {
      /* lo->Org is on the left.  We can make CCW triangles from up->Dst. */
      while( lo->Lnext != up && (E