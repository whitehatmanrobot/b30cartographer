       }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cy = pcg->cy;
              if (cy != 0)
              {
                y       = pcg->ptlOrigin.y + yGlyph;
                x       = pcg->ptlOrigin.x + xGlyph;
                xRight  = pcg->cx + x;
                yBottom = pcg->cy + y;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   < xRight) &&
                    (prclClip->top    < yBottom))
                {
                  // Lazily set the hardware clipping:

                  if (!bClippingSet)
                  {
                    bClippingSet = TRUE;
                    vSetClipping(ppdev, prclClip);
                  }

                  M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);

                  M32_OW(pjMmBase, CUR_X,        xOffset + x);
                  M32_OW(pjMmBase, DEST_X_START, xOffset + x);
                  M32_OW(pjMmBase, DEST_X_END,   xOffset + xRight);
                  M32_OW(pjMmBase, CUR_Y,        yOffset + y);
                  M32_OW(pjMmBase, DEST_Y_END,   yOffset + yBottom);

                  M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);

                  pw = (WORD*) &pcg->ad[0];
                  cw = pcg->cw;

                  do {
                      M32_OW_DIRECT(pjMmBase, PIX_TRANS, *pw);
                  } while (pw++, --cw != 0);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    vResetClipping(ppdev);

    return(bRet);
}

VOID vM32DataPortOutB(PDEV *ppdev, PBYTE pb, UINT count)
{
    BYTE *pjMmBase = ppdev->pjMmBase;
    UINT i;

    for (i=0; i < count; i++)
        {
        if (i % 8 == 0)
            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);

        M32_OB(pjMmBase, PIX_TRANS + 1, *((PUCHAR)pb)++);
        }
}

 /******************************Public*Routine******************************\
* BOOL bM32GeneralText
*
\**************************************************************************/

BOOL bM32GeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjMmBase;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBiasL = 0;
    LONG        xBiasR = 0;
    LONG        yBiasT = 0;
    LONG        cy = 0;
    LONG        cx = 0;
    BYTE*       pjGlyph;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    RECTL       NoClip;
    LONG        x;
    LONG        y;

    pjMmBase = ppdev->pjMmBase;

    /* Define Default Clipping area to be full video ram */
    NoClip.top    = 0;
    NoClip.left   = 0;
    NoClip.right  = ppdev->cxScreen;
    NoClip.bottom = ppdev->cyScreen;

    if (pco == NULL)
        iDComplexity = DC_TRIVIAL;
    else
        iDComplexity = pco->iDComplexity;

    do {

      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &NoClip;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;

        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {

          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            vSetClipping(ppdev, prclClip);
            //ppdev->lRightScissor = rclRealClip.right;  ???

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph  = pgb->sizlBitmap.cx;
              cyGlyph  = pgb->sizlBitmap.cy;
              pjGlyph = (BYTE*) pgb->aj;


              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);

                x = ppdev->xOffset + ptlOrigin.x;
                M32_OW(pjMmBase, CUR_X, LOWORD(x));
                M32_OW(pjMmBase, DEST_X_START, LOWORD(x));
                M32_OW(pjMmBase, DEST_X_END, LOWORD(x) + ROUND8(cxGlyph) );
                M32_OW(pjMmBase, SCISSOR_R, LOWORD(x) + cxGlyph-1);

                y = ppdev->yOffset + ptlOrigin.y;
                M32_OW(pjMmBase, CUR_Y, LOWORD(y));

                M32_OW(pjMmBase, DEST_Y_END, (LOWORD(y) + cyGlyph));

                vM32DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) * cyGlyph) >> 3);

                /*
                _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x, ptlOrigin.y,
                               cxGlyph, cyGlyph, pjGlyph,
                               (ROUND8(cxGlyph) * cyGlyph) >> 3);
                */

              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if ( ( ptlOrigin.x <= prclClip->left ) &&
                     (ppdev->pModeInfo->ModeFlags & AMI_TEXTBAND) )
                    {
                    vResetClipping(ppdev);
                    return FALSE;
                    }

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {

                  /* Do software clipping */

                  /* Calculated the Bias in pixels */

                  yBiasT = (yTop - ptlOrigin.y);

                  /*  change address of pjGlyph to point +yBiasT
                      scan lines into the Glyph */

                  pjGlyph += (yBiasT * (ROUND8(cxGlyph) >> 3));

                  M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);

                  x = ppdev->xOffset + ptlOrigin.x;
                  M32_OW(pjMmBase, CUR_X, LOWORD(x));
                  M32_OW(pjMmBase, DEST_X_START, LOWORD(x));
                  M32_OW(pjMmBase, DEST_X_END, LOWORD(x) + ROUND8(cxGlyph) );
                  M32_OW(pjMmBase, SCISSOR_R, LOWORD(x) + cxGlyph-1);

                  y = ppdev->yOffset + ptlOrigin.y;
                  M32_OW(pjMmBase, CUR_Y, LOWORD(y+yBiasT));

                  M32_OW(pjMmBase, DEST_Y_END, (LOWORD(y+yBiasT) + cy));

                  vM32DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) >> 3) * cy);

                  /*
                  _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x,ptlOrigin.y+yBiasT,
                                 cxGlyph, cy, pjGlyph,
                                 (ROUND8(cxGlyph) >>3) * cy);
                  */

                } /*if*/

              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }

            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

    vResetClipping(ppdev);

    return TRUE;
}

/******************************Public*Routine******************************\
* BOOL bM32TextOut
*
\**************************************************************************/

BOOL bM32TextOut(
PDEV*       ppdev,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque)
{
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    CACHEDFONT*     pcf;
    RECTL           rclOpaque;
    BOOL            bTextPerfectFit;

    pjMmBase = ppdev->pjMmBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      if (iDComplexity == DC_TRIVIAL)
      {

      DrawOpaqueRect:

        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);

        M32_OW(pjMmBase, FRGD_COLOR,   pboOpaque->iSolidColor);
        M32_OW(pjMmBase, ALU_FG_FN,    OVERPAINT);
        M32_OW(pjMmBase, DP_CONFIG,    FG_COLOR_SRC_FG | WRITE | DRAW);
        M32_OW(pjMmBase, CUR_X,        xOffset + prclOpaque->left);
        M32_OW(pjMmBase, DEST_X_START, xOffset + prclOpaque->left);
        M32_OW(pjMmBase, DEST_X_END,   xOffset + prclOpaque->right);
        M32_OW(pjMmBase, CUR_Y,        yOffset + prclOpaque->top);

        vM32QuietDown(ppdev, pjMmBase);

        M32_OW(pjMmBase, DEST_Y_END,   yOffset + prclOpaque->bottom);
      }
      else if (iDComplexity == DC_RECT)
      {
        if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
        {
          prclOpaque = &rclOpaque;
          goto DrawOpaqueRect;
        }
      }
      else
      {
        vClipSolid(ppdev, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
              SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
              SO_CHAR_INC_EQUAL_BM_BASE)) ==
              (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
              SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

      if (bTextPerfectFit)
      {
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
        M32_OW(pjMmBase, ALU_BG_FN,  OVERPAINT);
        M32_OW(pjMmBase, BKGD_COLOR, pboOpaque->iSolidColor);
        goto SkipTransparentInitialization;
      }
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
    M32_OW(pjMmBase, ALU_BG_FN, LEAVE_ALONE);

SkipTransparentInitialization:

    M32_OW(pjMmBase, DP_CONFIG,   EXT_MONO_SRC_HOST | DRAW | WRITE |
                                  FG_COLOR_SRC_FG | BG_COLOR_SRC_BG |
                                  LSB_FIRST | BIT16);
    M32_OW(pjMmBase, ALU_FG_FN,   OVERPAINT);
    M32_OW(pjMmBase, FRGD_COLOR,  pboFore->iSolidColor);

    if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
        ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
    {
      pcf = (CACHEDFONT*) pfo->pvConsumer;

      if (pcf == NULL)
      {
        pcf = pcfAllocateCachedFont(ppdev);
        if (pcf == NULL)
          return(FALSE);

        pfo->pvConsumer = pcf;
      }

      // Use our glyph cache:

      if (iDComplexity == DC_TRIVIAL)
      {
        do {
          if (pstro->pgp != NULL)
          {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
          }
          else
          {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
          }

          if (cGlyph > 0)
          {
            if (pstro->ulCharInc == 0)
            {
              if (!bM32CachedProportionalText(ppdev, pcf, pgp, cGlyph))
                return(FALSE);
            }
            else
            {
              if (!bM32CachedFixedText(ppdev, pcf, pgp, cGlyph, pstro->ulCharInc))
                return(FALSE);
            }
          }
        } while (bMoreGlyphs);
      }
      else
      {
        if (!bM32CachedClippedText(ppdev, pcf, pstro, pco))
          return(FALSE);
      }
    }
    else
    {
      DISPDBG((4, "Text too big to cache: %li x %li",
             pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

      M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
      M32_OW(pjMmBase, DP_CONFIG, EXT_MONO_SRC_HOST | DRAW | WRITE |
                                  FG_COLOR_SRC_FG | BG_COLOR_SRC_BG);

      return bM32GeneralText(ppdev, pstro, pco);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bM64CachedProportionalText
*
* Draws proportionally spaced glyphs via glyph caching.
*
\**************************************************************************/

BOOL bM64CachedProportionalText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjMmBase;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            xOffset;
    LONG            yOffset;
    LONG            x;
    LONG            y;
    LONG            cd;
    DWORD*          pd;
    LONG            cFifo;

    pjMmBase  = ppdev->pjMmBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;
    cFifo   = 0;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            // The glyph's origin y-coordinate may often be negative, so we
            // can't compute this as follows:
            //
            // x = pgp->ptl.x + pcg->ptlOrigin.x;
            // y = pgp->ptl.y + pcg->ptlOrigin.y;

            ASSERTDD((pgp->ptl.y + pcg->ptlOrigin.y) >= 0,
                "Can't have negative 'y' coordinates here");

            cFifo -= 2;
            if (cFifo < 0)
            {
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                cFifo = 14;
            }

            x = xOffset + pgp->ptl.x + pcg->ptlOrigin.x;
            y = yOffset + pgp->ptl.y + pcg->ptlOrigin.y;

            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

            pd = (DWORD*) &pcg->ad[0];
            cd = pcg->cd;

            do {
                if (--cFifo < 0)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 15;
                }

                M64_OD(pjMmBase, HOST_DATA0, *pd);

            } while (pd++, --cd != 0);
        }

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

BOOL bM64CachedProportionalText24(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjMmBase;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            xOffset;
    LONG            yOffset;
    LONG            x;
    LONG            y;
    LONG            cd;
    DWORD*          pd;
    LONG            cFifo;

    pjMmBase  = ppdev->pjMmBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;
    cFifo   = 0;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            // The glyph's origin y-coordinate may often be negative, so we
            // can't compute this as follows:
            //
            // x = pgp->ptl.x + pcg->ptlOrigin.x;
            // y = pgp->ptl.y + pcg->ptlOrigin.y;

            ASSERTDD((pgp->ptl.y + pcg->ptlOrigin.y) >= 0,
                "Can't have negative 'y' coordinates here");

            cFifo -= 3;
            if (cFifo < 0)
            {
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                cFifo = 13;
            }

            x = (xOffset + pgp->ptl.x + pcg->ptlOrigin.x) * 3;
            y = yOffset + pgp->ptl.y + pcg->ptlOrigin.y;

            M64_OD(pjMmBase, DST_CNTL,         0x83 | (((x + MAX_NEGX*3)/4 % 6) << 8));
            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

            pd = (DWORD*) &pcg->ad[0];
            cd = pcg->cd;

            do {
                if (--cFifo < 0)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 15;
                }

                M64_OD(pjMmBase, HOST_DATA0, *pd);

            } while (pd++, --cd != 0);
        }

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bM64CachedFixedText
*
* Draws fixed spaced glyphs via glyph caching.
*
\*************************************************************************/

BOOL bM64CachedFixedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph,
ULONG       ulCharInc)
{
    BYTE*           pjMmBase;
    LONG            xGlyph;
    LONG            yGlyph;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            x;
    LONG            y;
    DWORD*          pd;
    LONG            cd;
    LONG            cFifo;

    pjMmBase = ppdev->pjMmBase;
    cFifo  = 0;

    // Convert to absolute coordinates:

    xGlyph = pgp->ptl.x + ppdev->xOffset;
    yGlyph = pgp->ptl.y + ppdev->yOffset;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            x = xGlyph + pcg->ptlOrigin.x;
            y = yGlyph + pcg->ptlOrigin.y;

            cFifo -= 2;
            if (cFifo < 0)
            {
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                cFifo = 14;
            }

            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

            pd = (DWORD*) &pcg->ad[0];
            cd = pcg->cd;

            do {
                if (--cFifo < 0)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 15;
                }

                M64_OD(pjMmBase, HOST_DATA0, *pd);

            } while (pd++, --cd != 0);
        }

        xGlyph += ulCharInc;

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

BOOL bM64CachedFixedText24(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph,
ULONG       ulCharInc)
{
    BYTE*           pjMmBase;
    LONG            xGlyph;
    LONG            yGlyph;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            x;
    LONG            y;
    DWORD*          pd;
    LONG            cd;
    LONG            cFifo;

    pjMmBase = ppdev->pjMmBase;
    cFifo  = 0;

    // Convert to absolute coordinates:

    xGlyph = pgp->ptl.x + ppdev->xOffset;
    yGlyph = pgp->ptl.y + ppdev->yOffset;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg) {
            pcg = pcg->pcgNext;
        }

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        if (pcg->cx != 0)
        {
            x = (xGlyph + pcg->ptlOrigin.x) * 3;
            y = yGlyph + pcg->ptlOrigin.y;

            cFifo -= 3;
            if (cFifo < 0)
            {
                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                cFifo = 13;
            }

            M64_OD(pjMmBase, DST_CNTL,         0x83 | (((x + MAX_NEGX*3)/4 % 6) << 8));
            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x, y));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

            pd = (DWORD*) &pcg->ad[0];
            cd = pcg->cd;

            do {
                if (--cFifo < 0)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 15;
                }

                M64_OD(pjMmBase, HOST_DATA0, *pd);

            } while (pd++, --cd != 0);
        }

        xGlyph += ulCharInc;

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bM64CachedClippedText
*
* Draws clipped text via glyph caching.
*
\**************************************************************************/

BOOL bM64CachedClippedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClippingSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            yBottom;
    LONG            cy;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    DWORD*          pd;
    LONG            cd;
    LONG            cFifo;

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
             "Don't expect trivial clipping in this function");

    bRet      = TRUE;
    pjMmBase    = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    ulCharInc = pstro->ulCharInc;
    cFifo     = 0;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        if (pco->iDComplexity == DC_RECT)
        {
          // We could call 'cEnumStart' and 'bEnum' when the clipping is
          // DC_RECT, but the last time I checked, those two calls took
          // more than 150 instructions to go through GDI.  Since
          // 'rclBounds' already contains the DC_RECT clip rectangle,
          // and since it's such a common case, we'll special case it:

          bMore    = FALSE;
          ce.c     = 1;
          prclClip = &pco->rclBounds;

          goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClippingSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;

            // We can't yet convert to absolute coordinates by adding
            // in 'xOffset' or 'yOffset' here because we have yet to
            // compare the coordinates to 'prclClip':

            xGlyph = pgp->ptl.x;
            yGlyph = pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              hg  = pgp->hg;
              pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

              while (pcg->hg < hg)
                pcg = pcg->pcgNext;

              if (pcg->hg > hg)
              {
                // This will hopefully not be the common case (that is,
                // we will have a high cache hit rate), so if I were
                // writing this in Asm I would have this out-of-line
                // to avoid the jump around for the common case.
                // But the Pentium has branch prediction, so what the
                // heck.

                pcg = pcgNew(ppdev, pcf, pgp);
                if (pcg == NULL)
                {
                  bRet = FALSE;
                  goto AllDone;
                }
              }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cy = pcg->cy;
              if (cy != 0)
              {
                y       = pcg->ptlOrigin.y + yGlyph;
                x       = pcg->ptlOrigin.x + xGlyph;
                xRight  = pcg->cx + x;
                yBottom = pcg->cy + y;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   < xRight) &&
                    (prclClip->top    < yBottom))
                {
                  // Lazily set the hardware clipping:

                  if (!bClippingSet)
                  {
                    bClippingSet = TRUE;
                    vSetClipping(ppdev, prclClip);
                    cFifo = 0;              // Have to initialize count
                  }

                  cFifo -= 2;
                  if (cFifo < 0)
                  {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 14;
                  }

                  M64_OD(pjMmBase, DST_Y_X,          PACKXY(xOffset + x, yOffset + y));
                  M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

                  pd = (DWORD*) &pcg->ad[0];
                  cd = pcg->cd;

                  do {
                    if (--cFifo < 0)
                    {
                      M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                      cFifo = 15;
                    }

                    M64_OD(pjMmBase, HOST_DATA0, *pd);

                  } while (pd++, --cd != 0);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    vResetClipping(ppdev);

    return(bRet);
}

BOOL bM64CachedClippedText24(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClippingSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            yBottom;
    LONG            cy;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    DWORD*          pd;
    LONG            cd;
    LONG            cFifo;
    LONG            xTmp;

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
             "Don't expect trivial clipping in this function");

    bRet      = TRUE;
    pjMmBase    = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    ulCharInc = pstro->ulCharInc;
    cFifo     = 0;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        if (pco->iDComplexity == DC_RECT)
        {
          // We could call 'cEnumStart' and 'bEnum' when the clipping is
          // DC_RECT, but the last time I checked, those two calls took
          // more than 150 instructions to go through GDI.  Since
          // 'rclBounds' already contains the DC_RECT clip rectangle,
          // and since it's such a common case, we'll special case it:

          bMore    = FALSE;
          ce.c     = 1;
          prclClip = &pco->rclBounds;

          goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClippingSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;

            // We can't yet convert to absolute coordinates by adding
            // in 'xOffset' or 'yOffset' here because we have yet to
            // compare the coordinates to 'prclClip':

            xGlyph = pgp->ptl.x;
            yGlyph = pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              hg  = pgp->hg;
              pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

              while (pcg->hg < hg)
                pcg = pcg->pcgNext;

              if (pcg->hg > hg)
              {
                // This will hopefully not be the common case (that is,
                // we will have a high cache hit rate), so if I were
                // writing this in Asm I would have this out-of-line
                // to avoid the jump around for the common case.
                // But the Pentium has branch prediction, so what the
                // heck.

                pcg = pcgNew(ppdev, pcf, pgp);
                if (pcg == NULL)
                {
                  bRet = FALSE;
                  goto AllDone;
                }
              }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cy = pcg->cy;
              if (cy != 0)
              {
                y       = pcg->ptlOrigin.y + yGlyph;
                x       = pcg->ptlOrigin.x + xGlyph;
                xRight  = pcg->cx + x;
                yBottom = pcg->cy + y;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   < xRight) &&
                    (prclClip->top    < yBottom))
                {
                  // Lazily set the hardware clipping:

                  if (!bClippingSet)
                  {
                    bClippingSet = TRUE;
                    vSetClipping(ppdev, prclClip);
                    cFifo = 0;              // Have to initialize count
                  }

                  cFifo -= 3;
                  if (cFifo < 0)
                  {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                    cFifo = 13;
                  }

                  xTmp = (xOffset + x) * 3;
                  M64_OD(pjMmBase, DST_CNTL,         0x83 | (((xTmp + MAX_NEGX*3)/4 % 6) << 8));
                  M64_OD(pjMmBase, DST_Y_X,          PACKXY(xTmp, yOffset + y));
                  M64_OD(pjMmBase, DST_HEIGHT_WIDTH, pcg->cxy);

                  pd = (DWORD*) &pcg->ad[0];
                  cd = pcg->cd;

                  do {
                    if (--cFifo < 0)
                    {
                      M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
                      cFifo = 15;
                    }

                    M64_OD(pjMmBase, HOST_DATA0, *pd);

                  } while (pd++, --cd != 0);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    vResetClipping(ppdev);

    return(bRet);
}

 /******************************Public*Routine******************************\
* BOOL bM64GeneralText
*
\**************************************************************************/

BOOL bM64GeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjMmBase;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBiasL = 0;
    LONG        xBiasR = 0;
    LONG        yBiasT = 0;
    LONG        cy = 0;
    LONG        cx = 0;
    BYTE*       pjGlyph;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    RECTL       NoClip;

    pjMmBase = ppdev->pjMmBase;

    /* Define Default Clipping area to be full video ram */
    NoClip.top    = 0;
    NoClip.left   = 0;
    NoClip.right  = ppdev->cxScreen;
    NoClip.bottom = ppdev->cyScreen;

    if (pco == NULL)
        iDComplexity = DC_TRIVIAL;
    else
        iDComplexity = pco->iDComplexity;

    do {

      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &NoClip;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;

        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {

          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            vSetClipping(ppdev, prclClip);
            //ppdev->lRightScissor = rclRealClip.right;  ???

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph  = pgb->sizlBitmap.cx;
              cyGlyph  = pgb->sizlBitmap.cy;
              pjGlyph = (BYTE*) pgb->aj;


              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);

                M64_OD(pjMmBase, HOST_CNTL, 1);

                M64_OD(pjMmBase, DST_Y_X, ((ppdev->yOffset+ptlOrigin.y) & 0xffff) |
                                          ((ppdev->xOffset+ptlOrigin.x) << 16));
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cyGlyph | cxGlyph << 16);

                vM64DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) * cyGlyph) >> 3);

                /*
                _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x, ptlOrigin.y,
                               cxGlyph, cyGlyph, pjGlyph,
                               (ROUND8(cxGlyph) * cyGlyph) >> 3);
                */

              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if ( ( ptlOrigin.x <= prclClip->left ) &&
                     (ppdev->pModeInfo->ModeFlags & AMI_TEXTBAND) )
                    {
                    vResetClipping(ppdev);
                    return FALSE;
                    }

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {

                  /* Do software clipping */

                  /* Calculated the Bias in pixels */

                  yBiasT = (yTop - ptlOrigin.y);

                  /*  change address of pjGlyph to point +yBiasT
                      scan lines into the Glyph */

                  pjGlyph += (yBiasT * (ROUND8(cxGlyph) >> 3));

                  M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);

                  M64_OD(pjMmBase, HOST_CNTL, 1);

                  M64_OD(pjMmBase, DST_Y_X, ((ppdev->yOffset+ptlOrigin.y+yBiasT) & 0xffff) |
                                            ((ppdev->xOffset+ptlOrigin.x) << 16));
                  M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cy | cxGlyph << 16);

                  vM64DataPortOutB(ppdev, pjGlyph, (ROUND8(cxGlyph) >> 3) * cy);

                  /*
                  _vBlit_DSC_SH1UP(ppdev,ptlOrigin.x,ptlOrigin.y+yBiasT,
                                 cxGlyph, cy, pjGlyph,
                                 (ROUND8(cxGlyph) >>3) * cy);
                  */

                } /*if*/

              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }

            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

    vResetClipping(ppdev);

    // We must reset the HOST_CNTL register, or else BAD things happen when
    // rendering text in the OTHER functions.
    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, HOST_CNTL, 0);

    return TRUE;
}

VOID vM64DataPortOutD_24bppmono(PDEV* ppdev, PBYTE pb, UINT count, LONG pitch)
{
    BYTE* pjMmBase = ppdev->pjMmBase;
    UINT i,j;
    DWORD hostdata, remainder;
    UINT l;
    LONG data24;
    unsigned char data8;

    hostdata = 0;
    l = 0;

    for (i = 0; i < count; i++)
    {
        switch (l)
            {
            case 0:
                // expand 8 to 24bpp
                data24 = 0;
                data8 = *pb++;
                for (j = 0; j < 8; j++)
                {
                    data24 <<= 3;
                    if ((data8 >> j) & 1)
                        {
                        data24 |= 7;
                        }
                }
                hostdata = data24;

                // expand 8 to 24bpp
                data24 = 0;
                data8 = *pb++;
                for (j = 0; j < 8; j++)
                {
                    data24 <<= 3;
                    if ((data8 >> j) & 1)
                        {
                        data24 |= 7;
                        }
                }
                remainder = data24;

                hostdata = hostdata | (remainder << 24);
                break;

            case 1:
                data24 = 0;
                data8 = *pb++;
                for (j = 0; j < 8; j++)
                {
                    data24 <<= 3;
                    if ((data8 >> j) & 1)
                        {
                        data24 |= 7;
                        }
                }
                remainder = data24;

                hostdata = (hostdata >> 8) | (remainder << 16);
                break;

            case 2:
                data24 = 0;
                data8 = *pb++;
                for (j = 0; j < 8; j++)
                {
                    data24 <<= 3;
                    if ((data8 >> j) & 1)
                        {
                        data24 |= 7;
                        }
                }
                remainder = data24;

                hostdata = (hostdata >> 16) | (remainder << 8);
                break;
            }

        if ((i % 14) == 0)
            {
            M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
            }
        M64_OD(pjMmBase, HOST_DATA0, hostdata);

        hostdata = remainder;

        // 24 bpp alignment variable handling
        l = (l+1) % 3;
    }
}

BOOL bM64GeneralText24(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjMmBase;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBiasL = 0;
    LONG        xBiasR = 0;
    LONG        yBiasT = 0;
    LONG        cy = 0;
    LONG        cx = 0;
    BYTE*       pjGlyph;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    RECTL       NoClip;
    BOOLEAN     resetScissor;
    LONG        x;
    DWORD       dwCount;

    pjMmBase = ppdev->pjMmBase;

    /* Define Default Clipping area to be full video ram */
    NoClip.top    = 0;
    NoClip.left   = 0;
    NoClip.right  = ppdev->cxScreen;
    NoClip.bottom = ppdev->cyScreen;

    if (pco == NULL)
        iDComplexity = DC_TRIVIAL;
    else
        iDComplexity = pco->iDComplexity;

    do {

      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &NoClip;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;

        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {

          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            vSetClipping(ppdev, prclClip);
            //ppdev->lRightScissor = rclRealClip.right;  ???

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph  = pgb->sizlBitmap.cx;
              cyGlyph  = pgb->sizlBitmap.cy;
              pjGlyph = (BYTE*) pgb->aj;


              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph
                x = ppdev->xOffset+ptlOrigin.x;
                resetScissor = FALSE;

                if ((prclClip->right * 3) - 1 > (x - ppdev->xOffset + cxGlyph) * 3 - 1)
                {
                    resetScissor = TRUE;
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
                    M64_OD(pjMmBase, SC_RIGHT, (x + cxGlyph) * 3 - 1);
                }
                else
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);
                }

                M64_OD(pjMmBase, DST_CNTL, 0x83 | (((x + MAX_NEGX)*3/4 % 6) << 8));
                M64_OD(pjMmBase, DST_Y_X, ((ppdev->yOffset+ptlOrigin.y) & 0xffff) |
                                          (x*3 << 16));
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cyGlyph | (ROUND8(cxGlyph) * 3) << 16);

                dwCount = (ROUND8(cxGlyph) * 3 * cyGlyph + 31) / 32;
                vM64DataPortOutD_24bppmono(ppdev, pjGlyph, dwCount, cxGlyph);

                if (resetScissor)
                {
                    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
                    M64_OD(pjMmBase, SC_RIGHT, (ppdev->xOffset + prclClip->right) * 3 - 1);
                }

              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if ( ( ptlOrigin.x <= prclClip->left ) &&
                     (ppdev->pModeInfo->ModeFlags & AMI_TEXTBAND) )
                    {
                    vResetClipping(ppdev);
                    return FALSE;
                    }

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {
                    /* Do software clipping */

                    /* Calculated the Bias in pixels */

                    yBiasT = (yTop - ptlOrigin.y);

                    /*  change address of pjGlyph to point +yBiasT
                        scan lines into the Glyph */

                    pjGlyph += (yBiasT * (ROUND8(cxGlyph) >> 3));

                    x = ppdev->xOffset+ptlOrigin.x;
                    resetScissor = FALSE;

                    if ((prclClip->right * 3) - 1 > (x - ppdev->xOffset + cxGlyph) * 3 - 1)
                    {
                        resetScissor = TRUE;
                        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
                        M64_OD(pjMmBase, SC_RIGHT, (x + cxGlyph) * 3 - 1);
                    }
                    else
                    {
                        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 3);
                    }

                    M64_OD(pjMmBase, DST_CNTL, 0x83 | (((x + MAX_NEGX)*3/4 % 6) << 8));
                    M64_OD(pjMmBase, DST_Y_X, ((ppdev->yOffset+ptlOrigin.y+yBiasT) & 0xffff) |
                                              (x*3 << 16));
                    M64_OD(pjMmBase, DST_HEIGHT_WIDTH, cy | (ROUND8(cxGlyph) * 3) << 16);

                    dwCount = (ROUND8(cxGlyph) * 3 * cy + 31) / 32;
                    vM64DataPortOutD_24bppmono(ppdev, pjGlyph, dwCount, cxGlyph);

                    if (resetScissor)
                    {
                        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
                        M64_OD(pjMmBase, SC_RIGHT, (ppdev->xOffset + prclClip->right) * 3 - 1);
                    }

                } /*if*/

              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }

            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

    vResetClipping(ppdev);

    return TRUE;
}

/******************************Public*Routine******************************\
* BOOL bM64TextOut
*
\**************************************************************************/

BOOL bM64TextOut(
PDEV*       ppdev,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque)
{
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    CACHEDFONT*     pcf;
    RECTL           rclOpaque;

    pjMmBase  = ppdev->pjMmBase;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      if (iDComplexity == DC_TRIVIAL)
      {

      DrawOpaqueRect:

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);

        M64_OD(pjMmBase, DP_MIX,        (OVERPAINT << 16));
        M64_OD(pjMmBase, DP_FRGD_CLR,   pboOpaque->iSolidColor);
        M64_OD(pjMmBase, DP_SRC,        DP_SRC_FrgdClr << 8);
        M64_OD(pjMmBase, DST_Y_X,       PACKXY_FAST(xOffset + prclOpaque->left,
                                                    yOffset + prclOpaque->top));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH,
                            PACKXY_FAST(prclOpaque->right - prclOpaque->left,
                                        prclOpaque->bottom - prclOpaque->top));
      }
      else if (iDComplexity == DC_RECT)
      {
        if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
        {
          prclOpaque = &rclOpaque;
          goto DrawOpaqueRect;
        }
      }
      else
      {
        vClipSolid(ppdev, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      // I didn't observe any performance difference between setting
      // the ATI to opaque or transparent mode (when the font allowed
      // it -- some don't).
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );

    M64_OD(pjMmBase, DP_MIX,      (OVERPAINT << 16) | LEAVE_ALONE);
    M64_OD(pjMmBase, DP_FRGD_CLR, pboFore->iSolidColor);
    M64_OD(pjMmBase, DP_SRC,      (DP_SRC_Host << 16) | (DP_SRC_FrgdClr << 8) |
                                  (DP_SRC_BkgdClr));
    // For some reason, the SRC color depth must be monochrome.
    // Otherwise, it will cause wait-for-idle to hang.
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth & 0xFFFF00FF);

    if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
        ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
    {
      pcf = (CACHEDFONT*) pfo->pvConsumer;

      if (pcf == NULL)
      {
        pcf = pcfAllocateCachedFont(ppdev);
        if (pcf == NULL)
           goto ReturnFalse;

        pfo->pvConsumer = pcf;
      }

      // Use our glyph cache:

      if (iDComplexity == DC_TRIVIAL)
      {
        do {
          if (pstro->pgp != NULL)
          {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
          }
          else
          {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
          }

          if (cGlyph > 0)
          {
            if (pstro->ulCharInc == 0)
            {
              if (!bM64CachedProportionalText(ppdev, pcf, pgp, cGlyph))
                 goto ReturnFalse;
            }
            else
            {
              if (!bM64CachedFixedText(ppdev, pcf, pgp, cGlyph, pstro->ulCharInc))
                 goto ReturnFalse;
            }
          }
        } while (bMoreGlyphs);
      }
      else
      {
        if (!bM64CachedClippedText(ppdev, pcf, pstro, pco))
           goto ReturnFalse;
      }
    }
    else
    {
      DISPDBG((4, "Text too big to cache: %li x %li",
            pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

      if (!bM64GeneralText(ppdev, pstro, pco))
         goto ReturnFalse;
    }

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
    return(TRUE);

ReturnFalse:
    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
    return(FALSE);
}

BOOL bM64TextOut24(
PDEV*       ppdev,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque)
{
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    CACHEDFONT*     pcf;
    RECTL           rclOpaque;
    LONG            x;

    pjMmBase  = ppdev->pjMmBase;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      if (iDComplexity == DC_TRIVIAL)
      {

      DrawOpaqueRect:
        x = (xOffset + prclOpaque->left) * 3;

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);

        M64_OD(pjMmBase, DST_CNTL,      0x83 | ((x/4 % 6) << 8));
        M64_OD(pjMmBase, DP_MIX,        (OVERPAINT << 16));
        M64_OD(pjMmBase, DP_FRGD_CLR,   pboOpaque->iSolidColor);
        M64_OD(pjMmBase, DP_SRC,        DP_SRC_FrgdClr << 8);
        M64_OD(pjMmBase, DST_Y_X,       PACKXY_FAST(x,
                                                    yOffset + prclOpaque->top));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH,
                            PACKXY_FAST((prclOpaque->right - prclOpaque->left) * 3,
                                        prclOpaque->bottom - prclOpaque->top));
      }
      else if (iDComplexity == DC_RECT)
      {
        if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
        {
          prclOpaque = &rclOpaque;
          goto DrawOpaqueRect;
        }
      }
      else
      {
        vClipSolid(ppdev, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      // I didn't observe any performance difference between setting
      // the ATI to opaque or transparent mode (when the font allowed
      // it -- some don't).
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );

    M64_OD(pjMmBase, DP_MIX,      (OVERPAINT << 16) | LEAVE_ALONE);
    M64_OD(pjMmBase, DP_FRGD_CLR, pboFore->iSolidColor);
    M64_OD(pjMmBase, DP_SRC,      (DP_SRC_Host << 16) | (DP_SRC_FrgdClr << 8) |
                                  (DP_SRC_BkgdClr));
    // For some reason, the SRC color depth must be monochrome.
    // Otherwise, it will cause wait-for-idle to hang.
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth & 0xFFFF00FF);

    if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
        ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
    {
      pcf = (CACHEDFONT*) pfo->pvConsumer;

      if (pcf == NULL)
      {
        pcf = pcfAllocateCachedFont(ppdev);
        if (pcf == NULL)
           goto ReturnFalse;

        pfo->pvConsumer = pcf;
      }

      // Use our glyph cache:

      if (iDComplexity == DC_TRIVIAL)
      {
        do {
          if (pstro->pgp != NULL)
          {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
          }
          else
          {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
          }

          if (cGlyph > 0)
          {
            if (pstro->ulCharInc == 0)
            {
              if (!bM64CachedProportionalText24(ppdev, pcf, pgp, cGlyph))
                 goto ReturnFalse;
            }
            else
            {
              if (!bM64CachedFixedText24(ppdev, pcf, pgp, cGlyph, pstro->ulCharInc))
                 goto ReturnFalse;
            }
          }
        } while (bMoreGlyphs);
      }
      else
      {
        if (!bM64CachedClippedText24(ppdev, pcf, pstro, pco))
           goto ReturnFalse;
      }
    }
    else
    {
      DISPDBG((4, "Text too big to cache: %li x %li",
            pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

      if (!bM64GeneralText24(ppdev, pstro, pco))
         goto ReturnFalse;
    }

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
    return(TRUE);

ReturnFalse:
    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,    // Always unused, unless GCAPS_ARBRUSHOPAQUE set
MIX       mix)          // Always a copy mix (0x0d0d)
{
    PDEV*   ppdev;
    DSURF*  pdsurf;
    OH*     poh;

    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:

    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt != DT_DIB)
    {
      poh            = pdsurf->poh;
      ppdev          = (PDEV*) pso->dhpdev;
      ppdev->xOffset = poh->x;
      ppdev->yOffset = poh->y;

      if (!ppdev->pfnTextOut(ppdev, pstro, pfo, pco, prclOpaque, pboFore,
                             pboOpaque))
      {
          if (DIRECT_ACCESS(ppdev))
          {
              BANK bnk;

              vBankStart(ppdev,
                         (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround,
                         pco,
                         &bnk);

              do {
                EngTextOut(bnk.pso, pstro, pfo, bnk.pco, prclExtra, prclOpaque,
                           pboFore, pboOpaque, pptlBrush, mix);

              } while (bBankEnum(&bnk));
          }
          else
          {
              BOOL      b;
              BYTE*     pjBits;
              BYTE*     pjScan0;
              HSURF     hsurfDst;
              LONG      lDelta;
              RECTL     rclDst;
              RECTL     rclScreen;
              SIZEL     sizl;
              SURFOBJ*  psoTmp;


              b = FALSE;          // For error cases, assume we'll fail

              /*
              rclDst.left   = 0;
              rclDst.top    = 0;
              rclDst.right  = pdsurf->sizl.cx;
              rclDst.bottom = pdsurf->sizl.cy;
              */
              rclDst = (prclOpaque != NULL) ? *prclOpaque : pstro->rclBkGround;

              if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
              {
                  rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                  rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                  rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                  rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);
              }

              sizl.cx = rclDst.right  - rclDst.left;
              sizl.cy = rclDst.bottom - rclDst.top;

              {
                  // We need to create a temporary work buffer.  We have to do
                  // some fudging with the offsets so that the upper-left corner
                  // of the (relative coordinates) clip object bounds passed to
                  // GDI will be transformed to the upper-left corner of our
                  // temporary bitmap.

                  // The alignment doesn't have to be as tight as this at 16bpp
                  // and 32bpp, but it won't hurt:

                  lDelta = (((rclDst.right + 3) & ~3L) - (rclDst.left & ~3L))
                         * ppdev->cjPelSize;

                  // We're actually only allocating a bitmap that is 'sizl.cx' x
                  // 'sizl.cy' in size:

                  pjBits = AtiAllocMem(LMEM_FIXED, 0, lDelta * sizl.cy);
                  if (pjBits == NULL)
                      goto Error_2;

                  // We now adjust the surface's 'pvScan0' so that when GDI thinks
                  // it's writing to pixel (rclDst.top, rclDst.left), it will
                  // actually be writing to the upper-left pixel of our temporary
                  // bitmap:

                  pjScan0 = pjBits - (rclDst.top * lDelta)
                                   - ((rclDst.left & ~3L) * ppdev->cjPelSize);

                  ASSERTDD((((ULONG_PTR) pjScan0) & 3) == 0,
                          "pvScan0 must be dword aligned!");

                  hsurfDst = (HSURF) EngCreateBitmap(
                              sizl,                   // Bitmap covers rectangle
                              lDelta,                 // Use this delta
                              ppdev->iBitmapFormat,   // Same colour depth
                              BMF_TOPDOWN,            // Must have a positive delta
                              pjScan0);               // Where (0, 0) would be

                  if ((hsurfDst == 0) ||
                      (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                      goto Error_3;

                  psoTmp = EngLockSurface(hsurfDst);
                  if (psoTmp == NULL)
                      goto Error_4;

                  // Make sure that the rectangle we Get/Put from/to the screen
                  // is in absolute coordinates:

                  rclScreen.left   = rclDst.left   + ppdev->xOffset;
                  rclScreen.right  = rclDst.right  + ppdev->xOffset;
                  rclScreen.top    = rclDst.top    + ppdev->yOffset;
                  rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

                  ppdev->pfnGetBits(ppdev, psoTmp, &rclDst, (POINTL*) &rclScreen);

                  b = EngTextOut(psoTmp, pstro, pfo, pco, prclExtra, prclOpaque,
                             pboFore, pboOpaque, pptlBrush, mix);

                  ppdev->pfnPutBits(ppdev, psoTmp, &rclScreen, (POINTL*) &rclDst);

                  EngUnlockSurface(psoTmp);

              Error_4:

                  EngDeleteSurface(hsurfDst);

              Error_3:

                  AtiFreeMem(pjBits);
              }

              Error_2:

              return(b);
          }
      }
    }
    else
    {
      // We're drawing to a DFB we've converted to a DIB, so just call GDI
      // to handle it:

      return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                        pboFore, pboOpaque, pptlBrush, mix));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
}

/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
    // If we were to do off-screen glyph caching, we would probably want
    // to invalidate our cache here, because it will get destroyed when
    // we switch to full-screen.
}

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(
FONTOBJ*    pfo)
{
    CACHEDFONT* pcf;

    pcf = pfo->pvConsumer;
    if (pcf != NULL)
    {
        vFreeCachedFont(pcf);
        pfo->pvConsumer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\amach.h ===
//*************************************************************************
//**                                                                     **
//**                             AMACH.H                                 **
//**                                                                     **
//**     Copyright (c) 1993, ATI Technologies Inc.                       **
//*************************************************************************
//   
//  Created from the 68800.H and 68801.H in the Windows NT Group
//      as a simple merging of the files so ALL Mach8 and Mach32 defines
//      are located in one H file.
//
//  Created the 68800.inc file which includes equates, macros, etc 
//       from the following include files:    
//       8514vesa.inc, vga1regs.inc,  m32regs.inc,  8514.inc
//
// supplement Defines and values to the 68800 Family.
//
// This is a "C" only file and is NOT derived from any Assembler INC files.

  
/**********************       PolyTron RCS Utilities

   $Revision:   1.2  $
   $Date:   23 Dec 1994 10:48:28  $
   $Author:   ASHANMUG  $
   $Log:   S:/source/wnt/ms11/miniport/vcs/amach.h  $
 * 
 *    Rev 1.2   23 Dec 1994 10:48:28   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.1   20 May 1994 13:55:52   RWOLFF
 * Ajith's change: removed unused register SRC_CMP_COLOR from enumeration.
 * 
 *    Rev 1.0   31 Jan 1994 11:26:18   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.4   14 Jan 1994 15:15:30   RWOLFF
 * Added offsets of VGA registers from start of VGA_BASE_IO_PORT and
 * VGA_END_BREAK_PORT blocks, definition for bit in MISC_OPTIONS to
 * enable block write.
 * 
 *    Rev 1.3   15 Dec 1993 15:23:14   RWOLFF
 * Removed EISA configuration registers and (implied) placeholder for
 * linear framebuffer from register enumeration.
 * 
 *    Rev 1.2   10 Nov 1993 19:20:18   RWOLFF
 * Added definitions for DATA_READY bit of GE_STAT (ready to read from
 * PIX_TRANS in screen-to-host blit) and READ_WRITE bit of DP_CONFIG (indicates
 * whether we are reading from or writing to drawing trajectory).
 * 
 *    Rev 1.1   08 Oct 1993 10:58:52   RWOLFF
 * Added definitions for bit fields in MISC_OPTIONS and EXT_GE_CONFIG.
 * 
 *    Rev 1.0   03 Sep 1993 14:25:54   RWOLFF
 * Initial revision.
	
	   Rev 1.4   06 Jul 1993 15:53:42   RWOLFF
	Added definitions for ATI 68860 and AT&T 491 DACs.
	
	   Rev 1.3   07 Jun 1993 12:57:32   BRADES
	add EXT_SRC_Y, EXT_CUR_Y for Mach8 512k minimum mode.
	add enums for 24 and 32 bpp formats.
	
	   Rev 1.2   30 Apr 1993 15:57:06   BRADES
	fix DISP_STATUS, SEQ_IND and 1CE registers to use table.
	
	   Rev 1.0   14 Apr 1993 15:38:38   BRADES
	Initial revision.
	
	   Rev 1.6   15 Mar 1993 22:22:12   BRADES
	add mode_table.m_screen_pitch for the # pixels on a display line.
	Used with Mach8 800 by 600 where pitch is 896.
	
	   Rev 1.5   08 Mar 1993 19:58:10   BRADES
	added DEC Alpha and update to Build 390.  Thsi is from Miniport source.
	
	   Rev 1.3   15 Jan 1993 10:19:32   Robert_Wolff
	Added definitions for video card type, amount of video memory,
	and resolutions supported (formerly in VIDFIND.H).
	
	   Rev 1.2   17 Dec 1992 18:09:10   Robert_Wolff
	Added definitions for various bits in the CMD and GE_STAT registers.
	Definitions originally were in the now-obsolete S3.H for the
	engine-only driver.
	
	   Rev 1.1   13 Nov 1992 13:29:48   Robert_Wolff
	Fixed list of memory types (based on table on p. 9-66 of Programmer's
	Guide to the Mach 32 Registers, release 1.2, which swapped 2 types and
	omitted the second flavour of 256kx4 VRAM).
	
	   Rev 1.0   13 Nov 1992 09:31:02   Chris_Brady
	Initial revision.


End of PolyTron RCS section                             *****************/


#define REVISION             0x0002             // No one should use this


//-------------------------------------------------------------------------
//                 REGISTER PORT ADDRESSES
//
//  PS/2  POS registers
#define SETUP_ID1            0x0100 // Setup Mode Identification (Byte 1)
#define SETUP_ID2            0x0101 // Setup Mode Identification (Byte 2)
#define SETUP_OPT            0x0102 // Setup Mode Option Select
#define ROM_SETUP            0x0103 // 
#define SETUP_1              0x0104 //
#define SETUP_2              0x0105 //


//   Lowest and highest I/O ports used by the VGAWonder. 
#define VGA_BASE_IO_PORT        0x03B0
#define VGA_START_BREAK_PORT    0x03BB
#define VGA_END_BREAK_PORT      0x03C0
#define VGA_MAX_IO_PORT         0x03DF

// Registers used in reading/writing EEPROM
#define IO_SEQ_IND     0x03C4           // Sequencer index register 
#define IO_HI_SEQ_ADDR IO_SEQ_IND       // word register
#define IO_SEQ_DATA    0x03C5           // Sequencer data register 

/*
 * Offsets for VGA registers from regVGA_BASE_IO_PORT or
 * regVGA_END_BREAK_PORT (depending on which block they're in)
 */
#define GENMO_OFFSET        0x0002      /* 0x03C2 */
#define DAC_W_INDEX_OFFSET  0x0008      /* 0x03C8 */
#define DAC_DATA_OFFSET     0x0009      /* 0x03C9 */
#define CRTX_COLOUR_OFFSET  0x0014      /* 0x03D4 */
#define GENS1_COLOUR_OFFSET 0x001A      /* 0x03DA */



// define registers in IO space
#define IO_DAC_MASK             0x02EA // DAC Mask
#define IO_DAC_R_INDEX          0x02EB // DAC Read Index
#define IO_DAC_W_INDEX          0x02EC // DAC Write Index
#define IO_DAC_DATA             0x02ED // DAC Data

#define IO_DISP_STATUS          0x02E8 // Display Status
#define IO_H_TOTAL              0x02E8 // Horizontal Total
#define IO_OVERSCAN_COLOR_8     0x02EE 
#define IO_OVERSCAN_BLUE_24     0x02EF 
#define IO_H_DISP               0x06E8 // Horizontal Displayed
#define IO_OVERSCAN_GREEN_24    0x06EE 
#define IO_OVERSCAN_RED_24      0x06EF 
#define IO_H_SYNC_STRT          0x0AE8 // Horizontal Sync Start
#define IO_CURSOR_OFFSET_LO     0x0AEE 
#define IO_H_SYNC_WID           0x0EE8 // Horizontal Sync Width
#define IO_CURSOR_OFFSET_HI     0x0EEE 
#define IO_V_TOTAL              0x12E8 // Vertical Total
#define IO_CONFIG_STATUS_1      0x12EE // Read only equivalent to HORZ_CURSOR_POSN 
#define IO_HORZ_CURSOR_POSN     0x12EE 
#define IO_V_DISP               0x16E8 // Vertical Displayed
#define IO_CONFIG_STATUS_2      0x16EE // Read only equivalent to VERT_CURSOR_POSN
#define IO_VERT_CURSOR_POSN     0x16EE 
#define IO_V_SYNC_STRT          0x1AE8 // Vertical Sync Start
#define IO_CURSOR_COLOR_0       0x1AEE 
#define IO_FIFO_TEST_DATA       0x1AEE 
#define IO_CURSOR_COLOR_1       0x1AEF 
#define IO_V_SYNC_WID           0x1EE8 // Vertical Sync Width
#define IO_HORZ_CURSOR_OFFSET   0x1EEE 
#define IO_VERT_CURSOR_OFFSET   0x1EEF 
#define IO_DISP_CNTL            0x22E8 // Display Control 
#define IO_CRT_PITCH            0x26EE 
#define IO_CRT_OFFSET_LO        0x2AEE 
#define IO_CRT_OFFSET_HI        0x2EEE 
#define IO_LOCAL_CONTROL        0x32EE 
#define IO_FIFO_OPT             0x36EE 
#define IO_MISC_OPTIONS         0x36EE 
#define IO_EXT_CURSOR_COLOR_0   0x3AEE 
#define IO_FIFO_TEST_TAG        0x3AEE 
#define IO_EXT_CURSOR_COLOR_1   0x3EEE 
#define IO_SUBSYS_CNTL          0x42E8 // Subsystem Control
#define IO_SUBSYS_STAT          0x42E8 // Subsystem Status
#define IO_MEM_BNDRY            0x42EE 
#define IO_SHADOW_CTL           0x46EE 
#define IO_ROM_PAGE_SEL         0x46E8 // ROM Page Select (not in manual)
#define IO_ADVFUNC_CNTL         0x4AE8 // Advanced Function Control
#define IO_CLOCK_SEL            0x4AEE 
	
#define IO_ROM_ADDR_1           0x52EE 
#define IO_ROM_ADDR_2           0x56EE 
#define IO_SCRATCH_PAD_0        0x52EE 
#define IO_SCRATCH_PAD_1        0x56EE 
	
#define IO_SHADOW_SET           0x5AEE 
#define IO_MEM_CFG              0x5EEE 
#define IO_EXT_GE_STATUS        0x62EE 
	
#define IO_HORZ_OVERSCAN        0x62EE 
#define IO_VERT_OVERSCAN        0x66EE 
	
#define IO_MAX_WAITSTATES       0x6AEE 
#define IO_GE_OFFSET_LO         0x6EEE 
#define IO_BOUNDS_LEFT          0x72EE 
#define IO_GE_OFFSET_HI         0x72EE 
#define IO_BOUNDS_TOP           0x76EE 
#define IO_GE_PITCH             0x76EE 
#define IO_BOUNDS_RIGHT         0x7AEE 
#define IO_EXT_GE_CONFIG        0x7AEE 
#define IO_BOUNDS_BOTTOM        0x7EEE 
#define IO_MISC_CNTL            0x7EEE 
#define IO_CUR_Y                0x82E8 // Current Y Position
#define IO_PATT_DATA_INDEX      0x82EE 
#define IO_CUR_X                0x86E8 // Current X Position
#define IO_SRC_Y                0x8AE8 //
#define IO_DEST_Y               0x8AE8 //
#define IO_AXSTP                0x8AE8 // Destination Y Position
#define IO_SRC_X                0x8EE8 // Axial     Step Constant
#define IO_DEST_X               0x8EE8 //
#define IO_DIASTP               0x8EE8 // Destination X Position
#define IO_PATT_DATA            0x8EEE 
#define IO_R_EXT_GE_CONFIG      0x8EEE 
#define IO_ERR_TERM             0x92E8 // Error Term
#define IO_R_MISC_CNTL          0x92EE 
#define IO_MAJ_AXIS_PCNT        0x96E8 // Major Axis Pixel Count
#define IO_BRES_COUNT           0x96EE 
#define IO_CMD                  0x9AE8 // Command
#define IO_GE_STAT              0x9AE8 // Graphics Processor Status
#define IO_EXT_FIFO_STATUS      0x9AEE 
#define IO_LINEDRAW_INDEX       0x9AEE 
#define IO_SHORT_STROKE         0x9EE8 // Short Stroke Vector Transfer
#define IO_BKGD_COLOR           0xA2E8 // Background Color
#define IO_LINEDRAW_OPT         0xA2EE 
#define IO_FRGD_COLOR           0xA6E8 // Foreground Color
#define IO_DEST_X_START         0xA6EE 
#define IO_WRT_MASK             0xAAE8 // Write Mask
#define IO_DEST_X_END           0xAAEE 
#define IO_RD_MASK              0xAEE8 // Read Mask
#define IO_DEST_Y_END           0xAEEE 
#define IO_CMP_COLOR            0xB2E8 // Compare Color
#define IO_R_H_TOTAL            0xB2EE 
#define IO_R_H_DISP             0xB2EE 
#define IO_SRC_X_START          0xB2EE 
#define IO_BKGD_MIX             0xB6E8 // Background Mix
#define IO_ALU_BG_FN            0xB6EE 
#define IO_R_H_SYNC_STRT        0xB6EE 
#define IO_FRGD_MIX             0xBAE8 // Foreground Mix
#define IO_ALU_FG_FN            0xBAEE 
#define IO_R_H_SYNC_WID         0xBAEE 
#define IO_MULTIFUNC_CNTL       0xBEE8 // Multi-Function Control (mach 8)
#define IO_MIN_AXIS_PCNT        0xBEE8 
#define IO_SCISSOR_T            0xBEE8 
#define IO_SCISSOR_L            0xBEE8 
#define IO_SCISSOR_B            0xBEE8 
#define IO_SCISSOR_R            0xBEE8 
#define IO_MEM_CNTL             0xBEE8 
#define IO_PATTERN_L            0xBEE8 
#define IO_PATTERN_H            0xBEE8 
#define IO_PIXEL_CNTL           0xBEE8 
#define IO_SRC_X_END            0xBEEE 
#define IO_SRC_Y_DIR            0xC2EE 
#define IO_R_V_TOTAL            0xC2EE 
#define IO_EXT_SSV              0xC6EE // (used for MACH 8)
#define IO_EXT_SHORT_STROKE     0xC6EE 
#define IO_R_V_DISP             0xC6EE 
#define IO_SCAN_X               0xCAEE 
#define IO_R_V_SYNC_STRT        0xCAEE 
#define IO_DP_CONFIG            0xCEEE 
#define IO_VERT_LINE_CNTR       0xCEEE 
#define IO_PATT_LENGTH          0xD2EE 
#define IO_R_V_SYNC_WID         0xD2EE 
#define IO_PATT_INDEX           0xD6EE 
#define IO_EXT_SCISSOR_L        0xDAEE // "extended" left scissor (12 bits precision)
#define IO_R_SRC_X              0xDAEE 
#define IO_EXT_SCISSOR_T        0xDEEE // "extended" top scissor (12 bits precision)
#define IO_R_SRC_Y              0xDEEE 
#define IO_PIX_TRANS            0xE2E8 // Pixel Data Transfer
#define IO_PIX_TRANS_HI         0xE2E9 // Pixel Data Transfer
#define IO_EXT_SCISSOR_R        0xE2EE // "extended" right scissor (12 bits precision)
#define IO_EXT_SCISSOR_B        0xE6EE // "extended" bottom scissor (12 bits precision)
#define IO_SRC_CMP_COLOR        0xEAEE // (used for MACH 8)
#define IO_DEST_CMP_FN          0xEEEE 
#define IO_EXT_CUR_Y            0xF6EE // Mach8 only
#define IO_ASIC_ID              0xFAEE // Mach32 rev 6
#define IO_LINEDRAW             0xFEEE 



// Internal registers (read only, for test purposes only)
#define IO__PAR_FIFO_DATA       0x1AEE 
#define IO__PAR_FIFO_ADDR       0x3AEE 
#define IO__MAJOR_DEST_CNT      0x42EE 
#define IO__MAJOR_SRC_CNT       0x5EEE 
#define IO__MINOR_DEST_CNT      0x66EE 
#define IO__MINOR_SRC_CNT       0x8AEE 
#define IO__HW_TEST             0x32EE 
	

//---------------------------------------------------------
// define the registers locations in Memory Mapped space
// take the IO address and and with 0xFC00 works for offset

//---     IF    (port AND 0FFh) EQ 0E8h
//---           mov word ptr seg:[edx+(3FFE00h+((port AND 0FC00h)shr 8))],ax
//---     ELSE
//---       IF  (port AND 0FFh) EQ 0EEh
//---           mov word ptr seg:[edx+(3FFF00h+((port AND 0FC00h)shr 8))],ax
//---   0x3FFE00

#define MM_DISP_STATUS          (IO_DISP_STATUS      & 0xFC00) >> 8
#define MM_DISP_CNTL            (IO_DISP_CNTL        & 0xFC00) >> 8
#define MM_SUBSYS_CNTL          (IO_SUBSYS_CNTL      & 0xFC00) >> 8
#define MM_SUBSYS_STAT          (IO_SUBSYS_STAT      & 0xFC00) >> 8
#define MM_ADVFUNC_CNTL         (IO_ADVFUNC_CNTL     & 0xFC00) >> 8
#define MM_CUR_Y                (IO_CUR_Y            & 0xFC00) >> 8
#define MM_CUR_X                (IO_CUR_X            & 0xFC00) >> 8
#define MM_SRC_Y                (IO_SRC_Y            & 0xFC00) >> 8
#define MM_DEST_Y               (IO_DEST_Y           & 0xFC00) >> 8
#define MM_AXSTP                (IO_AXSTP            & 0xFC00) >> 8
#define MM_SRC_X                (IO_SRC_X            & 0xFC00) >> 8
#define MM_DEST_X               (IO_DEST_X           & 0xFC00) >> 8
#define MM_DIASTP               (IO_DIASTP           & 0xFC00) >> 8
#define MM_ERR_TERM             (IO_ERR_TERM         & 0xFC00) >> 8
#define MM_MAJ_AXIS_PCNT        (IO_MAJ_AXIS_PCNT    & 0xFC00) >> 8
#define MM_GE_STAT              (IO_GE_STAT          & 0xFC00) >> 8
#define MM_SHORT_STROKE         (IO_SHORT_STROKE     & 0xFC00) >> 8
#define MM_BKGD_COLOR           (IO_BKGD_COLOR       & 0xFC00) >> 8
#define MM_FRGD_COLOR           (IO_FRGD_COLOR       & 0xFC00) >> 8
#define MM_WRT_MASK             (IO_WRT_MASK         & 0xFC00) >> 8
#define MM_RD_MASK              (IO_RD_MASK          & 0xFC00) >> 8
#define MM_CMP_COLOR            (IO_CMP_COLOR        & 0xFC00) >> 8
#define MM_BKGD_MIX             (IO_BKGD_MIX         & 0xFC00) >> 8
#define MM_FRGD_MIX             (IO_FRGD_MIX         & 0xFC00) >> 8
#define MM_MULTIFUNC_CNTL       (IO_MULTIFUNC_CNTL   & 0xFC00) >> 8
#define MM_MIN_AXIS_PCNT        (IO_MIN_AXIS_PCNT    & 0xFC00) >> 8
//---   #define MM_MEM_CNTL     (IO_MEM_CNTL         & 0xFC00) >> 8
#define MM_PIXEL_CNTL           (IO_PIXEL_CNTL       & 0xFC00) >> 8
#define MM_PIX_TRANS            (IO_PIX_TRANS        & 0xFC00) >> 8
#define MM_PIX_TRANS_HI         (IO_PIX_TRANS_HI     & 0xFC00) >> 8


#define MM_CURSOR_OFFSET_LO     0x100+((IO_CURSOR_OFFSET_LO     & 0xFC00) >> 8) + (IO_CURSOR_OFFSET_LO     & 1) 
#define MM_CURSOR_OFFSET_HI     0x100+((IO_CURSOR_OFFSET_HI     & 0xFC00) >> 8) + (IO_CURSOR_OFFSET_HI     & 1) 
#define MM_CONFIG_STATUS_1      0x100+((IO_CONFIG_STATUS_1      & 0xFC00) >> 8) + (IO_CONFIG_STATUS_1      & 1) 
#define MM_HORZ_CURSOR_POSN     0x100+((IO_HORZ_CURSOR_POSN     & 0xFC00) >> 8) + (IO_HORZ_CURSOR_POSN     & 1) 
#define MM_CONFIG_STATUS_2      0x100+((IO_CONFIG_STATUS_2      & 0xFC00) >> 8) + (IO_CONFIG_STATUS_2      & 1)
#define MM_VERT_CURSOR_POSN     0x100+((IO_VERT_CURSOR_POSN     & 0xFC00) >> 8) + (IO_VERT_CURSOR_POSN     & 1)
#define MM_CURSOR_COLOR_0       0x100+((IO_CURSOR_COLOR_0       & 0xFC00) >> 8) + (IO_CURSOR_COLOR_0       & 1)
#define MM_CURSOR_COLOR_1       0x100+((IO_CURSOR_COLOR_1       & 0xFC00) >> 8) + (IO_CURSOR_COLOR_1       & 1)
#define MM_HORZ_CURSOR_OFFSET   0x100+((IO_HORZ_CURSOR_OFFSET   & 0xFC00) >> 8) + (IO_HORZ_CURSOR_OFFSET   & 1)
#define MM_VERT_CURSOR_OFFSET   0x100+((IO_VERT_CURSOR_OFFSET   & 0xFC00) >> 8) + (IO_VERT_CURSOR_OFFSET   & 1)
#define MM_CRT_PITCH            0x100+((IO_CRT_PITCH            & 0xFC00) >> 8) + (IO_CRT_PITCH            & 1)
#define MM_CRT_OFFSET_LO        0x100+((IO_CRT_OFFSET_LO        & 0xFC00) >> 8) + (IO_CRT_OFFSET_LO        & 1)
#define MM_CRT_OFFSET_HI        0x100+((IO_CRT_OFFSET_HI        & 0xFC00) >> 8) + (IO_CRT_OFFSET_HI        & 1)
#define MM_MISC_OPTIONS         0x100+((IO_MISC_OPTIONS         & 0xFC00) >> 8) + (IO_MISC_OPTIONS         & 1)
#define MM_EXT_CURSOR_COLOR_0   0x100+((IO_EXT_CURSOR_COLOR_0   & 0xFC00) >> 8) + (IO_EXT_CURSOR_COLOR_0   & 1)
#define MM_EXT_CURSOR_COLOR_1   0x100+((IO_EXT_CURSOR_COLOR_1   & 0xFC00) >> 8) + (IO_EXT_CURSOR_COLOR_1   & 1)
#define MM_CLOCK_SEL            0x100+((IO_CLOCK_SEL            & 0xFC00) >> 8) + (IO_CLOCK_SEL            & 1)
#define MM_EXT_GE_STATUS        0x100+((IO_EXT_GE_STATUS        & 0xFC00) >> 8) + (IO_EXT_GE_STATUS        & 1)
#define MM_GE_OFFSET_LO         0x100+((IO_GE_OFFSET_LO         & 0xFC00) >> 8) + (IO_GE_OFFSET_LO         & 1)
#define MM_BOUNDS_LEFT          0x100+((IO_BOUNDS_LEFT          & 0xFC00) >> 8) + (IO_BOUNDS_LEFT          & 1)
#define MM_GE_OFFSET_HI         0x100+((IO_GE_OFFSET_HI         & 0xFC00) >> 8) + (IO_GE_OFFSET_HI         & 1)
#define MM_BOUNDS_TOP           0x100+((IO_BOUNDS_TOP           & 0xFC00) >> 8) + (IO_BOUNDS_TOP           & 1)
#define MM_GE_PITCH             0x100+((IO_GE_PITCH             & 0xFC00) >> 8) + (IO_GE_PITCH             & 1)
#define MM_BOUNDS_RIGHT         0x100+((IO_BOUNDS_RIGHT         & 0xFC00) >> 8) + (IO_BOUNDS_RIGHT         & 1)
#define MM_EXT_GE_CONFIG        0x100+((IO_EXT_GE_CONFIG        & 0xFC00) >> 8) + (IO_EXT_GE_CONFIG        & 1)
#define MM_BOUNDS_BOTTOM        0x100+((IO_BOUNDS_BOTTOM        & 0xFC00) >> 8) + (IO_BOUNDS_BOTTOM        & 1)
#define MM_MISC_CNTL            0x100+((IO_MISC_CNTL            & 0xFC00) >> 8) + (IO_MISC_CNTL            & 1)
#define MM_PATT_DATA_INDEX      0x100+((IO_PATT_DATA_INDEX      & 0xFC00) >> 8) + (IO_PATT_DATA_INDEX      & 1)
#define MM_PATT_DATA            0x100+((IO_PATT_DATA            & 0xFC00) >> 8) + (IO_PATT_DATA            & 1)
#define MM_BRES_COUNT           0x100+((IO_BRES_COUNT           & 0xFC00) >> 8) + (IO_BRES_COUNT           & 1)
#define MM_EXT_FIFO_STATUS      0x100+((IO_EXT_FIFO_STATUS      & 0xFC00) >> 8) + (IO_EXT_FIFO_STATUS      & 1)
#define MM_LINEDRAW_INDEX       0x100+((IO_LINEDRAW_INDEX       & 0xFC00) >> 8) + (IO_LINEDRAW_INDEX       & 1)
#define MM_LINEDRAW_OPT         0x100+((IO_LINEDRAW_OPT         & 0xFC00) >> 8) + (IO_LINEDRAW_OPT         & 1)
#define MM_DEST_X_START         0x100+((IO_DEST_X_START         & 0xFC00) >> 8) + (IO_DEST_X_START         & 1)
#define MM_DEST_X_END           0x100+((IO_DEST_X_END           & 0xFC00) >> 8) + (IO_DEST_X_END           & 1)
#define MM_DEST_Y_END           0x100+((IO_DEST_Y_END           & 0xFC00) >> 8) + (IO_DEST_Y_END           & 1)
#define MM_SRC_X_START          0x100+((IO_SRC_X_START          & 0xFC00) >> 8) + (IO_SRC_X_START          & 1)
#define MM_ALU_BG_FN            0x100+((IO_ALU_BG_FN            & 0xFC00) >> 8) + (IO_ALU_BG_FN            & 1)
#define MM_ALU_FG_FN            0x100+((IO_ALU_FG_FN            & 0xFC00) >> 8) + (IO_ALU_FG_FN            & 1)
#define MM_SRC_X_END            0x100+((IO_SRC_X_END            & 0xFC00) >> 8) + (IO_SRC_X_END            & 1)
#define MM_SRC_Y_DIR            0x100+((IO_SRC_Y_DIR            & 0xFC00) >> 8) + (IO_SRC_Y_DIR            & 1)
#define MM_EXT_SSV              0x100+((IO_EXT_SSV              & 0xFC00) >> 8) + (IO_EXT_SSV              & 1)
#define MM_EXT_SHORT_STROKE     0x100+((IO_EXT_SHORT_STROKE     & 0xFC00) >> 8) + (IO_EXT_SHORT_STROKE     & 1)
#define MM_SCAN_X               0x100+((IO_SCAN_X               & 0xFC00) >> 8) + (IO_SCAN_X               & 1)
#define MM_DP_CONFIG            0x100+((IO_DP_CONFIG            & 0xFC00) >> 8) + (IO_DP_CONFIG            & 1)
#define MM_VERT_LINE_CNTR       0x100+((IO_VERT_LINE_CNTR       & 0xFC00) >> 8) + (IO_VERT_LINE_CNTR       & 1)
#define MM_PATT_LENGTH          0x100+((IO_PATT_LENGTH          & 0xFC00) >> 8) + (IO_PATT_LENGTH          & 1)
#define MM_PATT_INDEX           0x100+((IO_PATT_INDEX           & 0xFC00) >> 8) + (IO_PATT_INDEX           & 1)
#define MM_EXT_SCISSOR_L        0x100+((IO_EXT_SCISSOR_L        & 0xFC00) >> 8) + (IO_EXT_SCISSOR_L        & 1)
#define MM_EXT_SCISSOR_T        0x100+((IO_EXT_SCISSOR_T        & 0xFC00) >> 8) + (IO_EXT_SCISSOR_T        & 1)
#define MM_EXT_SCISSOR_R        0x100+((IO_EXT_SCISSOR_R        & 0xFC00) >> 8) + (IO_EXT_SCISSOR_R        & 1)
#define MM_EXT_SCISSOR_B        0x100+((IO_EXT_SCISSOR_B        & 0xFC00) >> 8) + (IO_EXT_SCISSOR_B        & 1)
#define MM_SRC_CMP_COLOR        0x100+((IO_SRC_CMP_COLOR        & 0xFC00) >> 8) + (IO_SRC_CMP_COLOR        & 1)
#define MM_DEST_CMP_FN          0x100+((IO_DEST_CMP_FN          & 0xFC00) >> 8) + (IO_DEST_CMP_FN          & 1)
#define MM_EXT_CUR_Y            0x100+((IO_EXT_CUR_Y            & 0xFC00) >> 8) + (IO_ASIC_ID              & 1)
#define MM_LINEDRAW             0x100+((IO_LINEDRAW             & 0xFC00) >> 8) + (IO_LINEDRAW             & 1)
													     
													     
//---------------------------------------------------------
// define the registers as subscripts to an array
// this order MATCHES  SETUP_M.H  Driver<space type>Range_m[] structures
// all entries are in INCREASING IO address.
//                                      // Alternate names AT same IO address
enum    {
    DAC_MASK=0           ,
    DAC_R_INDEX          ,        
    DAC_W_INDEX          ,        
    DAC_DATA             ,        
    DISP_STATUS          ,              //    H_TOTAL
    OVERSCAN_COLOR_8     ,              // OVERSCAN_BLUE_24 at 2EF
    H_DISP               ,
    OVERSCAN_GREEN_24    ,              // OVERSCAN_RED_24  at 6EF
    H_SYNC_STRT          ,
    CURSOR_OFFSET_LO     ,
    H_SYNC_WID           ,
    CURSOR_OFFSET_HI     ,
    V_TOTAL              ,
    CONFIG_STATUS_1      ,              //    HORZ_CURSOR_POSN     
    V_DISP               ,
    CONFIG_STATUS_2      ,              //    VERT_CURSOR_POSN     
    V_SYNC_STRT          ,
    CURSOR_COLOR_0       ,              //    FIFO_TEST_DATA       
    CURSOR_COLOR_1       ,
    V_SYNC_WID           ,
    HORZ_CURSOR_OFFSET   ,
    VERT_CURSOR_OFFSET   ,
    DISP_CNTL            ,
    CRT_PITCH            ,
    CRT_OFFSET_LO        ,
    CRT_OFFSET_HI        ,
    LOCAL_CONTROL        ,
    FIFO_OPT             ,              //    MISC_OPTIONS         
    EXT_CURSOR_COLOR_0   ,              //    FIFO_TEST_TAG        
    EXT_CURSOR_COLOR_1   ,
    SUBSYS_CNTL          ,              //    SUBSYS_STAT          
    MEM_BNDRY            ,
    ROM_PAGE_SEL         ,
    SHADOW_CTL           ,
    ADVFUNC_CNTL         ,
    CLOCK_SEL            ,
    ROM_ADDR_1           ,              //    SCRATCH_PAD_0        
    ROM_ADDR_2           ,              //    SCRATCH_PAD_1        
    SHADOW_SET           ,
    MEM_CFG              ,
    EXT_GE_STATUS        ,              //    HORZ_OVERSCAN        
    VERT_OVERSCAN        ,
    MAX_WAITSTATES       ,
    GE_OFFSET_LO         ,
    BOUNDS_LEFT          ,              //    GE_OFFSET_HI         
    BOUNDS_TOP           ,              //    GE_PITCH             
    BOUNDS_RIGHT         ,              //    EXT_GE_CONFIG        
    BOUNDS_BOTTOM        ,              //    MISC_CNTL            
    CUR_Y                ,
    PATT_DATA_INDEX      ,
    CUR_X                ,
    SRC_Y                ,              //    DEST_Y    AXSTP 
    SRC_X                ,              //    DEST_X    DIASTP  
    PATT_DATA            ,              //    R_EXT_GE_CONFIG   
    ERR_TERM             ,
    R_MISC_CNTL          ,
    MAJ_AXIS_PCNT        ,
    BRES_COUNT           ,
    CMD                  ,              //    GE_STAT       
    LINEDRAW_INDEX       ,              //    EXT_FIFO_STATUS
    SHORT_STROKE         ,
    BKGD_COLOR           ,
    LINEDRAW_OPT         ,
    FRGD_COLOR           ,
    DEST_X_START         ,
    WRT_MASK             ,
    DEST_X_END           ,
    RD_MASK              ,
    DEST_Y_END           ,
    CMP_COLOR            ,
    SRC_X_START          ,              //   R_H_TOTAL   R_H_DISP  
    BKGD_MIX             ,
    ALU_BG_FN            ,              //    R_H_SYNC_STRT      
    FRGD_MIX             ,
    ALU_FG_FN            ,              //   R_H_SYNC_WID  
    MULTIFUNC_CNTL       ,              // MIN_AXIS_PCNT SCISSOR_T SCISSOR_L  
					// SCISSOR_B SCISSOR_R MEM_CNTL 
					// PATTERN_L PATTERN_H PIXEL_CNTL 
    SRC_X_END            ,
    SRC_Y_DIR            ,              // R_V_TOTAL 
    EXT_SSV              ,              //  EXT_SHORT_STROKE    R_V_DISP 
    SCAN_X               ,              //  R_V_SYNC_STRT        
    DP_CONFIG            ,              //    VERT_LINE_CNTR       
    PATT_LENGTH          ,              // R_V_SYNC_WID      
    PATT_INDEX           ,
    EXT_SCISSOR_L        ,              //    R_SRC_X              
    EXT_SCISSOR_T        ,              //    R_SRC_Y              
    PIX_TRANS            ,
    PIX_TRANS_HI         ,
    EXT_SCISSOR_R        ,
    EXT_SCISSOR_B        ,
    DEST_CMP_FN          ,
    ASIC_ID              ,
    LINEDRAW             ,
    SEQ_IND              ,
    HI_SEQ_ADDR          ,
    SEQ_DATA             ,
    regVGA_BASE_IO_PORT  ,
    regVGA_END_BREAK_PORT,
    reg1CE               ,              // ati_reg == 0x1CE
    reg1CF               ,              // ati_reg == 0x1CF
    EXT_CUR_Y            ,
    reg3CE               ,              // 

// Internal registers (read only, for test purposes only)
    _PAR_FIFO_DATA       ,
    _PAR_FIFO_ADDR       ,
    _MAJOR_DEST_CNT      ,
    _MAJOR_SRC_CNT       ,
    _MINOR_DEST_CNT      ,
    _MINOR_SRC_CNT       ,
    _HW_TEST             
    };

// define the registers located at the same I/O addresses
#define    H_TOTAL                      DISP_STATUS          
#define    HORZ_CURSOR_POSN             CONFIG_STATUS_1      
#define    VERT_CURSOR_POSN             CONFIG_STATUS_2      
#define    FIFO_TEST_DATA               CURSOR_COLOR_0       
#define    MISC_OPTIONS                 FIFO_OPT             
#define    FIFO_TEST_TAG                EXT_CURSOR_COLOR_0   
#define    SUBSYS_STAT                  SUBSYS_CNTL          
#define    SCRATCH_PAD_0                ROM_ADDR_1           
#define    SCRATCH_PAD_1                ROM_ADDR_2           
#define    HORZ_OVERSCAN                EXT_GE_STATUS        
#define    GE_STAT                      CMD
#define    GE_OFFSET_HI                 BOUNDS_LEFT          
#define    GE_PITCH                     BOUNDS_TOP           
#define    EXT_GE_CONFIG                BOUNDS_RIGHT         
#define    MISC_CNTL                    BOUNDS_BOTTOM        
#define    DEST_Y                       SRC_Y                
#define    AXSTP                        SRC_Y                
#define    DEST_X                       SRC_X                
#define    DIASTP                       SRC_X                
#define    R_EXT_GE_CONFIG              PATT_DATA            
#define    EXT_FIFO_STATUS              LINEDRAW_INDEX       
#define    R_H_TOTAL                    SRC_X_START          
#define    R_H_DISP                     SRC_X_START          
#define    R_H_SYNC_STRT                ALU_BG_FN           
#define    R_H_SYNC_WID                 ALU_FG_FN            
#define    MEM_CNTL                     MULTIFUNC_CNTL       
#define    R_V_TOTAL                    SRC_Y_DIR            
#define    EXT_SHORT_STROKE             EXT_SSV              
#define    R_V_DISP                     EXT_SSV              
#define    R_V_SYNC_STRT                SCAN_X               
#define    VERT_LINE_CNTR               DP_CONFIG            
#define    R_V_SYNC_WID                 PATT_LENGTH          
#define    R_SRC_X                      EXT_SCISSOR_L        
#define    R_SRC_Y                      EXT_SCISSOR_T        
#define    EXT_SRC_Y                    ASIC_ID



//---------------------------------------------------------
//---------------------------------------------------------
//  Define the ASIC revisions into something Useful
//  Values are reported by the ASIC_ID register.

#define MACH32_REV3             0
#define MACH32_REV5             1               // not in production
#define MACH32_REV6             2


//---------------------------------------------------------
//

#define MIX_FN_NOT_D         0x0000 //NOT dest
#define MIX_FN_ZERO          0x0001 //dest = 0
#define MIX_FN_ONE           0x0002 //dest = 1
#define MIX_FN_LEAVE_ALONE   0x0003 //dest
#define MIX_FN_NOT_S         0x0004 //NOT source
#define MIX_FN_XOR           0x0005 //source XOR dest
#define MIX_FN_XNOR          0x0006 //source XOR  NOT dest
#define MIX_FN_PAINT         0x0007 //source
#define MIX_FN_NAND          0x0008 //NOT source OR NOT dest
#define MIX_FN_D_OR_NOT_S    0x0009 //NOT source OR     dest
#define MIX_FN_NOT_D_OR_S    0x000A //source OR NOT dest
#define MIX_FN_OR            0x000B //source OR  dest
#define MIX_FN_AND           0x000C //dest AND source
#define MIX_FN_NOT_D_AND_S   0x000D //NOT dest AND source
#define MIX_FN_D_AND_NOT_S   0x000E //dest AND NOT source
#define MIX_FN_NOR           0x000F //NOT dest AND NOT source
#define MIX_FN_MIN           0x0010 //minimum
#define MIX_FN_SUBSZ         0x0011 //(dest - source), with saturate
#define MIX_FN_SUBDZ         0x0012 //(source - dest), with saturate
#define MIX_FN_ADDS          0x0013 //add with saturation
#define MIX_FN_MAX           0x0014 //maximum

//
//
//---------------------------------------------------------
//
//Following are the FIFO checking macros:
//
#define ONE_WORD             0x8000 
#define TWO_WORDS            0xC000 
#define THREE_WORDS          0xE000 
#define FOUR_WORDS           0xF000 
#define FIVE_WORDS           0xF800 
#define SIX_WORDS            0xFC00 
#define SEVEN_WORDS          0xFE00 
#define EIGHT_WORDS          0xFF00 
#define NINE_WORDS           0xFF80 
#define TEN_WORDS            0xFFC0 
#define ELEVEN_WORDS         0xFFE0 
#define TWELVE_WORDS         0xFFF0 
#define THIRTEEN_WORDS       0xFFF8 
#define FOURTEEN_WORDS       0xFFFC 
#define FIFTEEN_WORDS        0xFFFE 
#define SIXTEEN_WORDS        0xFFFF 
//
//
//
//---------------------------------------
//
//
// Draw Command (IBM 8514 compatible CMD register)
//
// opcode field
#define OP_CODE              0xE000 
#define SHIFT_op_code        0x000D 
#define DRAW_SETUP           0x0000 
#define DRAW_LINE            0x2000 
#define FILL_RECT_H1H4       0x4000 
#define FILL_RECT_V1V2       0x6000 
#define FILL_RECT_V1H4       0x8000 
#define DRAW_POLY_LINE       0xA000 
#define BITBLT_OP            0xC000 
#define DRAW_FOREVER         0xE000 
// swap field
#define LSB_FIRST            0x1000 
// data width field
#define DATA_WIDTH           0x0200 
#define BIT16                0x0200 
#define BIT8                 0x0000 
// CPU wait field
#define CPU_WAIT             0x0100 
// octant field
#define OCTANT               0x00E0 
#define SHIFT_octant         0x0005 
#define YPOSITIVE            0x0080 
#define YMAJOR               0x0040 
#define XPOSITIVE            0x0020 
// draw field
#define DRAW                 0x0010 
// direction field
#define DIR_TYPE             0x0008 
#define DEGREE               0x0008 
#define XY                   0x0000 
#define RECT_RIGHT_AND_DOWN  0x00E0 // quadrant 3
#define RECT_LEFT_AND_UP     0x0000 // quadrant 1
// last pel off field
#define SHIFT_last_pel_off   0x0002 
#define LAST_PEL_OFF         0x0004 
#define LAST_PEL_ON          0x0000 
#define LAST_PIXEL_OFF       0x0004
#define LAST_PIXEL_ON        0x0000
#define MULTIPLE_PIXELS      0x0002
#define SINGLE_PIXEL         0x0000

// pixel mode
#define PIXEL_MODE           0x0002 
#define MULTI                0x0002 
#define SINGLE               0x0000 
// read/write
#define RW                   0x0001 
#define WRITE                0x0001 
#define READ                 0x0000 
//
// ---------------------------------------------------------
//


//
// GE_STAT (9AE8) is set if the engine is busy.
//
#define HARDWARE_BUSY   0x0200
#define DATA_READY      0x0100

/*
 * Miscelaneous Options (MISC_OPTIONS)
 */
#define MEM_SIZE_ALIAS      0x0000C
#define MEM_SIZE_STRIPPED   0x0FFF3
#define MEM_SIZE_512K       0x00000
#define MEM_SIZE_1M         0x00004
#define MEM_SIZE_2M         0x00008
#define MEM_SIZE_4M         0x0000C
#define BLK_WR_ENA          0x00400

//
// Extended Graphics Engine Status (EXT_GE_STATUS)
//
#define POINTS_INSIDE        0x8000 
#define EE_DATA_IN           0x4000 
#define GE_ACTIVE            0x2000 
#define CLIP_ABOVE           0x1000 
#define CLIP_BELOW           0x0800 
#define CLIP_LEFT            0x0400 
#define CLIP_RIGHT           0x0200 
#define CLIP_FLAGS           0x1E00 
#define CLIP_INSIDE          0x0100 
#define EE_CRC_VALID         0x0080 
#define CLIP_OVERRUN         0x000F 

/*
 * Extended Graphics Engine Configuration (EXT_GE_CONFIG)
 */
#define PIX_WIDTH_4BPP      0x0000
#define PIX_WIDTH_8BPP      0x0010
#define PIX_WIDTH_16BPP     0x0020
#define PIX_WIDTH_24BPP     0x0030
#define ORDER_16BPP_555     0x0000
#define ORDER_16BPP_565     0x0040
#define ORDER_16BPP_655     0x0080
#define ORDER_16BPP_664     0x00C0
#define ORDER_24BPP_RGB     0x0000
#define ORDER_24BPP_RGBx    0x0200
#define ORDER_24BPP_BGR     0x0400
#define ORDER_24BPP_xBGR    0x0600


//
// Datapath Configuration Register (DP_CONFIG) 
#define FG_COLOR_SRC         0xE000 
#define SHIFT_fg_color_src   0x000D 
#define DATA_ORDER           0x1000 
#define DATA_WIDTH           0x0200 
#define BG_COLOR_SRC         0x0180 
#define SHIFT_bg_color_src   0x0007 
#define EXT_MONO_SRC         0x0060 
#define SHIFT_ext_mono_src   0x0005 
#define DRAW                 0x0010 
#define READ_MODE            0x0004 
#define POLY_FILL_MODE       0x0002 
#define READ_WRITE           0x0001
#define SRC_SWAP             0x0800 
//
#define FG_COLOR_SRC_BG      0x0000 // Background Color Register
#define FG_COLOR_SRC_FG      0x2000 // Foreground Color Register
#define FG_COLOR_SRC_HOST    0x4000 // CPU Data Transfer Reg
#define FG_COLOR_SRC_BLIT    0x6000 // VRAM blit source
#define FG_COLOR_SRC_GS      0x8000 // Grey-scale mono blit
#define FG_COLOR_SRC_PATT    0xA000 // Color Pattern Shift Reg
#define FG_COLOR_SRC_CLUH    0xC000 // Color lookup of Host Data
#define FG_COLOR_SRC_CLUB    0xE000 // Color lookup of blit src
//
#define BG_COLOR_SRC_BG      0x0000 // Background Color Reg
#define BG_COLOR_SRC_FG      0x0080 // Foreground Color Reg
#define BG_COLOR_SRC_HOST    0x0100 // CPU Data Transfer Reg
#define BG_COLOR_SRC_BLIT    0x0180 // VRAM blit source

//
// Note that "EXT_MONO_SRC" and "MONO_SRC" are mutually destructive, but that
// "EXT_MONO_SRC" selects the ATI pattern registers.
//
#define EXT_MONO_SRC_ONE     0x0000 // Always '1'
#define EXT_MONO_SRC_PATT    0x0020 // ATI Mono Pattern Regs
#define EXT_MONO_SRC_HOST    0x0040 // CPU Data Transfer Reg
#define EXT_MONO_SRC_BLIT    0x0060 // VRAM Blit source plane

//
// Linedraw Options Register (LINEDRAW_OPT) 
//
#define CLIP_MODE            0x0600 
#define SHIFT_clip_mode      0x0009 
#define CLIP_MODE_DIS        0x0000 
#define CLIP_MODE_LINE       0x0200 
#define CLIP_MODE_PLINE      0x0400 
#define CLIP_MODE_PATT       0x0600 
#define BOUNDS_RESET         0x0100 
#define OCTANT               0x00E0 
#define SHIFT_ldo_octant     0x0005 
#define YDIR                 0x0080 
#define XMAJOR               0x0040 
#define XDIR                 0x0020 
#define DIR_TYPE             0x0008 
#define DIR_TYPE_DEGREE      0x0008 
#define DIR_TYPE_OCTANT      0x0000 
#define LAST_PEL_OFF         0x0004 
#define POLY_MODE            0x0002 
//
//

//--------------  was in 68801.H    --------------------------------------



//*** 8514  EEPROM command codes *************************************
//      format is     0111 1100 0000b
#define EE_READ             0x0600  // read address
#define EE_ERASE            0x0700  // erase address
#define EE_WRITE            0x0500  // write address
#define EE_ENAB             0x0980  // enable EEPROM
#define EE_DISAB            0x0800  // disable EEPROM


//-------------------------------------------------------------------------
//                 REGISTER  bit definitions


// Configuration Status   1  (CONFIG_STATUS_1)
// 
//
#define ROM_LOCATION         0xFE00 
#define SHIFT_rom_location   0x0009 
#define ROM_PAGE_ENA         0x0100 
#define ROM_ENA              0x0080 
#define MEM_INSTALLED        0x0060 
#define SHIFT_mem_installed  0x0005 
#define MEM_INSTALLED_128k   0x0000 
#define MEM_INSTALLED_256k   0x0020 
#define MEM_INSTALLED_512k   0x0040 
#define MEM_INSTALLED_1024k  0x0060 
#define DRAM_ENA             0x0010 
#define EEPROM_ENA           0x0008 
#define MC_BUS               0x0004 
#define BUS_16               0x0002 
#define CLK_MODE             0x0001 
//
//
// Configuration Status 2 (CONFIG_STATUS_2)
// 
//
//
#define FLASH_ENA            0x0010 
#define WRITE_PER_BIT        0x0008 
#define EPROM16_ENA          0x0004 
#define HIRES_BOOT           0x0002 
#define SHARE_CLOCK          0x0001 





//-------------------------------------------------------------------------
//  For the Mach32 - 68800 class of adapters,  the eeprom location
//  is different for an 8514/Ultra in an 8 bit bus, 16 bit bus, and 68800.
//
#define EE_DATA_IN         0x4000       // Inputs are OK

// Mach 32 values
#define EE_SELECT_M32      8
#define EE_CS_M32          4
#define EE_CLK_M32         2
#define EE_DATA_OUT_M32    1

// Mach 8 values  in a 16 bit bus
#define EE_SELECT_M8_16    0x8000
#define EE_CS_M8_16        0x4000
#define EE_CLK_M8_16       0x2000
#define EE_DATA_OUT_M8_16  0x1000

// Mach 8 values  in an 8 bit bus  OR jumpered to 8 bit I/O operation
#define EE_SELECT_M8_8     0x80
#define EE_CS_M8_8         0x04
#define EE_CLK_M8_8        0x02
#define EE_DATA_OUT_M8_8   0x01


//-------------------------------------------------------------------------
//  Context indices 
//
#define PATT_COLOR_INDEX      0
#define PATT_MONO_INDEX       16
#define PATT_INDEX_INDEX      19
#define DP_CONFIG_INDEX       27
#define LINEDRAW_OPTION_INDEX 26


//**********************   end  of  AMACH.H   ****************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\amachcx.h ===
//*************************************************************************
//**                                                                     **
//**                             AMACHCX.H                               **
//**                                                                     **
//**     Copyright (c) 1993, ATI Technologies Inc.                       **
//*************************************************************************
//
//  Created from the CH0.H 68800CX header file to get CX and standard
//      register definitions in the same format.
//
//  Created from the 68800.H and 68801.H in the Windows NT Group
//      as a simple merging of the files so ALL Mach8 and Mach32 defines
//      are located in one H file.
//
//  Created the 68800.inc file which includes equates, macros, etc 
//       from the following include files:    
//       8514vesa.inc, vga1regs.inc,  m32regs.inc,  8514.inc
//
// supplement Defines and values to the 68800 Family.
//
// This is a "C" only file and is NOT derived from any Assembler INC files.

  
/**********************       PolyTron RCS Utilities

   $Revision:   1.17  $
   $Date:   15 Apr 1996 16:57:28  $
   $Author:   RWolff  $
   $Log:   S:/source/wnt/ms11/miniport/archive/amachcx.h_v  $
 * 
 *    Rev 1.17   15 Apr 1996 16:57:28   RWolff
 * Added definitions for various revisions of the GX and CX ASICs
 * 
 *    Rev 1.16   01 Mar 1996 12:09:48   RWolff
 * VGA Graphics Index and Graphics Data are now handled as separate
 * registers rather than as offsets into the block of VGA registers.
 * 
 *    Rev 1.15   22 Sep 1995 16:47:08   RWolff
 * Added definitions for AL values of accelerator BIOS functions to
 * allow switching on the low byte of the function.
 * 
 *    Rev 1.14   24 Aug 1995 15:41:12   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 * 
 *    Rev 1.13   24 Feb 1995 12:28:36   RWOLFF
 * Added definitions used for relocatable I/O and 24BPP text banding
 * 
 *    Rev 1.12   20 Feb 1995 18:00:34   RWOLFF
 * Added definition for GX rev. E ASIC.
 * 
 *    Rev 1.11   23 Dec 1994 10:48:02   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.10   18 Nov 1994 11:52:12   RWOLFF
 * Register name change to CLOCK_CNTL to match latest documents, added
 * some new bitfield definitions for registers.
 * 
 *    Rev 1.9   14 Sep 1994 15:20:58   RWOLFF
 * Added definitions for all 32BPP colour orderings.
 * 
 *    Rev 1.8   31 Aug 1994 16:11:08   RWOLFF
 * Removed VGA_SLEEP from enumeration of registers used on Mach 64
 * (we don't access it, and it conflicts with DigiBoard), added
 * support for BGRx in 32BPP (used by TVP3026 DAC).
 * 
 *    Rev 1.7   20 Jul 1994 12:59:38   RWOLFF
 * Added support for multiple I/O base addresses for accelerator registers.
 * 
 *    Rev 1.6   12 May 1994 11:21:22   RWOLFF
 * Added masks for pitch and pixel depth fields of ECX for BIOS_LOAD_CRTC
 * call.
 * 
 *    Rev 1.5   05 May 1994 13:40:40   RWOLFF
 * Added definitions for chip identification register fields.
 * 
 *    Rev 1.4   04 May 1994 10:58:48   RWOLFF
 * Added definitions for MEM_SIZE field in MEM_CNTL register.
 * 
 *    Rev 1.3   27 Apr 1994 13:57:28   RWOLFF
 * Added definitions for offsets of graphics index and graphics data
 * registers from start of block of VGA registers.
 * 
 *    Rev 1.2   14 Mar 1994 16:31:58   RWOLFF
 * Added offset and pitch masks for SRC_OFF_PITCH register.
 * 
 *    Rev 1.1   03 Mar 1994 12:36:40   ASHANMUG
 * Correct GAMMA bit
 * 
 *    Rev 1.0   31 Jan 1994 11:26:34   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.4   24 Jan 1994 18:00:52   RWOLFF
 * Added new definitions for fields introduced in 94/01/19 BIOS document.
 * 
 *    Rev 1.3   14 Jan 1994 15:17:18   RWOLFF
 * Added definition for bit in GEN_TEST_CNTL to enable block write,
 * BIOS function codes now take AH value from a single definition
 * to allow single-point change of all codes, updated function codes
 * to match BIOS version 0.13.
 * 
 *    Rev 1.2   30 Nov 1993 18:09:14   RWOLFF
 * Fixed enumeration of register names, added definitions for more fields in
 * more registers, removed redundant definitions.
 * 
 *    Rev 1.1   05 Nov 1993 13:21:24   RWOLFF
 * Defined and enumerated values now use same naming conventions as AMACH.H
 * 
 *    Rev 1.0   03 Sep 1993 14:26:46   RWOLFF
 * Initial revision.


End of PolyTron RCS section				*****************/


#define REVISION             0x0002             // No one should use this

/*
 * Offsets from start of linear aperture to start of memory-mapped
 * registers on 4M and 8M cards, and offset from start of address
 * space to start of memory-mapped registers when VGA is enabled.
 */
#define OFFSET_4M   0x3FFC00
#define OFFSET_8M   0x7FFC00
#define OFFSET_VGA  0x0BFC00


/*
 * Base addresses for Mach 64 accelerator registers.
 */
#define M64_STD_BASE_ADDR       0x02EC
#define M64_ALT_BASE_ADDR_1     0x01C8
#define M64_ALT_BASE_ADDR_2     0x01CC
#define NUM_BASE_ADDRESSES      3

/*
 * CRTC I/O registers. Only the variable portion
 * of the register is given here. To get the full
 * register, add the base address.
 */

#define IO_CRTC_H_TOTAL_DISP    0x0000
#define IO_CRTC_H_SYNC_STRT_WID 0x0400
#define IO_CRTC_V_TOTAL_DISP    0x0800
#define IO_CRTC_V_SYNC_STRT_WID 0x0C00
#define IO_CRTC_CRNT_VLINE      0x1000
#define IO_CRTC_OFF_PITCH       0x1400
#define IO_CRTC_INT_CNTL        0x1800
#define IO_CRTC_GEN_CNTL        0x1C00

#define IO_OVR_CLR              0x2000
#define IO_OVR_WID_LEFT_RIGHT   0x2400
#define IO_OVR_WID_TOP_BOTTOM   0x2800

#define IO_CUR_CLR0             0x2C00
#define IO_CUR_CLR1             0x3000
#define IO_CUR_OFFSET           0x3400
#define IO_CUR_HORZ_VERT_POSN   0x3800
#define IO_CUR_HORZ_VERT_OFF    0x3C00

#define IO_SCRATCH_REG0         0x4000
#define IO_SCRATCH_REG1         0x4400

#define IO_CLOCK_CNTL           0x4800

#define IO_BUS_CNTL             0x4C00

#define IO_MEM_CNTL             0x5000
#define IO_MEM_VGA_WP_SEL       0x5400
#define IO_MEM_VGA_RP_SEL       0x5800

#define IO_DAC_REGS             0x5C00
#define IO_DAC_CNTL             0x6000

#define IO_GEN_TEST_CNTL        0x6400

#define IO_CONFIG_CNTL          0x6800
#define IO_CONFIG_CHIP_ID       0x6C00
#define IO_CONFIG_STAT0         0x7000
#define IO_CONFIG_STAT1         0x7400


// CRTC MEM Registers


#define MM_CRTC_H_TOTAL_DISP    0x0000
#define MM_CRTC_H_SYNC_STRT_WID 0x0001
#define MM_CRTC_V_TOTAL_DISP    0x0002
#define MM_CRTC_V_SYNC_STRT_WID 0x0003
#define MM_CRTC_CRNT_VLINE      0x0004
#define MM_CRTC_OFF_PITCH       0x0005
#define MM_CRTC_INT_CNTL        0x0006
#define MM_CRTC_GEN_CNTL        0x0007

#define MM_OVR_CLR              0x0010
#define MM_OVR_WID_LEFT_RIGHT   0x0011
#define MM_OVR_WID_TOP_BOTTOM   0x0012

#define MM_CUR_CLR0             0x0018
#define MM_CUR_CLR1             0x0019
#define MM_CUR_OFFSET           0x001A
#define MM_CUR_HORZ_VERT_POSN   0x001B
#define MM_CUR_HORZ_VERT_OFF    0x001C

#define MM_SCRATCH_REG0         0x0020
#define MM_SCRATCH_REG1         0x0021

#define MM_CLOCK_CNTL           0x0024

#define MM_BUS_CNTL             0x0028

#define MM_MEM_CNTL             0x002C
#define MM_MEM_VGA_WP_SEL       0x002D
#define MM_MEM_VGA_RP_SEL       0x002E

#define MM_DAC_REGS             0x0030
#define MM_DAC_CNTL             0x0031

#define MM_GEN_TEST_CNTL        0x0034

/*
 * This register does not exist in memory-mapped form,
 * but on cards with relocatable I/O, the I/O index of
 * each register matches its memory-mapped index. This
 * register was assigned an otherwise unused index for
 * this purpose.
 */
#define MM_CONFIG_CNTL          0x0037

#define MM_CONFIG_CHIP_ID       0x0038
#define MM_CONFIG_STAT0         0x0039
#define MM_CONFIG_STAT1         0x003A




#define MM_DST_OFF_PITCH        0x0040
#define MM_DST_X                0x0041
#define MM_DST_Y                0x0042
#define MM_DST_Y_X              0x0043
#define MM_DST_WIDTH            0x0044
#define MM_DST_HEIGHT           0x0045
#define MM_DST_HEIGHT_WIDTH     0x0046
#define MM_DST_X_WIDTH          0x0047
#define MM_DST_BRES_LNTH        0x0048
#define MM_DST_BRES_ERR         0x0049
#define MM_DST_BRES_INC         0x004A
#define MM_DST_BRES_DEC         0x004B
#define MM_DST_CNTL             0x004C

#define MM_SRC_OFF_PITCH        0x0060
#define MM_SRC_X                0x0061
#define MM_SRC_Y                0x0062
#define MM_SRC_Y_X              0x0063
#define MM_SRC_WIDTH1           0x0064
#define MM_SRC_HEIGHT1          0x0065
#define MM_SRC_HEIGHT1_WIDTH1   0x0066
#define MM_SRC_X_START          0x0067
#define MM_SRC_Y_START          0x0068
#define MM_SRC_Y_X_START        0x0069
#define MM_SRC_WIDTH2           0x006A
#define MM_SRC_HEIGHT2          0x006B
#define MM_SRC_HEIGHT2_WIDTH2   0x006C
#define MM_SRC_CNTL             0x006D

#define MM_HOST_DATA0           0x0080
#define MM_HOST_DATA1           0x0081
#define MM_HOST_DATA2           0x0082
#define MM_HOST_DATA3           0x0083
#define MM_HOST_DATA4           0x0084
#define MM_HOST_DATA5           0x0085
#define MM_HOST_DATA6           0x0086
#define MM_HOST_DATA7           0x0087
#define MM_HOST_DATA8           0x0088
#define MM_HOST_DATA9           0x0089
#define MM_HOST_DATA10          0x008A
#define MM_HOST_DATA11          0x008B
#define MM_HOST_DATA12          0x008C
#define MM_HOST_DATA13          0x008D
#define MM_HOST_DATA14          0x008E
#define MM_HOST_DATA15          0x008F
#define MM_HOST_CNTL            0x0090

#define MM_PAT_REG0             0x00A0
#define MM_PAT_REG1             0x00A1
#define MM_PAT_CNTL             0x00A2

#define MM_SC_LEFT              0x00A8
#define MM_SC_RIGHT             0x00A9
#define MM_SC_LEFT_RIGHT        0x00AA
#define MM_SC_TOP               0x00AB
#define MM_SC_BOTTOM            0x00AC
#define MM_SC_TOP_BOTTOM        0x00AD

#define MM_DP_BKGD_CLR          0x00B0
#define MM_DP_FRGD_CLR          0x00B1
#define MM_DP_WRITE_MASK        0x00B2
#define MM_DP_CHAIN_MASK        0x00B3
#define MM_DP_PIX_WIDTH         0x00B4
#define MM_DP_MIX               0x00B5
#define MM_DP_SRC               0x00B6

#define MM_CLR_CMP_CLR          0x00C0
#define MM_CLR_CMP_MSK          0x00C1
#define MM_CLR_CMP_CNTL         0x00C2

#define MM_FIFO_STAT            0x00C4

#define MM_CONTEXT_MASK         0x00C8
#define MM_CONTEXT_SAVE_CNTL    0x00CA
#define MM_CONTEXT_LOAD_CNTL    0x00CB

#define MM_GUI_TRAJ_CNTL        0x00CC
#define MM_GUI_STAT             0x00CE

/*
 * VGAWonder-compatible registers (all in I/O space).
 */
#define IO_VGA_SLEEP            0x0102
#define IO_VGA_BASE_IO_PORT     0x03B0
#define IO_VGA_START_BREAK_PORT 0x03BB
#define IO_VGA_END_BREAK_PORT   0x03C0
#define IO_VGA_MAX_IO_PORT      0x03DF

/*
 * VGA Sequencer index/data registers (most frequently used
 * of VGAWonder-compatible registers).
 */
#define IO_VGA_SEQ_IND          0x03C4
#define IO_VGA_SEQ_DATA         0x03C5

/*
 * VGA Graphics index/data registers (another frequently used
 * VGA register pair)
 */
#define IO_VGA_GRAX_IND         0x03CE
#define IO_VGA_GRAX_DATA        0x03CF

/*
 * ATI extended registers
 */
#define IO_reg1CE               0x01CE
#define IO_reg1CF               0x01CF



/*
 * Define the registers as subscripts to an array
 */
enum {
    VGA_BASE_IO_PORT=0      ,
    VGA_END_BREAK_PORT      ,
    VGA_SEQ_IND             ,
    VGA_SEQ_DATA            ,
    VGA_GRAX_IND            ,
    VGA_GRAX_DATA           ,
    reg1CE                  ,
    reg1CF                  ,
    CRTC_H_TOTAL_DISP       ,
    CRTC_H_SYNC_STRT_WID    ,
    CRTC_V_TOTAL_DISP       ,
    CRTC_V_SYNC_STRT_WID    ,
    CRTC_CRNT_VLINE         ,
    CRTC_OFF_PITCH          ,
    CRTC_INT_CNTL           ,
    CRTC_GEN_CNTL           ,
    OVR_CLR                 ,
    OVR_WID_LEFT_RIGHT      ,
    OVR_WID_TOP_BOTTOM      ,
    CUR_CLR0                ,
    CUR_CLR1                ,
    CUR_OFFSET              ,
    CUR_HORZ_VERT_POSN      ,
    CUR_HORZ_VERT_OFF       ,
    SCRATCH_REG0            ,
    SCRATCH_REG1            ,
    CLOCK_CNTL              ,
    BUS_CNTL                ,
    MEM_CNTL                ,
    MEM_VGA_WP_SEL          ,
    MEM_VGA_RP_SEL          ,
    DAC_REGS                ,
    DAC_CNTL                ,
    GEN_TEST_CNTL           ,
    CONFIG_CNTL             ,
    CONFIG_CHIP_ID          ,
    CONFIG_STAT0            ,
    CONFIG_STAT1            ,
    DST_OFF_PITCH           ,
    DST_X                   ,
    DST_Y                   ,
    DST_Y_X                 ,
    DST_WIDTH               ,
    DST_HEIGHT              ,
    DST_HEIGHT_WIDTH        ,
    DST_X_WIDTH             ,
    DST_BRES_LNTH           ,
    DST_BRES_ERR            ,
    DST_BRES_INC            ,
    DST_BRES_DEC            ,
    DST_CNTL                ,
    SRC_OFF_PITCH           ,
    SRC_X                   ,
    SRC_Y                   ,
    SRC_Y_X                 ,
    SRC_WIDTH1              ,
    SRC_HEIGHT1             ,
    SRC_HEIGHT1_WIDTH1      ,
    SRC_X_START             ,
    SRC_Y_START             ,
    SRC_Y_X_START           ,
    SRC_WIDTH2              ,
    SRC_HEIGHT2             ,
    SRC_HEIGHT2_WIDTH2      ,
    SRC_CNTL                ,
    HOST_DATA0              ,
    HOST_DATA1              ,
    HOST_DATA2              ,
    HOST_DATA3              ,
    HOST_DATA4              ,
    HOST_DATA5              ,
    HOST_DATA6              ,
    HOST_DATA7              ,
    HOST_DATA8              ,
    HOST_DATA9              ,
    HOST_DATA10             ,
    HOST_DATA11             ,
    HOST_DATA12             ,
    HOST_DATA13             ,
    HOST_DATA14             ,
    HOST_DATA15             ,
    HOST_CNTL               ,
    PAT_REG0                ,
    PAT_REG1                ,
    PAT_CNTL                ,
    SC_LEFT                 ,
    SC_RIGHT                ,
    SC_LEFT_RIGHT           ,
    SC_TOP                  ,
    SC_BOTTOM               ,
    SC_TOP_BOTTOM           ,
    DP_BKGD_CLR             ,
    DP_FRGD_CLR             ,
    DP_WRITE_MASK           ,
    DP_CHAIN_MASK           ,
    DP_PIX_WIDTH            ,
    DP_MIX                  ,
    DP_SRC                  ,
    CLR_CMP_CLR             ,
    CLR_CMP_MSK             ,
    CLR_CMP_CNTL            ,
    FIFO_STAT               ,
    CONTEXT_MASK            ,
    CONTEXT_SAVE_CNTL       ,
    CONTEXT_LOAD_CNTL       ,
    GUI_TRAJ_CNTL           ,
    GUI_STAT
};


/*
 * Bit fields used in the registers.
 *
 * CRT Offset and Pitch
 */
#define CRTC_OFF_PITCH_Offset   0x000FFFFF
#define CRTC_OFF_PITCH_Pitch    0xFFC00000

/*
 * CRT General Control
 */
#define CRTC_GEN_CNTL_DblScan   0x00000001
#define CRTC_GEN_CNTL_Interlace 0x00000002
#define CRTC_GEN_CNTL_HSynDisab 0x00000004
#define CRTC_GEN_CNTL_VSynDisab 0x00000008
#define CRTC_GEN_CNTL_CompSync  0x00000010
#define CRTC_GEN_CNTL_MuxMode   0x00000020
#define CRTC_GEN_CNTL_DispDisab 0x00000040
#define CRTC_GEN_CNTL_DepthMask 0x00000700
#define CRTC_GEN_CNTL_Dep4      0x00000100
#define CRTC_GEN_CNTL_Dep8      0x00000200
#define CRTC_GEN_CNTL_Dep15_555 0x00000300
#define CRTC_GEN_CNTL_Dep16_565 0x00000400
#define CRTC_GEN_CNTL_Dep24     0x00000500
#define CRTC_GEN_CNTL_Dep32     0x00000600
#define CRTC_GEN_CNTL_ShowVga   0x00000000
#define CRTC_GEN_CNTL_ShowAcc   0x01000000
#define CRTC_GEN_CNTL_CrtcEna   0x02000000

/*
 * Clock control
 */
#define CLOCK_CNTL_ClockStrobe  0x00000040

/*
 * Memory Control
 */
#define MEM_CNTL_MemSizeMsk     0x00000007
#define MEM_CNTL_MemSize512k    0x00000000
#define MEM_CNTL_MemSize1Mb     0x00000001
#define MEM_CNTL_MemSize2Mb     0x00000002
#define MEM_CNTL_MemSize4Mb     0x00000003
#define MEM_CNTL_MemSize6Mb     0x00000004
#define MEM_CNTL_MemSize8Mb     0x00000005
#define MEM_CNTL_MemBndryMsk    0x00070000
#define MEM_CNTL_MemBndryEn     0x00040000
#define MEM_CNTL_MemBndry0k     0x00000000
#define MEM_CNTL_MemBndry256k   0x00010000
#define MEM_CNTL_MemBndry512k   0x00020000
#define MEM_CNTL_MemBndry1Mb    0x00030000

/*
 * DAC control
 */
#define DAC_CNTL_ExtSelMask     0x00000003
#define DAC_CNTL_ExtSelStrip    ~DAC_CNTL_ExtSelMask
#define DAC_CNTL_ExtSelRS2      0x00000001
#define DAC_CNTL_ExtSelRS3      0x00000002
#define DAC_CNTL_VgaAddrEna     0x00002000

/*
 * General and Test control
 */
#define GEN_TEST_CNTL_CursorEna     0x00000080
#define GEN_TEST_CNTL_GuiEna        0x00000100
#define GEN_TEST_CNTL_BlkWrtEna     0x00000200
#define GEN_TEST_CNTL_GuiRegEna     0x00020000
#define GEN_TEST_CNTL_TestMode      0x00700000
#define GEN_TEST_CNTL_TestMode0     0x00000000
#define GEN_TEST_CNTL_TestMode1     0x00100000
#define GEN_TEST_CNTL_TestMode2     0x00200000
#define GEN_TEST_CNTL_TestMode3     0x00300000
#define GEN_TEST_CNTL_TestMode4     0x00400000
#define GEN_TEST_CNTL_MemWR         0x01000000
#define GEN_TEST_CNTL_MemStrobe     0x02000000
#define GEN_TEST_CNTL_DstSSEna      0x04000000
#define GEN_TEST_CNTL_DstSSStrobe   0x08000000
#define GEN_TEST_CNTL_SrcSSEna      0x10000000
#define GEN_TEST_CNTL_SrcSSStrobe   0x20000000

/*
 * Configuration Control
 */
#define CONFIG_CNTL_LinApDisab      0x00000000
#define CONFIG_CNTL_LinAp4M         0x00000001
#define CONFIG_CNTL_LinAp8M         0x00000002
#define CONFIG_CNTL_LinApMask       0x00000003
#define CONFIG_CNTL_VgaApDisab      0x00000000
#define CONFIG_CNTL_VgaApEnab       0x00000004
#define CONFIG_CNTL_LinApLocMask    0x00003FF0
#define CONFIG_CNTL_LinApLocShift       4
#define CONFIG_CNTL_CardIDMask      0x00070000
#define CONFIG_CNTL_VgaEnabled      0x00000000
#define CONFIG_CNTL_VgaDisabled     0x00080000

/*
 * Chip identification
 */
#define CONFIG_CHIP_ID_TypeMask     0x0000FFFF
#define CONFIG_CHIP_ID_ClassMask    0x00FF0000
#define CONFIG_CHIP_ID_RevMask      0xFF000000
#define CONFIG_CHIP_ID_TypeGX       0x000000D7
#define CONFIG_CHIP_ID_TypeCX       0x00000057
#define CONFIG_CHIP_ID_RevC         0x00000000
#define CONFIG_CHIP_ID_RevD         0x01000000
#define CONFIG_CHIP_ID_RevE         0x02000000
#define CONFIG_CHIP_ID_RevF         0x03000000
#define CONFIG_CHIP_ID_GXRevC       CONFIG_CHIP_ID_TypeGX | CONFIG_CHIP_ID_RevC
#define CONFIG_CHIP_ID_GXRevD       CONFIG_CHIP_ID_TypeGX | CONFIG_CHIP_ID_RevD
#define CONFIG_CHIP_ID_GXRevE       CONFIG_CHIP_ID_TypeGX | CONFIG_CHIP_ID_RevE
#define CONFIG_CHIP_ID_GXRevF       CONFIG_CHIP_ID_TypeGX | CONFIG_CHIP_ID_RevF


//
// ASIC IDs (upper byte of CONFIG_CHIP_ID)
//
#define ASIC_ID_NEC_VT_A3           0x08000000
#define ASIC_ID_NEC_VT_A4           0x48000000
#define ASIC_ID_SGS_VT_A4           0x40000000

/*
 * Configuration status register 0
 */
#define CONFIG_STAT0_BusMask        0x00000007
#define CONFIG_STAT0_MemTypeMask    0x00000038
#define CONFIG_STAT0_DRAM256x4      0x00000000
#define CONFIG_STAT0_VRAM256xAny    0x00000008
#define CONFIG_STAT0_VRAM256x16ssr  0x00000010
#define CONFIG_STAT0_DRAM256x16     0x00000018
#define CONFIG_STAT0_GDRAM256x16    0x00000020
#define CONFIG_STAT0_EVRAM256xAny   0x00000028
#define CONFIG_STAT0_EVRAM256x16ssr 0x00000030
#define CONFIG_STAT0_MemTypeShift       3
#define CONFIG_STAT0_DualCasEna     0x00000040
#define CONFIG_STAT0_LocalBusOpt    0x00000180
#define CONFIG_STAT0_DacTypeMask    0x00000E00
#define CONFIG_STAT0_DacTypeShift       9
#define CONFIG_STAT0_CardId         0x00007000
#define CONFIG_STAT0_NoTristate     0x00008000
#define CONFIG_STAT0_ExtRomAddr     0x003F0000
#define CONFIG_STAT0_RomDisab       0x00400000
#define CONFIG_STAT0_VgaEna         0x00800000
#define CONFIG_STAT0_VlbCfg         0x01000000
#define CONFIG_STAT0_ChipEna        0x02000000
#define CONFIG_STAT0_NoReadDelay    0x04000000
#define CONFIG_STAT0_RomOption      0x08000000
#define CONFIG_STAT0_BusOption      0x10000000
#define CONFIG_STAT0_LBDacWriteEna  0x20000000
#define CONFIG_STAT0_VlbRdyDisab    0x40000000
#define CONFIG_STAT0_Ap4GigRange    0x80000000

/*
 * Destination width
 */
#define DST_WIDTH_Disable       0x80000000

/*
 * Destination control
 */
#define DST_CNTL_XDir           0x00000001
#define DST_CNTL_YDir           0x00000002
#define DST_CNTL_YMajor         0x00000004
#define DST_CNTL_XTile          0x00000008
#define DST_CNTL_YTile          0x00000010
#define DST_CNTL_LastPel        0x00000020
#define DST_CNTL_PolyEna        0x00000040
#define DST_CNTL_24_RotEna      0x00000080
#define DST_CNTL_24_Rot         0x00000700

/*
 * Source offset and pitch
 */
#define SRC_OFF_PITCH_Offset    0x000FFFFF
#define SRC_OFF_PITCH_Pitch     0xFFC00000

/*
 * Source control
 */
#define SRC_CNTL_PatEna         0x0001
#define SRC_CNTL_PatRotEna      0x0002
#define SRC_CNTL_LinearEna      0x0004
#define SRC_CNTL_ByteAlign      0x0008
#define SRC_CNTL_LineXDir       0x0010

/*
 * Host control
 */
#define HOST_CNTL_ByteAlign     0x0001

/*
 * Pattern control
 */
#define PAT_CNTL_MonoEna        0x0001
#define PAT_CNTL_Clr4x2Ena      0x0002
#define PAT_CNTL_Clr8x1Ena      0x0004

/*
 * Datapath Source selections
 */
#define DP_SRC_BkgdClr          0x0000
#define DP_SRC_FrgdClr          0x0001
#define DP_SRC_Host             0x0002
#define DP_SRC_Blit             0x0003
#define DP_SRC_Pattern          0x0004
#define DP_SRC_Always1          0x00000000
#define DP_SRC_MonoPattern      0x00010000
#define DP_SRC_MonoHost         0x00020000
#define DP_SRC_MonoBlit         0x00030000

/*
 * Colour Comparison control
 */
#define CLR_CMP_CNTL_Source     0x00010000

/*
 * Context load and store pointers
 */
#define CONTEXT_LOAD_Cmd        0x00030000
#define CONTEXT_LOAD_CmdLoad    0x00010000
#define CONTEXT_LOAD_CmdBlt     0x00020000
#define CONTEXT_LOAD_CmdLine    0x00030000
#define CONTEXT_LOAD_Disable    0x80000000

//---------------------------------------------------------
//---------------------------------------------------------
//  Define the ASIC revisions into something Useful

#define MACH32_REV3             0
#define MACH32_REV5             1               // not in production
#define MACH32_REV6             2
#define MACH32_CX               4


//---------------------------------------------------------
//  Mix functions

#define MIX_FN_NOT_D         0x0000 //NOT dest
#define MIX_FN_ZERO          0x0001 //dest = 0
#define MIX_FN_ONE           0x0002 //dest = 1
#define MIX_FN_LEAVE_ALONE   0x0003 //dest
#define MIX_FN_NOT_S         0x0004 //NOT source
#define MIX_FN_XOR           0x0005 //source XOR dest
#define MIX_FN_XNOR          0x0006 //source XOR  NOT dest
#define MIX_FN_PAINT         0x0007 //source
#define MIX_FN_NAND          0x0008 //NOT source OR NOT dest
#define MIX_FN_D_OR_NOT_S    0x0009 //NOT source OR     dest
#define MIX_FN_NOT_D_OR_S    0x000A //source OR NOT dest
#define MIX_FN_OR            0x000B //source OR  dest
#define MIX_FN_AND           0x000C //dest AND source
#define MIX_FN_NOT_D_AND_S   0x000D //NOT dest AND source
#define MIX_FN_D_AND_NOT_S   0x000E //dest AND NOT source
#define MIX_FN_NOR           0x000F //NOT dest AND NOT source
#define MIX_FN_AVG           0x0017 // (dest+source)/2

//
//
//---------------------------------------------------------
//

/*
 * Values for DP_PIX_WIDTH register
 */
#define DP_PIX_WIDTH_Mono       0x00000000
#define DP_PIX_WIDTH_4bpp       0x00000001
#define DP_PIX_WIDTH_8bpp       0x00000002
#define DP_PIX_WIDTH_15bpp      0x00000003
#define DP_PIX_WIDTH_16bpp      0x00000004
#define DP_PIX_WIDTH_32bpp      0x00000006
#define DP_PIX_WIDTH_NibbleSwap 0x01000000

/*
 * Values for DP_SRC register
 */
#define DP_BKGD_SRC_BG      0x00000000  // Background Color Reg
#define DP_BKGD_SRC_FG      0x00000001  // Foreground Color Reg
#define DP_BKGD_SRC_HOST    0x00000002  // Host data
#define DP_BKGD_SRC_BLIT    0x00000003  // VRAM blit source
#define DP_BKGD_SRC_PATT    0x00000004  // Pattern registers
//
#define DP_FRGD_SRC_BG      0x00000000  // Background Color Register
#define DP_FRGD_SRC_FG      0x00000100  // Foreground Color Register
#define DP_FRGD_SRC_HOST    0x00000200  // Host data
#define DP_FRGD_SRC_BLIT    0x00000300  // VRAM blit source
#define DP_FRGD_SRC_PATT    0x00000400  // Pattern registers
//
#define DP_MONO_SRC_ONE     0x00000000  // Always '1'
#define DP_MONO_SRC_PATT    0x00010000  // Pattern registers
#define DP_MONO_SRC_HOST    0x00020000  // Host data
#define DP_MONO_SRC_BLIT    0x00030000  // Blit source

/*
 * Values for FIFO_STAT register
 */
#define ONE_WORD            0x00008000  /* One free FIFO entry */
#define TWO_WORDS           0x0000C000
#define THREE_WORDS         0x0000E000
#define FOUR_WORDS          0x0000F000
#define FIVE_WORDS          0x0000F800
#define SIX_WORDS           0x0000FC00
#define SEVEN_WORDS         0x0000FE00
#define EIGHT_WORDS         0x0000FF00
#define NINE_WORDS          0x0000FF80
#define TEN_WORDS           0x0000FFC0
#define ELEVEN_WORDS        0x0000FFE0
#define TWELVE_WORDS        0x0000FFF0
#define THIRTEEN_WORDS      0x0000FFF8
#define FOURTEEN_WORDS      0x0000FFFC
#define FIFTEEN_WORDS       0x0000FFFE
#define SIXTEEN_WORDS       0x0000FFFF  /* Sixteen free FIFO entries */
#define FIFO_ERR            0x80000000  /* FIFO overrun error */

/*
 * Fields in GUI_TRAJ_CNTL register
 */
#define GUI_TRAJ_CNTL_DxtXDir       0x00000001  // 1=left to right
#define GUI_TRAJ_CNTL_DstYDir       0x00000002  // 1=top to bottom
#define GUI_TRAJ_CNTL_DstYMajor     0x00000004  // 1=Y-major line
#define GUI_TRAJ_CNTL_DstXTile      0x00000008  // Enable tiling in X direction
#define GUI_TRAJ_CNTL_DstYTile      0x00000010  // Enable tiling in Y direction
#define GUI_TRAJ_CNTL_DstLastPel    0x00000020  // Draw last pixel
#define GUI_TRAJ_CNTL_DstPolygonEna 0x00000040  // Polygon outline/fill enable
#define GUI_TRAJ_CNTL_SrcPattEna    0x00010000  // Enable pattern source
#define GUI_TRAJ_CNTL_SrcPattRotEna 0x00020000  // Enable pattern source rotation
#define GUI_TRAJ_CNTL_SrcLinearEna  0x00040000  // Source advanced linearly in memory
#define GUI_TRAJ_CNTL_SrcByteAlign  0x00080000  // Source is byte aligned
#define GUI_TRAJ_CNTL_SrcLineXDir   0x00100000  // Source X direction during Bresenham linedraw
#define GUI_TRAJ_CNTL_PattMonoEna   0x01000000  // Monochrome 8x8 pattern enable
#define GUI_TRAJ_CNTL_PattClr4x2Ena 0x02000000  // Colour 4x2 pattern enable
#define GUI_TRAJ_CNTL_PattClr8x1Ena 0x04000000  // Colour 8x1 pattern enable
#define GUI_TRAJ_CNTL_HostByteAlign 0x10000000  // Host data is byte aligned

/*
 * Fields in GUI_STAT register
 */
#define GUI_STAT_GuiActive          0x00000001  /* Engine busy */


/*
 * Extended BIOS services. Word values are function selectors, doubleword
 * values are bit flags which may be ORed with each other for "write"
 * calls or extracted for "read" calls.
 */
#define BIOS_PREFIX_VGA_ENAB    0xA000  /* Accelerator BIOS prefix with VGA enabled */
#define BIOS_PREFIX_MAX_DISAB   0xAF00  /* Highest allowed BIOS prefix with VGA disabled */
#define BIOS_PREFIX_INCREMENT   0x0100  /* Step between BIOS prefixes */
#define BIOS_PREFIX_UNASSIGNED  0xFF00  /* Flag to show this card's BIOS prefix is not yet known */


#define BIOS_LOAD_CRTC_LB       0x00
#define BIOS_LOAD_CRTC      phwDeviceExtension->BiosPrefix | BIOS_LOAD_CRTC_LB

#define BIOS_DEPTH_MASK         0x00000007
#define BIOS_DEPTH_4BPP         0x00000001
#define BIOS_DEPTH_8BPP         0x00000002
#define BIOS_DEPTH_15BPP_555    0x00000003
#define BIOS_DEPTH_16BPP_565    0x00000004
#define BIOS_DEPTH_24BPP        0x00000005
#define BIOS_DEPTH_32BPP        0x00000006
#define BIOS_ORDER_32BPP_MASK   0x00000028
#define BIOS_DEPTH_ORDER_MASK   BIOS_DEPTH_MASK | BIOS_ORDER_32BPP_MASK
#define BIOS_ORDER_32BPP_RGBx   0x00000000
#define BIOS_ORDER_32BPP_xRGB   0x00000008
#define BIOS_ORDER_32BPP_BGRx   0x00000020
#define BIOS_ORDER_32BPP_xBGR   0x00000028
#define BIOS_DEPTH_32BPP_RGBx   BIOS_DEPTH_32BPP | BIOS_ORDER_32BPP_RGBx
#define BIOS_DEPTH_32BPP_xRGB   BIOS_DEPTH_32BPP | BIOS_ORDER_32BPP_xRGB
#define BIOS_DEPTH_32BPP_BGRx   BIOS_DEPTH_32BPP | BIOS_ORDER_32BPP_BGRx
#define BIOS_DEPTH_32BPP_xBGR   BIOS_DEPTH_32BPP | BIOS_ORDER_32BPP_xBGR
#define BIOS_ENABLE_GAMMA       0x00000010  /* Enable gamma correction */
#define BIOS_PITCH_MASK         0x000000C0
#define BIOS_PITCH_1024         0x00000000  /* Screen pitch 1024 pixels */
#define BIOS_PITCH_UNCHANGED    0x00000040  /* Don't change screen pitch */
#define BIOS_PITCH_HOR_RES      0x00000080  /* Screen pitch is horizontal resolution */
#define BIOS_RES_MASK           0x0000FF00
#define BIOS_RES_640x480        0x00001200
#define BIOS_RES_800x600        0x00006A00
#define BIOS_RES_1024x768       0x00005500
#define BIOS_RES_EEPROM         0x00008000  /* Load table from EEPROM */
#define BIOS_RES_BUFFER         0x00008100  /* Load table from buffer in first 1M */
#define BIOS_RES_HIGH_BUFFER    0x00009100  /* Load table from unrestricted buffer */
#define BIOS_RES_OEM            0x00008200  /* OEM-specific mode */
#define BIOS_RES_1280x1024      0x00008300
#define BIOS_RES_1600x1200      0x00008400

#define BIOS_SET_MODE_LB        0x01
#define BIOS_SET_MODE       phwDeviceExtension->BiosPrefix | BIOS_SET_MODE_LB

#define BIOS_MODE_VGA           0x00000000
#define BIOS_MODE_COPROCESSOR   0x00000001

#define BIOS_LOAD_SET_LB        0x02
#define BIOS_LOAD_SET       phwDeviceExtension->BiosPrefix | BIOS_LOAD_SET_LB
#define BIOS_READ_EEPROM_LB     0x03
#define BIOS_READ_EEPROM    phwDeviceExtension->BiosPrefix | BIOS_READ_EEPROM_LB
#define BIOS_WRITE_EEPROM_LB    0x04
#define BIOS_WRITE_EEPROM   phwDeviceExtension->BiosPrefix | BIOS_WRITE_EEPROM_LB
#define BIOS_APERTURE_LB        0x05
#define BIOS_APERTURE       phwDeviceExtension->BiosPrefix | BIOS_APERTURE_LB

#define BIOS_DISABLE_APERTURE   0x00000000
#define BIOS_LINEAR_APERTURE    0x00000001
#define BIOS_VGA_APERTURE       0x00000004

#define BIOS_SHORT_QUERY_LB     0x06
#define BIOS_SHORT_QUERY    phwDeviceExtension->BiosPrefix | BIOS_SHORT_QUERY_LB

#define BIOS_AP_DISABLED        0x00000000
#define BIOS_AP_4M              0x00000001
#define BIOS_AP_8M              0x00000002
#define BIOS_AP_16M             0x00000003
#define BIOS_AP_SIZEMASK        0x00000003
#define BIOS_AP_SETTABLE        0x00000000  /* User can set aperture */
#define BIOS_AP_FIXED           0x00000040  /* Aperture location is fixed */
#define BIOS_AP_RNG_128M        0x00000000  /* Aperture must be below 128M */
#define BIOS_AP_RNG_4G          0x00000080  /* Aperture can be anywhere */

#define BIOS_CAP_LIST_LB        0x07
#define BIOS_CAP_LIST       phwDeviceExtension->BiosPrefix | BIOS_CAP_LIST_LB
#define BIOS_GET_QUERY_SIZE_LB  0x08
#define BIOS_GET_QUERY_SIZE phwDeviceExtension->BiosPrefix | BIOS_GET_QUERY_SIZE_LB
#define BIOS_QUERY_LB           0x09
#define BIOS_QUERY          phwDeviceExtension->BiosPrefix | BIOS_QUERY_LB

/*
 * The following values are used for both BIOS_GET_QUERY_SIZE
 * and BIOS_QUERY
 */
#define BIOS_QUERY_HEADER       0x00000000  /* Get header information only */
#define BIOS_QUERY_FULL         0x00000001  /* Also get mode tables */

#define BIOS_GET_CLOCK_LB       0x0A
#define BIOS_GET_CLOCK      phwDeviceExtension->BiosPrefix | BIOS_GET_CLOCK_LB
#define BIOS_SET_CLOCK_LB       0x0B
#define BIOS_SET_CLOCK      phwDeviceExtension->BiosPrefix | BIOS_SET_CLOCK_LB
#define BIOS_SET_DPMS_LB        0x0C
#define BIOS_SET_DPMS       phwDeviceExtension->BiosPrefix | BIOS_SET_DPMS_LB
#define BIOS_GET_DPMS_LB        0x0D
#define BIOS_GET_DPMS       phwDeviceExtension->BiosPrefix | BIOS_GET_DPMS_LB

#define BIOS_DPMS_ACTIVE        0x00000000
#define BIOS_DPMS_STANDBY       0x00000001
#define BIOS_DPMS_SUSPEND       0x00000002
#define BIOS_DPMS_OFF           0x00000003
#define BIOS_DPMS_BLANK_SCREEN  0x00000004

/*
 * Set and return Graphics Controller's power management state.
 */
#define BIOS_SET_PM_LB      0x0E
#define BIOS_SET_PM         phwDeviceExtension->BiosPrefix | BIOS_SET_PM_LB
#define BIOS_GET_PM_LB      0x0F
#define BIOS_GET_PM         phwDeviceExtension->BiosPrefix | BIOS_GET_PM_LB
#define BIOS_RAMDAC_STATE_LB        0x10
#define BIOS_RAMDAC_STATE   phwDeviceExtension->BiosPrefix | BIOS_RAMDAC_STATE_LB

#define BIOS_RAMDAC_NORMAL      0x00000000
#define BIOS_RAMDAC_SLEEP       0x00000001

#define BIOS_STORAGE_INFO_LB        0x11   /* Get external storage device info */
#define BIOS_STORAGE_INFO   phwDeviceExtension->BiosPrefix | BIOS_STORAGE_INFO_LB

#define BIOS_DEVICE_TYPE        0x0000000F
#define BIOS_READ_WRITE         0x00000000
#define BIOS_RDONLY             0x00000010
#define BIOS_NO_READ_WRITE      0x00000030
#define BIOS_READ_WRITE_APP     0x00000040
#define BIOS_NO_EXT_STORAGE     0x00000080
#define BIOS_NUM_16BIT_ENTRIES  0x0000FF00
#define BIOS_CRTC_TABLE_OFFSET  0x000000FF
#define BIOS_CRTC_TABLE_SIZE    0x0000FF00

#define BIOS_QUERY_IOBASE_LB        0x12   /* Get I/O base address */
#define BIOS_QUERY_IOBASE   phwDeviceExtension->BiosPrefix | BIOS_QUERY_IOBASE_LB
#define BIOS_DDC_SUPPORT_LB     0x13   /* Get Display Data Channel support information */
#define BIOS_DDC_SUPPORT    phwDeviceExtension->BiosPrefix | BIOS_DDC_SUPPORT_LB


#define REG_BLOCK_0             0x00000100
#define GP_IO                   (REG_BLOCK_0 | 0x1E)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\cvtddc.h ===
/************************************************************************/
/*                                                                      */
/*                              CVTDDC.H                                */
/*                                                                      */
/*       November 10  1995 (c) 1995 ATI Technologies Incorporated.      */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.0  $
      $Date:   21 Nov 1995 11:04:58  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/cvtddc.h_v  $
//
//   Rev 1.0   21 Nov 1995 11:04:58   RWolff
//Initial revision.


End of PolyTron RCS section                             *****************/



/*
 * Prototypes for functions supplied by CVTVDIF.C
 */
extern ULONG IsDDCSupported(void);
extern VP_STATUS MergeEDIDTables(void);


/*
 * Definitions used to identify the type of external mode
 * table source to be merged with the "canned" tables.
 */
enum {
    MERGE_UNKNOWN = 0,  /* Source not yet determined */
    MERGE_VDIF_FILE,    /* Source is a VDIF file read from disk */
    MERGE_EDID_DDC,     /* Source is an EDID structure transferred via DDC */
    MERGE_VDIF_DDC      /* Source is a VDIF file transferred via DDC */
    };

/*
 * Definitions and data structures used only within CVTDDC.C
 */
/*
 * Detailed timing description from EDID structure
 */
#pragma pack(1)
struct EdidDetailTiming{
    USHORT PixClock;            /* Pixel clock in units of 10 kHz */
    UCHAR HorActiveLowByte;     /* Low byte of Horizontal Active */
    UCHAR HorBlankLowByte;      /* Low byte of Horizontal Blank (total - active) */
    UCHAR HorHighNybbles;       /* High nybbles of above 2 values */
    UCHAR VerActiveLowByte;     /* Low byte of Vertical Active */
    UCHAR VerBlankLowByte;      /* Low byte of Vertical Blank (total - active) */
    UCHAR VerHighNybbles;       /* High nybbles of above 2 values */
    UCHAR HSyncOffsetLB;        /* Low byte of hor. sync offset */
    UCHAR HSyncWidthLB;         /* Low byte of hor. sync width */
    UCHAR VSyncOffWidLN;        /* Low nybbles of ver. sync offset and width */
    UCHAR SyncHighBits;         /* High bits of sync values */
    UCHAR HorSizeLowByte;       /* Low byte of hor. size in mm */
    UCHAR VerSizeLowByte;       /* Low byte of ver. size in mm */
    UCHAR SizeHighNybbles;      /* High nybbles of above 2 values */
    UCHAR HorBorder;            /* Size of horizontal overscan */
    UCHAR VerBorder;            /* Size of vertical overscan */
    UCHAR Flags;                /* Interlace and sync polarities */
};
#pragma pack()

ULONG
DDC2Query(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PUCHAR QueryBuffer,
    USHORT BufferSize
    );

BOOLEAN
DDC2Query50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG  BufferSize
    );

#define EDID_FLAGS_INTERLACE            0x80
#define EDID_FLAGS_SYNC_TYPE_MASK       0x18
#define EDID_FLAGS_SYNC_ANALOG_COMP     0x00
#define EDID_FLAGS_SYNC_BIPOLAR_AN_COMP 0x08
#define EDID_FLAGS_SYNC_DIGITAL_COMP    0x10
#define EDID_FLAGS_SYNC_DIGITAL_SEP     0x18
#define EDID_FLAGS_V_SYNC_POS           0x04
#define EDID_FLAGS_H_SYNC_POS           0x02
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\atimp.h ===
/************************************************************************/
/*                                                                      */
/*                              ATIMP.H                                 */
/*                                                                      */
/*    November  2  1992	    (c) 1992, ATI Technologies Incorporated.	*/
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.22  $
      $Date:   01 Mar 1996 12:10:48  $
   $Author:   RWolff  $
      $Log:   S:/source/wnt/ms11/miniport/archive/atimp.h_v  $
 * 
 *    Rev 1.22   01 Mar 1996 12:10:48   RWolff
 * Allocated more space for mapped registers, since VGA Graphics Index
 * and Graphics Data are now handled as separate registers rather than
 * as offsets into the block of VGA registers.
 * 
 *    Rev 1.21   02 Feb 1996 17:14:52   RWolff
 * Moved DDC/VDIF merge source information into hardware device extension
 * so each card can be considered independently in a multihead setup.
 * 
 *    Rev 1.20   29 Jan 1996 16:53:58   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC, removed
 * dead code.
 * 
 *    Rev 1.19   22 Dec 1995 14:52:32   RWolff
 * Added support for Mach 64 GT internal DAC.
 * 
 *    Rev 1.18   19 Dec 1995 14:00:26   RWolff
 * Increased size of buffer used to store query structure and mode tables
 * to allow for increase in the number of "canned" tables due to support
 * for higher refresh rates.
 * 
 *    Rev 1.17   28 Nov 1995 18:07:58   RWolff
 * Added "Card Initialized" field to hardware device extension. This
 * is part of multiheaded support, to prevent multiple initializations
 * of a single card.
 * 
 *    Rev 1.16   27 Oct 1995 14:21:26   RWolff
 * Removed mapped LFB from hardware device extension.
 * 
 *    Rev 1.15   08 Sep 1995 16:36:12   RWolff
 * Added support for AT&T 408 DAC (STG1703 equivalent).
 * 
 *    Rev 1.14   24 Aug 1995 15:38:38   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 * 
 *    Rev 1.13   28 Jul 1995 14:39:50   RWolff
 * Added support for the Mach 64 VT (CT equivalent with video overlay).
 * 
 *    Rev 1.12   31 Mar 1995 11:57:44   RWOLFF
 * Changed debug thresholds to avoid being swamped by level 3 statements
 * in VIDEOPRT.SYS, removed DEBUG_SWITCH since it's no longer used.
 * 
 *    Rev 1.11   30 Mar 1995 12:01:54   RWOLFF
 * Added definitions for debug level thresholds.
 * 
 *    Rev 1.10   07 Feb 1995 18:19:54   RWOLFF
 * Updated colour depth table for STG1702/1703. Entries for DACs
 * that are supposedly equivalent to these are unchanged, since
 * I did not have cards with these DACs and more than 2M of
 * video memory to test with.
 * 
 *    Rev 1.9   30 Jan 1995 11:56:42   RWOLFF
 * Added support for CT internal DAC.
 * 
 *    Rev 1.8   18 Jan 1995 15:39:32   RWOLFF
 * Added support for Chrontel DAC.
 * 
 *    Rev 1.7   23 Dec 1994 10:48:32   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.6   18 Nov 1994 11:53:28   RWOLFF
 * Added support for split rasters, Power PC, and new DAC type DAC_STG1703.
 * 
 *    Rev 1.5   06 Sep 1994 10:46:52   ASHANMUG
 * Disable 1600x1200 on all cards except with TVM DAC
 * 
 *    Rev 1.4   31 Aug 1994 16:16:10   RWOLFF
 * Added support for TVP3026 DAC and 1152x864, doubled QUERYSIZE to
 * allow additional mode tables (needed because we now support 1152x864
 * and 1600x1200, we have more refresh rates at 1280x1024, and TVP DAC
 * supports high-res high depth modes AND 4BPP).
 * 
 *    Rev 1.3   19 Aug 1994 17:06:22   RWOLFF
 * Added support for the SC15026 DAC.
 * 
 *    Rev 1.2   12 May 1994 11:09:00   RWOLFF
 * Expanded CardInfo field of hardware device extension structure to allow
 * more mode tables (needed when setting up "canned" refresh rates"), added
 * defined value for hardware default refresh rate.
 * 
 *    Rev 1.1   03 Mar 1994 12:37:10   ASHANMUG
 * Make pageable
 * 
 *    Rev 1.0   31 Jan 1994 11:40:12   RWOLFF
 * Initial revision.
        
           Rev 1.8   14 Jan 1994 15:19:14   RWOLFF
        Added support for 1600x1200 mode.
        
           Rev 1.7   15 Dec 1993 15:25:04   RWOLFF
        Added support for SC15021 DAC.
        
           Rev 1.6   30 Nov 1993 18:11:38   RWOLFF
        Changed maximum pixel depth for STG1700 DAC at 640x480 and 800x600 to 32BPP
        
           Rev 1.5   05 Nov 1993 13:22:46   RWOLFF
        Added new DAC types.
        
           Rev 1.4   08 Oct 1993 15:16:54   RWOLFF
        Updated build and version numbers.
        
           Rev 1.3   08 Oct 1993 11:01:46   RWOLFF
        Removed code specific to a particular family of ATI accelerators, added
        definition for a delay which is only used on DEC Alpha machines.
        
           Rev 1.2   24 Sep 1993 11:47:44   RWOLFF
        Added definition for DEBUG_SWITCH, which will allow VideoDebugPrint() calls
        to be turned on and off all at once.
        
           Rev 1.1   03 Sep 1993 14:27:00   RWOLFF
        Partway through CX isolation.
        
           Rev 1.0   16 Aug 1993 13:30:56   Robert_Wolff
        Initial revision.
        
           Rev 1.15   06 Jul 1993 15:48:32   RWOLFF
        Added MaxDepth[] entries for AT&T 491 and ATI 68860 DACs.
        
           Rev 1.14   10 Jun 1993 15:57:02   RWOLFF
        Added definition for size of buffer used in registry reads,
        moved definition of checked-version-only breakpoint INT
        here to avoid duplicating it in all C files.
        
           Rev 1.13   07 Jun 1993 12:59:00   BRADES
        add EXT_CUR_Y, and EXT_SRC_Y mach8 register defines.
        
           Rev 1.12   18 May 1993 14:07:38   RWOLFF
        Added definition TTY_ATTR_NORMAL (white on blue attribute), which is needed
        in aperture tests and was supplied by now-obsolete TTY.H.
        
           Rev 1.11   10 May 1993 16:41:18   RWOLFF
        Added table listing maximum pixel depth for each supported DAC/resolution
        combination.
        
           Rev 1.10   30 Apr 1993 17:08:24   RWOLFF
        RegistryBuffer is now dynamically allocated.
        
           Rev 1.9   30 Apr 1993 15:52:42   BRADES
        fix DISP_STATUS from 5 to 2e8.
        
           Rev 1.7   14 Apr 1993 17:41:30   RWOLFF
        Removed redundant definitions to eliminate warnings.
        
           Rev 1.6   08 Apr 1993 16:45:42   RWOLFF
        Revision level as checked in at Microsoft.

           Rev 1.5   30 Mar 1993 17:09:38   RWOLFF
        Made RegistryParameterCallback() avialable to all miniport source files,
        increased buffer capacity for registry reads.
        
           Rev 1.4   25 Mar 1993 11:17:16   RWOLFF
        No longer grabs registers we don't use.
        
           Rev 1.3   08 Mar 1993 19:30:52   BRADES
        submit to MS NT
        
           Rev 1.2   10 Feb 1993 13:00:48   Robert_Wolff
        Added VideoRamLength field to HW_DEVICE_EXTENSION, FrameLength is now
        the aperture size rather than the amount of video memory.
        
           Rev 1.1   05 Feb 1993 16:55:06   Robert_Wolff
        Now initializes "shareable" field of VIDEO_ACCESS_RANGE structures
        to allow VGA driver to run concurrently with ours. This allows switching
        to/from full-screen DOS sessions.
        
           Rev 1.0   05 Feb 1993 16:17:42   Robert_Wolff
        Initial revision.
        
           Rev 1.0   02 Nov 1992 20:48:14   Chris_Brady
        Initial revision.
        

End of PolyTron RCS section                             *****************/

#ifdef DOC

DESCRIPTION
     ATI Windows NT Miniport driver for the Mach64, Mach32, and Mach8 
     families.
     This file will select the appropriate functions depending on the 
     computer configuration.

Environment:

    Kernel mode

#endif


/*
 * SPLIT_RASTERS is defined in order to work with a display driver which
 * may break a scan line across the boundary between 64k pages when using
 * the VGA aperture, and undefined when working with a display driver
 * which requires that every scan line be contained within a single page
 * (modes with a screen width of less than 1024 pixels are padded to a
 * pitch of 1024, modes with a width greater than 1024 but less than
 * 2048 are padded to a pitch of 2048).
 */
#define SPLIT_RASTERS   1

/*
 * Values used to indicate priority of VideoDebugPrint() calls.
 *
 * To set the debug threshold, set the ati\Device0\VideoDebugLevel
 * registry field to the lowest-priority debug statments you want
 * to see. For example, a value of 2 will display DEBUG_ERROR and
 * DEBUG_IMPORTANT in addition to DEBUG_TRACE, but will not display
 * DEBUG_DETAIL.
 */
#define DEBUG_ERROR         0   /* Statements with this level should never happen */
#define DEBUG_NORMAL        1   /* Entry/exit points of major functions and other important information */
#define DEBUG_DETAIL        2   /* Detailed debug information */
#define DEBUG_RIDICULOUS    3   /* This level will trigger MASSIVE numbers of statments from VIDEOPRT.SYS */
/*
 * Uncomment to allow building using free version of VIDEOPRT.LIB
 */
//#undef VideoDebugPrint
//#define VideoDebugPrint(x)

/*
 * Delay for DEC Alpha and other machines too fast to allow
 * consecutive I/O instructions without a delay in between.
 */
#if defined (ALPHA) || defined (_ALPHA_)
#define DEC_DELAY delay(3);
#else
#define DEC_DELAY
#endif

/*
 * Definitions used by the IOCTL_VIDEO_ATI_GET_VERSION packet.
 */
#define MINIPORT_BUILD          511 /* NT Retail build number */
#define MINIPORT_VERSION_MAJOR  0   /* Major version number */
#define MINIPORT_VERSION_MINOR  3   /* Minor version number */


// #define DBG 1

#define CURSOR_WIDTH   64
#define CURSOR_HEIGHT  64

/*
 * Screen attributes for "blue screen" text (white on blue), used
 * to recognize whether or not we are looking at the "blue screen"
 * or other memory.
 */
#define TTY_ATTR_NORMAL 0x17


//------------------------------------------------------------------------

/*
 * List of available resolutions
 */
#define RES_640     0
#define RES_800     1
#define RES_1024    2
#define RES_1152    3
#define RES_1280    4
#define RES_1600    5

/*
 * "Card found" status variables. We support a single card that does
 * not use block relocatable I/O, or up to 16 cards (INT 10 AH=A0 through
 * AH=AF) that use block relocatable I/O, but never a mix of block and
 * non-block cards.
 */
extern BOOL FoundNonBlockCard;
extern USHORT NumBlockCardsFound;

/*
 * List of greatest pixel depths available for each supported
 * DAC at all resolutions.
 *
 * A value of 0 indicates that the DAC is known to not support
 * the corresponding resolution. A value of 1 indicates that
 * it is unknown whether or not the DAC supports the corresponding
 * resolution. Since we don't report any modes with a colour depth
 * less than 4BPP, both will be seen as the resolution not being
 * supported.
 */
#ifdef INCLUDE_ATIMP
short MaxDepth[HOW_MANY_DACs][RES_1600-RES_640+1] =
    {
    16, 16, 16, 16, 8,  1,  /* DAC_ATI_68830 */
    24, 16, 8,  8,  8,  1,  /* DAC_SIERRA */
    32, 32, 16, 16, 8,  1,  /* DAC_TI34075 */
    8,  8,  8,  8,  8,  1,  /* DAC_BT47x */
    24, 16, 8,  8,  8,  1,  /* DAC_BT48x */
    32, 32, 32, 32, 24, 1,  /* DAC_ATI_68860 */
    32, 32, 16, 16, 8,  1,  /* DAC_STG1700 */
    24, 24, 24, 24, 16, 1,  /* DAC_SC15021 NOTE: Should be able to handle 32BPP. */
    /*
     * DAC types below are for cases where incompatible DAC types
     * report the same code in CONFIG_STATUS_1. Since the DAC type
     * field is 3 bits and can't grow (bits immediately above and
     * below are already assigned), DAC types 8 and above will
     * not conflict with reported DAC types but are still legal
     * in the query structure's DAC type field (8 bit unsigned integer).
     */
    24, 16, 8,  8,  8,  1,  /* DAC_ATT491 */
    32, 32, 16, 16, 8,  1,  /* DAC_ATT498 */
    24, 16, 8,  8,  8,  1,  /* DAC_SC15026 */
    32, 32, 32, 32, 24, 24, /* DAC_TVP3026 */
    32, 32, 32, 32, 24, 24, /* DAC_IBM514 */
    32, 32, 24, 16, 16, 1,  /* DAC_STG1702 */
    32, 32, 24, 16, 16, 1,  /* DAC_STG1703 */
    32, 32, 16, 16, 8,  1,  /* DAC_CH8398 */
    32, 32, 16, 16, 8,  1,  /* DAC_ATT408 */
    32, 32, 16, 16, 8,  1,  /* DAC_INTERNAL_CT */
    32, 32, 16, 16, 8,  1,  /* DAC_INTERNAL_GT */
    32, 32, 16, 16, 8,  1   /* DAC_INTERNAL_VT */
    };
#else
extern short MaxDepth[HOW_MANY_DACs][RES_1600-RES_640+1];
#endif

//-----------------------------------------------------------------------

typedef struct tagVDATA {
    ULONG   Address;
    ULONG   Value;
} VDATA, *PVDATA;

//------------------------------------------

#ifndef QUERYSIZE
#define QUERYSIZE       12288
#endif

/*
 * Value stored in VIDEO_MODE_INFORMATION.Frequency field to
 * indicate hardware default refresh rate.
 */
#define DEFAULT_REFRESH 1


/*
 * Number of mapped address ranges allowed in HW_DEVICE_EXTENSION
 * structure. Modules which will be mapping address ranges to fill
 * arrays with this size contain checks on this value. If the array
 * would be overfilled, these checks will cause compile-time errors.
 */
#define NUM_ADDRESS_RANGES_ALLOWED  108

/*
 * Define device extension structure. This is device dependant/private
 * information.
 */
typedef struct _HW_DEVICE_EXTENSION {
    /*
     * I/O space ranges used. The extra 1 is for the
     * VGAWONDER extended base register, which is determined
     * at runtime.
     */
    PVOID aVideoAddressIO[NUM_ADDRESS_RANGES_ALLOWED];

    /*
     * Memory Mapped address ranges used. This array must
     * be the same size as the I/O mapped array.
     */
    PVOID aVideoAddressMM[NUM_ADDRESS_RANGES_ALLOWED];

    PVOID RomBaseRange;     /* ROM address range used */

    PHYSICAL_ADDRESS PhysicalFrameAddress;  /* Physical address of the LFB */

    ULONG VideoRamSize;         /* Amount of installed video memory */


    ULONG FrameLength;          /* Aperture size. */

    ULONG ModeIndex;            /* Index of current mode in either ModesVGA[] */
                                /* or mode tables in CardInfo[], depending on */
                                /* whether video card is VGAWonder or accelerator */

    ULONG HardwareCursorAddr;   /* Storage of cursor bitmap for 68800 hardware cursor */
    ULONG ModelNumber;			/* ATI Adapter Card Type */
    USHORT BiosPrefix;          /* Card sequence for accelerator INT 10 calls */
    ULONG BaseIOAddress;        /* Used in matching BIOS prefix to I/O base on relocatable cards */
    char CardInfo[QUERYSIZE];   /* Storage for query information */

    struct st_eeprom_data *ee;  /* Information used to access EEPROM */

    /*
     * The following 4 fields are used when re-initializing the windowed
     * screen after a full-screen DOS session. They are a flag to show
     * that the mode is being re-initialized instead of entered for the
     * first time, the palette of colours to use, the first palette entry
     * to be reloaded, and the number of palette entries to be reloaded.
     */
    BOOL ReInitializing;
    ULONG Clut[256];
    USHORT FirstEntry;
    USHORT NumEntries;

    /*
     * Used to ensure that ATIMPInitialize() is only called once for
     * any given card.
     */
    BOOL CardInitialized;

    ULONG PreviousPowerState;

    /*
     * Shows whether to merge "canned" mode tables with tables from
     * VDIF file, or with tables from EDID structure returned by DDC.
     */
    ULONG MergeSource;

    ULONG EdidChecksum;         /* Checksum of EDID structure */

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

#if defined INCLUDE_ATIMP
    PHW_DEVICE_EXTENSION phwDeviceExtension;       // Global Miniport Variable now
#else
    extern PHW_DEVICE_EXTENSION  phwDeviceExtension;
#endif


/*
 * Registry callback routine and buffers to allow data to be retrieved
 * by other routines.
 */
extern VP_STATUS
RegistryParameterCallback(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PVOID Context,
    PWSTR Name,
    PVOID Data,
    ULONG Length
    );

#define REGISTRY_BUFFER_SIZE 200    /* Size of buffer used in registry reads */
extern UCHAR RegistryBuffer[];      /* Last value retrieved from the registry */
extern ULONG RegistryBufferLength;  /* Size of last retrieved value */

/*
 * Macros to provide debug breakpoints in checked version while
 * clearing them in free version.
 */
#if DBG
#if defined(i386) || defined(_X86_)
#define INT	_asm int 3;
#else
#define INT DbgBreakPoint();
/*
 * Function prototype has vanished from headers we include, so
 * we must supply it on our own.
 */
extern void DbgBreakPoint(void);
#endif
#else
#define INT
#endif

/*
 * Routine to make an absolute far call.
 */
#if 0
#ifdef _X86_
extern VP_STATUS CallAbsolute(unsigned short, unsigned short, VIDEO_X86_BIOS_ARGUMENTS *);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\atioem.h ===
/************************************************************************/
/*                                                                      */
/*                              ATIOEM.H                                */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.0  $
    $Date:   31 Jan 1994 11:28:06  $
    $Author:   RWOLFF  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/atioem.h  $
 * 
 *    Rev 1.0   31 Jan 1994 11:28:06   RWOLFF
 * Initial revision.
        
           Rev 1.0   16 Aug 1993 13:30:20   Robert_Wolff
        Initial revision.
        
           Rev 1.1   10 May 1993 16:41:48   RWOLFF
        Eliminated unnecessary passing of hardware device extension
        as a parameter.
        
           Rev 1.0   30 Mar 1993 17:13:00   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    ATIOEM.H -  Function prototypes and data definitions for ATIOEM.C.

#endif


/*
 * Definitions for IgnoreCase parameter of CompareASCIIToUnicode()
 */
#define CASE_SENSITIVE      0
#define CASE_INSENSITIVE    1

extern LONG CompareASCIIToUnicode(PUCHAR Ascii, PUCHAR Unicode, BOOL IgnoreCase);

extern VP_STATUS OEMGetParms(struct query_structure *query);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\atioem.c ===
/************************************************************************/
/*                                                                      */
/*                              ATIOEM.C                                */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.                  */
/************************************************************************/

/**********************       PolyTron RCS Utilities

    $Revision:   1.20  $
    $Date:   01 May 1996 14:08:38  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/atioem.c_v  $
 * 
 *    Rev 1.20   01 May 1996 14:08:38   RWolff
 * Locked out 24BPP on Alpha and on machines without LFB.
 * 
 *    Rev 1.19   23 Jan 1996 11:43:24   RWolff
 * Eliminated level 3 warnings, protected against false values of TARGET_BUILD.
 * 
 *    Rev 1.18   11 Jan 1996 19:35:58   RWolff
 * Added maximum pixel clock rate to all calls to SetFixedModes().
 * This is required as part of a Mach 64 fix.
 * 
 *    Rev 1.17   22 Dec 1995 14:52:52   RWolff
 * Switched to TARGET_BUILD to identify the NT version for which
 * the driver is being built.
 * 
 *    Rev 1.16   20 Jul 1995 17:26:54   mgrubac
 * Added support for VDIF files
 * 
 *    Rev 1.15   31 Mar 1995 11:51:36   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 * 
 *    Rev 1.14   23 Dec 1994 10:47:28   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.13   18 Nov 1994 11:37:56   RWOLFF
 * Added support for Dell Sylvester, STG1703 DAC, and display driver
 * that can handle split rasters.
 * 
 *    Rev 1.12   14 Sep 1994 15:29:52   RWOLFF
 * Now reads in frequency table and monitor description from disk.
 * If disk-based frequency table is missing or invalid, loads default
 * OEM-specific frequency table if it is different from the retail
 * frequency table. If disk-based monitor description is missing or
 * invalid, reads installed modes in OEM-specific manner if the OEM
 * type is known. For unknown OEM types with no disk-based monitor
 * description, only predefined mode tables are listed.
 * 
 *    Rev 1.11   31 Aug 1994 16:20:06   RWOLFF
 * Changed includes to correspond to Daytona RC1, now skips over
 * 1152x864 (Mach 64-only mode, this module is for Mach 32), assumes
 * system is not a Premmia SE under NT retail because the definition
 * we use to look for this machine is not available under NT retail.
 * 
 *    Rev 1.10   19 Aug 1994 17:08:28   RWOLFF
 * Fixed aperture location bug on AST Premmia SE, added support for
 * SC15026 DAC and 1280x1024 70Hz and 74Hz, and pixel clock
 * generator independence.
 * 
 *    Rev 1.9   20 Jul 1994 13:01:56   RWOLFF
 * Added diagnostic print statements for DELL, now defaults to "worst"
 * (interlaced if available, else lowest frequency) refresh rate instead
 * of skipping the resolution if we get an invalid result when trying
 * to find which refresh rate is desired on a DELL Omniplex.
 * 
 *    Rev 1.8   12 Jul 1994 17:42:24   RWOLFF
 * Andre Vachon's changes: different way of allowing DELL users
 * to run without an ATIOEM field.
 * 
 *    Rev 1.7   11 Jul 1994 11:57:34   RWOLFF
 * No longer aborts if ATIOEM field is missing from registry. Some OEMs
 * auto-detect, and generic OEMs can use the "canned" mode tables,
 * so this field is no longer mandatory and someone removed it from
 * the registry sometime after Beta 2 for Daytona.
 *
 *    Rev 1.6   15 Jun 1994 11:05:16   RWOLFF
 * No longer lists "canned" mode tables for Dell Omniplex, since these tables
 * assume the use of the same clock generator as on our retail cards, and
 * Dell uses a different clock generator.
 *
 *    Rev 1.5   20 May 1994 16:07:12   RWOLFF
 * Fix for 800x600 screen tearing on Intel BATMAN PCI motherboards.
 *
 *    Rev 1.4   18 May 1994 17:02:14   RWOLFF
 * Interlaced mode tables now report frame rate rather than vertical
 * scan frequency in the refresh rate field.
 *
 *    Rev 1.3   12 May 1994 11:06:20   RWOLFF
 * Added refresh rate to OEM mode tables, sets up "canned" mode tables
 * for all OEMs except AST Premmia, no longer aborts if no OEM string
 * found either in ATIOEM registry entry or through auto-detection since
 * the "canned" mode tables will be available, no longer supports 32BPP,
 * since this module is for the Mach 8 and Mach 32.
 *
 *    Rev 1.2   31 Mar 1994 15:06:20   RWOLFF
 * Added debugging code.
 *
 *    Rev 1.1   07 Feb 1994 14:05:14   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 *
 *    Rev 1.0   31 Jan 1994 10:57:34   RWOLFF
 * Initial revision.

           Rev 1.7   24 Jan 1994 18:02:54   RWOLFF
        Pixel clock multiplication on BT48x and AT&T 49[123] DACs at 16 and 24 BPP
        is now done when mode tables are created rather than when mode is set.

           Rev 1.6   15 Dec 1993 15:25:26   RWOLFF
        Added support for SC15021 DAC, removed debug print statements.

           Rev 1.5   30 Nov 1993 18:12:28   RWOLFF
        Added support for AT&T 498 DAC, now doubles pixel clock at 32BPP for
        DACs that need it. Removed extra increment of mode table counter
        (previously, counter would show 1 more mode table than actually
        existed for each 24BPP mode table present that required clock doubling).

           Rev 1.4   05 Nov 1993 13:31:44   RWOLFF
        Added STG1700 DAC and Dell support

           Rev 1.2   08 Oct 1993 11:03:16   RWOLFF
        Removed debug breakpoint.

           Rev 1.1   03 Sep 1993 14:21:26   RWOLFF
        Partway through CX isolation.

           Rev 1.0   16 Aug 1993 13:27:00   Robert_Wolff
        Initial revision.

           Rev 1.8   10 Jun 1993 15:59:34   RWOLFF
        Translation of VDP-format monitor description file is now done inside
        the registry callback function to eliminate the need for an excessively
        large static buffer (Andre Vachon at Microsoft doesn't want the
        callback function to dynamically allocate a buffer).

           Rev 1.7   10 May 1993 16:37:56   RWOLFF
        GetOEMParms() now recognizes maximum pixel depth of each possible DAC at
        each supported resolution, eliminated unnecessary passing of
        hardware device extension as a parameter.

           Rev 1.6   04 May 1993 16:44:00   RWOLFF
        Removed INT 3s (debugging code), added workaround for optimizer bug that
        turned a FOR loop into an infinite loop.

           Rev 1.5   30 Apr 1993 16:37:02   RWOLFF
        Changed to work with dynamically allocated registry read buffer.
        Parameters are now read in from disk in VDP file format rather than
        as binary data (need floating point bug in NT fixed before this can be used).

           Rev 1.4   24 Apr 1993 17:14:48   RWOLFF
        No longer falls back to 56Hz at 800x600 16BPP on 1M Mach 32.

           Rev 1.3   21 Apr 1993 17:24:12   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        Sets q_status_flags to show which resolutions are supported.
        Can now read either CRT table to use or raw CRT parameters from
        disk file.

           Rev 1.2   14 Apr 1993 18:39:30   RWOLFF
        On AST machines, now reads from the computer what monitor type
        is configured and sets CRT parameters appropriately.

           Rev 1.1   08 Apr 1993 16:52:58   RWOLFF
        Revision level as checked in at Microsoft.

           Rev 1.0   30 Mar 1993 17:12:38   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    ATIOEM.C -  Functions to obtain CRT parameters from OEM versions
                of Mach 32/Mach 8 accelerators which lack an EEPROM.

#endif


#include <stdlib.h>
#include <string.h>

#include "dderror.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"      /* for VP_STATUS definition */
#include "vidlog.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#include "atioem.h"
#include "services.h"
#include "vdptocrt.h"

/*
 * Definition needed to build under revision 404 of Windows NT.
 * Under later revisions, it is defined in a header which we
 * include.
 */
#ifndef ERROR_DEV_NOT_EXIST
#define ERROR_DEV_NOT_EXIST 55L
#endif

/*
 * OEM types supported by this module
 */
enum {
    OEM_AST_PREMMIA,        /* Also includes Bravo machines */
    OEM_DELL_OMNIPLEX,
    OEM_DELL_SYLVESTER,     /* Different programming of clock generator from Omniplex */
    OEM_UNKNOWN             /* Generic OEM - "canned" modes only, no HW defaults */
    };

/*
 * AST machines have "AST " starting at offset 0x50 into the BIOS.
 * AST_REC_VALUE is the character sequence "AST " stored as an
 * Intel-format DWORD.
 */
#define AST_REC_OFFSET  0x50
#define AST_REC_VALUE   0x20545341

/*
 * Definitions used to distinguish Premmia SE from other
 * AST machines. The Premmia SE has its aperture in the
 * 4G range, with the location split between MEM_CFG and
 * SCRATCH_PAD_0, but it does not have bit 0 of byte 0x62
 * in the BIOS set to indicate this.
 */
#define EISA_ID_OFFSET  8           /* Offset to feed VideoPortGetBusData() */
#define PREMMIA_SE_SLOT 0           /* Motherboard is slot 0 */
#define PREMMIA_SE_ID   0x01057406  /* EISA ID of Premmia SE */

/*
 * Indices into 1CE register where AST monitor configuration is kept.
 */
#define AST_640_STORE   0xBA
#define AST_800_STORE   0x81
#define AST_1024_STORE  0x80

/*
 * Values found in AST monitor configuration registers for the
 * different monitor setups.
 */
#define M640F60AST  0x02
#define M640F72AST  0x03
#define M800F56AST  0x84
#define M800F60AST  0x88
#define M800F72AST  0xA0
#define M1024F60AST 0x02
#define M1024F70AST 0x04
#define M1024F72AST 0x08
#define M1024F87AST 0x01

/*
 * Definitions used in stepping through pixel depths for AST Premmia.
 * Since the supported depths can't be stepped through a FOR loop
 * by a simple mathematical function, use an array index instead.
 */
enum {
    DEPTH_4BPP = 0,
    DEPTH_8BPP,
    DEPTH_16BPP,
    DEPTH_24BPP
    };

/*
 * Pixel depth
 */
USHORT ASTDepth[DEPTH_24BPP - DEPTH_4BPP + 1] =
{
    4,
    8,
    16,
    24
};

/*
 * Pixel clock frequency multiplier
 */
USHORT ASTClockMult[DEPTH_24BPP - DEPTH_4BPP + 1] =
{
    CLOCK_SINGLE,
    CLOCK_SINGLE,
    CLOCK_DOUBLE,
    CLOCK_TRIPLE
};

/*
 * Pixel size as a multiple of 4BPP (lowest depth)
 */
USHORT ASTNybblesPerPixel[DEPTH_24BPP - DEPTH_4BPP + 1] =
{
    1,
    2,
    4,
    6
};


/*
 * Dell machines have "DELL" starting at an offset into the BIOS which
 * is a multiple of 0x100. Currently, it is always at offset 0x100, but
 * this may change. DELL_REC_VALUE is the character sequence "DELL"
 * stored as an Intel-format DWORD.
 *
 * Some Dell machines store the pixel clock frequency table in the BIOS
 * rather than using the default Dell frequency table. On these machines,
 * the identifier DELL_TABLE_PRESENT will be found at offset DELL_TP_OFFSET
 * from the start of DELL_REC_VALUE, and the offset of the frequency table
 * into the video BIOS will be found at offset DELL_TABLE_OFFSET from the
 * start of DELL_TABLE_PRESENT.
 *
 * The table consists of 18 words. The first word is DELL_TABLE_SIG,
 * the second is the table type, and the remaining 16 are the clock
 * table entries.
 */
#define DELL_REC_SPACING    0x100
#define DELL_REC_VALUE      0x4C4C4544
#define DELL_TABLE_PRESENT  0x7674          /* "tv" as WORD */
#define DELL_TP_OFFSET      0x08
#define DELL_TABLE_OFFSET   0x0C
#define DELL_TABLE_SIG      0x7463          /* "ct" as WORD */

/*
 * Indices into 1CE register where Dell monitor configuration is kept.
 */
#define DELL_640_STORE  0xBA
#define DELL_800_STORE  0x81
#define DELL_1024_STORE 0x80
#define DELL_1280_STORE 0x84

/*
 * Values found in Dell monitor configuration registers for the
 * different monitor setups.
 */
#define MASK_640_DELL   0x01
#define M640F60DELL     0x00
#define M640F72DELL     0x01
#define MASK_800_DELL   0x3F
#define M800F56DELL     0x04
#define M800F60DELL     0x08
#define M800F72DELL     0x20
#define MASK_1024_DELL  0x1F
#define M1024F87DELL    0x01
#define M1024F60DELL    0x02
#define M1024F70DELL    0x04
#define M1024F72DELL    0x08
#define MASK_1280_DELL  0xFC
#define M1280F87DELL    0x04
#define M1280F60DELL    0x10
#define M1280F70DELL    0x20
#define M1280F74DELL    0x40



/*
 * Local functions to get CRT data for specific OEM cards.
 */
VP_STATUS ReadAST(struct query_structure *query);
VP_STATUS ReadZenith(struct st_mode_table *Modes);
VP_STATUS ReadOlivetti(struct st_mode_table *Modes);
VP_STATUS ReadDell(struct st_mode_table *Modes);
ULONG DetectDell(struct query_structure *Query);
BOOL DetectSylvester(struct query_structure *Query, ULONG HeaderOffset);
VP_STATUS ReadOEM1(struct st_mode_table *Modes);
VP_STATUS ReadOEM2(struct st_mode_table *Modes);
VP_STATUS ReadOEM3(struct st_mode_table *Modes);
VP_STATUS ReadOEM4(struct st_mode_table *Modes);
VP_STATUS ReadOEM5(struct st_mode_table *Modes);



/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, OEMGetParms)
#pragma alloc_text(PAGE_COM, CompareASCIIToUnicode)
#pragma alloc_text(PAGE_COM, ReadAST)
#pragma alloc_text(PAGE_COM, ReadZenith)
#pragma alloc_text(PAGE_COM, ReadOlivetti)
#pragma alloc_text(PAGE_COM, ReadDell)
#pragma alloc_text(PAGE_COM, DetectDell)
#pragma alloc_text(PAGE_COM, DetectSylvester)
#pragma alloc_text(PAGE_COM, ReadOEM1)
#pragma alloc_text(PAGE_COM, ReadOEM2)
#pragma alloc_text(PAGE_COM, ReadOEM3)
#pragma alloc_text(PAGE_COM, ReadOEM4)
#pragma alloc_text(PAGE_COM, ReadOEM5)
#endif


/*
 * VP_STATUS OEMGetParms(query);
 *
 * struct query_structure *query;   Description of video card setup
 *
 * Routine to fill in the mode tables for an OEM version of one
 * of our video cards which lacks an EEPROM to store this data.
 *
 * Returns:
 *  NO_ERROR                if successful
 *  ERROR_DEV_NOT_EXIST     if an unknown OEM card is specified
 *  ERROR_INVALID_PARAMETER         if an error occurs
 */
VP_STATUS OEMGetParms(struct query_structure *query)
{
struct st_mode_table *pmode;    /* Mode table we are currently working on */
struct st_mode_table ListOfModes[RES_1280 - RES_640 + 1];
VP_STATUS RetVal;           /* Value returned by called functions */
short CurrentResolution;    /* Resolution we are setting up */
long NumPixels;             /* Number of pixels at current resolution */
long MemAvail;              /* Bytes of video memory available to accelerator */
UCHAR Scratch;              /* Temporary variable */
short   StartIndex;         /* First mode for SetFixedModes() to set up */
short   EndIndex;           /* Last mode for SetFixedModes() to set up */
BOOL    ModeInstalled;      /* Is this resolution configured? */
WORD    Multiplier;         /* Pixel clock multiplier */
USHORT  OEMType;            /* Which OEM accelerator we are dealing with */
ULONG   OEMInfoOffset;      /* Offset of OEM information block into the BIOS */
short MaxModes;             /* Maximum number of modes possible */
short FreeTables;            /* Number of remaining free mode tables */

    /*
     * Clear out our mode tables, then check to see which OEM card
     * we are dealing with and read its CRT parameters.
     */
    VideoPortZeroMemory(ListOfModes, (RES_1280-RES_640+1)*sizeof(struct st_mode_table));

    /*
     * Try to auto-detect the type of OEM accelerator using recognition
     * strings in the BIOS. If we can't identify the OEM in this manner,
     * or there is no BIOS, treat it as a generic OEM card.
     */
    if (query->q_bios != FALSE)
        {
        if ((OEMInfoOffset = DetectDell(query)) != 0)
            OEMType = OEM_DELL_OMNIPLEX;
        else if (*(PULONG)(query->q_bios + AST_REC_OFFSET) == AST_REC_VALUE)
            OEMType = OEM_AST_PREMMIA;
        else
            OEMType = OEM_UNKNOWN;
        }
    else
        {
        OEMType = OEM_UNKNOWN;
        }

    /*
     * The ATIOEM registry field can override the auto-detected OEM type.
     * If this field is not present, or we don't recognize the value
     * it contains, continue with the OEM type we detected in the
     * previous step.
     */
    RegistryBufferLength = 0;

    if (VideoPortGetRegistryParameters(phwDeviceExtension,
                                       L"ATIOEM",
                                       FALSE,
                                       RegistryParameterCallback,
                                       NULL) == NO_ERROR)
        {
        VideoDebugPrint((DEBUG_DETAIL, "ATIOEM field found\n"));
        if (RegistryBufferLength == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Registry call gave Zero Length\n"));
            }
        else if (!CompareASCIIToUnicode("AST", RegistryBuffer, CASE_INSENSITIVE))
            {
            OEMType = OEM_AST_PREMMIA;
            }
        else if (!CompareASCIIToUnicode("DELL", RegistryBuffer, CASE_INSENSITIVE))
            {
            OEMType = OEM_DELL_OMNIPLEX;
            /*
             * If the auto-detection failed, assume the Dell header
             * starts at the default location (for Sylvester/Omniplex
             * determination). If the auto-detection succeeded, but
             * the ATIOEM registry field still exists, leave this
             * value alone.
             */
            if (OEMInfoOffset == 0)
                OEMInfoOffset = DELL_REC_SPACING;
            }
        else
            {
            VideoPortLogError(phwDeviceExtension, NULL, VID_ATIOEM_UNUSED, 20);
            }
        }

    /*
     * Load the frequency table corresponding to 
     * the selected OEM type, unless it uses the
     * same frequency table as our retail clock chip.
     *
     */
    
    /*
     * Load the table for the desired OEM type.
     */
    if (OEMType == OEM_DELL_OMNIPLEX)
        {
        /*
         * On a Sylvester (more recent model than the Omniplex),
         * we must read the clock frequency table from the BIOS
         * rather than using the Omniplex table. Otherwise, the
         * two machines can be handled in the same manner.
         *
         * DetectSylvester() will load the clock frequency table
         * if it finds a Sylvester, and return without loading
         * the table if it finds a non-Sylvester machine.
         */
        if (DetectSylvester(query,OEMInfoOffset) == FALSE)
            {
            ClockGenerator[0]  =  25175000L;
            ClockGenerator[1]  =  28322000L;
            ClockGenerator[2]  =  31500000L;
            ClockGenerator[3]  =  36000000L;
            ClockGenerator[4]  =  40000000L;
            ClockGenerator[5]  =  44900000L;
            ClockGenerator[6]  =  50000000L;
            ClockGenerator[7]  =  65000000L;
            ClockGenerator[8]  =  75000000L;
            ClockGenerator[9]  =  77500000L;
            ClockGenerator[10] =  80000000L;
            ClockGenerator[11] =  90000000L;
            ClockGenerator[12] = 100000000L;
            ClockGenerator[13] = 110000000L;
            ClockGenerator[14] = 126000000L;
            ClockGenerator[15] = 135000000L;
            }
        }
    else if (OEMType == OEM_AST_PREMMIA)
        {
        ClockGenerator[0]  =  50000000L;
        ClockGenerator[1]  =  63000000L;
        ClockGenerator[2]  =  92400000L;
        ClockGenerator[3]  =  36000000L;
        ClockGenerator[4]  =  50350000L;
        ClockGenerator[5]  =  56640000L;
        ClockGenerator[6]  =         0L;
        ClockGenerator[7]  =  44900000L;
        ClockGenerator[8]  =  67500000L;
        ClockGenerator[9]  =  31500000L;
        ClockGenerator[10] =  55000000L;
        ClockGenerator[11] =  80000000L;
        ClockGenerator[12] =  39910000L;
        ClockGenerator[13] =  72000000L;
        ClockGenerator[14] =  75000000L;
        ClockGenerator[15] =  65000000L;
        }

    /*
     * else (this OEM type uses the retail frequency table)
     */


    /*
     * Checking the number of modes available would involve
     * duplicating most of the code to fill in the mode tables.
     * Since this is to determine how much memory is needed
     * to hold the query structure, we can assume the worst
     * case (all possible modes are present). This would be:
     *
     * Resolution   Pixel Depths (BPP)  Refresh rates (Hz)      Number of modes
     * 640x480      4,8,16,24           HWD,60,72               12
     * 800x600      4,8,16,24           HWD,56,60,70,72,89,95   28
     * 1024x768     4,8,16              HWD,60,66,70,72,87      18
     * 1280x1024    4,8                 HWD,60,70,74,87,95      12
     *
     * HWD = hardware default refresh rate (rate set by INSTALL)
     *
     * Total: 70 modes
     */
    if (QUERYSIZE < (70 * sizeof(struct st_mode_table) + sizeof(struct query_structure)))
        return ERROR_INSUFFICIENT_BUFFER;

    MaxModes = (QUERYSIZE - sizeof(struct query_structure)) /
                                          sizeof(struct st_mode_table); 

    /*
     * Load the configured mode tables corresponding
     * to the selected OEM type. If there is no custom monitor description,
     * and we do not recognize the OEM type, use only the predefined
     * mode tables.
     *
     */

    /*
     * Load the configured mode tables according to the OEM type
     * detected.
     * AST machines load the entire list of mode tables (all
     * pixel depths, including "canned" modes). Generic OEM
     * machines only load the "canned" modes (done later).
     */
    if (OEMType == OEM_DELL_OMNIPLEX)
        {
        RetVal = ReadDell(ListOfModes);
        }
    else if (OEMType == OEM_AST_PREMMIA)
        {
        RetVal = ReadAST(query);
        return RetVal;
        }


    /*
     * Get a pointer into the mode table section of the query structure.
     */
    pmode = (struct st_mode_table *)query;  // first mode table at end of query
    ((struct query_structure *)pmode)++;

    /*
     * Get the amount of available video memory.
     */
    MemAvail = query->q_memory_size * QUARTER_MEG;  // Total memory installed
    /*
     * Subtract the amount of memory reserved for the VGA. This only
     * applies to the Graphics Ultra, since the 8514/ULTRA has no
     * VGA, and we will set all memory as shared on the Mach 32.
    if (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA)
        MemAvail -= (query->q_VGA_boundary * QUARTER_MEG);

    /*
     * Initially assume no video modes are available.
     */
    query->q_number_modes = 0;
    query->q_status_flags = 0;

    /*
     * Fill in the mode tables section of the query structure.
     */
    for (CurrentResolution = RES_640; CurrentResolution <= RES_1280; CurrentResolution++)
        {
        /*
         * Skip over 1152x864 (new resolution for Mach 64, which
         * would require extensive re-work for Mach 32, the family
         * for which this module was written).
         */
        if (CurrentResolution == RES_1152)
            continue;

        /*
         * If this resolution is configured, indicate that there is a
         * hardware default mode. If not, only list the "canned" refresh
         * rates for this resolution.
         */
        if (!ListOfModes[CurrentResolution].m_h_total)
            ModeInstalled = FALSE;
        else
            ModeInstalled = TRUE;

        /*
         * Find the number of pixels for the current resolution.
         */
        switch (CurrentResolution)
            {
            case RES_640:
                /*
                 * On a Mach 32 with no aperture, we use a screen pitch
                 * of 1024. Other cases and Mach 32 with an aperture
                 * use a screen pitch of the number of pixels.
                 */
#if !defined (SPLIT_RASTERS)
                if((phwDeviceExtension->ModelNumber == MACH32_ULTRA)
                    && (query->q_aperture_cfg == 0))
                    ListOfModes[CurrentResolution].m_screen_pitch = 1024;
                else
#endif
                  ListOfModes[CurrentResolution].m_screen_pitch = 640;
                NumPixels = ListOfModes[CurrentResolution].m_screen_pitch * 480;
                query->q_status_flags |= VRES_640x480;
                ListOfModes[CurrentResolution].Refresh = DEFAULT_REFRESH;
                StartIndex = B640F60;
                EndIndex = B640F72;
                break;

            case RES_800:
                /*
                 * On a Mach 32 with no aperture, we use a screen pitch
                 * of 1024. Mach 32 rev. 3 and Mach 8 cards need a screen
                 * pitch which is a multiple of 128. Other cases and
                 * Mach 32 rev. 6 and higher with an aperture use a screen
                 * pitch of the number of pixels.
                 */
#if defined (SPLIT_RASTERS)
                if ((query->q_asic_rev == CI_68800_3)
#else
                if((phwDeviceExtension->ModelNumber == MACH32_ULTRA)
                    && (query->q_aperture_cfg == 0))
                    ListOfModes[CurrentResolution].m_screen_pitch = 1024;
                else if ((query->q_asic_rev == CI_68800_3)
#endif
                    || (query->q_asic_rev == CI_38800_1)
                    || (query->q_bus_type == BUS_PCI))
                    ListOfModes[CurrentResolution].m_screen_pitch = 896;
                else
                    ListOfModes[CurrentResolution].m_screen_pitch = 800;
                NumPixels = ListOfModes[CurrentResolution].m_screen_pitch * 600;
                query->q_status_flags |= VRES_800x600;
                ListOfModes[CurrentResolution].Refresh = DEFAULT_REFRESH;
                StartIndex = B800F89;
                EndIndex = B800F72;
                break;

            case RES_1024:
                ListOfModes[CurrentResolution].m_screen_pitch = 1024;
                NumPixels = ListOfModes[CurrentResolution].m_screen_pitch * 768;
                query->q_status_flags |= VRES_1024x768;
                ListOfModes[CurrentResolution].Refresh = DEFAULT_REFRESH;
                StartIndex = B1024F87;
                EndIndex = B1024F72;
                break;

            case RES_1280:
                ListOfModes[CurrentResolution].m_screen_pitch = 1280;
                NumPixels = ListOfModes[CurrentResolution].m_screen_pitch * 1024;
                query->q_status_flags |= VRES_1024x768;
                ListOfModes[CurrentResolution].Refresh = DEFAULT_REFRESH;
                StartIndex = B1280F87;
                /*
                 * 1280x1024 noninterlaced has the following restrictions:
                 *
                 * Dell machines:
                 *  VRAM supports up to 70Hz
                 *  DRAM supports up to 74Hz
                 *
                 * Other machines:
                 *  VRAM supports up to 74Hz
                 *  DRAM supports up to 60Hz
                 *
                 * This is because Dell uses faster (and more expensive)
                 * DRAM than on our retail cards (non-x86 implementations
                 * will hit this code block on retail cards), but has
                 * problems at 74Hz on their VRAM implementations. Other
                 * OEMs have not requested that their cards be treated
                 * differently from our retail cards in this respect.
                 */
                if ((query->q_memory_type == VMEM_DRAM_256Kx4) ||
                    (query->q_memory_type == VMEM_DRAM_256Kx16) ||
                    (query->q_memory_type == VMEM_DRAM_256Kx4_GRAP))
                    {
                    if (OEMType == OEM_DELL_OMNIPLEX)
                        EndIndex = B1280F74;
                    else
                        EndIndex = B1280F60;
                    }
                else
                    {
                    if (OEMType == OEM_DELL_OMNIPLEX)
                        EndIndex = B1280F70;
                    else
                        EndIndex = B1280F74;
                    }
                break;
            }

        /*
         * For each supported pixel depth at the given resolution,
         * copy the mode table, fill in the colour depth field,
         * and increment the counter for the number of supported modes.
         * Test 4BPP before 8BPP so the mode tables will appear in
         * increasing order of pixel depth.
         */
        if (NumPixels <= MemAvail*2)
            {
            if (ModeInstalled)
                {
                VideoPortMoveMemory(pmode, &ListOfModes[CurrentResolution],
                            sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 4;
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   4,
                                                   ListOfModes[CurrentResolution].m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }
        if (NumPixels <= MemAvail)
            {
            if (ModeInstalled)
                {
                VideoPortMoveMemory(pmode, &ListOfModes[CurrentResolution],
                                    sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 8;
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   8,
                                                   ListOfModes[CurrentResolution].m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }

        /*
         * Resolutions above 8BPP are only available for the Mach 32.
         */
        if (phwDeviceExtension->ModelNumber != MACH32_ULTRA)
            continue;

        /*
         * 16, 24, and 32 BPP require a DAC which can support
         * the selected pixel depth at the current resolution
         * as well as enough memory.
         */
        if ((NumPixels*2 <= MemAvail) &&
            (MaxDepth[query->q_DAC_type][CurrentResolution] >= 16))
            {
            VideoPortMoveMemory(pmode, &ListOfModes[CurrentResolution],
                    sizeof(struct st_mode_table));
            /*
             * Handle DACs that require higher pixel clocks for 16BPP.
             */
            if ((query->q_DAC_type == DAC_BT48x) ||
                (query->q_DAC_type == DAC_SC15026) ||
                (query->q_DAC_type == DAC_ATT491))
                {
                pmode->ClockFreq *= 2;
                Multiplier = CLOCK_DOUBLE;
                if (CurrentResolution == RES_800)
                    EndIndex = B800F60;     /* 70 Hz and up not supported at 16BPP */
                }
            else
                {
                Scratch = 0;
                Multiplier = CLOCK_SINGLE;
                }

            pmode->m_pixel_depth = 16;

            /*
             * If this resolution is not configured, or if we need to
             * double the clock frequency but can't, ignore the mode
             * table we just created.
             */
            if (ModeInstalled && (Scratch != 0xFF))
                {
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   Multiplier,
                                                   16,
                                                   ListOfModes[CurrentResolution].m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }


        /*
         * Our new source stream display driver needs a linear aperture
         * in order to handle 24BPP. Since the display driver doesn't
         * have access to the aperture information when it is deciding
         * which modes to pass on to the display applet, it can't make
         * the decision to reject 24BPP modes for cards with only a
         * VGA aperture. This decision must therefore be made in the
         * miniport, so in a paged aperture configuration there are no
         * 24BPP modes for the display driver to accept or reject.
         *
         * On the Alpha, we can't use dense space on the Mach 32 LFB,
         * so we treat it as a no-aperture case.
         */
        if (query->q_aperture_cfg == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP not available because we don't have a linear aperture\n"));
            continue;
            }

#if defined(ALPHA)
        VideoDebugPrint((DEBUG_DETAIL, "24BPP not available in sparse space on Alpha\n"));
        continue;
#endif

        /*
         * 800x600 24BPP exhibits screen tearing unless the pitch
         * is a multiple of 128 (only applies to Rev. 6, since Rev. 3
         * and PCI implementations already have a pitch of 896).
         * Other pixel depths are not affected, and other resolutions
         * are already a multiple of 128 pixels wide.
         *
         * Expand the 800x600 pitch to 896 here, rather than for
         * all pixel depths, because making the change for all
         * pixel depths would disable 16BPP (which doesn't have
         * the problem) on 1M cards. The screen pitch will only
         * be 800 on cards which will exhibit this problem - don't
         * check for a resolution of 800x600 because we don't want
         * to cut the pitch from 1024 down to 896 if SPLIT_RASTERS
         * is not defined.
         */
        if (ListOfModes[CurrentResolution].m_screen_pitch == 800)
            {
            ListOfModes[CurrentResolution].m_screen_pitch = 896;
            NumPixels = (long) ListOfModes[CurrentResolution].m_screen_pitch * 600;
            }

        if ((NumPixels*3 <= MemAvail) &&
            (MaxDepth[query->q_DAC_type][CurrentResolution] >= 24))
            {
            VideoPortMoveMemory(pmode, &ListOfModes[CurrentResolution],
                                sizeof(struct st_mode_table));
            pmode->m_pixel_depth = 24;

            /*
             * Handle DACs that require higher pixel clocks for 24BPP.
             */
            Scratch = 0;
            if ((query->q_DAC_type == DAC_STG1700) ||
                (query->q_DAC_type == DAC_ATT498))
                {
                pmode->ClockFreq *= 2;
                Multiplier = CLOCK_DOUBLE;
                }
            else if ((query->q_DAC_type == DAC_SC15021) ||
                (query->q_DAC_type == DAC_STG1702) ||
                (query->q_DAC_type == DAC_STG1703))
                {
                pmode->ClockFreq *= 3;
                pmode->ClockFreq >>= 1;
                Multiplier = CLOCK_THREE_HALVES;
                }
            else if ((query->q_DAC_type == DAC_BT48x) ||
                (query->q_DAC_type == DAC_SC15026) ||
                (query->q_DAC_type == DAC_ATT491))
                {
                pmode->ClockFreq *= 3;
                Multiplier = CLOCK_TRIPLE;
                EndIndex = B640F60;     /* Only supports 24BPP in 640x480 60Hz */
                }
            else
                {
                Multiplier = CLOCK_SINGLE;
                if ((query->q_DAC_type == DAC_TI34075) && (CurrentResolution == RES_800))
                    EndIndex = B800F70;
                }

            /*
             * If we needed to alter the clock frequency, and couldn't
             * generate an appropriate selector/divisor pair,
             * then ignore this mode.
             */
            if (ModeInstalled && (Scratch != 0x0FF))
                {
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   Multiplier,
                                                   24,
                                                   ListOfModes[CurrentResolution].m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }

        }

    return NO_ERROR;

}   /* OEMGetParms() */


/*
 * LONG CompareASCIIToUnicode(Ascii, Unicode, IgnoreCase);
 *
 * PUCHAR Ascii;    ASCII string to be compared
 * PUCHAR Unicode;  Unicode string to be compared
 * BOOL IgnoreCase; Flag to determine case sensitive/insensitive comparison
 *
 * Compare 2 strings, one ASCII and the other UNICODE, to see whether
 * they are equal, and if not, which one is first in alphabetical order.
 *
 * Returns:
 *  0           if strings are equal
 *  positive    if ASCII string comes first
 *  negative    if UNICODE string comes first
 */
LONG CompareASCIIToUnicode(PUCHAR Ascii, PUCHAR Unicode, BOOL IgnoreCase)
{
UCHAR   CharA;
UCHAR   CharU;

    /*
     * Keep going until both strings have a simultaneous null terminator.
     */
    while (*Ascii || *Unicode)
        {
        /*
         * Get the next character from each string. If we are doing a
         * case-insensitive comparison, translate to upper case.
         */
        if (IgnoreCase)
            {
            if ((*Ascii >= 'a') && (*Ascii <= 'z'))
                CharA = *Ascii - ('a'-'A');
            else
                CharA = *Ascii;

            if ((*Unicode >= 'a') && (*Unicode <= 'z'))
                CharU = *Unicode - ('a' - 'A');
            else
                CharU = *Unicode;
            }
        else{
            CharA = *Ascii;
            CharU = *Unicode;
            }

        /*
         * Check if one of the characters precedes the other. This will
         * catch the case of unequal length strings, since the null
         * terminator on the shorter string will precede any character
         * in the longer string.
         */
        if (CharA < CharU)
            return 1;
        else if (CharA > CharU)
            return -1;

        /*
         * Advance to the next character in each string. Unicode strings
         * occupy 2 bytes per character, so we must check only every
         * second character.
         */
        Ascii++;
        Unicode++;
        Unicode++;
        }

    /*
     * The strings are identical and of equal length.
     */
    return 0;

}   /* CompareASCIIToUnicode() */




/*
 * VP_STATUS ReadAST(Modes);
 *
 * struct query_structure *query;   Mode tables to be filled in
 *
 * Routine to get CRT parameters for AST versions of
 * our cards. All AST cards choose from a limited selection
 * of vertical refresh rates with no "custom monitor" option,
 * so we can use hardcoded tables for each refresh rate. We
 * can't use the BookVgaTable() function, since AST cards have
 * a different clock chip from retail cards, resulting in different
 * values in the ClockSel field for AST and retail versions. Also,
 * AST cards all use the Brooktree DAC.
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadAST(struct query_structure *query)
{
struct st_mode_table *pmode;    /* Mode table we are currently working on */
struct st_mode_table *OldPmode; /* Mode table pointer before SetFixedModes() call */
unsigned char Frequency;        /* Vertical refresh rate for monitor */
long NumPixels;                 /* Number of pixels at current resolution */
USHORT Pitch;                   /* Screen pitch */
long MemAvail;                  /* Bytes of video memory available to accelerator */
USHORT LastNumModes;            /* Number of modes not including current resolution */
short StartIndex;               /* First mode for SetFixedModes() to set up */
short EndIndex;                 /* Last mode for SetFixedModes() to set up */
short HWIndex;                  /* Mode selected as hardware default */
USHORT PixelDepth;              /* Pixel depth we are working on */
#if (TARGET_BUILD >= 350)
ULONG EisaId;                   /* EISA ID of the motherboard */
#endif
short MaxModes;                 /* Maximum number of modes possible */
short FreeTables;               /* Number of remaining free mode tables */


#if (TARGET_BUILD >= 350)
    /*
     * The Premmia SE splits its aperture location between MEM_CFG and
     * SCRATCH_PAD_0, but does not set the flag bit (bit 0 of BIOS byte
     * 0x62). According to AST, the only way to distinguish this from
     * other Premmia machines is to check its EISA ID.
     *
     * The VideoPortGetBusData() routine is not available in NT 3.1,
     * so Premmia users running NT 3.1 are out of luck.
     */
    VideoPortGetBusData(phwDeviceExtension,
                        EisaConfiguration,
                        PREMMIA_SE_SLOT,
                        &EisaId,
                        EISA_ID_OFFSET,
                        sizeof(ULONG));

    if (EisaId == PREMMIA_SE_ID)
    {
        query->q_aperture_addr = (INPW(MEM_CFG) & 0x7F00) >> 8;
        query->q_aperture_addr |= ((INPW(SCRATCH_PAD_0) & 0x1F00) >> 1);
    }
#endif


    /*
     * Get the memory size in nybbles (half a byte). A 4BPP pixel
     * uses 1 nybble. For other depths, compare this number to the
     * product of the number of pixels needed and the number of
     * nybbles per pixel.
     *
     * The q_memory_size field contains the number of quarter-megabyte
     * blocks of memory available, so multiplying it by HALF_MEG yields
     * the number of nybbles of video memory.
     */
    MemAvail = query->q_memory_size * HALF_MEG;

    /*
     * Initially assume no video modes.
     */
    query->q_number_modes = 0;
    LastNumModes = 0;
    query->q_status_flags = 0;

    /*
     * Get a pointer into the mode table section of the query structure.
     */
    pmode = (struct st_mode_table *)query;  // first mode table at end of query
    ((struct query_structure *)pmode)++;


    MaxModes = (QUERYSIZE - sizeof(struct query_structure)) /
                                          sizeof(struct st_mode_table); 
    /*
     * Find out which refresh rate is used at 640x480, and fill in the
     * mode tables for the various pixel depths at this resoulution.
     */
    OUTP(reg1CE, AST_640_STORE);
    Frequency = INP(reg1CF);
    switch(Frequency)
        {
        case M640F72AST:
            HWIndex = B640F72;
            break;

        case M640F60AST:
        default:
            HWIndex = B640F60;
            break;
        }

    /*
     * Select the "canned" mode tables for 640x480, and get
     * information regarding the screen size. The Premmia always
     * has the linear aperture enabled, so we don't need to
     * stretch the pitch to 1024. Also, it always uses a
     * Mach 32 ASIC and a BT48x or equivalent DAC, so we
     * don't need to check the ASIC family or DAC type
     * to determine if a particular resolution/pixel depth/
     * refresh rate combination is supported.
     */
    StartIndex = B640F60;
    EndIndex = B640F72;
    Pitch = 640;
    NumPixels = Pitch * 480;

    /*
     * Fill in the mode tables for 640x480 at all pixel depths.
     */
    for (PixelDepth = DEPTH_4BPP; PixelDepth <= DEPTH_24BPP; PixelDepth++)
        {
        /*
         * Only include modes if there is enough memory.
         */
        if ((NumPixels * ASTNybblesPerPixel[PixelDepth]) <= MemAvail)
            {
            /*
             * 640x480 24BPP is only available at 60Hz.
             */
            if (ASTDepth[PixelDepth] == 24)
                {
                HWIndex = B640F60;
                EndIndex = B640F60;
                }

            /*
             * Set up the hardware default refresh rate.
             */
            OldPmode = pmode;

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(HWIndex,
                                                   HWIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            OldPmode->Refresh = DEFAULT_REFRESH;

            /*
             * Set up the canned mode tables.
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);

            }   /* end if (enough memory for 640x480) */

        }   /* end for (loop on 640x480 pixel depth) */

    /*
     * If we installed any 640x480 mode tables, report that
     * 640x480 is supported.
     */
    if (query->q_number_modes > LastNumModes)
        {
        query->q_status_flags |= VRES_640x480;
        LastNumModes = query->q_number_modes;
        }


    /*
     * Find out which refresh rate is used at 800x600, and fill in the
     * mode tables for the various pixel depths at this resoulution.
     */
    OUTP(reg1CE, AST_800_STORE);
    Frequency = INP(reg1CF);
    switch(Frequency)
        {
        case M800F72AST:
            HWIndex = B800F72;
            break;

        case M800F60AST:
            HWIndex = B800F60;
            break;

        case M800F56AST:
        default:
            HWIndex = B800F56;
            break;
        }

    /*
     * Select the "canned" mode tables for 800x600, and get
     * information regarding the screen size. 68800-3 cards
     * need a screen pitch that is a multiple of 128.
     */
    StartIndex = B800F89;
    EndIndex = B800F72;
    if (query->q_asic_rev == CI_68800_3)
        Pitch = 896;
    else
        Pitch = 800;
    NumPixels = Pitch * 600;

    /*
     * Fill in the mode tables for 800x600 at all pixel depths.
     */
    for (PixelDepth = DEPTH_4BPP; PixelDepth <= DEPTH_16BPP; PixelDepth++)
        {
        /*
         * Only include modes if there is enough memory.
         */
        if ((NumPixels * ASTNybblesPerPixel[PixelDepth]) <= MemAvail)
            {
            /*
             * 800x600 16BPP is only supported for 56Hz, 60Hz,
             * and interlaced. Machines with a hardware default
             * of 72Hz fall back to 56Hz.
             */
            if (ASTDepth[PixelDepth] == 16)
                {
                HWIndex = B800F56;
                EndIndex = B800F60;
                }

            /*
             * Set up the hardware default refresh rate.
             */
            OldPmode = pmode;

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(HWIndex,
                                                   HWIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            OldPmode->Refresh = DEFAULT_REFRESH;

            /*
             * Set up the canned mode tables.
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);

            }   /* end if (enough memory for 800x600) */

        }   /* end for (loop on 800x600 pixel depth) */

    /*
     * If we installed any 800x600 mode tables, report that
     * 800x600 is supported.
     */
    if (query->q_number_modes > LastNumModes)
        {
        query->q_status_flags |= VRES_800x600;
        LastNumModes = query->q_number_modes;
        }


    /*
     * Find out which refresh rate is used at 1024x768, and fill in the
     * mode tables for the various pixel depths at this resoulution.
     */
    OUTP(reg1CE, AST_1024_STORE);
    Frequency = INP(reg1CF);
    switch(Frequency)
        {
        case M1024F72AST:
            HWIndex = B1024F72;
            break;

        case M1024F70AST:
            HWIndex = B1024F70;
            break;

        case M1024F60AST:
            HWIndex = B1024F60;
            break;

        case M1024F87AST:
        default:
            HWIndex = B1024F87;
            break;
        }

    /*
     * Select the "canned" mode tables for 1024x768.
     */
    StartIndex = B1024F87;
    EndIndex = B1024F72;
    Pitch = 1024;
    NumPixels = Pitch * 768;

    /*
     * Fill in the mode tables for 1024x768 at all pixel depths.
     */
    for (PixelDepth = DEPTH_4BPP; PixelDepth <= DEPTH_8BPP; PixelDepth++)
        {
        /*
         * Only include modes if there is enough memory.
         */
        if ((NumPixels * ASTNybblesPerPixel[PixelDepth]) <= MemAvail)
            {
            /*
             * Set up the hardware default refresh rate.
             */
            OldPmode = pmode;

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(HWIndex,
                                                   HWIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            OldPmode->Refresh = DEFAULT_REFRESH;

            /*
             * Set up the canned mode tables.
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);

            }   /* end if (enough memory for 1024x768) */

        }   /* end for (loop on 1024x768 pixel depth) */

    /*
     * If we installed any 1024x768 mode tables, report that
     * 1024x768 is supported.
     */
    if (query->q_number_modes > LastNumModes)
        {
        query->q_status_flags |= VRES_1024x768;
        LastNumModes = query->q_number_modes;
        }


    /*
     * Select the "canned" mode tables for 1280x1024.
     *
     * The DACs used on AST Premmia machines only support
     * interlaced modes at this resolution, and there
     * is no configured hardware default refresh rate.
     */
    StartIndex = B1280F87;
    EndIndex = B1280F95;
    Pitch = 1280;
    NumPixels = Pitch * 1024;

    /*
     * Fill in the mode tables for 1280x1024 at all pixel depths.
     */
    for (PixelDepth = DEPTH_4BPP; PixelDepth <= DEPTH_8BPP; PixelDepth++)
        {
        /*
         * Only include modes if there is enough memory.
         */
        if ((NumPixels * ASTNybblesPerPixel[PixelDepth]) <= MemAvail)
            {
            /*
             * Set up the canned mode tables.
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   ASTClockMult[PixelDepth],
                                                   ASTDepth[PixelDepth],
                                                   Pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);

            }   /* end if (enough memory for 1280x1024) */

        }   /* end for (loop on 1280x1024 pixel depth) */

    /*
     * If we installed any 1280x1024 mode tables, report that
     * 1280x1024 is supported.
     */
    if (query->q_number_modes > LastNumModes)
        query->q_status_flags |= VRES_1280x1024;

    return NO_ERROR;

}   /* ReadAST() */


/*
 * VP_STATUS ReadZenith(, Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Routine to get CRT parameters for Zenith versions of
 * our cards. Mapped to NEC 3D or compatible until we get
 * info on how to read the actual parameters.
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadZenith(struct st_mode_table *Modes)
{
    ReadOEM3(Modes);
    return NO_ERROR;

}


/*
 * VP_STATUS ReadOlivetti(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Routine to get CRT parameters for Olivetti versions of
 * our cards. Mapped to NEC 3D or compatible until we get
 * info on how to read the actual parameters.
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOlivetti(struct st_mode_table *Modes)
{
    ReadOEM3(Modes);
    return NO_ERROR;
}



/***************************************************************************
 *
 * VP_STATUS ReadDell(Modes);
 *
 * struct st_mode_table *Modes; Mode table to be filled in
 *
 * DESCRIPTION:
 *  Routine to get CRT parameters for Dell versions of our cards.
 *
 * RETURN VALUE:
 *  NO_ERROR
 *
 * GLOBALS CHANGED:
 *  ClockGenerator[] array
 *
 * CALLED BY:
 *  OEMGetParms()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS ReadDell(struct st_mode_table *Modes)
{
struct st_mode_table *pmode;    /* Mode table we are currently working on */
UCHAR Fubar;                    // Temporary variable

    pmode = Modes;

    /*
     * Get the 640x480 mode table.
     *
     * NOTE: Modes points to an array of 4 mode tables, one for each
     *       resolution. If a resolution is not configured, its
     *       mode table is left empty.
     */
    OUTP(reg1CE, DELL_640_STORE);
    Fubar = INP(reg1CF);
    VideoDebugPrint((DEBUG_DETAIL, "Dell 640x480: 0x1CF reports 0x%X\n", Fubar));
    switch(Fubar & MASK_640_DELL)
        {
        case M640F72DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 640x480: 72Hz\n"));
            BookVgaTable(B640F72, pmode);
            break;

        case M640F60DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 640x480: 60Hz explicit\n"));
        default:                /* All VGA monitors support 640x480 60Hz */
            VideoDebugPrint((DEBUG_DETAIL, "Dell 640x480: 60Hz\n"));
            BookVgaTable(B640F60, pmode);
            break;
        }
    pmode++;

    /*
     * Get the 800x600 mode table.
     */
    OUTP(reg1CE, DELL_800_STORE);
    Fubar = INP(reg1CF);
    VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 0x1CF reports 0x%X\n", Fubar));
    switch(Fubar & MASK_800_DELL)
        {
        case M800F72DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 72Hz\n"));
            BookVgaTable(B800F72, pmode);
            break;

        case M800F60DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 60Hz\n"));
            BookVgaTable(B800F60, pmode);
            break;

        case M800F56DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 56Hz explicit\n"));
        default:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 800x600: 56Hz\n"));
            BookVgaTable(B800F56, pmode);
            break;
        }
    pmode++;

    /*
     * Get the 1024x768 mode table.
     */
    OUTP(reg1CE, DELL_1024_STORE);
    Fubar = INP(reg1CF);
    VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 0x1CF reports 0x%X\n", Fubar));
    switch(Fubar & MASK_1024_DELL)
        {
        case M1024F72DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 72Hz\n"));
            BookVgaTable(B1024F72, pmode);
            break;

        case M1024F70DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 70Hz\n"));
            BookVgaTable(B1024F70, pmode);
            break;

        case M1024F60DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 60Hz\n"));
            BookVgaTable(B1024F60, pmode);
            break;

        case M1024F87DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 87Hz interlaced explicit\n"));
        default:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1024x768: 87Hz interlaced\n"));
            BookVgaTable(B1024F87, pmode);
            break;
        }
    pmode++;

    /*
     * Skip 1152x864. This mode is not used on Mach 32 cards, and
     * this routine is only called for Mach 32 cards.
     */
    pmode++;

    /*
     * Get the 1280x1024 mode table.
     */
    OUTP(reg1CE, DELL_1280_STORE);
    Fubar = INP(reg1CF);
    VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 0x1CF reports 0x%X\n", Fubar));
    switch(Fubar & MASK_1280_DELL)
        {
        case M1280F74DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 74Hz\n"));
            BookVgaTable(B1280F74, pmode);
            break;

        case M1280F70DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 70Hz\n"));
            BookVgaTable(B1280F70, pmode);
            break;

        case M1280F60DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 60Hz\n"));
            BookVgaTable(B1280F60, pmode);
            break;

        case M1280F87DELL:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 87Hz interlaced explicit\n"));
        default:
            VideoDebugPrint((DEBUG_DETAIL, "Dell 1280x1024: 87Hz interlaced\n"));
            BookVgaTable(B1280F87, pmode);
            break;
        }

    return NO_ERROR;

}   /* ReadDell() */



/***************************************************************************
 *
 * ULONG DetectDell(Query);
 *
 * struct query_structure *Query;   Description of video card setup
 *
 * DESCRIPTION:
 *  Routine to check whether or not we are dealing with a Dell machine.
 *
 * RETURN VALUE:
 *  Offset of beginning of the Dell information block into the BIOS
 *  0 if this is not a Dell OEM implementation.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  OEMGetParms()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

ULONG DetectDell(struct query_structure *Query)
{
    ULONG CurrentOffset;    /* Current offset to check for Dell signature */
    ULONG BiosLength;       /* Length of the video BIOS */

    /*
     * Dell OEM implementations will have an information block
     * starting at an offset that is a multiple of DELL_REC_SPACING
     * into the video BIOS. The first 4 bytes of this block will
     * contain the signature value DELL_REC_VALUE. Find out how
     * large the video BIOS is, and step through it checking for
     * the signature string. If we reach the end of the video
     * BIOS without finding the signature string, this is not
     * a Dell OEM implementation.
     */
    BiosLength = (ULONG)(VideoPortReadRegisterUchar(Query->q_bios + 2)) * 512;

    for(CurrentOffset = DELL_REC_SPACING; CurrentOffset < BiosLength; CurrentOffset += DELL_REC_SPACING)
        {
        if (VideoPortReadRegisterUlong((PULONG)(Query->q_bios + CurrentOffset)) == DELL_REC_VALUE)
            return CurrentOffset;
        }

    /*
     * Signature string not found, so this is not a Dell OEM implementation.
     */
    return 0;

}   /* DetectDell() */



/***************************************************************************
 *
 * BOOL DetectSylvester(Query, HeaderOffset);
 *
 * struct query_structure *Query;   Description of video card setup
 * ULONG HeaderOffset;              Offset of Dell header into video BIOS
 *
 * DESCRIPTION:
 *  Routine to check whether or not the Dell machine we are dealing
 *  with is a Sylvester (table of pixel clock frequencies is stored
 *  in BIOS image, rather than using a fixed table). If it is a
 *  Sylvester, load the table of clock frequencies.
 *
 * RETURN VALUE:
 *  TRUE if this is a Sylvester
 *  FALSE if this is not a Sylvester
 *
 * GLOBALS CHANGED:
 *  ClockGenerator[]
 *
 * CALLED BY:
 *  OEMGetParms()
 *
 * NOTE:
 *  Assumes that this is a Dell OEM implementation. Results are undefined
 *  when run on other systems.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL DetectSylvester(struct query_structure *Query, ULONG HeaderOffset)
{
    PUSHORT TablePointer;   /* Pointer to the clock table in the BIOS */
    USHORT Scratch;         /* Temporary variable */

    /*
     * Dell machines which store the clock table in the BIOS have
     * the signature DELL_TABLE_PRESENT at offset DELL_TP_OFFSET
     * into the video information table (which starts at offset
     * HeaderOffset into the BIOS). Older implementations (i.e.
     * the Omniplex) use a fixed frequency table, and do not have
     * this signature string.
     */
    if (VideoPortReadRegisterUshort((PUSHORT)(Query->q_bios + HeaderOffset + DELL_TP_OFFSET)) != DELL_TABLE_PRESENT)
        return FALSE;

    /*
     * This is a Sylvester. The offset of the frequency table into the
     * BIOS is stored at offset DELL_TABLE_OFFSET into the video
     * information table.
     */
    TablePointer = (PUSHORT)(Query->q_bios + VideoPortReadRegisterUshort((PUSHORT)(Query->q_bios + HeaderOffset + DELL_TABLE_OFFSET)));

    /*
     * The frequency table has a 4-byte header. The first 2 bytes are
     * the signature string DELL_TABLE_SIG - if this signature is not
     * present, assume that the DELL_TABLE_PRESENT string was actually
     * other data that happened to match, and treat this as an older
     * implementation.
     *
     * The last 2 bytes are the table type. Currently, only table type
     * 1 (16 entries, each is a word specifying the pixel clock frequency
     * in units of 10 kHz) is supported. Treat other table types as an
     * older implementation.
     */
    if (VideoPortReadRegisterUshort(TablePointer++) != DELL_TABLE_SIG)
        return FALSE;
    if (VideoPortReadRegisterUshort(TablePointer++) != 1)
        return FALSE;

    /*
     * We have found a valid frequency table. Load its contents into
     * our frequency table. The multiplication is because the table
     * in the BIOS is in units of 10 kHz, and our table is in Hz.
     */
    for (Scratch = 0; Scratch < 16; Scratch++)
        {
        ClockGenerator[Scratch] = VideoPortReadRegisterUshort(TablePointer++) * 10000L;
        }

    return TRUE;

}   /* DetectSylvester() */




/*
 * VP_STATUS ReadOEM1(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *
 *  (straight VGA monitor)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM1(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    return NO_ERROR;
}


/*
 * VP_STATUS ReadOEM2(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *  1024x768 87Hz interlaced
 *
 *  (8514-compatible monitor)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM2(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    BookVgaTable(B1024F87, &(Modes[RES_1024]));
    return NO_ERROR;
}


/*
 * VP_STATUS ReadOEM3(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *  800x600 56Hz noninterlaced
 *  1024x768 87Hz interlaced
 *
 *  (NEC 3D or compatible)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM3(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    BookVgaTable(B800F56, &(Modes[RES_800]));
    BookVgaTable(B1024F87, &(Modes[RES_1024]));
    return NO_ERROR;
}


/*
 * VP_STATUS ReadOEM4(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *  800x600 72Hz noninterlaced
 *  1024x768 60Hz noninterlaced
 *  1280x1024 87Hz interlaced
 *
 *  (TVM MediaScan 4A+ or compatible)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM4(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    BookVgaTable(B800F72, &(Modes[RES_800]));
    BookVgaTable(B1024F60, &(Modes[RES_1024]));
    BookVgaTable(B1280F87, &(Modes[RES_1280]));
    return NO_ERROR;
}


/*
 * VP_STATUS ReadOEM5(Modes);
 *
 * struct st_mode_table *Modes; Mode tables to be filled in
 *
 * Generic OEM monitor for future use.
 *
 * Resolutions supported:
 *  640x480 60Hz noninterlaced
 *  800x600 72Hz noninterlaced
 *  1024x768 72Hz noninterlaced
 *  1280x1024 60Hz noninterlaced
 *
 *  (NEC 5FG or compatible)
 *
 * Returns:
 *  NO_ERROR
 */
VP_STATUS ReadOEM5(struct st_mode_table *Modes)
{
    BookVgaTable(B640F60, &(Modes[RES_640]));
    BookVgaTable(B800F72, &(Modes[RES_800]));
    BookVgaTable(B1024F72, &(Modes[RES_1024]));
    BookVgaTable(B1280F60, &(Modes[RES_1280]));
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\cvtvdif.c ===
/************************************************************************/
/*                                                                      */
/*                              CVTVDIF.C                               */
/*                                                                      */
/*       July 12  1995 (c) 1993, 1995 ATI Technologies Incorporated.    */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.5  $
      $Date:   23 Jan 1996 11:45:32  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/cvtvdif.c_v  $
 * 
 *    Rev 1.5   23 Jan 1996 11:45:32   RWolff
 * Protected against false values of TARGET_BUILD.
 * 
 *    Rev 1.4   11 Jan 1996 19:39:06   RWolff
 * Now restricts "canned" mode tables by both maximum index and maximum
 * pixel clock frequency, and VDIF mode tables by maximum pixel clock
 * frequency only, rather than both by maximum refresh rate.
 * 
 *    Rev 1.3   19 Dec 1995 14:07:14   RWolff
 * Added debug print statements.
 * 
 *    Rev 1.2   30 Oct 1995 12:09:42   MGrubac
 * Fixed bug in calculating CRTC parameters based on read in data from VDIF files.
 * 
 *    Rev 1.1   26 Jul 1995 13:06:44   mgrubac
 * Moved mode tables merging to VDIFCallback() routine.
 * 
 *    Rev 1.0   20 Jul 1995 18:19:12   mgrubac
 * Initial revision.


End of PolyTron RCS section                             *****************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>

#include "dderror.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"      /* for VP_STATUS definition */
#include "vidlog.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#include "atioem.h"
#include "services.h"
#include "vdptocrt.h"
#include "vdpdata.h"
#include "cvtvdif.h"


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, SetOtherModeParameters)
#endif

void *pCallbackArgs;  /* Pointer for passing parameters to VDIFCallback() */ 

 
/**************************************************************************
 *
 * void SetOtherModeParameters( PixelDepth, Pitch, Multiplier, pmode)
 * WORD Multiplier;     What needs to be done to the pixel clock
 * WORD PixelDepth;     Number of bits per pixel
 * WORD Pitch;          Screen pitch to use
 * struct st_mode_table *pmode; Pointer to structure that must contain
 *                              at least the member ClockFreq
 *
 *
 * DESCRIPTION:
 *  Sets parameters PixelDepth, Pitch and adjusts ClockFreq 
 *
 * RETURN VALUE:
 *  None
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  SetFixedModes and VDIFCallback 
 *
 * AUTHOR:
 *  Miroslav Grubac
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/
void SetOtherModeParameters( WORD PixelDepth,
                              WORD Pitch,
                              WORD Multiplier,
                              struct st_mode_table *pmode)
{
    pmode->m_pixel_depth = (UCHAR) PixelDepth;
    pmode->m_screen_pitch = Pitch;

    /*
     * Take care of any pixel clock multiplication that is needed.
     */
    switch(Multiplier)
        {
        case CLOCK_TRIPLE:
            pmode->ClockFreq *= 3;
            break;

        case CLOCK_DOUBLE:
            pmode->ClockFreq *= 2;
            break;

        case CLOCK_THREE_HALVES:
            pmode->ClockFreq *= 3;
            pmode->ClockFreq >>= 1;
            break;

        case CLOCK_SINGLE:
        default:
            break;
        }

} /* SetOtherModeParameters() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\atint.h ===
/*************************************************************************
 **                                                                     **
 **                             ATINT.H                                 **
 **                                                                     **
 **     Copyright (c) 1992, ATI Technologies Inc.                       **
 *************************************************************************
    
  Contains information specific to Windows NT, and is common between
  the Install application ANTPANEL, and the Display and Miniport drivers.
 
  $Revision:   1.18  $
  $Date:   25 Apr 1996 14:21:40  $
  $Author:   RWolff  $
  $Log:   S:/source/wnt/ms11/miniport/archive/atint.h_v  $
 * 
 *    Rev 1.18   25 Apr 1996 14:21:40   RWolff
 * Forces build for NT 4.0, since all code drops to Microsoft will be
 * built under NT 4.0.
 * 
 *    Rev 1.17   23 Apr 1996 17:25:50   RWolff
 * Split reporting of "internal DAC cursor needs double buffering" from
 * "this is a CT", added flag to report 1M SDRAM cards.
 * 
 *    Rev 1.16   23 Jan 1996 11:41:36   RWolff
 * Now forces compile-time error if NTDDVDEO.H is not included before
 * this file rather than generating false values of TARGET_BUILD, added
 * DrvEscape() functions used by multiheaded display applet.
 * 
 *    Rev 1.15   22 Dec 1995 14:59:32   RWolff
 * Added support for Mach 64 GT internal DAC.
 * 
 *    Rev 1.14   21 Dec 1995 14:05:36   RWolff
 * Added TARGET_BUILD definition to identify which version of NT we are
 * building for, rather than using a different definition for each break
 * between versions.
 * 
 *    Rev 1.13   23 Nov 1995 11:25:10   RWolff
 * Added multihead support.
 * 
 *    Rev 1.12   24 Aug 1995 15:38:04   RWolff
 * Added definitions to report CT and VT ASICs to the display driver.
 * 
 *    Rev 1.11   27 Feb 1995 17:46:44   RWOLFF
 * Added flag for packed (relocatable) I/O to ENH_VERSION_NT.FeatureFlags
 * bitmask.
 * 
 *    Rev 1.10   24 Feb 1995 12:23:08   RWOLFF
 * Added flag for 24BPP text banding to ModeFlags field of mode
 * information structure.
 * 
 *    Rev 1.9   03 Feb 1995 15:14:16   RWOLFF
 * Added Feature Flag to show that dense space is available.
 * 
 *    Rev 1.8   30 Jan 1995 11:54:36   RWOLFF
 * Made detection of Daytona vs. older versions of NT automatic, miniport
 * and display driver now use the same version of this file.
 * 
 *    Rev 1.7   23 Dec 1994 10:48:34   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.6   31 Aug 1994 16:18:38   RWOLFF
 * Added definiton to go in ENH_VERSION_NT.FeatureFlags to show that
 * TVP3026 cursor handling is needed.
 * 
 *    Rev 1.5   04 May 1994 19:24:04   RWOLFF
 * Moved block write flag back to IOCTL_VIDEO_ATI_GET_MODE_INFORMATION
 * because the test can only be run if we have already switched
 * into graphics mode.
 * 
 *    Rev 1.4   28 Apr 1994 10:58:52   RWOLFF
 * Moved mode-independent bug/feature flags to IOCTL_VIDEO_ATI_GET_VERSION
 * packet from IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet.
 * 
 *    Rev 1.3   27 Apr 1994 13:52:58   RWOLFF
 * Added definition for MIO bug in ModeFlags bitfield.
 * 
 *    Rev 1.2   31 Mar 1994 15:00:52   RWOLFF
 * Added key to be used in DrvEscape() and values to be returned.
 * 
 *    Rev 1.1   14 Mar 1994 16:29:08   RWOLFF
 * Added bit definition in ModeFlags for 2M boundary tearing, DPMS IOCTL
 * is now consistent with Daytona.
 * 
 *    Rev 1.0   31 Jan 1994 11:29:10   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.3   24 Jan 1994 18:01:42   RWOLFF
 * Added definitions for new Mach 32 ASIC (68800LX), changed some Mach 64
 * definitions to accomodate changes in 94/01/19 BIOS document.
 * 
 *    Rev 1.2   14 Jan 1994 15:19:32   RWOLFF
 * Added definition for unknown non-Mach32 ASIC, flags to show if block
 * write and memory mapped registers are available, added fields for
 * bus type in ENH_VERSION_NT structure, preliminary structure and
 * definitions for DPMS packet.
 * 
 *    Rev 1.1   30 Nov 1993 18:12:12   RWOLFF
 * Renamed definitions for Mach 64 chip.
 * 
 *    Rev 1.0   03 Sep 1993 14:27:20   RWOLFF
 * Initial revision.
        
           Rev 1.5   22 Jan 1993 14:49:34   Chris_Brady
        add card capabilities to GET_INFO Ioctl.
        
           Rev 1.4   22 Jan 1993 14:46:40   Chris_Brady
        add ATIC_ defines for the card capabilities.
        
           Rev 1.3   20 Jan 1993 17:47:16   Robert_Wolff
        Added PVERSION_NT type definition, removed obsolete comment.
        
           Rev 1.2   19 Jan 1993 09:50:58   Chris_Brady
        add ANT_ drawing interface defines.
        
           Rev 1.1   18 Jan 1993 15:49:34   Chris_Brady
        new GetInof structure.
        
           Rev 1.0   15 Jan 1993 16:43:08   Chris_Brady
        Initial revision.
  

------------------------------------------------------------------------*/

//  is in the \ddk\public\sdk\inc  directory 
#include <devioctl.h>

// allow the miniport driver to Force seletion of a Programming Interface
enum    {
    ANT_DEFAULT=0,
    ANT_ENGINE_ONLY,
    ANT_APERTURE,
    ANT_VGA
    };

// Private Display driver Functions. Communication from ANTPANEL to
// the Display  ATI*.DLL to the Miniport ATI*.SYS  drivers.
enum   {                
    ATI_GET_INFO=1,
    ATI_GET_nextone
    };

// Define the possible ATI graphics card configurations so the Display
// driver can decide the best drawing methods to use.
// size is ULONG 32  bit field
// assigned by miniport to   VERSION_NT.capcard
#define ATIC_FIELD_LONGEST  0x80000000  //just to illustrate size

#define ATIC_APERTURE_LFB   0x0400
#define ATIC_APERTURE_VGA   0x0200      
#define ATIC_APERTURE_NONE  0x0100      //neither VGA or LFB found

#define ATIC_CARD_TYPE      0x00F0      //defines from 68801.h << 4
#define ATIC_BUS_TYPE       0x000F      //defines from 68801.H



// used with     IOCTL_VIDEO_ATI_GET_VERSION
// In hex:   BBBBVVMM where 
//    BBBB is the build number         (0-32767),
//    VV   is the major version number (0-255)
//    MM   is the minor version number (0-255)
typedef  struct  {
    ULONG       display;                //Display Version number
    ULONG       miniport;               //Miniport Version number
    ULONG       capcard;                //card capabilities
    struct   {
        short   xres;
        short   yres;
        short   color;                  // maximum bits per pixel
        }   resolution[6];
    } VERSION_NT, *PVERSION_NT;

/*
 * Definitions used with the ENH_VERSION_NT structure
 */
#define ENH_REVISION 1  // First revision of ENH_VERSION_NT structure

#define BETA_MINIPORT 0x00000080    // Bit set in InterfaceVersion for unsupported miniport versions

enum {
    CI_38800_1 = 0,         // Mach 8 ASIC, only one revision in use
    CI_68800_3,             // Mach 32 ASIC, first production revision
    CI_68800_6,             // Mach 32 ASIC, second production revision
    CI_68800_AX,            // Mach 32 AX ASIC
    CI_88800_GX,            // Mach 64 GX ASIC
    CI_68800_LX,            // Mach 32 LX ASIC
    CI_OTHER_UNKNOWN=30,    // Unknown ASIC other than Mach 32
    CI_68800_UNKNOWN=31     // Mach 32 ASIC other than versions above
    };

#define FL_CI_38800_1       0x00000001
#define FL_CI_68800_3       0x00000002
#define FL_CI_68800_6       0x00000004
#define FL_CI_68800_AX      0x00000008
#define FL_CI_88800_GX      0x00000010
#define FL_CI_68800_LX      0x00000020
#define FL_CI_OTHER_UNKNOWN 0x40000000
#define FL_CI_68800_UNKNOWN 0x80000000

enum {
    ENGINE_ONLY = 0,    // No aperture available
    AP_LFB,             // Linear framebuffer available
    AP_68800_VGA,       // 64k VGA aperture available
    AP_CX_VGA           // Two 32k VGA apertures available
    };

#define FL_ENGINE_ONLY  0x00000001
#define FL_AP_LFB       0x00000002
#define FL_68800_VGA    0x00000004
#define FL_CX_VGA       0x00000008

#define FL_MM_REGS      0x80000000  /* Memory Mapped registers are available */

/*
 * Values which can be placed in FeatureFlags field of ENH_VERSION_NT.
 *
 * Flags should be added to this field if they represent bugs/features
 * which affect all resolution/pixel depth combinations on a given card.
 */
#define EVN_DPMS            0x00000001  // DPMS is supported
#define EVN_SPLIT_TRANS     0x00000002  // This card has split transfer bug
#define EVN_MIO_BUG         0x00000004  // Card has multiple in/out hardware bug
#define EVN_TVP_DAC_CUR     0x00000008  // Cursor handled by TVP DAC, not the ASIC
#define EVN_IBM514_DAC_CUR  0x00000010  // Cursor handled by IBM DAC, not the ASIC
#define EVN_DENSE_CAPABLE   0x00000020  // Card is capable of using dense space
#define EVN_PACKED_IO       0x00000040  // Card uses packed I/O space
#define EVN_INT_DAC_CUR     0x00000080  /* Cards with internal DAC must use double buffer to avoid flickering cursor */
#define EVN_VT_ASIC         0x00000100  /* VT has extended capabilities our other cards don't */
#define EVN_GT_ASIC         0x00000200  /* GT has extended capabilities our other cards don't */
#define EVN_CT_ASIC         0x00000400  /* Identify CT ASIC */
/*
 * Cards with 1M of SDRAM need special handling (problem occurs on the
 * VTA4, may or may not happen with this configuration on future ASICs).
 */
#define EVN_SDRAM_1M        0x00000800


/*
 * Enhanced information structure for use with IOCTL_VIDEO_ATI_GET_VERSION.
 * This structure will be used if a non-null input buffer is passed when
 * making the call, and the older structure above will be used if a null
 * input buffer is passed.
 */
typedef struct{
    ULONG StructureVersion;     /* Revision of structure being passed in */
    ULONG InterfaceVersion;     /* Revision of private interface being used */
    ULONG ChipIndex;            /* Which accelerator chip is present */
    ULONG ChipFlag;             /* Flag corresponding to chip being used */
    ULONG ApertureType;         /* Best aperture type available */
    ULONG ApertureFlag;         /* Flag corresponding to aperture type */
    ULONG BusType;              /* Type of bus being used */
    ULONG BusFlag;              /* Flag corresponding to bus type */
    ULONG FeatureFlags;         /* Flags for features/bugs of this card */
    ULONG NumCards;             /* Number of ATI cards in the system */
    } ENH_VERSION_NT, *PENH_VERSION_NT;

/*
 * Values which can be placed in ModeFlags field of ATI_MODE_INFO.
 *
 * Flags should be added to this field if they represent bugs/features
 * which affect some but not all resolution/pixel depth combinations
 * on a given card.
 */
#define AMI_ODD_EVEN    0x00000001  // Hardware cursor odd/even bug, undefined
                                    // for cards without hardware cursor
#define AMI_MIN_MODE    0x00000002  // 8514/A compatible minimum mode
#define AMI_2M_BNDRY    0x00000004  // Tearing occurs on 2M boundary
#define AMI_BLOCK_WRITE 0x00000008  // Block write is supported. This is
                                    // mode-independent, but must be tested
                                    // after we have switched into graphics mode.
#define AMI_TEXTBAND    0x00000010  // Text banding in 24BPP mode

/*
 * Mode information structure for use with IOCTL_VIDEO_ATI_GET_MODE_INFORMATION.
 * This structure provides information specific to the video mode in use.
 */
typedef struct{
    ULONG ModeFlags;        /* Flags for features/bugs of this mode */

    LONG VisWidthPix;       /* Visible screen width in pixels */
    LONG VisWidthByte;      /* Visible screen width in bytes */
    LONG VisHeight;         /* Visible screen height */
    LONG BitsPerPixel;
    /*
     * The next 2 fields hold the number of bytes of memory used per pixel
     * (integer and fractional parts). A 4BPP unpacked (1 pixel per byte,
     * ignore unused 4 bits) mode would yield 1 and 0, the same as for 8BPP
     * (1.0 bytes per pixel). A 4BPP packed (2 pixels per byte) mode would
     * yield 0 and 500 (0.500 bytes per pixel). The fractional field will
     * always hold a 3-digit number, since bytes per pixel will always be
     * a multiple of 0.125 (one bit is one-eighth of a byte).
     */
    LONG IntBytesPerPixel;
    LONG FracBytesPerPixel;
    LONG PitchPix;          /* Screen pitch in pixels */
    LONG PitchByte;         /* Screen pitch in bytes */

    /*
     * The following fields refer to the offscreen block to the right of
     * the visible screen. This block is only present when the screen pitch
     * differs from the visible screen width. Its height is always the
     * same as the visible screen height, and its vertical start offset
     * is assumed to be zero.
     *
     * NOTE: If RightWidthPix is zero, this block does not exist for the
     *       current mode, and the other fields in this group are undefined.
     */
    LONG RightWidthPix;     /* Width of block in pixels */
    LONG RightWidthByte;    /* Width of block in bytes */
    LONG RightStartOffPix;  /* Horizontal start offset of block in pixels */
    LONG RightStartOffByte; /* Horizontal start offset of block in bytes */
    LONG RightEndOffPix;    /* Horizontal end offset of block in pixels */
    LONG RightEndOffByte;   /* Horizontal end offset of block in bytes */

    /*
     * The following fields refer to the offscreen block below the visible
     * screen. Values listed as "Hard" refer to the maximum vertical offset
     * for which enough video memory exists to support a full line of pixels.
     * Values listed as "Soft" refer to the maximum vertical offset which
     * can be reached without writing to the GE_OFFSET register.
     *
     * The horizontal start offset is assumed to be zero.
     */
    LONG BottomWidthPix;    /* Width of block in pixels */
    LONG BottomWidthByte;   /* Width of block in bytes */
    LONG BottomStartOff;    /* Vertical start offset of block */
    LONG BottomEndOffSoft;  /* "Soft" vertical end offset of block */
    LONG BottomEndOffHard;  /* "Hard" vertical end offset of block */
    LONG BottomHeightSoft;  /* "Soft" height of block */
    LONG BottomHeightHard;  /* "Hard" height of block */

    } ATI_MODE_INFO, *PATI_MODE_INFO;

//------------------------------------------------------------------------

/*
 * IOCTL codes to allow communication between the miniport driver
 * and higher-level modules. The Windows NT specification allocates
 * function codes 2048-4095 to external vendors.
 */
#define IOCTL_VIDEO_MIN_EXTERNAL_VENDOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAX_EXTERNAL_VENDOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 4095, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_GET_VERSION \
    CTL_CODE(FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_EM_SYNC_TO_MINIPORT \
    CTL_CODE(FILE_DEVICE_VIDEO, 2049, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_EM_SYNC_FROM_MINIPORT \
    CTL_CODE(FILE_DEVICE_VIDEO, 2050, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_GET_MODE_INFORMATION \
    CTL_CODE(FILE_DEVICE_VIDEO, 2051, METHOD_BUFFERED, FILE_ANY_ACCESS)


/*
 * The following definitions and IOCTLs are standard definitions from
 * the NTDDVDEO.H file in Daytona and later releases of Windows NT.
 * They are provided here to let earlier versions use the DPMS IOCTLs
 * without requiring source changes. Do not edit this section.
 *
 * Structures are made conditional on the absence of one of the
 * power management IOCTLs, rather than on the structure itself,
 * since "#if !defined(<symbol>)" doesn't trigger on symbols that
 * refer to structures, rather than numeric values.
 */

//
// IOCTL_VIDEO_SET_POWER_MANAGEMENT - Tells the device to change the power
//                                    consumption level of the device to the
//                                    new state.
// IOCTL_VIDEO_GET_POWER_MANAGEMENT - Return the current power consumption
//                                    level of the device.
//
// NOTE:
// This IOCTL is based on the VESA DPMS proposal.
// Changes to the DPMS standard will be refelcted in this IOCTL.
//

#if !defined(IOCTL_VIDEO_SET_POWER_MANAGEMENT)
typedef enum _VIDEO_POWER_STATE {
    VideoPowerOn = 1,
    VideoPowerStandBy,
    VideoPowerSuspend,
    VideoPowerOff
} VIDEO_POWER_STATE, *PVIDEO_POWER_STATE;
#endif

#if !defined(IOCTL_VIDEO_SET_POWER_MANAGEMENT)
typedef struct _VIDEO_POWER_MANAGEMENT {
    ULONG Length;
    ULONG DPMSVersion;
    ULONG PowerState;
} VIDEO_POWER_MANAGEMENT, *PVIDEO_POWER_MANAGEMENT;
#endif

//
//Length - Length of the structure in bytes. Also used to do verisioning.
//
//DPMSVersion - Version of the DPMS standard supported by the device.
//              Only used in the "GET" IOCTL.
//
//PowerState - One of the power states listed in VIDEO_POWER_STATE.
//

//
// Note:
// Once the power has been turned off to the device, all other IOCTLs made
// to the miniport will be intercepted by the port driver and will return
// failiure, until the power on the device has been turned back on.
//

/*
 * We use the presence or absence of various IOCTLs to determine
 * the build of Windows NT for which we are compiling the driver.
 * If this file is included, but the file which contains the IOCTLs
 * is not, in a source file, this will result in a false report of
 * the target build, which can cause numerous problems.
 *
 * This conditional block will force a compile error if the file
 * containing the IOCTLs (NTDDVDEO.H in NT 3.51 retail) was not
 * included prior to this file being included.
 */
#if !defined(IOCTL_VIDEO_SET_CURRENT_MODE)
    NTDDVDEO.H must be included before ATINT.H
#endif

/*
 * End of DPMS support for pre-Daytona versions of Windows NT.
 */

#define IOCTL_VIDEO_ATI_INIT_AUX_CARD \
    CTL_CODE(FILE_DEVICE_VIDEO, 2054, METHOD_BUFFERED, FILE_ANY_ACCESS)

/*
 * Structures used in DCI support. They were added some time after the
 * initial release of Windows NT 3.5, so we must make them available only
 * if they're not already defined. These "placeholders" are solely to
 * allow the miniport to be compiled - the packets will only be called
 * in later versions of Windows NT 3.5.
 *
 * There are no "placeholders" for the IOCTLs themselves, since their
 * presence or absence is used to determine whether or not to compile
 * the DCI cases in ATIMPStartIO().
 */
//
// _WIN32_WINNT is available starting from NT 4.0.
//
#if (_WIN32_WINNT >= 0x500)
    #define TARGET_BUILD        500
#else
    #if (_WIN32_WINNT >= 0x400)
        #define TARGET_BUILD    400
    #else
        #define TARGET_BUILD    351
    #endif
#endif

/*
 * Keys to be used in DrvEscape() call to handle DPMS and other private
 * ATI functions. These keys fit into a large "hole" between
 * GETSETSCREENPARAMS (3072) and BEGIN_PATH (4096)
 */
#define ESC_SET_POWER_MANAGEMENT    4000
#define ESC_GET_NUM_CARDS           4001
#define ESC_GET_MODES               4002
#define ESC_GET_VGA_ENABLED         4003
#define ESC_SET_CURRENT_FULLSCREEN  4004

/*
 * Values to show whether or not a given function is supported by
 * the DrvEscape entry point.
 */
#define ESC_IS_SUPPORTED    0x00000001  /* Function is supported */
#define ESC_NOT_SUPPORTED   0xFFFFFFFF  /* Unsupported function called */
#define ESC_NOT_IMPLEMENTED 0x00000000  /* QUERYESCSUPPORT called for unimplemented function */



//*********************   end of ATINT.H   ****************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\cvtddc.c ===
/************************************************************************/
/*                                                                      */
/*                              CVTDDC.C                                */
/*                                                                      */
/*       November 10 1995 (c) 1995 ATI Technologies Incorporated.       */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.5  $
      $Date:   10 Apr 1996 16:58:22  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/cvtddc.c_v  $
//
//   Rev 1.5   10 Apr 1996 16:58:22   RWolff
//Temorarily treats all cards as non-DDC to avoid system hang due to
//conflict over system timer registers. Final solution is to make DDC
//query in the miniport, using the StallExecution function, rather than
//calling the BIOS function which can hang the machine.
//
//   Rev 1.4   01 Mar 1996 12:13:28   RWolff
//Now saves and restores the portion of video memory used as
//a buffer to hold data returned by the DDC query call.
//
//   Rev 1.3   02 Feb 1996 17:15:44   RWolff
//Now gets DDC/VDIF merge source information from hardware device
//extension rather than storing it in static variables, moved code to
//obtain a buffer in VGA memory to a separate routine.
//
//   Rev 1.2   29 Jan 1996 16:54:40   RWolff
//Now uses VideoPortInt10() rather than no-BIOS code on PPC.
//
//   Rev 1.1   11 Jan 1996 19:37:44   RWolff
//Now restricts "canned" mode tables by both maximum index and maximum
//pixel clock frequency, and EDID mode tables by maximum pixel clock
//frequency only, rather than both by maximum refresh rate.
//
//   Rev 1.0   21 Nov 1995 11:04:38   RWolff
//Initial revision.


End of PolyTron RCS section                             *****************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>

#include "dderror.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"      /* for VP_STATUS definition */

#include "stdtyp.h"
#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"
#include "cvtvga.h"
#include "services.h"
#include "vdptocrt.h"
#include "cvtvdif.h"
#define INCLUDE_CVTDDC
#include "cvtddc.h"


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_CX, IsDDCSupported)
#pragma alloc_text(PAGE_DDC, MergeEDIDTables)
#endif



/*****************************************************************************
 *
 * ULONG IsDDCSupported(void);
 *
 * DESCRIPTION:
 *  Reports the degree of DDC support for the available monitor/graphics
 *  card combination.
 *
 * RETURN VALUE:
 *  MERGE_EDID_DDC  if DDC can return EDID data structures
 *  MERGE_VDIF_FILE if no monitor data available from DDC
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  SetFixedModes()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

ULONG IsDDCSupported(void)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    VP_STATUS RetVal;                   /* Status returned by VideoPortInt10() */
    ULONG MergeSource;                  /* Source of mode tables to merge with "canned" tables */

    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_DDC_SUPPORT;
    Registers.Ebx = 0;
    if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
        /*
         * If we can't find out DDC status from the BIOS,
         * assume DDC is not supported.
         */
        {
        VideoDebugPrint((DEBUG_ERROR, "Error querying DDC status, assume it's not supported\n"));
        MergeSource = MERGE_VDIF_FILE;
        }
    else
        {
#if 0
        /*
         * Workaround: Our BIOS call to obtain the DDC information uses
         * the system timer (0x40/0x43) registers, which (according to
         * Microsoft) the video BIOS is not supposed to touch. This
         * causes some machines to hang during the DDC query. Until
         * we can bring the DDC query into the miniport (using approved
         * time delay routines), report that this card doesn't support
         * DDC.
         */
        if ((Registers.Eax & 0x00000002) && (Registers.Ebx & 0x00000002))
            {
            /*
             * DDC2 supported by both BIOS and monitor. Check separately
             * for DDC1 and DDC2 in case we decide to handle them
             * differently in future.
             */
            VideoDebugPrint((DEBUG_NORMAL, "DDC2 supported\n"));
            MergeSource = MERGE_EDID_DDC;
            }
        else if ((Registers.Eax & 0x00000001) && (Registers.Ebx & 0x00000001))
            {
            /*
             * DDC1 supported by both BIOS and monitor.
             */
            VideoDebugPrint((DEBUG_NORMAL, "DDC1 supported\n"));
            MergeSource = MERGE_EDID_DDC;
            }
        else
            {
            /*
             * Either the BIOS or the monitor does not support DDC.
             */
            VideoDebugPrint((DEBUG_NORMAL, "DDC not supported\n"));
            MergeSource = MERGE_VDIF_FILE;
            }
#else
        MergeSource = MERGE_VDIF_FILE;
#endif
        }

    return MergeSource;

}   /* IsDDCSupported() */



/*****************************************************************************
 *
 * VP_STATUS MergeEDIDTables(void);
 *
 * DESCRIPTION:
 *  Merges canned mode tables from BookValues[] with tables found in an
 *  EDID structure retrieved via DDC. Global pointer variable pCallbackArgs
 *  is used to point to a structure that passes data in both directions
 *  between this function and SetFixedModes(). For details on input and
 *  output data see definition of stVDIFCallbackData structure. 
 *
 * RETURN VALUE:
 *  NO_ERROR if tables retrieved correctly
 *  ERROR_INVALID_PARAMETER if unable to retrieve data via DDC
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  SetFixedModes()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS MergeEDIDTables(void)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    VP_STATUS RetVal;                   /* Status returned by VideoPortInt10() */
    ULONG BufferSeg;                    /* Segment to use for buffer */
    ULONG BufferSize = 128;             /* EDID structure is 128 bytes long */
    PUCHAR MappedBuffer;                /* Pointer to buffer used for BIOS query */
    static UCHAR FixedBuffer[128];      /* Buffer used to avoid repeated BIOS queries */
    struct EdidDetailTiming *EdidPtr;   /* Used in extracting information from buffer */
    ULONG DetailOffset;                 /* Offset of detailed timing into EDID structure */
    ULONG Scratch;                      /* Temporary variable */
    struct stVDIFCallbackData *pArgs;   /* Pointer to arguments structure */
    struct st_mode_table BuildTbl;      /* Mode table being built */
    struct st_mode_table LiveTables[4]; /* Tables already extracted */
    USHORT NumTablesFound = 0;          /* Number of valid entries in LiveTables[] */
    USHORT NumLowerTables;              /* Number of tables with a lower refresh rate than BuildTbl */
    USHORT HorTotal;                    /* Horizontal total */
    USHORT VerTotal;                    /* Vertical total */
    USHORT SyncStrt;                    /* Sync start */
    USHORT HighBound;                   /* Highest frame rate to look for */
    UCHAR SavedScreen[128];             /* Data saved from screen buffer used for DDC query */


    pArgs = pCallbackArgs;

    /*
     * If we haven't already retrieved the EDID information into local
     * storage, do it now.
     */
    if (phwDeviceExtension->EdidChecksum == 0)
        {
        MappedBuffer = GetVgaBuffer(BufferSize, 0x500, &BufferSeg, SavedScreen);

        /*
         * We now have a buffer big enough to hold the EDID structure,
         * so make the BIOS call to fill it in.
         */
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        Registers.Eax = BIOS_DDC_SUPPORT;
        Registers.Ebx = 1;
        Registers.Ecx = BufferSize;
        Registers.Edx = BufferSeg;
        Registers.Edi = 0;
        if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)

            {
            VideoDebugPrint((DEBUG_ERROR, "MergeEDIDTables() - failed BIOS_DDC_SUPPORT call\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            return RetVal;
            }

        /*
         * Copy the EDID structure into local storage, then restore
         * the contents of the buffer we used for the DDC query.
         */
        for (Scratch = 0; Scratch < 128; Scratch++)
            {
            FixedBuffer[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
            phwDeviceExtension->EdidChecksum += FixedBuffer[Scratch];
            VideoPortWriteRegisterUchar(&(MappedBuffer[Scratch]), SavedScreen[Scratch]);
            }

        /*
         * Check if we have a valid EDID header. If we don't, then
         * we can't extract EDID information. Occasionally, a
         * monitor hooked up to a switchbox will return corrupt
         * EDID data.
         */
        if ((FixedBuffer[0] != 0) ||
            (FixedBuffer[1] != 0xFF) ||
            (FixedBuffer[2] != 0xFF) ||
            (FixedBuffer[3] != 0xFF) ||
            (FixedBuffer[4] != 0xFF) ||
            (FixedBuffer[5] != 0xFF) ||
            (FixedBuffer[6] != 0xFF) ||
            (FixedBuffer[7] != 0))
            {
            VideoDebugPrint((DEBUG_ERROR, "Invalid EDID header\n"));
            return ERROR_INVALID_PARAMETER;
            }

        /*
         * We now have the EDID structure in local storage, so we can free
         * the buffer we collected it into. If the lower 8 bits of the
         * checksum are nonzero, the structure is invalid.
         */
        VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
        if ((phwDeviceExtension->EdidChecksum & 0x000000FF) != 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "MergeEDIDTables() - invalid checksum 0x%X\n", phwDeviceExtension->EdidChecksum));
            return ERROR_INVALID_PARAMETER;
            }
        }   /* endif (phwDeviceExtension->EdidChecksum == 0) */

    /*
     * There are 4 detailed timing blocks in the EDID structure. Read
     * each of them in turn.
     */
    for (DetailOffset = 54; DetailOffset <= 108; DetailOffset += 18)
        {
        ((PUCHAR)EdidPtr) = FixedBuffer + DetailOffset;

        /*
         * Initially check only the horizontal and vertical
         * resolution. If they don't match the resolution we
         * are working on, skip to the next detailed timing block.
         */
        BuildTbl.m_x_size = ((EdidPtr->HorHighNybbles & 0xF0) << 4) | EdidPtr->HorActiveLowByte;
        BuildTbl.m_y_size = ((EdidPtr->VerHighNybbles & 0xF0) << 4) | EdidPtr->VerActiveLowByte;

        if ((BuildTbl.m_x_size != pArgs->HorRes) || (BuildTbl.m_y_size != pArgs->VerRes))
            {
            VideoDebugPrint((DEBUG_DETAIL, "EDID mode %dx%d doesn't match desired mode %dx%d, skipping\n",
                BuildTbl.m_x_size, BuildTbl.m_y_size, pArgs->HorRes, pArgs->VerRes));
            continue;
            }

        /*
         * The table we are looking at matches the resolution we are
         * working on. Fill in the remaining parameters.
         */
        BuildTbl.m_h_disp = (UCHAR)(BuildTbl.m_x_size / 8 - 1);
        BuildTbl.m_v_disp = (short) normal_to_skip2((long)(BuildTbl.m_y_size - 1));

        BuildTbl.ClockFreq = (ULONG)(EdidPtr->PixClock) * 10000L;

        /*
         * If the pixel clock frequency for this mode is greater than
         * the maximum pixel clock frequency the graphics card supports
         * for the current resolution and pixel depth (this routine deals
         * with only one resolution/pixel depth combination at a time,
         * so our limiting pixel clock rate will always be for the current
         * resolution/pixel depth combination), we can't use this mode.
         */
        if (BuildTbl.ClockFreq > pArgs->MaxDotClock)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Skipping table because pixel clock rate is too high\n"));
            continue;
            }

        HorTotal = ((EdidPtr->HorHighNybbles & 0x0F) << 8) | EdidPtr->HorBlankLowByte;
        HorTotal += BuildTbl.m_x_size;
        BuildTbl.m_h_total = (UCHAR)(HorTotal / 8 - 1);

        VerTotal = ((EdidPtr->VerHighNybbles & 0x0F) << 8) | EdidPtr->VerBlankLowByte;
        VerTotal += BuildTbl.m_y_size;
        BuildTbl.m_v_total = (short) normal_to_skip2((long)(VerTotal - 1));

        SyncStrt = ((EdidPtr->SyncHighBits & 0xC0) << 2) | EdidPtr->HSyncOffsetLB;
        SyncStrt += BuildTbl.m_x_size;
        BuildTbl.m_h_sync_strt = (UCHAR)(SyncStrt / 8 - 1);

        SyncStrt = ((EdidPtr->SyncHighBits & 0x0C) << 2) | ((EdidPtr->VSyncOffWidLN & 0xF0) >> 4);
        SyncStrt += BuildTbl.m_y_size;
        BuildTbl.m_v_sync_strt = (short) normal_to_skip2((long)(SyncStrt - 1));

        /*
         * We only support digital separate sync monitors.
         */
        if ((EdidPtr->Flags & EDID_FLAGS_SYNC_TYPE_MASK) != EDID_FLAGS_SYNC_DIGITAL_SEP)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Skipping table due to wrong sync type\n"));
            continue;
            }

        Scratch = ((EdidPtr->SyncHighBits & 0x30) << 4) | EdidPtr->HSyncWidthLB;
        if (!(EdidPtr->Flags & EDID_FLAGS_H_SYNC_POS))
            Scratch |= 0x20;
        BuildTbl.m_h_sync_wid = (UCHAR)Scratch;

        Scratch = ((EdidPtr->SyncHighBits & 0x03) << 4) | (EdidPtr->VSyncOffWidLN & 0x0F);
        if (!(EdidPtr->Flags & EDID_FLAGS_V_SYNC_POS))
            Scratch |= 0x20;
        BuildTbl.m_v_sync_wid = (UCHAR)Scratch;

        BuildTbl.m_status_flags = 0;
        BuildTbl.m_vfifo_16 = 8;
        BuildTbl.m_vfifo_24 = 8;
        BuildTbl.m_clock_select = 0x800;

        BuildTbl.m_h_overscan = 0;
        BuildTbl.m_v_overscan = 0;
        BuildTbl.m_overscan_8b = 0;
        BuildTbl.m_overscan_gr = 0;

        if (EdidPtr->Flags & EDID_FLAGS_INTERLACE)
            BuildTbl.m_disp_cntl = 0x33;
        else
            BuildTbl.m_disp_cntl = 0x23;

        /*
         * The EDID detailed timing tables don't include the refresh
         * rate. In our VDIF to monitor timings routines, we obtain
         * the horizontal and vertical totals from the equations
         *
         * Htot = PixClk/HorFreq
         * Vtot = HorFreq/FrameRate
         *
         * These equations can be rearranged to
         *
         * HorFreq = PixClk/Htot
         * FrameRate = HorFreq/Vtot = (PixClk/Htot)/Vtot = PixClk/(Htot*Vtot)
         *
         * The multiplication, addition, and division below is to
         * round up to the nearest whole number, since we don't
         * have access to floating point.
         */
        Scratch = (BuildTbl.ClockFreq * 10)/(HorTotal*VerTotal);
        Scratch += 5;
        Scratch /= 10;
        BuildTbl.Refresh = (short)Scratch;
        VideoDebugPrint((DEBUG_DETAIL, "Refresh rate = %dHz\n", BuildTbl.Refresh));

        /*
         * Set the pixel depth and pitch, and adjust the clock frequency
         * if the DAC needs multiple clocks per pixel.
         */
        SetOtherModeParameters(pArgs->PixelDepth, pArgs->Pitch,
                               pArgs->Multiplier, &BuildTbl);

        /*
         * We now have a mode table for the resolution we are
         * looking at. If this is the first table we have found
         * at this resolution, we can simply fill in the first
         * entry in LiveTables[]. If not, we must put the table
         * into the list in order by refresh rate.
         */
        if (NumTablesFound == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "First DDC table for this resolution\n"));
            VideoPortMoveMemory(&(LiveTables[0]), &BuildTbl, sizeof(struct st_mode_table));
            NumTablesFound = 1;
            }
        else
            {
            /*
             * Run through the list of tables we have already found.
             * Skip over the tables which have refresh rates lower than
             * the new table, and shift tables with higher refresh
             * rates up one position to make room for the new table.
             * There is no need to check for available spaces in the
             * LiveTables[] array, since this array has 4 entries and
             * the EDID structure can hold a maximum of 4 detailed
             * timings.
             */
            for (NumLowerTables = 0; NumLowerTables < NumTablesFound; NumLowerTables++)
                {
                if (LiveTables[NumLowerTables].Refresh < BuildTbl.Refresh)
                    {
                    VideoDebugPrint((DEBUG_DETAIL, "Skipping table %d, since %dHz is less than %dHz\n",
                                    NumLowerTables, LiveTables[NumLowerTables].Refresh, BuildTbl.Refresh));
                    continue;
                    }

                /*
                 * NumLowerTables now holds the number of tables in LiveTables[] which
                 * have refresh rates lower than that in BuildTbl. We must now move
                 * the tables in LiveTables[] with refresh rates higher than that in
                 * BuildTbl up one space to make room for BuildTbl to be inserted.
                 * After moving the tables, break out of the outer loop.
                 */
                for (Scratch = NumTablesFound; Scratch >= NumLowerTables; Scratch--)
                    {
                    VideoDebugPrint((DEBUG_DETAIL, "Moving table %d, since %dHz is more than %dHz\n",
                                    Scratch, LiveTables[Scratch].Refresh, BuildTbl.Refresh));
                    VideoPortMoveMemory(&(LiveTables[Scratch+1]), &(LiveTables[Scratch]), sizeof(struct st_mode_table));
                    }
                break;
                }
            /*
             * When we get here, one of two conditions is satisfied:
             *
             * 1. All the existing tables in LiveTables[] have a refresh
             *    rate less than that in BuildTbl, so the outer loop will
             *    have exited with NumLowerTables equal to NumTablesFound.
             *
             * 2. There are some tables in LiveTables[] which have a refresh
             *    rate greater than that in BuildTbl. The inner loop will
             *    have exited after moving these tables up one space, then
             *    we will have broken out of the outer loop. NumLowerTables
             *    is equal to the number of existing tables which have a
             *    refresh rate less than that in BuildTbl.
             *
             * In both cases, LiveTables[NumLowerTables] is a free slot
             * at the location where BuildTbl should be copied.
             */
            VideoDebugPrint((DEBUG_DETAIL, "Copying new table to entry %d\n", NumLowerTables));
            VideoPortMoveMemory(&(LiveTables[NumLowerTables]), &BuildTbl, sizeof(struct st_mode_table));
            NumTablesFound++;

            }   /* end if (NumTablesFound != 0) */

        }   /* end for (look at next detailed timing block) */

    /*
     * We now have all the mode tables from the EDID structure which
     * match the desired resolution stored in LiveTables[] in order
     * of increasing refresh rate, with the number of such tables
     * in NumTablesFound. Now we must merge the results with the
     * "canned" mode tables.
     */
    HighBound = BookValues[pArgs->EndIndex].Refresh;

    /*
     * Use NumLowerTables to go through the list of tables from
     * the EDID structure.
     *
     * Since there will never be a legitimate mode table with a
     * pixel clock frequency of zero hertz, we can use this value
     * as a flag to show that we don't want to use the tables from
     * the EDID structure. Initially, we only want to lock out the
     * use of these tables if none exist, but we will later lock
     * them out if we have already used all of them.
     */
    NumLowerTables = 0;
    if (NumTablesFound == 0)
        LiveTables[0].ClockFreq = 0;

    while (pArgs->FreeTables > 0)
        {
        /*
         * If the EDID table exists, and either it has a refresh rate
         * less than or equal to that of the next "canned" table or
         * we have run out of acceptable "canned" tables, use the EDID
         * table. We know that any EDID table will have an acceptable
         * pixel clock frequency because we have already discarded any
         * that are out of range.
         */
        if ((LiveTables[NumLowerTables].ClockFreq != 0) &&
            ((LiveTables[NumLowerTables].Refresh <= BookValues[pArgs->Index].Refresh) ||
             (pArgs->Index > pArgs->EndIndex) ||
             (BookValues[pArgs->Index].ClockFreq > pArgs->MaxDotClock)))
            {
            VideoDebugPrint((DEBUG_DETAIL, "Copying %dHz table from EDID\n", LiveTables[NumLowerTables].Refresh));
            VideoPortMoveMemory((*pArgs->ppFreeTables), &(LiveTables[NumLowerTables]), sizeof(struct st_mode_table));
            NumLowerTables++;
            }
        /*
         * The above check will have failed if the EDID table did not exist,
         * or if it did but an acceptable "canned" table with a lower
         * refresh rate also exists. Check to see if we have an acceptable
         * "canned" table, and use it if we do.
         */
        else if ((pArgs->Index <= pArgs->EndIndex) &&
                 (BookValues[pArgs->Index].ClockFreq <= pArgs->MaxDotClock))
            {
            VideoDebugPrint((DEBUG_DETAIL, "Copying %dHz \"canned\" table\n", BookValues[pArgs->Index].Refresh));
            BookVgaTable(pArgs->Index, *pArgs->ppFreeTables);
            SetOtherModeParameters(pArgs->PixelDepth, pArgs->Pitch,
                pArgs->Multiplier, *pArgs->ppFreeTables);
            pArgs->Index++;
            }
        /*
         * The only way we will fail both of the above checks is if there
         * are no acceptable mode tables remaining, either from the EDID
         * structure or from our list of "canned" tables. If this is the
         * case, we don't need to look for more mode tables to add to
         * our list.
         */
        else
            {
            break;
            }

        /*
         * Update the lower bound, since we don't want to consider
         * tables with refresh rates lower than or equal to the one
         * in the table we just added to the list. After we have
         * done this, skip ahead in both the "canned" and EDID tables
         * to get past those which are below the new lower bound.
         *
         * Don't skip a mode table from the EDID structure with a pixel
         * clock frequency of zero, since this is a flag to show that we
         * have already used all of the suitable mode tables from the
         * EDID structure, rather than a legitimate mode table.
         */
        pArgs->LowBound = (*pArgs->ppFreeTables)->Refresh + 1;

        while ((pArgs->Index <= pArgs->EndIndex) &&
               (BookValues[pArgs->Index].Refresh < pArgs->LowBound))
            {
            VideoDebugPrint((DEBUG_DETAIL, "Skipping %dHz \"canned\" table\n", BookValues[pArgs->Index].Refresh));
            pArgs->Index++;
            }

        while ((NumLowerTables < NumTablesFound) &&
               (LiveTables[NumLowerTables].ClockFreq != 0) &&
               (LiveTables[NumLowerTables].Refresh < pArgs->LowBound))
            {
            VideoDebugPrint((DEBUG_DETAIL, "Skipping %dHz table from EDID\n", LiveTables[NumLowerTables].Refresh));
            NumLowerTables++;
            }

        /*
         * If we have run out of EDID tables, mark the EDID tables
         * with our flag to show that they should be ignored (no
         * legitimate mode will have a pixel clock rate of zero
         * hertz).
         *
         * We must do this in the first entry of the structure then
         * reset the "next EDID table to use" index to point to the
         * first entry, rather than modifying whatever happens to be
         * the next entry, to avoid trampling data outside our array
         * in the (unlikely) event that all of the possible detailed
         * timings in the EDID structure were valid mode tables with
         * in-range pixel clock frequencies for the resolution we are
         * looking at.
         *
         * There is no need to set a flag if we run out of "canned"
         * tables because we identify this condition by the index
         * being higher than the highest index we want to look for,
         * which is an input parameter.
         */
        if (NumLowerTables == NumTablesFound)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Ran out of EDID tables\n"));
            NumLowerTables = 0;
            LiveTables[0].ClockFreq = 0;
            }

        /*
         * Adjust the free tables pointer and count to reflect the
         * table we have just added.
         */
        (*pArgs->ppFreeTables)++;
        pArgs->NumModes++;
        pArgs->FreeTables--;

        }   /* end while (more tables and not yet reached high bound) */

    return NO_ERROR;

}   /* MergeEDIDTables() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\detect_m.c ===
/************************************************************************/
/*                                                                      */
/*                              DETECT_M.C                              */
/*                                                                      */
/*        Aug 25  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.9  $
      $Date:   31 Mar 1995 11:55:44  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/detect_m.c  $
 * 
 *    Rev 1.9   31 Mar 1995 11:55:44   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 * 
 *    Rev 1.8   11 Jan 1995 13:58:46   RWOLFF
 * Fixed bug introduced in rev. 1.4 - COM4: was detected as being a Mach8
 * or Mach32 card, which would leave the triple-boot with no valid video
 * driver.
 * 
 *    Rev 1.7   04 Jan 1995 12:02:06   RWOLFF
 * Get_BIOS_Seg() moved to SERVICES.C as part of fix for non-ATI cards
 * being detected as Mach64.
 * 
 *    Rev 1.6   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.5   19 Aug 1994 17:10:56   RWOLFF
 * Added support for Graphics Wonder, fixed search for BIOS signature,
 * removed dead code.
 * 
 *    Rev 1.4   22 Jul 1994 17:46:56   RWOLFF
 * Merged with Richard's non-x86 code stream.
 * 
 *    Rev 1.3   20 Jul 1994 13:03:44   RWOLFF
 * Fixed debug print statment.
 * 
 *    Rev 1.2   31 Mar 1994 15:06:42   RWOLFF
 * Added debugging code.
 * 
 *    Rev 1.1   07 Feb 1994 14:06:42   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:05:48   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.3   05 Nov 1993 13:23:36   RWOLFF
 * Fixed BIOS segment detection (used to always get C000).
 * 
 *    Rev 1.2   08 Oct 1993 11:09:26   RWOLFF
 * Added "_m" to function names to identify them as being specific to the
 * 8514/A-compatible family of ATI accelerators.
 * 
 *    Rev 1.1   24 Sep 1993 11:41:58   RWOLFF
 * Removed mapping of identification-only registers for all card families,
 * added additional 8514/A-compatible information gathering formerly done
 * in ATIMP.C.
 * 
 *    Rev 1.0   03 Sep 1993 14:22:48   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
DETECT_M.C - Identify which (if any) ATI card is present in the system.

DESCRIPTION
    This file contains routines which check for the presence of various
    ATI graphics accelerators.

    NOTE: This module only has access to those I/O registers needed
          to uniquely identify which ATI card is present.

OTHER FILES

#endif

#include "dderror.h"

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"

#define INCLUDE_DETECT_M
#include "detect_m.h"
#include "eeprom.h"
#include "modes_m.h"
#include "services.h"
#include "setup_m.h"


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, WhichATIAccelerator_m)
#pragma alloc_text(PAGE_M, GetExtraData_m)
#pragma alloc_text(PAGE_M, ATIFindExtFcn_m)
#pragma alloc_text(PAGE_M, ATIFindEEPROM_m)
#pragma alloc_text(PAGE_M, ATIGetSpecialHandling_m)
#endif


/*
 * Static variables used by this module.
 */
static BYTE *p;             // Used to address ROM directly
static BYTE GraphicsWonderSignature[] = "GRAPHICS WONDER";


/*
 * int WhichATIAccelerator_m(void);
 *
 * Determine which (if any) ATI 8514/A-compatible
 * accelerator is present.
 *
 * Returns: Accelerator type
 *  _8514_ULTRA     - 8514/Ultra
 *  GRAPHICS_ULTRA  - Graphics ULTRA/Graphics VANTAGE
 *  MACH32_ULTRA    - 68800 detected
 *  NO_ATI_ACCEL    - no ATI 8514/A-compatible accelerator
 */
int WhichATIAccelerator_m(void)
{
	int	status;
    WORD    Scratch;        /* Temporary variable */

    /*
     * All current ATI accelerators are 8514/A compatible. Check
     * for 8514/A, and if not present assume that no ATI accelerator
     * is present.
     */

    /*
     * Ensure that the DAC gets clocks (not guaranteed in ISA machines
     * in VGA passthrough mode because the cable might not be connected).
     */
    Passth8514_m(SHOW_ACCEL);

    /*
     * Cut the pixel clock down to low speed. The value given will yield
     * 25 MHz on most of the clock chips we are dealing with.
     */
    Scratch=(INPW(CLOCK_SEL) & 0xff00) | 0x51;
    OUTPW(CLOCK_SEL,Scratch);

/************************************************************************
 * DAC index read/write test
 *   This test writes to the read index and reads it back
 *   (it should be incremented by one).  This tests for the
 *   presence of a standard DAC in an 8514/A adapter.  This
 *   test is sufficient to ensure the presence of an 8514/A
 *   type adapter.
 ************************************************************************/

	OUTP(DAC_R_INDEX,0xa4);
	short_delay();	/* This delay must be greater than	*/
			/* than the minimum delay required	*/
			/* by the DAC (see the DAC spec)	*/
	if (INP(DAC_W_INDEX) == 0xa5)
        {
        /*
         * Reading back A5 from DAC_W_INDEX always means an 8514-compatible
         * card is present, but not all 8514-compatible cards will
         * produce this value.
         */
        status=TRUE;
        VideoDebugPrint((DEBUG_DETAIL, "First test - this is an 8514/A\n"));
        }
	else{
        /*
         * Secondary test for 8514/compatible card. Reset the draw engine,
         * then write an alternating bit pattern to the ERR_TERM register.
         */
        OUTPW(SUBSYS_CNTL, 0x900F);
        OUTPW(SUBSYS_CNTL, 0x400F);
        OUTPW(ERR_TERM, 0x5555);
        WaitForIdle_m();
        /*
         * If we don't read back the value we wrote, then there is
         * no 8514-compatible card in the system. If we do read back
         * what we wrote, we must repeat the test with the opposite
         * bit pattern.
         */
        if (INPW(ERR_TERM) != 0x5555)
            {
            status=FALSE;
            VideoDebugPrint((DEBUG_DETAIL, "Second test - 0x5555 not found, no 8514/A\n"));
            }
        else{
            OUTPW(ERR_TERM, 0x0AAAA);
            WaitForIdle_m();
            if (INPW(ERR_TERM) != 0x0AAAA)
                {
                status=FALSE;
                VideoDebugPrint((DEBUG_DETAIL, "Second test - 0xAAAA not found, no 8514/A\n"));
                }
            else
                {
                status=TRUE;
                VideoDebugPrint((DEBUG_DETAIL, "Second test - this is an 8514/A\n"));
                }
            }
        }

    /*
     * Turn on passthrough so display is driven by VGA.
     */
    Passth8514_m(SHOW_VGA);

    if (status == FALSE)
        {
        VideoDebugPrint((DEBUG_DETAIL, "No 8514/A-compatible card found\n"));
        return NO_ATI_ACCEL;
        }


    /*
     * We now know that the video card is 8514/A compatible. Now check
     * to see if it has the ATI extensions.
     */
    Scratch = INPW (ROM_ADDR_1);    // save original value
    OUTPW (ROM_ADDR_1,0x5555);      // bits 7 and 15 must be zero

    WaitForIdle_m();

    status = INPW(ROM_ADDR_1) == 0x5555 ? TRUE : FALSE;

    OUTPW  (ROM_ADDR_1, Scratch);
    if (status == FALSE)
        {
        VideoDebugPrint((DEBUG_DETAIL, "8514/A-compatible card found, but it doesn't have ATI extensions\n"));
        return NO_ATI_ACCEL;
        }


    /*
     * We know that an ATI accelerator is present. Determine which one.
     */

    VideoDebugPrint((DEBUG_DETAIL, "8514/A-compatible card found with ATI extensions\n"));
#if !defined (i386) && !defined (_i386_)
    /*
     * Alpha Jensen under test falsely reports Mach 32 as Mach 8
     */
    Scratch = 0x02aa;
#else
    // This is not a R/W register in the Mach 8 but it is in the Mach 32
    OUTPW (SRC_X,0xaaaa);		// fill with a dummy value
    WaitForIdle_m();
    Scratch = INPW(R_SRC_X);
#endif
    if (Scratch == 0x02aa)
        {
        status = MACH32_ULTRA;
    	if (INPW(CONFIG_STATUS_1) & 1)	    //is 8514 or VGA enabled decides eeprom
            {
            Mach32DescribeEEPROM(STYLE_8514);
            }
        else
            {
            Mach32DescribeEEPROM(STYLE_VGA);
            }
        }

    else{
        /*
         * Mach 8 card found, determine which one.
         *
         * Only the 8514/ULTRA shares its clock with the VGA.
         * We can't check for the IBM 8514 ROM pages to be
         * enabled, because if we did an 8514/ULTRA with the
         * jumper set to disable the EEPROM would be falsely
         * recognized as a Graphics ULTRA.
         *
         * Even if this jumper is set to "disabled", we can
         * still read from the EEPROM.
         */
        if (INPW(CONFIG_STATUS_2) & SHARE_CLOCK)
            {
            status = _8514_ULTRA;
            /*
             * Only the 8514/Ultra has a hardware bug that prevents it
             * from writing to the EEPROM when it is in an 8 bit ISA bus.
             */
    	    if (   ((INPW(CONFIG_STATUS_1) & MC_BUS) == 0)     // ISA  bus only
	    	&& ((INPW(CONFIG_STATUS_1) & BUS_16) == 0))    // 8 bit BUS
                {
                Mach8UltraDescribeEEPROM(BUS_8BIT);
                }
            else
                {
                Mach8UltraDescribeEEPROM(BUS_16BIT);
                }
            }
        else{
            /*
             * Graphics ULTRA or Graphics VANTAGE found. For our purposes,
             * they are identical.
             */
            status = GRAPHICS_ULTRA;
            Mach8ComboDescribeEEPROM();
            }
        }

    phwDeviceExtension->ee = &ee;

    return (status);

}   /* WhichATIAccelerator_m() */



/*
 * void GetExtraData_m(void);
 *
 * Collect additional data (register locations and revision-specific
 * card capabilities) for the 8514/A-compatible family of ATI accelerators.
 */
void GetExtraData_m(void)
{
    struct query_structure *QueryPtr;   /* Query information for the card */

    
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);
    ati_reg  = reg1CE;              // ATI VGA extended register
    vga_chip = VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[VGA_CHIP_OFFSET]));     /* VGA chip revision as ASCII */

    // Find out whether extended BIOS functions and the EEPROM are available.
    QueryPtr->q_ext_bios_fcn = ATIFindExtFcn_m(QueryPtr);
    QueryPtr->q_eeprom = ATIFindEEPROM_m(QueryPtr);

    ATIGetSpecialHandling_m(QueryPtr);           // special card distinctions
    return;
}   /* GetExtraData_m() */



/*
 * BOOL ATIFindExtFcn_m(QueryPtr)
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Routine to see if extended BIOS functions for setting the accelerator
 * mode are present in the BIOS of an ATI accelerator card. Assumes that
 * an ATI accleratore with a ROM BIOS is present, results are undefined
 * if this assumption is invalid.
 */
BOOL ATIFindExtFcn_m(struct query_structure *QueryPtr)
{

    /*
     * TEMPORARY WORKAROUND: Windows NT does not yet provide a hook
     * to make an absolute far call to real mode code. To avoid
     * branching into code which depends on this service being available,
     * report that no extended BIOS functions are available.
     *
     * Once this hook becomes available so that we can use
     * extended BIOS functions, we can check the BIOS to see
     * if it contains entry points. On Mach 8 and Mach 32
     * accelerators with extended BIOS functions, there will
     * be an unconditional jump located at the entry point
     * for each extended function.
     */
    return FALSE;

}   /* ATIFindExtFcn_m() */



/*
 * BOOL ATIFindEEPROM_m(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Routine to see if an EEPROM is present on an ATI accelerator card.
 * Assumes that an ATI accelerator is present and the model is known,
 * results are undefined if this assumption is invalid.
 *
 * Returns:
 *  TRUE if an EEPROM is present on the card
 *  FALSE if no EEPROM is present
 */
BOOL ATIFindEEPROM_m(struct query_structure *QueryPtr)
{
    WORD ValueRead;     /* Value read from the EEPROM */


    /*
     * The EEPROM read will return all bits the same if no EEPROM
     * is present. If an EEPROM is present, word 2 will have at least
     * one bit set and at least one bit cleared regardless of
     * accelerator type (8514/ULTRA, Graphics Ultra, or Mach 32).
     */
    ValueRead = (ee.EEread) (2);
    VideoDebugPrint((DEBUG_NORMAL, "Value read from second EEPROM word is 0x%X\n", ValueRead));
    if ((ValueRead == 0x0FFFF) || !ValueRead)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Will check for OEM accelerator\n"));
        return FALSE;
        }
    else
        {
        VideoDebugPrint((DEBUG_NORMAL, "Won't check for OEM accelerator\n"));
        return TRUE;
        }

}   /* ATIFindEEPROM_m() */


/*
 * void ATIGetSpecialHandling_m(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Finds out from ROM BIOS whether or not 1280x1024 is available on
 * a Mach 8 card, and whether or not all bits of memory aperture
 * location are found in MEM_CFG register on a Mach 32. Assumes
 * that an ATI accelerator with a ROM BIOS is present, results
 * are undefined if this assumption is invalid.
 */
void ATIGetSpecialHandling_m(struct query_structure *QueryPtr)
{
    USHORT SearchLoop;  /* Used in finding beginning of Graphics Wonder ID string */
    USHORT ScanLoop;    /* Used in stepping through Graphics Wonder ID string */


    /*
     * Check the BIOS revision number. Mach 8 cards with a BIOS
     * revision prior to 1.4 can't do 1280x1024, but use the same
     * mode table for 132 column text mode.
     *
     * Some BIOS revisions (including 1.40 on a Graphics Ultra)
     * only contain the first digit of the minor revision in the
     * BIOS, while others (including 1.35 on an 8514/ULTRA) contain
     * the entire minor revision.
     *
     * The q_ignore1280 field is ignored for Mach 32 cards.
     */
    if((VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH8_REV_OFFSET])) < 1) ||    // Major revision
        (VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH8_REV_OFFSET+1])) < 4) || // Single-digit minor revision
        ((VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH8_REV_OFFSET+1])) >= 10) &&  // 2-digit minor revision
        (VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH8_REV_OFFSET+1])) < 40)))
        QueryPtr->q_ignore1280 = TRUE;
    else
        QueryPtr->q_ignore1280 = FALSE;



    /*
     * On the Mach 32, bit 0 of BIOS byte MACH32_EXTRA_OFFSET will
     * be set if bits 7 through 11 of the aperture address are to
     * located in SCRATCH_PAD_0 and clear if all the bits are in
     * MEM_CFG.
     *
     * The q_m32_aper_calc field is ignored for Mach 8 cards.
     */
    if (VideoPortReadRegisterUchar (&((QueryPtr->q_bios)[MACH32_EXTRA_OFFSET])) & 0x0001)
        QueryPtr->q_m32_aper_calc = TRUE;
    else
        QueryPtr->q_m32_aper_calc = FALSE;

    /*
     * The Graphics Wonder (low-cost version of the Mach 32) is
     * available with either the BT48x or the TI34075 DAC.
     *
     * These cards may be built with ASICs which passed tests on
     * modes supported by the BT48x DAC but failed tests on modes
     * only supported by the TI34075. Such a card may appear to work
     * in TI-only modes, but experience problems (not necessarily
     * reproducable on other Graphics Wonder cards, even from the
     * same production run) ranging from drawing bugs to hardware
     * damage. For this reason, Graphics Wonder cards MUST NOT be
     * run in modes not supported by the BT48x DAC.
     *
     * Initially assume that we do not have a Graphics Wonder. If
     * we find the beginning of the ID string, we can change our
     * assumption.
     */
    QueryPtr->q_GraphicsWonder = FALSE;
    for (SearchLoop = GW_AREA_START; SearchLoop < GW_AREA_END; SearchLoop++)
        {
        /*
         * Loop until we have found what might be the Graphics Wonder
         * identification string, but might also be a byte which
         * happens to match the first character in the string.
         * If we find a match, initially assume that we have
         * found the start of the string.
         */
        if (VideoPortReadRegisterUchar(&((QueryPtr->q_bios)[SearchLoop])) != GraphicsWonderSignature[0])
            continue;

        QueryPtr->q_GraphicsWonder = TRUE;
        /*
         * Check to see whether this is actually the start of the
         * Graphics Wonder identification string. If it isn't,
         * keep looking.
         */
        for (ScanLoop = 0; GraphicsWonderSignature[ScanLoop] != 0; ScanLoop++)
            {
            if (VideoPortReadRegisterUchar(&((QueryPtr->q_bios)[SearchLoop + ScanLoop]))
                != GraphicsWonderSignature[ScanLoop])
                {
                QueryPtr->q_GraphicsWonder = FALSE;
                break;
                }
            }

        /*
         * If this is a Graphics Wonder, restrict the maximum pixel
         * depth of the TI34075 DAC to that supported by the BT48x.
         *
         * Once we have found the Graphics Wonder ID string, we don't
         * need to keep looking for it.
         */
        if (QueryPtr->q_GraphicsWonder == TRUE)
            {
            for (ScanLoop = RES_640; ScanLoop <= RES_1280; ScanLoop++)
                {
                MaxDepth[DAC_TI34075][ScanLoop] = MaxDepth[DAC_BT48x][ScanLoop];
                }
            QueryPtr->q_GraphicsWonder = TRUE;
            break;
            }

        }   /* end search for Graphics Wonder */

    return;

}   /* ATIGetSpecialHandling_m() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\detect_m.h ===
/************************************************************************/
/*                                                                      */
/*                              DETECT_M.H                              */
/*                                                                      */
/*        Aug 25  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.4  $
      $Date:   11 Jan 1995 13:57:52  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/detect_m.h  $
 * 
 *    Rev 1.4   11 Jan 1995 13:57:52   RWOLFF
 * Replaced VCS logfile comment accidentally removed when checking in
 * the last revision.
 * 
 *    Rev 1.3   04 Jan 1995 13:17:30   RWOLFF
 * Moved definitions used by Get_BIOS_Seg() to SERVICES.H.
 * 
 *    Rev 1.2   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.1   19 Aug 1994 17:10:40   RWOLFF
 * Added support for Graphics Wonder, removed dead code.
 * 
 *    Rev 1.0   31 Jan 1994 11:41:00   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.3   05 Nov 1993 13:24:36   RWOLFF
 * Added new #defined values for new BIOS segment detection code.
 * 
 *    Rev 1.2   08 Oct 1993 11:08:42   RWOLFF
 * Added "_m" to function names to identify them as being specific to the
 * 8514/A-compatible family of ATI accelerators.
 * 
 *    Rev 1.1   24 Sep 1993 11:43:26   RWOLFF
 * Removed mapping of identification-only registers for all card families,
 * added additional 8514/A-compatible information gathering formerly done
 * in ATIMP.C.
 * 
 *    Rev 1.0   03 Sep 1993 14:27:50   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
DETECT_M.H - Header file for DETECT_M.C

#endif

/*
 * Prototypes for functions supplied by DETECT_M.C
 */
extern int  WhichATIAccelerator_m(void);

extern void GetExtraData_m(void);
extern BOOL ATIFindExtFcn_m(struct query_structure *);
extern BOOL ATIFindEEPROM_m(struct query_structure *);
extern void ATIGetSpecialHandling_m(struct query_structure *);

/*
 * Definitions used internally by DETECT_M.C.
 */
#ifdef INCLUDE_DETECT_M

   
/*
 * On Graphics Wonder cards, the string "GRAPHICS WONDER" will appear
 * somewhere in the first 500 bytes of the video BIOS.
 */
#define GW_AREA_START       0
#define GW_AREA_END       500  


#define VGA_CHIP_OFFSET     0x43    /* Bytes from base where vga_chip found */
#define MACH8_REV_OFFSET    0x4C    /* Bytes from base where Mach 8 BIOS revision found */
#define MACH32_EXTRA_OFFSET 0x62    /* Bytes from base where "aperture high bits read
                                       from high byte of SCRATCH_PAD_0" flag found */
#define LOAD_SHADOW_OFFSET  0x64    /* Bytes from base where Load Shadow Set entry found */
#define INTEL_JMP           0xE9    /* Opcode for Intel 80x86 JMP instruction */


#endif  /* defined INCLUDE_DETECT_M */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\ddc50.c ===
//
// Module:  DDC50.C
// Date:    Jun 29, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.1  $
      $Date:   30 Jun 1997 11:36:28  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\ddc50.c_v  $
 * 
 *    Rev 1.1   30 Jun 1997 11:36:28   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>

#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"

#include "video.h"      /* for VP_STATUS definition */

#include "stdtyp.h"
#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvdif.h"
#include "cvtvga.h"
#include "dynainit.h"
#include "dynatime.h"
#include "services.h"
#include "vdptocrt.h"
#define INCLUDE_CVTDDC
#include "cvtddc.h"


#if (TARGET_BUILD >= 500)


VOID    WriteClockLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData);
VOID    WriteDataLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData);
BOOLEAN ReadClockLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension);
BOOLEAN ReadDataLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension);
VOID    WaitForVsyncActiveDAC(PHW_DEVICE_EXTENSION HwDeviceExtension);


VOID    WriteClockLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData);
VOID    WriteDataLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData);
BOOLEAN ReadClockLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension);
BOOLEAN ReadDataLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension);
VOID    WaitForVsyncActiveGP(PHW_DEVICE_EXTENSION HwDeviceExtension);


/****************************************************************
;       DDC register
;
; High Byte, High Word
;
;      ...  5   4   3   2   1   0    SCW = CLK  Write
; --------|---|---|---|---|---|---|  SDW = DATA Write
;      ...|SCW|SDW|   |SCR|SDR|   |  SCR = CLK  Read
; ---------------------------------  SDR = DATA Read
;
;****************************************************************/


VOID WriteClockLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData)
{
    UCHAR Scratch;

    //
    // Value is inverted.
    //

    ucData = (ucData + 1) & 0x01;

    //
    // Write to the SCL line.
    //

    Scratch = (INP_HBHW(DAC_CNTL) & 0xE8) | (ucData << 5);
    OUTP_HBHW(DAC_CNTL, Scratch);

}

VOID WriteDataLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData)
{
    UCHAR Scratch;

    //
    // Value is inverted.
    //

    ucData = (ucData + 1) & 0x01;

    //
    // Write to the SDA line.
    //

    Scratch = (INP_HBHW(DAC_CNTL) & 0xD8) | (ucData << 4);
    OUTP_HBHW(DAC_CNTL, Scratch);
}


BOOLEAN ReadClockLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    return ((INP_HBHW(DAC_CNTL) & 0x04) >> 2);
}

BOOLEAN ReadDataLineDAC(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    return ((INP_HBHW(DAC_CNTL) & 0x02) >> 1);
}


VOID WaitForVsyncActiveDAC(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    //
    // BUGBUG
    //

    delay(30);
}


/****************************************************************
;       DDC register
;
; High Byte, Low Word
;
;      ...  5   4   3   2   1   0
; --------|---|---|---|---|---|---|
;      ...|SCR|SDR|   |   |   |   |  SCR = CLK  Read
; ---------------------------------  SDR = DATA Read
;
; High Byte, High Word
;
;      ...  5   4   3   2   1   0    SCW = CLK  Write
; --------|---|---|---|---|---|---|  SDW = DATA Write
;      ...|SCW|SDW|   |   |   |   |
; ---------------------------------
;
;****************************************************************/


VOID WriteClockLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData)
{
    UCHAR Scratch;

    //
    // Value is inverted.
    //

    ucData = (ucData + 1) & 0x01;

    //
    // Write to the SCL line.
    //

    Scratch = (INP_HBHW(GP_IO) & 0xDF) | (ucData << 5);
    OUTP_HBHW(GP_IO, Scratch);

}

VOID WriteDataLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension, UCHAR ucData)
{
    UCHAR Scratch;

    //
    // Value is inverted.
    //

    ucData = (ucData + 1) & 0x01;

    //
    // Write to the SDA line.
    //

    Scratch = (INP_HBHW(GP_IO) & 0xEF) | (ucData << 4);
    OUTP_HBHW(GP_IO, Scratch);
}


BOOLEAN ReadClockLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    return ((INP_HBLW(GP_IO) & 0x20) >> 5);
}

BOOLEAN ReadDataLineGP(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    return ((INP_HBLW(GP_IO) & 0x10) >> 4);
}

VOID WaitForVsyncActiveGP(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    //
    // BUGBUG
    //

    delay(30);
}





BOOLEAN
DDC2Query50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG  BufferSize)
//
// DESCRIPTION:
//  Reads the basic EDID structure from the monitor using DDC2.
//
// PARAMETERS:
//  phwDeviceExtension  Points to per-adapter device extension.
//  QueryBuffer         Buffer where information will be stored.
//  BufferSize          Size of the buffer to fill.
//
// RETURN VALUE:
//  Whether the call succeeded or not.
//
{

    struct query_structure * Query;
    I2C_FNC_TABLE i2c;
    ULONG Checksum;
    ULONG i;

    //
    // Get a formatted pointer into the query section of HW_DEVICE_EXTENSION.
    //

    Query = (struct query_structure *)phwDeviceExtension->CardInfo;

    //
    // Determine which class of hardware we are dealing with, since
    // different cards use different registers to control the SCL
    // and SDA lines. Don't worry about cards which don't support
    // DDC2, since the check for DDC support will have rejected
    // any of these cards so we won't reach this point in the code.
    //

    {
        i2c.WriteClockLine = WriteClockLineDAC;
        i2c.WriteDataLine  = WriteDataLineDAC;
        i2c.ReadClockLine  = ReadClockLineDAC;
        i2c.ReadDataLine   = ReadDataLineDAC;
        i2c.WaitVsync      = WaitForVsyncActiveDAC;

        VideoDebugPrint((DEBUG_NORMAL, "DAC DDC control"));
    }

    i2c.Size = sizeof(I2C_FNC_TABLE);

    if (!VideoPortDDCMonitorHelper(phwDeviceExtension,
                                   &i2c,
                                   QueryBuffer,
                                   BufferSize))
    {
        VideoDebugPrint((DEBUG_NORMAL, "DDC Query Failed\n"));
        return FALSE;
    }

    return TRUE;

}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\dpms.c ===
//
// Module:  DPMS.C
// Date:    Aug 08, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.1  $
      $Date:   21 Aug 1997 15:01:36  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\dpms.c_v  $
 * 
 *    Rev 1.1   21 Aug 1997 15:01:36   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/

#include <stdio.h>
#include <stdlib.h>

#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach1.h"
#include "amachcx.h"
#include "atimp.h"
#include "atint.h"
#include "dpms.h"
#include "init_m.h"
#include "init_cx.h"

//
// Allow miniport to be swapped out when not needed.
//
#if defined (ALLOC_PRAGMA)
#pragma alloc_text (PAGE_COM, SetMonitorPowerState)
#pragma alloc_text (PAGE_COM, GetMonitorPowerState)
#endif


VP_STATUS
SetMonitorPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    VIDEO_POWER_STATE VideoPowerState
    )
//
// DESCRIPTION:
//  Set the CRT output to the desired DPMS state under.
//
// PARAMETERS:
//  phwDeviceExtension  Points to hardware device extension structure.
//  VideoPowerState     Desired DPMS state.
//
// RETURN VALUE:
//  Status code, NO_ERROR = OK.
//
{
    ASSERT(phwDeviceExtension != NULL);

    VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS SetMonitorPowerState: Setting power state to %lu\n", VideoPowerState));

    if ((VideoPowerState != VideoPowerOn) &&
        (VideoPowerState != VideoPowerStandBy) &&
        (VideoPowerState != VideoPowerSuspend) &&
        (VideoPowerState != VideoPowerOff))
    {
        VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS SetMonitorPowerState: Invalid VideoPowerState\n"));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Different card families need different routines to set the power management state.
    //

    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
    {
        VIDEO_X86_BIOS_ARGUMENTS Registers;

        //
        // Invoke the BIOS call to set the desired DPMS state. The BIOS call
        // enumeration of DPMS states is in the same order as that in
        // VIDEO_POWER_STATE, but it is zero-based instead of one-based.
        //
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_SET_DPMS;
        Registers.Ecx = VideoPowerState - 1;
        VideoPortInt10(phwDeviceExtension, &Registers);

        return NO_ERROR;
    }

    else if((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
            (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
            (phwDeviceExtension->ModelNumber == MACH32_ULTRA))

    {
        struct query_structure * pQuery =
            (struct query_structure *) phwDeviceExtension->CardInfo;

        return SetPowerManagement_m(pQuery, VideoPowerState);
    }
    else
    {
        VideoDebugPrint((DEBUG_ERROR, "ATI.SYS SetMonitorPowerState: Invalid adapter type\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}   // SetMonitorPowerState()

VP_STATUS
GetMonitorPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PVIDEO_POWER_STATE pVideoPowerState
    )
//
// DESCRIPTION:
//  Retrieve the current CRT power state.
//
// PARAMETERS:
//  phwDeviceExtension  Points to hardware device extension structure.
//  pVideoPowerStats    Points to
//
// RETURN VALUE:
//  Error code on error.
//  NO_ERROR = OK, current power management state in pVideoPowerState.
//
// NOTE:
//  The enumerations VIDEO_DEVICE_POWER_MANAGEMENT (used by GetMonitorPowerState()) and VIDEO_POWER_MANAGEMENT
//  (used by this IOCTL) have opposite orderings (VIDEO_POWER_MANAGEMENT values increase as power consumption
//  decreases, while VIDEO_DEVICE_POWER_MANAGEMENT values increase as power consumption increases, and has
//  a reserved value for "state unknown"), so we can't simply add a constant to translate between them.
//
{
    VP_STATUS vpStatus;

    ASSERT(phwDeviceExtension != NULL && pVideoPowerState != NULL);

    //
    // Different card families need different routines to retrieve the power management state.
    //
    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        *pVideoPowerState = GetPowerManagement_cx(phwDeviceExtension);
    else
        *pVideoPowerState = GetPowerManagement_m(phwDeviceExtension);

    //
    // VIDEO_POWER_STATE has 5 possible states and a
    // reserved value to report that we can't read the state.
    // Our cards support 3 levels of monitor power-down in
    // addition to normal operation. Since the number of
    // values which can be reported exceeds the number
    // of states our cards can be in, we will never report
    // one of the possible states (VPPowerDeviceD3).
    //
    switch (*pVideoPowerState)
    {
        case VideoPowerOn:
    
            VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS GetMonitorPowerState: Currently set to DPMS ON\n"));
            vpStatus = NO_ERROR;
            break;

        case VideoPowerStandBy:

            VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS GetMonitorPowerState: Currently set to DPMS STAND-BY\n"));
            vpStatus = NO_ERROR;
            break;

        case VideoPowerSuspend:

            VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS GetMonitorPowerState: Currently set to DPMS SUSPEND\n"));
            vpStatus = NO_ERROR;
            break;

        case VideoPowerOff:

            VideoDebugPrint((DEBUG_DETAIL, "ATI.SYS GetMonitorPowerState: Currently set to DPMS OFF\n"));
            vpStatus = NO_ERROR;
            break;

        default:

            VideoDebugPrint((DEBUG_ERROR, "ATI.SYS GetMonitorPowerState: Currently set to invalid DPMS state\n"));
            *pVideoPowerState = VideoPowerOn;
            vpStatus = ERROR_INVALID_PARAMETER;
            break;
    }

    return vpStatus;
}   // GetMonitorPowerState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\cvtvdif.h ===
/************************************************************************/
/*                                                                      */
/*                              CVTVDIF.H                               */
/*                                                                      */
/*       July 12  1995 (c) 1993, 1995 ATI Technologies Incorporated.    */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.3  $
      $Date:   11 Jan 1996 19:40:34  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/cvtvdif.h_v  $
 * 
 *    Rev 1.3   11 Jan 1996 19:40:34   RWolff
 * Added field for maximum supported pixel clock frequency to VDIFInputs
 * structure.
 * 
 *    Rev 1.2   30 Oct 1995 12:11:56   MGrubac
 * Fixed bug in calculating CRTC parameters based on read in data from VDIF files.
 * 
 *    Rev 1.1   26 Jul 1995 12:54:54   mgrubac
 * Changed members of stVDIFCallbackData structure.
 * 
 *    Rev 1.0   20 Jul 1995 18:23:32   mgrubac
 * Initial revision.


End of PolyTron RCS section                             *****************/



/*
 * Prototypes for functions supplied by CVTVDIF.C
 */

extern void SetOtherModeParameters( WORD PixelDepth,
                                    WORD Pitch,
                                    WORD Multiplier,
                                    struct st_mode_table *pmode);

#define CARRETURN       '\x0D'  /* Carriage return */
#define TIMINGSECTION   "PREADJUSTED_TIMING"
#define HORPIXEL        "HORPIXEL"
#define VERPIXEL        "VERPIXEL"
#define VERFREQUENCY    "VERFREQUENCY"
#define HORFREQUENCY    "HORFREQUENCY"
#define SCANTYPE        "SCANTYPE"
#define PIXELCLOCK      "PIXELCLOCK"
#define HORSYNCTIME     "HORSYNCTIME"
#define HORADDRTIME     "HORADDRTIME"
#define HORBLANKTIME    "HORBLANKTIME"
#define HORBLANKSTART   "HORBLANKSTART"
#define VERSYNCTIME     "VERSYNCTIME"
#define VERADDRTIME     "VERADDRTIME"
#define VERBLANKTIME    "VERBLANKTIME"
#define VERBLANKSTART   "VERBLANKSTART"
#define HORSYNCSTART    "HORSYNCSTART"
#define VERSYNCSTART    "VERSYNCSTART"
#define HORSYNCPOLARITY "HORSYNCPOLARITY"
#define VERSYNCPOLARITY "VERSYNCPOLARITY"

/*
 * Structure for passing arguments and returned values between 
 * SetFixedModes() and VDIFCallback() 
 */
struct stVDIFCallbackData 
    { 
    /* 
     * Input and Outputs are from perspective of VDIFCallback() 
     */

    /*
     * FreeTables;  Input : number of free tables 
     *              Output: number of free tables after VDIFCallback routine  
     */
    short FreeTables;      
    /*
     * NumModes; Input and output: Number of mode tables added to list.
     * Incremented every time a new mode table is added to the list, in 
     * SetFixedModes() and in VDIFCallback()  
     */
    WORD NumModes;        
    WORD Index;         /* Input: First entry from "book" tables to use */
    WORD EndIndex;      /* Input: Last entry from "book" tables to use */
    WORD LowBound;      /* Input and output: The lowest frame rate */
    WORD Multiplier;    /* Input Argument from SetFixedModes */
    WORD HorRes;        /* Input Argument from SetFixedModes */
    WORD VerRes;        /* Input Argument from SetFixedModes */
    WORD PixelDepth;    /* Input Argument from SetFixedModes */
    WORD Pitch;         /* Input Argument from SetFixedModes */
    ULONG MaxDotClock;  /* Maximum supported pixel clock frequency */
    /*
     * ppFreeTables; Input and output: Pointer to pointer to the next free mode 
     * table. Incremented every time a new mode table is added to the list, in
     * SetFixedModes() and in VDIFCallback() 
     */
    struct st_mode_table **ppFreeTables; 
    };

/*
 * Structure for AlterTables[] to contain information we need to extract
 * from VDIF file for each mode table
 */
struct VDIFInputs 
    {      
    short MinFrameRate;
    BOOL  Interlaced; 
    ULONG PixelClock;
    ULONG HorFrequency;
    ULONG VerFrequency;
    ULONG HorSyncStart;
    ULONG VerSyncStart;
    ULONG HorBlankStart;
    ULONG VerBlankStart;
    ULONG HorAddrTime;
    ULONG VerAddrTime;
    ULONG HorBlankTime;
    ULONG VerBlankTime;
    ULONG HorSyncTime;
    ULONG VerSyncTime;
    ULONG HorPolarity;
    ULONG VerPolarity;
    };


/*
 * Pointer for passing parameters to callback functions by pointing 
 * (after casting) to a structure containing input (and possibly output)
 * variables for a callback function. Originally intended for use with 
 * SetFixedModes() and VDIFCallback(). 
 */
extern void *pCallbackArgs;  

/*
 * VDIF Macros
 */
#define OPER_LIMITS(vdif) \
        ((VDIFLimitsRec *)((char *)(vdif) + (vdif)->OffsetOperationalLimits))
#define NEXT_OPER_LIMITS(limits) \
        ((VDIFLimitsRec *)((char *)(limits) + (limits)->OffsetNextLimits))
#define PREADJ_TIMING(limits) \
        ((VDIFTimingRec *)((char *)(limits) + (limits)->Header.ScnLength))
#define NEXT_PREADJ_TIMING(timing) \
        ((VDIFTimingRec *)((char *)(timing) + (timing)->Header.ScnLength))

/*
 * Binary VDIF file defines
 */
#define VDIF_MONITOR_MONOCHROME      0
#define VDIF_MONITOR_COLOR           1

#define VDIF_VIDEO_TTL               0
#define VDIF_VIDEO_ANALOG            1
#define VDIF_VIDEO_ECL               2
#define VDIF_VIDEO_DECL              3
#define VDIF_VIDEO_OTHER             4

#define VDIF_SYNC_SEPARATE           0
#define VDIF_SYNC_C                  1
#define VDIF_SYNC_CP                 2
#define VDIF_SYNC_G                  3
#define VDIF_SYNC_GP                 4
#define VDIF_SYNC_OTHER              5
#define VDIF_EXT_XTAL                6

#define VDIF_SCAN_NONINTERLACED      0
#define VDIF_SCAN_INTERLACED         1
#define VDIF_SCAN_OTHER              2

#define VDIF_POLARITY_NEGATIVE       0
#define VDIF_POLARITY_POSITIVE       1

/*
 * We must force byte alignment of structures used in binary VDIF files, 
 * since structures contained in binary files are already byte aligned 
 */

#pragma pack(1)

struct _VDIF                           /* Monitor Description: */
   {
   UCHAR        VDIFId[4];             /* Always "VDIF" */
   ULONG        FileLength;            /* Lenght of the whole file */
   ULONG        Checksum;              /* Sum of all bytes in the file after */
                                       /* This feeld */
   USHORT       VDIFVersion;           /* Structure version number */
   USHORT       VDIFRevision;          /* Structure revision number */
   USHORT       Date[3];               /* File date Year/Month/Day */
   USHORT       DateManufactured[3];   /* Date Year/Month/Day */
   ULONG        FileRevision;          /* File revision string */
   ULONG        Manufacturer;          /* ASCII ID of the manufacturer */
   ULONG        ModelNumber;           /* ASCII ID of the model */
   ULONG        MinVDIFIndex;          /* ASCII ID of Minimum VDIF index */
   ULONG        Version;               /* ASCII ID of the model version */
   ULONG        SerialNumber;          /* ASCII ID of the serial number */
   UCHAR        MonitorType;           /* Monochrome or Color */
   UCHAR        CRTSize;               /* Inches */
   UCHAR        BorderRed;             /* Percent */
   UCHAR        BorderGreen;           /* Percent */
   UCHAR        BorderBlue;            /* Percent */
   UCHAR        Reserved1;             /* Padding */
   USHORT       Reserved2;             /* Padding */
   ULONG        RedPhosphorDecay;      /* Microseconds */
   ULONG        GreenPhosphorDecay;    /* Microseconds */
   ULONG        BluePhosphorDecay;     /* Microseconds */
   USHORT       WhitePoint_x;          /* WhitePoint in CIExyY (scale 1000) */
   USHORT       WhitePoint_y;
   USHORT       WhitePoint_Y;
   USHORT       RedChromaticity_x;     /* Red chromaticity in x,y */
   USHORT       RedChromaticity_y;
   USHORT       GreenChromaticity_x;   /* Green chromaticity in x,y */
   USHORT       GreenChromaticity_y;
   USHORT       BlueChromaticity_x;    /* Blue chromaticity in x,y */
   USHORT       BlueChromaticity_y;
   USHORT       RedGamma;              /* Gamme curve exponent (scale 1000) */
   USHORT       GreenGamma;
   USHORT       BlueGamma;
   ULONG        NumberOperationalLimits;
   ULONG        OffsetOperationalLimits;
   ULONG        NumberOptions;         /* Optional sections (gamma table) */
   ULONG        OffsetOptions;
   ULONG        OffsetStringTable;
   };
#pragma pack()

typedef struct _VDIF  VDIFRec;

#pragma pack(1)
struct _VDIFScnHdr                     /* Generic Section Header: */
   {
   ULONG        ScnLength;             /* Lenght of section */
   ULONG        ScnTag;                /* Tag for section identification */
   };
#pragma pack()
typedef struct _VDIFScnHdr  VDIFScnHdrRec;

#pragma pack(1)
struct _VDIFLimits                     /* Operational Limits: */
   {
   VDIFScnHdrRec        Header;        /* Common section info */
   USHORT       MaxHorPixel;           /* Pixels */
   USHORT       MaxVerPixel;           /* Lines */
   USHORT       MaxHorAddrLength;      /* Millimeters */
   USHORT       MaxVerAddrHeight;      /* Millimeters */
   UCHAR        VideoType;             /* TTL / Analog / ECL / DECL */
   UCHAR        SyncType;              /* TTL / Analog / ECL / DECL */
   UCHAR        SyncConfiguration;     /* Separate / C / CP / G / GP */
   UCHAR        Reserved1;             /* Padding */
   USHORT       Reserved2;             /* Padding */
   USHORT       TerminationResistance;        
   USHORT       WhiteLevel;            /* Millivolts */
   USHORT       BlackLevel;            /* Millivolts */
   USHORT       BlankLevel;            /* Millivolts */
   USHORT       SyncLevel;             /* Millivolts */
   ULONG        MaxPixelClock;         /* KiloHertz */
   ULONG        MinHorFrequency;       /* Hertz */
   ULONG        MaxHorFrequency;       /* Hertz */
   ULONG        MinVerFrequency;       /* MilliHertz */
   ULONG        MaxVerFrequency;       /* MilliHertz */
   USHORT       MinHorRetrace;         /* Nanoseconds */
   USHORT       MinVerRetrace;         /* Microseconds */
   ULONG        NumberPreadjustedTimings;
   ULONG        OffsetNextLimits;
   };
#pragma pack()
typedef struct _VDIFLimits  VDIFLimitsRec;

#pragma pack(1)
struct _VDIFTiming                     /* Preadjusted Timing: */
   {
   VDIFScnHdrRec        Header;        /* Common section info */
   ULONG        PreadjustedTimingName; /* SVGA/SVPMI mode number */
   USHORT       HorPixel;              /* Pixels */
   USHORT       VerPixel;              /* Lines */
   USHORT       HorAddrLength;         /* Millimeters */
   USHORT       VerAddrHeight;         /* Millimeters */
   UCHAR        PixelWidthRatio;       /* Gives H:V */
   UCHAR        PixelHeightRatio;
   UCHAR        Reserved1;             /* Padding */
   UCHAR        ScanType;              /* Noninterlaced / interlaced */
   UCHAR        HorSyncPolarity;       /* Negative / positive */
   UCHAR        VerSyncPolarity;       /* Negative / positive */
   USHORT       CharacterWidth;        /* Pixels */
   ULONG        PixelClock;            /* KiloHertz */
   ULONG        HorFrequency;          /* Hertz */
   ULONG        VerFrequency;          /* MilliHertz */
   ULONG        HorTotalTime;          /* Nanoseconds */
   ULONG        VerTotalTime;          /* Microseconds */
   USHORT       HorAddrTime;           /* Nanoseconds */
   USHORT       HorBlankStart;         /* Nanoseconds */
   USHORT       HorBlankTime;          /* Nanoseconds */
   USHORT       HorSyncStart;          /* Nanoseconds */
   USHORT       HorSyncTime;           /* Nanoseconds */
   USHORT       VerAddrTime;           /* Microseconds */
   USHORT       VerBlankStart;         /* Microseconds */
   USHORT       VerBlankTime;          /* Microseconds */
   USHORT       VerSyncStart;          /* Microseconds */
   USHORT       VerSyncTime;           /* Microseconds */
   };
#pragma pack()
typedef struct _VDIFTiming  VDIFTimingRec;

#pragma pack(1)
struct     _VDIFGamma                  /* Gamma Table: */
   {
   VDIFScnHdrRec Header;               /* Common sectio info */
   USHORT     GammaTableEntries;       /* Count of grays or RGB 3-tuples */
   USHORT     Unused1;
   };
#pragma pack()
typedef struct _VDIFGamma  VDIFGammaRec;

typedef enum                           /* Tags for section identification */
   {
   VDIF_OPERATIONAL_LIMITS_TAG = 1,
   VDIF_PREADJUSTED_TIMING_TAG,
   VDIF_GAMMA_TABLE_TAG
   } VDIFScnTag;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\cvtvga.h ===
/************************************************************************/
/*                                                                      */
/*                                  CVTVGA.H                            */
/*                                                                      */
/*      Copyright (c) 1992,         ATI Technologies Inc.               */
/************************************************************************/

/**********************       PolyTron RCS Utilities

 $Revision:   1.8  $
     $Date:   06 Feb 1996 15:59:40  $
   $Author:   RWolff  $
      $Log:   S:/source/wnt/ms11/miniport/archive/cvtvga.h_v  $
 * 
 *    Rev 1.8   06 Feb 1996 15:59:40   RWolff
 * For 1600x1200, deleted 52Hz table (never an official mode, offered
 * only to allow a choice of refresh rates), updated 60Hz to match CRT
 * parameters currently offered by install program, added 66Hz and 76Hz.
 * 
 *    Rev 1.7   19 Dec 1995 14:01:34   RWolff
 * Added support for refresh rates up to 100Hz at 640x480, 800x600, and
 * 1024x768 and 75Hz at 1280x1024. Updated mode tables to match those in
 * the Mach64 Programmer's Guide.
 * 
 *    Rev 1.6   07 Sep 1995 16:43:06   RWolff
 * Fixed 1280x1024 95Hz interlaced (listed as 47Hz in display applet) to
 * eliminate "wrap" at top of screen. The tables in both the Mach 32
 * and Mach 64 books contain the wrong values for vertical total and
 * vertical sync start.
 * 
 *    Rev 1.5   20 Jul 1995 17:55:48   mgrubac
 * Added support for VDIF files
 * 
 *    Rev 1.4   10 Apr 1995 15:57:36   RWOLFF
 * Added prototype for routine to replace BookValues[] entries where the
 * Mach 64 and Mach 8/Mach 32 need different CRT parameters.
 * 
 *    Rev 1.3   31 Aug 1994 16:23:08   RWOLFF
 * Added support for 1152x864 and 1600x1200 "canned" mode tables.
 * 
 *    Rev 1.2   19 Aug 1994 17:10:22   RWOLFF
 * Added support for non-standard pixel clock generators.
 * 
 *    Rev 1.1   12 May 1994 11:11:02   RWOLFF
 * Added refresh rate to st_book_data structure, re-ordered list of book
 * mode tables to allow a single range of indices when highest noninterlaced
 * refresh rates at a given resolution are ignored.
 * 
 *    Rev 1.0   31 Jan 1994 11:40:38   RWOLFF
 * Initial revision.
        
           Rev 1.1   08 Oct 1993 11:04:50   RWOLFF
        Removed prototype for unused "fall back to 56Hz" function for 800x600.
        
           Rev 1.0   16 Aug 1993 13:30:00   Robert_Wolff
        Initial revision.
        
           Rev 1.8   08 Apr 1993 16:44:54   RWOLFF
        Revision level as checked in at Microsoft.
        
           Rev 1.6   25 Mar 1993 11:13:38   RWOLFF
        Brought function prototype into sync with the function definition
        to eliminate compile-time warnings.
        
           Rev 1.5   08 Mar 1993 19:28:18   BRADES
        submit to MS NT
        
           Rev 1.4   02 Dec 1992 17:29:56   Robert_Wolff
        Added prototype for FallBack800to56().
        
           Rev 1.3   27 Nov 1992 15:18:20   STEPHEN
        No change.
        
           Rev 1.2   17 Nov 1992 17:25:34   Robert_Wolff
        Fixed gathering of CRT parameters for 68800 card with minimal
        install (EEPROM blank, then predefined monitor type selected).
        
           Rev 1.1   12 Nov 1992 16:44:26   Robert_Wolff
        Same file is now used for both Windows NT driver and VIDEO.EXE
        test program. XlateVgaTable() no longer depends on the global
        variable classMACH32.
        
           Rev 1.1   09 Oct 1992 15:01:24   Robert_Wolff
        Added fields for DISP_CNTL and CLOCK_SEL values.
        
           Rev 1.0   01 Oct 1992 15:32:38   Robert_Wolff
        Initial revision.


End of PolyTron RCS section                             *****************/


#if defined(DOC)
CVTVGA.H - ATI card VGA to 8514 format translation

DESCRIPTION:
    This include file contains definitions specific to the
    VGA to 8514 format EEPROM translation module of the program VIDEO.EXE

    Included are structure definitions, function prototypes
    and general definitions


#endif

/*
 * Bit 8 of CRT parameter table entry 0 is set if the table is in
 * 8514 format and clear if the table is in VGA format.
 */
#define FMT_8514    0x0100

/*
 * Bit 6 of CRT parameter table entry 0 is set if all parameters
 * are to be read from the EEPROM and clear if only sync polarities
 * are to be used.
 */
#define CRTC_USAGE  0x0040

/*
 * Bit flags to recognize which vertical scan rate is used at
 * a given resolution. The name for the constant is in the form
 * M<horizontal resolution>F<vertical scan frequency), with the
 * "M" standing for (M)ode.
 */
#define M640F72     0x0001

#define M800F72     0x0020
#define M800F70     0x0010
#define M800F60     0x0008
#define M800F56     0x0004
#define M800F89     0x0002
#define M800F95     0x0001

#define M1024F66    0x0010
#define M1024F72    0x0008
#define M1024F70    0x0004
#define M1024F60    0x0002
#define M1024F87    0x0001

#define M1280F95    0x0002
#define M1280F87    0x0001

/*
 * There are 3 1120x750 modes which use the same flag bit. Assume
 * that the 70Hz noninterlaced mode was selected.
 */
#define M1120F70    0x0001

/*
 * In some installations, the display parameters are not stored
 * in the EEPROM. Instead, they are read from a table corresponding
 * to Appendix D of the Programmer's Guide to the Mach 32 Registers.
 *
 * The entries in our copy of the table are arranged in ascending order
 * of horizontal resolution, with entries having the same horizontal
 * resolution sorted from worst to best (interlaced modes in increasing
 * order of vertical scan frequency, followed by noninterlaced modes in
 * ascending order of vertical scan frequency.
 *
 * The name for the constant is in the form
 * B<horizontal resolution>F<vertical scan frequency>, with the
 * "B" standing for (B)ook.
 */
#define B640F60     0
#define B640F72     1
#define B640F75     2
#define B640F90     3
#define B640F100    4
#define B800F89     5
#define B800F95     6
#define B800F56     7
#define B800F60     8
#define B800F70     9
#define B800F72     10
#define B800F75     11
#define B800F90     12
#define B800F100    13
#define B1024F87    14
#define B1024F60    15
#define B1024F66    16
#define B1024F70    17
#define B1024F72    18
#define B1024F75    19
#define B1024F90    20
#define B1024F100   21
#define B1120F70    22
#define B1152F87    23
#define B1152F95    24
#define B1152F60    25
#define B1152F70    26
#define B1152F75    27
#define B1152F80    28
#define B1280F87    29
#define B1280F95    30
#define B1280F60    31
#define B1280F70    32
#define B1280F74    33
#define B1280F75    34
#define B1600F60    35
#define B1600F66    36
#define B1600F76    37

/*
 * VGA parameter table entry to use when translating into 8514 format.
 * The value NO_TBL_ENTRY will cause the VGA to 8514 format translation
 * routine to fail gracefully if we have run into an EEPROM CRT parameter
 * table in VGA format for which we have no entry in the VGA parameter table.
 *
 * The entries in the VGA parameter table are arranged in ascending order
 * of horizontal resolution, with entries having the same horizontal
 * resolution sorted in ascending order of vertical scan frequency. No
 * distinction is made between interlaced and noninterlaced modes.
 *
 * The name for the constant is in the form
 * T<horizontal resolution>F<vertical scan frequency>, with the
 * "T" standing for (T)able.
 */
#define T640F72     0

#define T800F72     4
#define T800F70     3
#define T800F60     2
#define T800F56     1
#define T800F89     5

#define T1024F72    8
#define T1024F70    7
#define T1024F60    6
#define T1024F87    9

/*
 * Some resolution/vertical scan rate combinations (e.g. IBM default
 * 640x480) did not have VGA parameter tables in either VGAP$PS2.ASM
 * or VGAP$68A.MAC. For these modes, XlateVgaTable() will return
 * the parameters in Appendix D of the Programmer's Guide to the
 * Mach 32 Registers, since calculating the values for the mode table
 * requires a VGA parameter table.
 *
 * If we encounter one of these modes (identified by its (T)able
 * value being greater than or equal to USE_BOOK_VALUE), handle
 * it the same way we deal with modes whose parameters are not
 * stored in the EEPROM.
 */
#define NO_TBL_ENTRY -1
#define USE_BOOK_VALUE 1000

#define T640F60     USE_BOOK_VALUE+B640F60
#define T800F95     USE_BOOK_VALUE+B800F95
#define T1024F66    USE_BOOK_VALUE+B1024F66
#define T1280F87    USE_BOOK_VALUE+B1280F87
#define T1280F95    USE_BOOK_VALUE+B1280F95
#define T1120F70    USE_BOOK_VALUE+B1120F70

/*
 * Value returned in overscan words if no table entry was found.
 * This value was chosen because it will stand out when the overscan
 * words are printed out as 4 hex digits (as is done by VIDEO.EXE).
 */
#define INVALID_WARNING 0x0DEAD

/*
 * Bits which are set in pmode->control when sync polarity is negative,
 * and mask which must be ORed with sync width during VGA to 8514 conversion
 * if the sync is negative.
 */
#define HSYNC_BIT       0x4000
#define VSYNC_BIT       0x8000
#define NEG_SYNC_FACTOR 0x0020

/*
 * Mask for bit which is set in st_vga_data.MiscParms
 * for interlaced modes.
 */
#define INTERL  0x040

/*
 * Mask for bit which is set in st_vga_data.Mode
 * if word mode is enabled.
 */
#define WORD_MODE 0x004

/*
 * Format of VGA parameter table. This structure contains only those values
 * from the mode tables in VGAROM\VGAP$68A.MAC and VGAROM\VGAP$PS2.ASM which
 * are used in translating EEPROM data from VGA to 8514 format (original
 * tables are 64 bytes).
 *
 * The offsets listed in the comments are the offsets of the corresponding
 * bytes in the assembler tables.
 */
struct st_vga_data
{
    unsigned char Stretch;      /* Horizontal values stretched if 128 here, offset 0 */
    unsigned char MiscParms;    /* Miscelaneous parameters, offset 7 */
    unsigned char DisplayWidth; /* Offset 11 */
    unsigned char DisplayHgt;   /* Offset 28 */
    unsigned char Mode;         /* Contains word mode flag, offset 33 */

    /*
     * Values for CLOCK_SEL, DISP_CNTL, and ClockFreq taken from the
     * Programmer's Guide to the Mach 32 Registers. These values are
     * not stored as a combination of the CRT registers when the
     * EEPROM data is in VGA format.
     */
    unsigned short ClockSel;
    unsigned short DispCntl;
    unsigned long  ClockFreq;   /* Pixel clock frequency in Hertz */
};

/*
 * Data structure to hold mode parameters as quoted in Appendix D
 * of the Programmer's Guide to the Mach 32 Registers.
 */
struct st_book_data
{
    unsigned char HTotal;       /* Horizontal total */
    unsigned char HDisp;        /* Horizontal displayed */
    unsigned char HSyncStrt;    /* Horizontal sync start */
    unsigned char HSyncWid;     /* Horizontal sync width */
    unsigned short VTotal;      /* Vertical total */
    unsigned short VDisp;       /* Vertical displayed */
    unsigned short VSyncStrt;   /* Vertical sync start */
    unsigned char VSyncWid;     /* Vertical sync width */
    unsigned char DispCntl;     /* Display control */
    unsigned long ClockFreq;    /* Pixel clock frequency, in Hertz */
    unsigned short ClockSel;    /* Clock Select */
    unsigned short Refresh;     /* Refresh rate */
};

/*
 * Data structure which eases setting one particular byte of a
 * data word. If foo is a variable of type SplitWord, then a 16 bit
 * value can be set using foo.word, or the high and low bytes
 * can be accessed independently by using foo.byte.high and
 * foo.byte.low.
 */
struct TwoBytes
{
    unsigned char low;
    unsigned char high;
};

union SplitWord
{
    unsigned short word;
    struct TwoBytes byte;
};

/*
 * Function to translate a CRT parameter table in VGA format
 * into 8514 format and fill in the mode table.
 */
extern short XlateVgaTable(PVOID HwDeviceExtension, short TableOffset,
                           struct st_mode_table *pmode, short VgaTblEntry,
                           short BookTblEntry, struct st_eeprom_data *ee,
                           BOOL IsMach32);

/*
 * Function to fill in a CRT parameter table using values from
 * Appendix D of the Programmer's Guide to the Mach 32 Registers,
 * rather than the EEPROM contents. This is done when the
 * bit flag for "use stored parameters" is clear.
 */
extern void BookVgaTable(short VgaTblEntry, struct st_mode_table *pmode);

/*
 * Function to replace "canned" CRT tables with Mach 64 versions
 * in cases where the Mach 64 needs a pixel clock value which the
 * Mach 8 and Mach 32 can't generate.
 */
extern void SetMach64Tables(void);

/*
 * Array of parameters taken from Appendix D of the
 * Programmer's Guide to the Mach 32 Registers.
 *
 * For interlaced modes, the refresh rate field contains the
 * frame rate, not the vertical scan frequency.
 */
#ifdef INCLUDE_CVTVGA
struct st_book_data BookValues[B1600F76-B640F60+1] =
{
    {0x063, 0x04F, 0x052, 0x02C, 0x0418, 0x03BF, 0x03D2, 0x022, 0x023,  25175000L, 0x0800, 60}, /* 640x480 60Hz NI */
    {0x069, 0x04F, 0x052, 0x025, 0x040B, 0x03BF, 0x03D0, 0x023, 0x023,  32000000L, 0x0800, 72}, /* 640x480 72Hz NI */
    {0x068, 0x04F, 0x051, 0x028, 0x03E3, 0x03BF, 0x03C0, 0x023, 0x023,  31500000L, 0x0800, 75}, /* 640x480 75Hz NI */
    {0x067, 0x04F, 0x053, 0x025, 0x0428, 0x03BF, 0x03F0, 0x02E, 0x023,  39910000L, 0x0800, 90}, /* 640x480 90Hz NI */
    {0x069, 0x04F, 0x057, 0x030, 0x0422, 0x03BF, 0x03E9, 0x02C, 0x023,  44900000L, 0x0800, 100},    /* 640x480 100Hz NI */

    {0x080, 0x063, 0x065, 0x004, 0x057D, 0x04AB, 0x04C2, 0x02C, 0x033,  32500000L, 0x0800, 44}, /* 800x600 89Hz I */
    {0x084, 0x063, 0x06D, 0x010, 0x057C, 0x04AB, 0x04C2, 0x00C, 0x033,  36000000L, 0x0800, 47}, /* 800x600 95Hz I */
    {0x07F, 0x063, 0x066, 0x009, 0x04E0, 0x04AB, 0x04B0, 0x002, 0x023,  36000000L, 0x0800, 56}, /* 800x600 56Hz NI */
    {0x083, 0x063, 0x068, 0x010, 0x04E3, 0x04AB, 0x04B0, 0x004, 0x023,  40000000L, 0x0800, 60}, /* 800x600 60Hz NI */
    {0x07D, 0x063, 0x066, 0x012, 0x04F3, 0x04AB, 0x04C0, 0x02C, 0x023,  44900000L, 0x0800, 70}, /* 800x600 70Hz NI */
    {0x081, 0x063, 0x06A, 0x00F, 0x0537, 0x04AB, 0x04F8, 0x006, 0x023,  50000000L, 0x0800, 72}, /* 800x600 72Hz NI */
    {0x083, 0x063, 0x065, 0x00A, 0x04E0, 0x04AB, 0x04B0, 0x003, 0x023,  49500000L, 0x0800, 75}, /* 800x600 75Hz NI */
    {0x07B, 0x063, 0x063, 0x008, 0x04F2, 0x04AB, 0x04BB, 0x00B, 0x023,  56640000L, 0x0800, 90}, /* 800x600 90Hz NI */
    {0x086, 0x063, 0x067, 0x008, 0x04E0, 0x04AB, 0x04BA, 0x004, 0x023,  67500000L, 0x0800, 100},    /* 800x600 75Hz NI */

    {0x09D, 0x07F, 0x081, 0x016, 0x0660, 0x05FF, 0x0600, 0x008, 0x033,  44900000L, 0x0800, 43}, /* 1024x768 87Hz I */
    {0x0A7, 0x07F, 0x082, 0x031, 0x0649, 0x05FF, 0x0602, 0x026, 0x023,  65000000L, 0x0800, 60}, /* 1024x768 60Hz NI */
    {0x0AD, 0x07F, 0x085, 0x016, 0x065B, 0x05FF, 0x060B, 0x004, 0x023,  75000000L, 0x0800, 66}, /* 1024x768 66Hz NI */
    {0x0A5, 0x07F, 0x082, 0x031, 0x0649, 0x05FF, 0x0602, 0x026, 0x023,  75000000L, 0x0800, 70}, /* 1024x768 70Hz NI */
    {0x0A0, 0x07F, 0x082, 0x031, 0x0649, 0x05FF, 0x0602, 0x026, 0x023,  75000000L, 0x0800, 72}, /* 1024x768 72Hz NI */
    {0x0A3, 0x07F, 0x081, 0x00C, 0x063B, 0x05FF, 0x0600, 0x003, 0x023,  78750000L, 0x0800, 75}, /* 1024x768 75Hz NI */
    {0x0A3, 0x07F, 0x07C, 0x02C, 0x0698, 0x05FF, 0x0628, 0x02F, 0x023, 100000000L, 0x0800, 90}, /* 1024x768 90Hz NI */
    {0x0AD, 0x07F, 0x081, 0x02B, 0x062B, 0x05FF, 0x05FF, 0x028, 0x023, 110000000L, 0x0800, 100},    /* 1024x768 100Hz NI */

    {0x0AE, 0x08B, 0x095, 0x00F, 0x0659, 0x05DD, 0x05FC, 0x00A, 0x023,  80000000L, 0x0800, 70}, /* 1120x750 70Hz NI */

    {0x0B0, 0x08F, 0x097, 0x010, 0x083E, 0x06BF, 0x075D, 0x009, 0x033,  65000000L, 0x0800, 43}, /* 1152x864 87Hz I */
    {0x0B4, 0x08F, 0x09A, 0x010, 0x0766, 0x06BF, 0x06FD, 0x009, 0x033,  65000000L, 0x0800, 47}, /* 1152x864 95Hz I */
    {0x0B5, 0x08F, 0x097, 0x00E, 0x0727, 0x06BF, 0x06CD, 0x005, 0x023,  80000000L, 0x0800, 60}, /* 1152x864 60Hz NI */
    {0x0BC, 0x08F, 0x093, 0x013, 0x0764, 0x06BF, 0x06DC, 0x00B, 0x023, 100000000L, 0x0800, 70}, /* 1152x864 70Hz NI */
    {0x0B6, 0x08F, 0x092, 0x012, 0x07D5, 0x06BF, 0x071C, 0x008, 0x023, 110000000L, 0x0800, 75}, /* 1152x864 75Hz NI */
    {0x0B3, 0x08F, 0x090, 0x00E, 0x077D, 0x06BF, 0x06FD, 0x007, 0x023, 110000000L, 0x0800, 80}, /* 1152x864 80Hz NI */

    {0x0C7, 0x09F, 0x0A9, 0x00A, 0x08F8, 0x07FF, 0x0861, 0x00A, 0x033,  80000000L, 0x0800, 43}, /* 1280x1024 87Hz I */
    {0x0C7, 0x09F, 0x0A9, 0x00A, 0x0842, 0x07FF, 0x0800, 0x00A, 0x033,  80000000L, 0x0800, 47}, /* 1280x1024 95Hz I */
    {0x0D6, 0x09F, 0x0A9, 0x02E, 0x0852, 0x07FF, 0x0800, 0x025, 0x023, 110000000L, 0x0800 | CLOCK_SEL_MUX, 60}, /* 1280x1024 60Hz NI */
    {0x0D2, 0x09F, 0x0A9, 0x00E, 0x0851, 0x07FF, 0x0800, 0x005, 0x023, 126000000L, 0x0800 | CLOCK_SEL_MUX, 70}, /* 1280x1024 70Hz NI */
    {0x0D5, 0x09F, 0x0A3, 0x012, 0x084B, 0x07FF, 0x07FF, 0x01E, 0x023, 135000000L, 0x0800 | CLOCK_SEL_MUX, 74}, /* 1280x1024 74Hz NI */
    {0x0D2, 0x09F, 0x0A1, 0x012, 0x0851, 0x07FF, 0x0800, 0x003, 0x023, 135000000L, 0x0800 | CLOCK_SEL_MUX, 75}, /* 1280x1024 75Hz NI */

    /*
     * Although the horizontal CRT parameters are stored in 8-bit fields,
     * some refresh rates at 1600x1200 result in a 9-bit value. In these
     * cases, we store only the lower-order 8 bits, and the BIOS will
     * resolve the matter when we set the mode.
     */
    {0x0FF, 0x0C7, 0x0CB, 0x034, 0x09E9, 0x095F, 0x0971, 0x028, 0x023, 156000000L, 0x0800, 60}, /* 1600x1200 60Hz NI */
    {0x003, 0x0C7, 0x0CC, 0x031, 0x09C8, 0x095F, 0x0962, 0x023, 0x023, 172000000L, 0x0800, 66}, /* 1600x1200 66Hz NI */
    {0x003, 0x0C7, 0x0CC, 0x031, 0x09C8, 0x095F, 0x0962, 0x025, 0x023, 198000000L, 0x0800, 76}  /* 1600x1200 76Hz NI */
};
#else
extern struct st_book_data BookValues[B1600F76-B640F60+1]; 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\cvtvga.c ===
/************************************************************************/
/*                                                                      */
/*                              CVTVGA.C                                */
/*                                                                      */
/*  Copyright (c) 1992, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.9  $
    $Date:   20 Jul 1995 17:53:30  $
    $Author:   mgrubac  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/cvtvga.c  $
 * 
 *    Rev 1.9   20 Jul 1995 17:53:30   mgrubac
 * Added support for VDIF files
 * 
 *    Rev 1.8   10 Apr 1995 15:55:26   RWOLFF
 * Updated 640x480 72Hz mode table from version 1.2 to version 1.5 of the
 * Programmer's Guide to the Mach 32 Registers, added routine to replace
 * BookValues[] entries where the Mach 64 needs CRT parameters the Mach 8
 * and Mach 32 can't handle (currently, only 640x480 72Hz falls into
 * this category).
 * 
 *    Rev 1.7   23 Dec 1994 10:47:58   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.6   18 Nov 1994 11:39:04   RWOLFF
 * Added comments with function name at the end of each function.
 * 
 *    Rev 1.5   31 Aug 1994 16:22:42   RWOLFF
 * Added support for 1152x864 and 1600x1200 "canned" mode tables.
 * 
 *    Rev 1.4   19 Aug 1994 17:09:52   RWOLFF
 * Added support for non-standard pixel clock generators.
 * 
 *    Rev 1.3   18 May 1994 17:02:58   RWOLFF
 * Interlaced mode tables now report frame rate rather than vertical
 * scan frequency in the refresh rate field.
 * 
 *    Rev 1.2   12 May 1994 11:13:04   RWOLFF
 * Added refresh rate to entries in BookValues[], re-ordered BookValues[]
 * to allow a single range of indices to cover all desired refresh rates at
 * a given resolution even when the highest nonitnerlaced refresh rates
 * are ignored.
 * 
 *    Rev 1.1   07 Feb 1994 14:06:06   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:05:14   RWOLFF
 * Initial revision.
        
           Rev 1.4   30 Nov 1993 18:15:02   RWOLFF
        Corrected clock select value for 1280x1024 60Hz noninterlaced.
        
           Rev 1.3   08 Oct 1993 15:17:56   RWOLFF
        No longer includes VIDFIND.H
        
           Rev 1.2   08 Oct 1993 11:05:14   RWOLFF
        Removed unused "fall back to 56Hz" function for 800x600.
        
           Rev 1.1   03 Sep 1993 14:21:52   RWOLFF
        Partway through CX isolation.
        
           Rev 1.0   16 Aug 1993 13:22:04   Robert_Wolff
        Initial revision.
        
           Rev 1.12   30 Apr 1993 16:39:18   RWOLFF
        640x480 8BPP now stable on 512k Graphics Vantage. Fix is not yet final -
        old code is present but commented out, will remove when fix is final.
        
           Rev 1.11   21 Apr 1993 17:17:16   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        
           Rev 1.10   30 Mar 1993 17:10:28   RWOLFF
        Added 1280x1024 60Hz noninterlaced to resolutions which can be selected
        by BookVgaTable().
        
           Rev 1.9   25 Mar 1993 11:12:34   RWOLFF
        Brought comment block in function header into sync with actual code.
        
           Rev 1.8   08 Mar 1993 19:28:28   BRADES
        submit to MS NT
        
           Rev 1.6   06 Jan 1993 10:57:56   Robert_Wolff
        Added type casts to eliminate compile warnings.
        
           Rev 1.5   02 Dec 1992 17:28:58   Robert_Wolff
        Added function FallBack800to56(), which replaces those parameters
        of an 800x600 mode table with the values used by the 56Hz vertical
        frequency mode in Programmer's Guide to the Mach 32 Registers.
        
           Rev 1.4   27 Nov 1992 15:18:30   STEPHEN
        No change.
        
           Rev 1.3   17 Nov 1992 17:21:02   Robert_Wolff
        Now uses parameters from Appendix D of the Programmer's Guide to
        the Mach 32 Registers rather than values from the EEPROM if the
        CRTC_USAGE bit is clear (clear = use sync polarities only, will
        be clear if card is configured for a predefined monitor rather
        than having CRT parameters written to the EEPROM), fixed calculation
        of parameters for Mach 8 in 800x600 at 60, 70, and 72 Hz noninterlaced
        (other frequencies at 800x600, other resolutions on Mach 8, and all
        resolutions on Mach 32 didn't have this problem).
        
           Rev 1.2   13 Nov 1992 17:09:44   Robert_Wolff
        Now includes 68801.H, which consists of the now-obsolete MACH8.H
        and elements moved from VIDFIND.H.
        
           Rev 1.1   12 Nov 1992 16:39:38   Robert_Wolff
        Merged source trees for Windows NT driver and VIDEO.EXE test program
        (same source file can be used for both). XlateVgaTable() now takes
        an extra parameter to determine whether to handle data for Mach32
        or Mach8 cards, rather than using the global variable classMACH32.
        
           Rev 1.0   05 Nov 1992 13:59:56   Robert_Wolff
        Initial revision.
        
           Rev 1.1   09 Oct 1992 15:03:28   Robert_Wolff
        Now assigns values for DISP_CNTL, CLOCK_SEL, VFIFO_16, and VFIFO_24.
        
           Rev 1.0   01 Oct 1992 15:31:42   Robert_Wolff
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    CVTVGA.C -  Functions to convert CRT parameter table from VGA
        to 8514 format.

#endif

#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"

#define INCLUDE_CVTVGA
#include "amach.h"
#include "amach1.h"
#include "cvtvga.h"
#include "atimp.h"
#include "services.h"

/*
 * Arrays of VGA parameter tables used in translating from
 * VGA format to 8514 format. Currently the 800x600 noninterlaced
 * entries have different values for the Mach8 and Mach32
 * engines (Mach 8 is the "else" case with the comment
 * "TESTING ONLY" for 56Hz). Assume that the VFIFO_DEPTH
 * field is 8 entries.
 */
static struct st_vga_data VgaParmTable_M32[10] =
{
    {0x050, 0x000, 0x04F, 0x0DF, 0x0E3, 0x0800, 0x023, 32000000L},  /* Mode 12, VGAP$PS2.ASM */
    {0x064, 0x000, 0x063, 0x057, 0x0E3, 0x0800, 0x023, 36000000L},  /* m800_36m, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x057, 0x0E3, 0x0800, 0x023, 40000000L},  /* m800_40mphip, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x057, 0x0E3, 0x0800, 0x023, 44900000L},  /* m800_45m, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x057, 0x0E3, 0x0800, 0x023, 50350000L},  /* m800_50mvesa, VGAP$68A.MAC */
    {0x064, 0x0C0, 0x063, 0x057, 0x0E3, 0x0800, 0x033, 32500000L},  /* m800_36m8514, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 65000000L},  /* m1024_65m, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 75000000L},  /* m1024_75mvesa, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 75000000L},  /* m1024_75m72Hz, VGAP$68A.MAC */
    {0x080, 0x0C0, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x033, 44900000L}   /* m1024_45m, VGAP$68A.MAC */
};

static struct st_vga_data VgaParmTable_M8[10] =
{
    {0x050, 0x000, 0x04F, 0x0DF, 0x0E3, 0x0800, 0x023, 32000000L},  /* Mode 12, VGAP$PS2.ASM */
    {0x064, 0x000, 0x063, 0x02B, 0x0E7, 0x0800, 0x023, 36000000L},  /* m800_36m, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x02B, 0x0E7, 0x0800, 0x023, 40000000L},  /* m800_40mphip, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x02B, 0x0E7, 0x0800, 0x023, 44900000L},  /* m800_45m, VGAP$68A.MAC */
    {0x064, 0x000, 0x063, 0x02B, 0x0E7, 0x0800, 0x023, 50350000L},  /* m800_50mvesa, VGAP$68A.MAC */
    {0x064, 0x0C0, 0x063, 0x057, 0x0E3, 0x0800, 0x033, 32500000L},  /* m800_36m8514, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 65000000L},  /* m1024_65m, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 75000000L},  /* m1024_75mvesa, VGAP$68A.MAC */
    {0x080, 0x000, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x023, 75000000L},  /* m1024_75m72Hz, VGAP$68A.MAC */
    {0x080, 0x0C0, 0x07F, 0x0FF, 0x0E3, 0x0800, 0x033, 44900000L}   /* m1024_45m, VGAP$68A.MAC */
};

/*
 * Pointer to currently-used VGA parameter table
 */
static struct st_vga_data *VgaParmTable;


/*
 * Some of the processing of vertical values is handled differently
 * on non-Mach32 cards with 512k of video memory. The routine which
 * behaves differently based on whether or not we have an older card
 * with 512k is called several times, so setting this flag in a higher-
 * level routine will reduce the number of tests required.
 */
static BOOL HalfMeg;


static void GetVertOverflow(unsigned char *Value);
static unsigned short Gen8514V(union SplitWord INPut, short VgaTblEntry);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, GetVertOverflow)
#pragma alloc_text(PAGE_M, Gen8514V)
#pragma alloc_text(PAGE_M, XlateVgaTable)
#pragma alloc_text(PAGE_M, BookVgaTable)
#endif


/****************************************************************
 * GetVertOverflow
 *
 * Gets the overflow (2 most significant bits) of a vertical
 * value. On entry, Value will point to a copy of the CRT07
 * register which has been shifted so that bit 8 of the desired
 * value is in bit 0 of *Value, and bit 9 of the desired value
 * is in bit 5 of *Value. On exit, bits 8 and 9 will be in bits
 * 0 and 1 respectively of *Value.
 *
 *   INPUT: Value = ptr to raw overflow value
 *
 *   RETURN: Value = ptr to processed overflow value
 *
 ****************************************************************/
static void GetVertOverflow(unsigned char *Value)
{
    unsigned char Scratch;  /* Scratchpad variable */

    Scratch = (*Value >> 4) & 0x02;
    *Value = (*Value & 0x01) | Scratch;
    return;

}   /* GetVertOverflow() */



/****************************************************************
 * Gen8514V
 *
 * Another stage in the processing of a vertical value. This is
 * taken directly from gen8514v in COMBO$01.ASM.
 *
 *   INPUT: INPut	= value before processing
 *          VgaTblEntry = which set of VGA parameters corresponds
 *                        to the desired mode
 *
 *   RETURN: processed value
 *
 ****************************************************************/
static unsigned short Gen8514V(union SplitWord INPut, short VgaTblEntry)
{
    union SplitWord Scratch;    /* Scratchpad variable */

    if(VgaParmTable[VgaTblEntry].Mode & WORD_MODE)
	INPut.word <<= 1;

    INPut.word -= 1;
    Scratch.word = INPut.word;
    Scratch.word <<= 1;

// 512k handling not yet final. 640x480 is stable with wrong colours
// with special case commented out, don't want to delete code until
// changes are final.
//
//    if (HalfMeg)
//        {
//        Scratch.word <<= 1;
//        INPut.byte.low &= 0x01;
//        }
//    else{
        INPut.byte.low &= 0x03;
//        }

    Scratch.byte.low &= 0x0F8;
    INPut.byte.high = Scratch.byte.high;
    INPut.byte.low |= Scratch.byte.low;

    Scratch.byte.high &= 0x01;
    Scratch.byte.high <<= 2;
    INPut.byte.low |= Scratch.byte.high;

    return INPut.word;

}   /* Gen8514V() */



/*
 * short XlateVgaTable(HwDeviceExtension, TableOffset, pmode, VgaTblEntry,
 *                     BookTblEntry, ee, IsMach32);
 *
 * PVOID HwDeviceExtension;     Hardware extension for Windows NT
 * short TableOffset;           Offset of start of desired mode table into EEPROM
 * struct st_mode_table *pmode; Mode table to fill in
 * short VgaTblEntry;           Resolution/vertical frequency of desired mode
 * short BookTblEntry;          Appendix D entry to use if parameters not in EEPROM
 * struct st_eeprom_data *ee;   EEPROM setup description
 * BOOL IsMach32;               Indicates whether card is a Mach32 or a Mach8
 *
 * Translates an EEPROM mode table from VGA to 8514 format and
 * fills in the mode table passed in the parameter pmode.
 *
 *  RETURN: Nonzero if values filled in
 *          Zero if we were unable to find the appropriate
 *           VGA parameter table. If this is the case, the
 *           value INVALID_WARNING is placed in pmode->m_h_overscan,
 *           pmode->m_v_overscan, pmode->m_overscan_8b, and
 *           pmode->m_overscan_gr.
 */

short XlateVgaTable(PVOID HwDeviceExtension,
		    short TableOffset, struct st_mode_table *pmode,
                    short VgaTblEntry, short BookTblEntry,
                    struct st_eeprom_data *ee, BOOL IsMach32)
{
    PHW_DEVICE_EXTENSION phwDeviceExtension = HwDeviceExtension;


    /*
     * Certain modes on some cards require extra scaling. This variable
     * is set to the scaling factor (zero if no scaling needed). Initially
     * assume that no scaling is needed.
     */
    short FudgeFactor = 0;

    union SplitWord ValueRead;  /* Value read from the EEPROM */
    
    /*
     * Storage for CRT registers 06, 07 and 11. These registers are either
     * used a number of times and would need repeated reads if they weren't
     * saved, or are read before they are needed because they are the
     * other byte of a word which contains a register which is needed
     * at an earlier stage of the calculation.
     */
    unsigned char Crt06;
    unsigned char Crt07;
    unsigned char Crt11;

    /*
     * Saved value of the low byte of the vertical sync start.
     */
    unsigned char VSyncStart;




    /*
     * If this is a mode for which we have no information,
     * set up our warning and return.
     */
    if (VgaTblEntry == NO_TBL_ENTRY)
        {
        pmode->m_h_overscan = (short) INVALID_WARNING;
        pmode->m_v_overscan = (short) INVALID_WARNING;
        pmode->m_overscan_8b = (short) INVALID_WARNING;
        pmode->m_overscan_gr = (short) INVALID_WARNING;
        return 0;
        }

    /*
     * Under some circumstances, the CRT parameters will not be
     * properly entered into the EEPROM, so attempting to read
     * them will produce garbage values. If this is the case,
     * the CRTC_USAGE bit in word 0 of the mode table will
     * be clear (use sync polarities only).
     *
     * This case must be detected here, rather than calling
     * BookVgaTable() whenever the USE_STORED_PARMS bit of the
     * mode descriptor word is clear, because adjusting the screen
     * size and position for a custom monitor does not always set
     * this bit, but it will set the CRTC_USAGE bit.
     *
     * For this case, and for modes for which we have the parameters
     * from Appendix D of the Programmer's Guide to the Mach 32
     * Registers but no way to calculate the mode table information
     * based on values read from the EEPROM, fill in the mode table
     * with the book values and return.
     */
    ValueRead.word = (ee->EEread)((short)(TableOffset+0));
    if ((VgaTblEntry >= USE_BOOK_VALUE) || !(ValueRead.word & CRTC_USAGE))
        {
        BookVgaTable(BookTblEntry, pmode);
        return 1;
        }

    /*
     * We have VGA parameter tables to allow us to calculate the mode
     * table entries from the EEPROM contents.
     *
     * Initially assume that we have either a Mach32 card or an older
     * card with 1M of video memory.
     */
    HalfMeg = 0;

    /*
     * Select the VGA parameter table for the card we are using
     * (Mach8 or Mach32). On Mach8 cards, check if we are using
     * a mode which requires scaling, and if we have only 512k
     * of video memory.
     */
    if (IsMach32)
        {
        VgaParmTable = VgaParmTable_M32;
        }
    else{
        VgaParmTable = VgaParmTable_M8;
        if (VgaParmTable[VgaTblEntry].Stretch == 0x080)
            FudgeFactor = 1;
	if (!(INP(SUBSYS_STAT) & 0x080))
            HalfMeg = 1;
        }


    /*
     * Get the horizontal total first.
     */
    ValueRead.word = (ee->EEread)((short) (TableOffset+3));
    ValueRead.byte.high = ((ValueRead.byte.high + 5) << FudgeFactor) - 1;
    pmode->m_h_total = ValueRead.byte.high;
    Crt06 = ValueRead.byte.low;


    /*
     * Get the horizontal display width.
     */
    pmode->m_h_disp = VgaParmTable[VgaTblEntry].DisplayWidth;
    pmode->m_x_size = (pmode->m_h_disp + 1) * 8;


    /*
     * Get the start of the horizontal sync.
     */
    ValueRead.word = (ee->EEread)((short) (TableOffset+4));
    pmode->m_h_sync_strt = ((ValueRead.byte.high - 2) << FudgeFactor) + FudgeFactor;


    /*
     * Get the horizontal sync width.
     */
    ValueRead.word &= 0x1F1F;
    ValueRead.byte.low -= ValueRead.byte.high;
    ValueRead.byte.low &= 0x1f;
    ValueRead.byte.low <<= FudgeFactor;
    if (pmode->control & HSYNC_BIT)
        ValueRead.byte.low |= NEG_SYNC_FACTOR;
    pmode->m_h_sync_wid = ValueRead.byte.low;


    /*
     * Get the vertical total.
     */
    ValueRead.word = (ee->EEread)((short) (TableOffset+8));
    Crt07 = ValueRead.byte.high;
    ValueRead.byte.low = Crt06;
    GetVertOverflow(&(ValueRead.byte.high));    /* Overflow in bits 0&5 */
    ValueRead.word += 2;

    if (VgaParmTable[VgaTblEntry].MiscParms & INTERL)
        ValueRead.word += 4;

    ValueRead.word = Gen8514V(ValueRead, VgaTblEntry);

    if (VgaParmTable[VgaTblEntry].MiscParms & INTERL)
        ValueRead.byte.low &= 0x0FE;

    pmode->m_v_total = ValueRead.word;


    /*
     * Get the number of displayed scanlines.
     */
    ValueRead.byte.low = VgaParmTable[VgaTblEntry].DisplayHgt;
    ValueRead.byte.high = Crt07 >> 1;   /* Overflow in bits 1&6 */
    GetVertOverflow(&(ValueRead.byte.high));
    ValueRead.word++;
    pmode->m_v_disp = Gen8514V(ValueRead, VgaTblEntry);

    /*
     * Y size is derived by removing bit 2.
     */
    pmode->m_y_size = (((pmode->m_v_disp >> 1) & 0x0FFFC) | (pmode->m_v_disp & 0x03)) + 1;


    /*
     * Get the start of the vertical sync.
     */
    ValueRead.word = (ee->EEread)((short) (TableOffset+5));
    Crt11 = ValueRead.byte.low;
    ValueRead.byte.low = ValueRead.byte.high;
    VSyncStart = ValueRead.byte.high;
    ValueRead.byte.high = Crt07 >> 2;   /* Overflow in bits 2&7 */
    GetVertOverflow(&(ValueRead.byte.high));

    ValueRead.word++;
    pmode->m_v_sync_strt = Gen8514V(ValueRead, VgaTblEntry);


    /*
     * Get the vertical sync width.
     */
    Crt11 -= (VSyncStart & 0x0f);
    if (VgaParmTable[VgaTblEntry].Mode & WORD_MODE)
        Crt11 <<= 1;
    Crt11 &= 0x0f;
    if (pmode->control & VSYNC_BIT)
        Crt11 |= NEG_SYNC_FACTOR;
    pmode->m_v_sync_wid = Crt11;

    /*
     * Get the clock select and display control values.
     */
    pmode->m_clock_select = VgaParmTable[VgaTblEntry].ClockSel;
    pmode->ClockFreq = VgaParmTable[VgaTblEntry].ClockFreq;
    pmode->m_disp_cntl = (UCHAR)(VgaParmTable[VgaTblEntry].DispCntl);

    /*
     * Assume an 8-entry FIFO for 16 and 24 bit colour.
     */
    pmode->m_vfifo_24 = 8;
    pmode->m_vfifo_16 = 8;

    /*
     * Some parameters in 8514 format do not have corresponding EEPROM
     * table entries in VGA format. Set the pmode fields for these
     * parameters to zero.
     */
    pmode->m_h_overscan = 0;
    pmode->m_v_overscan = 0;
    pmode->m_overscan_8b = 0;
    pmode->m_overscan_gr = 0;
    pmode->m_status_flags = 0;


    /*
     * Let the caller know that the pmode table is now filled in.
     */
    return 1;

}   /* XlateVgaTable() */


/*
 * void BookVgaTable(VgaTblEntry, pmode);
 *
 * short VgaTblEntry;               Desired entry in BookValues[]
 * struct st_mode_table *pmode;     Mode table to fill in
 *
 * Fills in a mode table using the values in the BookValues[] entry
 * corresponding to the resolution specified by VgaTblEntry.
 */
void BookVgaTable(short VgaTblEntry, struct st_mode_table *pmode)
{
    pmode->m_h_total = BookValues[VgaTblEntry].HTotal;
    pmode->m_h_disp  = BookValues[VgaTblEntry].HDisp;
    pmode->m_x_size  = (pmode->m_h_disp+1)*8;

    pmode->m_h_sync_strt = BookValues[VgaTblEntry].HSyncStrt;
    pmode->m_h_sync_wid  = BookValues[VgaTblEntry].HSyncWid;

    pmode->m_v_total = BookValues[VgaTblEntry].VTotal;
    pmode->m_v_disp  = BookValues[VgaTblEntry].VDisp;
    /*
     * y_size is derived by removing bit 2
     */
    pmode->m_y_size = (((pmode->m_v_disp >> 1) & 0x0FFFC) | (pmode->m_v_disp & 0x03)) + 1;

    pmode->m_v_sync_strt = BookValues[VgaTblEntry].VSyncStrt;
    pmode->m_v_sync_wid  = BookValues[VgaTblEntry].VSyncWid;
    pmode->m_disp_cntl   = BookValues[VgaTblEntry].DispCntl;

    pmode->m_clock_select = BookValues[VgaTblEntry].ClockSel;
    pmode->ClockFreq = BookValues[VgaTblEntry].ClockFreq;

    /*
     * Assume 8 FIFO entries for 16 and 24 bit colour.
     */
    pmode->m_vfifo_24 = 8;
    pmode->m_vfifo_16 = 8;

    /*
     * Fill in the refresh rate
     */
    pmode->Refresh = BookValues[VgaTblEntry].Refresh;

    /*
     * Clear the values which we don't have data for, then let
     * the caller know that the table is filled in.
     */
    pmode->m_h_overscan = 0;
    pmode->m_v_overscan = 0;
    pmode->m_overscan_8b = 0;
    pmode->m_overscan_gr = 0;
    pmode->m_status_flags = 0;

    return;

}   /* BookVgaTable() */



/***************************************************************************
 *
 * void SetMach64Tables(void);
 *
 * DESCRIPTION:
 *  Replace "canned" mode tables that differ between Mach 64 and
 *  Mach 8/Mach 32 parameters with Mach 64 versions. Whenever possible,
 *  an update to a VESA-compatible parameter table should be done in
 *  BookValues[] - this routine is only for those cases where the
 *  Mach 64 requires a pixel clock frequency that the clock generator
 *  on the Mach 8 or Mach 32 can't produce.
 *
 * GLOBALS CHANGED:
 *  Some entries in BookValues[] table
 *
 * CALLED BY:
 *  QueryMach64()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void SetMach64Tables(void)
{
    #define NUM_TABLES_TO_SWAP  1
    ULONG TableIndices[NUM_TABLES_TO_SWAP] =
    {
        B640F72
    };
    struct st_book_data NewTables[NUM_TABLES_TO_SWAP] =
    {
        {0x067, 0x04F, 0x052, 0x025, 0x040B, 0x03BF, 0x03D0, 0x023, 0x023,  31200000L, 0x0800, 72}  /* 640x480 72Hz NI */
    };
    ULONG LoopCount;

    /*
     * Go through the list of tables that need to be replaced, setting all
     * the fields to the Mach 64 values.
     */
    for (LoopCount = 0; LoopCount < NUM_TABLES_TO_SWAP; LoopCount++)
        {
        BookValues[TableIndices[LoopCount]].HTotal    = NewTables[LoopCount].HTotal;
        BookValues[TableIndices[LoopCount]].HDisp     = NewTables[LoopCount].HDisp;
        BookValues[TableIndices[LoopCount]].HSyncStrt = NewTables[LoopCount].HSyncStrt;
        BookValues[TableIndices[LoopCount]].HSyncWid  = NewTables[LoopCount].HSyncWid;
        BookValues[TableIndices[LoopCount]].VTotal    = NewTables[LoopCount].VTotal;
        BookValues[TableIndices[LoopCount]].VDisp     = NewTables[LoopCount].VDisp;
        BookValues[TableIndices[LoopCount]].VSyncStrt = NewTables[LoopCount].VSyncStrt;
        BookValues[TableIndices[LoopCount]].VSyncWid  = NewTables[LoopCount].VSyncWid;
        BookValues[TableIndices[LoopCount]].DispCntl  = NewTables[LoopCount].DispCntl;
        BookValues[TableIndices[LoopCount]].ClockFreq = NewTables[LoopCount].ClockFreq;
        BookValues[TableIndices[LoopCount]].ClockSel  = NewTables[LoopCount].ClockSel;
        BookValues[TableIndices[LoopCount]].Refresh   = NewTables[LoopCount].Refresh;
        }

    return;

}   /* SetMach64Tables() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\atimp.c ===
/************************************************************************/
/*                                                                      */
/*                              ATIMP.C                                 */
/*                                                                      */
/*      Copyright (c) 1992,         ATI Technologies Inc.               */
/************************************************************************/

//  Brades:  Changes to be merged into Rob's source
//
//  904 -- frame address stored in dar[0]. we are rgistering our LFB addres
//      in DriverIORanges, but assigning to frameaddress.
//      Is this used,  or needed????

/**********************       PolyTron RCS Utilities

  $Revision:   1.43  $
      $Date:   15 May 1996 16:29:52  $
   $Author:   RWolff  $
      $Log:   S:/source/wnt/ms11/miniport/archive/atimp.c_v  $
 *
 *    Rev 1.43   15 May 1996 16:29:52   RWolff
 * Added workaround for Alpha hang on PCI bus greater than 0, now reports
 * failure of mode set on Mach 64.
 *
 *    Rev 1.42   01 May 1996 14:07:52   RWolff
 * Calls new routine DenseOnAlpha() to determine dense space support rather
 * than assuming all PCI cards support dense space.
 *
 *    Rev 1.41   23 Apr 1996 17:16:38   RWolff
 * Now reports 1M cards with SDRAM (needs special alignment in display
 * driver), separated "internal DAC cursor double buffering needed"
 * from "this is a CT".
 *
 *    Rev 1.40   15 Mar 1996 16:27:08   RWolff
 * IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES now only frees the I/O mapped
 * registers in NT 4.0 and above. This is because the mapped values for
 * the permanent and test screens use the same virtual address, and
 * in 3.51 VideoPortUnmapMemory() refuses to unmap them.
 *
 *    Rev 1.39   12 Mar 1996 17:41:50   RWolff
 * Made IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES work under new source
 * stream display driver, removed debug print statements from ATIMPResetHw()
 * since this routine can't call pageable routines and debug print
 * statements are pageable.
 *
 *    Rev 1.38   29 Jan 1996 16:53:30   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC, removed
 * dead code.
 *
 *    Rev 1.37   23 Jan 1996 11:41:10   RWolff
 * Eliminated level 3 warnings, added debug print statements.
 *
 *    Rev 1.36   22 Dec 1995 14:51:42   RWolff
 * Added support for Mach 64 GT internal DAC, switched to TARGET_BUILD
 * to identify the NT version for which the driver is being built.
 *
 *    Rev 1.35   23 Nov 1995 11:24:40   RWolff
 * Added multihead support.
 *
 *    Rev 1.34   17 Nov 1995 13:41:02   RWolff
 * Temporary fallback until problem with VideoPortGetBaseAddress() is
 * resolved. This should have gone in as branch revision 1.33.1.0, but
 * the @#$%^&* configuration doesn't allow branches.
 *
 *    Rev 1.33   27 Oct 1995 14:20:06   RWolff
 * Fixes to bring up NT 3.51 on PPC, no longer makes mapped LFB part of
 * hardware device extension.
 *
 *    Rev 1.32   08 Sep 1995 16:36:04   RWolff
 * Added support for AT&T 408 DAC (STG1703 equivalent).
 *
 *    Rev 1.31   28 Aug 1995 16:37:36   RWolff
 * No longer restores memory size on x86 boxes in ATIMPResetHw(). This
 * is a fix for EPR 7839 - the restoration is not necessary on x86
 * machines, but on some non-x86 boxes the memory size is not restored
 * on a warm boot, so we must do it to allow the use of modes needing
 * more than 1M after booting out of a 4BPP mode.
 *
 *    Rev 1.30   24 Aug 1995 15:39:42   RWolff
 * Changed detection of block I/O cards to match Microsoft's standard for
 * plug-and-play, now reports CT and VT ASICs to the display driver.
 *
 *    Rev 1.29   03 Aug 1995 16:22:42   RWOLFF
 * Reverted to old bus ordering (PCI last) for non-Alpha machines under
 * NT 3.5. Using the new ordering (PCI first) on an x86 under 3.5
 * resulted in the display applet rejecting attempts to test 16 and 24 BPP
 * on a Mach 32 (PCI or ISA) in a PCI machine.
 *
 *    Rev 1.28   02 Jun 1995 14:19:14   RWOLFF
 * Rearranged bus test order to put PCI first, added CT internal to
 * DACs supported in no-BIOS version.
 *
 *    Rev 1.27   31 Mar 1995 11:55:18   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.26   08 Mar 1995 11:33:18   ASHANMUG
 * The pitch in 24bpp should be the pitch in engine pixels and not true pixels
 *
 *    Rev 1.25   27 Feb 1995 17:51:50   RWOLFF
 * Now reports (Mach 64 only) whether I/O space is packed (relocatable)
 * or not, reports number of lines of offscreen memory for 4BPP as if
 * the card has 1M of video memory, since we set the card to 1M for
 * this depth.
 *
 *    Rev 1.24   24 Feb 1995 12:24:40   RWOLFF
 * Now adds text banding to the ATIModeInformation->ModeFlags bits
 * that are filled in.
 *
 *    Rev 1.23   20 Feb 1995 18:03:30   RWOLFF
 * Reporting of screen tearing on 2M boundary is now DAC-independant, added
 * 1600x1200 16BPP to modes which experience this tearing.
 *
 *    Rev 1.22   03 Feb 1995 15:13:50   RWOLFF
 * Added packets to support DCI.
 *
 *    Rev 1.21   30 Jan 1995 12:16:24   RWOLFF
 * Made definition of IBM DAC special cursor flag consistent with
 * similar flag for TVP DAC.
 *
 *    Rev 1.20   18 Jan 1995 15:38:46   RWOLFF
 * Now looks for Mach64 before looking for our older accelerators, Chrontel
 * DAC is now supported as a separate type rather than being lumped in
 * with STG1702.
 *
 *    Rev 1.19   11 Jan 1995 13:54:00   RWOLFF
 * ATIMPResetHw() now restores the memory size on Mach64 cards. This is
 * a fix for a problem that showed up on the DEC Alpha, but may affect
 * other platforms as well. In 4BPP modes, we must tell the card that it
 * has only 1M of memory, but on a warm boot, the x86 emulation did not
 * re-initialize the memory size, so until the next cold boot, only modes
 * available in 1M were listed.
 *
 *    Rev 1.18   04 Jan 1995 11:59:28   RWOLFF
 * ATIMPFindAdapter() will only detect ATI cards on the first invocation,
 * to avoid the same card being detected once per bus and causing problems
 * when Windows NT thinks it's multiple cards.
 *
 *    Rev 1.17   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.16   18 Nov 1994 11:36:52   RWOLFF
 * Now checks for PCI bus, cleaned up temporary debug print statements,
 * fixed non-x86 Mach 64 handling, added support for Power PC and
 * STG1703 DAC.
 *
 *    Rev 1.15   31 Aug 1994 16:14:00   RWOLFF
 * IOCTL_VIDEO_ATI_GET_VERSION packet now reports TVP3026 DAC (different
 * cursor handling needed in display driver),
 * IOCTL_VIDEO_ATI_GET_MODE_INFORMATION now reports 1152x864 24BPP as
 * having screen tearing at end of first 2M bank.
 *
 *    Rev 1.14   22 Jul 1994 17:47:50   RWOLFF
 * Merged with Richard's non-x86 code stream.
 *
 *    Rev 1.13   20 Jul 1994 13:04:06   RWOLFF
 * Changes required to support multiple I/O base addresses for Mach 64
 * accelerator registers, ATIMPInitialize() now leaves the adapter in
 * a state where an INT 10 can switch it to a VGA mode (fix for
 * showstopper bug on Landtrain machines), calls new routine
 * FillInRegistry() so the video applet can get information about
 * the graphics card.
 *
 *    Rev 1.12   30 Jun 1994 18:11:36   RWOLFF
 * Changes to allow the new method of checking for aperture conflict.
 *
 *    Rev 1.11   15 Jun 1994 11:04:24   RWOLFF
 * In IOCTL_VIDEO_ATI_GET_VERSION, now only sets
 * RequestPacket->StatusBlock->Information if the buffer is big enough.
 *
 *    Rev 1.10   20 May 1994 19:18:00   RWOLFF
 * IOCTL_VIDEO_ATI_GET_VERSION old format packet now returns the highest
 * pixel depth for a given resolution even if it isn't the last mode
 * table for the resolution.
 *
 *    Rev 1.9   20 May 1994 13:57:40   RWOLFF
 * Ajith's change: now saves in the query structure the bus type reported by NT.
 *
 *    Rev 1.8   12 May 1994 11:04:24   RWOLFF
 * Now forces OEM handling on DEC ALPHA machines.
 *
 *    Rev 1.7   04 May 1994 19:25:40   RWOLFF
 * Fixes for hanging and corrupting screen when display applet run.
 *
 *    Rev 1.6   28 Apr 1994 10:59:56   RWOLFF
 * Moved mode-independent bug/feature flags to IOCTL_VIDEO_ATI_GET_VERSION
 * packet from IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet.
 *
 *    Rev 1.5   27 Apr 1994 13:54:42   RWOLFF
 * IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet now reports whether MIO bug
 * is present on Mach 32 cards.
 *
 *    Rev 1.4   31 Mar 1994 15:05:00   RWOLFF
 * Added DPMS support, brought ATIMPResetHw() up to latest specs, added
 * debugging code.
 *
 *    Rev 1.3   14 Mar 1994 16:32:20   RWOLFF
 * Added ATIMPResetHw() function, fix for 2M boundary tearing, replaced
 * VCS logfile comments that were omitted in an earlier checkin.
 *
 *    Rev 1.2   03 Mar 1994 12:36:56   ASHANMUG
 * Make pageable
 *
 *    Rev 1.1   07 Feb 1994 13:56:18   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed, removed LookForSubstitute() since miniport is no longer
 * supposed to check whether mode has been substituted, no longer logs
 * a message when the miniport aborts due to no ATI card being found,
 * removed unused routine ATIMPQueryPointerCapabilities().
 *
 *    Rev 1.0   31 Jan 1994 10:52:34   RWOLFF
 * Initial revision.

           Rev 1.6   14 Jan 1994 15:14:08   RWOLFF
        Removed commented-out code, packet announcements now all controlled by
        DEBUG_SWITCH, device reset for old cards now done by a single call,
        new format for IOCTL_VIDEO_ATI_GET_VERSION packet, reports block write
        capability in IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet, added
        1600x1200 support.

           Rev 1.5   30 Nov 1993 18:10:04   RWOLFF
        Moved query of card capabilities (once type of card is known) from
        ATIMPFindAdapter() to ATIMPInitialize() because query for Mach 64 needs
        to use VideoPortInt10(), which can't be used in ATIMPFindAdapter().

           Rev 1.4   05 Nov 1993 13:22:12   RWOLFF
        Added initial Mach64 code (currently inactive).

           Rev 1.3   08 Oct 1993 11:00:24   RWOLFF
        Removed code specific to a particular family of ATI accelerators.

           Rev 1.2   24 Sep 1993 11:49:46   RWOLFF
        Removed cursor-specific IOCTLs (handled in display driver), now selects
        24BPP colour order best suited to the DAC being used instead of forcing
        BGR.

           Rev 1.1   03 Sep 1993 14:20:46   RWOLFF
        Partway through CX isolation.

           Rev 1.0   16 Aug 1993 13:27:50   Robert_Wolff
        Initial revision.

           Rev 1.23   06 Jul 1993 15:46:14   RWOLFF
        Got rid of mach32_split_fixup special handling. This code was to support
        a non-production hardware combination.

           Rev 1.22   10 Jun 1993 15:58:32   RWOLFF
        Reading from registry now uses a static buffer rather than a dynamically
        allocated one (originated by Andre Vachon at Microsoft).

           Rev 1.21   07 Jun 1993 11:43:16   BRADES
        Rev 6 split transfer fixup.

           Rev 1.19   18 May 1993 14:04:00   RWOLFF
        Removed reference to obsolete header TTY.H, calls to wait_for_idle()
        no longer pass hardware device extension, since it's a global variable.

           Rev 1.18   12 May 1993 16:30:36   RWOLFF
        Now writes error messages to event log rather than blue screen,
        initializes "special handling" variables determined from BIOS
        to default values on cards with no BIOS. This revision contains
        code for experimental far call support, but it's "#if 0"ed out.

           Rev 1.17   10 May 1993 16:35:12   RWOLFF
        LookForSubstitute() now recognizes all cases of colour depth not
        supported by the DAC, unusable linear frame buffer now falls back
        to LFB disabled operation rather than aborting the miniport, removed
        unused variables and unnecessary passing of hardware device extension
        as a parameter.

           Rev 1.16   30 Apr 1993 17:58:50   BRADES
        ATIMP startio assign QueryPtr once at start of function.
        uses aVideoAddress virtual table for IO port addresses.

           Rev 1.15   30 Apr 1993 16:33:42   RWOLFF
        Updated to use NT build 438 initialization data structure.
        Registry read buffer is now dynamically allocated to fit data requested
        rather than being a fixed "hope it's big enough" size.

           Rev 1.14   21 Apr 1993 17:22:06   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        Accelerator detection now checks only for functionality, not our BIOS
        signature string which may not be present in OEM versions. Query
        structure now indicates whether extended BIOS functions and/or
        EEPROM are present. Added ability to switch between graphics and
        text modes using absolute far calls in BIOS. Removed handling
        of obsolete DriverOverride registry field.

           Rev 1.13   14 Apr 1993 18:30:22   RWOLFF
        24BPP is now done as BGR (supported by both TI and Brooktree DACs)
        rather than RGB (only supported by TI DACs).

           Rev 1.12   08 Apr 1993 16:53:18   RWOLFF
        Revision level as checked in at Microsoft.

           Rev 1.9   25 Mar 1993 11:10:38   RWOLFF
        Cleaned up compile warnings, now returns failure if no EEPROM is present.

           Rev 1.8   16 Mar 1993 17:15:16   BRADES
        get_cursor uses screen_pitch instead of x_size.

           Rev 1.7   16 Mar 1993 17:04:58   BRADES
        Change ATI video to graphics message

           Rev 1.6   15 Mar 1993 22:20:30   BRADES
        use m_screen_pitch for the # pixels per display lines

           Rev 1.5   08 Mar 1993 19:23:44   BRADES
        update memory sizing to 256 increments, clean code.

           Rev 1.4   10 Feb 1993 13:01:28   Robert_Wolff
        IOCTL_VIDEO_MAP_VIDEO_MEMORY no longer assumes frame buffer length
        is equal to video memory size (linear aperture present). It can now
        accept 64k (uses VGA aperture) and 0 (no aperture available).

           Rev 1.3   06 Feb 1993 12:55:52   Robert_Wolff
        Now sets VIDEO_MODE_INFORMATION.ScreenStride to bytes per line (as listed
        in the documentation). In the October beta, it had to be pixels per line.

           Rev 1.2   05 Feb 1993 22:12:36   Robert_Wolff
        Adjusted MessageDelay() to compensate for short_delay() no longer being
        optimized out of existence.

           Rev 1.1   05 Feb 1993 16:15:28   Robert_Wolff
        Made it compatible with the new DDK, registry calls now use VideoPort
        functions rather than RTL functions. This version will work with the
        framebuffer driver.

           Rev 1.0   02 Feb 1993 13:36:50   Robert_Wolff
        Initial revision.

           Rev 1.2   26 Jan 1993 10:28:30   Robert_Wolff
        Now fills in Number<colour>Bits fields in VIDEO_MODE_INFORMATION structure.

           Rev 1.1   25 Jan 1993 13:31:52   Robert_Wolff
        Re-enabled forcing of shared VGA/accelerator memory for Mach 32
        cards with no aperture enabled.

           Rev 1.0   22 Jan 1993 16:44:42   Robert_Wolff
        Initial revision.

           Rev 1.26   21 Jan 1993 17:59:24   Robert_Wolff
        Eliminated multiple definition link warnings, updated comments
        in LookForSubstitute().

           Rev 1.25   20 Jan 1993 17:47:48   Robert_Wolff
        Now checks optional DriverOverride field in registry, and forces
        use of appropriate (engine, framebuffer, or VGAWonder) driver
        if the field is present and nonzero. If field is missing or zero,
        former behaviour is used.
        IOCTL_VIDEO_ATI_GET_VERSION packet now also returns the maximum
        pixel depth available at each resolution.
        Added mode substitution case for 16 BPP selected when using the
        engine-only (fixed 8 BPP colour depth) driver.

           Rev 1.24   15 Jan 1993 15:12:26   Robert_Wolff
        Added IOCTL_VIDEO_ATI_GET_VERSION packet in ATIMPStartIO() to
        return version number of the miniport.

           Rev 1.23   14 Jan 1993 17:49:40   Robert_Wolff
        Removed reference to blank screen in message printed before query
        structure filled in, moved printing of this message and the "Done."
        terminator so all checking for video cards is between them.

           Rev 1.22   14 Jan 1993 10:37:28   Robert_Wolff
        Re-inserted "fail if VGAWonder but no ATI accelerator" check due
        to lack of VGAWONDER .DLL file in late January driver package.

           Rev 1.21   13 Jan 1993 13:31:04   Robert_Wolff
        Added support for the Corsair and other machines which don't store
        their aperture location in the EEPROM, single miniport now handles
        VGAWonder in addition to accelerators.

           Rev 1.20   07 Jan 1993 18:20:34   Robert_Wolff
        Now checks to see if aperture is configured but unusable, and
        forces the use of the engine-only driver if this is the case.
        Added message to let users know that the black screen during
        EEPROM read is normal.

           Rev 1.19   06 Jan 1993 11:04:36   Robert_Wolff
        BIOS locations C0000-DFFFF now mapped as one block, cleaned up warnings.

           Rev 1.18   04 Jan 1993 14:39:50   Robert_Wolff
        Added card type as a parameter to setmode().

           Rev 1.17   24 Dec 1992 14:41:20   Chris_Brady
        fixup warnings

           Rev 1.16   15 Dec 1992 13:34:46   Robert_Wolff
        Writing of MEM_CFG when forcing 4M aperture now preserves all but
        the aperture size bits. This allows operation on Corsair as well
        as standard versions of the Mach 32 card.

           Rev 1.15   11 Dec 1992 14:45:44   Robert_Wolff
        Now forces the use of the FRAMEBUF driver if a 2M aperture is configured.

           Rev 1.14   11 Dec 1992 09:47:34   Robert_Wolff
        Now sets the "don't show the substitution message" flag no matter what
        the status of the first call to LookForSubstitute() was (sub, no sub,
        or error), rather than only when a substitution was made and the message
        was displayed.

           Rev 1.13   10 Dec 1992 14:24:16   Robert_Wolff
        Shortened mode substitution messages in LookForSubstitute(), messages
        are now displayed only on the first call to this routine, to avoid
        delays in switching back to graphics mode from a full-screen DOS box.

           Rev 1.12   09 Dec 1992 14:18:38   Robert_Wolff
        Eliminated uninitialized pointer in IOCTL_VIDEO_SET_CURRENT_MODE
        packet, moved initialization of QueryPtr and FirstMode pointers
        to before the switch on packet type, rather than being in all
        packets where the pointers are used. This should prevent similar
        problems if other packets are changed to use the pointers, and
        eliminates redundant code.

           Rev 1.11   09 Dec 1992 10:35:04   Robert_Wolff
        Added user-level "blue-screen" messages for fatal errors, checks BIOS
        revision to catch Mach 8 cards that can't do 1280x1024, forces the
        use of the engine-only driver if no aperture is configured, memory
        boundary and hardware cursor stuff is now done only for Mach 32 cards
        (since they're only available on Mach 32), sets split pixel mode for
        Mach 8 in 1280x1024, added mode substitution message for Mach 8 when
        registry is configured for 16 BPP or higher.

           Rev 1.10   01 Dec 1992 17:00:18   Robert_Wolff
        "I-beam" text insertion cursor no longer has left side filled with a
        solid black block.

           Rev 1.9   30 Nov 1992 17:34:38   Robert_Wolff
        Now allows 1M aperture if configured video mode uses less than 1M
        of video memory, prints message to user if Windows NT decides
        to use a video mode other than the one configured in the registry.

           Rev 1.8   27 Nov 1992 18:40:24   Chris_Brady
        VGA Wonder detect looks for signature in a range.
        Graphics Ultra Pro Microchannel version moved it.

           Rev 1.7   25 Nov 1992 09:47:36   Robert_Wolff
        Now tells GetCapMach32() to assume the VGA boundary is set to shared,
        since we will set it to this value later, and we don't want to lose
        access to modes which require some of the memory currently assigned
        to the VGA. Added delay in IOCTL_VIDEO_SET_CURRENT_MODE case of
        ATIMPStartIO() after calculating the hardware cursor offset. This delay
        may not be needed, but I didn't want to remove it since this is the
        source for the driver sent to QA and I wanted it to be rebuildable.

           Rev 1.6   20 Nov 1992 16:04:30   Robert_Wolff
        Now reads query information from Mach 8 cards instead of only
        from Mach 32 cards. Mach 8 cards still cause ATIMPFindAdapter()
	to return ERROR_INVALID_PARAMETER, since until we get an engine-only
        driver, we can't use a card that doesn't support an aperture.

           Rev 1.5   19 Nov 1992 09:53:36   GRACE
        after setting a mode do a wait for idle to let the pixel clock settle before
        using engine to draw.

           Rev 1.4   17 Nov 1992 14:07:52   GRACE
        changed framelength to reflect the size of memory on the board not the
        aperture size.
        In the StartIO section, only set up QueryPtr and FirstMode when necessary

           Rev 1.3   12 Nov 1992 09:23:02   GRACE
        removed the struct definition for DeviceExtension to a68.h
        Not using DevInitATIMP, DevSetCursorShape, DevSetCursorPos or DevCursorOff.
	DevCursorOff changed to a define that turns cursor off with an OUTP.
        Also removed some excess junk that is left from the video program.

           Rev 1.2   06 Nov 1992 19:12:48   Robert_Wolff
        Fixed signed/unsigned bug in multiple calls to VideoPortInitialize().
        Now requests access to I/O ports and ROM addresses used for VGA-style
        EEPROM reads, and gets information about installed modes from the
        Mach32 card.

        NOTE: This is a checkpoint for further changes. Due to incompatibilities
              between the old (hardcoded resolution) code in other modules and the
              new (read from the card) code here, this revision will not produce a
              working driver.

           Rev 1.1   05 Nov 1992 12:02:18   Robert_Wolff
        Now reads query structure and mode tables from the MACH32 card
        rather than using hardcoded values for aperture size/location
        and supported modes.

           Rev 1.0   02 Nov 1992 20:47:58   Chris_Brady
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC

DESCRIPTION
     ATI Windows NT Miniport driver for the Mach 64, Mach32, and Mach8
     families.
     This file will select the appropriate functions depending on the
     computer configuration.

OTHER FILES
     ???

#endif

#include <stdio.h>
#include <string.h>

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "stdtyp.h"

#include "amach1.h"
#include "vidlog.h"

/*
 * To avoid multiple definition errors, pre-initialized variables
 * in ATIMP.H are initialized if INCLUDE_ATIMP is defined, but
 * are declared external if it is not defined. For consistency,
 * define this value here rather than in other files which also include
 * ATIMP.H so the variables are initialized by the source file with
 * the same root name as the header file.
 */
#define INCLUDE_ATIMP
#include "detect_m.h"
#include "amachcx.h"
#include "atimp.h"
#include "atint.h"
#include "atioem.h"
#include "cvtddc.h"
#include "dpms.h"
#include "eeprom.h"
#include "init_cx.h"
#include "init_m.h"
#include "modes_m.h"
#include "query_cx.h"
#include "query_m.h"
#include "services.h"
#include "setup_cx.h"
#include "setup_m.h"



//------------------------------------------------------------------

/*
 * Initially assume we have not yet found a non-block card, and
 * have found no block relocatable cards.
 */
BOOL FoundNonBlockCard = FALSE;
USHORT NumBlockCardsFound = 0;

/*------------------------------------------------------------------------
 *
 * Function Prototypes
 *
 * Functions that start with 'ATIMP' are entry points for the OS port driver.
 */

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    );

VP_STATUS
ATIMPFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
ATIMPInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
ATIMPStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

BOOLEAN
ATIMPResetHw(
    IN PVOID HwDeviceExtension,
    IN ULONG Columns,
    IN ULONG Rows
    );

//
// New entry points added for NT 5.0.
//

#if (TARGET_BUILD >= 500)

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
ATIMPSetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve possible DPMS power management states.
//
VP_STATUS
ATIMPGetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
ATIMPGetVideoChildDescriptor(
    PVOID pHwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );
#endif  // TARGET_BUILD >= 500


//
// Routine to set the DPMS power management state.
//
BOOLEAN
SetDisplayPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    VIDEO_POWER_STATE VideoPowerState
    );

//
// Routine to retrieve the current DPMS power management state.
//
VIDEO_POWER_STATE
GetDisplayPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );


/* */
UCHAR RegistryBuffer[REGISTRY_BUFFER_SIZE];     /* Last value retrieved from the registry */
ULONG RegistryBufferLength = 0;     /* Size of last retrieved value */

/*
 * Allow miniport to be swapped out when not needed.
 *
 * ATIMPResetHw() must be in the non-paged pool.
 *
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, DriverEntry)
#pragma alloc_text(PAGE_COM, ATIMPFindAdapter)
#pragma alloc_text(PAGE_COM, ATIMPInitialize)
#pragma alloc_text(PAGE_COM, ATIMPStartIO)
#if (TARGET_BUILD >= 500)
#pragma alloc_text(PAGE_COM, ATIMPSetPower50)
#pragma alloc_text(PAGE_COM, ATIMPGetPower50)
#pragma alloc_text(PAGE_COM, ATIMPGetVideoChildDescriptor)
#endif  // TARGET_BUILD >= 500
#pragma alloc_text(PAGE_COM, RegistryParameterCallback)
#endif


//------------------------------------------------------------------------

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    /*
     * Most recently returned and lowest received so far return values
     * from VideoPortInitialize().
     *
     * BUGBUG: According to the docs and include files, these should
     *         be of type VP_STATUS (maps to long). When tracing
     *         through the code, however, I saw that a failed call
     *         to VideoPortInitialize() due to submitting the wrong
     *         bus type yields a code of 0xC00000C0 while one which
     *         succeeds yields 0x00000000. When following the format
     *         of the NTSTATUS (maps to unsigned long) type, these are
     *         STATUS_DEVICE_DOES_NOT_EXIST and STATUS_SUCCESS respectively.
     *         The docs on VideoPortInitialize() say to return the smallest
     *         returned value if multiple calls are made (consistent with
     *         the NTSTATUS format where the 2 most significant bits are
     *         00 for success, 01 for information, 10 for warning, and
     *         11 for error, since the multiple calls would be for mutually
     *         exclusive bus types), presumably to return the best possible
     *         outcome (fail only if we can't find any supported bus).
     *
     *         If we use the VP_STATUS type as recommended, error conditions
     *         will be seen as smaller than success, since they are negative
     *         numbers (MSB set) and success is positive (MSB clear). Use
     *         unsigned long values to avoid this problem.
     */
    ULONG   ThisInitStatus;
    ULONG   LowestInitStatus;


    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));
    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);
    /*
     * Set entry points.
     */
    hwInitData.HwFindAdapter = ATIMPFindAdapter;
    hwInitData.HwInitialize  = ATIMPInitialize;
    hwInitData.HwInterrupt   = NULL;
    hwInitData.HwStartIO     = ATIMPStartIO;
    hwInitData.HwResetHw     = ATIMPResetHw;

#if (TARGET_BUILD >= 500)

    //
    // Set new entry points added for NT 5.0.
    //

    //
    // We can only enable these for a PnP driver, and this is not
    // a pnp driver.  At least at the moment.
    //

    hwInitData.HwSetPowerState = ATIMPSetPower50;
    hwInitData.HwGetPowerState = ATIMPGetPower50;
    hwInitData.HwGetVideoChildDescriptor = ATIMPGetVideoChildDescriptor;

#endif  // TARGET_BUILD >= 500


    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    /*
     * Call VideoPortInitialize() once for each type of interface we support.
     * As documented in the DDK, return the lowest status value returned
     * by this function.
     *
     * The DEC Alpha requires the new ordering (PCI first) in both
     * 3.5 and 3.51, while the x86 requires the new ordering in 3.51
     * and the old ordering in 3.5. I haven't built a new miniport
     * for either Power PC or MIPS since implementing the new order,
     * so for now assume that they require the old order.
     *
     * On the x86, using the new order in 3.5 will result in the
     * IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES packet failing on
     * the Mach 32 in PCI systems, which leaves 16 and 24 BPP
     * listed as available in the video applet but being rejected
     * when they are tested.
     */
#if !defined(_ALPHA_) && !defined(IOCTL_VIDEO_SHARE_VIDEO_MEMORY)
    hwInitData.AdapterInterfaceType = Eisa;
    LowestInitStatus =  (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);

    hwInitData.AdapterInterfaceType = Isa;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;

    hwInitData.AdapterInterfaceType = MicroChannel;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;

    hwInitData.AdapterInterfaceType = PCIBus;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;
#else
    hwInitData.AdapterInterfaceType = PCIBus;
    LowestInitStatus =  (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);

    hwInitData.AdapterInterfaceType = Eisa;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;

    hwInitData.AdapterInterfaceType = Isa;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;

    hwInitData.AdapterInterfaceType = MicroChannel;
    ThisInitStatus = (ULONG) VideoPortInitialize(Context1, Context2, &hwInitData, NULL);
    if (ThisInitStatus < LowestInitStatus)
        LowestInitStatus = ThisInitStatus;
#endif

    return LowestInitStatus;

}   /* end DriverEntry() */

//------------------------------------------------------------------------

VP_STATUS
ATIMPFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:
    This routine is the main execution entry point for the miniport driver.
    It accepts a Video Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:
    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize().

    ArgumentString - Suuplies a NYLL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver . This structure is initialized with
        any knwon configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates a host adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_INVALID_PARAMETER - Indicates the supplied configuration was invalid.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{
    VP_STATUS status;
    struct query_structure *QueryPtr;   /* Query information for the card */
    phwDeviceExtension = HwDeviceExtension;


    VideoDebugPrint((DEBUG_NORMAL, "ATI: FindAdapter\n"));

    /*
     * On systems with multiple buses (i.e. any PCI/ISA system), this
     * routine will be called once for each bus, and each invocation
     * will detect the ATI card. To keep Windows NT from thinking that
     * there are multiple cards, check to see if we have found an ATI
     * card on a previous invocation, and if we have, report that there
     * is no ATI card.
     */
    if (ConfigInfo->AdapterInterfaceType == PCIBus)
        {

        VIDEO_ACCESS_RANGE AccessRange3C0 = { 0x3C0, 0, 1, 1, 1, 1};

        VideoDebugPrint((DEBUG_NORMAL, "PCI bus\n"));
#if defined(ALPHA) || defined(_ALPHA_)
        /*
         * On the DEC Alpha, our card detection runs into trouble
         * on all but the first (bridged to ISA/EISA, supports
         * VGA BIOS emulation) PCI bus.
         */
        if (ConfigInfo->SystemIoBusNumber > 0)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Alpha, not first PCI bus - skipping\n"));
            return ERROR_DEV_NOT_EXIST;
            }
#endif
        //
        // AndreVa.
        // Since we have a PnP driver, all detection is done throught the
        // inf - no slot searching.
        // Fix code that is lower in DetectMach64 later.
        //
        // For now, just make sure the card is enabled and fail if it's not,
        // so we don't any a different card via the searching mechanism.
        // This only happens if you have a disabled ATI card on the motherboard
        // and an active one in a slot
        //

        if (NO_ERROR != VideoPortVerifyAccessRanges(HwDeviceExtension,
                                                    1,
                                                    &AccessRange3C0))
        {
            VideoDebugPrint((DEBUG_NORMAL, "ATI: PCI FindAdapter called for Disabled card\n"));
            *Again = 0;     /* We don't want to be called again */
            return ERROR_DEV_NOT_EXIST;
        }

        }
    else if (ConfigInfo->AdapterInterfaceType == Isa)
        {
        VideoDebugPrint((DEBUG_NORMAL, "ISA bus\n"));
        }
    else if (ConfigInfo->AdapterInterfaceType == Eisa)
        {
        VideoDebugPrint((DEBUG_NORMAL, "EISA bus\n"));
        }
    else if (ConfigInfo->AdapterInterfaceType == MicroChannel)
        {
        VideoDebugPrint((DEBUG_NORMAL, "MicroChannel bus\n"));
        }

    if ((FoundNonBlockCard == TRUE) || (NumBlockCardsFound == ATI_MAX_BLOCK_CARDS))
        {
        VideoDebugPrint((DEBUG_NORMAL, "ATI: FindAdapter already found maximum number of supported cards\n"));
        *Again = 0;     /* We don't want to be called again */
        return ERROR_DEV_NOT_EXIST;
        }

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * Save the bus type reported by NT
     */
    QueryPtr->q_system_bus_type = ConfigInfo->AdapterInterfaceType;


    /*
     * Initially we don't know whether or not block write mode is available.
     */
    QueryPtr->q_BlockWrite = BLOCK_WRITE_UNKNOWN;

    /*
     * Make sure the size of the structure is at least as large as what we
     * are expecting (check version of the config info structure).
     * If this test fails, it's an unrecoverable error, so we don't want
     * to be called again.
     */
    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO))
        {
        VideoPortLogError(HwDeviceExtension, NULL, VID_SMALL_BUFFER, 1);
        *Again = 0;
        return ERROR_INVALID_PARAMETER;
        }

    /********************************************************************/
    /* Find out which of our accelerators, if any, is present.          */
    /********************************************************************/


    /*
     * Look for an ATI accelerator card. This test does not require
     * information retrieved from the BIOS or the EEPROM (which may not
     * be present in some versions of our cards).
     *
     * Initially assume that we are looking for a Mach 64 accelerator,
     * since the test for this family is less destructive (doesn't
     * black out the screen on DEC Alpha machines) than the test for
     * one of our 8514/A-compatible accelerators.
     *
     * Don't report failure if we are unable to map the I/O ranges
     * used by the Mach 64 accelerators, since if we are dealing with
     * one of our 8514/A-compatible accelerators this is irrelevant.
     *
     * CompatIORangesUsable_cx() calls DetectMach64() when it's checking
     * to see which base address to use for the accelerator registers,
     * so if this calll succeeds we know that a Mach 64 is present.
     * If the call fails, there is no need to unmap the I/O ranges
     * it has mapped, since it always cleans up after itself when it
     * finds that a particular base address is not being used for a
     * Mach 64. As a result, a failed call will not leave any addresses
     * mapped, since no available base address was used by a Mach 64.
     */
    if ((status = CompatIORangesUsable_cx(ConfigInfo->AdapterInterfaceType)) == NO_ERROR)
        {
        phwDeviceExtension->ModelNumber = MACH64_ULTRA;
        }
    else if (NumBlockCardsFound == 0)
        {
        /*
         * There is no Mach 64 present, so look for one of our
         * 8514/A-compatible accelerators (Mach 8 and Mach 32).
         * The check on NumBlockCardsFound is to catch the case
         * where we found a relocatable card on a previous bus
         * type, so we won't have dropped out due to FoundNonBlockCard
         * being TRUE but CompatIORangesUsable_cx() won't find
         * a Mach 64 on this bus type.
         */

        /*
         * Since we don't use PCI detection, don't look for these cards
         * on the PCI bus, except for the Mach 32 PCI AX
         */
        if (ConfigInfo->AdapterInterfaceType == PCIBus)
        {
            PCI_COMMON_CONFIG ConfigData;
            ULONG RetVal;

            RetVal = VideoPortGetBusData(phwDeviceExtension,
                                        PCIConfiguration,
                                        0,
                                        &ConfigData,
                                        0,
                                        PCI_COMMON_HDR_LENGTH);

            /*
             * If we received an error return, skip to the
             * next possible slot.
             */
            if ((RetVal == PCI_COMMON_HDR_LENGTH) &&
                (ConfigData.VendorID == 0x1002)   &&
                (ConfigData.DeviceID == 0x4158))
            {
                VideoDebugPrint((DEBUG_NORMAL, "FOUND PnP Mach 32 AX card found\n"));
            }
            else
            {
                *Again = 0;
                return ERROR_DEV_NOT_EXIST;
            }
        }

        /* If we can't map the I/O base addresses used by these cards,
         * then there is no ATI accelerator present. Unmap any of
         * the ranges which may have been mapped, then report failure.
         *
         * In the event of failure to find a Mach 8 or Mach 32,
         * report that we don't want to be called again for the
         * current bus, but don't set LookForAnotherCard to zero.
         * This is because there may still be a block relocatable
         * card on a subsequent bus.
         */
        status = CompatIORangesUsable_m();
        if (status != NO_ERROR)
            {
            UnmapIORanges_m();
            VideoPortLogError(HwDeviceExtension, NULL, VID_CANT_MAP, 2);
            *Again = 0;
            return status;
            }

#if !defined (i386) && !defined (_i386_)
        /*
         *  ALPHA - The miniport will have to perform the ROM Bios functions
         * that are normally done on bootup in x86 machines.
         * For now we will initialize them the way they are specifically
         * on this card that we are currently using.
         */
        AlphaInit_m();

#endif

        /*
         * Check which of our 8514/A-accelerators is present. If we
         * can't find one, unmap the I/O ranges and report failure.
         *
         * Don't log an error, because NT tries all the miniports
         * on initial setup to see which card is installed, and failure
         * to find an ATI card is a normal condition if another brand
         * of accelerator is present.
         *
         */
        phwDeviceExtension->ModelNumber = WhichATIAccelerator_m();
        if (phwDeviceExtension->ModelNumber == NO_ATI_ACCEL)
            {
            UnmapIORanges_m();
            *Again = 0;
            return ERROR_DEV_NOT_EXIST;
            }

        /*
         * We have found a Mach 8 or Mach 32. None of these cards are
         * block relocatable, so we must not look for another card
         * (since we don't support a mix of block and non-block
         * cards).
         */
        FoundNonBlockCard = TRUE;
        LookForAnotherCard = 0;

        }   /* endif (no Mach 64) */
    else
        {
        /*
         * A relocatable Mach 64 was found on a previous bus type.
         * Since we can't handle a mix of relocatable and fixed
         * base cards, we have skipped the Mach 32 search (the
         * Mach 64 search doesn't look for fixed base cards if
         * a relocatable card has already been found), and must
         * report that no ATI cards were found.
         */
        *Again = 0;
        VideoDebugPrint((DEBUG_DETAIL, "Skipping 8514/A-compatible test because block cards found\n"));
        return ERROR_DEV_NOT_EXIST;
        }

    /*
     * We have found one of our accelerators, so check for the
     * BIOS signature string.
     */
    QueryPtr->q_bios = (char *) Get_BIOS_Seg();

    /*
     * If we can't find the signature string, we can't access either
     * the EEPROM (if present) or the extended BIOS functions. Since
     * the special handling functions (extended Mach 32 aperture calculation
     * and Mach 8 ignore 1280x1024) depend on BIOS data, assume that
     * they don't apply.
     *
     * If we found the signature string, check whether the EEPROM
     * and extended BIOS functions are available.
     */

#if !defined (i386) && !defined (_i386_)
    /*
     * If we are using a Mach 64, we always use the extended BIOS
     * functions (either emulated x86 in the firmware, or an approximation
     * of the BIOS functions accessed through the same interface as
     * the BIOS functions would use). For this reason, we must have
     * the BIOS as non-FALSE. Since all searches that depend on the
     * q_bios field being a valid address are Mach 8/32 specific,
     * we can just set it to TRUE for Mach 64. For Mach 8 and 32,
     * still assume that we don't have a BIOS.
     */
    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Non-x86 machine with Mach64, assuming BIOS is available\n"));
        QueryPtr->q_bios = (PUCHAR)TRUE;
        }
    else
        {
        VideoDebugPrint((DEBUG_NORMAL, "Non-x86 machine with Mach8/Mach32, forcing no-BIOS handling\n"));
        QueryPtr->q_bios = FALSE;
        }
#endif

    if (QueryPtr->q_bios == FALSE)
        {
        QueryPtr->q_eeprom = FALSE;
        QueryPtr->q_ext_bios_fcn = FALSE;
        QueryPtr->q_m32_aper_calc = FALSE;
        QueryPtr->q_ignore1280 = FALSE;
        }
    else{
        /*
         * Get additional data required by the graphics card being used.
         */
        if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
            (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
            (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
            {
            GetExtraData_m();
            }

        else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
            {
            /*
             * Mach 64 cards always have extended BIOS functions
             * available. The EEPROM (normally present) is irrelevant,
             * since we can query the card's status using the BIOS.
             */
            QueryPtr->q_ext_bios_fcn = TRUE;
            }


        }   /* BIOS signature string found */

    /*
     * We must map the VGA aperture (graphics, colour text, and mono
     * text) into the VDM's address space to use VideoPortInt10()
     * (function is only available on 80x86).
     */
#ifdef i386
    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;
#else
    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00000000;
#endif

    /*
     * If we get this far, we have enough information to be able to set
     * the video mode we want. ATI accelerator cards need the
     * Emulator entries and state size cleared
     */
    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    ConfigInfo->HardwareStateSize = 0;

    /*
     * Setting *Again to 0 tells Windows NT not to call us again for
     * the same bus, while setting it to 1 indicates that we want to
     * look for another card on the current bus. LookForAnotherCard
     * will have been set to 0 if we have found the maximum number
     * of block-relocatable cards or a single non-relocatable card.
     */
    *Again = LookForAnotherCard;

    /*
     * Since ATIMPFindAdapter() is called before ATIMPInitialize(),
     * this card has not yet had ATIMPInitialize() called.
     */
    phwDeviceExtension->CardInitialized = FALSE;

    return NO_ERROR;

}   /* end ATIMPFindAdapter() */

//------------------------------------------------------------------------

/***************************************************************************
 *
 * BOOLEAN ATIMPInitialize(HwDeviceExtension);
 *
 * PVOID HwDeviceExtension;     Pointer to the miniport's device extension.
 *
 * DESCRIPTION:
 *  Query the capabilities of the graphics card, then initialize it. This
 *  routine is called once an adapter has been found and all the required
 *  data structures for it have been created.
 *
 *  We can't query the capabilities of the card in ATIMPFindAdapter()
 *  because some families of card use VideoPortInt10() in the query
 *  routine, and this system service will fail if called in ATIMPFindAdapter().
 *
 * RETURN VALUE:
 *  TRUE if we are able to obtain the query information for the card
 *  FALSE if we can't query the card's capabilities.
 *
 * GLOBALS CHANGED:
 *  phwDeviceExtension  This global variable is set in every entry point routine.
 *
 * CALLED BY:
 *  This is one of the entry point routines for Windows NT.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOLEAN ATIMPInitialize(PVOID HwDeviceExtension)
{
    struct st_mode_table *CrtTable;     /* Pointer to current mode */
    struct query_structure *QueryPtr;   /* Query information for the card */
    VP_STATUS QueryStatus;
    phwDeviceExtension = HwDeviceExtension;

    /*
     * We only need to keep track of which I/O base address is involved
     * in multi-headed setups. In some single-headed setups, the
     * additional data is not available.
     */
    if (NumBlockCardsFound >= 2)
        VideoDebugPrint((DEBUG_NORMAL, "\nATIMPInitialize() called for base address 0x%X\n\n", phwDeviceExtension->BaseIOAddress));
    else
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPInitialize: start\n"));

    /*
     * This function should only be called once for any card. Since
     * we have no way of knowing whether or not the display driver
     * will make multiple calls to the IOCTL_VIDEO_ATI_INIT_AUX_CARD
     * packet, we must ensure that only the first call for any card
     * actually does anything.
     */
    if (phwDeviceExtension->CardInitialized != FALSE)
        {
        VideoDebugPrint((DEBUG_ERROR, "This card already initialized, no further action needed\n"));
        return TRUE;
        }
    phwDeviceExtension->CardInitialized = TRUE;

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension,
     * and another pointer to the first mode table. The CardInfo[] field
     * is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;

    /*
     * Indicate that the next IOCTL_VIDEO_SET_CURRENT_MODE call
     * is the first. On the first call, video memory is cleared.
     * On subsequent calls, the palette is re-initialized but
     * video memory is not cleared.
     */
    phwDeviceExtension->ReInitializing = FALSE;

    /*
     * ASSERT: We are dealing with an ATI accelerator card
     * whose model is known, and we know whether or not
     * any special handling is needed for the card.
     *
     * Fill in the query structure for the card, using a method
     * appropriate to the card type.
     */
    switch(phwDeviceExtension->ModelNumber)
        {
        case _8514_ULTRA:
            VideoDebugPrint((DEBUG_NORMAL, "8514/ULTRA found\n"));
            QueryStatus = Query8514Ultra(QueryPtr);
            break;

        case GRAPHICS_ULTRA:
            VideoDebugPrint((DEBUG_NORMAL, "Mach 8 combo found\n"));
            QueryStatus = QueryGUltra(QueryPtr);
            break;

        case MACH32_ULTRA:
            VideoDebugPrint((DEBUG_NORMAL, "Mach 32 found\n"));
            QueryStatus = QueryMach32(QueryPtr, TRUE);
            if (QueryStatus == ERROR_INSUFFICIENT_BUFFER)
                {
                VideoPortLogError(HwDeviceExtension, NULL, VID_SMALL_BUFFER, 3);
                return FALSE;
                }
            break;

        case MACH64_ULTRA:
            VideoDebugPrint((DEBUG_NORMAL, "Mach 64 found\n"));
            QueryStatus = QueryMach64(QueryPtr);
            if (QueryStatus == ERROR_INSUFFICIENT_BUFFER)
                {
                VideoDebugPrint((DEBUG_ERROR, "QueryMach64() failed due to small buffer\n"));
                VideoPortLogError(HwDeviceExtension, NULL, VID_SMALL_BUFFER, 4);
                return FALSE;
                }
            else if (QueryStatus != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_ERROR, "QueryMach64() failed due to unknown cause\n"));
                VideoPortLogError(HwDeviceExtension, NULL, VID_QUERY_FAIL, 5);
                return FALSE;
                }
            break;
        }

    /*
     * If we have access to the extended BIOS functions, we can
     * use them to switch into the desired video mode. If we don't
     * have access to these functions, but were able to read
     * the EEPROM, we can switch into the desired mode by writing
     * CRT parameters directly to the accelerator registers.
     *
     * If we don't have access to the extended BIOS functions, and
     * we couldn't find an EEPROM, attempt to retrieve the CRT
     * parameters based on the contents of the ATIOEM field in
     * the registry. If we can't do this, then we don't have enough
     * information to be able to set the video mode we want.
     */
    if (!QueryPtr->q_ext_bios_fcn && !QueryPtr->q_eeprom)
        {
        QueryStatus = OEMGetParms(QueryPtr);
        if (QueryStatus != NO_ERROR)
            {
		    return FALSE;
            }
        }

    phwDeviceExtension->VideoRamSize = QueryPtr->q_memory_size * QUARTER_MEG;

    //  Subtract the amount of memory reserved for the VGA.
    phwDeviceExtension->VideoRamSize -= (QueryPtr->q_VGA_boundary * QUARTER_MEG);

    phwDeviceExtension->PhysicalFrameAddress.HighPart = 0;
    phwDeviceExtension->PhysicalFrameAddress.LowPart  = QueryPtr->q_aperture_addr*ONE_MEG;

    /*
     * If the linear aperture is available, the frame buffer size
     * is equal to the amount of accelerator-accessible video memory.
     */
    if (QueryPtr->q_aperture_cfg)
        {
        phwDeviceExtension->FrameLength = phwDeviceExtension->VideoRamSize;
        VideoDebugPrint((DEBUG_DETAIL, "LFB size = 0x%X bytes\n", phwDeviceExtension->FrameLength));
        }

    /*
     * Call the hardware-specific initialization routine for the
     * card we are using.
     */
    if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
        (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
        (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
        {
        /*
         * If the LFB is not usable, set up the LFB configuration
         * variables to show that there is no linear frame buffer.
         * The decision as to whether to use the 64k VGA aperture
         * or go with the graphics engine only is made in the
         * IOCTL_VIDEO_MAP_VIDEO_MEMORY packet.
         */
        if (QueryPtr->q_aperture_cfg)
            {
            if (IsApertureConflict_m(QueryPtr))
                {
                VideoPortLogError(HwDeviceExtension, NULL, VID_LFB_CONFLICT, 7);
                QueryPtr->q_aperture_cfg        = 0;
                phwDeviceExtension->FrameLength = 0;
                }
            else
                {
                /*
                 * On Mach 32 cards that can use memory mapped registers,
                 * map them in. We already know that we are dealing with
                 * a Mach 32, since this is the only card in the family
                 * of 8514/A-compatible ATI accelerators that can use
                 * a linear framebuffer.
                 */
                if ((QueryPtr->q_asic_rev == CI_68800_6) || (QueryPtr->q_asic_rev == CI_68800_AX))
                    {
                    CompatMMRangesUsable_m();
                    }
                }
            }
        /*
         * On Mach 32 cards with the aperture disabled (either as configured
         * or because a conflict was detected), try to claim the VGA aperture.
         * If we can't (unlikely), report failure, since some of our Mach 32
         * chips run into trouble in engine-only (neither linear nor paged
         * aperture available) mode.
         */
        if ((phwDeviceExtension->ModelNumber == MACH32_ULTRA) &&
            (QueryPtr->q_aperture_cfg == 0) &&
            (QueryPtr->q_VGA_type == 1))
            {
            if (IsVGAConflict_m())
                return FALSE;
            }

        Initialize_m();

        /*
         * This routine must leave the card in a state where an INT 10
         * can set it to a VGA mode. Only the Mach 8 and Mach 32 need
         * a special setup (the Mach 64 can always be set into VGA mode
         * by an INT 10).
         */
        ResetDevice_m();
        }
    else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        {
        /*
         * If the LFB is not usable, set up the LFB configuration
         * variables to show that there is no linear frame buffer.
         */
        if (QueryPtr->q_aperture_cfg)
            {
            if (IsApertureConflict_cx(QueryPtr))
                {
                VideoDebugPrint((DEBUG_NORMAL, "Found LFB conflict, must use VGA aperture instead\n"));
                VideoPortLogError(HwDeviceExtension, NULL, VID_LFB_CONFLICT, 8);
                QueryPtr->q_aperture_cfg        = 0;
                phwDeviceExtension->FrameLength = 0;
                }
            }
        else
            {
            phwDeviceExtension->FrameLength = 0;
            }

        /*
         * Mach 64 drawing registers only exist in memory mapped form.
         * If the linear aperture is not available, they will be
         * available through the VGA aperture (unlike Mach 32,
         * where memory mapped registers are only in the linear
         * aperture). If memory mapped registers are unavailable,
         * we can't run.
         */
        QueryStatus = CompatMMRangesUsable_cx();
        if (QueryStatus != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "Can't use memory-mapped registers, aborting\n"));
            VideoPortLogError(HwDeviceExtension, NULL, VID_CANT_MAP, 9);
            return FALSE;
            }
        Initialize_cx();

        }   /* end if (Mach 64) */

    /*
     * Initialize the monitor parameters.
     */
    phwDeviceExtension->ModeIndex = 0;

    /*
     * Set CrtTable to point to the mode table associated with the
     * selected mode.
     *
     * When a pointer to a structure is incremented by an integer,
     * the integer represents the number of structure-sized blocks
     * to skip over, not the number of bytes to skip over.
     */
    CrtTable += phwDeviceExtension->ModeIndex;
    QueryPtr->q_desire_x  = CrtTable->m_x_size;
    QueryPtr->q_desire_y  = CrtTable->m_y_size;
    QueryPtr->q_pix_depth = CrtTable->m_pixel_depth;


#if (TARGET_BUILD >= 350)
    /*
     * In Windows NT 3.5 and higher, fill in regsistry fields used
     * by the display applet to report card specifics to the user.
     */
    FillInRegistry(QueryPtr);
#endif

    VideoDebugPrint((DEBUG_NORMAL, "End of ATIMPInitialize()\n"));

    return TRUE;

}   /* end ATIMPInitialize() */

//------------------------------------------------------------------------

BOOLEAN
ATIMPStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:


--*/

{
    VP_STATUS status;
    PVIDEO_NUM_MODES NumModes;
    PVERSION_NT VersionInformation;
    PENH_VERSION_NT EnhVersionInformation;
    PATI_MODE_INFO ATIModeInformation;
    PVIDEO_CLUT clutBuffer;
    PVIDEO_MEMORY MappedMemory;

    UCHAR ModesLookedAt;    /* Number of mode tables we have already examined */
    short LastXRes;         /* X-resolution of last mode table examined */
    short ResolutionsDone;  /* Number of resolutions we have finished with */
    ULONG ulScratch;        /* Temporary variable */

    int i;
    ULONG *pSrc;

    struct query_structure *QueryPtr;   /* Query information for the card */
    struct st_mode_table *FirstMode;    /* Pointer to first mode table */
    struct st_mode_table *CrtTable;     /* Pointer to current mode */

    phwDeviceExtension = HwDeviceExtension;

    /*
     * We only need to keep track of which I/O base address is involved
     * in multi-headed setups. In some single-headed setups, the
     * additional data is not available.
     */
    if (NumBlockCardsFound >= 2)
        VideoDebugPrint((DEBUG_NORMAL, "\nATIMPStartIO() called for base address 0x%X\n\n", phwDeviceExtension->BaseIOAddress));

    // * Get a formatted pointer into the query section of HwDeviceExtension.
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);


    //
    // Switch on the IoControlCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //
    switch (RequestPacket->IoControlCode)
        {
        case IOCTL_VIDEO_MAP_VIDEO_MEMORY:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - MapVideoMemory\n"));

            if ( (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_MEMORY_INFORMATION))) ||
                (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            /*
             * Map the video memory in the manner appropriate to the
             * card we are using.
             */
            if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                {
                status = MapVideoMemory_m(RequestPacket, QueryPtr);
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                status = MapVideoMemory_cx(RequestPacket, QueryPtr);
                }
            else	//	handling a case which should never
            {		//	happen: unknown ModelNumber
                VideoDebugPrint((DEBUG_ERROR, "ati.sys ATIMPStartIO: Unknown ModelNumber\n"));
                ASSERT(FALSE);
                status = ERROR_INVALID_PARAMETER;
            }

            break;

        case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - UnMapVideoMemory\n"));

            if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            //
            // Note that in MapVideoMemory_m, the VP routine VideoMapMemory
            // is not called, so don't try to call unmap here!
            //

            if ((QueryPtr->q_aperture_cfg == 0) &&
                !((phwDeviceExtension->ModelNumber == MACH32_ULTRA) &&
                  (QueryPtr->q_VGA_type == 1)))
                status = NO_ERROR;
            else
            {
                status = NO_ERROR;
                if ( ((PVIDEO_MEMORY)(RequestPacket->InputBuffer))->RequestedVirtualAddress != NULL )
                {
                    status = VideoPortUnmapMemory(phwDeviceExtension,
                        ((PVIDEO_MEMORY) (RequestPacket->InputBuffer))->RequestedVirtualAddress,  0);
                }
            }
            break;


        case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - QueryPublicAccessRanges\n"));

            // HACKHACK - This is a temporary hack for ALPHA until we really
            // decide how to do this.

            if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                {
                status = QueryPublicAccessRanges_m(RequestPacket);
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                status = QueryPublicAccessRanges_cx(RequestPacket);
                }
            break;


        case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - FreePublicAccessRanges\n"));

            if (RequestPacket->InputBufferLength < 2 * sizeof(VIDEO_MEMORY))
                {
                VideoDebugPrint((DEBUG_ERROR, "Received length %d, need length %d\n", RequestPacket->InputBufferLength, sizeof(VIDEO_PUBLIC_ACCESS_RANGES)));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            status = NO_ERROR;
            MappedMemory = RequestPacket->InputBuffer;

            if (MappedMemory->RequestedVirtualAddress != NULL)
                {
#if (TARGET_BUILD >= 400)
                /*
                 * This packet will be called as part of the cleanup
                 * for the test of a new graphics mode. The packet
                 * IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES will have
                 * generated the same virtual address for the test
                 * screen as was generated for the main Windows session.
                 *
                 * In NT 3.51 (and presumably earlier versions), the
                 * call to VideoPortUnmapMemory() will refuse to release
                 * the mapping, while in NT 4.0 (and presumably subsequent
                 * versions) it will release the mapping. This is probably
                 * due to the routine being able to distinguish between
                 * the test and permanent screens in 4.0, but not being
                 * able to disginguish between them (and therefore refusing
                 * to free resources which it thinks are currently in use
                 * by the permanent screen) in 3.51.
                 *
                 * Freeing resources will be necessary if "on-the-fly"
                 * mode switching is added to Windows NT, but this will
                 * almost certainly not be added to 3.51 (if it is added,
                 * it would be to the then-current version). Since we
                 * don't really need to free the mapped I/O ranges under
                 * 3.51 (under the old display driver source stream, this
                 * packet didn't get called), let 3.51 and earlier think
                 * that the resources were freed successfully to avoid
                 * generating an error condition, and only attempt to
                 * unmap the I/O registers under NT 4.0 and later.
                 */
                status = VideoPortUnmapMemory(phwDeviceExtension,
                                            MappedMemory->RequestedVirtualAddress,
                                            0);
#endif
                VideoDebugPrint((DEBUG_DETAIL, "VideoPortUnmapMemory() returned 0x%X\n", status));
                }
            else
                {
                VideoDebugPrint((DEBUG_DETAIL, "Address was NULL, no need to unmap\n"));
                }

            /*
             * We have just unmapped the I/O mapped registers. Since our
             * memory-mapped registers are contained in the block which
             * is mapped by IOCTL_VIDEO_MAP_VIDEO_MEMORY, they will have
             * already been freed by IOCTL_VIDEO_UNMAP_VIDEO_MEMORY, so
             * there is no need to free them here.
             */
            break;

        case IOCTL_VIDEO_QUERY_CURRENT_MODE:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - QueryCurrentModes\n"));

            if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                {
                status = QueryCurrentMode_m(RequestPacket, QueryPtr);
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                status = QueryCurrentMode_cx(RequestPacket, QueryPtr);
                }
            break;

        case IOCTL_VIDEO_QUERY_AVAIL_MODES:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - QueryAvailableModes\n"));

            if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                {
                status = QueryAvailModes_m(RequestPacket, QueryPtr);
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                status = QueryAvailModes_cx(RequestPacket, QueryPtr);
                }
            break;


        case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - QueryNumAvailableModes\n"));

            /*
             * Find out the size of the data to be put in the buffer and
             * return that in the status information
             */
            if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = sizeof(VIDEO_NUM_MODES)) )
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                }
            else{
                NumModes = (PVIDEO_NUM_MODES)RequestPacket->OutputBuffer;
                NumModes->NumModes = QueryPtr->q_number_modes;
                NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);
                status = NO_ERROR;
                }
            break;

        case IOCTL_VIDEO_SET_CURRENT_MODE:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SetCurrentMode\n"));

            /*
             * Verify that the mode we've been asked to set is less
             * than or equal to the highest mode number for which we
             * have a mode table (mode number is zero-based, so highest
             * mode number is 1 less than number of modes).
             */
            if (((PVIDEO_MODE)(RequestPacket->InputBuffer))->RequestedMode
    	        >= QueryPtr->q_number_modes)
                {
                status = ERROR_INVALID_PARAMETER;
                break;
                }

            phwDeviceExtension->ModeIndex = *(ULONG *)(RequestPacket->InputBuffer);

            CrtTable = (struct st_mode_table *)QueryPtr;
            ((struct query_structure *)CrtTable)++;

            CrtTable += phwDeviceExtension->ModeIndex;

            // * Set resolution and pixel depth of new current mode.
            QueryPtr->q_desire_x = CrtTable->m_x_size;
            QueryPtr->q_desire_y = CrtTable->m_y_size;
            QueryPtr->q_pix_depth = CrtTable->m_pixel_depth;
            QueryPtr->q_screen_pitch = CrtTable->m_screen_pitch;

            /*
             * If we are using the extended BIOS functions to switch modes,
             * do it now. The Mach 32 uses the extended BIOS functions to
             * read in the CRT parameters for a direct-register mode switch,
             * rather than using a BIOS mode switch.
             */
            if ((QueryPtr->q_ext_bios_fcn) && (phwDeviceExtension->ModelNumber != MACH32_ULTRA))
                {
                /*
                 * Do the mode switch through the BIOS.
                 */
                if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                    {
                    status = SetCurrentMode_cx(QueryPtr, CrtTable);
                    }
                }
            else{
                if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                    (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                    (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                    {
                    SetCurrentMode_m(QueryPtr, CrtTable);
                    status = NO_ERROR;
                    }
                }   /* end if (not using BIOS call for mode switch) */

            break;


        case IOCTL_VIDEO_SET_PALETTE_REGISTERS:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SetPaletteRegs\n"));
            status = NO_ERROR;
            break;

        case IOCTL_VIDEO_SET_COLOR_REGISTERS:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SetColorRegs\n"));

            CrtTable = (struct st_mode_table *)QueryPtr;
	        ((struct query_structure *)CrtTable)++;

        	clutBuffer = RequestPacket->InputBuffer;
        	phwDeviceExtension->ReInitializing = TRUE;

            /*
             * Check if the size of the data in the input
             * buffer is large enough.
             */
            if ( (RequestPacket->InputBufferLength < sizeof(VIDEO_CLUT) - sizeof(ULONG))
                || (RequestPacket->InputBufferLength < sizeof(VIDEO_CLUT) +
                    (sizeof(ULONG) * (clutBuffer->NumEntries - 1)) ) )
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            CrtTable += phwDeviceExtension->ModeIndex;
        	if (CrtTable->m_pixel_depth <= 8)
                {
                if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
                    (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA) ||
                    (phwDeviceExtension->ModelNumber == MACH32_ULTRA))
                    {
                    SetPalette_m((PULONG)clutBuffer->LookupTable,
                                 clutBuffer->FirstEntry,
                                 clutBuffer->NumEntries);
                    }
                else if(phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                    {
                    SetPalette_cx((PULONG)clutBuffer->LookupTable,
                                  clutBuffer->FirstEntry,
                                  clutBuffer->NumEntries);
                    }
                status = NO_ERROR;
                }

            /*
             * Remember the most recent palette we were given so we
             * can re-initialize it in subsequent calls to the
             * IOCTL_VIDEO_SET_CURRENT_MODE packet.
             */
        	phwDeviceExtension->FirstEntry = clutBuffer->FirstEntry;
        	phwDeviceExtension->NumEntries = clutBuffer->NumEntries;

        	pSrc = (ULONG *) clutBuffer->LookupTable;

            for (i = clutBuffer->FirstEntry; i < (int) clutBuffer->NumEntries; i++)
	            {
                /*
                 * Save palette colours.
                 */
        	    phwDeviceExtension->Clut[i] = *pSrc;
                pSrc++;
        	    }

            break;




    case IOCTL_VIDEO_RESET_DEVICE:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - RESET_DEVICE\n"));

        /*
         * If we are using the extended BIOS functions to switch modes,
         * do it now. The Mach 32 uses the extended BIOS functions to
         * read in the CRT parameters for a direct-register mode switch,
         * rather than using a BIOS mode switch.
         */
        if ((QueryPtr->q_ext_bios_fcn) && (phwDeviceExtension->ModelNumber != MACH32_ULTRA))
            {
            /*
             * Do the mode switch through the BIOS (hook not yet present
             * in Windows NT).
             */
            if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                ResetDevice_cx();
                }
            }
        else{
            ResetDevice_m();
            }

        status = NO_ERROR;
        break;


    case IOCTL_VIDEO_SET_POWER_MANAGEMENT:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SET_POWER_MANAGEMENT\n"));

        /*
         * If the VIDEO_POWER_MANAGEMENT structure is the wrong size
         * (miniport and display driver using different versions),
         * report the error.
         */
        if (((PVIDEO_POWER_MANAGEMENT)(RequestPacket->InputBuffer))->Length
            != sizeof(struct _VIDEO_POWER_MANAGEMENT))
            {
            status = ERROR_INVALID_PARAMETER;
            break;
            }

        ulScratch = ((PVIDEO_POWER_MANAGEMENT)(RequestPacket->InputBuffer))->PowerState;

        switch (ulScratch)
            {
            case VideoPowerOn:
                VideoDebugPrint((DEBUG_DETAIL, "DPMS ON selected\n"));
                break;

            case VideoPowerStandBy:
                VideoDebugPrint((DEBUG_DETAIL, "DPMS STAND-BY selected\n"));
                break;

            case VideoPowerSuspend:
                VideoDebugPrint((DEBUG_DETAIL, "DPMS SUSPEND selected\n"));
                break;

            case VideoPowerOff:
                VideoDebugPrint((DEBUG_DETAIL, "DPMS OFF selected\n"));
                break;

            default:
                VideoDebugPrint((DEBUG_ERROR, "DPMS invalid state selected\n"));
                break;
            }

        /*
         * Different card families need different routines to set
         * the power management state.
         */
        if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
            status = SetPowerManagement_cx(ulScratch);
        else
            status = SetPowerManagement_m(QueryPtr, ulScratch);
        break;


    /*
     * Packets used in DCI support. They were added some time after
     * the initial release of Windows NT 3.5, so not all versions of
     * the DDK will support them. Make the packet code conditional on
     * our building a driver for NT version 3.51 or later in order to
     * avoid the need for a SOURCES flag to identify DCI vs. non-DCI builds.
     */
#if (TARGET_BUILD >= 351)
    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - SHARE_VIDEO_MEMORY\n"));

        if ((RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
            (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)))
            {
            VideoDebugPrint((DEBUG_ERROR, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        /*
         * Share the video memory in the manner appropriate to the
         * card we are using. We can only share memory if the
         * card supports an aperture - Mach 8 cards never support
         * an aperture, so if we are working with one, we know
         * that we can't share the memory. The card-specific
         * routines will identify no-aperture and other cases
         * where we can't share video memory on Mach 32 and
         * Mach 64 cards.
         */
        if ((phwDeviceExtension->ModelNumber == _8514_ULTRA) ||
            (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA))
            {
            VideoDebugPrint((DEBUG_ERROR, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - Mach 8 can't share memory\n"));
            status = ERROR_INVALID_FUNCTION;
            }
        else if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
            {
            status = ShareVideoMemory_m(RequestPacket, QueryPtr);
            }
        else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
            {
            status = ShareVideoMemory_cx(RequestPacket, QueryPtr);
            }

        break;


    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - UNSHARE_VIDEO_MEMORY\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        status = VideoPortUnmapMemory(phwDeviceExtension,
                                    ((PVIDEO_SHARE_MEMORY)(RequestPacket->InputBuffer))->RequestedVirtualAddress,
                                    ((PVIDEO_SHARE_MEMORY)(RequestPacket->InputBuffer))->ProcessHandle);

        break;
#endif  /* TARGET_BUILD >= 350 */


    // ------ * ATI-specific packets start here.  -------------
    /*
     * Get the version number of the miniport, and the
     * resolutions supported (including maximum colour
     * depth).
     */
    case IOCTL_VIDEO_ATI_GET_VERSION:
        VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - ATIGetVersion\n"));

        /*
         * Two versions of this packet exist, depending on which display
         * driver is used. Display drivers which use the old version do
         * not send information to the miniport, so the input buffer is
         * null. Drivers which use the new version pass a non-null input
         * buffer.
         */
        if (RequestPacket->InputBufferLength == 0)
            {
            /*
             * Old packet.
             */
            if (RequestPacket->OutputBufferLength < sizeof(VERSION_NT))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            RequestPacket->StatusBlock->Information = sizeof(VERSION_NT);

            FirstMode = (struct st_mode_table *)QueryPtr;
            ((struct query_structure *)FirstMode)++;

            VersionInformation = RequestPacket->OutputBuffer;
            VersionInformation->miniport =
                (MINIPORT_BUILD << 16) | (MINIPORT_VERSION_MAJOR << 8) | MINIPORT_VERSION_MINOR;

            /*
             * Get the capabilities of the video card. The capcard field
             * holds the following information:
             *
             * Bits 0-3     Bus type (defined values from AMACH.H)
             * Bits 4-7     Product identifier (defined values from AMACH.H)
             * Bit  8       No aperture is available
             * Bit  9       64k VGA aperture is available
             * Bit  10      Linear aperture is available
             *
             * NOTE: Bits 9 and 10 are NOT mutually exclusive.
             */
            VersionInformation->capcard = QueryPtr->q_bus_type;
            VersionInformation->capcard |= (phwDeviceExtension->ModelNumber) << 4;

            if (QueryPtr->q_aperture_cfg)
                VersionInformation->capcard |= ATIC_APERTURE_LFB;

            /*
             * 64k VGA aperture is available on the VGAWonder, and on
             * accelerator cards with the VGA enabled and the VGA boundary
             * set to shared memory.
             */
            if ((phwDeviceExtension->ModelNumber == WONDER) ||
                ((QueryPtr->q_VGA_type) && !(QueryPtr->q_VGA_boundary)))
                VersionInformation->capcard |= ATIC_APERTURE_VGA;

            /*
             * If neither aperture is available, set the "no aperture" bit.
             */
            if (!(VersionInformation->capcard & ATIC_APERTURE_LFB) &&
                !(VersionInformation->capcard & ATIC_APERTURE_VGA))
                VersionInformation->capcard |= ATIC_APERTURE_NONE;

            // Get the available resolutions and maximum colour depth for
            // each. init to a value which does not correspond to any
            // resolution.
            CrtTable = FirstMode;
            LastXRes = -1;
            ResolutionsDone = -1;
            for (ModesLookedAt = 0; ModesLookedAt < QueryPtr->q_number_modes; ModesLookedAt++)
                {
                // do we have a new resolution?
                if (LastXRes != CrtTable->m_x_size)
                    {
                    ResolutionsDone++;
                    LastXRes = CrtTable->m_x_size;
                    VersionInformation->resolution[ResolutionsDone].color = 0;
                    }

                /*
                 * Write the desired information from the current mode table
                 * in the query structure into the current mode table in
                 * the OUTPut buffer.
                 * Leave the OUTPut buffer with the highest colour depth in
                 * each supported resolution.
                 */
                if (CrtTable->m_pixel_depth > VersionInformation->resolution[ResolutionsDone].color)
                    {
                    VersionInformation->resolution[ResolutionsDone].xres = CrtTable->m_x_size;
                    VersionInformation->resolution[ResolutionsDone].yres = CrtTable->m_y_size;
                    VersionInformation->resolution[ResolutionsDone].color= CrtTable->m_pixel_depth;
                    }

                CrtTable++;         // Advance to the next mode table
                }
            status = NO_ERROR;
            }
        else if((RequestPacket->InputBuffer == RequestPacket->OutputBuffer) &&
                (((PENH_VERSION_NT)(RequestPacket->InputBuffer))->StructureVersion == 0) &&
                (((PENH_VERSION_NT)(RequestPacket->InputBuffer))->InterfaceVersion == 0))
            {
            /*
             * Interim packet
             */

            if (RequestPacket->OutputBufferLength < sizeof(ENH_VERSION_NT))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            RequestPacket->StatusBlock->Information = sizeof(ENH_VERSION_NT);

            EnhVersionInformation = RequestPacket->OutputBuffer;

            /*
             * Report the miniport version we are using.
             */
//            EnhVersionInformation->InterfaceVersion = (MINIPORT_VERSION_MAJOR << 8) | MINIPORT_VERSION_MINOR;
            EnhVersionInformation->InterfaceVersion = 0;

            /*
             * Remove the following line ONLY for official release versions
             * of the miniport. This line indicates that this is an
             * experimental (unsupported) version.
             */
            EnhVersionInformation->InterfaceVersion |= BETA_MINIPORT;

            /*
             * Report the chip used as both a numeric value and a flag.
             */
            EnhVersionInformation->ChipIndex = QueryPtr->q_asic_rev;
            EnhVersionInformation->ChipFlag = 1 << (QueryPtr->q_asic_rev);

            /*
             * Report the best aperture configuration available.
             *
             * Linear Framebuffer is preferable to VGA aperture,
             * which is preferable to engine-only.
             *
             * NOTE: VGA aperture will need to be split into
             *       68800-style and 68800CX-style once we
             *       go from the emulator to silicon.
             */
            if (QueryPtr->q_aperture_cfg != 0)
                EnhVersionInformation->ApertureType = AP_LFB;
            else if ((QueryPtr->q_asic_rev != CI_38800_1) && (QueryPtr->q_VGA_type == 1))
                EnhVersionInformation->ApertureType = AP_68800_VGA;
            else
                EnhVersionInformation->ApertureType = ENGINE_ONLY;
            EnhVersionInformation->ApertureFlag = 1 << (EnhVersionInformation->ApertureType);

            /*
             * Report the bus type being used.
             */
            EnhVersionInformation->BusType = QueryPtr->q_bus_type;
            EnhVersionInformation->BusFlag = 1 << (EnhVersionInformation->BusType);

            /*
             * For ASIC revisions that are capable of using memory mapped
             * registers, check to see whether we are using them.
             */
            if ((QueryPtr->q_asic_rev == CI_68800_6) || (QueryPtr->q_asic_rev == CI_68800_AX))
                {
                if (MemoryMappedEnabled_m())
                    EnhVersionInformation->BusFlag |= FL_MM_REGS;
                }

            /*
             * Report the number of ATI graphics cards in the system,
             * so the display driver will know how many auxillary
             * cards to initialize.
             *
             * Since multiheaded support requires all the ATI cards
             * present to be block I/O cards, the global variable
             * NumBlockCardsFound will always be 2 or higher in
             * multiheaded systems. If it is 0 (non-block card found,
             * since we will never get to this point if there are
             * no ATI cards) or 1 (single block I/O card), report
             * that there is 1 ATI card present.
             */
            if (NumBlockCardsFound >= 2)
                EnhVersionInformation->NumCards = NumBlockCardsFound;
            else
                EnhVersionInformation->NumCards = 1;
            VideoDebugPrint((DEBUG_DETAIL, "Reporting %d cards\n", EnhVersionInformation->NumCards));

            /*
             * Fill in the list of features this card supports.
             *
             * We can disable the sync signals even on cards that
             * don't have registers dedicated to DPMS support, so
             * all our cards support DPMS.
             */
            EnhVersionInformation->FeatureFlags = EVN_DPMS;

            /*
             * All platforms except the DEC Alpha are always
             * capable of using dense space. On the Alpha,
             * some machines with some of our cards are
             * capable of using dense space, while others
             * aren't.
             */
#if defined(_ALPHA_)
            if (DenseOnAlpha(QueryPtr) == TRUE)
                {
                EnhVersionInformation->FeatureFlags |= EVN_DENSE_CAPABLE;
                VideoDebugPrint((DEBUG_DETAIL, "Reporting dense capable in FeatureFlags\n"));
                }
#else
            EnhVersionInformation->FeatureFlags |= EVN_DENSE_CAPABLE;
#endif
            if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
                {
                if ((QueryPtr->q_asic_rev == CI_68800_6) && (QueryPtr->q_aperture_cfg == 0)
                    && (QueryPtr->q_VGA_type == 1) && ((QueryPtr->q_memory_type == 5) ||
                    (QueryPtr->q_memory_type == 6)))
                    EnhVersionInformation->FeatureFlags |= EVN_SPLIT_TRANS;
                if (IsMioBug_m(QueryPtr))
                    EnhVersionInformation->FeatureFlags |= EVN_MIO_BUG;
                }
            else if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                if (IsPackedIO_cx())
                    EnhVersionInformation->FeatureFlags |= EVN_PACKED_IO;

                if ((QueryPtr->q_memory_type == VMEM_SDRAM) &&
                    (QueryPtr->q_memory_size == VRAM_1mb))
                    EnhVersionInformation->FeatureFlags |= EVN_SDRAM_1M;

                if (QueryPtr->q_DAC_type == DAC_TVP3026)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_TVP_DAC_CUR;
                    }
                else if (QueryPtr->q_DAC_type == DAC_IBM514)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_IBM514_DAC_CUR;
                    }
                else if (QueryPtr->q_DAC_type == DAC_INTERNAL_CT)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_INT_DAC_CUR;
                    EnhVersionInformation->FeatureFlags |= EVN_CT_ASIC;
                    }
                else if (QueryPtr->q_DAC_type == DAC_INTERNAL_VT)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_INT_DAC_CUR;
                    EnhVersionInformation->FeatureFlags |= EVN_VT_ASIC;
                    }
                else if (QueryPtr->q_DAC_type == DAC_INTERNAL_GT)
                    {
                    EnhVersionInformation->FeatureFlags |= EVN_INT_DAC_CUR;
                    EnhVersionInformation->FeatureFlags |= EVN_GT_ASIC;
                    }
                }
            /*
             * Currently there are no feature flags specific to the Mach 8.
             */

            status = NO_ERROR;
            }
        else    /* Final form of the packet is not yet defined */
            {
            status = ERROR_INVALID_FUNCTION;
            }
        break;



        /*
         * Packet to return information regarding the capabilities/bugs
         * of the current mode.
         */
        case IOCTL_VIDEO_ATI_GET_MODE_INFORMATION:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - ATIGetModeInformation\n"));
            if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = sizeof(ENH_VERSION_NT)))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }
            ATIModeInformation = RequestPacket->OutputBuffer;
            ATIModeInformation->ModeFlags = 0;

            /*
             * Information regarding the visible portion of the screen.
             */
            ATIModeInformation->VisWidthPix = QueryPtr->q_desire_x;
            ATIModeInformation->VisHeight = QueryPtr->q_desire_y;
            ATIModeInformation->BitsPerPixel = QueryPtr->q_pix_depth;

            /*
             * We require the true pitch in 24bpp
             */
            if (QueryPtr->q_pix_depth == 24)
                {
                ATIModeInformation->PitchPix = QueryPtr->q_screen_pitch * 3;
                }
            else
                {
                ATIModeInformation->PitchPix = QueryPtr->q_screen_pitch;
                }
            /*
             * The FracBytesPerPixel field represents the first 3 places
             * of decimal in the fractional part of bytes per pixel.
             * No precision is lost, because the smallest granularity
             * (one bit per pixel) is 0.125 bytes per pixel, and any
             * multiple of this value does not extend beyond 3 places
             * of decimal.
             *
             * Mach 8 1280x1024 4BPP is packed pixel, other 4BPP modes all
             * ignore the upper 4 bits of each byte.
             */
            if ((QueryPtr->q_pix_depth == 4) &&
                !((QueryPtr->q_asic_rev == CI_38800_1) && (QueryPtr->q_desire_x == 1280)))
                {
                ATIModeInformation->IntBytesPerPixel = 1;
                ATIModeInformation->FracBytesPerPixel = 0;
                }
            else{
                ATIModeInformation->IntBytesPerPixel = QueryPtr->q_pix_depth / 8;
                switch (QueryPtr->q_pix_depth % 8)
                    {
                    case 0:
                        ATIModeInformation->FracBytesPerPixel = 0;
                        break;

                    case 1:
                        ATIModeInformation->FracBytesPerPixel = 125;
                        break;

                    case 2:
                        ATIModeInformation->FracBytesPerPixel = 250;
                        break;

                    case 3:
                        ATIModeInformation->FracBytesPerPixel = 375;
                        break;

                    case 4:
                        ATIModeInformation->FracBytesPerPixel = 500;
                        break;

                    case 5:
                        ATIModeInformation->FracBytesPerPixel = 625;
                        break;

                    case 6:
                        ATIModeInformation->FracBytesPerPixel = 750;
                        break;

                    case 7:
                        ATIModeInformation->FracBytesPerPixel = 875;
                        break;
                    }
                }
            ATIModeInformation->PitchByte = (QueryPtr->q_screen_pitch *
                ((ATIModeInformation->IntBytesPerPixel * 1000) + ATIModeInformation->FracBytesPerPixel)) / 8000;
            ATIModeInformation->VisWidthByte = (QueryPtr->q_desire_x *
                ((ATIModeInformation->IntBytesPerPixel * 1000) + ATIModeInformation->FracBytesPerPixel)) / 8000;

            /*
             * Information regarding the offscreen memory to the right
             * of the visible screen.
             */
            ATIModeInformation->RightWidthPix = ATIModeInformation->PitchPix - ATIModeInformation->VisWidthPix;
            ATIModeInformation->RightWidthByte = ATIModeInformation->PitchByte - ATIModeInformation->VisWidthByte;
            ATIModeInformation->RightStartOffPix = ATIModeInformation->VisWidthPix + 1;
            ATIModeInformation->RightStartOffByte = ATIModeInformation->VisWidthByte + 1;
            ATIModeInformation->RightEndOffPix = ATIModeInformation->PitchPix;
            ATIModeInformation->RightEndOffByte = ATIModeInformation->PitchByte;

            /*
             * Information regarding the offscreen memory below the
             * visible screen.
             */
            ATIModeInformation->BottomWidthPix = ATIModeInformation->PitchPix;
            ATIModeInformation->BottomWidthByte = ATIModeInformation->PitchByte;
            ATIModeInformation->BottomStartOff = ATIModeInformation->VisHeight + 1;
            /*
             * "Hard" values are the maximum Y coordinate which is backed by
             * video memory. "Soft" values are the maximum Y coordinate which
             * may be accessed without resetting the graphic engine offset
             * into video memory.
             *
             * In 4BPP modes, we always force the card to think it has
             * only 1M of memory.
             */
            if (QueryPtr->q_pix_depth == 4)
                {
                ATIModeInformation->BottomEndOffHard = ONE_MEG / ATIModeInformation->PitchByte;
                }
            else
                {
                ATIModeInformation->BottomEndOffHard = ((QueryPtr->q_memory_size - QueryPtr->q_VGA_boundary)
                    * QUARTER_MEG) / ATIModeInformation->PitchByte;
                }
            if ((QueryPtr->q_asic_rev == CI_88800_GX) && (ATIModeInformation->BottomEndOffHard > 16387))
                ATIModeInformation->BottomEndOffSoft = 16387;
            else if (ATIModeInformation->BottomEndOffHard > 1535)
                ATIModeInformation->BottomEndOffSoft = 1535;
            else
                ATIModeInformation->BottomEndOffSoft = ATIModeInformation->BottomEndOffHard;
            ATIModeInformation->BottomHeightHard = ATIModeInformation->BottomEndOffHard - ATIModeInformation->VisHeight;
            ATIModeInformation->BottomHeightSoft = ATIModeInformation->BottomEndOffSoft - ATIModeInformation->VisHeight;

            /*
             * Fill in the list of "quirks" experienced by this particular mode.
             */
            if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
                {
                if (((QueryPtr->q_desire_x == 1280) && (QueryPtr->q_desire_y == 1024)) ||
                    (((QueryPtr->q_DAC_type == DAC_STG1700) ||
                        (QueryPtr->q_DAC_type == DAC_STG1702) ||
                        (QueryPtr->q_DAC_type == DAC_STG1703)) && (QueryPtr->q_pix_depth >= 24)))
                    {
                    ATIModeInformation->ModeFlags |= AMI_ODD_EVEN;
                    }

                /*
                 * The test for block write mode must be made after we
                 * switch into graphics mode, but it is not mode dependent.
                 *
                 * Because the test corrupts the screen, and is not
                 * mode dependent, only run it the first time this
                 * packet is called and save the result to report
                 * on subsequent calls.
                 */
                if (QueryPtr->q_BlockWrite == BLOCK_WRITE_UNKNOWN)
                    {
                    if (BlockWriteAvail_m(QueryPtr))
                        QueryPtr->q_BlockWrite = BLOCK_WRITE_YES;
                    else
                        QueryPtr->q_BlockWrite = BLOCK_WRITE_NO;
                    }
                if (QueryPtr->q_BlockWrite == BLOCK_WRITE_YES)
                    ATIModeInformation->ModeFlags |= AMI_BLOCK_WRITE;
                }
            else if(phwDeviceExtension->ModelNumber == MACH64_ULTRA)
                {
                if (((QueryPtr->q_DAC_type == DAC_STG1700) ||
                        (QueryPtr->q_DAC_type == DAC_STG1702) ||
                        (QueryPtr->q_DAC_type == DAC_STG1703) ||
                        (QueryPtr->q_DAC_type == DAC_ATT408) ||
                        (QueryPtr->q_DAC_type == DAC_CH8398)) &&
                    (QueryPtr->q_pix_depth >= 24))
                    ATIModeInformation->ModeFlags |= AMI_ODD_EVEN;
                if (((QueryPtr->q_pix_depth == 24) && (QueryPtr->q_desire_x == 1280)) ||
                    ((QueryPtr->q_pix_depth == 24) && (QueryPtr->q_desire_x == 1152)) ||
                    ((QueryPtr->q_pix_depth == 16) && (QueryPtr->q_desire_x == 1600)))
                    ATIModeInformation->ModeFlags |= AMI_2M_BNDRY;

                if (TextBanding_cx(QueryPtr))
                    ATIModeInformation->ModeFlags |= AMI_TEXTBAND;

                /*
                 * See Mach 32 section above for explanation.
                 */
                if (QueryPtr->q_BlockWrite == BLOCK_WRITE_UNKNOWN)
                    {
                    if (BlockWriteAvail_cx(QueryPtr))
                        QueryPtr->q_BlockWrite = BLOCK_WRITE_YES;
                    else
                        QueryPtr->q_BlockWrite = BLOCK_WRITE_NO;
                    }
                if (QueryPtr->q_BlockWrite == BLOCK_WRITE_YES)
                    ATIModeInformation->ModeFlags |= AMI_BLOCK_WRITE;
                }

            status = NO_ERROR;
            break;


        /*
         * Packet to force initialization of auxillary card in multiheaded
         * setup. Currently (NT 3.51 retail), only the primrary card
         * receives a call to ATIMPInitialize().
         *
         * This packet must be called for all auxillary cards before
         * IOCTL_VIDEO_SET_CURRENT_MODE is called for any card, since
         * ATIMPInitialize() uses resources that are only available
         * when the primrary (VGA enabled) card is in a VGA mode.
         */
        case IOCTL_VIDEO_ATI_INIT_AUX_CARD:
            VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO - ATIInitAuxCard\n"));
            ATIMPInitialize(phwDeviceExtension);
            status = NO_ERROR;
            break;




        default:
            VideoDebugPrint((DEBUG_ERROR, "Fell through ATIMP startIO routine - invalid command\n"));
            status = ERROR_INVALID_FUNCTION;
            break;

    }

    RequestPacket->StatusBlock->Status = status;
    VideoDebugPrint((DEBUG_NORMAL, "ATIMPStartIO: Returning with status=%d\n", status));

    return TRUE;

} // end ATIMPStartIO()

/***************************************************************************
 *
 * BOOLEAN ATIMPResetHw(HwDeviceExtension, Columns, Rows);
 *
 * PVOID HwDeviceExtension;     Pointer to the miniport's device extension.
 * ULONG Columns;               Number of character columns on text screen
 * ULONG Rows;                  Number of character rows on text screen
 *
 * DESCRIPTION:
 *  Put the graphics card into either a text mode or a state where an
 *  INT 10 call will put it into a text mode.
 *
 * GLOBALS CHANGED:
 *  phwDeviceExtension  This global variable is set in every entry point routine.
 *
 * CALLED BY:
 *  This is one of the entry point routines for Windows NT.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOLEAN ATIMPResetHw(PVOID HwDeviceExtension, ULONG Columns, ULONG Rows)
{
    phwDeviceExtension = HwDeviceExtension;

    /*
     * On the Mach 64, an INT 10 to VGA text mode will work even
     * when in accelerator mode, so we don't need to explicitly
     * switch out of accelerator mode. On the Mach 8 and Mach 32,
     * we must switch out of accelerator mode, and on the Mach 32
     * we must load the VGA text font.
     *
     * On the Mach 64, some non-x86 machines (first noticed on the
     * DEC Alpha) don't do the warm boot BIOS re-initialization that
     * is done on the x86. Part of this re-initialization sets the
     * memory size register to the correct amount of memory, which
     * must be done if we were in a 4BPP mode (in 4BPP, we must force
     * the memory size to 1M). To avoid locking out modes requiring
     * over 1M (at least until the next cold boot) on these machines,
     * we must restore the memory size to the correct value. Since this
     * has the side effect of generating black vertical bands as a
     * transient (due to interleaving of memory banks on 2M and higher
     * configurations), only do this on non-x86 machines, since the
     * BIOS will take care of it (without the visible side effect)
     * on x86 platforms.
     *
     * Since this routine, and all routines it calls, must be
     * nonpageable (in case the reason it is called is because
     * there is a fatal error in the paging mechanism), and
     * VideoDebugPrint() is pageable, we must not call VideoDebugPrint()
     * from this routine. Temporary additions for testing are OK,
     * but the calls must be removed before the code is released
     * for production.
     */
#if defined (i386) || defined (_i386_)
    if (phwDeviceExtension->ModelNumber != MACH64_ULTRA)
        SetTextMode_m();
#else
    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        RestoreMemSize_cx();
    else
        SetTextMode_m();
#endif

    return FALSE;

}   /* end ATIMPResetHw() */

#if (TARGET_BUILD >= 500)

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344

VP_STATUS
ATIMPSetPower50(
    PHW_DEVICE_EXTENSION pHwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
//
// DESCRIPTION:
//  Set the graphics card to the desired DPMS state.
//
// PARAMETERS:
//  pHwDeviceExtension  Points to per-adapter device extension.
//  HwDeviceId          id identifying the device.
//  pVideoPowerMgmt     Points to structure containing desired DPMS state.
//
// RETURN VALUE:
//	Status code.
//
{
    ULONG ulDesiredState;

    ASSERT((pHwDeviceExtension != NULL) && (pVideoPowerMgmt != NULL));

    VideoDebugPrint((DEBUG_NORMAL, "ati.sys ATIMPSetPower50: *** Entry point ***\n"));

    ulDesiredState = pVideoPowerMgmt->PowerState;

    //
    // Check the ID passed down by the caller.
    // We must handle setting the power for each of the devices specifically.
    //
    VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPSetPower50: Device Id = 0x%x\n", HwDeviceId));

    if ((QUERY_MONITOR_ID == HwDeviceId) ||
        (QUERY_NONDDC_MONITOR_ID == HwDeviceId))
    {
        VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPSetPower50: Device Id = Monitor\n"));

        if (pVideoPowerMgmt->PowerState == VideoPowerHibernate) {

            // We just leave the monitor powered on for Hibernate.
            return NO_ERROR;
        }

        //
        // This is the monitor -- we will use the standard BIOS DPMS call.
        //
        return SetMonitorPowerState(pHwDeviceExtension, ulDesiredState);
    }
    else if (DISPLAY_ADAPTER_HW_ID == HwDeviceId)
    {
        VP_STATUS status;
        struct query_structure *QueryPtr =
            (struct query_structure *) (phwDeviceExtension->CardInfo);


        VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPSetPower50: Device Id = Graphics Adapter\n"));

        switch (pVideoPowerMgmt->PowerState) {

            case VideoPowerOn:
            case VideoPowerHibernate:

                status = NO_ERROR;
                break;

            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:

                status = ERROR_INVALID_PARAMETER;
                break;

            default:

                //
                // We indicated in ATIGetPowerState that we couldn't
                // do VideoPowerOff.  So we should not get a call to
                // do it here.
                //

                ASSERT(FALSE);
                status = ERROR_INVALID_PARAMETER;
                break;

        }

        return status;
    }
    else
    {
        VideoDebugPrint((DEBUG_ERROR, "ati.sys ATIMPSetPower50: Unknown pHwDeviceId\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}   // ATIMPSetPower50()

VP_STATUS
ATIMPGetPower50(
    PHW_DEVICE_EXTENSION pHwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
//
// DESCRIPTION:
//  Returns whether or not this particular DPMS state can be set on the
//  graphics card or monitor
//
// PARAMETERS:
//  pHwDeviceExtension  Points to per-adapter device extension.
//  HwDeviceId          id identifying the device.
//  pVideoPowerMgmt     Points to DPMS state we wish to know is supported or not.
//
// RETURN VALUE:
//  Status code.
//
{
    ASSERT((pHwDeviceExtension != NULL) && (pVideoPowerMgmt != NULL));

    VideoDebugPrint((DEBUG_NORMAL, "ati.sys ATIMPGetPower50: *** Entry point ***\n"));

    //
    // We currently only support settings the power on the monitor.
    // Check that we get the private ID we passed back the system.
    //

    VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPGetPower50: Device Id = 0x%x\n", HwDeviceId));

    if ((QUERY_MONITOR_ID == HwDeviceId) ||
        (QUERY_NONDDC_MONITOR_ID == HwDeviceId))
    {
        VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPGetPower50: Device Id = Monitor, State = D%ld\n",
            pVideoPowerMgmt->PowerState - 1));

        switch (pVideoPowerMgmt->PowerState)
        {
            case VideoPowerOn:
            case VideoPowerHibernate:

                return NO_ERROR;

            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:

                return ERROR_INVALID_FUNCTION;

            default:

                return ERROR_INVALID_PARAMETER;
        }

    }
    else if (DISPLAY_ADAPTER_HW_ID == HwDeviceId)
    {
        VideoDebugPrint((DEBUG_DETAIL, "ati.sys ATIMPGetPower50: Device Id = Graphics Adapter, State = D%ld\n",
            pVideoPowerMgmt->PowerState - 1));

        switch (pVideoPowerMgmt->PowerState) {

            case VideoPowerOn:
            case VideoPowerHibernate:

                return NO_ERROR;

            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:

                //
                // Indicate that we can't do VideoPowerOff, because
                // we have no way of coming back when power is re-applied
                // to the card.
                //

                return ERROR_INVALID_FUNCTION;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_FUNCTION;
        }
    }
    else
    {
        VideoDebugPrint((DEBUG_ERROR, "ati.sys ATIMPGetPower50: Unknown HwDeviceId\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}   // ATIMPGetPower50()

ULONG
ATIMPGetVideoChildDescriptor(
    PVOID pHwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )
//
// DESCRIPTION:
//  Enumerate all devices controlled by the ATI graphics chip.
//  This includes DDC monitors attached to the board, as well as other devices
//  which may be connected to a proprietary bus.
//
// PARAMETERS:
//  HwDeviceExtension   Pointer to our hardware device extension structure.
//  ChildEnumInfo       Information about the device that should be enumerated.
//  pvChildDescriptor   Identification structure of the device (EDID, string).
//  pHwId               Private unique 32 bit ID to passed back to the miniport.
//  pUnused             Do not use.
//
// RETURN VALUE:
//  ERROR_NO_MORE_DEVICES if no more child devices exist.
//  ERROR_INVALID_NAME if the device could not be enumerated, but more devices
//                     exist.
//  ERROR_MORE_DATA to be called again
//
// NOTE:
//  In the event of a failure return, none of the fields are valid except for
//  the return value and the pbMoreChildren field.
//
{
//
//
    ULONG Status;

    ASSERT(NULL != pHwDeviceExtension);

    VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: *** Entry point ***\n"));
    VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: pHwDeviceExtension = 0x%08X\n",
        pHwDeviceExtension));
    VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: ChildIndex = %ld\n", ChildEnumInfo->ChildIndex));


    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:

        //
        // This is the last device we enumerate.  Tell the system we don't
        // have any more.
        //

        *pChildType = Monitor;

        //
        // Obtain the EDID structure via DDC.
        //

        if (DDC2Query50(pHwDeviceExtension,
                        pvChildDescriptor,
                        ChildEnumInfo->ChildDescriptorSize) == TRUE)
        {
            ASSERT(pChildType != NULL && pHwId != NULL);

            *pHwId = QUERY_MONITOR_ID;

            VideoDebugPrint((DEBUG_NORMAL, "ati.sys ATIMPGetVideoChildDescriptor: Successfully read EDID structure\n"));

        } else {

            //
            // Alway return TRUE, since we always have a monitor output
            // on the card and it just may not be a detectable device.
            //
            ASSERT(pChildType != NULL && pHwId != NULL);

            *pHwId = QUERY_NONDDC_MONITOR_ID;

            VideoDebugPrint((DEBUG_NORMAL, "ati.sys ATIMPGetVideoChildDescriptor: DDC not supported\n"));

        }

        Status = ERROR_MORE_DATA;
        break;

    case DISPLAY_ADAPTER_HW_ID:
        {

        PUSHORT     pPnpDeviceDescription = NULL;
        ULONG       stringSize = sizeof(L"*PNPXXXX");

        struct query_structure * QueryPtr =
            (struct query_structure *) (phwDeviceExtension->CardInfo);

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;


        //
        //  Figure out which card type and set pPnpDeviceDescription at
        //  associated string.
        //

        // "ATI Graphics Ultra Pro (mach32)"
        pPnpDeviceDescription = L"*PNP090A";

        if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        {
            // "ATI Graphics Pro Turbo (mach64)"
            pPnpDeviceDescription = L"*PNP0916";
        }
        else if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        {
            if (QueryPtr->q_system_bus_type == Eisa)
            {
                // "ATI Graphics Ultra Pro EISA (mach32)"
                pPnpDeviceDescription = L"*ATI4402";
            }
        }
        else if (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA)
        {
            // "ATI Graphics Ultra (mach8)"
            pPnpDeviceDescription = L"*PNP090B";

        }
        else if (phwDeviceExtension->ModelNumber == WONDER)
        {
            // "ATI VGA Wonder"
            pPnpDeviceDescription = L"*PNP090D";
        }

        //
        //  Now just copy the string into memory provided.
        //

        memcpy(pvChildDescriptor, pPnpDeviceDescription, stringSize);

        Status = ERROR_MORE_DATA;

        break;
        }


    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }

    if (ERROR_MORE_DATA == Status)
    {
        VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: ChildType = %ld\n", *pChildType));
        VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: pvHdId = 0x%x\n", *pHwId));
        VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: *** Exit TRUE ***\n"));
    }
    else
    {
        VideoDebugPrint((DEBUG_NORMAL, "ATI.SYS!AtiGetVideoChildDescriptor: *** Exit FALSE ***\n"));
    }

    return Status;

}   // AtiGetVideoChildDescriptor()

#endif  // TARGET_BUILD >= 500


//------------------------------------------------------------------------
/*
 * VP_STATUS RegistryParameterCallback(phwDeviceExtension, Context, Name, Data, Length);
 *
 * PHW_DEVICE_EXTENSION phwDeviceExtension;     Miniport device extension
 * PVOID Context;           Context parameter passed to the callback routine
 * PWSTR Name;              Pointer to the name of the requested field
 * PVOID Data;              Pointer to a buffer containing the information
 * ULONG Length;            Length of the data
 *
 * Routine to process the information coming back from the registry.
 *
 * Return value:
 *  NO_ERROR if successful
 *  ERROR_INSUFFICIENT_BUFFER if too much data to store
 */
VP_STATUS RegistryParameterCallback(PHW_DEVICE_EXTENSION phwDeviceExtension,
                                    PVOID Context,
                                    PWSTR Name,
                                    PVOID Data,
                                    ULONG Length)
{
    if (Length > REGISTRY_BUFFER_SIZE)
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Copy the data to our local buffer so other routines
     * can use it.
     */
    memcpy(RegistryBuffer, Data, Length);
    RegistryBufferLength = Length;
    return NO_ERROR;

}   /* RegistryParameterCallback() */

BOOLEAN
SetDisplayPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    VIDEO_POWER_STATE VideoPowerState
    )
//
// DESCRIPTION:
//  Set the graphics card to the desired DPMS state under NT 3.51 and NT 4.0.
//
// PARAMETERS:
//  phwDeviceExtension  Pointer to our hardware device extension structure.
//  VideoPowerState     Desired DPMS state.
//
// RETURN VALUE:
//  TRUE if successful.
//  FALSE if unsuccessful.
//
{
    ASSERT(phwDeviceExtension != NULL);

    VideoDebugPrint((DEBUG_DETAIL, "ati.sys SetDisplayPowerState: Setting power state to %lu\n", VideoPowerState));

    //
    // Different card families need different routines to set the power management state.
    //

    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
    {
        VIDEO_X86_BIOS_ARGUMENTS Registers;

        //
        // Invoke the BIOS call to set the desired DPMS state. The BIOS call
        // enumeration of DPMS states is in the same order as that in
        // VIDEO_POWER_STATE, but it is zero-based instead of one-based.
        //
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_SET_DPMS;
        Registers.Ecx = VideoPowerState - 1;
        VideoPortInt10(phwDeviceExtension, &Registers);

        return TRUE;
    }
    else
    {
        VideoDebugPrint((DEBUG_ERROR, "ati.sys SetDisplayPowerState: Invalid adapter type\n"));
        ASSERT(FALSE);
        return FALSE;
    }
}   // SetDisplayPowerState()

VIDEO_POWER_STATE
GetDisplayPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    )
//
// DESCRIPTION:
//  Retrieve the current DPMS state from the graphics card.
//
// PARAMETERS:
//  phwDeviceExtension  Pointer to our hardware device extension structure.
//
// RETURN VALUE:
//  Current power management state.
//
// NOTE:
//  The enumerations VIDEO_DEVICE_POWER_MANAGEMENT (used by GetDisplayPowerState()) and VIDEO_POWER_MANAGEMENT
//  (used by this IOCTL) have opposite orderings (VIDEO_POWER_MANAGEMENT values increase as power consumption
//  decreases, while VIDEO_DEVICE_POWER_MANAGEMENT values increase as power consumption increases, and has
//  a reserved value for "state unknown"), so we can't simply add a constant to translate between them.
//
{
    VIDEO_POWER_STATE CurrentState = VideoPowerUnspecified;         // Current DPMS state

    ASSERT(phwDeviceExtension != NULL);

    //
    // Different card families need different routines to retrieve the power management state.
    //
    if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
        CurrentState = GetPowerManagement_cx(phwDeviceExtension);

    //
    // VIDEO_POWER_STATE has 5 possible states and a
    // reserved value to report that we can't read the state.
    // Our cards support 3 levels of monitor power-down in
    // addition to normal operation. Since the number of
    // values which can be reported exceeds the number
    // of states our cards can be in, we will never report
    // one of the possible states (VPPowerDeviceD3).
    //
    switch (CurrentState)
    {
        case VideoPowerUnspecified:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: unknown videocard\n"));
            break;

        case VideoPowerOn:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: Currently set to DPMS ON\n"));
            break;

        case VideoPowerStandBy:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: Currently set to DPMS STAND-BY\n"));
            break;

        case VideoPowerSuspend:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: Currently set to DPMS SUSPEND\n"));
            break;

        case VideoPowerOff:

            VideoDebugPrint((DEBUG_DETAIL, "ati.sys GetDisplayPowerState: Currently set to DPMS OFF\n"));
            break;

        default:

            VideoDebugPrint((DEBUG_ERROR, "ati.sys GetDisplayPowerState: Currently set to invalid DPMS state\n"));
            break;
    }

    return CurrentState;
}   // GetDisplayPowerState()



// ***********************   End of  ATIMP.C  ****************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\eeprom.h ===
/************************************************************************/
/*                                                                      */
/*                              EEPROM.H                                */
/*                                                                      */
/*        Aug 25  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.0  $
      $Date:   31 Jan 1994 11:41:26  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/eeprom.h  $
 * 
 *    Rev 1.0   31 Jan 1994 11:41:26   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.1   08 Oct 1993 15:18:50   RWOLFF
 * Added prototypes for ee_sel_eeprom() and ee_init_io() to allow
 * EEVGA.C to be built without including VIDFIND.H.
 * 
 *    Rev 1.0   03 Sep 1993 14:28:04   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
EEPROM.H - Header file for EEPROM.C

#endif


/*
 * Constants used for EEPROM access.
 */
#define STYLE_8514  0   /* Data stored 8514-style */
#define STYLE_VGA   1   /* Data stored VGA-style */

#define BUS_8BIT    0   /* 8514/ULTRA in 8-bit slot */
#define BUS_16BIT   1   /* 8514/ULTRA in 16-bit slot */

/*
 * Global data structures used for EEPROM access.
 */
extern struct  st_eeprom_data  ee;      // the location of I/O port bits

/*
 * Global variables dealing with the EEPROM.
 */
extern ULONG    ati_reg;        /* Base register for ATI extended VGA registers */
extern char     vga_chip;       // VGA chip revision as ascii

/*
 * Function prototypes.
 */
extern WORD ee_read_vga (short iIndex);     // VGA method
extern void ee_write_vga(unsigned short uiIndex, unsigned short uiData);
extern void ee_cmd_vga(unsigned short uiInstruct);
extern void ee_erase_vga(unsigned short uiIndex);
extern void ee_enab_vga(void);
extern void ee_disab_vga(void);

extern WORD ee_read_8514 (short index);
extern void ee_cmd_16 (WORD instruct);
extern void ee_cmd_1K (WORD instruct);

extern void Mach32DescribeEEPROM(int Style);
extern void Mach8UltraDescribeEEPROM(int BusWidth);
extern void Mach8ComboDescribeEEPROM(void);

BOOLEAN ee_sel_eeprom (PVOID Context);
BOOLEAN ee_init_io (PVOID Context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\dpms.h ===
//
// Module:  DPMS.H
// Date:    Aug 11, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.1  $
      $Date:   21 Aug 1997 15:02:00  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\dpms.h_v  $
 * 
 *    Rev 1.1   21 Aug 1997 15:02:00   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/


#ifndef _DPMS_H_
#define _DPMS_H_

//
// Prototypes for functions supplied by DPMS.C
//
VP_STATUS
SetMonitorPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    VIDEO_POWER_STATE VideoPowerState
    );

VP_STATUS
GetMonitorPowerState(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PVIDEO_POWER_STATE pVideoPowerState
    );

#endif  // _DPMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\dynatime.h ===
//
// Module:  DYNATIME.H
// Date:    Feb 13, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.4  $
      $Date:   13 Jul 1997 21:36:20  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\dynatime.h_v  $
 * 
 *    Rev 1.4   13 Jul 1997 21:36:20   MACIESOW
 * Flat panel and TV support.
 * 
 *    Rev 1.3   02 Jun 1997 14:20:56   MACIESOW
 * Clean up.
 * 
 *    Rev 1.2   02 May 1997 15:01:56   MACIESOW
 * Registry mode filters. Mode lookup table.
 * 
 *    Rev 1.1   25 Apr 1997 13:07:46   MACIESOW
 * o globals.
 * 
 *    Rev 1.0   15 Mar 1997 10:16:50   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifndef _DYNATIME_H_
#define _DYNATIME_H_

//
// Define the various types of displays.
//
#define DISPLAY_TYPE_FLAT_PANEL     0x00000001
#define DISPLAY_TYPE_CRT            0x00000002
#define DISPLAY_TYPE_TV             0x00000004

//
// Prototypes for functions supplied by DYNATIME.C.
//
BOOL
IsMonitorConnected(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
IsMonitorOn(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetMonitorOn(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetMonitorOff(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetFlatPanelOn(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetFlatPanelOff(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetTVOn(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

BOOL
SetTVOff(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

VP_STATUS
GetDisplays(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PULONG pulDisplays
    );

VP_STATUS
GetDisplays(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PULONG pulDisplays
    );

VP_STATUS
SetDisplays(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG ulDisplays
    );

BOOL
MapModeIndex(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG ulDesiredIndex,
    PULONG pulActualIndex
    );

#endif  // _DYNATIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\eevga.c ===
/************************************************************************/
/*                                                                      */
/*                              EEVGA.C                                 */
/*                                                                      */
/* Copyright   (c)  1992  ATI Technologies Inc.                         */
/************************************************************************/
/*                                                                      */

/**********************       PolyTron RCS Utilities

 $Revision:   1.3  $
     $Date:   23 Jan 1996 11:46:08  $
   $Author:   RWolff  $
      $Log:   S:/source/wnt/ms11/miniport/archive/eevga.c_v  $
 * 
 *    Rev 1.3   23 Jan 1996 11:46:08   RWolff
 * Eliminated level 3 warnings.
 * 
 *    Rev 1.2   23 Dec 1994 10:47:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.1   07 Feb 1994 14:07:44   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:08:26   RWOLFF
 * Initial revision.
        
           Rev 1.2   08 Oct 1993 15:17:28   RWOLFF
        No longer includes VIDFIND.H.
        
           Rev 1.1   03 Sep 1993 14:23:18   RWOLFF
        Partway through CX isolation.
        
           Rev 1.0   16 Aug 1993 13:26:32   Robert_Wolff
        Initial revision.
        
           Rev 1.11   24 Jun 1993 14:32:48   RWOLFF
        Microsoft-originated change: now uses VideoPortSynchronizeExecution()
        instead of _disable()/_enable() pairs.
        
           Rev 1.10   10 May 1993 10:54:08   RWOLFF
        Fixed uninitialized variable in Read_ee().
        
           Rev 1.9   27 Apr 1993 20:19:40   BRADES
        change extern ati_reg toa long, is a virtual IO address now.
        
           Rev 1.8   21 Apr 1993 17:31:10   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        
           Rev 1.7   08 Mar 1993 19:28:36   BRADES
        submit to MS NT
        
           Rev 1.5   06 Jan 1993 11:05:22   Robert_Wolff
        Cleaned up compile warnings.
        
           Rev 1.4   27 Nov 1992 15:19:30   STEPHEN
        No change.
        
           Rev 1.3   13 Nov 1992 16:32:32   Robert_Wolff
        Now includes 68801.H, which consists of the now-obsolete MACH8.H
        and elements moved from VIDFIND.H.
        
           Rev 1.2   12 Nov 1992 16:56:56   Robert_Wolff
        Same source file can now be used for both Windows NT driver and
        VIDEO.EXE test program.
        
           Rev 1.1   06 Nov 1992 19:02:34   Robert_Wolff
        Moved I/O port defines to VIDFIND.H.
        
           Rev 1.0   05 Nov 1992 14:01:06   Robert_Wolff
        Initial revision.
        
           Rev 1.1   01 Oct 1992 15:29:08   Robert_Wolff
        Can now handle both Mach32 and Mach8 cards.
        
           Rev 1.0   14 Sep 1992 09:44:30   Robert_Wolff
        Initial revision.
        
        
End of PolyTron RCS section                             *****************/


#if defined(DOC)
EEVGA.C - EEPROM read and write routines

DESCRIPTION:

        VGA   EEPROM read and write routines

September 4 1992 -  R. Wolff

Translated from assembler into C.

August 28 1992 -   C. Brady.

This has been adapted from the VGA$EEC.ASM software by Steve Stefanidis

The original code used externs to long_delay() and short_delay(), these
where changed to use local function delay.

The original used compile time options to work with various VGA revisions,
it is required to be run time determinate since we need to access
eeprom VGA style (how archaic) for the Graphics Ultra (38800) and the
68800 family of graphics controllers.

OLD_EEPROM_MAP  equ     1       ; enables the Old EEPROM Handling routines
REMOVED,  the DETECT.C routine assigns the eeprom address size used 
in EE_addr().  I do not know of a Graphics Ultra using 7 bit address
since they ONLY had a 1k eeprom == 64 words.

#endif      

#include <conio.h>
#include <dos.h>

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "cvtvga.h"     /* For SplitWord data type */
#include "eeprom.h"
#include "services.h"

#define OFF		0
#define ON		1

#define IND_OFFSET  0x00B0
#define SYNC_I      0x008 ^ IND_OFFSET
#define L_ALL       0x004
#define MISC3_I     0x010 ^ IND_OFFSET
#define EEPROM      0x020               /* EEPROM Enable bit */
#define EE_WREG     0x003 ^ IND_OFFSET
#define EE_CS       0x008               /* Chip Select bit */
#define EE_ENABLE   0x004
#define EE_CLK      0x002
#define EE_DI       0x001
#define EE_RREG     0x007 ^ IND_OFFSET
#define EE_DO       0x008

/*
 * Definitions for reading and writing the VGA sequencer registers.
 */
#define SD_CLOCK    0x0001      /* Index for clock mode register */
/*
 * Bit to set in clock mode register to blank the screen and disable
 * video-generation logic access to video memory.
 */
#define SD_CLK_OFF  0x020

ULONG   ati_reg;        // Base register for ATI extended VGA registers
char    vga_chip;       // VGA chip revision as ascii

/*
 * Storage for register where EEPROM read/write happens.
 */
static union SplitWord zEepromIOPort;

/*
 * Storage for original status which is determined in Sel_EE() and
 * which must be restored in DeSel_EE().
 */
static union SplitWord zOrigStat;

/*
 * EEPROM word to be read/written/erased/etc.
 */
static unsigned char ucEepromWord;

static void setscrn(int iSetting);
static unsigned short Read_ee(void);
static void ee_sel_vga(void);
static void ee_clock_vga(void);
static void EE_control(unsigned char ucEepromStatus);
static void ee_deselect_vga(void);
static void Write_ee(unsigned short uiData);
static void Enabl_ee(void);
static void Disab_ee(void);
static void Erase_ee(void);

extern void ee_wait(void);


/*
 * Allow miniport to be swapped out when not needed.
 *
 * The following routines are called through function pointers
 * rather than an explicit call to the routine, and may run into
 * trouble if paged out. If problems develop, make them un-pageable:
 * ee_read_vga()
 * ee_cmd_vga()
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, ee_read_vga)
#pragma alloc_text(PAGE_M, ee_write_vga)
#pragma alloc_text(PAGE_M, ee_erase_vga)
#pragma alloc_text(PAGE_M, ee_enab_vga)
#pragma alloc_text(PAGE_M, ee_disab_vga)
#pragma alloc_text(PAGE_M, setscrn)
#pragma alloc_text(PAGE_M, Read_ee)
#pragma alloc_text(PAGE_M, ee_sel_vga)
#pragma alloc_text(PAGE_M, ee_cmd_vga)
#pragma alloc_text(PAGE_M, ee_sel_eeprom)
#pragma alloc_text(PAGE_M, ee_clock_vga)
#pragma alloc_text(PAGE_M, EE_control)
#pragma alloc_text(PAGE_M, ee_deselect_vga)
#pragma alloc_text(PAGE_M, Write_ee)
#pragma alloc_text(PAGE_M, Enabl_ee)
#pragma alloc_text(PAGE_M, Disab_ee)
#pragma alloc_text(PAGE_M, Erase_ee)
#endif


/*
 * WORD ee_read_vga(iIndex);
 *
 * short iIndex;                    Which word of EEPROM should be read
 *
 * Read the specified word from the EEPROM.
 */
WORD ee_read_vga(short iIndex)
{
    unsigned short uiRetVal;    /* Value returned by Read_ee() */

    setscrn(OFF);           /* Disable the video card */

    /*
     * Set up the word index within the EEPROM and the chip identifier.
     */
    ucEepromWord = iIndex & 0x00ff;

    uiRetVal = Read_ee();           /* Get the word */

    setscrn(ON);            /* Re-enable the video card */

    return uiRetVal;
}



/*
 * void ee_write_vga(uiIndex, uiData);
 *
 * unsigned short uiIndex;
 * unsigned short uiData;
 *
 * Routine to write a word to the EEPROM.
 */
void ee_write_vga(unsigned short uiIndex, unsigned short uiData)
{
    setscrn(OFF);
    ucEepromWord = uiIndex & 0x00ff;
    Write_ee(uiData);

    ee_wait();
    setscrn(ON);

    return;
}



/*
 * void ee_erase_vga(uiIndex);
 *
 * unsigned short uiIndex;
 *
 * Routine to erase a word in the EEPROM.
 */
void ee_erase_vga(unsigned short uiIndex)
{
    setscrn(OFF);
    ucEepromWord = uiIndex & 0x00ff;
    Erase_ee();
    setscrn(ON);

    ee_wait();
    return;
}



/*
 * void ee_enab_vga(void);
 *
 * Routine to enable the EEPROM.
 */
void ee_enab_vga()
{
    setscrn(OFF);
    Enabl_ee();
    setscrn(ON);
    return;
}



/*
 * void ee_disab_vga(void);
 *
 * Routine to disable the EEPROM.
 */
void ee_disab_vga(void)
{
    setscrn(OFF);
    Disab_ee();
    setscrn(ON);

    ee_wait();
    return;
}



/*
 * static void setscrn(iSetting);
 *
 * int iSetting;    Should the video card be enabled (ON) or disabled (OFF)
 *
 * Enable or disable the video card, as selected by the caller.
 */
static void setscrn(int iSetting)
{
    static unsigned char ucSavedMode;   /* Saved value of clock mode register */


    if (iSetting)
        {
        /*
         * Caller wants to unblank the screen.
         *
         * Point the sequencer index register to the clock mode register.
         */
        OUTP(SEQ_IND, SD_CLOCK);

        /*
         * Set the clock mode register to the value it had before we
         * blanked the screen.
         */
        OUTP(SEQ_DATA, ucSavedMode);
        }

    else{
        /*
         * Caller wants to blank the screen.
         *
         * Point the sequencer index register to the clock mode register.
         */
        OUTP(SEQ_IND, SD_CLOCK);

        /*
         * Read and save the current contents of the clock mode register.
         */
        ucSavedMode = INP(SEQ_DATA);

        /*
         * Blank the screen without changing the other contents
         * of the clock mode register.
         */
        OUTP(SEQ_DATA, (BYTE)(ucSavedMode | SD_CLK_OFF));
        }

    return;
}



/*
 * static unsigned short Read_ee(void);
 *
 * A lower-level way of getting a word out of the EEPROM.
 */
static unsigned short Read_ee(void)
{
    int iCount;                         /* Loop counter */
    unsigned short uiValueRead = 0;     /* Value read from the EEPROM */
    union SplitWord zStateSet;          /* Used in setting the video state */

    ee_sel_vga();
    if (vga_chip >= '4')    /* ASIC revision level */
        {
        /*
         * Set read/write bit of ATI register 26 to read.
         */
        zStateSet.byte.low = 0x0a6;
        OUTP(ati_reg, zStateSet.byte.low);
        zStateSet.byte.high = INP(ati_reg+1);
        OUTPW(ati_reg, (WORD)((zStateSet.word & 0x0FBFF)));
        }

    ee_cmd_vga((unsigned short) (EE_READ | ucEepromWord));
    zEepromIOPort.byte.high &= (~EE_DI);
    OUTPW(ati_reg, zEepromIOPort.word);
    ee_clock_vga();

    /*
     * Read in the word, one bit at a time.
     */
    for (iCount = 0; iCount < 16; iCount++)
        {
        uiValueRead = uiValueRead << 1;
        OUTP(ati_reg, EE_RREG);
        if (INP(ati_reg+1) & EE_DO)
            uiValueRead |= 1;
        ee_clock_vga();
        }

    ee_deselect_vga();

    /*
     * Undo the state setting which was done on entry.
     */
    if (vga_chip >= '4')
	OUTPW(ati_reg, zStateSet.word);

    return uiValueRead;
}




/*
 * static void ee_sel_vga(void);
 *
 * This routine selects the EEPROM.
 */
static void ee_sel_vga(void)
{

    if (vga_chip <= '2')
        {
        /*
         * Get the video card's status.
         */
        VideoPortSynchronizeExecution(phwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          ee_sel_eeprom,
                                      phwDeviceExtension);

        OUTPW(HI_SEQ_ADDR, 0x0100);
        }
    else{
        EE_control(EEPROM);
        }

    return;
}



/*
 * void ee_cmd_vga(uiInstruct);
 *
 * unsigned short uiInstruct;   Opcode and address to send
 *
 * Sends EEPROM opcode and address to the EEPROM. The uiInstruct
 * parameter holds the 5 bit opcode and 6 bit index in the
 * format xxxx xOOO OOII IIII, where:
 * x is an unused bit
 * O is an opcode bit
 * I is an index bit
 */
void ee_cmd_vga(unsigned short uiInstruct)
{
    struct st_eeprom_data *ee = phwDeviceExtension->ee;

    int iCount;     /* Loop counter */
    /*
     * Mask showing which bit to test when sending the opcode or the address.
     */
    unsigned short uiBitTest;

    /*
     * Get the initial value for the I/O register which
     * will have its bits forced to specific values.
     */
    VideoPortSynchronizeExecution(phwDeviceExtension,
                                  VpHighPriority,
                                  (PMINIPORT_SYNCHRONIZE_ROUTINE) ee_init_io,
                                  phwDeviceExtension);

    ee_clock_vga();
    zEepromIOPort.byte.high &= (~EE_DI);
    zEepromIOPort.byte.high |= (EE_ENABLE | EE_CS); /* Enable the EEPROM and select the chip */
    OUTPW(ati_reg, zEepromIOPort.word);

    ee_clock_vga();

    /*
     * Send the opcode.
     */
    uiBitTest = 0x400;
    for (iCount = 0; iCount < 3; iCount++)
        {
        if (uiInstruct & uiBitTest)
            zEepromIOPort.byte.high |= EE_DI;
        else
            zEepromIOPort.byte.high &= (~EE_DI);
        OUTPW(ati_reg, zEepromIOPort.word);
        ee_clock_vga();
        uiBitTest >>= 1;
        }


    /*
     * We have finished with the opcode, now send the address.
     * Assume the EEPROM address is no longer than 8 bits
     * (256 word capacity). The Graphics Ultra series use
     * a 6 bit address (64 words), while the G.U. Plus and
     * Pro use 8 bits (but the EEPROM is only 128 words long).
     * Assume a 6 bit EEPROM address (64 word capacity).
     */
    uiBitTest = 0x01 << (ee->addr_size - 1);
    for (iCount = 0; iCount < ee->addr_size; iCount++)
        {
        if (uiBitTest & uiInstruct)
            zEepromIOPort.byte.high |= EE_DI;
        else
            zEepromIOPort.byte.high &= (~EE_DI);
        OUTPW(ati_reg, zEepromIOPort.word);
        ee_clock_vga();
        uiBitTest >>= 1;
        }

    return;
}


BOOLEAN
ee_sel_eeprom (
    PVOID Context
    )

/*++

Routine Description:

    Selects the eeprom within the context of interrupts being disabled.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.

--*/

{
    union SplitWord zStatus;    /* Status of the video card. */
    PHW_DEVICE_EXTENSION phwDeviceExtension = Context;


    OUTP(ati_reg, SYNC_I);
    zStatus.byte.high = INP(ati_reg + 1);
    zStatus.byte.low = SYNC_I;

    /*
     * Preserve the status so ee_deselect_vga() can restore it.
     */
    zOrigStat.word = zStatus.word;

    /*
     * Unlock the EEPROM to allow reading/writing.
     */
    zStatus.byte.high &= ~L_ALL;
    OUTPW(ati_reg, zStatus.word);
    return TRUE;


}

BOOLEAN
ee_init_io (
    PVOID Context
    )

/*++

Routine Description:


    Gets the initial value for the I/O register which
    will have its bits forced to specific values.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.

--*/

{
    PHW_DEVICE_EXTENSION phwDeviceExtension = Context;


    zEepromIOPort.byte.low = EE_WREG;
    OUTP(ati_reg, zEepromIOPort.byte.low);
    zEepromIOPort.byte.high = INP(ati_reg + 1);
    return TRUE;

}



/*
 * static void ee_clock_vga(void);
 *
 * Toggle the EEPROM CLK line high then low.
 */
static void ee_clock_vga(void)
{
    ee_wait();

    zEepromIOPort.byte.high |= EE_CLK;
    OUTPW(ati_reg, zEepromIOPort.word);

    ee_wait();

    zEepromIOPort.byte.high &= ~EE_CLK;
    OUTPW(ati_reg, zEepromIOPort.word);

    return;
}



/*
 * static void EE_control(ucEepromStatus);
 *
 * unsigned char ucEepromStatus;    Sets whether or not we should access the EEPROM
 *
 * Sets/resets the EEPROM bit of the data register at index MISC3_I.
 * This enables/disables EEPROM access.
 */
static void EE_control(unsigned char ucEepromStatus)
{
    union SplitWord zCtrlData;  /* Data read/written at specified control port */


    /*
     * Set up to write to the MISC3_I index register, and initialize
     * the data field to the EEPROM status we want.
     */
    zCtrlData.byte.high = ucEepromStatus;
    zCtrlData.byte.low = MISC3_I;
    OUTP(ati_reg, zCtrlData.byte.low);

    /*
     * Read in the data which is stored at the index MISC3_I, and combine
     * its contents (other than the EEPROM enable/disable bit)
     * with the desired EEPROM status we received as a parameter.
     */
    zCtrlData.byte.high |= (INP(ati_reg + 1) & ~EEPROM);

    /*
     * Write the result back. All bits other than the EEPROM enable/disable
     * bit will be unmodified.
     */
    OUTPW(ati_reg, zCtrlData.word);

    return;
}



/*
 * static void ee_deselect_vga(void);
 *
 * Purpose: Disable EEPROM read/write
 */
static void ee_deselect_vga(void)
{
    zEepromIOPort.byte.high &= (~EE_CS);
    OUTPW(ati_reg, zEepromIOPort.word);
    ee_clock_vga();
    zEepromIOPort.byte.high &= (~EE_ENABLE);
    OUTPW(ati_reg, zEepromIOPort.word);

    if (vga_chip <= '2')
        {
        OUTPW(HI_SEQ_ADDR, 0x0300);
        OUTPW(ati_reg, zOrigStat.word);
        }
    else{
        EE_control(0);
        }

    ee_wait();
    return;
}



/*
 * static void Write_ee(uiData);
 *
 * unsigned short uiData;       Value to write to the EEPROM.
 *
 * Lower-level routine to write a word to the EEPROM.
 */
static void Write_ee(unsigned short uiData)
{
    int iCount;                 /* Loop counter */

    ee_sel_vga();

    ee_cmd_vga((unsigned short) (EE_WRITE | ucEepromWord));

    /*
     * Write out the word, one bit at a time.
     */
    for (iCount = 0; iCount < 16; iCount++)
        {
        if (uiData & 0x8000)
            zEepromIOPort.byte.high |= EE_DI;
        else
            zEepromIOPort.byte.high &= (~EE_DI);
        OUTPW(ati_reg, zEepromIOPort.word);

        ee_clock_vga();
        uiData = uiData << 1;
        }

    ee_deselect_vga();

    return;
}



/*
 * Static void Enabl_ee(void);
 *
 * This is a lower-level routine to enable the EEPROM.
 */
static void Enabl_ee()
{

    ee_sel_vga();

    ee_cmd_vga((EE_ENAB | 0x3f));

    ee_deselect_vga();

    return;
}



/*
 * Static void Disab_ee(void);
 *
 * This is a lower-level routine to disable the EEPROM.
 */
static void Disab_ee(void)
{

    ee_sel_vga();

    ee_cmd_vga((EE_DISAB | 0x00));

    ee_deselect_vga();

    return;
}



/*
 * Static void Erase_ee(void);
 *
 * This is a lower-level routine to erase the EEPROM.
 */
static void Erase_ee(void)
{

    ee_sel_vga();

    ee_cmd_vga((unsigned short) (EE_ERASE | ucEepromWord));

    ee_deselect_vga();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\dynainit.h ===
//
// Module:  DYNAINIT.H
// Date:    Feb 10, 1997
//
// Copyright (c) 1997 by ATI Technologies Inc.
//

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.4  $
      $Date:   13 Jul 1997 21:34:14  $
   $Author:   MACIESOW  $
      $Log:   V:\source\wnt\ms11\miniport\archive\dynainit.h_v  $
 * 
 *    Rev 1.4   13 Jul 1997 21:34:14   MACIESOW
 * Flat panel and TV support.
 * 
 *    Rev 1.3   02 Jun 1997 14:18:14   MACIESOW
 * Clean up.
 * 
 *    Rev 1.2   02 May 1997 15:00:14   MACIESOW
 * Registry mode filters. Mode lookup table.
 * 
 *    Rev 1.1   25 Apr 1997 12:53:06   MACIESOW
 * No globals.
 * 
 *    Rev 1.0   15 Mar 1997 10:16:16   MACIESOW
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifndef _DYNAINIT_H_
#define _DYNAINIT_H_

//
// Flags used by hardware change detection
//
#define HC_CARD                     0x0001
#define HC_MONITOR                  0x0002
#define HC_MONITOR_OFF              0x0004
#define HC_MONITOR_UNKNOWN          0x8000

//
// Defines used in CARD_INFO structure
//
#define CARD_CHIP_TYPE_SIZE         128
#define CARD_DAC_TYPE_SIZE          128
#define CARD_ADAPTER_STRING_SIZE    128
#define CARD_BIOS_STRING_SIZE       128

//
// Defines used in MONITOR_INFO structure
//
#define MONITOR_GENERIC             L"Generic"
#define MONITOR_DATA_GENERIC        0
#define MONITOR_DATA_ASCII_VDIF     1
#define MONITOR_DATA_BIN_VDIF       2
#define MONITOR_DATA_EDID           3
#define MONITOR_DATE_SIZE           11
#define MONITOR_REVISION_SIZE       16
#define MONITOR_MANUFACTURER_SIZE   16
#define MONITOR_MODEL_NUMBER_SIZE   16
#define MONITOR_MIN_VDIF_INDEX_SIZE 16
#define MONITOR_VERSION_SIZE        16
#define MONITOR_SERIAL_NUMBER_SIZE  16
#define MONITOR_TYPE_SIZE           16
#define MONITOR_GENERIC_SIZE        sizeof(MONITOR_GENERIC)
#define MONITOR_BIN_VDIF_SIZE       38
#define MONITOR_EDID_SIZE           10

//
// Define the maximum TV resolutions and refresh rate.
//
#define TV_MAX_HOR_RESOLUTION       800
#define TV_MAX_VER_RESOLUTION       600
#define TV_MAX_REFRESH              60

//
// Define default values in case if ATI ROM cannot be read.
//
#define LT_MAX_HOR_RESOLUTION       1600
#define LT_MAX_VER_RESOLUTION       1200
#define LT_DEFAULT_REFRESH_FLAGS    0xFFFF

//
// Define refresh LT rate flags.
//
#define LT_REFRESH_FLAG_43          0x0001
#define LT_REFRESH_FLAG_47          0x0002
#define LT_REFRESH_FLAG_60          0x0004
#define LT_REFRESH_FLAG_67          0x0008
#define LT_REFRESH_FLAG_70          0x0010
#define LT_REFRESH_FLAG_72          0x0020
#define LT_REFRESH_FLAG_75          0x0040
#define LT_REFRESH_FLAG_76          0x0080
#define LT_REFRESH_FLAG_85          0x0100
#define LT_REFRESH_FLAG_90          0x0200
#define LT_REFRESH_FLAG_100         0x0400
#define LT_REFRESH_FLAG_120         0x0800
#define LT_REFRESH_FLAG_140         0x1000
#define LT_REFRESH_FLAG_150         0x2000
#define LT_REFRESH_FLAG_160         0x4000
#define LT_REFRESH_FLAG_200         0x8000

//
// Structure containing information about the current LCD display (BIOS al = 0x83).
//
#pragma pack(1)
typedef struct _FLAT_PANEL_INFO
{
    BYTE byteId;                    // Panel identification
    BYTE byteIdString[24];          // Panel identification string
    WORD wHorSize;                  // Horizontal size in pixels
    WORD wVerSize;                  // Vertical size in lines
    WORD wType;                     // Flat panel type
	                                //  bit 0      0 = monochrome
	                                //             1 = color
	                                //  bit 1      0 = single panel construction
	                                //             1 = dual (split) panel construction
	                                //  bits 7-2   0 = STN (passive matrix)
	                                //             1 = TFT (active matrix)
	                                //             2 = active addressed STN
	                                //             3 = EL
	                                //             4 = plasma
	                                //  bits 15-18 reserved
    BYTE byteRedBits;               // Red bits per primary
    BYTE byteGreenBits;             // Green bits per primary
    BYTE byteBlueBits;              // Blue bits per primary
    BYTE byteReserved1;             // Reserved bits per primary
    DWORD dwOffScreenMem;           // Size in KB of off screen memory required for frame buffer
    DWORD dwPointerMem;             // Pointer to reserved off screen memory for frame buffer
    BYTE byteReserved2[14];         // Reserved
} FLAT_PANEL_INFO, *PFLAT_PANEL_INFO;
#pragma pack()

typedef struct _CARD_INFO
{
    UCHAR ucaChipType[CARD_CHIP_TYPE_SIZE];
    UCHAR ucaDacType[CARD_DAC_TYPE_SIZE];
    UCHAR ucaAdapterString[CARD_ADAPTER_STRING_SIZE];
    UCHAR ucaBiosString[CARD_BIOS_STRING_SIZE];
    ULONG ulMemorySize;
} CARD_INFO, *PCARD_INFO;

typedef struct _MONITOR_INFO
{
    BOOL bDDC2Used;
    short nDataSource;
    union
    {
        struct
        {
            UCHAR ucaDate[MONITOR_DATE_SIZE];
            UCHAR ucaRevision[MONITOR_REVISION_SIZE];
            UCHAR ucaManufacturer[MONITOR_MANUFACTURER_SIZE];
            UCHAR ucaModelNumber[MONITOR_MODEL_NUMBER_SIZE];
            UCHAR ucaMinVDIFIndex[MONITOR_MIN_VDIF_INDEX_SIZE];
            UCHAR ucaVersion[MONITOR_VERSION_SIZE];
            UCHAR ucaSerialNumber[MONITOR_SERIAL_NUMBER_SIZE];
            UCHAR ucaDateManufactured[MONITOR_DATE_SIZE];
            UCHAR ucaMonitorType[MONITOR_TYPE_SIZE];
            short nCRTSize;
        } AsciiVdif;
        UCHAR ucaGeneric[MONITOR_GENERIC_SIZE];
        UCHAR ucaBinVdif[MONITOR_BIN_VDIF_SIZE];
        UCHAR ucaEdid[MONITOR_EDID_SIZE];
    } ProductID;
} MONITOR_INFO, *PMONITOR_INFO;

//
// Prototypes for functions supplied by DYNAINIT.C
//
BOOL
FinishModeTableCreation(                    // To be removed
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

VOID
GetRegistryCardInfo(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PCARD_INFO pCardInfo
    );

VOID
GetRegistryMonitorInfo(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PMONITOR_INFO pMonitorInfo
    );

#endif  // _DYNAINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\eeprom.c ===
/************************************************************************/
/*                                                                      */
/*                               EEPROM.C                               */
/*                                                                      */
/*  Copyright (c) 1992, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.3  $
    $Date:   23 Jan 1996 11:45:50  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/eeprom.c_v  $
 * 
 *    Rev 1.3   23 Jan 1996 11:45:50   RWolff
 * Eliminated level 3 warnings.
 * 
 *    Rev 1.2   23 Dec 1994 10:47:34   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.1   07 Feb 1994 14:07:06   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:08:14   RWOLFF
 * Initial revision.
        
           Rev 1.2   08 Oct 1993 15:17:42   RWOLFF
        No longer includes VIDFIND.H.
        
           Rev 1.1   03 Sep 1993 14:23:06   RWOLFF
        Partway through CX isolation.
        
           Rev 1.0   16 Aug 1993 13:23:00   Robert_Wolff
        Initial revision.
        
           Rev 1.10   21 Apr 1993 17:29:48   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        
           Rev 1.9   25 Mar 1993 11:14:42   RWOLFF
        Added typecast to get rid of warnings.
        
           Rev 1.8   08 Mar 1993 19:30:28   BRADES
        submit to MS NT
        
           Rev 1.5   06 Jan 1993 11:02:04   Robert_Wolff
        Eliminated dead code.
        
           Rev 1.4   24 Dec 1992 14:41:36   Chris_Brady
        fixup warnings
        
           Rev 1.3   27 Nov 1992 15:19:12   STEPHEN
        No change.
        
           Rev 1.2   13 Nov 1992 17:08:28   Robert_Wolff
        Now includes 68801.H, which consists of the now-obsolete MACH8.H
        and elements moved from VIDFIND.H.
        
           Rev 1.1   12 Nov 1992 16:54:00   Robert_Wolff
        Same source file can now be used with both Windows NT driver
        and VIDEO.EXE test program.
        
           Rev 1.0   05 Nov 1992 14:06:02   Robert_Wolff
        Initial revision.
        
           Rev 1.1   14 Sep 1992 09:44:40   Robert_Wolff
        Moved EEPROM opcodes to VIDEO.H, made VGA routine names consistent
        with same-purpose routines for 8514.
        
           Rev 1.0   02 Sep 1992 12:12:54   Chris_Brady
        Initial revision.
        

End of PolyTron RCS section                             *****************/

#ifdef DOC
    EEPROM.C -  EEPROM functions for 8514/Ultra, Graphics Ultra adapters
        see   EEVGA.ASM for the  VGA class  eeprom functions.

        Since time marches on, and the names of accelerator products
        changes often, these names are equivalent :
        { Mach32 or 68800 or Graphics Ultra Pro }

#endif

#include <conio.h>

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"

#include "amach.h"
#include "amach1.h"

#include "atimp.h"
#include "eeprom.h"
#include "services.h"

//----------------IFNDEF DATA_ASM
extern  WORD    rom_segment;
extern  WORD    rom_offset;



//----------------IFNDEF INIT_ASM
extern  WORD    default_640_set;
extern  WORD    default_1024_set;



/*
 * Global EEPROM data structures
 */
struct  st_eeprom_data  ee;             // the location of I/O port bits


//-----------------------------------------
//   function prototypes 



        void    ee_wait (void);
        void    ee_clock_16 (WORD eedata);
        void    ee_sel_16 (void);
        void    ee_deselect_16 (void);
        WORD    ee_read (short index);
        void    ee_write (short index, WORD eedata);


//-----------------------------------------


/*
 * Allow miniport to be swapped out when not needed.
 *
 * The following routines are called through function pointers
 * rather than an explicit call to the routine, and may run into
 * trouble if paged out. If problems develop, make them un-pageable:
 * ee_cmd_16()
 * ee_cmd_1K()
 * ee_read_8514()
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, ee_wait)
#pragma alloc_text(PAGE_M, ee_cmd_16)
#pragma alloc_text(PAGE_M, ee_cmd_1K)
#pragma alloc_text(PAGE_M, ee_sel_16)
#pragma alloc_text(PAGE_M, ee_deselect_16)
#pragma alloc_text(PAGE_M, ee_clock_16)
#pragma alloc_text(PAGE_M, ee_read)
#pragma alloc_text(PAGE_M, ee_read_8514)
#pragma alloc_text(PAGE_M, ee_write)
#pragma alloc_text(PAGE_M, Mach32DescribeEEPROM)
#pragma alloc_text(PAGE_M, Mach8UltraDescribeEEPROM)
#pragma alloc_text(PAGE_M, Mach8ComboDescribeEEPROM)
#endif
// these commands do NOT use the index component bits 5-0 so there
// is not a problem addressing up to 8 bit indexes , 256 words.
#define EE_EWEN            0x04C0    // program enable
#define EE_EWDS            0x0400    // program disable
#define EE_ERAL            0x0480    // erase all
#define EE_WRAL            0x0440    // program all



//;----------------------------------------------------------------------
//; EE_WAIT
//;   Waits for the requisite minimum setup time for the EEPROM
//;----------------------------------------------------------------------


void    ee_wait ()
{
//EE_DELAY_TIME (256-1) * 0.8381 usec = 214.0 usec
    delay (1);                      // delay in milliseconds
}   /* ee_wait */


//----------------------------------------------------------------------
// EE_CMD_16
//   Sends EEPROM opcode and address to a 1k, 2k eeprom
//   instruct is an  5 bit command in the form of 0111 1100 0000
//            with a 6 bit index   in the form of 0000 0011 1111
//   IF bit 10 is 1, then 8 bit address follows, else address not used.
//   Write data Serially to the   EE_DATA_OUT_M32 bit of the ee->out.
//   Send out in high to low bit order
//   
//----------------------------------------------------------------------

void    ee_cmd_16 (WORD instruct)
{
int     jj;
WORD    bittest = 0x400;                // 0100 0000 0000b    bit 10
WORD    eedata;
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_clock_16((WORD) (ee->select | ee->chipselect));  // start bit
    for (jj=0; jj < 11;  jj++)
        {
        ee_wait();
        if (instruct & bittest)             // is a one bit
            eedata = ee->select | ee->chipselect | ee->data_out;
        else
            eedata = ee->select | ee->chipselect;
        OUTPW (ee->iop_out, eedata);
        
        ee_clock_16 (eedata);       // send cmd bit
        bittest >>= 1;                      // next bit to the right
        }
    return;
}    /* ee_cmd_16 */



//----------------------------------------------------------------------
// EE_CMD_1K
//   Sends EEPROM opcode and address to a 1k, 2k eeprom
//   instruct is an  5 bit command in the form of 0111 1100 0000
//            with a 6 bit index   in the form of 0000 0011 1111
//   IF bit 10 is 1, then 8 bit address follows, else address not used.
//   Write data Serially to the   EE_DATA_OUT_M32 bit of the ee->iop_out.
//   Send out in high to low bit order
//   
//----------------------------------------------------------------------

void    ee_cmd_1K (WORD instruct)
{
int     jj;
WORD    bittest = 0x400;                // 0100 0000 0000b    bit 10
WORD    eedata;
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_clock_16((WORD) (ee->select | ee->chipselect));  // start bit      
    for (jj=0; jj < 3;  jj++)
        {
        ee_wait();
        if (instruct & bittest)             // is a one bit
            eedata = ee->select | ee->chipselect | ee->data_out;
        else
            eedata = ee->select | ee->chipselect;
        OUTPW (ee->iop_out, eedata);
        
        ee_clock_16 (eedata);       // send cmd bit
        bittest >>= 1;                      // next bit to the right
        }
    bittest = 0x20;                         // 0010 0000b    bit 5
    for (jj=0; jj < 6;  jj++)
        {
        ee_wait();
        if (instruct & bittest)             // is a one bit
            eedata = ee->select | ee->chipselect | ee->data_out;
        else
            eedata = ee->select | ee->chipselect;
        OUTPW (ee->iop_out, eedata);
        
        ee_clock_16 (eedata);           // send cmd bit
        bittest >>= 1;                      // next bit to the right
        }
    return;
}    /* ee_cmd_1K */



//;----------------------------------------------------------------------
//; EE_SEL_16
//;   Pull EEPROM chip select high
//;
//;----------------------------------------------------------------------

void    ee_sel_16 (void)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_wait();
    OUTPW (ee->iop_out, (WORD)((ee->select) | (ee->chipselect)));   // EE_CS high
    ee_wait();
    return;

}   /* ee_sel_16 */


//;----------------------------------------------------------------------
//; EE_DESELECT_16
//;   Pull EEPROM chip select low
//;
//;----------------------------------------------------------------------

void    ee_deselect_16 (void)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_wait();
    OUTPW (ee->iop_out, ee->select);    // EE_CS high
    ee_clock_16 (ee->select);           // send cmd bit
    OUTPW (ee->iop_out, 0);             // disable EEprom activity
    ee_wait();
    return;

}   /* ee_deselect_16 */


//;----------------------------------------------------------------------
//; EE_CLOCK_16
//;   Toggle EEPROM CLK line high then low
//;
//;   INPUT: eedata = select status for EEPROM
//;----------------------------------------------------------------------

void    ee_clock_16 (WORD eedata)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

    ee_wait();
    OUTPW (ee->iop_out, (WORD)(eedata | (ee->clock)));      // clock ON
    ee_wait();
    OUTPW (ee->iop_out, (WORD)(eedata & ~(ee->clock)));     // clock OFF
    ee_wait();

}   /* ee_clock_16 */


//;----------------------------------------------------------------------
//; EE_READ                     - was a 68800 function
//;   Read a word from EEPROM      ONLY called from   INIT.asm
//;   INPUT: bl = index
//;   OUTPUT: ax = data
//;----------------------------------------------------------------------

WORD    ee_read (short index)
{
WORD    indata=0;

    if (INPW(CONFIG_STATUS_1) & 1)		//is 8514 or VGA eeprom
        {                               // VGA disabled, use 8514 method
        indata = ee_read_8514 (index);
        }
    else{
        indata = ee_read_vga (index);   // VGA method
        }
    return (indata);
}   /* ee_read */


//;----------------------------------------------------------------------
//; EE_READ_8514   
//;   Read a word from using 8514 EEPROM registers
//;   INPUT: bl = index
//;   OUTPUT: ax = data
//;----------------------------------------------------------------------

WORD    ee_read_8514 (short index) 
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

int     jj;
WORD    save_misc, indata=0;

    save_misc = INPW (R_MISC_CNTL); 	// Read only location
    ee_sel_16();
    (ee->EEcmd) ((WORD) (EE_READ | index));     // send read cmd and index to EEPROM
    ee_clock_16 ((WORD) (ee->select | ee->chipselect));

    for (jj=0; jj < 16; jj++)
        {
        indata <<= 1;
        if (INPW(ee->iop_in) & ee->data_in)	// get data bit
            indata |= 1;
        ee_clock_16 ((WORD) (ee->select | ee->chipselect));
        }

    ee_deselect_16();
    OUTPW (MISC_CNTL, save_misc);

    return (indata);
}   /* ee_read_8514 */


//;----------------------------------------------------------------------
//; EE_WRITE
//;   Writes a word to EEPROM      
//;             However, this will fail since 1K eeprom does NOT need
//;             the EE_EWEN, EE_EWDS  commands          +++++++++++++++++
//;             See EEVGA.C  ee_write_vga().
//;   INPUT: index = which word to write
//;          data  = data to write
//;----------------------------------------------------------------------
                
void    ee_write (short index, WORD eedata)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;

int     jj;
WORD    save_misc, indata=0;

    if (INPW(CONFIG_STATUS_1) & 1)		//is 8514 or VGA eeprom
        {                                       // VGA disabled, use 8514 method
        save_misc = INPW (R_MISC_CNTL); 	// Read only location
        OUTP (DISP_CNTL, 0x53); 	// disable CRT before writing EEPROM

        ee_sel_16();
        ee_cmd_16 (EE_EWEN);        // enable EEPROM write

        ee_deselect_16();   // EE_CS low
        ee_sel_16();

        ee_cmd_16 ((WORD) (EE_ERASE | index)); 
        ee_deselect_16();   // EE_CS low
        delay (50);

        ee_sel_16();
        ee_cmd_16 ((WORD) (EE_WRITE | index));      // EEPROM write data


        for (jj=0; jj < 16; jj++)
            {
            ee_wait();
            if (eedata & 0x8000)                // get data bit
                OUTPW (ee->iop_out, (WORD)((ee->select) | (ee->chipselect) | (ee->data_out)));
            else
                OUTPW (ee->iop_out, (WORD)((ee->select) | (ee->chipselect)));
            ee_clock_16  ((WORD) (ee->select | ee->chipselect));
            eedata <<= 1;
            }

        ee_deselect_16();   // EE_CS low
        delay (50);                                   // in milliseconds
        ee_sel_16();
        ee_cmd_16 (EE_EWDS);    // disable EEPROM write
        ee_deselect_16();   // EE_CS low

        OUTPW (ee->iop_out, save_misc);
        }
    else{
        ee_write_vga (index, eedata);       // VGA method
        }

}   /* ee_write */


/***************************************************************************
 *
 * New Functions
 *
 ***************************************************************************/

/*
 * void Mach32DescribeEEPROM(Style);
 *
 * int Style;   Is data stored 8514-style or VGA-style?
 *
 * Fill in the EEPROM description structure for the Mach 32 card.
 */
void Mach32DescribeEEPROM(int Style)
{
    ee.iop_out      = MISC_CNTL;
    ee.iop_in       = EXT_GE_STATUS;
    ee.clock        = EE_CLK_M32;
    ee.select       = EE_SELECT_M32;
    ee.chipselect   = EE_CS_M32;
    ee.data_out     = EE_DATA_OUT_M32;
    ee.data_in      = EE_DATA_IN;

    if (Style == STYLE_8514)
        {
        ee.EEread = ee_read_8514;       // 8514 style
        ee.EEcmd  = ee_cmd_16;
        }
    else{
        ee.EEread       = ee_read_vga;  // VGA style
        ee.EEcmd        = ee_cmd_vga;
        ee.addr_size    = 8;
        }
    return;
}


/*
 * void Mach8UltraDescribeEEPROM(BusWidth);
 *
 * int BusWidth;    Is 8514/ULTRA plugged into 8 or 16 bit slot?
 *
 * Fill in the EEPROM description structure for the 8514/ULTRA.
 */
void Mach8UltraDescribeEEPROM(int BusWidth)
{
    ee.data_in      = EE_DATA_IN;
    ee.iop_out      = EXT_GE_CONFIG;
    ee.iop_in       = EXT_GE_STATUS;
    ee.EEread       = ee_read_8514;        // how read eeprom
    ee.EEcmd        = ee_cmd_1K;           // send command to eeprom

    /*
     * Only the 8514/Ultra has a hardware bug that prevents it
     * from writing to the EEPROM when it is in an 8 bit ISA bus.
     */
    if (BusWidth == BUS_8BIT)
        {
        ee.clock        = EE_CLK_M8_8;
        ee.select       = EE_SELECT_M8_8;
        ee.chipselect   = EE_CS_M8_8;
        ee.data_out     = EE_DATA_OUT_M8_8;
        }
    else{
        ee.clock        = EE_CLK_M8_16;        // assume are in a 16 bit bus
        ee.select       = EE_SELECT_M8_16;
        ee.chipselect   = EE_CS_M8_16;
        ee.data_out     = EE_DATA_OUT_M8_16;
        }
    return;
}


/*
 * void Mach8ComboDescribeEEPROM(void);
 *
 * Fill in the EEPROM description structure for the Graphics ULTRA
 * and Graphics VANTAGE. These cards always have both the 8514 and
 * the VGA enabled, so the EEPROM is ALWAYS read VGA style.
 */
extern void Mach8ComboDescribeEEPROM(void)
{
    ee.addr_size        = 6;
    ee.iop_out          = EXT_GE_CONFIG;
    ee.iop_in           = EXT_GE_STATUS;
    ee.data_in          = EE_DATA_IN;

    ee.clock            = EE_CLK_M8_16;     // are in a 16 bit bus
    ee.select           = EE_SELECT_M8_16;
    ee.chipselect       = EE_CS_M8_16;
    ee.data_out         = EE_DATA_OUT_M8_16;

    ee.EEread           = ee_read_vga;      // VGA style
    ee.EEcmd            = ee_cmd_vga;
    return;
}




//*******************   end  of  EEPROM.C   ******************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\init_cx.h ===
/************************************************************************/
/*                                                                      */
/*                              INIT_CX.H                               */
/*                                                                      */
/*        Nov 15  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.6  $
      $Date:   15 May 1996 16:35:10  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/init_cx.h_v  $
 *
 *    Rev 1.6   15 May 1996 16:35:10   RWolff
 * Updated prototype for SetCurrentMode_cx() to allow reporting
 * of failure on mode set.
 *
 *    Rev 1.5   03 Feb 1995 15:16:24   RWOLFF
 * Added prototypes for functions used in DCI support.
 *
 *    Rev 1.4   11 Jan 1995 14:02:48   RWOLFF
 * Added prototype for RestoreMemSize_cx().
 *
 *    Rev 1.3   12 May 1994 11:14:36   RWOLFF
 * Definitions and data structures used by new routine SetModeFromTable_cx()
 *
 *    Rev 1.2   31 Mar 1994 15:05:38   RWOLFF
 * Added prototype for SetPowerManagement_cx().
 *
 *    Rev 1.1   03 Mar 1994 12:37:20   ASHANMUG
 *
 *    Rev 1.0   31 Jan 1994 11:41:50   RWOLFF
 * Initial revision.
 *
 *    Rev 1.0   30 Nov 1993 18:32:58   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
INIT_CX.H - Header file for INIT_CX.C

#endif


/*
 * Prototypes for functions supplied by INIT_CX.C
 */
extern void Initialize_cx(void);
extern VP_STATUS MapVideoMemory_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS QueryPublicAccessRanges_cx(PVIDEO_REQUEST_PACKET RequestPacket);
extern VP_STATUS QueryCurrentMode_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS QueryAvailModes_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS SetCurrentMode_cx(struct query_structure *QueryPtr, struct st_mode_table *CrtTable);
extern void SetPalette_cx(PULONG lpPalette, USHORT StartIndex, USHORT Count);
extern void IdentityMapPalette_cx(void);
extern void ResetDevice_cx(void);
extern VP_STATUS SetPowerManagement_cx(ULONG DpmsState);

DWORD GetPowerManagement_cx(
    PHW_DEVICE_EXTENSION phwDeviceExtension
    );

extern void RestoreMemSize_cx(void);
extern VP_STATUS ShareVideoMemory_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern void BankMap_cx(ULONG BankRead, ULONG BankWrite, PVOID Context);

#ifdef INCLUDE_INIT_CX
/*
 * Private definitions used in INIT_CX.C
 */

/*
 * Value to put in low byte of cx_bios_set_from_table.cx_bs_mode_select
 * to indicate that this is an accelerator mode.
 */
#define CX_BS_MODE_SELECT_ACC   0x0080

/*
 * Bit fields in cx_bios_set_from_table.cx_bs_flags
 */
#define CX_BS_FLAGS_MUX         0x0400
#define CX_BS_FLAGS_INTERLACED  0x0200
#define CX_BS_FLAGS_ALL_PARMS   0x0010

/*
 * Value to put in high byte of cx_bios_set_from_table.cx_bs_v_sync_wid
 * to force use of the pixel clock frequency in the cx_bs_dot_clock
 * field rather than a divisor/selector pair.
 */
#define CX_BS_V_SYNC_WID_CLK    0xFF00

/*
 * Mode table structure used in setting the video mode using CH=0x81
 * AX=??00 BIOS call.
 *
 * The alignment of fields within the table expected by the BIOS
 * does not match the default structure alignment of the Windows NT
 * C compiler, so we must force byte alignment.
 */
#pragma pack(1)
struct cx_bios_set_from_table{
    WORD cx_bs_reserved_1;      /* Reserved */
    WORD cx_bs_mode_select;     /* Resolution to use */
    WORD cx_bs_flags;           /* Flags to indicate various conditions */
    WORD cx_bs_h_tot_disp;      /* Horizontal total and displayed values */
    WORD cx_bs_h_sync_strt_wid; /* Horizontal sync start and width */
    WORD cx_bs_v_total;         /* Vertical total */
    WORD cx_bs_v_disp;          /* Vertical displayed */
    WORD cx_bs_v_sync_strt;     /* Vertical sync start */
    WORD cx_bs_v_sync_wid;      /* Vertical sync width */
    WORD cx_bs_dot_clock;       /* Pixel clock frequency to use */
    WORD cx_bs_h_overscan;      /* Horizontal overscan information */
    WORD cx_bs_v_overscan;      /* Vertical overscan information */
    WORD cx_bs_overscan_8b;     /* 8BPP and blue overscan colour */
    WORD cx_bs_overscan_gr;     /* Green and red overscan colour */
    WORD cx_bs_reserved_2;      /* Reserved */
};
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\init_cx.c ===
/************************************************************************/
/*                                                                      */
/*                              INIT_CX.C                               */
/*                                                                      */
/*        Nov 15  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.42  $
      $Date:   15 May 1996 16:34:38  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/init_cx.c_v  $
 *
 *    Rev 1.42   15 May 1996 16:34:38   RWolff
 * Now reports failure of mode set, waits for idle after setting
 * accelerator mode.
 *
 *    Rev 1.41   01 May 1996 14:09:20   RWolff
 * Calls new routine DenseOnAlpha() to determine dense space support rather
 * than assuming all PCI cards support dense space.
 *
 *    Rev 1.40   17 Apr 1996 13:09:04   RWolff
 * Backed out Alpha LFB mapping as dense.
 *
 *    Rev 1.39   11 Apr 1996 15:13:20   RWolff
 * Now maps framebuffer as dense on DEC Alpha with PCI graphics card.
 *
 *    Rev 1.38   20 Mar 1996 13:42:32   RWolff
 * Removed debug print statements from RestoreMemSize_cx(), which must
 * be nonpageable since it is called from ATIMPResetHw().
 *
 *    Rev 1.37   01 Mar 1996 12:11:50   RWolff
 * VGA Graphics Index and Graphics Data are now handled as separate
 * registers rather than as offsets into the block of VGA registers.
 *
 *    Rev 1.36   02 Feb 1996 17:16:40   RWolff
 * Now uses VideoPortInt10() rather than our no-BIOS code to set "canned"
 * modes on VGA-disabled cards.
 *
 *    Rev 1.35   29 Jan 1996 16:55:02   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC.
 *
 *    Rev 1.34   23 Jan 1996 11:46:22   RWolff
 * Added debug print statements.
 *
 *    Rev 1.33   22 Dec 1995 14:53:30   RWolff
 * Added support for Mach 64 GT internal DAC.
 *
 *    Rev 1.32   23 Nov 1995 11:27:46   RWolff
 * Fixes needed for initial run of VT chips (check if they're still needed
 * on the final version), added support for multiple block-relocatable
 * Mach 64 cards.
 *
 *    Rev 1.31   28 Jul 1995 14:40:58   RWolff
 * Added support for the Mach 64 VT (CT equivalent with video overlay).
 *
 *    Rev 1.30   23 Jun 1995 16:01:46   RWOLFF
 * In 8BPP and lower modes, SetPalette_cx() now uses the VGA palette
 * registers rather than the accelerator palette registers. This is
 * done so that a video capture card attached to the feature connector
 * will know what colours the palette is set to.
 *
 *    Rev 1.29   02 Jun 1995 14:26:48   RWOLFF
 * Added debug print statements.
 *
 *    Rev 1.28   31 Mar 1995 11:57:12   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.27   08 Mar 1995 11:33:54   ASHANMUG
 * Fixed a bug if the banked aperture was enabled, the memory mapped register we
 * getting moved if the memory sized was changed to support 4bpp
 *
 *    Rev 1.26   27 Feb 1995 17:48:08   RWOLFF
 * Now always reports 1M when mapping video memory for 4BPP, since we
 * force the card to 1M, QueryPublicAccessRanges_cx() now returns
 * the virtual address of the I/O register base rather than the
 * beginning of I/O space.
 *
 *    Rev 1.25   20 Feb 1995 18:01:18   RWOLFF
 * Made test and workaround for screen tearing on 2M boundary DAC-independant,
 * 1600x1200 16BPP added to modes that have this tearing.
 *
 *    Rev 1.24   14 Feb 1995 15:45:36   RWOLFF
 * Changed conditional compile that uses or fakes failure of
 * VideoPortMapBankedMemory() to look for IOCTL_VIDEO_SHARE_VIDEO_MEMORY
 * instead of the routine itself. Looking for the routine always failed,
 * and since the routine is supplied in order to allow DCI to be used
 * on systems without a linear framebuffer, it should be available on
 * any DDK version that supports the IOCTL. If it isn't, a compile-time
 * error will be generated (unresolved external reference).
 *
 *    Rev 1.23   09 Feb 1995 14:57:36   RWOLFF
 * Fix for GX-E IBM DAC screen tearing in 800x600 8BPP.
 *
 *    Rev 1.22   07 Feb 1995 18:24:22   RWOLFF
 * Fixed screen trash on return from 4BPP test on CT and 4M Xpression.
 * These were the first cards I was able to obtain that switched aperture
 * size between modes (GX uses 8M aperture only on 4M cards, which used
 * to be made only with DAC that didn't support 4BPP, but CT uses 8M for
 * 2M card and 4M when cut back to 1M).
 *
 *    Rev 1.21   03 Feb 1995 15:15:12   RWOLFF
 * Added support for DCI, fixed CT internal DAC 4BPP cursor problem,
 * RestoreMemSize_cx() is no longer pageable, since it is called
 * on a bugcheck.
 *
 *    Rev 1.20   30 Jan 1995 11:56:24   RWOLFF
 * Now supports CT internal DAC.
 *
 *    Rev 1.19   11 Jan 1995 14:04:04   RWOLFF
 * Added routine RestoreMemSize_cx() which sets the memory size register
 * back to the value read by the BIOS query. This is used when returning
 * from a test of 4BPP (code had been inlined there) or when shutting down
 * from 4BPP (new) because 4BPP modes require that the memory size be
 * set to 1M. On some platforms, the x86 emulation in the firmware does not
 * reset the memory size to the true value, so a warm reboot from 4BPP left
 * the card thinking that it only had 1M.
 *
 *    Rev 1.18   23 Dec 1994 10:47:48   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.17   18 Nov 1994 11:40:00   RWOLFF
 * Added support for Mach 64 without BIOS.
 *
 *    Rev 1.16   14 Sep 1994 15:24:38   RWOLFF
 * Now uses "most desirable supported colour ordering" field in query
 * structure rather than DAC type to determine which colour ordering
 * to use for 24 and 32BPP.
 *
 *    Rev 1.15   31 Aug 1994 16:24:02   RWOLFF
 * Added support for TVP3026 DAC, 1152x864, and BGRx colour ordering
 * (used by TVP DAC), uses VideoPort[Read|Write]Register[Uchar|Ushort|Ulong]()
 * instead of direct assignments when accessing structures stored in
 * VGA text screen off-screen memory.
 *
 *    Rev 1.14   19 Aug 1994 17:15:32   RWOLFF
 * Added support for non-standard pixel clock generators.
 *
 *    Rev 1.13   09 Aug 1994 11:52:30   RWOLFF
 * Shifting of colours when setting up palette is now done in
 * display driver.
 *
 *    Rev 1.12   27 Jun 1994 16:27:38   RWOLFF
 * Now reports all hardware default mode tables as noninterlaced to
 * avoid confusing the display applet.
 *
 *    Rev 1.11   15 Jun 1994 11:06:24   RWOLFF
 * Now sets the cursor colour every time we enter graphics mode. This is a
 * fix for the black cursor after testing 4BPP from 16BPP.
 *
 *    Rev 1.10   12 May 1994 11:22:40   RWOLFF
 * Added routine SetModeFromTable_cx() to allow the use of refresh rates not
 * configured when card was installed, now reports refresh rate from mode table
 * instead of only "use hardware default".
 *
 *    Rev 1.9   04 May 1994 10:59:12   RWOLFF
 * Now forces memory size to 1M on all 4BPP-capable DACs when using 4BPP,
 * sets memory size back to true value when not using 4BPP.
 *
 *    Rev 1.8   27 Apr 1994 13:59:38   RWOLFF
 * Added support for paged aperture, fixed cursor colour for 4BPP.
 *
 *    Rev 1.7   26 Apr 1994 12:38:32   RWOLFF
 * Now uses a frame length of 128k when LFB is disabled.
 *
 *    Rev 1.6   31 Mar 1994 15:02:42   RWOLFF
 * Added SetPowerManagement_cx() function to implement DPMS handling,
 * added 4BPP support.
 *
 *    Rev 1.5   14 Mar 1994 16:30:58   RWOLFF
 * XMillimeter field of mode information structure now set properly, added
 * fix for 2M boundary tearing.
 *
 *    Rev 1.4   03 Mar 1994 12:37:32   ASHANMUG
 * Set palettized mode
 *
 *    Rev 1.2   03 Feb 1994 16:44:26   RWOLFF
 * Fixed "ceiling check" on right scissor register (documentation had
 * maximum value wrong). Moved initialization of hardware cursor
 * colours to after the switch into graphics mode. Colour initialization
 * is ignored if it is done before the mode switch (undocumented), but
 * this wasn't noticed earlier because most cards power up with the
 * colours already set to the values we want.
 *
 *    Rev 1.1   31 Jan 1994 16:24:38   RWOLFF
 * Fixed setting of cursor colours on cards with 68860 DAC, now fills
 * in Frequency and VideoMemoryBitmap[Width|Height] fields of mode
 * information structure. Sets Number[Red|Green|Blue]Bits fields for
 * palette modes to 6 (assumes VGA-compatible DAC) instead of 0 to allow
 * Windows NT to set the palette colours to the best match for the
 * colours to be displayed.
 *
 *    Rev 1.0   31 Jan 1994 11:10:18   RWOLFF
 * Initial revision.
 *
 *    Rev 1.3   24 Jan 1994 18:03:52   RWOLFF
 * Changes to accomodate 94/01/19 BIOS document.
 *
 *    Rev 1.2   14 Jan 1994 15:20:48   RWOLFF
 * Fixes required by BIOS version 0.13, added 1600x1200 support.
 *
 *    Rev 1.1   15 Dec 1993 15:26:30   RWOLFF
 * Clear screen only the first time we set the desired video mode.
 *
 *    Rev 1.0   30 Nov 1993 18:32:22   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
INIT_CX.C - Highest-level card-dependent routines for miniport.

DESCRIPTION
    This file contains initialization and packet handling routines
    for Mach 64-compatible ATI accelerators. Routines in this module
    are called only by routines in ATIMP.C, which is card-independent.

OTHER FILES

#endif

#include "dderror.h"

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"

#define INCLUDE_INIT_CX
#include "init_cx.h"
#include "query_cx.h"
#include "services.h"
#include "setup_cx.h"



/*
 * Prototypes for static functions.
 */
static void QuerySingleMode_cx(PVIDEO_MODE_INFORMATION ModeInformation, struct query_structure *QueryPtr, ULONG ModeIndex);
static VP_STATUS SetModeFromTable_cx(struct st_mode_table *ModeTable, VIDEO_X86_BIOS_ARGUMENTS Registers);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_CX, Initialize_cx)
#pragma alloc_text(PAGE_CX, MapVideoMemory_cx)
#pragma alloc_text(PAGE_CX, QueryPublicAccessRanges_cx)
#pragma alloc_text(PAGE_CX, QueryCurrentMode_cx)
#pragma alloc_text(PAGE_CX, QueryAvailModes_cx)
#pragma alloc_text(PAGE_CX, QuerySingleMode_cx)
#pragma alloc_text(PAGE_CX, SetCurrentMode_cx)
#pragma alloc_text(PAGE_CX, SetPalette_cx)
#pragma alloc_text(PAGE_CX, IdentityMapPalette_cx)
#pragma alloc_text(PAGE_CX, ResetDevice_cx)
#pragma alloc_text(PAGE_CX, SetPowerManagement_cx)
#pragma alloc_text(PAGE_CX, GetPowerManagement_cx)
#pragma alloc_text(PAGE_CX, SetModeFromTable_cx)
/* RestoreMemSize_cx() can't be made pageable */
#pragma alloc_text(PAGE_CX, ShareVideoMemory_cx)
/* BankMap_cx() can't be made pageable */
#endif

/***************************************************************************
 *
 * void Initialize_cx(void);
 *
 * DESCRIPTION:
 *  This routine is the Mach 64-compatible hardware initialization routine
 *  for the miniport driver. It is called once an adapter has been found
 *  and all the required data structures for it have been created.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPInitialize()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void Initialize_cx(void)
{
    DWORD Scratch;                      /* Temporary variable */
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    struct query_structure *Query;      /* Information about the graphics card */

    Query = (struct query_structure *) (phwDeviceExtension->CardInfo);
    /*
     * If the linear aperture is not configured, enable the VGA aperture.
     */
    if (phwDeviceExtension->FrameLength == 0)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Initialize_cx() switching to VGA aperture\n"));
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_APERTURE;
        Registers.Ecx = BIOS_VGA_APERTURE;
        VideoPortInt10(phwDeviceExtension, &Registers);
        }

    /*
     * Set the screen to start at the beginning of accelerator memory.
     */
    Scratch = INPD(CRTC_OFF_PITCH) & ~CRTC_OFF_PITCH_Offset;
    OUTPD(CRTC_OFF_PITCH, Scratch);

    /*
     * Disable the hardware cursor and set it up with the bitmap
     * starting at the top left corner of the 64x64 block.
     */
    Scratch = INPD(GEN_TEST_CNTL) & ~GEN_TEST_CNTL_CursorEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    OUTPD(CUR_HORZ_VERT_OFF, 0x00000000);

    /*
     * TVP3026 DAC requires special handling to disable
     * the cursor.
     */
    if (Query->q_DAC_type == DAC_TVP3026)
        {
        /*
         * Access the indirect cursor control register.
         */
        OUTP(DAC_CNTL, (BYTE)(INP(DAC_CNTL) & 0xFC));
        OUTP(DAC_REGS, 6);
        /*
         * Write the "cursor disabled" value to the
         * indexed data register.
         */
        OUTP(DAC_CNTL, (BYTE)((INP(DAC_CNTL) & 0xFC) | 2));
        OUTP_HBLW(DAC_REGS, 0);
        /*
         * Go back to using direct registers.
         */
        OUTP(DAC_CNTL, (BYTE)(INP(DAC_CNTL) & 0xFC));
        }

    VideoDebugPrint((DEBUG_NORMAL, "Initialize_cx() complete\n"));

    return;

}   /* Initialize_cx() */



/**************************************************************************
 *
 * VP_STATUS MapVideoMemory_cx(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Map the card's video memory into system memory and store the mapped
 *  address and size in OutputBuffer.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  FrameLength and PhysicalFrameAddress fields of phwDeviceExtension
 *  if linear framebuffer is not present.
 *
 * CALLED BY:
 *  IOCTL_VIDEO_MAP_VIDEO_MEMORY packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS MapVideoMemory_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;        /* Scratch variable used by VideoPortMapMemory() */
    VP_STATUS status;       /* Error code obtained from O/S calls */
    UCHAR Scratch;          /* Temporary variable */
    ULONG FrameBufferLengthSave;


    memoryInformation = RequestPacket->OutputBuffer;

    memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
        (RequestPacket->InputBuffer))->RequestedVirtualAddress;

    /*
     * The VideoRamLength field contains the amount of video memory
     * on the card. The FrameBufferLength field contains the
     * size of the aperture in bytes
     *
     * Initially assume that the linear aperture is available.
     *
     * In 4BPP, we always force the card to think it has 1M of memory.
     */
    if (QueryPtr->q_pix_depth == 4)
        memoryInformation->VideoRamLength = ONE_MEG;
    else
        memoryInformation->VideoRamLength = phwDeviceExtension->VideoRamSize;

    Scratch = QueryPtr->q_aperture_cfg & CONFIG_CNTL_LinApMask;

    if (Scratch == CONFIG_CNTL_LinAp4M)
        {
        memoryInformation->FrameBufferLength = 4 * ONE_MEG;
        }
    else if (Scratch == CONFIG_CNTL_LinAp8M)
        {
        memoryInformation->FrameBufferLength = 8 * ONE_MEG;
        }

    /*
     * If the linear aperture is not available, map in the VGA aperture
     * instead. Since the Mach 64 needs an aperture in order to use
     * the drawing registers, ATIMPFindAdapter() will have already
     * reported that it couldn't find a usable card if both the linear
     * and VGA apertures are disabled.
     */
    else if (Scratch == CONFIG_CNTL_LinApDisab)
        {
        phwDeviceExtension->FrameLength = 0x20000;
        phwDeviceExtension->PhysicalFrameAddress.LowPart = 0x0A0000;
        memoryInformation->FrameBufferLength = phwDeviceExtension->FrameLength;
        }
    inIoSpace = 0;
#if defined(ALPHA)
    /*
     * Use dense space if we can, otherwise use sparse space.
     */
    if (DenseOnAlpha(QueryPtr) == TRUE)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Using dense space for LFB\n"));
        inIoSpace = 4;
        }
#endif

    FrameBufferLengthSave = memoryInformation->FrameBufferLength;

    status = VideoPortMapMemory(phwDeviceExtension,
                    	        phwDeviceExtension->PhysicalFrameAddress,
                                &(memoryInformation->FrameBufferLength),
                                &inIoSpace,
                                &(memoryInformation->VideoRamBase));

#if defined (ALPHA)
    /*
     * VideoPortMapMemory() returns invalid FrameBufferLength
     * on the Alpha.
     */
    memoryInformation->FrameBufferLength = FrameBufferLengthSave;
#endif

    memoryInformation->FrameBufferBase    = memoryInformation->VideoRamBase;
    VideoDebugPrint((DEBUG_DETAIL, "Frame buffer mapped base = 0x%X\n", memoryInformation->VideoRamBase));

    /*
     * On some DAC/memory combinations, some modes which require more
     * than 2M of memory (1152x764 24BPP, 1280x1024 24BPP, and
     * 1600x1200 16BPP) will have screen tearing at the 2M boundary.
     *
     * As a workaround, the display driver must start the framebuffer
     * at an offset which will put the 2M boundary at the start of a
     * scanline.
     *
     * Other DAC/memory combinations are unaffected, but since this
     * fix is nearly harmless (only ill effect is to make DCI unusable
     * in these modes), we can catch all future combinations which
     * suffer from this problem by assuming that all DAC/memory
     * combinations are affected.
     */
    if ((QueryPtr->q_pix_depth == 24) &&
        (QueryPtr->q_desire_x == 1280))
        (PUCHAR)memoryInformation->FrameBufferBase += (0x40 * 8);
    else if ((QueryPtr->q_pix_depth == 24) &&
            (QueryPtr->q_desire_x == 1152))
        (PUCHAR)memoryInformation->FrameBufferBase += (0x160 * 8);
    else if ((QueryPtr->q_pix_depth == 16) &&
            (QueryPtr->q_desire_x == 1600))
        (PUCHAR)memoryInformation->FrameBufferBase += (0x90 * 8);

    return status;

}   /* MapVideoMemory_cx() */


/**************************************************************************
 *
 * VP_STATUS QueryPublicAccessRanges_cx(RequestPacket);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 *
 * DESCRIPTION:
 *  Map and return information on the video card's public access ranges.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryPublicAccessRanges_cx(PVIDEO_REQUEST_PACKET RequestPacket)
{
    PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
    PHYSICAL_ADDRESS physicalPortBase;
    ULONG physicalPortLength;

    if ( RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) )
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryPublicAccessRanges_cx() - buffer too small to handle query\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    portAccess = RequestPacket->OutputBuffer;
	
    portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
    portAccess->InIoSpace       = 1;               // In IO space
    portAccess->MappedInIoSpace = portAccess->InIoSpace;

    physicalPortBase.HighPart   = 0x00000000;
    physicalPortBase.LowPart    = GetIOBase_cx();
//    physicalPortLength          = LINEDRAW+2 - physicalPortBase.LowPart;
    /*
     * If we are using packed (relocatable) I/O, all our I/O mapped
     * registers are in a 1k block. If not, they are sparsely distributed
     * in a 32k region.
     */
    if (IsPackedIO_cx())
        physicalPortLength = 0x400;
    else
        physicalPortLength = 0x8000;

// *SANITIZE* Should report MM registers instead

    return VideoPortMapMemory(phwDeviceExtension,
                              physicalPortBase,
                              &physicalPortLength,
                              &(portAccess->MappedInIoSpace),
                              &(portAccess->VirtualAddress));

}   /* QueryPublicAccessRanges_cx() */


/**************************************************************************
 *
 * VP_STATUS QueryCurrentMode_cx(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Get screen information and colour masks for the current video mode.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryCurrentMode_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MODE_INFORMATION ModeInformation;

    /*
     * If the output buffer is too small to hold the information we need
     * to put in it, return with the appropriate error code.
     */
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        sizeof(VIDEO_MODE_INFORMATION)) )
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryCurrentMode_cx() - buffer too small to handle query\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Fill in the mode information structure.
     */
    ModeInformation = RequestPacket->OutputBuffer;

    QuerySingleMode_cx(ModeInformation, QueryPtr, phwDeviceExtension->ModeIndex);

    return NO_ERROR;

}   /* QueryCurrentMode_cx() */


/**************************************************************************
 *
 * VP_STATUS QueryAvailModes_cx(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Get screen information and colour masks for all available video modes.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_AVAIL_MODES packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryAvailModes_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MODE_INFORMATION ModeInformation;
    ULONG CurrentMode;

    /*
     * If the output buffer is too small to hold the information we need
     * to put in it, return with the appropriate error code.
     */
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        QueryPtr->q_number_modes * sizeof(VIDEO_MODE_INFORMATION)) )
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryAvailModes_cx() - buffer too small to handle query\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Fill in the mode information structure.
     */
    ModeInformation = RequestPacket->OutputBuffer;

    /*
     * For each mode supported by the card, store the mode characteristics
     * in the output buffer.
     */
    for (CurrentMode = 0; CurrentMode < QueryPtr->q_number_modes; CurrentMode++, ModeInformation++)
        QuerySingleMode_cx(ModeInformation, QueryPtr, CurrentMode);

    return NO_ERROR;

}   /* QueryCurrentMode_cx() */



/**************************************************************************
 *
 * static void QuerySingleMode_cx(ModeInformation, QueryPtr, ModeIndex);
 *
 * PVIDEO_MODE_INFORMATION ModeInformation; Table to be filled in
 * struct query_structure *QueryPtr;        Query information for the card
 * ULONG ModeIndex;                         Index of mode table to use
 *
 * DESCRIPTION:
 *  Fill in a single Windows NT mode information table using data from
 *  one of our CRT parameter tables.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  QueryCurrentMode_cx() and QueryAvailModes_cx()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static void QuerySingleMode_cx(PVIDEO_MODE_INFORMATION ModeInformation,
                              struct query_structure *QueryPtr,
                              ULONG ModeIndex)
{
    struct st_mode_table *CrtTable;     /* Pointer to current mode table */
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;
    CrtTable += ModeIndex;


    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = ModeIndex;

    ModeInformation->VisScreenWidth  = CrtTable->m_x_size;
    ModeInformation->VisScreenHeight = CrtTable->m_y_size;

    // * Bytes per line = ((pixels/line) * (bits/pixel)) / (bits/byte))
    ModeInformation->ScreenStride = (CrtTable->m_screen_pitch * CrtTable->m_pixel_depth) / 8;

    ModeInformation->NumberOfPlanes = 1;
    ModeInformation->BitsPerPlane = (USHORT) CrtTable->m_pixel_depth;

    ModeInformation->Frequency = CrtTable->Refresh;

    /*
     * Driver can't measure the screen size,
     * so take reasonable values (16" diagonal).
     */
    ModeInformation->XMillimeter = 320;
    ModeInformation->YMillimeter = 240;

    switch(ModeInformation->BitsPerPlane)
        {
        case 4:
            /*
             * Assume 6 bit DAC, since all VGA-compatible DACs support
             * 6 bit mode. Future expansion (extensive testing needed):
             * check DAC definition to see if 8 bit mode is supported,
             * and use 8 bit mode if available.
             */
            ModeInformation->RedMask   = 0x00000000;
            ModeInformation->GreenMask = 0x00000000;
            ModeInformation->BlueMask  = 0x00000000;
            ModeInformation->NumberRedBits      = 6;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 6;
            CrtTable->ColourDepthInfo = BIOS_DEPTH_4BPP;
            break;

        case 16:
            /*
             * Assume that all DACs capable of 16BPP support 565.
             */
            ModeInformation->RedMask   = 0x0000f800;
            ModeInformation->GreenMask = 0x000007e0;
            ModeInformation->BlueMask  = 0x0000001f;
            ModeInformation->NumberRedBits      = 5;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 5;
            CrtTable->ColourDepthInfo = BIOS_DEPTH_16BPP_565;
            break;

        case 24:
            /*
             * Windows NT uses RGB as the standard 24BPP mode,
             * so use this ordering unless this card only
             * supports BGR.
             */
            if (QueryPtr->q_HiColourSupport & RGB24_RGB)
                {
                ModeInformation->RedMask   = 0x00ff0000;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x000000ff;
                }
            else{
                ModeInformation->RedMask   = 0x000000ff;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x00ff0000;
                }
            CrtTable->ColourDepthInfo = BIOS_DEPTH_24BPP;
            ModeInformation->NumberRedBits      = 8;
            ModeInformation->NumberGreenBits    = 8;
            ModeInformation->NumberBlueBits     = 8;
            break;

        case 32:
            /*
             * Windows NT uses RGBx as the standard 32BPP mode,
             * so use this ordering if it's available. If it
             * isn't, use the best available colour ordering.
             */
            if (QueryPtr->q_HiColourSupport & RGB32_RGBx)
                {
                ModeInformation->RedMask   = 0xff000000;
                ModeInformation->GreenMask = 0x00ff0000;
                ModeInformation->BlueMask  = 0x0000ff00;
                CrtTable->ColourDepthInfo = BIOS_DEPTH_32BPP_RGBx;
                }
            else if (QueryPtr->q_HiColourSupport & RGB32_xRGB)
                {
                ModeInformation->RedMask   = 0x00ff0000;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x000000ff;
                CrtTable->ColourDepthInfo = BIOS_DEPTH_32BPP_xRGB;
                }
            else if (QueryPtr->q_HiColourSupport & RGB32_BGRx)
                {
                ModeInformation->RedMask   = 0x0000ff00;
                ModeInformation->GreenMask = 0x00ff0000;
                ModeInformation->BlueMask  = 0xff000000;
                CrtTable->ColourDepthInfo = BIOS_DEPTH_32BPP_BGRx;
                }
            else    /* if (QueryPtr->q_HiColourSupport & RGB32_xBGR) */
                {
                ModeInformation->RedMask   = 0x000000ff;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x00ff0000;
                CrtTable->ColourDepthInfo = BIOS_DEPTH_32BPP_xBGR;
                }
            ModeInformation->NumberRedBits      = 8;
            ModeInformation->NumberGreenBits    = 8;
            ModeInformation->NumberBlueBits     = 8;
            break;

        case 8:
        default:
            /*
             * Assume 6 bit DAC, since all VGA-compatible DACs support
             * 6 bit mode. Future expansion (extensive testing needed):
             * check DAC definition to see if 8 bit mode is supported,
             * and use 8 bit mode if available.
             */
            ModeInformation->RedMask   = 0x00000000;
            ModeInformation->GreenMask = 0x00000000;
            ModeInformation->BlueMask  = 0x00000000;
            ModeInformation->NumberRedBits      = 6;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 6;
            CrtTable->ColourDepthInfo = BIOS_DEPTH_8BPP;
            break;
        }

    ModeInformation->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;

    if (CrtTable->m_pixel_depth <= 8)
        {
        ModeInformation->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
            VIDEO_MODE_MANAGED_PALETTE;
        }

    /*
     * On "canned" mode tables,bit 4 of the m_disp_cntl field is set
     * for interlaced modes and cleared for noninterlaced modes.
     *
     * The display applet gets confused if some of the "Use hardware
     * default" modes are interlaced and some are noninterlaced
     * (two "Use hardware default" entries are shown in the refresh
     * rate list). To avoid this, report all mode tables stored in
     * the EEPROM as noninterlaced, even if they are interlaced.
     * "Canned" mode tables give true reports.
     *
     * If the display applet ever gets fixed, configured mode tables
     * have (CrtTable->control & (CRTC_GEN_CNTL_Interlace << 8)) nonzero
     * for interlaced and zero for noninterlaced.
     */
    if (CrtTable->Refresh == DEFAULT_REFRESH)
        {
        ModeInformation->AttributeFlags &= ~VIDEO_MODE_INTERLACED;
        }
    else
        {
        if (CrtTable->m_disp_cntl & 0x010)
            {
            ModeInformation->AttributeFlags |= VIDEO_MODE_INTERLACED;
            }
        else
            {
            ModeInformation->AttributeFlags &= ~VIDEO_MODE_INTERLACED;
            }
        }

    /*
     * Fill in the video memory bitmap width and height fields.
     * The descriptions are somewhat ambiguous - assume that
     * "bitmap width" is the same as ScreenStride (bytes from
     * start of one scanline to start of the next) and "bitmap
     * height" refers to the number of complete scanlines which
     * will fit into video memory.
     */
    ModeInformation->VideoMemoryBitmapWidth = ModeInformation->ScreenStride;
    ModeInformation->VideoMemoryBitmapHeight = (QueryPtr->q_memory_size * QUARTER_MEG) / ModeInformation->VideoMemoryBitmapWidth;

    return;

}   /* QuerySingleMode_m() */

VOID
EnableOldMach64MouseCursor(
    PHW_DEVICE_EXTENSION pHwDeviceExtension
    )
{
    ULONG   temp;

    VideoDebugPrint((1, "Enabling the cursor\n"));
    temp  = INPD(GEN_TEST_CNTL);
    temp |= GEN_TEST_CNTL_CursorEna;

    OUTPD(GEN_TEST_CNTL, temp);
}



/**************************************************************************
 *
 * VP_STATUS SetCurrentMode_cx(QueryPtr, CrtTable);
 *
 * struct query_structure *QueryPtr;    Query information for the card
 * struct st_mode_table *CrtTable;      CRT parameter table for desired mode
 *
 * DESCRIPTION:
 *  Switch into the specified video mode.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * NOTE:
 *  In the event of an error return by one of the services we call,
 *  there is no indication in our error return of which service failed,
 *  only the fact that one failed and the error code it returned. If
 *  a checked version of the miniport is being run under the kernel
 *  debugger, an indication will be printed to the debug terminal.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  96 05 15    Now checks return values from INT 10 calls.
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS SetCurrentMode_cx(struct query_structure *QueryPtr, struct st_mode_table *CrtTable)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    ULONG WidthToClear;                 /* Screen width (in pixels) to clear */
    ULONG ScreenPitch;                  /* Pitch in units of 8 pixels */
    ULONG ScreenOffset = 0;             /* Byte offset - varies with display mode */
    ULONG PixelDepth;                   /* Colour depth of screen */
    ULONG HorScissors;                  /* Horizontal scissor values */
    ULONG Scratch;                      /* Temporary variable */
    int CursorProgOffset;               /* Offset of DAC register used to program the cursor */
    VP_STATUS RetVal;                   /* Value returned by routines called */

    /*
     * Early versions of the Mach 64 BIOS have a bug where not all registers
     * are set when initializing an accelerator mode. These registers are
     * set when going into the 640x480 8BPP VGAWonder mode.
     *
     * All VGA disabled cards were built after this bug was fixed, so
     * this mode switch is not necessary for them. On these cards, we
     * must not do the mode switch, since it will affect the VGA enabled
     * card rather than the card we are working on.
     */
    if (phwDeviceExtension->BiosPrefix == BIOS_PREFIX_VGA_ENAB)
        {
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = 0x62;
        RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed SVGA mode set\n"));
            return RetVal;
            }
        }

    /*
     * Setting the linear aperture using the BIOS call will set
     * a 4M aperture on 2M and lower cards, and an 8M aperture
     * on 4M cards. Since we force the memory size to 1M in
     * 4BPP modes (workaround for a hardware bug), this can
     * result in writing to the wrong location for memory mapped
     * registers if we switch between 4BPP and other depths
     * (typically when testing a new mode) on a 4M card.
     *
     * To avoid this, set the memory size to its "honest" value
     * before enabling the linear aperture. If we need to cut
     * back to 1M, we will do this after the aperture is set.
     * This will result in the aperture always being the same
     * size, so the memory mapped registers will always be
     * in the same place.
     *
     * When using the VGA aperture, we must set the "honest" value
     * after enabling the aperture but before setting the mode.
     * Otherwise, the system will hang when testing a mode that
     * needs more than 1M of memory from a 4BPP mode.
     *
     * If the linear aperture is not configured, enable the VGA aperture.
     */
    if (QueryPtr->q_aperture_cfg != 0)
        {
        RestoreMemSize_cx();
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_APERTURE;
        Registers.Ecx = BIOS_LINEAR_APERTURE;
        RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed to enable linear aperture\n"));
            return RetVal;
            }
        }
    else
        {
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_APERTURE;
        Registers.Ecx = BIOS_VGA_APERTURE;
        RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed to enable VGA aperture\n"));
            return RetVal;
            }
        OUTP(VGA_GRAX_IND, 6);
        OUTP(VGA_GRAX_DATA, (BYTE)(INP(VGA_GRAX_DATA) & 0xF3));
        }

    /*
     * Now we can set the accelerator mode.
     */
    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_LOAD_SET;

    /*
     * ECX register holds colour depth, gamma correction enable/disable
     * (not used in NT miniport), pitch size, and resolution.
     */
    Registers.Ecx = CrtTable->ColourDepthInfo;

    /*
     * Screen pitch differs from horizontal resolution only when using the
     * VGA aperture and horizontal resolution is less than 1024.
     */
    if ((CrtTable->m_screen_pitch == 1024) && (CrtTable->m_x_size < 1024))
        Registers.Ecx |= BIOS_PITCH_1024;
    else
        Registers.Ecx |= BIOS_PITCH_HOR_RES;

    /*
     * On the 68860 DAC and ?T internal DACs, we must enable gamma
     * correction for all pixel depths where the palette is not used.
     */
    if (((QueryPtr->q_DAC_type == DAC_ATI_68860) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_CT) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_GT) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_VT)) &&
        (QueryPtr->q_pix_depth > 8))
        {
        Registers.Ecx |= BIOS_ENABLE_GAMMA;
        }
    /*
     * Fix 4bpp bugs by setting memory size to 1Meg. We do not
     * need to switch back to the "honest" memory size for
     * other pixel depths unless we are using the VGA aperture,
     * since this was done for linear apertures before we enabled
     * the aperture in order to ensure the same aperture size
     * (and therefore the same locations for memory mapped
     * registers) is used for all modes.
     */
    else if (QueryPtr->q_pix_depth == 4)
        {
        OUTPD(MEM_CNTL, (INPD(MEM_CNTL) & ~MEM_CNTL_MemSizeMsk) | MEM_CNTL_MemSize1Mb);
        }
    else if (QueryPtr->q_aperture_cfg == 0)
        {
        RestoreMemSize_cx();
        }

    switch(CrtTable->m_x_size)
        {
        case 640:
            Registers.Ecx |= BIOS_RES_640x480;
            break;

        case 800:
            Registers.Ecx |= BIOS_RES_800x600;
            break;

        case 1024:
            Registers.Ecx |= BIOS_RES_1024x768;
            break;

        case 1152:
            /*
             * Only "Other" mode that the config program will
             * install for production cards.
             */
            Registers.Ecx |= BIOS_RES_OEM;
            break;

        case 1280:
            Registers.Ecx |= BIOS_RES_1280x1024;
            break;

        case 1600:
            Registers.Ecx |= BIOS_RES_1600x1200;
            break;
        }

    if (CrtTable->Refresh == DEFAULT_REFRESH)
        {
        RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed mode set for default refresh\n"));
            return RetVal;
            }
        if (phwDeviceExtension->BiosPrefix != BIOS_PREFIX_VGA_ENAB)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Have set hardware default refresh on VGA-disabled card\n"));
            /*
             * On VGA-disabled cards, the INT 10 call will leave the
             * DAC mask set to 0x00 (in palette modes, treat all pixels
             * as if they are colour 0, regardless of what colour they
             * really are). We must set it to 0xFF (in palette modes,
             * use all bits of the value written to each pixel) in order
             * to get the screen to display properly. This has no effect
             * on non-palette (16BPP and higher) modes.
             */
            OUTP_LBHW(DAC_REGS, 0xFF);  /* DAC_MASK */
            }
        }
    else
        {
        RetVal = SetModeFromTable_cx(CrtTable, Registers);
        if (RetVal != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed call to SetModeFromTable_cx()\n"));
            return RetVal;
            }
        }

    /*
     * If the LFB is disabled, and we had to round up the pitch
     * to 2048 (1152x864, 1280x1024, or 1600x1200), set the pitch
     * registers manually, because there's no option in the
     * INT 10 call to set them to anything other than 1024 or the
     * screen width.
     */
    if (CrtTable->m_screen_pitch == 2048)
        {
        OUTPD(CRTC_OFF_PITCH, ((INPD(CRTC_OFF_PITCH) & 0x000FFFFF) | ((2048/8) << 22)));
        OUTPD(SRC_OFF_PITCH, ((INPD(SRC_OFF_PITCH) & 0x000FFFFF) | ((2048/8) << 22)));
        OUTPD(DST_OFF_PITCH, ((INPD(DST_OFF_PITCH) & 0x000FFFFF) | ((2048/8) << 22)));
        }
    /*
     * On 800x600, we must round the pitch up to a multiple of 64 to avoid
     * screen warping on some DACs. Set the pitch registers to correspond
     * to this.
     */
    else if (CrtTable->m_screen_pitch == 832)
        {
        OUTPD(CRTC_OFF_PITCH, ((INPD(CRTC_OFF_PITCH) & 0x000FFFFF) | ((832/8) << 22)));
        OUTPD(SRC_OFF_PITCH, ((INPD(SRC_OFF_PITCH) & 0x000FFFFF) | ((832/8) << 22)));
        OUTPD(DST_OFF_PITCH, ((INPD(DST_OFF_PITCH) & 0x000FFFFF) | ((832/8) << 22)));
        }


    /*
     * Set up the hardware cursor with colour 0 black and colour 1 white.
     * Do this here rather than in Initialize_cx() because the cursor
     * colours don't "take" unless we are in accelerator mode.
     *
     * On cards with 68860 DACs, the CUR_CLR0/1 registers don't set
     * the cursor colours. Instead, the colours must be set using the
     * DAC_CNTL and DAC_REGS registers. The cursor colour settings
     * are independent of pixel depth because the 68860 doesn't
     * support 4BPP, which is the only depth that requires a different
     * setting for the cursor colours.
     *
     * Cursor colour initialization is done unconditionally, rather than
     * only on the first graphics mode set, because otherwise testing a
     * different pixel depth (most commonly testing 1024x768 4BPP when
     * 1024x768 16BPP configured) may corrupt the cursor colours.
     */
    if ((QueryPtr->q_DAC_type == DAC_ATI_68860) ||
        (QueryPtr->q_DAC_type == DAC_TVP3026) ||
        (QueryPtr->q_DAC_type == DAC_IBM514))
        {
        OUTP(DAC_CNTL, (BYTE)((INP(DAC_CNTL) & 0xFC) | 1));

        /*
         * On TVP3026 DAC, skip the OVERSCAN colour register.
         */
        if (QueryPtr->q_DAC_type == DAC_TVP3026)
            {
            OUTP(DAC_REGS, 1);
            CursorProgOffset = 1;   /* DAC_DATA */
            }
        else if (QueryPtr->q_DAC_type == DAC_ATI_68860)
            {
            OUTP(DAC_REGS, 0);
            CursorProgOffset = 1;   /* DAC_DATA */
            }
        else /* if (QueryPtr->q_DAC_type == DAC_IBM514) */
            {
            OUTP_HBHW(DAC_REGS, 1);     /* Auto-increment */
            OUTP(DAC_REGS, 0x40);
            OUTP_HBLW(DAC_REGS, 0);
            CursorProgOffset = 2;   /* DAC_MASK */
            }

        LioOutp(DAC_REGS, 0, CursorProgOffset);     /* Colour 0 red */
        LioOutp(DAC_REGS, 0, CursorProgOffset);     /* Colour 0 green */
        LioOutp(DAC_REGS, 0, CursorProgOffset);     /* Colour 0 blue */

        LioOutp(DAC_REGS, 0xFF, CursorProgOffset);  /* Colour 1 red */
        LioOutp(DAC_REGS, 0xFF, CursorProgOffset);  /* Colour 1 green */
        LioOutp(DAC_REGS, 0xFF, CursorProgOffset);  /* Colour 1 blue */


        OUTP(DAC_CNTL, (BYTE)((INP(DAC_CNTL) & 0xFC)));
        }

    else    /* if (DAC not one of ATI68860, TVP3026, or IBM514) */
        {
        OUTPD(CUR_CLR0, 0x00000000);
        /*
         * On most Mach 64 cards, we must use only the lower 4 bits
         * when setting up the white part of the cursor. On the
         * ?T, however, we must set all 8 bits for each of the colour
         * components.
         *
         * Verify that the VT/GT still need this after the final ASIC
         * becomes available.
         */
        if ((QueryPtr->q_pix_depth == 4) &&
            (QueryPtr->q_DAC_type != DAC_INTERNAL_CT) &&
            (QueryPtr->q_DAC_type != DAC_INTERNAL_GT) &&
            (QueryPtr->q_DAC_type != DAC_INTERNAL_VT))
            {
            OUTPD(CUR_CLR1, 0x0F0F0F0F);
            }
        else
            {
            OUTPD(CUR_CLR1, 0xFFFFFFFF);
            }

        }

    /*
     * phwDeviceExtension->ReInitializing becomes TRUE in
     * IOCTL_VIDEO_SET_COLOR_REGISTERS packet of ATIMPStartIO().
     *
     * If this is the first time we are going into graphics mode,
     * Turn on the graphics engine. Otherwise, set the palette
     * to the last set of colours that was selected while in
     * accelerator mode.
     */
    if (phwDeviceExtension->ReInitializing)
        {
        SetPalette_cx(phwDeviceExtension->Clut,
                      phwDeviceExtension->FirstEntry,
                      phwDeviceExtension->NumEntries);
        }
    else
        {

        /*
         * Turn on the graphics engine.
         */
        OUTPD(GEN_TEST_CNTL, (INPD(GEN_TEST_CNTL) | GEN_TEST_CNTL_GuiEna));
        }

    /*
     * If we are using a 68860 DAC or ?T internal DAC in a non-palette
     * mode, identity map the palette.
     */
    if (((QueryPtr->q_DAC_type == DAC_ATI_68860) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_CT) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_GT) ||
        (QueryPtr->q_DAC_type == DAC_INTERNAL_VT)) &&
        (QueryPtr->q_pix_depth > 8))
        IdentityMapPalette_cx();


    /*
     * Clear the screen regardless of whether or not this is the
     * first time we are going into graphics mode. This is done
     * because in 3.50 and later releases of Windows NT, the
     * screen will be filled with garbage if we don't clear it.
     *
     * 24BPP is not a legal setting for DP_DST_PIX_WID@DP_PIX_WID.
     * Instead, use 8BPP, but tell the engine that the screen is
     * 3 times as wide as it actually is.
     */
    if (CrtTable->ColourDepthInfo == BIOS_DEPTH_24BPP)
        {
        WidthToClear = CrtTable->m_x_size * 3;
        ScreenPitch = (CrtTable->m_screen_pitch * 3) / 8;
        PixelDepth = BIOS_DEPTH_8BPP;
        /*
         * Horizontal scissors are only valid in the range
         * -4096 to +4095. If the horizontal resolution
         * is high enough to put the scissor outside this
         * range, clamp the scissors to the maximum
         * permitted value.
         */
        HorScissors = QueryPtr->q_desire_x * 3;
        if (HorScissors > 4095)
            HorScissors = 4095;
        HorScissors <<= 16;
        }
    else
        {
        WidthToClear = CrtTable->m_x_size;
        ScreenPitch = CrtTable->m_screen_pitch / 8;
        PixelDepth = CrtTable->ColourDepthInfo;
        HorScissors = (QueryPtr->q_desire_x) << 16;
        }

    /*
     * On some DAC/memory combinations, some modes which require more
     * than 2M of memory (1152x764 24BPP, 1280x1024 24BPP, and
     * 1600x1200 16BPP) will have screen tearing at the 2M boundary.
     *
     * As a workaround, the offset field of all 3 CRTC/SRC/DST_OFF_PITCH
     * registers must be set to put the 2M boundary at the start
     * of a scanline.
     *
     * Other DAC/memory combinations are unaffected, but since this
     * fix is nearly harmless (only ill effect is to make DCI unusable
     * in these modes), we can catch all future combinations which
     * suffer from this problem by assuming that all DAC/memory
     * combinations are affected.
     */
    if ((QueryPtr->q_pix_depth == 24) &&
        (QueryPtr->q_desire_x == 1280))
        {
        ScreenOffset = 0x40;
        }
    else if ((QueryPtr->q_pix_depth == 24) &&
            (QueryPtr->q_desire_x == 1152))
        {
        ScreenOffset = 0x160;
        }
    else if ((QueryPtr->q_pix_depth == 16) &&
            (QueryPtr->q_desire_x == 1600))
        {
        ScreenOffset = 0x90;
        }
    else /* all other DAC/resolution/pixel depth combinations */
        {
        ScreenOffset = 0;
        }

    CheckFIFOSpace_cx(TWO_WORDS);
    Scratch = INPD(CRTC_OFF_PITCH) & ~CRTC_OFF_PITCH_Offset;
    Scratch |= ScreenOffset;
    OUTPD(CRTC_OFF_PITCH, Scratch);
    Scratch = INPD(SRC_OFF_PITCH) & ~SRC_OFF_PITCH_Offset;
    Scratch |= ScreenOffset;
    OUTPD(SRC_OFF_PITCH, Scratch);


    /*
     * The pixel widths for destination,
     * source, and host must be the same.
     */
    PixelDepth |= ((PixelDepth << 8) | (PixelDepth << 16));

    CheckFIFOSpace_cx(ELEVEN_WORDS);

    OUTPD(DP_WRITE_MASK, 0xFFFFFFFF);
    OUTPD(DST_OFF_PITCH, (ScreenPitch << 22) | ScreenOffset);
    OUTPD(DST_CNTL, (DST_CNTL_XDir | DST_CNTL_YDir));
    OUTPD(DP_PIX_WIDTH, PixelDepth);
    OUTPD(DP_SRC, (DP_FRGD_SRC_FG | DP_BKGD_SRC_BG | DP_MONO_SRC_ONE));
    OUTPD(DP_MIX, ((MIX_FN_PAINT << 16) | MIX_FN_PAINT));
    OUTPD(DP_FRGD_CLR, 0x0);
    OUTPD(SC_LEFT_RIGHT, HorScissors);
    OUTPD(SC_TOP_BOTTOM, (CrtTable->m_y_size) << 16);
    OUTPD(DST_Y_X, 0);
    OUTPD(DST_HEIGHT_WIDTH, (WidthToClear << 16) | CrtTable->m_y_size);

    if (WaitForIdle_cx() == FALSE)
        {
        VideoDebugPrint((DEBUG_ERROR, "SetCurrentMode_cx() failed WaitForIdle_cx()\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    return NO_ERROR;

}   /* SetCurrentMode_cx() */


/***************************************************************************
 *
 * void SetPalette_cx(lpPalette, StartIndex, Count);
 *
 * PPALETTEENTRY lpPalette;     Colour values to plug into palette
 * USHORT StartIndex;           First palette entry to set
 * USHORT Count;                Number of palette entries to set
 *
 * DESCRIPTION:
 *  Set the desired number of palette entries to the specified colours,
 *  starting at the specified index. Colour values are stored in
 *  doublewords, in the order (low byte to high byte) RGBx.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_cx() and IOCTL_VIDEO_SET_COLOR_REGISTERS packet
 *  of ATIMPStartIO()
 *
 * AUTHOR:
 *  unknown
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void SetPalette_cx(PULONG lpPalette, USHORT StartIndex, USHORT Count)
{
int   i;
BYTE *pPal=(BYTE *)lpPalette;
struct query_structure *Query;      /* Information about the graphics card */

    Query = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * In the current rev of the 88800GX, the memory mapped access
     * to the DAC_REGS register is broken but the I/O mapped access
     * works properly. Force the use of the I/O mapped access.
     */
    phwDeviceExtension->aVideoAddressMM[DAC_REGS] = 0;

    /*
     * If a video capture card is hooked up to the feature connector,
     * it will only "see" the palette being set if we use the VGA
     * palette registers. This applies only in 4 and 8BPP, and is
     * not necessary for when we identity map the palette (needed
     * on certain DACs in 16BPP and above).
     *
     * In a multi-headed setup, only the card with the VGA enabled is
     * able to be programmed using the VGA registers. All others must
     * be programmed using the accelerator registers. Since this is
     * the only card where we can hook up a video capture card to the
     * feature connector, we don't lose "snooping" capability by
     * programming VGA-disabled cards through the accelerator registers.
     */
    if ((Query->q_pix_depth <= 8) && (phwDeviceExtension->BiosPrefix == BIOS_PREFIX_VGA_ENAB))
        {
        VideoDebugPrint((DEBUG_DETAIL, "Setting palette via VGA registers\n"));
        /*
         * DAC_W_INDEX is 8 bytes into second block of VGA registers.
         * We do not have a separate OUTP()able register for this one.
         */
        LioOutp(VGA_END_BREAK_PORT, (BYTE)StartIndex, 8);

            for (i=0; i<Count; i++)     /* this is number of colours to update */
                {
            /*
             * DAC_DATA is 9 bytes into second block of VGA registers.
             * We do not have a separate OUTP()able register for this one.
             */
            LioOutp(VGA_END_BREAK_PORT, *pPal++, 9);    /* red */
            LioOutp(VGA_END_BREAK_PORT, *pPal++, 9);    /* green */
            LioOutp(VGA_END_BREAK_PORT, *pPal++, 9);    /* blue */
            pPal++;
                }
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "Setting palette via accelerator registers\n"));
        OUTP(DAC_REGS,(BYTE)StartIndex);    /* load DAC_W_INDEX@DAC_REGS with StartIndex */

            for (i=0; i<Count; i++)     /* this is number of colours to update */
                {
            /*
             * DAC_DATA@DAC_REGS is high byte of low word.
             */
            OUTP_HBLW(DAC_REGS, *pPal++);   /* red */
                OUTP_HBLW(DAC_REGS, *pPal++);   /* green */
                OUTP_HBLW(DAC_REGS, *pPal++);   /* blue */
            pPal++;
                }
        }

    /*
     * Victor Tango requires a few registers to be re-initialized after
     * setting the palette.
     */
    if (Query->q_DAC_type == DAC_INTERNAL_VT)
        {
        OUTP_LBHW(DAC_REGS, 0xFF);  /* DAC_MASK */
        OUTP(DAC_REGS, 0xFF);       /* DAC_W_INDEX */
        }

    return;

}   /* SetPalette_cx() */



/***************************************************************************
 *
 * void IdentityMapPalette_cx(void);
 *
 * DESCRIPTION:
 *  Set the entire palette to a grey scale whose intensity at each
 *  index is equal to the index value.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_cx()
 *
 * AUTHOR:
 *  unknown
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void IdentityMapPalette_cx(void)
{
unsigned long Index;
struct query_structure *Query;      /* Information about the graphics card */

    Query = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * In the current rev of the 88800GX, the memory mapped access
     * to the DAC_REGS register is broken but the I/O mapped access
     * works properly. Force the use of the I/O mapped access.
     */
    phwDeviceExtension->aVideoAddressMM[DAC_REGS] = 0;

	 OUTP(DAC_REGS, 0);      // Start at first palette entry.

	 for (Index=0; Index<256; Index++)   // Fill the whole palette.
        {
        /*
         * DAC_DATA@DAC_REGS is high byte of low word.
         */
             OUTP_HBLW(DAC_REGS,(BYTE)(Index));      // red
             OUTP_HBLW(DAC_REGS,(BYTE)(Index));      // green
             OUTP_HBLW(DAC_REGS,(BYTE)(Index));      // blue
        }

    /*
     * Victor Tango requires a few registers to be re-initialized after
     * setting the palette.
     */
    if (Query->q_DAC_type == DAC_INTERNAL_VT)
        {
        OUTP_LBHW(DAC_REGS, 0xFF);  /* DAC_MASK */
        OUTP(DAC_REGS, 0xFF);       /* DAC_W_INDEX */
        }

    return;

}   /* IdentityMapPalette_cx() */



/**************************************************************************
 *
 * void ResetDevice_cx(void);
 *
 * DESCRIPTION:
 *  Switch back to VGA mode.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_RESET_DEVICE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void ResetDevice_cx(void)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    ULONG Scratch;


    VideoDebugPrint((DEBUG_NORMAL, "ResetDevice_cx() - entry\n"));

    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_SET_MODE;
    Registers.Ecx = BIOS_MODE_VGA;
    VideoPortInt10(phwDeviceExtension, &Registers);

    VideoDebugPrint((DEBUG_DETAIL, "ResetDevice_cx() - VGA controls screen\n"));

    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = 0x3;
    VideoPortInt10(phwDeviceExtension, &Registers);

    VideoDebugPrint((DEBUG_NORMAL, "ResetDevice_cx() - exit\n"));

    return;

}   /* ResetDevice_cx() */



/**************************************************************************
 *
 * DWORD GetPowerManagement_cx();
 *
 * DESCRIPTION:
 *  Determine our current DPMS state.
 *
 * RETURN VALUE:
 *  Current DPMS state (VIDEO_POWER_STATE enumeration)
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPGetPower()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

DWORD GetPowerManagement_cx(PHW_DEVICE_EXTENSION phwDeviceExtension)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */

    ASSERT(phwDeviceExtension != NULL);

    /*
     * Invoke the BIOS call to get the desired DPMS state. The BIOS call
     * enumeration of DPMS states is in the same order as that in
     * VIDEO_POWER_STATE, but it is zero-based instead of one-based.
     */
    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_GET_DPMS;
    VideoPortInt10(phwDeviceExtension, &Registers);

    return (Registers.Ecx + 1);
}   /* GetPowerManagement_cx() */


/**************************************************************************
 *
 * VP_STATUS SetPowerManagement_cx(DpmsState);
 *
 *  DWORD DpmsState;    Desired DPMS state (VIDEO_POWER_STATE enumeration)
 *
 * DESCRIPTION:
 *  Switch into the desired DPMS state.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  ERROR_INVALID_PARAMETER if invalid state requested.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_POWER_MANAGEMENT packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS SetPowerManagement_cx(DWORD DpmsState)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */

    /*
     * Only accept valid states.
     */
    if ((DpmsState < VideoPowerOn) || (DpmsState > VideoPowerOff))
        {
        VideoDebugPrint((DEBUG_ERROR, "SetPowerManagement_cx - invalid DPMS state selected\n"));
        return ERROR_INVALID_PARAMETER;
        }

    /*
     * Invoke the BIOS call to set the desired DPMS state. The BIOS call
     * enumeration of DPMS states is in the same order as that in
     * VIDEO_POWER_STATE, but it is zero-based instead of one-based.
     */
    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = BIOS_SET_DPMS;
    Registers.Ecx = DpmsState - 1;
    VideoPortInt10(phwDeviceExtension, &Registers);

    return NO_ERROR;

}   /* SetPowerManagement_cx() */





/**************************************************************************
 *
 * static VP_STATUS SetModeFromTable_cx(ModeTable, Registers);
 *
 * struct st_mode_table *ModeTable;     Mode table to set up screen from
 * VIDEO_X86_BIOS_ARGUMENTS Registers;  Registers for INT 10 call
 *
 * DESCRIPTION:
 *  Switch into the graphics mode specified by ModeTable.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_cx()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  96 05 15    Now checks return values from INT 10 calls.
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static VP_STATUS SetModeFromTable_cx(struct st_mode_table *ModeTable, VIDEO_X86_BIOS_ARGUMENTS Registers)
{
#define TBL_SET_BUFFER_SIZE 100

    PUCHAR MappedBuffer;                    /* Pointer to buffer used for BIOS query */
    struct cx_bios_set_from_table *CxTable; /* Mode table in Mach 64 BIOS format */
    ULONG Scratch;                          /* Temporary variable */
    struct query_structure *QueryPtr;       /* Query information for the card */
    VIDEO_X86_BIOS_ARGUMENTS TempRegs;      /* Used in setting 640x480 8BPP to enable LFB */
    BOOL FlippedPrimrary = FALSE;           /* TRUE if we switched to VGA aperture on primrary card */
    UCHAR SavedScreen[TBL_SET_BUFFER_SIZE]; /* Used to restore contents of primrary screen */
    VP_STATUS RetVal;                       /* Value returned by routines called */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * To set the video mode from a table, we need to write the mode table
     * to a buffer in physical memory below 1M. The nature of this block
     * falls into one of two cases:
     *
     * Primrary (VGA enabled) card:
     *  We have already switched into video mode 0x62 (VGA 640x480 8BPP)
     *  to set up registers that under some circumstances are not set up
     *  by the accelerator mode set, so we have access to a 64k block
     *  starting at 0xA0000 which is backed by physical (video) memory
     *  and which we can write to without corrupting code and/or data
     *  being used by other processes.
     *
     * Secondary (VGA disabled) card:
     *  There is a VGA enabled card in the machine, which falls into
     *  one of five sub-cases:
     *
     *  1. VGA is in colour text mode
     *     We can use the offscreen portion of the buffer, and it doesn't
     *     matter whether or not the card is a Mach 64.
     *
     *  2. VGA is in mono text mode
     *     We can use the offscreen portion of the buffer, and it doesn't
     *     matter whether or not the card is a Mach 64.
     *
     *  3. VGA is in graphics mode
     *     We can use the beginning of the graphics screen, and it doesn't
     *     matter whether or not the card is a Mach 64.
     *
     *  4. VGA-enabled card is a Mach 64 in accelerator mode
     *     We can temporarily flip the primrary card's aperture status
     *     from LFB to VGA aperture, and use the start of the VGA
     *     aperture.
     *
     *  5. VGA-enabled card is another brand of accelerator, in accelerator mode
     *     This case should never occur, since NT should only run one video
     *     driver with VgaCompatible set to zero. If it is the ATI driver,
     *     a non-ATI card should not be in accelerator mode. If it is the
     *     driver for the non-ATI card, we will never receive a request
     *     to change into an accelerator mode on our card.
     *
     * We don't need to claim the whole block, but we should claim a bit
     * more than the size of the mode table so the BIOS won't try to access
     * unclaimed memory.
     */
    if (phwDeviceExtension->BiosPrefix == BIOS_PREFIX_VGA_ENAB)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Setting mode on primrary card\n"));
        MappedBuffer = MapFramebuffer(0xA0000, TBL_SET_BUFFER_SIZE);
        if (MappedBuffer == 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed MapFramebuffer()\n"));
            return ERROR_INSUFFICIENT_BUFFER;
            }
        /*
         * Tell the BIOS to load the CRTC parameters from a table,
         * rather than using the configured refresh rate for this
         * resolution, and let it know where the table is.
         */
        Registers.Eax = BIOS_LOAD_SET;
        Registers.Edx = 0xA000;
        Registers.Ebx = 0x0000;
        Registers.Ecx &= ~BIOS_RES_MASK;    /* Mask out code for configured resolution */
        Registers.Ecx |= BIOS_RES_BUFFER;
        }
    else
        {
        /*
         * This is a VGA disabled card. First try sub-cases 1 through 3.
         */
        VideoDebugPrint((DEBUG_NORMAL, "Setting mode on secondary card\n"));

        MappedBuffer = GetVgaBuffer(TBL_SET_BUFFER_SIZE, 0, &(Registers.Edx), SavedScreen);

        /*
         * If we were unable to map the buffer, assume we are dealing
         * with sub-case 4. We can't distinguish between sub-cases
         * 4 and 5, since the code to report an error if we issue an
         * invalid BIOS call is in the ATI video BIOS, which won't
         * be present in sub-case 5. Users in this sub-case are on
         * their own.
         *
         * For sub-case 4 (VGA-enabled card is a Mach 64 in accelerator
         * mode), temporarily flip from LFB mode to VGA aperture mode
         * so we can use the VGA aperture without destroying the contents
         * of the screen.
         */
        if (MappedBuffer == 0)
            {
            FlippedPrimrary = TRUE;
            VideoDebugPrint((DEBUG_DETAIL, "Temporary setting primrary card to VGA aperture\n"));
            VideoPortZeroMemory(&TempRegs, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
            TempRegs.Eax = BIOS_PREFIX_VGA_ENAB | BIOS_APERTURE_LB;
            TempRegs.Ecx = BIOS_VGA_APERTURE;
            RetVal = VideoPortInt10(phwDeviceExtension, &TempRegs);
            if (RetVal != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed VGA-enabled flip to VGA aperture\n"));
                return RetVal;
                }
            MappedBuffer = MapFramebuffer(0xA0000, TBL_SET_BUFFER_SIZE);
            if (MappedBuffer == 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed to map buffer on VGA-enabled card\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Registers.Edx = 0xA000;

            /*
             * Save the contents of the buffer so that we can restore it
             * after we finish the mode set.
             */
            for (Scratch = 0; Scratch < TBL_SET_BUFFER_SIZE; Scratch++)
                SavedScreen[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
            }

        /*
         * Tell the BIOS to load the CRTC parameters from a table,
         * rather than using the configured refresh rate for this
         * resolution, and let it know where the table is.
         */
        Registers.Eax = BIOS_LOAD_SET;
        Registers.Ebx = 0x0000;
        Registers.Ecx &= ~BIOS_RES_MASK;    /* Mask out code for configured resolution */
        Registers.Ecx |= BIOS_RES_BUFFER;

        }   /* end if (VGA disabled card) */

    CxTable = (struct cx_bios_set_from_table *)MappedBuffer;

    /*
     * Copy the mode table into the Mach 64 format table. First handle
     * the fields that only require shifting and masking.
     */
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_mode_select), (WORD)((Registers.Ecx & BIOS_RES_MASK) | CX_BS_MODE_SELECT_ACC));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_h_tot_disp), (WORD)((ModeTable->m_h_disp << 8) | ModeTable->m_h_total));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_h_sync_strt_wid), (WORD)((ModeTable->m_h_sync_wid << 8) | ModeTable->m_h_sync_strt));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_sync_wid), (WORD)(ModeTable->m_v_sync_wid | CX_BS_V_SYNC_WID_CLK));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_h_overscan), ModeTable->m_h_overscan);
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_overscan), ModeTable->m_v_overscan);
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_overscan_8b), ModeTable->m_overscan_8b);
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_overscan_gr), ModeTable->m_overscan_gr);

    /*
     * Next take care of fields which must be translated from our
     * "canned" mode tables.
     *
     * The cx_crtc_gen_cntl field has only 3 bits that we use: interlace,
     * MUX mode (all 1280x1024 noninterlaced modes), and force use of
     * all parameters from the table (this bit is used by all the
     * "canned" tables).
     */
    if ((ModeTable->m_disp_cntl) & 0x10)
        VideoPortWriteRegisterUshort(&(CxTable->cx_bs_flags), CX_BS_FLAGS_INTERLACED | CX_BS_FLAGS_ALL_PARMS);
    else if ((ModeTable->m_x_size > 1024) && (ModeTable->ClockFreq >= 100000000L))
        VideoPortWriteRegisterUshort(&(CxTable->cx_bs_flags), CX_BS_FLAGS_MUX | CX_BS_FLAGS_ALL_PARMS);
    else
        VideoPortWriteRegisterUshort(&(CxTable->cx_bs_flags), CX_BS_FLAGS_ALL_PARMS);
    /*
     * Vertical parameters other than sync width are in skip-2 in
     * the "canned" tables, but need to be in linear form for the Mach 64.
     */
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_total), (WORD)(((ModeTable->m_v_total >> 1) & 0x0FFFC) | (ModeTable->m_v_total & 0x03)));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_disp), (WORD)(((ModeTable->m_v_disp >> 1) & 0x0FFFC) | (ModeTable->m_v_disp & 0x03)));
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_v_sync_strt), (WORD)(((ModeTable->m_v_sync_strt >> 1) & 0x0FFFC) | (ModeTable->m_v_sync_strt & 0x03)));
    /*
     * The cx_dot_clock field takes the pixel clock frequency in units
     * of 10 kHz.
     */
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_dot_clock), (WORD)(ModeTable->ClockFreq / 10000L));

    /*
     * Now set up fields which have constant values.
     */
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_reserved_1), 0);
    VideoPortWriteRegisterUshort(&(CxTable->cx_bs_reserved_2), 0);

    /*
     * Some Mach64 cards need to have an internal flag set up before
     * they can switch into certain resolutions. Cards which have
     * these resolutions configured using INSTALL.EXE don't need this
     * flag set up, so we don't need to do it when switching to a
     * hardware default mode. Since we don't know if the card needs
     * this flag for the resolution we are using, set it for all
     * "canned" mode tables.
     *
     * Unfortunately, this flag will disable automatic "kickdown"
     * to a lower refresh rate for high pixel depths when "use
     * hardware default refresh rate" is selected. To avoid this
     * problem, save the contents of the scratchpad register, set
     * the flag, then after we set the mode we want, restore the
     * contents of the scratchpad register.
     */
    Scratch = INPD(SCRATCH_REG1);
    OUTPD(SCRATCH_REG1, Scratch | 0x00000200);

    RetVal = VideoPortInt10(phwDeviceExtension, &Registers);
    if (RetVal != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed mode set\n"));
        return RetVal;
        }

    /*
     * If we are dealing with a VGA-disabled card (typically in a
     * multiheaded setup, but under rare circumstances someone may
     * be using a VGA-disabled Mach 64 with a separate VGA card),
     * we must clean up after ourselves. First of all, the DAC_MASK
     * register will have been left at zero by the BIOS call, which
     * inhibits display of palette modes. Next, we must restore the
     * contents of the buffer we used to store the CRT parameter table.
     *
     * Finally, if we obtained the buffer by setting a VGA-enabled
     * Mach 64 in accelerator mode to use the VGA aperture, we must
     * restore it to its previous aperture status. Since this will
     * only happen in a multiheaded setup, and we only support PCI
     * cards in such a setup (i.e. all cards have LFB available),
     * we can safely assume that the VGA-enabled card was originally
     * configured for LFB mode.
     */
    if (phwDeviceExtension->BiosPrefix != BIOS_PREFIX_VGA_ENAB)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Cleaning up after mode set on VGA-disabled card\n"));
        OUTP_LBHW(DAC_REGS, 0xFF);  /* DAC_MASK */

        for (Scratch = 0; Scratch < TBL_SET_BUFFER_SIZE; Scratch++)
            VideoPortWriteRegisterUchar(&(MappedBuffer[Scratch]), SavedScreen[Scratch]);

        if (FlippedPrimrary == TRUE)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Setting primrary card back to LFB mode\n"));
            VideoPortZeroMemory(&TempRegs, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
            TempRegs.Eax = BIOS_PREFIX_VGA_ENAB | BIOS_APERTURE_LB;
            TempRegs.Ecx = BIOS_LINEAR_APERTURE;
            RetVal = VideoPortInt10(phwDeviceExtension, &TempRegs);
            if (RetVal != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_ERROR, "SetModeFromTable_cx() failed VGA-enabled flip to linear aperture\n"));
                return RetVal;
                }
            }
        }
    OUTPD(SCRATCH_REG1, Scratch);
    VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);

    return NO_ERROR;

}   /* SetModeFromTable_cx() */


/**************************************************************************
 *
 * void RestoreMemSize_cx(void);
 *
 * DESCRIPTION:
 *  Restore the "memory size" register on the card when switching out
 *  of a mode which requires this register to be set to a specific value.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_cx() and ATIMPResetHw()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void RestoreMemSize_cx(void)
{
    struct query_structure *QueryPtr;   /* Query information for the card */
    ULONG Scratch;                      /* Temporary variable */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    Scratch = INPD(MEM_CNTL) & ~MEM_CNTL_MemSizeMsk;
    switch(QueryPtr->q_memory_size)
        {
        case VRAM_512k:
            Scratch |= MEM_CNTL_MemSize512k;
            break;

        case VRAM_1mb:
            Scratch |= MEM_CNTL_MemSize1Mb;
            break;

        case VRAM_2mb:
            Scratch |= MEM_CNTL_MemSize2Mb;
            break;

        case VRAM_4mb:
            Scratch |= MEM_CNTL_MemSize4Mb;
            break;

        case VRAM_6mb:
            Scratch |= MEM_CNTL_MemSize6Mb;
            break;

        case VRAM_8mb:
            Scratch |= MEM_CNTL_MemSize8Mb;
            break;

        default:
            break;
        }
    OUTPD(MEM_CNTL, Scratch);

    return;

}   /* RestoreMemSize_cx() */



/**************************************************************************
 *
 * VP_STATUS ShareVideoMemory_cx(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Allow applications to do direct screen access through DCI.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SHARE_VIDEO_MEMORY packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS ShareVideoMemory_cx(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_SHARE_MEMORY InputPtr;               /* Pointer to input structure */
    PVIDEO_SHARE_MEMORY_INFORMATION OutputPtr;  /* Pointer to output structure */
    PHYSICAL_ADDRESS ShareAddress;              /* Physical address of video memory */
    PVOID VirtualAddress;                       /* Virtual address to map video memory at */
    ULONG SharedViewSize;                       /* Size of block to share */
    ULONG SpaceType;                            /* Sparse or dense space? */
    VP_STATUS Status;                           /* Status to return */

    /*
     * On some DAC/memory combinations, some modes which require more
     * than 2M of memory (1152x764 24BPP, 1280x1024 24BPP, and
     * 1600x1200 16BPP) will have screen tearing at the 2M boundary.
     *
     * As a workaround, the display driver must start the framebuffer
     * at an offset which will put the 2M boundary at the start of a
     * scanline.
     *
     * Other DAC/memory combinations are unaffected, but since this
     * fix is nearly harmless (only ill effect is to make DCI unusable
     * in these modes), we can catch all future combinations which
     * suffer from this problem by assuming that all DAC/memory
     * combinations are affected.
     *
     * Since this requires anyone making direct access to video memory
     * to be aware of the workaround, we can't make the memory available
     * through DCI.
     */
    if (((QueryPtr->q_pix_depth == 24) && (QueryPtr->q_desire_x == 1280)) ||
        ((QueryPtr->q_pix_depth == 24) && (QueryPtr->q_desire_x == 1152)) ||
        ((QueryPtr->q_pix_depth == 16) && (QueryPtr->q_desire_x == 1600)))
        return ERROR_INVALID_FUNCTION;

    InputPtr = RequestPacket->InputBuffer;

    if ((InputPtr->ViewOffset > phwDeviceExtension->VideoRamSize) ||
        ((InputPtr->ViewOffset + InputPtr->ViewSize) > phwDeviceExtension->VideoRamSize))
        {
        VideoDebugPrint((DEBUG_ERROR, "ShareVideoMemory_cx() - access beyond video memory\n"));
        return ERROR_INVALID_PARAMETER;
        }

    RequestPacket->StatusBlock->Information = sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

    /*
     * Beware: the input buffer and the output buffer are the same buffer,
     * and therefore data should not be copied from one to the other.
     */
    VirtualAddress = InputPtr->ProcessHandle;
    SharedViewSize = InputPtr->ViewSize;

    SpaceType = 0;
#if defined(_ALPHA_)
    /*
     * Use dense space mapping whenever we can, because that will
     * allow us to support DCI and direct GDI access.
     *
     * Dense space is extremely slow with ISA cards on the newer Alphas,
     * because any byte- or word-write requires a read/modify/write
     * operation, and the ALpha can only ever do 64-bit reads when in
     * dense mode. As a result, these operations would always require
     * 4 reads and 2 writes on the ISA bus. Also, some older Alphas
     * don't support dense space mapping.
     *
     * Any Alpha that supports PCI can support dense space mapping, and
     * because the bus is wider and faster, the read/modify/write has
     * less of an impact on performance.
     */
    if (QueryPtr->q_bus_type == BUS_PCI)
        SpaceType = 4;
#endif

    /*
     * NOTE: we are ignoring ViewOffset
     */
    ShareAddress.QuadPart = phwDeviceExtension->PhysicalFrameAddress.QuadPart;


    /*
     * If the LFB is enabled, use ordinary mapping. If we have only
     * the paged aperture, we must map to banked memory. Since the
     * LFB is always aligned on a 4M boundary (8M boundary for 8M
     * aperture), this check for the paged aperture will never falsely
     * detect a LFB as paged.
     */
    if (phwDeviceExtension->PhysicalFrameAddress.LowPart == 0x0A0000)
        {
        /*
         * On some versions of the DDK, VideoPortMapBankedMemory() is
         * not available. If this is the case, force an error.
         * This routine should be available in all versions of
         * the DDK which support DCI, since it is used for DCI
         * support on cards with banked apertures.
         */
#if defined(IOCTL_VIDEO_SHARE_VIDEO_MEMORY)
        Status = VideoPortMapBankedMemory(
            phwDeviceExtension,
            ShareAddress,
            &SharedViewSize,
            &SpaceType,
            &VirtualAddress,
            0x10000,            /* Only first 64k of 128k aperture available */
            FALSE,              /* No separate read/write banks */
            BankMap_cx,         /* Our bank-mapping routine */
            (PVOID) phwDeviceExtension);
#else
        Status = ERROR_INVALID_FUNCTION;
#endif
        }
    else    /* LFB */
        {
        Status = VideoPortMapMemory(phwDeviceExtension,
                                    ShareAddress,
                                    &SharedViewSize,
                                    &SpaceType,
                                    &VirtualAddress);
        }

    OutputPtr = RequestPacket->OutputBuffer;
    OutputPtr->SharedViewOffset = InputPtr->ViewOffset;
    OutputPtr->VirtualAddress = VirtualAddress;
    OutputPtr->SharedViewSize = SharedViewSize;

    return Status;

}   /* ShareVideoMemory_cx() */



/**************************************************************************
 *
 * void BankMap_cx(BankRead, BankWrite, Context);
 *
 * ULONG BankRead;       Bank to read
 * ULONG BankWrite;      Bank to write
 * PVOID Context;       Pointer to hardware-specific information
 *
 * DESCRIPTION:
 *  Map the selected bank of video memory into the 64k VGA aperture.
 *  We don't support separate read and write banks, so we use BankWrite
 *  to set the read/write bank, and ignore BankRead.
 *
 * CALLED BY:
 *  This is an entry point, rather than being called
 *  by other miniport functions.
 *
 * NOTE:
 *  This function is called directly by the memory manager during page
 *  fault handling, and so cannot be made pageable.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void BankMap_cx(ULONG BankRead, ULONG BankWrite, PVOID Context)
{
    OUTPD(MEM_VGA_WP_SEL, (BankWrite*2) | (BankWrite*2 + 1) << 16);
    OUTPD(MEM_VGA_RP_SEL, (BankWrite*2) | (BankWrite*2 + 1) << 16);

    return;

}   /* BankMap_cx() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\init_m.c ===
/************************************************************************/
/*                                                                      */
/*                              INIT_M.C                                */
/*                                                                      */
/*        Sep 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.16  $
      $Date:   15 May 1996 16:35:42  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/init_m.c_v  $
 *
 *    Rev 1.16   15 May 1996 16:35:42   RWolff
 * Waits for idle after setting accelerator mode.
 *
 *    Rev 1.15   17 Apr 1996 13:09:26   RWolff
 * Backed out Alpha LFB mapping as dense.
 *
 *    Rev 1.14   11 Apr 1996 15:12:40   RWolff
 * Now maps framebuffer as dense on DEC Alpha with PCI graphics card.
 *
 *    Rev 1.13   31 Mar 1995 11:53:46   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.12   14 Feb 1995 15:41:20   RWOLFF
 * Changed conditional compile that uses or fakes failure of
 * VideoPortMapBankedMemory() to look for IOCTL_VIDEO_SHARE_VIDEO_MEMORY
 * instead of the routine itself. Looking for the routine always failed,
 * and since the routine is supplied in order to allow DCI to be used
 * on systems without a linear framebuffer, it should be available on
 * any DDK version that supports the IOCTL. If it isn't, a compile-time
 * error will be generated (unresolved external reference).
 *
 *    Rev 1.11   03 Feb 1995 15:17:00   RWOLFF
 * Added support for DCI, removed dead code.
 *
 *    Rev 1.10   23 Dec 1994 10:47:18   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.9   22 Jul 1994 17:48:50   RWOLFF
 * Merged with Richard's non-x86 code stream.
 *
 *    Rev 1.8   27 Jun 1994 16:30:12   RWOLFF
 * Now reports all hardware default mode tables as noninterlaced to
 * avoid confusing the display applet.
 *
 *    Rev 1.7   15 Jun 1994 11:07:08   RWOLFF
 * Now uses VideoPortZeroDeviceMemory() to clear 24BPP screens on NT builds
 * where this function is available.
 *
 *    Rev 1.6   12 May 1994 11:05:32   RWOLFF
 * Reports the refresh rate from the mode table, rather than always
 * reporting "Use hardware default".
 *
 *    Rev 1.5   31 Mar 1994 15:02:00   RWOLFF
 * Added SetPowerManagement_m() function to implement DPMS handling.
 *
 *    Rev 1.4   14 Mar 1994 16:31:36   RWOLFF
 * XMillimeter field of mode information structure now set properly.
 *
 *    Rev 1.3   03 Mar 1994 12:37:54   ASHANMUG
 * Pageable
 *
 *    Rev 1.1   31 Jan 1994 16:27:06   RWOLFF
 * Now fills in Frequency and VideoMemoryBitmap[Width|Height] fields of
 * mode information structure. Sets Number[Red|Green|Blue]Bits fields
 * for palette modes to 6 (assumes VGA-compatible DAC) instead of 0
 * to allow Windows NT to set the palette colours to the best match
 * for the colours to be displayed.
 *
 *    Rev 1.0   31 Jan 1994 11:10:40   RWOLFF
 * Initial revision.
 *
 *    Rev 1.6   24 Jan 1994 18:04:28   RWOLFF
 * Now puts DAC in known state before setting video mode. This is to
 * accomodate the Graphics Wonder (1M DRAM Mach 32 with BT48x DAC).
 *
 *    Rev 1.5   14 Jan 1994 15:21:22   RWOLFF
 * SetCurrentMode_m() and (new routine) ResetDevice_m() now initialize
 * and deinitialize the bank manager.
 *
 *    Rev 1.4   15 Dec 1993 15:26:48   RWOLFF
 * Added note to clean up before sending to Microsoft.
 *
 *    Rev 1.3   30 Nov 1993 18:16:34   RWOLFF
 * MapVideoMemory_m() now sets memoryInformation->FrameBufferLength to
 * aperture size rather than amount of video memory present.
 *
 *    Rev 1.2   05 Nov 1993 13:25:24   RWOLFF
 * Switched to defined values for memory type, 1280x1024 DAC initialization is
 * now done in the same manner as for other resolutions.
 *
 *    Rev 1.0   08 Oct 1993 11:20:34   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
INIT_M.C - Highest-level card-dependent routines for miniport.

DESCRIPTION
    This file contains initialization and packet handling routines
    for 8514/A-compatible ATI accelerators. Routines in this module
    are called only by routines in ATIMP.C, which is card-independent.

OTHER FILES

#endif

#include "dderror.h"

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"

#define INCLUDE_INIT_M
#include "init_m.h"
#include "modes_m.h"
#include "services.h"
#include "setup_m.h"


/*
 * Prototypes for static functions.
 */
static void QuerySingleMode_m(PVIDEO_MODE_INFORMATION ModeInformation, struct query_structure *QueryPtr, ULONG ModeIndex);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, AlphaInit_m)
#pragma alloc_text(PAGE_M, Initialize_m)
#pragma alloc_text(PAGE_M, MapVideoMemory_m)
#pragma alloc_text(PAGE_M, QueryPublicAccessRanges_m)
#pragma alloc_text(PAGE_M, QueryCurrentMode_m)
#pragma alloc_text(PAGE_M, QueryAvailModes_m)
#pragma alloc_text(PAGE_M, QuerySingleMode_m)
#pragma alloc_text(PAGE_M, SetCurrentMode_m)
#pragma alloc_text(PAGE_M, ResetDevice_m)
#pragma alloc_text(PAGE_M, SetPowerManagement_m)
#pragma alloc_text(PAGE_M, ShareVideoMemory_m)
/* BankMap_m() can't be made pageable */
#endif



/***************************************************************************
 *
 * void AlphaInit_m(void);
 *
 * DESCRIPTION:
 *  Perform the initialization that would normally be done by the ROM
 *  BIOS on x86 machines.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void AlphaInit_m(void)
{
    OUTPW(MEM_CFG, 0);
    DEC_DELAY
    OUTPW(MISC_OPTIONS, 0xb0a9);
    DEC_DELAY
    OUTPW(MEM_BNDRY, 0);
    DEC_DELAY
#if 0
    OUTPW(CONFIG_STATUS_1, 0x1410);
    DEC_DELAY
    OUTPW(SCRATCH_PAD_1, 0);
    DEC_DELAY
    OUTPW(SCRATCH_PAD_0, 0);
    DEC_DELAY
#endif
    OUTPW(CLOCK_SEL, 0x250);
    DEC_DELAY
    OUTPW(DAC_W_INDEX, 0x40);
    DEC_DELAY
    OUTPW(MISC_CNTL, 0xC00);
    DEC_DELAY
    OUTPW(LOCAL_CONTROL, 0x1402);
#if defined (MIPS) || defined (_MIPS_)
    DEC_DELAY
    OUTPW(OVERSCAN_COLOR_8, 0);    //RKE: to eliminate left overscan on MIPS
#endif
    DEC_DELAY

    return;

}   /* AlphaInit_m() */



/***************************************************************************
 *
 * void Initialize_m(void);
 *
 * DESCRIPTION:
 *  This routine is the 8514/A-compatible hardware initialization routine
 *  for the miniport driver. It is called once an adapter has been found
 *  and all the required data structures for it have been created.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPInitialize()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void Initialize_m(void)
{
    /*
     * Make sure we have enough available FIFO entries
     * to initialize the card.
     */
    CheckFIFOSpace_m(SIXTEEN_WORDS);

    /*
     * On the 68800, set the memory boundary to shared VGA memory.
     * On all cards, set the screen and drawing engine to start
     * at the beginning of accelerator memory and MEM_CNTL
     * to linear.
     */
    if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        OUTP (MEM_BNDRY,0);

    OUTPW(CRT_OFFSET_LO, 0);
    OUTPW(GE_OFFSET_LO,  0);
    OUTPW(CRT_OFFSET_HI, 0);
    OUTPW(GE_OFFSET_HI,  0);
    OUTPW(MEM_CNTL,0x5006);

    /*
     * Reset the engine and FIFO, then return to normal operation.
     */
    OUTPW(SUBSYS_CNTL,0x9000);
    OUTPW(SUBSYS_CNTL,0x5000);

    /*
     * The hardware cursor is available only for Mach 32 cards.
     * disable the cursor and initialize it to display quadrant I - 0
     */
    if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        {
        OUTPW(CURSOR_OFFSET_HI,0);

        OUTPW(HORZ_CURSOR_OFFSET,0);
        OUTP(VERT_CURSOR_OFFSET,0);
        OUTPW(CURSOR_COLOR_0, 0x0FF00);         /* Colour 0 black, colour 1 white */
        OUTPW(EXT_CURSOR_COLOR_0,0);	// black
        OUTPW(EXT_CURSOR_COLOR_1,0xffff);	// white
        }

    return;

}   /* Initialize_m() */


/**************************************************************************
 *
 * VP_STATUS MapVideoMemory_m(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Map the card's video memory into system memory and store the mapped
 *  address and size in OutputBuffer.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  FrameLength and PhysicalFrameAddress fields of phwDeviceExtension
 *  if Mach 32 card without linear framebuffer.
 *
 * CALLED BY:
 *  IOCTL_VIDEO_MAP_VIDEO_MEMORY packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS MapVideoMemory_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;        /* Scratch variable used by VideoPortMapMemory() */
    VP_STATUS status;       /* Error code obtained from O/S calls */

    memoryInformation = RequestPacket->OutputBuffer;

    memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
        (RequestPacket->InputBuffer))->RequestedVirtualAddress;

    /*
     * The VideoRamLength field contains the amount of video memory
     * on the card. The FrameBufferLength field contains the
     * size of the aperture in bytes
     *
     * Initially assume that the linear aperture is available.
     * For our 8514/A-compatible cards, we always enable a 4M aperture
     * if the LFB is available, so map the full 4M even if the
     * aperture size is greater than the amount of video memory.
     */
    memoryInformation->VideoRamLength    = phwDeviceExtension->VideoRamSize;
    memoryInformation->FrameBufferLength = 4 * ONE_MEG;

    /*
     * If the linear aperture is not available (==0), and we are
     * dealing with a card which can use the VGA 64k aperture,
     * map it in.
     */
    if (QueryPtr->q_aperture_cfg == 0)
        {
        if ((phwDeviceExtension->ModelNumber == MACH32_ULTRA) &&
            (QueryPtr->q_VGA_type == 1))
            {
            phwDeviceExtension->FrameLength = 0x10000;
            phwDeviceExtension->PhysicalFrameAddress.LowPart = 0x0A0000;
            memoryInformation->FrameBufferLength = phwDeviceExtension->FrameLength;
            }
        else{
            /*
             * This card can't use either linear or VGA aperture.
             * Set frame buffer size to zero and return.
             */
            memoryInformation->VideoRamBase      = 0;
            memoryInformation->FrameBufferLength = 0;
            memoryInformation->FrameBufferBase   = 0;
            return NO_ERROR;
            }
        }
    inIoSpace = 0;
#if 0   /* defined(ALPHA) if display driver can handle dense LFB */
    if (QueryPtr->q_bus_type == BUS_PCI)
        inIoSpace = 4;
#endif

    status = VideoPortMapMemory(phwDeviceExtension,
                    	        phwDeviceExtension->PhysicalFrameAddress,
                                &(memoryInformation->FrameBufferLength),
                                &inIoSpace,
                                &(memoryInformation->VideoRamBase));

    memoryInformation->FrameBufferBase    = memoryInformation->VideoRamBase;

    return status;

}   /* MapVideoMemory_m() */


/**************************************************************************
 *
 * VP_STATUS QueryPublicAccessRanges_m(RequestPacket);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 *
 * DESCRIPTION:
 *  Map and return information on the video card's public access ranges.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryPublicAccessRanges_m(PVIDEO_REQUEST_PACKET RequestPacket)
{
    PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
    PHYSICAL_ADDRESS physicalPortBase;
    ULONG physicalPortLength;

    if ( RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) )
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    portAccess = RequestPacket->OutputBuffer;
	
    portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
    portAccess->InIoSpace       = 1;               // In IO space
    portAccess->MappedInIoSpace = portAccess->InIoSpace;

    physicalPortBase.HighPart   = 0x00000000;
    physicalPortBase.LowPart    = 0x00000000;
//    physicalPortLength          = LINEDRAW+2 - physicalPortBase.LowPart;
    physicalPortLength = 0x10000;


// *SANITIZE* If MM available, give MM ports instead.

    return VideoPortMapMemory(phwDeviceExtension,
                              physicalPortBase,
                              &physicalPortLength,
                              &(portAccess->MappedInIoSpace),
                              &(portAccess->VirtualAddress));

}   /* QueryPublicAccessRanges_m() */


/**************************************************************************
 *
 * VP_STATUS QueryCurrentMode_m(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Get screen information and colour masks for the current video mode.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryCurrentMode_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MODE_INFORMATION ModeInformation;

    /*
     * If the output buffer is too small to hold the information we need
     * to put in it, return with the appropriate error code.
     */
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        sizeof(VIDEO_MODE_INFORMATION)) )
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Fill in the mode information structure.
     */
    ModeInformation = RequestPacket->OutputBuffer;

    QuerySingleMode_m(ModeInformation, QueryPtr, phwDeviceExtension->ModeIndex);

    return NO_ERROR;

}   /* QueryCurrentMode_m() */


/**************************************************************************
 *
 * VP_STATUS QueryAvailModes_m(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Get screen information and colour masks for all available video modes.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_QUERY_AVAIL_MODES packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryAvailModes_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_MODE_INFORMATION ModeInformation;
    ULONG CurrentMode;

    /*
     * If the output buffer is too small to hold the information we need
     * to put in it, return with the appropriate error code.
     */
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
        QueryPtr->q_number_modes * sizeof(VIDEO_MODE_INFORMATION)) )
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Fill in the mode information structure.
     */
    ModeInformation = RequestPacket->OutputBuffer;

    /*
     * For each mode supported by the card, store the mode characteristics
     * in the output buffer.
     */
    for (CurrentMode = 0; CurrentMode < QueryPtr->q_number_modes; CurrentMode++, ModeInformation++)
        QuerySingleMode_m(ModeInformation, QueryPtr, CurrentMode);

    return NO_ERROR;

}   /* QueryCurrentMode_m() */



/**************************************************************************
 *
 * static void QuerySingleMode_m(ModeInformation, QueryPtr, ModeIndex);
 *
 * PVIDEO_MODE_INFORMATION ModeInformation; Table to be filled in
 * struct query_structure *QueryPtr;        Query information for the card
 * ULONG ModeIndex;                         Index of mode table to use
 *
 * DESCRIPTION:
 *  Fill in a single Windows NT mode information table using data from
 *  one of our CRT parameter tables.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  QueryCurrentMode_m() and QueryAvailModes_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static void QuerySingleMode_m(PVIDEO_MODE_INFORMATION ModeInformation,
                              struct query_structure *QueryPtr,
                              ULONG ModeIndex)
{
    struct st_mode_table *CrtTable;     /* Pointer to current mode table */
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;
    CrtTable += ModeIndex;


    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = ModeIndex;

    ModeInformation->VisScreenWidth  = CrtTable->m_x_size;
    ModeInformation->VisScreenHeight = CrtTable->m_y_size;

    // * Bytes per line = ((pixels/line) * (bits/pixel)) / (bits/byte))
    ModeInformation->ScreenStride = (CrtTable->m_screen_pitch * CrtTable->m_pixel_depth) / 8;

    ModeInformation->NumberOfPlanes = 1;
    ModeInformation->BitsPerPlane = (USHORT) CrtTable->m_pixel_depth;

    ModeInformation->Frequency = CrtTable->Refresh;

    /*
     * Driver can't measure the screen size,
     * so take reasonable values (16" diagonal).
     */
    ModeInformation->XMillimeter = 320;
    ModeInformation->YMillimeter = 240;

    switch(ModeInformation->BitsPerPlane)
        {
        case 16:
            ModeInformation->RedMask   = 0x0000f800;
            ModeInformation->GreenMask = 0x000007e0;
            ModeInformation->BlueMask  = 0x0000001f;
            ModeInformation->NumberRedBits      = 5;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 5;
            CrtTable->ColourDepthInfo = PIX_WIDTH_16BPP | ORDER_16BPP_565;
            break;

        case 24:
            /*
             * Windows NT uses RGB as the standard 24BPP mode,
             * so use this ordering for all DACs except the
             * Brooktree 48x which only supports BGR.
             */
            if (QueryPtr->q_DAC_type != DAC_BT48x)
                {
                ModeInformation->RedMask   = 0x00ff0000;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x000000ff;
                CrtTable->ColourDepthInfo = PIX_WIDTH_24BPP | ORDER_24BPP_RGB;
                }
            else{
                ModeInformation->RedMask   = 0x000000ff;
                ModeInformation->GreenMask = 0x0000ff00;
                ModeInformation->BlueMask  = 0x00ff0000;
                CrtTable->ColourDepthInfo = PIX_WIDTH_24BPP | ORDER_24BPP_BGR;
                }
            ModeInformation->NumberRedBits      = 8;
            ModeInformation->NumberGreenBits    = 8;
            ModeInformation->NumberBlueBits     = 8;
            break;

        case 32:
            /*
             * Only the Brooktree 481 requires BGR,
             * and it doesn't support 32BPP.
             */
            ModeInformation->RedMask   = 0xff000000;
            ModeInformation->GreenMask = 0x00ff0000;
            ModeInformation->BlueMask  = 0x0000ff00;
            ModeInformation->NumberRedBits      = 8;
            ModeInformation->NumberGreenBits    = 8;
            ModeInformation->NumberBlueBits     = 8;
            CrtTable->ColourDepthInfo = PIX_WIDTH_24BPP | ORDER_24BPP_RGBx;
            break;

        default:
            ModeInformation->RedMask   = 0x00000000;
            ModeInformation->GreenMask = 0x00000000;
            ModeInformation->BlueMask  = 0x00000000;
            ModeInformation->NumberRedBits      = 6;
            ModeInformation->NumberGreenBits    = 6;
            ModeInformation->NumberBlueBits     = 6;
            CrtTable->ColourDepthInfo = PIX_WIDTH_8BPP;
            break;
        }

    ModeInformation->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;

    if (CrtTable->m_pixel_depth <= 8)
        {
        ModeInformation->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
            VIDEO_MODE_MANAGED_PALETTE;
        }

    /*
     * Bit 4 of the m_disp_cntl field is set for interlaced and
     * cleared for noninterlaced.
     *
     * The display applet gets confused if some of the "Use hardware
     * default" modes are interlaced and some are noninterlaced
     * (two "Use hardware default" entries are shown in the refresh
     * rate list). To avoid this, report all mode tables stored in
     * the EEPROM as noninterlaced, even if they are interlaced.
     * "Canned" mode tables give true reports.
     */
    if ((CrtTable->m_disp_cntl & 0x010) && (ModeInformation->Frequency != DEFAULT_REFRESH))
        ModeInformation->AttributeFlags |= VIDEO_MODE_INTERLACED;
    else
        ModeInformation->AttributeFlags &= ~VIDEO_MODE_INTERLACED;

    /*
     * Fill in the video memory bitmap width and height fields.
     * The descriptions are somewhat ambiguous - assume that
     * "bitmap width" is the same as ScreenStride (bytes from
     * start of one scanline to start of the next) and "bitmap
     * height" refers to the number of complete scanlines which
     * will fit into video memory.
     */
    ModeInformation->VideoMemoryBitmapWidth = ModeInformation->ScreenStride;
    ModeInformation->VideoMemoryBitmapHeight = (QueryPtr->q_memory_size * QUARTER_MEG) / ModeInformation->VideoMemoryBitmapWidth;

    return;

}   /* QuerySingleMode_m() */

//
//  When coming back from hibernate, mach32s can lock up and blackscreen.
//  This is because the card itself has to be reinitialized.
//  This initialization include at least the frame buffer initialization
//  and the initialization of the use of memory mapped registers.
//

VOID
EnableMach32FrameBufferAndMemMappedRegisters(
    PHW_DEVICE_EXTENSION pHwDeviceExtension
    )
{
    USHORT temp, temp1;

    //
    // enable the framebuffer.
    //

    temp = INPW(MEM_CFG) & 0x0fffc;     /* Preserve bits 2-15 */
    temp  |= 0x0002;                     /* 4M aperture        */
    OUTPW(MEM_CFG, temp);

    //
    // enable memory mapped register use.
    // save SRC_X ???

    OUTPW(SRC_X, 0x0AAAA);
    temp = INPW(R_SRC_X);
    if (temp  != 0x02AA)
       VideoDebugPrint((DEBUG_NORMAL, "Can't use memory mapped ranges, read %x\n", temp));

    temp1 = INPW(LOCAL_CONTROL);
    temp1 |= 0x0020;   // Enable memory mapped registers
    OUTPW(LOCAL_CONTROL, temp1);

    //restore SRC_X???: OUTPW(SRC_X, temp);
}


/**************************************************************************
 *
 * void SetCurrentMode_m(QueryPtr, CrtTable);
 *
 * struct query_structure *QueryPtr;    Query information for the card
 * struct st_mode_table *CrtTable;      CRT parameter table for desired mode
 *
 * DESCRIPTION:
 *  Switch into the specified video mode.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  1994 01 13  Added initialization of bank manager
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void SetCurrentMode_m(struct query_structure *QueryPtr, struct st_mode_table *CrtTable)
{
    WORD MiscOptions;   /* Contents of MISC_OPTIONS register */
    USHORT Scratch, USTemp;     /* Temporary variable */

    //
    //  When coming back from hibernate, mach32s can lock up and blackscreen.
    //  This is because the card itself has to be reinitialized.
    //  This initialization include at least the frame buffer initialization
    //  and the initialization of the use of memory mapped registers.
    //

    if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        {
        // enable the framebuffer.
        Scratch = INPW(MEM_CFG) & 0x0fffc;     /* Preserve bits 2-15 */
        Scratch  |= 0x0002;                     /* 4M aperture        */
        OUTPW(MEM_CFG, Scratch);

        // enable memory mapped register use.
        // save SRC_X ???
        OUTPW(SRC_X, 0x0AAAA);
        Scratch = INPW(R_SRC_X);
        if (Scratch  != 0x02AA)
           VideoDebugPrint((DEBUG_NORMAL, "Can't use memory mapped ranges, read %x\n", Scratch));

        USTemp = INPW(LOCAL_CONTROL);
        USTemp |= 0x0020;   // Enable memory mapped registers
        OUTPW(LOCAL_CONTROL, USTemp);
        //restore SRC_X???: OUTPW(SRC_X, Scratch);
        }


    /*
     * Put the DAC in a known state before we start.
     */
    UninitTiDac_m();

    Passth8514_m(SHOW_ACCEL);    // turn vga pass through off

    /*
     * On cards with the "MISC_OPTIONS doesn't report video memory size
     * correctly" bug, reset MISC_OPTIONS to show the true amount of
     * video memory. This is done here rather than when we determine
     * how much memory is present in order to avoid trashing the "blue
     * screen" (no adverse effects on operation, but would generate
     * large numbers of user complaints).
     */
    if (((QueryPtr->q_asic_rev == CI_68800_6) || (QueryPtr->q_asic_rev == CI_68800_AX)) &&
        (QueryPtr->q_VGA_type == 1) &&
        ((QueryPtr->q_memory_type == VMEM_DRAM_256Kx4) ||
         (QueryPtr->q_memory_type == VMEM_DRAM_256Kx16) ||
         (QueryPtr->q_memory_type == VMEM_DRAM_256Kx4_GRAP)))
        {
        MiscOptions = INPW(MISC_OPTIONS) & MEM_SIZE_STRIPPED;

        switch (QueryPtr->q_memory_size)
            {
            case VRAM_512k:
                MiscOptions |= MEM_SIZE_512K;
                break;

            case VRAM_1mb:
                MiscOptions |= MEM_SIZE_1M;
                break;

            case VRAM_2mb:
                MiscOptions |= MEM_SIZE_2M;
                break;

            case VRAM_4mb:
                MiscOptions |= MEM_SIZE_4M;
                break;
            }
        OUTPW(MISC_OPTIONS, MiscOptions);
        }

    setmode_m(CrtTable, (ULONG_PTR) &(phwDeviceExtension->RomBaseRange), (ULONG) phwDeviceExtension->ModelNumber);

    /*
     * On a Mach 8 card, 1280x1024 can only be done in split
     * pixel mode. If we are running on a Mach 8, and this
     * resolution was selected, go into split pixel mode.
     *
     * Bit 4 of EXT_GE_CONFIG is set for split pixel mode and
     * clear for normal mode. Bit 3 must be set, since clearing
     * it accesses EEPROM read/write mode.
     */
    if    ((phwDeviceExtension->ModelNumber == _8514_ULTRA)
        || (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA))
        {
        if (QueryPtr->q_desire_x == 1280)
                OUTPW(EXT_GE_CONFIG, 0x0018);
        else    OUTPW(EXT_GE_CONFIG, 0x0008);
        }

    /*
     * Default to 8 bits per pixel. Modes which require a different
     * setting will change this in the init_ti_<depth>_m() function.
     */
    OUTP(DAC_MASK, 0xff);

    if (phwDeviceExtension->ModelNumber == MACH32_ULTRA)
        {
        switch (CrtTable->m_pixel_depth)    // program the DAC for the
            {                               // other resolutions
            case 4:
            case 8:
                InitTi_8_m((WORD)(CrtTable->ColourDepthInfo | 0x0a));
                break;

            case 16:
                InitTi_16_m((WORD)(CrtTable->ColourDepthInfo | 0x0a), (ULONG_PTR) &(phwDeviceExtension->RomBaseRange));   /* 16 bit 565 */
                break;

            case 24:
            case 32:
                /*
                 * RGB/BGR and 24/32 bit mode information is
                 * stored in CrtTable->ColourDepthInfo.
                 */
                InitTi_24_m((WORD)(CrtTable->ColourDepthInfo | 0x0a), (ULONG_PTR) &(phwDeviceExtension->RomBaseRange));
                break;
            }
        }

    /*
     * If we are going to be using the VGA aperture on a Mach 32,
     * initialize the bank manager by saving the ATI extended register
     * values and putting the VGA controller into packed pixel mode.
     *
     * We can't identify this case by looking at
     * phwDeviceExtension->FrameLength because it is set to 0x10000
     * when the VGA aperture is being used in the
     * IOCTL_VIDEO_MAP_VIDEO_MEMORY packet which may or may not
     * have been called by the time we reach this point.
     */
    if ((phwDeviceExtension->ModelNumber == MACH32_ULTRA) &&
        (QueryPtr->q_aperture_cfg == 0) &&
        (QueryPtr->q_VGA_type == 1))
        {
        for (Scratch = 0; Scratch <= 2; Scratch++)
            {
            OUTP(reg1CE, (BYTE)(SavedExtRegs[Scratch] & 0x00FF));
            SavedExtRegs[Scratch] = (SavedExtRegs[Scratch] & 0x00FF) | (INP(reg1CF) << 8);
            }
        OUTPW(HI_SEQ_ADDR, 0x0F02);
        OUTPW(HI_SEQ_ADDR, 0x0A04);
        OUTPW(reg3CE, 0x1000);
        OUTPW(reg3CE, 0x0001);
        OUTPW(reg3CE, 0x0002);
        OUTPW(reg3CE, 0x0003);
        OUTPW(reg3CE, 0x0004);
        OUTPW(reg3CE, 0x0005);
        OUTPW(reg3CE, 0x0506);
        OUTPW(reg3CE, 0x0F07);
        OUTPW(reg3CE, 0xFF08);
        OUTPW(reg1CE, 0x28B0);  /* Enable 256 colour, 1M video RAM */
        OUTPW(reg1CE, 0x04B6);  /* Select linear addressing */
        OUTP(reg1CE, 0xBE);
        OUTPW(reg1CE, (WORD)(((INP(reg1CF) & 0xF7) << 8) | 0xBE));
        }


    /*
     * phwDeviceExtension->ReInitializing becomes TRUE in
     * IOCTL_VIDEO_SET_COLOR_REGISTERS packet of ATIMPStartIO().
     *
     * If this is not the first time we are switching into graphics
     * mode, set the palette to the last set of colours that was
     * selected while in graphics mode.
     */
    if (phwDeviceExtension->ReInitializing)
        {
        SetPalette_m(phwDeviceExtension->Clut,
                     phwDeviceExtension->FirstEntry,
                     phwDeviceExtension->NumEntries);
        }

    /*
     * Clear visible screen.
     *
     * 24 and 32 BPP would require a q_desire_y value beyond the
     * maximum allowable clipping value (1535) if we clear the screen
     * using a normal blit. Since these pixel depths are only supported
     * up to 800x600, we can fake it by doing a 16BPP blit of double the
     * screen height, clipping the special case of 640x480 24BPP on
     * a 1M card (this is the only true colour mode that will fit in
     * 1M, so if we hit this case on a 1M card, we know which mode
     * we're dealing with) to avoid running off the end of video memory.
     */
    if (CrtTable->m_pixel_depth >= 24)
        {
        /*
         * Save the colour depth configuration and switch into 16BPP
         */
        Scratch = INPW(R_EXT_GE_CONFIG);
        OUTPD(EXT_GE_CONFIG, (Scratch & 0xFFCF) | PIX_WIDTH_16BPP);

        CheckFIFOSpace_m(SIXTEEN_WORDS);

        OUTPW(DP_CONFIG, 0x2011);
        OUTPW(ALU_FG_FN, 0x7);          // Paint
        OUTPW(FRGD_COLOR, 0);	        // Black
        OUTPW(CUR_X, 0);
        OUTPW(CUR_Y, 0);
        OUTPW(DEST_X_START, 0);
        OUTPW(DEST_X_END, QueryPtr->q_desire_x);

        if (QueryPtr->q_memory_size == VRAM_1mb)
            OUTPW(DEST_Y_END, 720);     /* Only 640x480 24BPP will fit in 1M */
        else
            OUTPW(DEST_Y_END, (WORD)(2*(QueryPtr->q_desire_y)));

        /*
         * Let the blit finish then restore the colour depth configuration
         */
        WaitForIdle_m();
        OUTPD(EXT_GE_CONFIG, Scratch);

        }
    else{
        /*
         * Other colour depths can be handled by a normal blit, and the
         * LFB may not be available, so use a blit to clear the screen.
         */
        CheckFIFOSpace_m(SIXTEEN_WORDS);

        OUTPW(DP_CONFIG, 0x2011);
        OUTPW(ALU_FG_FN, 0x7);          // Paint
        OUTPW(FRGD_COLOR, 0);	        // Black
        OUTPW(CUR_X, 0);
        OUTPW(CUR_Y, 0);
        OUTPW(DEST_X_START, 0);
        OUTPW(DEST_X_END, QueryPtr->q_desire_x);
        OUTPW(DEST_Y_END, QueryPtr->q_desire_y);
        }

#if 0
    /*
     * In 800x600 24BPP, set the offset to start 1 pixel into video
     * memory to avoid screen tearing. The MAP_VIDEO_MEMORY packet
     * must adjust the framebuffer base to compensate for this.
     */
    if ((QueryPtr->q_desire_x == 800) && (QueryPtr->q_pix_depth == 24))
        {
        OUTPW(CRT_OFFSET_LO, 3);
        }
    else
        {
        OUTPW(CRT_OFFSET_HI, 0);
        }
#endif

    WaitForIdle_m();

    return;

}   /* SetCurrentMode_m() */



/**************************************************************************
 *
 * void ResetDevice_m(void);
 *
 * DESCRIPTION:
 *  Reset the accelerator to allow the VGA miniport to switch
 *  into a VGA mode.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_RESET_DEVICE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void ResetDevice_m(void)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */

    /*
     * If we are using the VGA aperture on a Mach 32, put its
     * VGA controller into planar mode.
     */
    if (phwDeviceExtension->FrameLength == 0x10000)
        {
        OUTPW(reg1CE, SavedExtRegs[0]);
        OUTPW(reg1CE, SavedExtRegs[1]);
        OUTPW(reg1CE, SavedExtRegs[2]);
        OUTP(reg1CE, 0xBE);
        OUTPW(reg1CE, (WORD)(((INP(reg1CF) & 0xF7) << 8) | 0xBE));
        }
    UninitTiDac_m();
    Passth8514_m(SHOW_VGA);

    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    Registers.Eax = 0x0003;         // set text mode 3
    VideoPortInt10(phwDeviceExtension, &Registers);

}   /* ResetDevice_m() */



/**************************************************************************
 *
 * VP_STATUS SetPowerManagement_m(QueryPtr, DpmsState);
 *
 * struct query_structure *QueryPtr;    Query information for the card
 * DWORD DpmsState;                     Desired DPMS state
 *                                      (VIDEO_POWER_STATE enumeration)
 *
 * DESCRIPTION:
 *  Switch into the desired DPMS state.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  ERROR_INVALID_PARAMETER if invalid state requested.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_POWER_MANAGEMENT packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS SetPowerManagement_m(struct query_structure *QueryPtr, DWORD DpmsState)
{
    struct st_mode_table *CrtTable; /* Mode table, used to obtain sync values */

    /*
     * Only accept valid states.
     */
    if ((DpmsState < VideoPowerOn) || (DpmsState > VideoPowerOff))
        return ERROR_INVALID_PARAMETER;

    /*
     * Set CrtTable to point to the mode table associated with the
     * selected mode.
     *
     * When a pointer to a structure is incremented by an integer,
     * the integer represents the number of structure-sized blocks
     * to skip over, not the number of bytes to skip over.
     */
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;
    CrtTable += phwDeviceExtension->ModeIndex;

    SavedDPMSState = DpmsState;

    /*
     * Mach 32 rev. 6 and later supports turning the sync signals on and off
     * through the HORZ_OVERSCAN registers, but some chips that report as
     * rev. 6 don't have this implemented. Also, Mach 32 rev. 3 and Mach 8
     * don't support this mechanism.
     *
     * Disabling the sync by setting it to start after the total will work
     * for all chips. Most chips will de-synchronize if the sync is set
     * to 1 more than the total, but some need higher values. To be sure
     * of de-synchronizing, set the disabled sync signal to start at
     * the highest possible value.
     */
    switch (DpmsState)
        {
        case VideoPowerOn:
            OUTP(H_SYNC_STRT,	CrtTable->m_h_sync_strt);
            OUTPW(V_SYNC_STRT,	CrtTable->m_v_sync_strt);
            break;

        case VideoPowerStandBy:
            OUTP(H_SYNC_STRT,	0xFF);
            OUTPW(V_SYNC_STRT,	CrtTable->m_v_sync_strt);
            break;

        case VideoPowerSuspend:
            OUTP(H_SYNC_STRT,	CrtTable->m_h_sync_strt);
            OUTPW(V_SYNC_STRT,	0x0FFF);
            break;

        case VideoPowerOff:
            OUTP(H_SYNC_STRT,	0xFF);
            OUTPW(V_SYNC_STRT,	0x0FFF);
            break;

        /*
         * This case should never happen, because the initial
         * acceptance of only valid states should have already
         * rejected anything that will appear here.
         */
        default:
            break;
        }
        return NO_ERROR;

}   /* SetPowerManagement_m() */


DWORD GetPowerManagement_m(PHW_DEVICE_EXTENSION phwDeviceExtension)
/*
 * DESCRIPTION:
 *  Report which DPMS state we are in.
 *
 * PARAMETERS:
 *  phwDeviceExtension  Points to per-adapter device extension.
 *
 * RETURN VALUE:
 *  Current DPMS state (VIDEO_POWER_STATE enumeration).
 */
{
    ASSERT(phwDeviceExtension != NULL);

    /*
     * On the Mach 8, the sync start registers are write-only, so
     * we can't check which state we are in. For this reason, we
     * have saved the state we switched into using SetPowerManagement_m().
     * On the Mach 32, we can either use this saved state or read
     * the sync start registers, but using the same method as for
     * the Mach 8 reduces complexity.
     */
    return SavedDPMSState;
}   /* GetPowerManagement_m() */



/**************************************************************************
 *
 * VP_STATUS ShareVideoMemory_m(RequestPacket, QueryPtr);
 *
 * PVIDEO_REQUEST_PACKET RequestPacket; Request packet with input and output buffers
 * struct query_structure *QueryPtr;    Query information for the card
 *
 * DESCRIPTION:
 *  Allow applications to do direct screen access through DCI.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if failed
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SHARE_VIDEO_MEMORY packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS ShareVideoMemory_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr)
{
    PVIDEO_SHARE_MEMORY InputPtr;               /* Pointer to input structure */
    PVIDEO_SHARE_MEMORY_INFORMATION OutputPtr;  /* Pointer to output structure */
    PHYSICAL_ADDRESS ShareAddress;              /* Physical address of video memory */
    PVOID VirtualAddress;                       /* Virtual address to map video memory at */
    ULONG SharedViewSize;                       /* Size of block to share */
    ULONG SpaceType;                            /* Sparse or dense space? */
    VP_STATUS Status;                           /* Status to return */

    /*
     * We can only share the aperture with application programs if there
     * is an aperture available. If both the LFB and the on-board VGA
     * and therefore the VGA aperture) are disabled, report that we
     * can't share the aperture.
     */
    if ((QueryPtr->q_aperture_cfg == 0) && (QueryPtr->q_VGA_type == 0))
        return ERROR_INVALID_FUNCTION;

    InputPtr = RequestPacket->InputBuffer;

    if ((InputPtr->ViewOffset > phwDeviceExtension->VideoRamSize) ||
        ((InputPtr->ViewOffset + InputPtr->ViewSize) > phwDeviceExtension->VideoRamSize))
        {
        VideoDebugPrint((DEBUG_ERROR, "ShareVideoMemory_m() - access beyond video memory\n"));
        return ERROR_INVALID_PARAMETER;
        }

    RequestPacket->StatusBlock->Information = sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

    /*
     * Beware: the input buffer and the output buffer are the same buffer,
     * and therefore data should not be copied from one to the other.
     */
    VirtualAddress = InputPtr->ProcessHandle;
    SharedViewSize = InputPtr->ViewSize;

    SpaceType = 0;
#if defined(_ALPHA_)
    /*
     * Use dense space mapping whenever we can, because that will
     * allow us to support DCI and direct GDI access.
     *
     * Dense space is extremely slow with ISA cards on the newer Alphas,
     * because any byte- or word-write requires a read/modify/write
     * operation, and the ALpha can only ever do 64-bit reads when in
     * dense mode. As a result, these operations would always require
     * 4 reads and 2 writes on the ISA bus. Also, some older Alphas
     * don't support dense space mapping.
     *
     * Any Alpha that supports PCI can support dense space mapping, and
     * because the bus is wider and faster, the read/modify/write has
     * less of an impact on performance.
     */
    if (QueryPtr->q_bus_type == BUS_PCI)
        SpaceType = 4;
#endif

    /*
     * NOTE: we are ignoring ViewOffset
     */
    ShareAddress.QuadPart = phwDeviceExtension->PhysicalFrameAddress.QuadPart;


    /*
     * If the LFB is enabled, use ordinary mapping. If we have only
     * the paged aperture, we must map to banked memory. Since the
     * LFB is always aligned on a 1M boundary (4M boundary for 4M
     * aperture), this check for the paged aperture will never falsely
     * detect a LFB as paged.
     */
    if (phwDeviceExtension->PhysicalFrameAddress.LowPart == 0x0A0000)
        {
        /*
         * On some versions of the DDK, VideoPortMapBankedMemory() is
         * not available. If this is the case, force an error.
         * This routine should be available in all versions of
         * the DDK which support DCI, since it is used for DCI
         * support on cards with banked apertures.
         */
#if defined(IOCTL_VIDEO_SHARE_VIDEO_MEMORY)
        Status = VideoPortMapBankedMemory(
            phwDeviceExtension,
            ShareAddress,
            &SharedViewSize,
            &SpaceType,
            &VirtualAddress,
            0x10000,            /* 64k VGA aperture */
            FALSE,              /* No separate read/write banks */
            BankMap_m,          /* Our bank-mapping routine */
            (PVOID) phwDeviceExtension);
#else
        Status = ERROR_INVALID_FUNCTION;
#endif
        }
    else    /* LFB */
        {
        Status = VideoPortMapMemory(phwDeviceExtension,
                                    ShareAddress,
                                    &SharedViewSize,
                                    &SpaceType,
                                    &VirtualAddress);
        }

    OutputPtr = RequestPacket->OutputBuffer;
    OutputPtr->SharedViewOffset = InputPtr->ViewOffset;
    OutputPtr->VirtualAddress = VirtualAddress;
    OutputPtr->SharedViewSize = SharedViewSize;

    return Status;

}   /* ShareVideoMemory_m() */



/**************************************************************************
 *
 * void BankMap_m(BankRead, BankWrite, Context);
 *
 * ULONG BankRead;       Bank to read
 * ULONG BankWrite;      Bank to write
 * PVOID Context;       Pointer to hardware-specific information
 *
 * DESCRIPTION:
 *  Map the selected bank of video memory into the 64k VGA aperture.
 *  We don't support separate read and write banks, so we use BankWrite
 *  to set the read/write bank, and ignore BankRead.
 *
 * CALLED BY:
 *  This is an entry point, rather than being called
 *  by other miniport functions.
 *
 * NOTE:
 *  This function is called directly by the memory manager during page
 *  fault handling, and so cannot be made pageable.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void BankMap_m(ULONG BankRead, ULONG BankWrite, PVOID Context)
{
    OUTPW( reg1CE, (USHORT)(((BankWrite & 0x0f) << 9) | 0xb2));
    OUTPW( reg1CE, (USHORT)(((BankWrite & 0x30) << 4) | 0xae));

    return;

}   /* BankMap_m() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\modes_m.h ===
/************************************************************************/
/*                                                                      */
/*                              MODES_M.H                               */
/*                                                                      */
/*        Aug 25  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.0  $
      $Date:   31 Jan 1994 11:42:30  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/modes_m.h  $
 *
 *    Rev 1.0   31 Jan 1994 11:42:30   RWOLFF
 * Initial revision.
 *
 *    Rev 1.2   14 Jan 1994 15:23:04   RWOLFF
 * Added definitions and data for SetTextMode_m()
 *
 *    Rev 1.1   08 Oct 1993 11:11:50   RWOLFF
 * Added "_m" to function names to identify them as being specific to the
 * 8514/A-compatible family of ATI accelerators.
 *
 *    Rev 1.0   03 Sep 1993 14:28:44   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
MODES_M.H - Header file for MODES_M.C

#endif


/*
 * Card-independent definitions for mode setting.
 */
#define SHOW_VGA    1   /* Display driven by VGA */
#define SHOW_ACCEL  0   /* Display driven by accelerator */

/*
 * Prototypes for mode setting functions.
 */
extern void setmode_m(struct st_mode_table *, ULONG_PTR, ULONG);
extern void Passth8514_m(int status);
extern void InitTi_8_m(WORD ext_ge_config);
extern void InitTi_16_m(WORD ext_ge_config, ULONG_PTR rom_address);
extern void InitTi_24_m(WORD ext_ge_config, ULONG_PTR rom_address);
extern void UninitTiDac_m(void);
extern void SetPalette_m(PULONG lpPalette, USHORT StartIndex, USHORT Count);
extern void SetTextMode_m(void);

/*
 * Definitions and data structures used internally by MODES_M.C
 */
#ifdef INCLUDE_MODES_M

/*
 * Red, Green, and Blue values for the default 16 colurs in VGA
 * 80x25 text mode. On the DEC ALPHA, the RGB ordering is reversed.
 */
unsigned char TextDAC_m[0x10*3] =
{
#if defined (ALPHA) || defined (_ALPHA_)
    0x00, 0x00, 0x00,   /* Black */
    0x2A, 0x00, 0x00,   /* Blue */
    0x00, 0x2A, 0x00,   /* Green */
    0x2A, 0x2A, 0x00,   /* Cyan */
    0x00, 0x00, 0x2A,   /* Red */
    0x2A, 0x00, 0x2A,   /* Magenta */
    0x00, 0x15, 0x2A,   /* Brown */
    0x2A, 0x2A, 0x2A,   /* White */
    0x15, 0x15, 0x15,   /* Grey */
    0x3F, 0x15, 0x15,   /* High intensity Blue */
    0x15, 0x3F, 0x15,   /* High intensity Green */
    0x3F, 0x3F, 0x15,   /* High intensity Cyan */
    0x15, 0x15, 0x3F,   /* High intensity Red */
    0x3F, 0x15, 0x3F,   /* High intensity Magenta */
    0x15, 0x3F, 0x3F,   /* Yellow */
    0x3F, 0x3F, 0x3F    /* High intensity White */
#else
    0x00, 0x00, 0x00,   /* Black */
    0x00, 0x00, 0x2A,   /* Blue */
    0x00, 0x2A, 0x00,   /* Green */
    0x00, 0x2A, 0x2A,   /* Cyan */
    0x2A, 0x00, 0x00,   /* Red */
    0x2A, 0x00, 0x2A,   /* Magenta */
    0x2A, 0x15, 0x00,   /* Brown */
    0x2A, 0x2A, 0x2A,   /* White */
    0x15, 0x15, 0x15,   /* Grey */
    0x15, 0x15, 0x3F,   /* High intensity Blue */
    0x15, 0x3F, 0x15,   /* High intensity Green */
    0x15, 0x3F, 0x3F,   /* High intensity Cyan */
    0x3F, 0x15, 0x15,   /* High intensity Red */
    0x3F, 0x15, 0x3F,   /* High intensity Magenta */
    0x3F, 0x3F, 0x15,   /* Yellow */
    0x3F, 0x3F, 0x3F    /* High intensity White */
#endif
};


/*
 * Indices into StdTextCRTC_m[] array
 */
#define S_PARM      5                   /* Start of sequencer parameters */
#define S_LEN       4                   /* Number of sequencer parameters */
#define MIS_PARM    S_PARM + S_LEN      /* Start of miscelaneous parameters */
#define MIS_LEN     1                   /* Number of miscelaneous parameters */
#define C_PARM      MIS_PARM + MIS_LEN  /* Start of CRTC parameters */
#define C_LEN       0x19                /* Number of CRTC parameters */
#define A_PARM      C_PARM + C_LEN      /* Start of attribute parameters */
#define A_LEN       0x14                /* Number of attribute parameters */
#define G_PARM      A_PARM + A_LEN      /* Start of Graphics parameters */
#define G_LEN       0x09                /* Number of graphics parameters */

/*
 * Values written to the standard VGA registers when switching into
 * 80x25 16 colour text mode.
 */
unsigned char StdTextCRTC_m[0x40] =
{
    0x50, 0x18, 0x10,
    0x00, 0x10,
    0x00, 0x03, 0x00, 0x02,
    0x67,
    0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F,
    0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00,
    0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
    0x0C, 0x00, 0x0F, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF
};

/*
 * Values written to the ATI extended VGA registers when switching into
 * 80x25 16 colour text mode. Within each triplet of bytes, the first
 * byte is the extended register, the second is the AND mask for the
 * contents of the register, and the third byte is the OR mask. A register
 * value of zero signals that all necessary registers have been programmed.
 */
unsigned char ExtTextCRTC_m[] =
{
    0xB0, 0xC1, 0x00,
    0xB1, 0x87, 0x00,
    0xB2, 0xBE, 0x00,
    0xB5, 0x7F, 0x00,
    0xB6, 0xE7, 0x00,
    0xB8, 0x7F, 0x40,
    0x00
};

/*
 * Font data
 */
unsigned char FontData_m[256*16] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x00 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0x82, 0x82, 0xAA, 0x82, 0x82, /* 0x01 '' */
    0xC6, 0xBA, 0x82, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xFE, 0xFE, 0xD6, 0xFE, 0xFE, /* 0x02 '' */
    0xBA, 0xC6, 0xFE, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x6C, 0xEE, 0xFE, 0xFE, 0xFE, /* 0x03 '' */
    0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, /* 0x04 '' */
    0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x10, 0x6C, /* 0x05 '' */
    0xEE, 0x6C, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x10, 0x38, 0x7C, 0x7C, 0xFE, 0xFE, /* 0x06 '' */
    0xFE, 0x6C, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, /* 0x07 '' */
    0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xC3, /* 0x08 '' */
    0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x66, 0x66, /* 0x09 <unprintable> */
    0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,

    0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0x99, 0x99, /* 0x0A '
' */
    0x99, 0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    0x00, 0x00, 0x1E, 0x0E, 0x1E, 0x36, 0x78, 0xCC, /* 0x0B '' */
    0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, /* 0x0C '' */
    0x7E, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x1E, 0x1A, 0x1E, 0x18, 0x18, 0x18, /* 0x0D <unprintable> */
    0x18, 0x78, 0xF8, 0x70, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3E, 0x36, 0x3E, 0x36, 0x36, 0x76, /* 0x0E '' */
    0xF6, 0x66, 0x0E, 0x1E, 0x0C, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0xDB, 0x7E, 0x3C, 0x66, 0x66, /* 0x0F '' */
    0x3C, 0x7E, 0xDB, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x80, 0xE0, 0xF0, 0xFC, 0xFE, /* 0x10 '' */
    0xFC, 0xF0, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x02, 0x0E, 0x3E, 0x7E, 0xFE, /* 0x11 '' */
    0x7E, 0x3E, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, /* 0x12 '' */
    0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, /* 0x13 '' */
    0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0xDB, 0x7B, /* 0x14 '' */
    0x1B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x7C, 0xF6, /* 0x15 '' */
    0xDE, 0x7C, 0x0C, 0xC6, 0xC6, 0x7C, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x16 '' */
    0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, /* 0x17 '' */
    0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, /* 0x18 '' */
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0x19 '' */
    0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0E, 0xFF, /* 0x1A '' */
    0x0E, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x70, 0xFE, /* 0x1B '' */
    0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, /* 0x1C '' */
    0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x66, 0xFF, /* 0x1D '' */
    0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x38, 0x7C, /* 0x1E '' */
    0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C, 0x7C, 0x7C, /* 0x1F '' */
    0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x20 ' ' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x3C, 0x18, /* 0x21 '!' */
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x36, 0x36, 0x36, 0x36, 0x14, 0x00, 0x00, /* 0x22 '"' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, /* 0x23 '#' */
    0xFE, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x7C, 0xC6, 0xC0, 0x78, /* 0x24 '$' */
    0x3C, 0x06, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x66, 0x0C, /* 0x25 '%' */
    0x18, 0x30, 0x66, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x38, 0x6C, 0x38, 0x30, 0x76, 0x7E, /* 0x26 '&' */
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0C, 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, /* 0x27 ''' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, /* 0x28 '(' */
    0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, /* 0x29 ')' */
    0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x38, 0xFE, /* 0x2A '*' */
    0x38, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, /* 0x2B '+' */
    0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x2C ',' */
    0x00, 0x0C, 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, /* 0x2D '-' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x2E '.' */
    0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, /* 0x2F '/' */
    0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, /* 0x30 '0' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x78, 0x18, 0x18, 0x18, 0x18, /* 0x31 '1' */
    0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x06, 0x0C, 0x18, /* 0x32 '2' */
    0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, /* 0x33 '3' */
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xCC, /* 0x34 '4' */
    0xFE, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, /* 0x35 '5' */
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xFC, 0xC6, /* 0x36 '6' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x0C, 0x18, 0x30, /* 0x37 '7' */
    0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, /* 0x38 '8' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, /* 0x39 '9' */
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, /* 0x3A ':' */
    0x00, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, /* 0x3B ';' */
    0x00, 0x0C, 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0xC0, /* 0x3C '<' */
    0x60, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, /* 0x3D '=' */
    0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, /* 0x3E '>' */
    0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, /* 0x3F '?' */
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xDE, 0xDE, /* 0x40 '@' */
    0xDE, 0xDC, 0xC0, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xFE, /* 0x41 'A' */
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, /* 0x42 'B' */
    0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, /* 0x43 'C' */
    0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, /* 0x44 'D' */
    0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0x66, 0x60, 0x64, 0x7C, 0x64, /* 0x45 'E' */
    0x60, 0x60, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0x66, 0x60, 0x64, 0x7C, 0x64, /* 0x46 'F' */
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC0, 0xC0, 0xC0, /* 0x47 'G' */
    0xCE, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, /* 0x48 'H' */
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0x49 'I' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0x4A 'J' */
    0x18, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xCC, 0xD8, 0xF0, 0xF0, /* 0x4B 'K' */
    0xD8, 0xCC, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, /* 0x4C 'L' */
    0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xEE, 0xEE, 0xFE, 0xD6, /* 0x4D 'M' */
    0xD6, 0xD6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xE6, 0xE6, 0xF6, 0xDE, /* 0x4E 'N' */
    0xCE, 0xCE, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x4F 'O' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x66, 0x7C, /* 0x50 'P' */
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x51 'Q' */
    0xC6, 0xD6, 0xD6, 0x7C, 0x06, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x78, /* 0x52 'R' */
    0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0x70, 0x1C, /* 0x53 'S' */
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, /* 0x54 'T' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x55 'U' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x56 'V' */
    0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, /* 0x57 'W' */
    0xFE, 0xEE, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x38, /* 0x58 'X' */
    0x6C, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, /* 0x59 'Y' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, /* 0x5A 'Z' */
    0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x60, /* 0x5B '[' */
    0x60, 0x60, 0x60, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0x30, /* 0x5C '\' */
    0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, /* 0x5D ']' */
    0x0C, 0x0C, 0x0C, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, /* 0x5E '^' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x5F '_' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,

    0x00, 0x18, 0x18, 0x18, 0x0C, 0x00, 0x00, 0x00, /* 0x60 '`' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, /* 0x61 'a' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, /* 0x62 'b' */
    0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, /* 0x63 'c' */
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, /* 0x64 'd' */
    0xCC, 0xCC, 0xCC, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, /* 0x65 'e' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x1C, 0x36, 0x30, 0x30, 0xFC, 0x30, /* 0x66 'f' */
    0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCE, 0xC6, /* 0x67 'g' */
    0xC6, 0xCE, 0x76, 0x06, 0xC6, 0x7C, 0x00, 0x00,

    0x00, 0x00, 0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, /* 0x68 'h' */
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, /* 0x69 'i' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0C, 0x0C, 0x00, 0x1C, 0x0C, 0x0C, /* 0x6A 'j' */
    0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0x00,

    0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x66, 0x6C, /* 0x6B 'k' */
    0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0x6C 'l' */
    0x18, 0x18, 0x18, 0x1C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xD6, /* 0x6D 'm' */
    0xD6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, /* 0x6E 'n' */
    0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, /* 0x6F 'o' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, /* 0x70 'p' */
    0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, /* 0x71 'q' */
    0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x60, /* 0x72 'r' */
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, /* 0x73 's' */
    0x7C, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x30, 0x30, 0x30, 0xFC, 0x30, 0x30, /* 0x74 't' */
    0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, /* 0x75 'u' */
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, /* 0x76 'v' */
    0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, /* 0x77 'w' */
    0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0x6C, /* 0x78 'x' */
    0x38, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, /* 0x79 'y' */
    0xC6, 0xCE, 0x76, 0x06, 0xC6, 0x7C, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x86, 0x0C, /* 0x7A 'z' */
    0x18, 0x30, 0x62, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, /* 0x7B '{' */
    0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, /* 0x7C '|' */
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, /* 0x7D '}' */
    0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, /* 0x7E '~' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, /* 0x7F '' */
    0x6C, 0x6C, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0xC6, /* 0x80 '' */
    0x66, 0x3C, 0x18, 0x0C, 0xCC, 0x38, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0x00, 0x00, 0xC6, 0xC6, 0xC6, /* 0x81 '' */
    0xC6, 0xC6, 0xCE, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xC6, /* 0x82 '' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x78, 0xCC, 0x00, 0x78, 0x0C, 0x7C, /* 0x83 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xCC, 0x00, 0x00, 0x78, 0x0C, 0x7C, /* 0x84 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0C, 0x7C, /* 0x85 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x38, 0x6C, 0x38, 0x00, 0x78, 0x0C, 0x7C, /* 0x86 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, /* 0x87 '' */
    0xC6, 0x7C, 0x18, 0x0C, 0x6C, 0x38, 0x00, 0x00,

    0x00, 0x30, 0x78, 0xCC, 0x00, 0x7C, 0xC6, 0xC6, /* 0x88 '' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xCC, 0x00, 0x00, 0x7C, 0xC6, 0xC6, /* 0x89 '' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x18, 0x0C, 0x00, 0x7C, 0xC6, 0xC6, /* 0x8A '' */
    0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18, /* 0x8B '' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x18, 0x3C, 0x66, 0x00, 0x38, 0x18, 0x18, /* 0x8C '' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18, /* 0x8D '' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0xC6, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, /* 0x8E '' */
    0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x38, 0x6C, 0x38, 0x00, 0x38, 0x6C, 0xC6, 0xC6, /* 0x8F '' */
    0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x0C, 0x18, 0x30, 0x00, 0xFE, 0x60, 0x60, 0x7C, /* 0x90 '' */
    0x60, 0x60, 0x60, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x66, 0xDB, 0x1B, 0x7F, /* 0x91 '' */
    0xD8, 0xD8, 0xDF, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0xD8, 0xFE, /* 0x92 '' */
    0xd8, 0xD8, 0xD8, 0xDE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x78, 0xCC, 0x00, 0x7C, 0xC6, 0xC6, /* 0x93 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xC6, 0x00, 0x00, 0x7C, 0xC6, 0xC6, /* 0x94 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x18, 0x0C, 0x00, 0x7C, 0xC6, 0xC6, /* 0x95 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x30, 0x78, 0xCC, 0x00, 0xC6, 0xC6, 0xC6, /* 0x96 '' */
    0xC6, 0xC6, 0xCE, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x60, 0x30, 0x18, 0x00, 0xC6, 0xC6, 0xC6, /* 0x97 '' */
    0xC6, 0xC6, 0xCE, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0xC6, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x98 '' */
    0xCE, 0x76, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00,

    0x00, 0xC6, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x99 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0x9A '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x7C, 0xC6, 0xC0, 0xC0, /* 0x9B '' */
    0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x38, 0x6C, 0x60, 0x60, 0xF0, 0x60, 0x60, /* 0x9C '' */
    0x60, 0x66, 0xF6, 0x6C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, /* 0x9D '' */
    0x18, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xCC, 0xDE, /* 0x9E '' */
    0xCC, 0xCC, 0xCC, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0E, 0x1B, 0x18, 0x18, 0x18, 0x7E, 0x18, /* 0x9F '' */
    0x18, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00, 0x00,

    0x00, 0x0C, 0x18, 0x30, 0x00, 0x78, 0x0C, 0x7C, /* 0xA0 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0C, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18, /* 0xA1 '' */
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xC6, /* 0xA2 '' */
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x18, 0x30, 0x60, 0x00, 0xCC, 0xCC, 0xCC, /* 0xA3 '' */
    0xCC, 0xCC, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x76, 0xDC, 0x00, 0xBC, 0x66, 0x66, /* 0xA4 '' */
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x76, 0xBC, 0x00, 0xC6, 0xC6, 0xE6, 0xF6, /* 0xA5 '' */
    0xDE, 0xCE, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, /* 0xA6 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7E, 0x00, /* 0xA7 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x30, /* 0xA8 '' */
    0x60, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, /* 0xA9 '' */
    0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, /* 0xAA '' */
    0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x60, 0x60, 0x62, 0x66, 0x6C, 0x18, 0x30, /* 0xAB '' */
    0x60, 0xDC, 0x36, 0x0C, 0x18, 0x3E, 0x00, 0x00,

    0x00, 0x60, 0x60, 0x62, 0x66, 0x6C, 0x18, 0x36, /* 0xAC '' */
    0x6E, 0xDE, 0x36, 0x7E, 0x06, 0x06, 0x00, 0x00,

    0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x3C, /* 0xAD '' */
    0x3C, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6C, 0xD8, /* 0xAE '' */
    0x6C, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x6C, 0x36, /* 0xAF '' */
    0x6C, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, /* 0xB0 '' */
    0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,

    0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, /* 0xB1 '' */
    0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,

    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, /* 0xB2 '' */
    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0xB3 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, /* 0xB4 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, /* 0xB5 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, /* 0xB6 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, /* 0xB7 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0xF8, /* 0xB8 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0xF6, /* 0xB9 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, /* 0xBA '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0xF6, /* 0xBB '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xFE, /* 0xBC '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFE, /* 0xBD '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, /* 0xBE '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, /* 0xBF '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, /* 0xC0 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, /* 0xC1 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, /* 0xC2 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, /* 0xC3 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, /* 0xC4 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, /* 0xC5 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, /* 0xC6 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, /* 0xC7 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3F, /* 0xC8 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, /* 0xC9 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xFF, /* 0xCA '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, /* 0xCB '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, /* 0xCC '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, /* 0xCD '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xF7, /* 0xCE '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0xFF, /* 0xCF '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, /* 0xD0 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, /* 0xD1 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, /* 0xD2 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, /* 0xD3 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, /* 0xD4 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, /* 0xD5 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, /* 0xD6 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, /* 0xD7 '' */
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,

    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0xFF, /* 0xD8 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, /* 0xD9 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, /* 0xDA '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* 0xDB '' */
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0xDC '' */
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, /* 0xDD '' */
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,

    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, /* 0xDE '' */
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,

    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* 0xDF '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0xD8, 0xD8, /* 0xE0 '' */
    0xD8, 0xD8, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x78, 0xCC, 0xCC, 0xD8, 0xFC, 0xC6, /* 0xE1 '' */
    0xC6, 0xC6, 0xC6, 0xCC, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0x66, 0x62, 0x60, 0x60, 0x60, /* 0xE2 '' */
    0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x6C, 0x6C, /* 0xE3 '' */
    0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0xC6, 0x62, 0x30, 0x18, 0x18, /* 0xE4 '' */
    0x30, 0x62, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xCC, /* 0xE5 '' */
    0xCC, 0xCC, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, /* 0xE6 '' */
    0x66, 0x7C, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x18, /* 0xE7 '' */
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xFE, 0x38, 0x38, 0x6C, 0xC6, 0xC6, /* 0xE8 '' */
    0x6C, 0x38, 0x38, 0xFE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, /* 0xE9 '' */
    0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xC6, /* 0xEA '' */
    0x6C, 0x6C, 0x6C, 0xEE, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x3E, 0x60, 0x60, 0x3C, 0x66, 0xC6, /* 0xEB '' */
    0xC6, 0xC6, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xDB, 0xDB, /* 0xEC '' */
    0xDB, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x02, 0x06, 0x7C, 0xCE, 0xDE, 0xF6, /* 0xED '' */
    0xF6, 0x7C, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, /* 0xEE '' */
    0x60, 0x60, 0x30, 0x1C, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, /* 0xEF '' */
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, /* 0xF0 '' */
    0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, /* 0xF1 '' */
    0x18, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, /* 0xF2 '' */
    0x30, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, /* 0xF3 '' */
    0x0C, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x0C, 0x1E, 0x1A, 0x18, /* 0xF4 '' */
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0xF5 '' */
    0x18, 0x18, 0x58, 0x78, 0x30, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7E, /* 0xF6 '' */
    0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, /* 0xF7 '' */
    0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x00, /* 0xF8 '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, /* 0xF9 '' */
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0xFA '' */
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, /* 0xFB '' */
    0xD8, 0xD8, 0x78, 0x38, 0x18, 0x00, 0x00, 0x00,

    0x00, 0x00, 0xD8, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, /* 0xFC '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x70, 0xD8, 0x18, 0x30, 0x60, 0xF8, /* 0xFD '' */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, /* 0xFE '' */
    0x7E, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0xFF ''*/
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\init_m.h ===
/************************************************************************/
/*                                                                      */
/*                              INIT_M.H                                */
/*                                                                      */
/*        Sep 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.2  $
      $Date:   03 Feb 1995 15:16:10  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/init_m.h  $
 *
 *    Rev 1.2   03 Feb 1995 15:16:10   RWOLFF
 * Added prototypes for functions used in DCI support.
 *
 *    Rev 1.1   31 Mar 1994 15:06:00   RWOLFF
 * Added prototype for SetPowerManagement_m().
 *
 *    Rev 1.0   31 Jan 1994 11:42:04   RWOLFF
 * Initial revision.
 *
 *    Rev 1.2   14 Jan 1994 15:22:00   RWOLFF
 * Added prototype for ResetDevice_m(), global variable to store
 * extended register status when initializing bank manager.
 *
 *    Rev 1.1   30 Nov 1993 18:17:36   RWOLFF
 * Added logging of VCS revision comments to comment block at top of file.

End of PolyTron RCS section                             *****************/

#ifdef DOC
INIT_M.H - Header file for INIT_M.C

#endif


/*
 * Prototypes for functions supplied by INIT_M.C
 */
extern void AlphaInit_m(void);
extern void Initialize_m(void);
extern VP_STATUS MapVideoMemory_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS QueryPublicAccessRanges_m(PVIDEO_REQUEST_PACKET RequestPacket);
extern VP_STATUS QueryCurrentMode_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern VP_STATUS QueryAvailModes_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern void SetCurrentMode_m(struct query_structure *QueryPtr, struct st_mode_table *CrtTable);
extern void ResetDevice_m(void);
extern VP_STATUS SetPowerManagement_m(struct query_structure *QueryPtr, ULONG DpmsState);
DWORD GetPowerManagement_m(PHW_DEVICE_EXTENSION phwDeviceExtension);
extern VP_STATUS ShareVideoMemory_m(PVIDEO_REQUEST_PACKET RequestPacket, struct query_structure *QueryPtr);
extern void BankMap_m(ULONG BankRead, ULONG BankWrite, PVOID Context);


#ifdef INCLUDE_INIT_M
/*
 * Private definitions and variables used in INIT_M.C
 */

/*
 * Used to reset Mach 32 extended registers before going
 * to full screen DOS.
 */
WORD SavedExtRegs[] = {0x08B0, 0x00B6, 0x00B2};

static DWORD SavedDPMSState = VideoPowerOn;

#endif /* defined INCLUDE_INIT_M */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\makefile.inc ===
atimp.rc: vidlog.rc

vidlog.h vidlog.rc msg00001.bin: vidlog.mc
    mc -v vidlog.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\query_cx.h ===
/************************************************************************/
/*                                                                      */
/*                              QUERY_CX.H                              */
/*                                                                      */
/*       Oct 19  1993 (c) 1993, ATI Technologies Incorporated.          */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.14  $
      $Date:   01 May 1996 14:11:26  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/query_cx.h_v  $
 * 
 *    Rev 1.14   01 May 1996 14:11:26   RWolff
 * Added prototype for new routine DenseOnAlpha().
 * 
 *    Rev 1.13   23 Apr 1996 17:24:00   RWolff
 * Split mapping of memory types reported by BIOS into our enumeration
 * of memory types according to ASIC type, since ?T and ?X use the same
 * memory type code to refer to different memory types.
 * 
 *    Rev 1.12   15 Apr 1996 16:58:22   RWolff
 * Added prototype for routine which identifies which flavour of the
 * Mach 64 is in use.
 * 
 *    Rev 1.11   20 Mar 1996 13:45:38   RWolff
 * Increased size of buffer where screen is stored prior to video memory
 * being used to hold query information.
 * 
 *    Rev 1.10   01 Mar 1996 12:16:02   RWolff
 * Added definitions used for Alpha "blue screen" preservation.
 * 
 *    Rev 1.9   11 Jan 1996 19:43:32   RWolff
 * New definitions and structures to support use of AX=A?07 BIOS call rather
 * than special cases to restrict refresh rates.
 * 
 *    Rev 1.8   24 Feb 1995 12:29:18   RWOLFF
 * Prototype for TextBanding_cx()
 * 
 *    Rev 1.7   18 Nov 1994 11:54:14   RWOLFF
 * Split structures and internal variables so that they can be included
 * separately, as needed for no-BIOS support.
 * 
 *    Rev 1.6   14 Sep 1994 15:20:26   RWOLFF
 * Added definitions for all 32BPP colour orderings.
 * 
 *    Rev 1.5   31 Aug 1994 16:28:18   RWOLFF
 * Added support for 1152x864.
 * 
 *    Rev 1.4   30 Jun 1994 18:12:56   RWOLFF
 * Removed prototype for IsApertureConflict_cx() and definitions used
 * only by this function. Function moved to SETUP_CX.C because the
 * new method of checking for conflict requires access to definitions
 * and data structures which are only available in this module.
 * 
 *    Rev 1.3   12 May 1994 11:21:02   RWOLFF
 * Updated comment.
 * 
 *    Rev 1.2   27 Apr 1994 14:11:22   RWOLFF
 * Removed unused lookup table.
 * 
 *    Rev 1.1   07 Feb 1994 14:13:02   RWOLFF
 * Removed prototype for GetMemoryNeeded_cx().
 * 
 *    Rev 1.0   31 Jan 1994 11:43:00   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.2   14 Jan 1994 15:24:32   RWOLFF
 * Updated CX query structure to match BIOS version 0.13, added 1600x1200
 * support, prototype for BlockWriteAvail_cx()
 * 
 *    Rev 1.1   30 Nov 1993 18:27:38   RWOLFF
 * Prototypes for new routines, fields of cx_query structure now match
 * fields in structure returned by BIOS query call.
 * 
 *    Rev 1.0   05 Nov 1993 13:36:52   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
QUERY_CX.H - Header file for QUERY_CX.C

#endif


/*
 * Definitions for deep colour and RAMDAC special features support,
 * stored in q_shadow_1 field (Mach 64 does not use shadow sets)
 * of query_structure.
 */
#define S1_SYNC_ON_GREEN    0x8000
#define S1_GAMMA_CORRECT    0x4000
#define S1_GREYSCALE_256    0x2000
#define S1_SLEEPMODE        0x1000
#define S1_32BPP            0x00F0
#define S1_32BPP_xRGB       0x0080
#define S1_32BPP_BGRx       0x0040
#define S1_32BPP_RGBx       0x0020
#define S1_32BPP_xBGR       0x0010
#define S1_24BPP            0x000C
#define S1_24BPP_BGR        0x0008
#define S1_24BPP_RGB        0x0004
#define S1_16BPP            0x0003
#define S1_16BPP_555        0x0002
#define S1_16BPP_565        0x0001



/*
 * Prototypes for functions provided by QUERY_CX.C
 */
extern int DetectMach64(void);
extern VP_STATUS QueryMach64(struct query_structure *Query);
extern BOOL BlockWriteAvail_cx(struct query_structure *Query);
extern BOOL TextBanding_cx(struct query_structure *Query);
extern PWSTR IdentifyMach64Asic(struct query_structure *Query, PULONG AsicStringLength);
#if defined(ALPHA)
extern BOOL DenseOnAlpha(struct query_structure *Query);
#endif


/*
 * Structures used in QUERY_CX.C and (on non-x86 machines with no
 * emulation, so VideoPortInt10() is not available) modules which
 * emulate the query functions of the BIOS.
 */
#ifdef STRUCTS_QUERY_CX

/*
 * Hardware capability structure returned by BIOS call AX=0xA?07.
 */
#pragma pack(1)
struct cx_hw_cap{
    BYTE cx_HorRes;             /* Horizontal resolution in units of 8 pixels */
    BYTE cx_RamOrDacType;       /* RAM type or bitmask of DAC types */
    BYTE cx_MemReq;             /* Minimum memory to support the mode in question */
    BYTE cx_MaxDotClock;        /* Maximum dot clock, in megahertz */
    BYTE cx_MaxPixDepth;        /* Code for maximum pixel depth for the mode in question */
};

/*
 * Query structure returned by CX BIOS call AX=0xA?09. This structure
 * is NOT interchangeable with query_structure from AMACH1.H.
 *
 * The alignment of fields within the BIOS query and mode table
 * structures does not match the default structure alignment of the
 * Windows NT C compiler, so we must force byte alignment.
 */
struct cx_query{
    WORD cx_sizeof_struct;      /* Size of the structure in bytes */
    BYTE cx_structure_rev;      /* Structure revision number */
    BYTE cx_number_modes;       /* Number of mode tables */
    WORD cx_mode_offset;        /* Offset in bytes to first mode table */
    BYTE cx_mode_size;          /* Size of each mode table */
    BYTE cx_vga_type;           /* VGA enabled/disabled status */
    WORD cx_asic_rev;           /* ASIC revision */
    BYTE cx_vga_boundary;       /* VGA boundary */
    BYTE cx_memory_size;        /* Amount of memory installed */
    BYTE cx_dac_type;           /* DAC type */
    BYTE cx_memory_type;        /* Type of memory chips installed */
    BYTE cx_bus_type;           /* Bus type */
    BYTE cx_special_sync;       /* Flags for composite sync and sync on green */
    WORD cx_aperture_addr;      /* Aperture address in megabytes (0-4095) */
    BYTE cx_aperture_cfg;       /* Aperture configuration */
    BYTE cx_deep_colour;        /* Deep colour support information */
    BYTE cx_ramdac_info;        /* Special features available from DAC */
    BYTE cx_reserved_1;         /* Reserved */
    WORD cx_current_mode;       /* Offset of current mode table */
    WORD cx_io_base;            /* I/O base address */
    BYTE cx_reserved_2[6];      /* Reserved */
};

/*
 * Mode table structure returned by CX BIOS call AX=0xA?09. This structure
 * is NOT interchangeable with st_mode_table from AMACH1.H.
 */
struct cx_mode_table{
    WORD cx_x_size;             /* Horizontal resolution in pixels */
    WORD cx_y_size;             /* Vertical resolution in pixels */
    BYTE cx_pixel_depth;        /* Maximum pixel depth */
    BYTE cx_reserved_1;         /* Reserved */
    WORD cx_eeprom_offset;      /* Offset of table into EEPROM */
    WORD cx_reserved_2;         /* Reserved */
    WORD cx_reserved_3;         /* Reserved */
    WORD cx_crtc_gen_cntl;      /* Interlace and double scan status */
    BYTE cx_crtc_h_total;       /* CRTC_H_TOTAL value */
    BYTE cx_crtc_h_disp;        /* CRTC_H_DISP value */
    BYTE cx_crtc_h_sync_strt;   /* CRTC_H_SYNC_STRT value */
    BYTE cx_crtc_h_sync_wid;    /* CRTC_H_SYNC_WID value */
    WORD cx_crtc_v_total;       /* CRTC_V_TOTAL value */
    WORD cx_crtc_v_disp;        /* CRTC_V_DISP value */
    WORD cx_crtc_v_sync_strt;   /* CRTC_V_SYNC_STRT value */
    BYTE cx_crtc_v_sync_wid;    /* CRTC_V_SYNC_WID value */
    BYTE cx_clock_cntl;         /* Clock selector and divider */
    WORD cx_dot_clock;          /* Dot clock for programmable clock chip */
    WORD cx_h_overscan;         /* Horizontal overscan information */
    WORD cx_v_overscan;         /* Vertical overscan information */
    WORD cx_overscan_8b;        /* 8BPP and blue overscan colour */
    WORD cx_overscan_gr;        /* Green and red overscan colour */
};
#pragma pack()

#endif  /* defined STRUCTS_QUERY_CX */


#ifdef INCLUDE_QUERY_CX
/*
 * Private definitions used in QUERY_CX.C
 */

#define FORMAT_DACMASK  0   /* cx_hw_cap.cx_RamOrDacType is mask of DAC types */
#define FORMAT_RAMMASK  1   /* cx_hw_cap.cx_RamOrDacType is mask of RAM types */
#define FORMAT_DACTYPE  2   /* cx_hw_cap.cx_RamOrDacType is DAC type */
#define FORMAT_RAMTYPE  3   /* cx_hw_cap.cx_RamOrDacType is RAM type */

/*
 * The following definitions are used in creating a buffer where the
 * contents of an existing VGA graphics screen and specific VGA registers
 * are stored in preparation for using the screen as a buffer below
 * 1M physical in order to store the BIOS query information. It is
 * assumed that the temporary buffer used to store this information
 * is an array of unsigned characters.
 *
 * According to Arthur Lai, older BIOSes determined the required size
 * of the query buffer at runtime by examining the installed modes,
 * while newer BIOSes take a buffer large enough to handle the worst
 * case scenario in order to reduce code size. This should never be
 * larger than 1 kilobyte. In the unlikely event that this is exceeded,
 * we will save the first kilobyte and allow the remainder to be
 * overwritten by query data, rather than overflowing our save buffer.
 */
#define VGA_SAVE_SIZE   1024    /* Array location where size of buffer is stored */
#define VGA_SAVE_SIZE_H 1025
#define VGA_SAVE_SEQ02  1026    /* Array location where sequencer register 2 value stored */
#define VGA_SAVE_GRA08  1027    /* Array location where graphics register 8 value stored */
#define VGA_SAVE_GRA01  1028    /* Array location where graphics register 1 value stored */
#define VGA_TOTAL_SIZE  1029    /* Size of screen/register save buffer */

/*
 * Pixel depths for use as an array index. Two columns will be wasted
 * since there is no depth code equal to zero and we don't use 15BPP,
 * but this allows direct indexing using the pixel width field of the
 * hardware capabilities structure returned by BIOS call AX=0xA?07.
 */
enum {
    DEPTH_NOTHING = 0,
    DEPTH_4BPP,
    DEPTH_8BPP,
    DEPTH_15BPP,
    DEPTH_16BPP,
    DEPTH_24BPP,
    DEPTH_32BPP,
    HOW_MANY_DEPTHS
    };    

/*
 * Mappings of Mach 64 query values to enumerations from AMACH1.H
 */
UCHAR CXMapMemSize[8] =
    {
    VRAM_512k,
    VRAM_1mb,
    VRAM_2mb,
    VRAM_4mb,
    VRAM_6mb,
    VRAM_8mb
    };

UCHAR CXMapRamType[7] =
    {
    VMEM_DRAM_256Kx16,
    VMEM_VRAM_256Kx4_SER512,
    VMEM_VRAM_256Kx16_SER256,
    VMEM_DRAM_256Kx4,
    VMEM_DRAM_256Kx4_GRAP,  /* Space filler - type 4 not documented */
    VMEM_VRAM_256Kx4_SPLIT512,
    VMEM_VRAM_256Kx16_SPLIT256
    };

UCHAR CTMapRamType[7] =
    {
    VMEM_GENERIC_DRAM,      /* Space filler - type 0 not documented */
    VMEM_GENERIC_DRAM,
    VMEM_EDO_DRAM,
    VMEM_BRRAM,
    VMEM_SDRAM,
    VMEM_GENERIC_DRAM,      /* Space filler - type 5 not documented */
    VMEM_GENERIC_DRAM       /* Space filler - type 6 not documented */
    };

UCHAR CXMapBus[8] =
    {
    BUS_ISA_16,     /* ISA bus */
    BUS_EISA,
    BUS_ISA_8,      /* Use "weakest" bus for types marked as reserved */
    BUS_ISA_8,      /* Reserved */
    BUS_ISA_8,      /* Reserved */
    BUS_ISA_8,      /* Reserved */
    BUS_LB_486,     /* Mach 64 lumps all VLB types together */
    BUS_PCI
    };

/*
 * Lookup table to translate the code for maximum colour depth returned
 * in the BIOS mode tables into bits per pixel.
 */
USHORT CXPixelDepth[7] =
    {
    0,      /* Undefined */
    4,
    8,
    16,     /* xRRR RRGG GGGB BBBB */
    16,     /* RRRR RGGG GGGB BBBB */
    24,
    32
    };

/*
 * Used in searching mode tables for desired resolution.
 */
USHORT CXHorRes[6] =
    {
    640,
    800,
    1024,
    1152,
    1280,
    1600
    };

/*
 * Flags to show that a given resolution is supported.
 */
UCHAR CXStatusFlags[6] =
    {
    VRES_640x480,
    VRES_800x600,
    VRES_1024x768,
    VRES_1152x864,
    VRES_1280x1024,
    VRES_1600x1200
    };

#endif  /* defined INCLUDE_QUERY_CX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\modes_m.c ===
/************************************************************************/
/*                                                                      */
/*                               MODES_M.C                              */
/*                                                                      */
/*          (c) 1991,1992, 1993    ATI Technologies Incorporated.       */
/************************************************************************/

/**********************       PolyTron RCS Utilities

    $Revision:   1.18  $
    $Date:   10 Apr 1996 17:00:44  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/modes_m.c_v  $
 *
 *    Rev 1.18   10 Apr 1996 17:00:44   RWolff
 * Microsoft-originated change.
 *
 *    Rev 1.17   23 Jan 1996 11:46:36   RWolff
 * Eliminated level 3 warnings.
 *
 *    Rev 1.16   08 Feb 1995 13:54:38   RWOLFF
 * Updated FIFO depth entries to correspond to more recent table.
 *
 *    Rev 1.15   20 Jan 1995 16:23:04   RWOLFF
 * Optimized video FIFO depth for the installed RAM size and selected
 * resolution, pixel depth, and refresh rate. This gives a slight performance
 * improvement on low-res, low-depth, low frequency modes while eliminating
 * noise on high-res, high-depth, high frequency modes.
 *
 *    Rev 1.14   23 Dec 1994 10:47:24   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.13   18 Nov 1994 11:40:54   RWOLFF
 * Added support for STG1702/1703 in native mode, as opposed to being
 * strapped into STG1700 emulation.
 *
 *    Rev 1.12   19 Aug 1994 17:11:26   RWOLFF
 * Added support for SC15026 DAC and non-standard pixel clock
 * generators, removed dead code.
 *
 *    Rev 1.11   09 Aug 1994 11:53:58   RWOLFF
 * Shifting of colours when setting up palette is now done in
 * display driver.
 *
 *    Rev 1.10   06 Jul 1994 16:23:58   RWOLFF
 * Fix for screen doubling when warm booting from ATI driver to 8514/A
 * driver on Mach 32.
 *
 *    Rev 1.9   30 Jun 1994 18:10:44   RWOLFF
 * Andre Vachon's change: don't clear screen on switch into text mode.
 * The HAL will do it, and we aren't allowed to do the memory mapping
 * needed to clear the screen.
 *
 *    Rev 1.8   20 May 1994 14:00:40   RWOLFF
 * Ajith's change: clears the screen on shutdown.
 *
 *    Rev 1.7   18 May 1994 17:01:18   RWOLFF
 * Fixed colour scramble in 16 and 24BPP on IBM ValuePoint (AT&T 49[123]
 * DAC), got rid of debug print statements and commented-out code.
 *
 *    Rev 1.6   31 Mar 1994 15:07:00   RWOLFF
 * Added debugging code.
 *
 *    Rev 1.5   16 Mar 1994 15:28:02   RWOLFF
 * Now determines DAC type using q_DAC_type field of query structure,
 * rather than raw value from CONFIG_STATUS_1. This allows different
 * DAC types reporting the same value to be distinguished.
 *
 *    Rev 1.4   14 Mar 1994 16:28:10   RWOLFF
 * Routines used by ATIMPResetHw() are no longer swappable, SetTextMode_m()
 * returns after toggling passthrough on Mach 8.
 *
 *    Rev 1.3   10 Feb 1994 16:02:34   RWOLFF
 * Fixed out-of-sync problem in 640x480 16BPP 60Hz.
 *
 *    Rev 1.2   08 Feb 1994 19:00:22   RWOLFF
 * Fixed pixel delay for Brooktree 48x DACs. This corrects flickering pixels
 * at 8BPP and unstable colours at 16 and 24 BPP.
 *
 *    Rev 1.1   07 Feb 1994 14:09:02   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 *
 *    Rev 1.0   31 Jan 1994 11:11:36   RWOLFF
 * Initial revision.
 *
 *    Rev 1.10   24 Jan 1994 18:05:36   RWOLFF
 * Now expects mode tables for 16 and 24 BPP on BT48x and AT&T 49[123] DACs
 * to already contain modified pixel clock and other fields, rather than
 * increasing pixel clock frequency when setting the video mode.
 *
 *    Rev 1.9   14 Jan 1994 15:22:36   RWOLFF
 * Added routine to switch into 80x25 16 colour text mode without using BIOS.
 *
 *    Rev 1.8   15 Dec 1993 15:27:32   RWOLFF
 * Added support for SC15021 DAC.
 *
 *    Rev 1.7   30 Nov 1993 18:18:40   RWOLFF
 * Added support for AT&T 498 DAC, 32BPP on STG1700 DAC.
 *
 *    Rev 1.6   10 Nov 1993 19:24:28   RWOLFF
 * Re-enabled MUX handling of 1280x1024 8BPP as special case of InitTi_8_m(),
 * fix for dark DOS full-screen on TI DAC cards.
 *
 *    Rev 1.5   05 Nov 1993 13:26:14   RWOLFF
 * Added support for STG1700 DAC.
 *
 *    Rev 1.4   15 Oct 1993 18:13:18   RWOLFF
 * Fix for memory-mapped scrambled screen.
 *
 *    Rev 1.3   08 Oct 1993 15:18:08   RWOLFF
 * No longer includes VIDFIND.H.
 *
 *    Rev 1.2   08 Oct 1993 11:11:04   RWOLFF
 * Added "_m" to function names to identify them as being specific to the
 * 8514/A-compatible family of ATI accelerators.
 *
 *    Rev 1.1   24 Sep 1993 18:15:08   RWOLFF
 * Added support for AT&T 49x DACs.
 *
 *    Rev 1.1   24 Sep 1993 11:47:14   RWOLFF
 * Added support for AT&T 49x DACs.
 *
 *    Rev 1.0   03 Sep 1993 14:23:48   RWOLFF
 * Initial revision.

           Rev 1.0   16 Aug 1993 13:29:28   Robert_Wolff
        Initial revision.

           Rev 1.18   06 Jul 1993 15:49:46   RWOLFF
        Removed mach32_split_fixup special handling (for non-production hardware),
        added support for AT&T 491 and ATI 68860 DACs. Unable to obtain appropriate
        hardware to test the DAC-related changes, must still add routine to
        distinguish AT&T 491 from Brooktree 48x when setting q_dac_type.

           Rev 1.17   07 Jun 1993 11:43:42   BRADES
        Rev 6 split transfer fixup.

           Rev 1.15   18 May 1993 14:06:04   RWOLFF
        Calls to wait_for_idle() no longer pass in hardware device extension,
        since it's a global variable.

           Rev 1.14   27 Apr 1993 20:16:28   BRADES
        do not use IO register+1 since now from Linear address table.

           Rev 1.13   21 Apr 1993 17:25:22   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.

           Rev 1.12   14 Apr 1993 18:22:26   RWOLFF
        High-colour initialization now supports Bt481 DAC.

           Rev 1.11   08 Apr 1993 16:50:48   RWOLFF
        Revision level as checked in at Microsoft.

           Rev 1.10   15 Mar 1993 22:19:28   BRADES
        use m_screen_pitch for the # pixels per display line.

           Rev 1.9   08 Mar 1993 19:29:30   BRADES
        submit to MS NT

           Rev 1.6   06 Jan 1993 10:59:20   Robert_Wolff
        ROM BIOS area C0000-DFFFF is now mapped as a single block,
        added type casts to eliminate compile warnings.

           Rev 1.5   04 Jan 1993 14:42:18   Robert_Wolff
        Added card type as a parameter to setmode(). This is done because the
        Mach 32 requires GE_PITCH and CRT_PITCH to be set to the horizontal
        resolution divided by 8, while the Mach 8 requires them to be set
        to the smallest multiple of 128 which is not less than the horizontal
        resolution, divided by 8. This difference is only significant for
        800x600, since 640x480, 1024x768, and 1280x1024 all have horizontal
        resolutions which are already multiples of 128 pixels.

           Rev 1.4   09 Dec 1992 10:31:52   Robert_Wolff
        Made setmode() compatible with Mach 8 cards in 800x600 mode, Get_clk_src()
        will now compile properly under both MS-DOS and Windows NT.

           Rev 1.3   27 Nov 1992 15:18:58   STEPHEN
        No change.

           Rev 1.2   17 Nov 1992 14:09:24   GRACE
        program the palette here instead of in a68_init.asm

           Rev 1.1   12 Nov 1992 09:29:04   GRACE
        removed all the excess baggage carried over from the video program.

           Rev 1.0   05 Nov 1992 14:02:22   Robert_Wolff
        Initial revision.



End of PolyTron RCS section                             *****************/

#ifdef DOC
 MODES_M.C -  Functions to switch the 8514/A-compatible family of
                ATI Graphics Accelerator adapters into ALL supported modes
   Note:  Different DACs have a different use for the DAC registers
   in IO space 2EA-2ED.  The DAC_MASK, DAC_R_INDEX may be misleading.


OTHER FILES

#endif


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "detect_m.h"

#define INCLUDE_MODES_M
#include "modes_m.h"
#include "services.h"
#include "setup_m.h"


#define NUM_ROM_BASE_RANGES 2

#if DBG
#if defined(i386) || defined(_X86_)
#define INT	_asm int 3;
#else
#define INT DbgBreakPoint();
#endif
#else
#define INT
#endif



static void InitTIMux_m(int config,ULONG_PTR rom_address);
static BYTE GetClkSrc_m(ULONG *rom_address);
static void SetBlankAdj_m(BYTE adjust);
static void Init68860_m(WORD ext_ge_config);
static void InitSTG1700_m(WORD ext_ge_config, BOOL DoublePixel);
static void InitSTG1702_m(WORD ext_ge_config, BOOL DoublePixel);
static void InitATT498_m(WORD ext_ge_config, BOOL DoublePixel);
static void InitSC15021_m(WORD ext_ge_config, BOOL DoublePixel);
static void InitSC15026_m(WORD ext_ge_config);
static void ReadDac4(void);



/*
 * Allow miniport to be swapped out when not needed.
 *
 * SetTextMode_m() and Passth8514_m() are called by ATIMPResetHw(),
 * which must be in nonpageable memory.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, setmode_m)
#pragma alloc_text(PAGE_M, InitTIMux_m)
#pragma alloc_text(PAGE_M, GetClkSrc_m)
#pragma alloc_text(PAGE_M, SetBlankAdj_m)
#pragma alloc_text(PAGE_M, InitTi_8_m)
#pragma alloc_text(PAGE_M, InitTi_16_m)
#pragma alloc_text(PAGE_M, InitTi_24_m)
#pragma alloc_text(PAGE_M, Init68860_m)
#pragma alloc_text(PAGE_M, InitSTG1700_m)
#pragma alloc_text(PAGE_M, InitSTG1702_m)
#pragma alloc_text(PAGE_M, InitATT498_m)
#pragma alloc_text(PAGE_M, InitSC15021_m)
#pragma alloc_text(PAGE_M, InitSC15026_m)
#pragma alloc_text(PAGE_M, ReadDac4)
#pragma alloc_text(PAGE_M, UninitTiDac_m)
#pragma alloc_text(PAGE_M, SetPalette_m)
#endif



/*
 * void Passth8514_m(status)
 *
 * int status;      Desired source for display
 *
 * Turn passthrough off (accelerator mode) if status is SHOW_ACCEL,
 * or on (vga passthrough) if status is SHOW_VGA.
 *
 * Note that this routine is specific to ATI graphics accelerators.
 * Generic 8514/A routine should also include setting up CRT parameters
 * to ensure that the DAC gets a reasonable clock rate.
 */
void Passth8514_m(int status)
{

    OUTP(DISP_CNTL,0x53);		/* disable CRT controller */

    if (status == SHOW_ACCEL)
        {
        OUTPW(ADVFUNC_CNTL,0x7);
        OUTPW(CLOCK_SEL,(WORD)(INPW(CLOCK_SEL)|1));     /* slow down the clock rate */
        }
    else
        {
        OUTPW(ADVFUNC_CNTL,0x6);
        OUTPW(CLOCK_SEL,(WORD)(INPW(CLOCK_SEL)&0xfffe));    /* speed up the clock rate */
        }
    OUTP(DISP_CNTL,0x33);		/* enable CRT controller */

    return;

}   /* Passth8514_m() */



/*
 * void setmode_m(crttable, rom_address, CardType);
 *
 * struct st_mode_table *crttable;  CRT parameters for desired mode
 * ULONG_PTR rom_address;           Location of ROM BIOS (virtual address)
 * ULONG CardType;                  Type of ATI accelerator
 *
 * Initialize the CRT controller in the 8514/A-compatible
 * family of ATI accelerators.
 */
void setmode_m (struct st_mode_table *crttable, ULONG_PTR rom_address, ULONG CardType)
{
    BYTE clock;
    WORD overscan;
    BYTE low,high;
    WORD ClockSelect;   /* Value to write to CLOCK_SEL register */
    struct query_structure *QueryPtr;   /* Query information for the card */
    ULONG BaseClock;    /* Pixel rate not adjusted for DAC type and pixel depth */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    ClockSelect = (crttable->m_clock_select & CLOCK_SEL_STRIP) | GetShiftedSelector(crttable->ClockFreq);

    WaitForIdle_m();

    OUTP(SHADOW_SET, 2);                    /* unlock shadows */
    DEC_DELAY
    DEC_DELAY
    OUTP(SHADOW_CTL, 0);
    DEC_DELAY
    OUTP(SHADOW_SET, 1);
    DEC_DELAY
    OUTP(SHADOW_CTL, 0);
    DEC_DELAY
    OUTP(SHADOW_SET, 0);
    DEC_DELAY

    /* disable CRT controller */

    OUTP(DISP_CNTL,0x53);
    delay(10);

    OUTP(CLOCK_SEL,	(UCHAR)(ClockSelect | 0x01 ));  /* Disable passthrough */
    DEC_DELAY
    OUTP(V_SYNC_WID,	crttable->m_v_sync_wid);
    DEC_DELAY
    OUTPW(V_SYNC_STRT,	crttable->m_v_sync_strt);
    DEC_DELAY
    OUTPW(V_DISP,	crttable->m_v_disp);
    DEC_DELAY
    OUTPW(V_TOTAL,	crttable->m_v_total);
    DEC_DELAY
    OUTP(H_SYNC_WID,	crttable->m_h_sync_wid);
    DEC_DELAY
    OUTP(H_SYNC_STRT,	crttable->m_h_sync_strt);
    DEC_DELAY
    OUTP(H_DISP,	crttable->m_h_disp);
    DEC_DELAY
    OUTP(H_TOTAL,	crttable->m_h_total);
    DEC_DELAY

    OUTP(GE_PITCH,  (UCHAR) (crttable->m_screen_pitch >> 3));
    DEC_DELAY
    OUTP(CRT_PITCH, (UCHAR) (crttable->m_screen_pitch >> 3));
    delay(10);

    OUTP(DISP_CNTL,	crttable->m_disp_cntl);
    delay(10);

    /*
     * Set up the Video FIFO depth. This field is used only on DRAM cards.
     * Since the required FIFO depth depends on 4 values (memory size,
     * pixel depth, resolution, and refresh rate) which are not enumerated
     * types, implementing the selection as an array indexed by these
     * values would require a very large, very sparse array.
     *
     * Select DRAM cards by excluding all known VRAM types rather than
     * by including all known DRAM types because only 7 of the 8 possible
     * memory types are defined. If the eighth type is VRAM and we include
     * it because it's not in the exclusion list, the value we assign will
     * be ignored. If it's DRAM and we exclude it because it's not in the
     * inclusion list, we will have problems.
     */
    if ((QueryPtr->q_memory_type != VMEM_VRAM_256Kx4_SER512) &&
        (QueryPtr->q_memory_type != VMEM_VRAM_256Kx4_SER256) &&
        (QueryPtr->q_memory_type != VMEM_VRAM_256Kx4_SPLIT512) &&
        (QueryPtr->q_memory_type != VMEM_VRAM_256Kx16_SPLIT256))
        {
        /*
         * We can't switch on the refresh rate because if we're setting
         * the mode from the installed mode table rather than one of the
         * "canned" tables, the refresh rate field will hold a reserved
         * value rather than the true rate. Instead, use the pixel rate,
         * which varies with refresh rate. We can't simply use the pixel
         * clock frequency, since it will have been boosted for certain
         * DAC and pixel depth combinations. Instead, we must undo this
         * boost in order to get the pixel rate.
         */
        switch (crttable->m_pixel_depth)
            {
            case 24:
                if ((QueryPtr->q_DAC_type == DAC_BT48x) ||
                    (QueryPtr->q_DAC_type == DAC_SC15026) ||
                    (QueryPtr->q_DAC_type == DAC_ATT491))
                    {
                    BaseClock = crttable->ClockFreq / 3;
                    }
                else if ((QueryPtr->q_DAC_type == DAC_SC15021) ||
                    (QueryPtr->q_DAC_type == DAC_STG1702) ||
                    (QueryPtr->q_DAC_type == DAC_STG1703))
                    {
                    BaseClock = crttable->ClockFreq * 2;
                    BaseClock /= 3;
                    }
                else if ((QueryPtr->q_DAC_type == DAC_STG1700) ||
                    (QueryPtr->q_DAC_type == DAC_ATT498))
                    {
                    BaseClock = crttable->ClockFreq / 2;
                    }
                else
                    {
                    BaseClock = crttable->ClockFreq;
                    }
                break;

            case 16:
                if ((QueryPtr->q_DAC_type == DAC_BT48x) ||
                    (QueryPtr->q_DAC_type == DAC_SC15026) ||
                    (QueryPtr->q_DAC_type == DAC_ATT491))
                    {
                    BaseClock = crttable->ClockFreq / 2;
                    }
                else
                    {
                    BaseClock = crttable->ClockFreq;
                    }
                break;

            case 8:
            default:
                BaseClock = crttable->ClockFreq;
                break;
            }

        /*
         * 1M cards include Mach 8 combo cards which report the total
         * (accelerator plus VGA) memory in q_memory_size. Since the
         * maximum VGA memory on these cards is 512k, none of them will
         * report 2M. If we were to look for 1M cards, we'd also have to
         * check for 1.25M and 1.5M cards in order to catch the combos.
         *
         * Some threshold values of BaseClock are chosen to catch both
         * straight-through (DAC displays 1 pixel per clock) and adjusted
         * (DAC needs more than 1 clock per pixel) cases, and so do not
         * correspond to the pixel clock frequency for any mode.
         */
        if (QueryPtr->q_memory_size == VRAM_2mb)
            {
            switch (crttable->m_pixel_depth)
                {
                case 24:
                    /*
                     * Only 640x480 and 800x600 suported.
                     */
                    if (crttable->m_x_size == 640)
                        {
                        if (BaseClock < 30000000L)    /* 60Hz */
                            clock = 0x08;
                        else    /* 72Hz */
                            clock = 0x0A;
                        }
                    else    /* 800x600 */
                        {
                        if (BaseClock <= 32500000)  /* 89Hz  interlaced */
                            clock = 0x0A;
                        else if (BaseClock <= 36000000) /* 95Hz interlaced and 56Hz */
                            clock = 0x0C;
                        else if (BaseClock <= 40000000) /* 60Hz */
                            clock = 0x0D;
                        else    /* 70Hz and 72Hz */
                            clock = 0x0E;
                        }
                    break;

                case 16:
                    /*
                     * All resolutions except 1280x1024 supported.
                     */
                    if (crttable->m_x_size == 640)
                        {
                        if (BaseClock < 30000000L)    /* 60Hz */
                            clock = 0x04;
                        else    /* 72Hz */
                            clock = 0x05;
                        }
                    else if (crttable->m_x_size == 800)
                        {
                        if (BaseClock <= 40000000) /* 89Hz and 95Hz interlaced, 56Hz, and 60Hz */
                            clock = 0x05;
                        else if (BaseClock <= 46000000) /* 70Hz */
                            clock = 0x07;
                        else    /* 72Hz */
                            clock = 0x08;
                        }
                    else    /* 1024x768 */
                        {
                        if (BaseClock < 45000000)   /* 87Hz interlaced */
                            {
                            clock = 0x07;
                            }
                        else if (BaseClock < 70000000)  /* 60Hz */
                            {
                            clock = 0x0B;
                            }
                        else    /* 66Hz, 70Hz, and 72Hz */
                            {
                            clock = 0x0D;
                            }
                        }
                    break;

                case 8:
                default:    /* If 4BPP is implemented, it will be treated like 8BPP */
                    if (crttable->m_x_size == 640)
                        {
                        /*
                         * Both available refresh rates use the same value
                         */
                        clock = 0x02;
                        }
                    else if (crttable->m_x_size == 800)
                        {
                        if (BaseClock <= 46000000) /* 89Hz and 95Hz interlaced, 56Hz, 60Hz, and 70Hz */
                            clock = 0x02;
                        else    /* 72Hz */
                            clock = 0x04;
                        }
                    else if (crttable->m_x_size == 1024)
                        {
                        if (BaseClock < 45000000)   /* 87Hz interlaced */
                            {
                            clock = 0x03;
                            }
                        else if (BaseClock < 70000000)  /* 60Hz */
                            {
                            clock = 0x05;
                            }
                        else    /* 66Hz, 70Hz, and 72Hz */
                            {
                            clock = 0x06;
                            }
                        }
                    else    /* 1280x1024 */
                        {
                        if (BaseClock < 100000000)  /* both interlaced modes */
                            clock = 0x07;
                        else    /* 60Hz - only DRAM noninterlaced mode */
                            clock = 0x0A;
                        }
                    break;
                }
            }
        else    /* 1M cards */
            {
            switch (crttable->m_pixel_depth)
                {
                case 24:
                    /*
                     * Only 640x480 fits in 1M. Both 60Hz and 72Hz
                     * use the same FIFO depth.
                     */
                    clock = 0x0E;
                    break;

                case 16:
                    /*
                     * Only 640x480 and 800x600 suported.
                     */
                    if (crttable->m_x_size == 640)
                        {
                        if (BaseClock < 30000000L)    /* 60Hz */
                            clock = 0x08;
                        else    /* 72Hz */
                            clock = 0x0A;
                        }
                    else    /* 800x600 */
                        {
                        if (BaseClock <= 32500000)  /* 89Hz  interlaced */
                            clock = 0x0A;
                        else    /* 95Hz interlaced and 56Hz, higher rates not supported in 1M */
                            clock = 0x0C;
                        }
                    break;

                case 8:
                default:    /* If 4BPP is implemented, it will be treated like 8BPP */
                    if (crttable->m_x_size == 640)
                        {
                        if (BaseClock < 30000000L)    /* 60Hz */
                            clock = 0x04;
                        else    /* 72Hz */
                            clock = 0x05;
                        }
                    else if (crttable->m_x_size == 800)
                        {
                        if (BaseClock <= 32500000)  /* 89Hz  interlaced */
                            clock = 0x05;
                        else if (BaseClock <= 40000000) /* 95Hz interlaced, 56Hz, and 60Hz */
                            clock = 0x06;
                        else if (BaseClock <= 46000000) /* 70Hz */
                            clock = 0x07;
                        else    /* 72Hz */
                            clock = 0x08;
                        }
                    else if (crttable->m_x_size == 1024)
                        {
                        if (BaseClock < 45000000)   /* 87Hz interlaced */
                            {
                            clock = 0x07;
                            }
                        else    /* 60Hz, 66Hz, 70Hz, and 72Hz */
                            {
                            clock = 0x08;
                            }
                        }
                    else    /* 1280x1024 */
                        {
                        /*
                         * Only interlaced modes supported in 1M (4BPP only),
                         * both use the same FIFO depth.
                         */
                        clock = 0x03;
                        }

                    break;
                }
            }

        WaitForIdle_m();
        OUTPW (CLOCK_SEL, (WORD)((clock << 8) | (ClockSelect & 0x00FF) | 0x01));
        DEC_DELAY
        }

    overscan=crttable->m_h_overscan;
    low=(BYTE)(overscan&0xff);
    high=(BYTE)(overscan>>8);

    high=high>>4;
    low=low&0xf;
    if (high>=low)
        high=low;
    else
        low=high;
    high=high<<4;
    low=low|high;

    WaitForIdle_m();
    OUTPW(HORZ_OVERSCAN,(WORD)(low & 0x00FF));
    DEC_DELAY

    overscan=crttable->m_v_overscan;
    low=(BYTE)(overscan&0xff);
    high=(BYTE)(overscan>>8);

    if (high>=low)
        high=low;
    else
        low=high;

    high <<= 8;
    overscan=(WORD)high + (WORD)low;

    OUTPW(VERT_OVERSCAN,overscan);
    DEC_DELAY
    return;

}   /* setmode_m() */



/*
 * void InitTIMux_m(config, rom_address);
 *
 * int config;          Default EXT_GE_CONFIG (should be 0x10A or 0x11A)
 * ULONG_PTR rom_address;   Virtual address of start of ROM BIOS
 *
 * Put TI DAC into MUX mode for 1280x1024 non-interlaced displays.
 */
void InitTIMux_m(int config,ULONG_PTR rom_address)
{
    struct query_structure *QueryPtr;   /* Query information for the card */
    WORD    reg;
    WORD    temp;

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    if (QueryPtr->q_DAC_type == DAC_TI34075)
        {
        reg=INPW(CLOCK_SEL);
        temp = (reg & CLOCK_SEL_STRIP) | GetShiftedSelector(50000000L);
        OUTPW(CLOCK_SEL,temp);
        OUTPW(EXT_GE_CONFIG,0x201a);        /* Set EXT_DAC_ADDR field */
        OUTP(DAC_MASK,9);	/* OUTPut clock is SCLK/2 and VCLK/2 */
        OUTP(DAC_R_INDEX,0x1d);        /* set MUX control to 8/16 */

        /* INPut clock source is CLK3 or CLK1 (most current release) */
        OUTP(DAC_DATA,GetClkSrc_m((ULONG *) rom_address));

        /* reset EXT_DAC_ADDR, put DAC in 6 bit mode, engine in 8 bit mode, enable MUX mode */
        OUTPW(EXT_GE_CONFIG,(WORD)config);
        SetBlankAdj_m(1);       /* set BLANK_ADJUST=1, PIXEL_DELAY=0    */
        OUTPW (CLOCK_SEL,reg);
        }
    return;

}   /* InitTIMux_m() */



/*
 * BYTE GetClkSrc_m(rom_address);
 *
 * ULONG *rom_address;  Virtual address of start of ROM BIOS
 *
 * Get INPUT_CLOCK_SEL value for TI DACs
 *
 * Returns:
 *  Input clock source
 */
BYTE GetClkSrc_m(ULONG *rom_address)
{
    WORD *rom;
    BYTE *crom;
    BYTE clock_sel=0;
    int	i;

        rom= (PUSHORT)*rom_address++;
        if (rom && VideoPortReadRegisterUshort ((PUSHORT)rom)==VIDEO_ROM_ID)
            {
            crom=(BYTE *)rom;
    	    clock_sel=VideoPortReadRegisterUchar (&crom[0x47]);
    	    i=NUM_ROM_BASE_RANGES;
            }
        if (clock_sel==0)
        clock_sel=1;

    return(clock_sel);

}   /* GetClkSrc_m() */



/*
 * void SetBlankAdj_m(adjust);
 *
 * BYTE adjust;     Desired blank adjust (bits 0-1)
 *                  and pixel delay (bits 2-3) values
 *
 * Sets the blank adjust and pixel delay values.
 */
void SetBlankAdj_m(BYTE adjust)
{
    WORD misc;

    misc = INPW(R_MISC_CNTL) & 0xF0FF | (adjust << 8);
    OUTPW (MISC_CNTL,misc);
    return;

}   /* SetBlankAdj_m() */



/*
 * void InitTi_8_m(ext_ge_config);
 *
 * WORD ext_ge_config;  Desired EXT_GE_CONFIG value (should be 0x1a)
 *
 * Initialize DAC for standard 8 bit per pixel mode.
 */
void InitTi_8_m(WORD ext_ge_config)
{
struct query_structure *QueryPtr;   /* Query information for the card */
WORD ClockSelect;                   /* Value from CLOCK_SEL register */
struct st_mode_table *CrtTable;     /* Pointer to current mode table */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension,
     * and another pointer to the current mode table. The CardInfo[] field
     * is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);
    CrtTable = (struct st_mode_table *)QueryPtr;
    ((struct query_structure *)CrtTable)++;
    CrtTable += phwDeviceExtension->ModeIndex;

    switch(QueryPtr->q_DAC_type)
        {
        case DAC_ATT491:    /* At 8 BPP, Brooktree 48x and AT&T 20C491 */
        case DAC_BT48x:     /* are set up the same way */
            OUTPW(EXT_GE_CONFIG,0x101a);        /* Set EXT_DAC_ADDR */
            OUTP (DAC_MASK,0);
        SetBlankAdj_m(0x0C);       /* set BLANK_ADJUST=0, PIXEL_DELAY=3    */
            break;

        case DAC_STG1700:
            /*
             * If we are running 1280x1024 noninterlaced, cut the
             * clock frequency in half, set the MUX bit in
             * ext_ge_config, and tell InitSTG1700_m() to use the
             * 8BPP double pixel mode.
             *
             * All 1280x1024 noninterlaced modes use a pixel clock
             * frequency of 110 MHz or higher, with the clock
             * frequency divided by 1.
             */
            ClockSelect = INPW(CLOCK_SEL);
            if ((QueryPtr->q_desire_x == 1280) &&
                ((CrtTable->m_clock_select & CLOCK_SEL_MUX) ||
                (CrtTable->ClockFreq >= 110000000)))
                {
                if (CrtTable->ClockFreq >= 110000000)
                    {
                    ClockSelect &= CLOCK_SEL_STRIP;
                    ClockSelect |= GetShiftedSelector((CrtTable->ClockFreq) / 2);
                    OUTPW(CLOCK_SEL, ClockSelect);
                    }
                ext_ge_config |= 0x0100;
                InitSTG1700_m(ext_ge_config, TRUE);
                }
            else
                {
                InitSTG1700_m(ext_ge_config, FALSE);
                }
            break;

        case DAC_STG1702:
        case DAC_STG1703:
            /*
             * If we are running 1280x1024 noninterlaced, cut the
             * clock frequency in half, set the MUX bit in
             * ext_ge_config, and tell InitSTG1702_m() to use the
             * 8BPP double pixel mode.
             *
             * All 1280x1024 noninterlaced modes use a pixel clock
             * frequency of 110 MHz or higher, with the clock
             * frequency divided by 1.
             */
            ClockSelect = INPW(CLOCK_SEL);
            if ((QueryPtr->q_desire_x == 1280) &&
                ((CrtTable->m_clock_select & CLOCK_SEL_MUX) ||
                (CrtTable->ClockFreq >= 110000000)))
                {
                if (CrtTable->ClockFreq >= 110000000)
                    {
                    ClockSelect &= CLOCK_SEL_STRIP;
                    ClockSelect |= GetShiftedSelector((CrtTable->ClockFreq) / 2);
                    OUTPW(CLOCK_SEL, ClockSelect);
                    }
                ext_ge_config |= 0x0100;
                InitSTG1702_m(ext_ge_config, TRUE);
                }
            else
                {
                InitSTG1702_m(ext_ge_config, FALSE);
                }
            break;

        case DAC_ATT498:
            /*
             * If we are running 1280x1024 noninterlaced, cut the
             * clock frequency in half, set the MUX bit in
             * ext_ge_config, and tell InitATT498_m() to use the
             * 8BPP double pixel mode.
             *
             * All 1280x1024 noninterlaced modes use a pixel clock
             * frequency of 110 MHz or higher, with the clock
             * frequency divided by 1.
             */
            ClockSelect = INPW(CLOCK_SEL);
            if ((QueryPtr->q_desire_x == 1280) &&
                ((CrtTable->m_clock_select & CLOCK_SEL_MUX) ||
                (CrtTable->ClockFreq >= 110000000)))
                {
                if (CrtTable->ClockFreq >= 110000000)
                    {
                    ClockSelect &= CLOCK_SEL_STRIP;
                    ClockSelect |= GetShiftedSelector((CrtTable->ClockFreq) / 2);
                    OUTPW(CLOCK_SEL, ClockSelect);
                    }
                ext_ge_config |= 0x0100;
                InitATT498_m(ext_ge_config, TRUE);
                }
            else
                {
                InitATT498_m(ext_ge_config, FALSE);
                }
            break;

        case DAC_SC15021:
            /*
             * If we are running 1280x1024 noninterlaced, cut the
             * clock frequency in half, set the MUX bit in
             * ext_ge_config, and tell InitSC15021_m() to use the
             * 8BPP double pixel mode.
             *
             * All 1280x1024 noninterlaced modes use a pixel clock
             * frequency of 110 MHz or higher, with the clock
             * frequency divided by 1.
             */
            ClockSelect = INPW(CLOCK_SEL);
            if ((QueryPtr->q_desire_x == 1280) &&
                ((CrtTable->m_clock_select & CLOCK_SEL_MUX) ||
                (CrtTable->ClockFreq >= 110000000)))
                {
                /*
                 * NOTE: The only SC15021 card available for testing
                 *       (93/12/07) is a DRAM card. Since 1280x1024
                 *       noninterlaced is only available on VRAM cards,
                 *       it has not been tested.
                 */
                if (CrtTable->ClockFreq >= 110000000)
                    {
                    ClockSelect &= CLOCK_SEL_STRIP;
                    ClockSelect |= GetShiftedSelector((CrtTable->ClockFreq) / 2);
                    OUTPW(CLOCK_SEL, ClockSelect);
                    }
                ext_ge_config |= 0x0100;
                InitSC15021_m(ext_ge_config, TRUE);
                }
            else
                {
                InitSC15021_m(ext_ge_config, FALSE);
                }
            break;

        case DAC_SC15026:
            InitSC15026_m(ext_ge_config);
            break;

        case DAC_TI34075:
            /*
             * Handle 1280x1024 through the MUX.
             */
            if (QueryPtr->q_desire_x == 1280)
                {
	            InitTIMux_m(0x11a, (ULONG_PTR) &(phwDeviceExtension->RomBaseRange));
                return;
                }
            else
                {
                OUTPW(EXT_GE_CONFIG,0x201a);    /* Set EXT_DAC_ADDR field */
                DEC_DELAY
                OUTP (DAC_DATA,0);              /* Input clock source is CLK0 */
                DEC_DELAY
                OUTP (DAC_MASK,0);              /* Output clock is SCLK/1 and VCLK/1 */
                DEC_DELAY
                OUTP (DAC_R_INDEX,0x2d);        /* set MUX control to 8/8 */
                DEC_DELAY
                SetBlankAdj_m(0xc);             /* set pixel delay to 3 */
                DEC_DELAY
                OUTPW(HORZ_OVERSCAN,1);         /* set horizontal skew */
                DEC_DELAY
                break;
                }

        case DAC_ATI_68860:
            Init68860_m(ext_ge_config);
            break;
        }

    //
    // reset EXT_DAC_ADDR, put DAC in 6 bit mode
    //
    OUTPW(EXT_GE_CONFIG,ext_ge_config);
    DEC_DELAY
    OUTP (DAC_MASK,0xff);           /* enable DAC_MASK */
    DEC_DELAY
    return;

}   /* InitTi_8_m() */



/*
 * void InitTi_16_m(ext_ge_config, rom_address);
 *
 * WORD ext_ge_config;  Desired EXT_GE_CONFIG value (should be 0x2a, 0x6a, 0xaa, or 0xea)
 * ULONG_PTR rom_address; Virtual address of start of ROM BIOS
 *
 * Initialize DAC for 16 bit per pixel mode.
 */
void InitTi_16_m(WORD ext_ge_config, ULONG_PTR rom_address)
{
    WORD    ReadExtGeConfig;
    BYTE dummy;
    struct query_structure *QueryPtr;   /* Query information for the card */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    switch(QueryPtr->q_DAC_type)
        {
        case DAC_TI34075:
            /* TLC34075 initialization */
            /* disable overlay feature */

            OUTP (DAC_MASK,0);
            DEC_DELAY

            /* set BLANK_ADJUST=1, PIXEL_DELAY=0 */
            SetBlankAdj_m(1);

            /* Set EXT_DAC_ADDR field */
            OUTPW(EXT_GE_CONFIG,0x201a);
            DEC_DELAY

            /* get INPut clock source */
            OUTP (DAC_DATA, GetClkSrc_m((ULONG *) rom_address));
            DEC_DELAY

            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the EXT_GE_CONFIG
             * value won't be interpreted properly.
             *
             * If this is done at the beginning of the
             * IOCTL_VIDEO_SET_CURRENT_MODE packet, rather than
             * just before setting EXT_GE_CONFIG for each DAC type,
             * it has no effect.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));

            /* OUTPut clock source is SCLK/1 and VCLK/1 */
            /*   -- for modes which require PCLK/2, set VCLK/2 */

            if ( INPW(CLOCK_SEL) & 0xc0 )
                {
                DEC_DELAY
                OUTPW (CLOCK_SEL, (WORD)(INPW(CLOCK_SEL) & 0xff3f));
                DEC_DELAY

                if ( (INPW(R_H_DISP) & 0x00FF) == 0x4f )    // H_DISP = 640?
                    {
                    /* exception case: 640x480 60 Hz needs longer blank adjust (2) */
                    DEC_DELAY
                    SetBlankAdj_m(2);
                    }

                OUTP (DAC_MASK,8);
                DEC_DELAY
                }
            else{
                DEC_DELAY
                OUTP (DAC_MASK,0);
                DEC_DELAY
                }
            OUTP (DAC_R_INDEX,0xd);     /* set MUX control to 24/32 */
            DEC_DELAY

            /* reset EXT_DAC_ADDR, put DAC in 8 bit mode, engine in 555 mode */
            OUTPW (EXT_GE_CONFIG, (WORD)(ext_ge_config | 0x4000));
            DEC_DELAY
            break;

        case DAC_BT48x:                   /* Brooktree Bt481 initialization */
            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the clock select
             * value won't be interpreted properly.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));
            ReadExtGeConfig = INPW(R_EXT_GE_CONFIG) & 0x000f;
            ReadExtGeConfig |= (ext_ge_config & 0x0ff0);
            OUTPW(EXT_GE_CONFIG, (WORD)(ReadExtGeConfig | 0x1000));

            /*
             * See Bt481/Bt482 Product Description p.5 top of col. 2
             */
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);

            /*
             * Determine 555 or 565
             */
            if (ext_ge_config & 0x0c0)
                OUTP(DAC_MASK, 0x0e0);  /* 565 */
            else
                OUTP(DAC_MASK, 0x0a0);  /* 555 */

            OUTPW(EXT_GE_CONFIG, ReadExtGeConfig);

            SetBlankAdj_m(0x0C);       /* set BLANK_ADJUST=0, PIXEL_DELAY=3    */

            break;

        /*
         * ATT20C491 initialization. At 16BPP, this DAC is subtly
         * different from the Brooktree 48x.
         */
        case DAC_ATT491:
            OUTP (DAC_MASK,0);
            SetBlankAdj_m(0x0C);        /* BLANK_ADJUST=0, PIXEL_DELAY=3 */
            OUTPW(EXT_GE_CONFIG,0x101a);        /* set EXT_DAC_ADDR */

            /*
             * Windows NT miniport currently only supports 565 in 16BPP.
             * The test for the mode may need to be changed once all
             * orderings are supported.
             */
            if (ext_ge_config &0x0c0)
                OUTP (DAC_MASK,0xc0);       // 565, 8 bit
            else
                OUTP (DAC_MASK,0xa0);       // 555, 8 bit   UNTESTED MODE

            OUTPW(EXT_GE_CONFIG,ext_ge_config);
            break;

        case DAC_STG1700:
            InitSTG1700_m(ext_ge_config, FALSE);
            break;

        case DAC_STG1702:
        case DAC_STG1703:
            InitSTG1702_m(ext_ge_config, FALSE);
            break;

        case DAC_ATT498:
            InitATT498_m(ext_ge_config, FALSE);
            break;

        case DAC_SC15021:
            InitSC15021_m(ext_ge_config, FALSE);
            break;

        case DAC_SC15026:
            InitSC15026_m(ext_ge_config);
            break;

        case DAC_ATI_68860:
            SetBlankAdj_m(0x0C);        /* BLANK_ADJUST=0, PIXEL_DELAY=3 */
            Init68860_m(ext_ge_config);
            OUTPW(EXT_GE_CONFIG,ext_ge_config);
            break;

        default:
            OUTPW(EXT_GE_CONFIG,ext_ge_config);

            /* set pixel delay (3) for non-TI_DACs */
            SetBlankAdj_m(0xc);
            break;
        }
    return;

}   /* InitTi_16_m() */



/*
 * void InitTi_24_m(ext_ge_config, rom_address);
 *
 * WORD ext_ge_config;  Desired EXT_GE_CONFIG value (should be 0x3a | 24_BIT_OPTIONS)
 * ULONG_PTR rom_address; Virtual address of start of ROM BIOS
 *
 * Initialize DAC for 24 bit per pixel mode, 3 bytes, RGB.
 */
void InitTi_24_m(WORD ext_ge_config, ULONG_PTR rom_address)
{
    WORD clock_sel;
    BYTE dummy;
    WORD ReadExtGeConfig;
    struct query_structure *QueryPtr;   /* Query information for the card */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * Set 8-bit DAC operation.
     */
    ext_ge_config |= 0x4000;

    switch(QueryPtr->q_DAC_type)
        {
        case DAC_TI34075:               /* TLC34075 initialization */
            SetBlankAdj_m(1);           /* BLANK_ADJ=1, PIXEL_DELAY=0 */
            DEC_DELAY
            OUTPW(EXT_GE_CONFIG,0x201a);        /* Set EXT_DAC_ADDR field */
            DEC_DELAY
            OUTP (DAC_DATA, GetClkSrc_m((ULONG *) rom_address));
            DEC_DELAY

            /* OUTPut clock source is SCLK/1 and VCLK/1 */
            /*   -- for modes which require PCLK/2, set VCLK/2 */
            clock_sel= INPW(CLOCK_SEL);
            DEC_DELAY

            /*
             * If clock select is currently divided by 2, divide by 1.
             */
            if (clock_sel & 0xc0)
                {
                clock_sel &= 0xff3f;

                /*
                 * 640x480 60Hz needs longer blank adjust (2). Other
                 * refresh rates at 640x400 don't need this, but they
                 * use a divide-by-1 clock so they don't reach this point.
                 */
                if (INP(R_H_DISP) == 0x4f)
                    {
                    /* exception case: 640x480 60 Hz needs longer blank adjust (2) */
                    DEC_DELAY
                    SetBlankAdj_m(2);
                    }

                DEC_DELAY
                OUTP (DAC_MASK,8);
                DEC_DELAY
                }
            else{
                OUTP (DAC_MASK,0);
                DEC_DELAY
                }

            OUTP(DAC_R_INDEX,0xd); /* set MUX control to 24/32 */
            DEC_DELAY

            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the clock select
             * value won't be interpreted properly.
             *
             * If this is done at the beginning of the
             * IOCTL_VIDEO_SET_CURRENT_MODE packet, rather than
             * just before setting EXT_GE_CONFIG for each DAC type,
             * it has no effect.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));
            DEC_DELAY

            /* reset EXT_DAC_ADDR, put DAC in 8 bit mode, engine in 555 mode */
            OUTPW (EXT_GE_CONFIG, (WORD)(ext_ge_config | 0x4000));
            DEC_DELAY
            OUTPW(CLOCK_SEL,clock_sel);
            DEC_DELAY
            OUTP  (DAC_MASK,0);           /* disable overlay feature */
            DEC_DELAY
            break;


        case DAC_BT48x:            /* Brooktree Bt481 initialization */
            /*
             * This code is still experimental.
             */

            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the clock select
             * value won't be interpreted properly.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));

            ReadExtGeConfig = INPW(R_EXT_GE_CONFIG) & 0x000f;
            ReadExtGeConfig |= (ext_ge_config & 0x0ff0);
            OUTPW(EXT_GE_CONFIG, (WORD)(ReadExtGeConfig | 0x1000));

            /*
             * See Bt481/Bt482 Product Description p.5 top of col. 2
             */
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);
            dummy = INP(DAC_MASK);

            OUTP(DAC_MASK, 0x0f0);  /* 8:8:8 single-edge clock */

            OUTPW(EXT_GE_CONFIG, ReadExtGeConfig);

            SetBlankAdj_m(0x0C);       /* set BLANK_ADJUST=0, PIXEL_DELAY=3    */

            break;


        case DAC_ATT491:        /* ATT20C491 initialization */
            OUTP(DAC_MASK,0);

            SetBlankAdj_m(0x0C);       /* set BLANK_ADJUST=0, PIXEL_DELAY=3    */

            /* set EXT_DAC_ADDR field */
            OUTPW(EXT_GE_CONFIG,0x101a);

            /* set 24bpp bypass mode */
            OUTP(DAC_MASK,0xe2);

            /*
             * Re-write the I/O vs. memory mapped flag (bit 5 of
             * LOCAL_CONTROL set). If this is not done, and memory
             * mapped registers are being used, the clock select
             * value won't be interpreted properly.
             */
            OUTPW(LOCAL_CONTROL, INPW(LOCAL_CONTROL));

            OUTPW(EXT_GE_CONFIG,ext_ge_config);
            break;

        case DAC_STG1700:
            InitSTG1700_m(ext_ge_config, FALSE);
            break;

        case DAC_STG1702:
        case DAC_STG1703:
            InitSTG1702_m(ext_ge_config, FALSE);
            break;

        case DAC_ATT498:
            InitATT498_m(ext_ge_config, FALSE);
            break;

        case DAC_SC15021:
            InitSC15021_m(ext_ge_config, FALSE);
            break;

        case DAC_SC15026:
            InitSC15026_m(ext_ge_config);
            break;

        case DAC_ATI_68860:
            Init68860_m(ext_ge_config);
            /* Intentional fallthrough */

        default:
            OUTPW(EXT_GE_CONFIG,ext_ge_config);
            break;
        }
    return;

}   /* InitTi_24_m() */



/*
 * void Init68860_m(ext_ge_config);
 *
 * WORD ext_ge_config;  Value to be written to EXT_GE_CONFIG register
 *
 * Initialize the ATI 68860 DAC.
 */
void Init68860_m(WORD ext_ge_config)
{
    struct query_structure *QueryPtr;   /* Query information for the card */
    unsigned char GMRValue;             /* Value to put into Graphics Mode Register */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    OUTPW(EXT_GE_CONFIG, (WORD)(ext_ge_config | 0x3000));   /* 6 bit DAC, DAC_EXT_ADDR = 3 */

    /*
     * Initialize Device Setup Register A. Select 6-bit DAC operation,
     * normal power mode, PIXA bus width=64, disable overscan, and
     * no delay PIXA latching. Enable both SOB0 and SOB1 on cards
     * with more than 512k, 512k cards enable only SOB0.
     */
    if (QueryPtr->q_memory_size == VRAM_512k)
        OUTP(DAC_W_INDEX, 0x2D);
    else
        OUTP(DAC_W_INDEX, 0x6D);

    OUTPW(EXT_GE_CONFIG, (WORD)(ext_ge_config | 0x2000));   /* 6 bit DAC, DAC_EXT_ADDR = 2 */

    /*
     * Initialize Clock Selection Register. Select activate SCLK, enable
     * SCLK output, CLK1 as dot clock, VCLK=CLK1/4, no delay PIXB latch.
     */
    OUTP(DAC_MASK, 0x1D);

    /*
     * Initialize Display Control Register. Enable CMPA output, enable POSW,
     * 0 IRE blanking pedestal, disabe sync onto Red, Green, and Blue DACs.
     */
    OUTP(DAC_W_INDEX, 0x02);

    /*
     * Get the Graphics Mode Register value corresponding to the desired
     * colour depth and RGB ordering, then write it.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case 0x0000:    /* 4 BPP */
            GMRValue = 0x01;
            break;

        case 0x0020:    /* 16 BPP 555 */
            GMRValue = 0x20;
            break;

        case 0x0060:    /* 16 BPP 565 */
            GMRValue = 0x21;
            break;

        case 0x00A0:    /* 16 BPP 655 */
            GMRValue = 0x22;
            break;

        case 0x00E0:    /* 16 BPP 664 */
            GMRValue = 0x23;
            break;

        case 0x0030:    /* 24 BPP RBG */
            GMRValue = 0x40;
            break;

        case 0x0430:    /* 24 BPP BGR */
            GMRValue = 0x41;
            break;

        case 0x0230:    /* 32 BPP RBGa */
            GMRValue = 0x60;
            break;

        case 0x0630:    /* 32 BPP aBGR */
            GMRValue = 0x61;
            break;

        default:        /* 8 BPP */
            GMRValue = 0x03;
            break;
        }
    OUTP(DAC_R_INDEX, GMRValue);

    return;

}   /* end Init68860_m() */



/***************************************************************************
 *
 * void InitSTG1700_m(ext_ge_config, DoublePixel);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 * BOOL DoublePixel;        Whether or not to use 8BPP double pixel mode
 *
 * DESCRIPTION:
 *  Initializes the STG1700 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitSTG1700_m(WORD ext_ge_config, BOOL DoublePixel)
{
    unsigned char PixModeSelect;    /* Value to write to DAC Pixel Mode Select registers */
    unsigned char Dummy;            /* Scratch variable */


    /*
     * Get the value to be written to the DAC's Pixel Mode Select registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            PixModeSelect = 0x02;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            PixModeSelect = 0x03;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            PixModeSelect = 0x04;
            break;

        default:    /* 4 and 8 BPP */
            if (DoublePixel == TRUE)
                PixModeSelect = 0x05;
            else
                PixModeSelect = 0x00;
            break;
        }

    /*
     * Enable extended register/pixel mode.
     */
    ReadDac4();
    OUTP(DAC_MASK, 0x18);

    /*
     * Skip over the Pixel Command register, then write to indexed
     * registers 3 and 4 (Primrary and Secondary Pixel Mode Select
     * registers). Registers auto-increment when written.
     */
    ReadDac4();
    Dummy = INP(DAC_MASK);
    OUTP(DAC_MASK, 0x03);               /* Index low */
    OUTP(DAC_MASK, 0x00);               /* Index high */
    OUTP(DAC_MASK, PixModeSelect);      /* Primrary pixel mode select */
    OUTP(DAC_MASK, PixModeSelect);      /* Secondary pixel mode select */

    /*
     * In 8BPP double pixel mode, we must also set the PLL control
     * register. Since this mode is only used for 1280x1024 noninterlaced,
     * which always has a pixel clock frequency greater than 64 MHz,
     * the setting for this register is a constant.
     */
    if (DoublePixel == TRUE)
        OUTP(DAC_MASK, 0x02);       /* Input is 32 to 67.5 MHz, output 64 to 135 MHz */

    OUTPW(EXT_GE_CONFIG, ext_ge_config);
    Dummy = INP(DAC_W_INDEX);               /* Clear counter */

    return;

}   /* end InitSTG1700_m() */



/***************************************************************************
 *
 * void InitSTG1702_m(ext_ge_config, DoublePixel);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 * BOOL DoublePixel;        Whether or not to use 8BPP double pixel mode
 *
 * DESCRIPTION:
 *  Initializes the STG1702/1703 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitSTG1702_m(WORD ext_ge_config, BOOL DoublePixel)
{
    unsigned char PixModeSelect;    /* Value to write to DAC Pixel Mode Select registers */
    unsigned char Dummy;            /* Scratch variable */


    /*
     * Get the value to be written to the DAC's Pixel Mode Select registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            PixModeSelect = 0x02;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            PixModeSelect = 0x03;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            /*
             * Use double 24BPP direct colour. In this mode,
             * two pixels are passed as
             * RRRRRRRRGGGGGGGG BBBBBBBBrrrrrrrr ggggggggbbbbbbbb
             * rather than
             * RRRRRRRRGGGGGGGG BBBBBBBBxxxxxxxx rrrrrrrrgggggggg bbbbbbbbxxxxxxxx
             */
            PixModeSelect = 0x09;
            break;

        default:    /* 4 and 8 BPP */
            if (DoublePixel == TRUE)
                PixModeSelect = 0x05;
            else
                PixModeSelect = 0x00;
            break;
        }

    /*
     * Enable extended register/pixel mode.
     */
    ReadDac4();
    OUTP(DAC_MASK, 0x18);

    /*
     * Skip over the Pixel Command register, then write to indexed
     * registers 3 and 4 (Primrary and Secondary Pixel Mode Select
     * registers). Registers auto-increment when written.
     */
    ReadDac4();
    Dummy = INP(DAC_MASK);
    OUTP(DAC_MASK, 0x03);               /* Index low */
    OUTP(DAC_MASK, 0x00);               /* Index high */
    OUTP(DAC_MASK, PixModeSelect);      /* Primrary pixel mode select */
    OUTP(DAC_MASK, PixModeSelect);      /* Secondary pixel mode select */

    /*
     * In 8BPP double pixel mode, we must also set the PLL control
     * register. Since this mode is only used for 1280x1024 noninterlaced,
     * which always has a pixel clock frequency greater than 64 MHz,
     * the setting for this register is a constant.
     */
    if (DoublePixel == TRUE)
        OUTP(DAC_MASK, 0x02);       /* Input is 32 to 67.5 MHz, output 64 to 135 MHz */

    OUTPW(EXT_GE_CONFIG, ext_ge_config);
    Dummy = INP(DAC_W_INDEX);               /* Clear counter */

    return;

}   /* end InitSTG1702_m() */



/***************************************************************************
 *
 * void InitATT498_m(ext_ge_config, DoublePixel);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 * BOOL DoublePixel;        Whether or not to use 8BPP double pixel mode
 *
 * DESCRIPTION:
 *  Initializes the AT&T 498 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitATT498_m(WORD ext_ge_config, BOOL DoublePixel)
{
    unsigned char PixModeSelect;    /* Value to write to DAC Pixel Mode Select registers */
    unsigned char Dummy;            /* Scratch variable */


    /*
     * Get the value to be written to the DAC's Pixel Mode Select registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            PixModeSelect = 0x17;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            PixModeSelect = 0x37;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            PixModeSelect = 0x57;
            break;

        default:    /* 4 and 8 BPP */
            if (DoublePixel == TRUE)
                PixModeSelect = 0x25;
            else
                PixModeSelect = 0x05;
            break;
        }

    /*
     * Get to the "hidden" Control Register 0, then fill it with
     * the appropriate pixel mode select value.
     */
    ReadDac4();
    OUTP(DAC_MASK, PixModeSelect);

    OUTPW(EXT_GE_CONFIG, ext_ge_config);
    Dummy = INP(DAC_W_INDEX);               /* Clear counter */

    return;

}   /* end InitATT498_m() */



/***************************************************************************
 *
 * void InitSC15021_m(ext_ge_config, DoublePixel);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 * BOOL DoublePixel;        Whether or not to use 8BPP double pixel mode
 *
 * DESCRIPTION:
 *  Initializes the Sierra 15021 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitSC15021_m(WORD ext_ge_config, BOOL DoublePixel)
{
    unsigned char Repack;           /* Value to write to Repack register */
    unsigned char ColourMode;       /* Colour mode to write to Command register */


    /*
     * Get the values to be written to the DAC's Repack (external to
     * internal data translation) and Command registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            Repack = 0x08;
            ColourMode = 0x80;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            Repack = 0x08;
            ColourMode = 0xC0;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            Repack = 0x05;
            ColourMode = 0x40;
            break;

        default:    /* 4 and 8 BPP */
            if (DoublePixel == TRUE)
                Repack = 0x04;
            else
                Repack = 0x00;
            ColourMode = 0x00;
            break;
        }

    OUTPW(EXT_GE_CONFIG, ext_ge_config);

    /*
     * Get to the "hidden" Command register and set Extended
     * Register Programming Flag.
     */
    ReadDac4();
    OUTP(DAC_MASK, 0x10);

    /*
     * Write to the Extended Index register so the Extended Data
     * register points to the Repack register.
     */
    OUTP(DAC_R_INDEX, 0x10);

    /*
     * Write out the values for the Repack and Command registers.
     * Clearing bit 4 of the Command register (all our ColourMode
     * values have this bit clear) will clear the Extended Register
     * Programming flag.
     */
    OUTP(DAC_W_INDEX, Repack);
    OUTP(DAC_MASK, ColourMode);

    OUTPW(EXT_GE_CONFIG, ext_ge_config);

    return;

}   /* end InitSC15021_m() */



/***************************************************************************
 *
 * void InitSC15026_m(ext_ge_config);
 *
 * WORD ext_ge_config;      Value to be written to EXT_GE_CONFIG register
 *
 * DESCRIPTION:
 *  Initializes the Sierra 15026 DAC to the desired colour depth.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  InitTi_<depth>_m(), UninitTiDac_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void InitSC15026_m(WORD ext_ge_config)
{
    unsigned char ColourMode;       /* Colour mode to write to Command register */


    /*
     * Get the values to be written to the DAC's Repack (external to
     * internal data translation) and Command registers.
     */
    switch (ext_ge_config & 0x06F0)
        {
        case (PIX_WIDTH_16BPP | ORDER_16BPP_555):
            ColourMode = 0xA0;
            break;

        case (PIX_WIDTH_16BPP | ORDER_16BPP_565):
            ColourMode = 0xE0;
            break;

        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGB):
        case (PIX_WIDTH_24BPP | ORDER_24BPP_RGBx):
            ColourMode = 0x60;
            break;

        default:    /* 4 and 8 BPP */
            ColourMode = 0x00;
            break;
        }

    OUTPW(EXT_GE_CONFIG, ext_ge_config);

    /*
     * Get to the "hidden" Command register and set Extended
     * Register Programming Flag.
     */
    ReadDac4();
    OUTP(DAC_MASK, 0x10);

    /*
     * Write to the Extended Index register so the Extended Data
     * register points to the Repack register.
     */
    OUTP(DAC_R_INDEX, 0x10);

    /*
     * Write out the values for the Repack and Command registers.
     * Clearing bit 4 of the Command register (all our ColourMode
     * values have this bit clear) will clear the Extended Register
     * Programming flag. All of our supported pixel depths use
     * a Repack value of zero.
     */
    OUTP(DAC_W_INDEX, 0);
    OUTP(DAC_MASK, ColourMode);

    OUTPW(EXT_GE_CONFIG, ext_ge_config);

    return;

}   /* end InitSC15026_m() */



/***************************************************************************
 *
 * void ReadDac4(void);
 *
 * DESCRIPTION:
 *  Gain access to the extended registers on STG1700 and similar DACs.
 *  These registers are hidden behind the pixel mask register. To access
 *  them, read the DAC_W_INDEX register once, then the DAC_MASK register
 *  four times. The next access to the DAC_MASK register will then be
 *  to the Pixel Command register. If access to another extended register
 *  is desired, each additional read from DAC_MASK will skip to the
 *  next extended register.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Init<DAC type>_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void ReadDac4(void)
{
    UCHAR Dummy;        /* Scratch variable */

    Dummy = INP(DAC_W_INDEX);
    Dummy = INP(DAC_MASK);
    Dummy = INP(DAC_MASK);
    Dummy = INP(DAC_MASK);
    Dummy = INP(DAC_MASK);
    return;

}   /* end ReadDac4() */



/*
 * void UninitTiDac_m(void);
 *
 * Prepare DAC for 8514/A compatible mode on
 * 8514/A-compatible ATI accelerators.
 */
void UninitTiDac_m (void)
{
    struct query_structure *QueryPtr;   /* Query information for the card */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    Passth8514_m(SHOW_ACCEL);    // can only program DAC in 8514 mode

    switch (QueryPtr->q_DAC_type)
        {
        case DAC_TI34075:
            OUTPW (EXT_GE_CONFIG,0x201a);       /* set EXT_DAC_ADDR field */
            DEC_DELAY
            OUTP (DAC_DATA,0);      /* Input clock source is CLK0 */
            DEC_DELAY
            OUTP (DAC_MASK,0);      /* Output clock is SCLK/1 and VCLK/1 */
            DEC_DELAY
            OUTP (DAC_R_INDEX,0x2d);       /* set MUX CONTROL TO 8/16 */
            DEC_DELAY

            /* set default 8bpp pixel delay and blank adjust */
            OUTPW (LOCAL_CONTROL,(WORD)(INPW(LOCAL_CONTROL) | 8));  // TI_DAC_BLANK_ADJUST is always on
            DEC_DELAY
            SetBlankAdj_m(0xc);
            DEC_DELAY
            OUTPW(HORZ_OVERSCAN,1);             /* set horizontal skew */
            DEC_DELAY
            break;

        case DAC_STG1700:
            InitSTG1700_m(PIX_WIDTH_8BPP | 0x000A, FALSE);
            break;

        case DAC_STG1702:
        case DAC_STG1703:
            InitSTG1702_m(PIX_WIDTH_8BPP | 0x000A, FALSE);
            break;

        case DAC_ATT498:
            InitATT498_m(PIX_WIDTH_8BPP | 0x000A, FALSE);
            break;

        case DAC_SC15021:
            InitSC15021_m(PIX_WIDTH_8BPP | 0x000A, FALSE);
            break;

        case DAC_SC15026:
            InitSC15026_m(PIX_WIDTH_8BPP | 0x000A);
            break;

        case DAC_ATT491:
        case DAC_BT48x:
            OUTPW (EXT_GE_CONFIG,0x101a);
            OUTP  (DAC_MASK,0);
            /* Intentional fallthrough */

        default:
            SetBlankAdj_m(0);                       /* PIXEL_DELAY=0 */
            OUTPW(HORZ_OVERSCAN,0);                 /* set horizontal skew */
            break;
        }

// reset EXT_DAC_ADDR, put DAC in 6 bit mode, engine in 8 bit mode
    OUTPW(EXT_GE_CONFIG,0x1a);
    DEC_DELAY
    Passth8514_m(SHOW_VGA);
    return;

}   /* UninitTiDac_m() */

/***************************************************************************
 *
 * void SetPalette_m(lpPalette, StartIndex, Count);
 *
 * PPALETTEENTRY lpPalette;     Colour values to plug into palette
 * USHORT StartIndex;           First palette entry to set
 * USHORT Count;                Number of palette entries to set
 *
 * DESCRIPTION:
 *  Set the desired number of palette entries to the specified colours,
 *  starting at the specified index. Colour values are stored in
 *  doublewords, in the order (low byte to high byte) RGBx.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  SetCurrentMode_m() and IOCTL_VIDEO_SET_COLOR_REGISTERS packet
 *  of ATIMPStartIO()
 *
 * AUTHOR:
 *  unknown
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void SetPalette_m(PULONG lpPalette, USHORT StartIndex, USHORT Count)
{
int     i;
BYTE *pPal=(BYTE *)lpPalette;

        OUTP(DAC_W_INDEX,(BYTE)StartIndex);     // load DAC_W_INDEX with StartIndex

        for (i=0; i<Count; i++)         // this is number of colours to update
            {
            OUTP(DAC_DATA, *pPal++);    // red
            OUTP(DAC_DATA, *pPal++);    // green
            OUTP(DAC_DATA, *pPal++);    // blue
            pPal++;
            }

    return;

}   /* SetPalette_m() */



/**************************************************************************
 *
 * void SetTextMode_m(void);
 *
 * DESCRIPTION:
 *  Switch into 80x25 16 colour text mode using register writes rather
 *  than BIOS calls. This allows systems with no video BIOS (e.g. DEC
 *  ALPHA) to return to a text screen when shutting down and rebooting.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPStartIO(), packet IOCTL_VIDEO_RESET_DEVICE
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 **************************************************************************/

void SetTextMode_m(void)
{
    short LoopCount;        /* Loop counter */
    BYTE Scratch;           /* Temporary variable */
    BYTE Seq02;             /* Saved value of Sequencer register 2 */
    BYTE Seq04;             /* Saved value of Sequencer register 4 */
    BYTE Gra05;             /* Saved value of Graphics register 5 */
    BYTE Gra06;             /* Saved value of Graphics register 6 */
    WORD ExtGeConfig;       /* Saved contents of EXT_GE_CONFIG register */
    WORD MiscOptions;       /* Saved contents of MISC_OPTIONS register */
    WORD Column;            /* Current byte of font data being dealt with */
    WORD ScreenColumn;      /* Screen column corresponding to current byte of font data */
    WORD Row;               /* Current character being dealt with */

    /*
     * Let the VGA drive the screen. Mach 8 cards have separate VGA and
     * accelerator controllers, so no further action needs to be taken
     * once this is done. Mach 32 cards need to be put into VGA text mode.
     */
    Passth8514_m(SHOW_VGA);
    if (phwDeviceExtension->ModelNumber != MACH32_ULTRA)
        return;

    /*
     * Stop the sequencer to change memory timing
     * and memory organization
     */
    OUTPW(HI_SEQ_ADDR, 0x00 | (0x01 << 8));

    for (LoopCount = 1; LoopCount <= S_LEN; ++LoopCount)
        OUTPW(HI_SEQ_ADDR, (WORD)(LoopCount | (StdTextCRTC_m[S_PARM + LoopCount - 1] << 8)));

    /*
     * Program the extended VGAWonder registers
     */
    for (LoopCount = 0; ExtTextCRTC_m[LoopCount] != 0; LoopCount += 3)
        {
        OUTP(reg1CE, ExtTextCRTC_m[LoopCount]);
        Scratch = (INP(reg1CF) & ExtTextCRTC_m[LoopCount + 1]) | ExtTextCRTC_m[LoopCount + 2];
        OUTPW(reg1CE, (WORD)(ExtTextCRTC_m[LoopCount] | (Scratch << 8)));
        }

    LioOutp(regVGA_END_BREAK_PORT, StdTextCRTC_m[MIS_PARM], GENMO_OFFSET);

    /*
     * Restart the sequencer after the memory changes
     */
    OUTPW(HI_SEQ_ADDR, 0x00 | (0x03 << 8));

    /*
     * Program the CRTC controller
     */
    LioOutpw(regVGA_END_BREAK_PORT, 0x11 | (0x00 << 8), CRTX_COLOUR_OFFSET);

    for (LoopCount = 0; LoopCount < C_LEN; ++LoopCount)
        LioOutpw(regVGA_END_BREAK_PORT, (WORD)(LoopCount | (StdTextCRTC_m[C_PARM + LoopCount] << 8)), CRTX_COLOUR_OFFSET);

    /*
     * Program the Attribute controller (internal palette)
     */
    Scratch = LioInp(regVGA_END_BREAK_PORT, GENS1_COLOUR_OFFSET);
    for (LoopCount = 0; LoopCount < A_LEN; LoopCount++)
        {
        OUTP(regVGA_END_BREAK_PORT, (BYTE)LoopCount);
        OUTP(regVGA_END_BREAK_PORT, StdTextCRTC_m[A_PARM + LoopCount]);
        }
    OUTP(regVGA_END_BREAK_PORT, 0x14);
    OUTP(regVGA_END_BREAK_PORT, 0x00);

    /*
     * Program the graphics controller
     */
    for (LoopCount = 0; LoopCount < G_LEN; ++LoopCount)
        OUTPW(reg3CE, (WORD)(LoopCount | (StdTextCRTC_m[G_PARM + LoopCount] << 8)));

    /*
     * Program the DAC (external palette)
     */
    for (LoopCount = 0; LoopCount < 0x10; ++LoopCount)
        {
        LioOutp(regVGA_END_BREAK_PORT, StdTextCRTC_m[A_PARM + LoopCount], DAC_W_INDEX_OFFSET);
        LioOutp(regVGA_END_BREAK_PORT, TextDAC_m[LoopCount * 3], DAC_DATA_OFFSET);
        LioOutp(regVGA_END_BREAK_PORT, TextDAC_m[LoopCount * 3 + 1], DAC_DATA_OFFSET);
        LioOutp(regVGA_END_BREAK_PORT, TextDAC_m[LoopCount * 3 + 2], DAC_DATA_OFFSET);
        }

    /*
     * Turn on the display
     */
    Scratch = LioInp(regVGA_END_BREAK_PORT, GENS1_COLOUR_OFFSET);
    OUTP(regVGA_END_BREAK_PORT, 0x20);

    /*
     * No need to clear the screen.
     * First, the driver should not call Map Frame while the machine is
     * bug checking !!!
     * Second, it is not necessary to clear the screen since the HAL will
     * do it.
     */

    /*
     * Initialize the 8x16 font. Start by saving the registers which
     * are changed during font initialization.
     */
    OUTP(SEQ_IND, 0x02);
    Seq02 = INP(SEQ_DATA);
    OUTP(SEQ_IND, 4);
    Seq04 = INP(SEQ_DATA);
    OUTP(reg3CE, 5);
    Gra05 = INP_HBLW(reg3CE);
    OUTP(reg3CE, 6);
    Gra06 = INP_HBLW(reg3CE);

    /*
     * Set up to allow font loading
     */
    OUTPW(reg3CE, 0x0005);
    OUTPW(reg3CE, 0x0406);
    OUTPW(HI_SEQ_ADDR, 0x0402);
    OUTPW(HI_SEQ_ADDR, 0x0704);

    /*
     * Load our font data into video memory. This would normally be
     * done through the VGA aperture, but some machines (including
     * the DEC ALPHA) are unable to use the VGA aperture. Since
     * this routine is needed to re-initialize the VGA text screen
     * on non-80x86 machines (which can't use the BIOS), and some
     * of these are unable to use the VGA aperture, we need an
     * alternate method of loading the font data.
     *
     * The font data occupies byte 2 (zero-based) of each doubleword
     * for the first 8192 doublewords of video memory, in the pattern
     * 16 bytes of character data followed by 16 zero bytes. To load
     * the font data using the graphics engine, set it to 8BPP at a
     * screen pitch of 128 pixels (32 doublewords per line). In the
     * first 16 font data columns, use a host to screen blit to copy
     * the font data. For the last 16 font data columns (constant data
     * of zero), do a paint blit with colour zero. This will yield
     * one character of font data per line. Since we have already
     * switched to display via the VGA, this will not affect the
     * on-screen image.
     *
     * Note that this is only possible on a Mach 32 with the VGA enabled.
     */

    /*
     * Initialize the drawing engine to 8BPP with a pitch of 128. Don't
     * set up the CRT, since we are only trying to fill in the appropriate
     * bytes of video memory, and the results of our drawing are not
     * intended to be seen.
     */
    ExtGeConfig = INPW(R_EXT_GE_CONFIG);
    MiscOptions = INPW(MISC_OPTIONS);
    OUTPW(MISC_OPTIONS, (WORD)(MiscOptions | 0x0002));  /* 8 bit host data I/O */
    OUTPW(EXT_GE_CONFIG, (WORD)(PIX_WIDTH_8BPP | 0x000A));
    OUTPW(GE_PITCH, (128 >> 3));
    OUTPW(GE_OFFSET_HI, 0);
    OUTPW(GE_OFFSET_LO, 0);

    /*
     * We must now do our 32 rectangular blits, each 1 pixel wide by
     * 256 pixels high. These start at column 2 (zero-based), and are
     * done every 4 columns.
     */
    for(Column = 0; Column <= 31; Column++)
        {
        ScreenColumn = (Column * 4) + 2;
        /*
         * If this is one of the first 16 columns, we need to do a
         * host-to-screen blit.
         */
        if (Column <= 15)
            {
            WaitForIdle_m();
            OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_HOST | BG_COLOR_SRC_BG | EXT_MONO_SRC_ONE | DRAW | READ_WRITE));
            OUTPW(CUR_X, ScreenColumn);
            OUTPW(CUR_Y, 0);
            OUTPW(DEST_X_START, ScreenColumn);
            OUTPW(DEST_X_END, (WORD)(ScreenColumn + 1));
            OUTPW(DEST_Y_END, 256);

            /*
             * The nth column contains the nth byte of character bitmap
             * data for each of the 256 characters. There are 16 bytes
             * of bitmap data per character, so the nth byte of data for
             * character x (n and x both zero-based) is at offset
             * (x * 16) + n.
             */
            for (Row = 0; Row < 256; Row++)
                {
                OUTP_HBLW(PIX_TRANS, FontData_m[(Row * 16) + Column]);
                }
            }
        else
            {
            /*
             * This is one of the "padding" zero bytes which must be
             * added to each character in the font to bring it up
             * to 32 bytes of data per character.
             */
            WaitForIdle_m();
            OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | DRAW | READ_WRITE));
            OUTPW(ALU_FG_FN, MIX_FN_PAINT);
            OUTPW(FRGD_COLOR, 0);
            OUTPW(CUR_X, ScreenColumn);
            OUTPW(CUR_Y, 0);
            OUTPW(DEST_X_START, ScreenColumn);
            OUTPW(DEST_X_END, (WORD)(ScreenColumn + 1));
            OUTPW(DEST_Y_END, 256);
            }
        }

    /*
     * Restore the graphics engine registers we changed.
     */
    OUTPW(EXT_GE_CONFIG, ExtGeConfig);
    OUTPW(MISC_OPTIONS, MiscOptions);

    /*
     * Restore the registers we changed to load the font.
     */
    OUTPW(reg3CE, (WORD) ((Gra06 << 8) | 6));
    OUTPW(reg3CE, (WORD) ((Gra05 << 8) | 5));
    OUTPW(HI_SEQ_ADDR, (WORD) ((Seq04 << 8) | 4));
    OUTPW(HI_SEQ_ADDR, (WORD) ((Seq02 << 8) | 2));

    /*
     * Set up the engine and CRT pitches for 1024x768, to avoid screen
     * doubling when warm-booting from our driver to the 8514/A driver.
     * This is only necessary on the Mach 32 (Mach 8 never reaches this
     * point in the code) because on the Mach 8, writing to ADVFUNC_CNTL
     * (done as part of Passth8514_m()) sets both registers up for
     * 1024x768.
     */
    OUTPW(GE_PITCH, 128);
    OUTPW(CRT_PITCH, 128);

    return;

}   /* SetTextMode_m() */

/*****************************	 end  of  MODES_M.C  **********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\query_cx.c ===
/************************************************************************/
/*                                                                      */
/*                              QUERY_CX.C                              */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.                  */
/************************************************************************/

/**********************       PolyTron RCS Utilities

    $Revision:   1.61  $
    $Date:   01 May 1996 14:10:14  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/query_cx.c_v  $
 *
 *    Rev 1.61   01 May 1996 14:10:14   RWolff
 * Calls new routine DenseOnAlpha() to determine dense space support rather
 * than assuming all PCI cards support dense space, routine treats only
 * PCI cards with ?T ASICs as supporting dense space.
 *
 *    Rev 1.60   23 Apr 1996 17:21:18   RWolff
 * Split mapping of memory types reported by BIOS into our enumeration
 * of memory types according to ASIC type, since ?T and ?X use the same
 * memory type code to refer to different memory types.
 *
 *    Rev 1.59   15 Apr 1996 16:57:56   RWolff
 * Added routine to identify which flavour of the Mach 64 is in use.
 *
 *    Rev 1.58   12 Apr 1996 16:14:48   RWolff
 * Now rejects 24BPP modes if linear aperture is not present, since new
 * source stream display driver can't do 24BPP in a paged aperture. This
 * rejection should be done in the display driver (the card still supports
 * the mode, but the display driver doesn't want to handle it), but at
 * the point where the display driver must decide to either accept or reject
 * modes, it doesn't have access to the aperture information.
 *
 *    Rev 1.57   20 Mar 1996 13:45:02   RWolff
 * Fixed truncation of screen buffer save size.
 *
 *    Rev 1.56   01 Mar 1996 12:14:20   RWolff
 * Can now use the existing VGA graphics screen used as the startup
 * "blue screen" on the DEC Alpha to store the results of the BIOS
 * query call rather than forcing a mode switch and destroying the
 * contents of the "blue screen".
 *
 *    Rev 1.55   06 Feb 1996 16:01:00   RWolff
 * Updated start and end indices for 1600x1200 to take into account addition
 * of 66Hz and 76Hz, and deletion of 52Hz.
 *
 *    Rev 1.54   02 Feb 1996 17:17:38   RWolff
 * DDC/VDIF merge source information is now stored in hardware device
 * extension rather than static variables, switches back to a VGA text
 * screen after we have finished with the query information if we needed
 * to switch into a graphics screen in order to obtain a buffer below
 * 1M physical (more information needed from DEC in order to make this
 * work on the Alpha), moved redundant cleanup code to its own routine.
 *
 *    Rev 1.53   29 Jan 1996 17:00:48   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC, restricted
 * 4BPP to 1M cards, and only for resolutions where 8BPP won't fit.
 *
 *    Rev 1.52   23 Jan 1996 11:47:26   RWolff
 * Protected against false values of TARGET_BUILD.
 *
 *    Rev 1.51   11 Jan 1996 19:42:16   RWolff
 * Now restricts refresh rates for each resolution/pixel depth combination
 * using data from AX=A?07 BIOS call rather than special cases.
 *
 *    Rev 1.50   22 Dec 1995 14:54:02   RWolff
 * Added support for Mach 64 GT internal DAC.
 *
 *    Rev 1.49   21 Dec 1995 14:04:02   RWolff
 * Locked out modes that ran into trouble at high refresh rates.
 *
 *    Rev 1.48   19 Dec 1995 13:57:02   RWolff
 * Added support for refresh rates up to 100Hz at 640x480, 800x600, and
 * 1024x768, and 76Hz at 1280x1024.
 *
 *    Rev 1.47   29 Nov 1995 14:36:16   RWolff
 * Fix for EPR#08840. The mode that was causing problems (1152x864 32BPP
 * 80Hz on IBM DAC) was one that (according to the INSTALL program)
 * shouldn't be available on the card.
 *
 *    Rev 1.46   28 Nov 1995 18:14:58   RWolff
 * Added debug print statements.
 *
 *    Rev 1.45   21 Nov 1995 11:02:02   RWolff
 * Restricted maximum size of BIOS query structure to allow space below
 * 1M for reading DDC data.
 *
 *    Rev 1.44   27 Oct 1995 14:23:54   RWolff
 * No longer checks for block write on non-LFB configurations, moved
 * mapping and unmapping of LFB into the block write check routine
 * rather than using the (no longer exists) mapped LFB in the hardware
 * device extension.
 *
 *    Rev 1.43   08 Sep 1995 16:35:32   RWolff
 * Added support for AT&T 408 DAC (STG1703 equivalent).
 *
 *    Rev 1.42   24 Aug 1995 15:37:20   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 *
 *    Rev 1.41   28 Jul 1995 14:40:36   RWolff
 * Added support for the Mach 64 VT (CT equivalent with video overlay).
 *
 *    Rev 1.40   26 Jul 1995 12:44:54   mgrubac
 * Locked out modes that didn't work on 4M CX cards with STG1703
 * and similar DACs.
 *
 *    Rev 1.39   20 Jul 1995 17:57:54   mgrubac
 * Added support for VDIF files.
 *
 *    Rev 1.38   13 Jun 1995 15:13:14   RWOLFF
 * Now uses VideoPortReadRegisterUlong() instead of direct memory
 * reads in BlockWriteAvailable_cx(), since direct reads don't
 * work on the DEC Alpha. Breaks out of block write test on
 * finding first mismatch, rather than testing the whole block,
 * to save time. One mismatch is enough to indicate that block
 * write mode is not supported, so after we find one we don't
 * need to check the rest of the block.
 *
 *    Rev 1.37   02 Jun 1995 14:31:44   RWOLFF
 * Added debug print statements, locked out modes that don't work properly
 * on some DACs.
 *
 *    Rev 1.36   10 Apr 1995 15:58:20   RWOLFF
 * Now replaces BookValues[] entries where the Mach 64 needs different CRT
 * parameters from the Mach 8/Mach 32 (fixes Chrontel DAC 1M 640x480 72Hz
 * 24BPP noise problem), locked out 800x600 16BPP 72Hz on 1M cards with
 * STG170x and equivalent DACs (another noise problem, this mode is not
 * supposed to be supported on 1M cards).
 *
 *    Rev 1.35   31 Mar 1995 11:56:16   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.34   27 Mar 1995 16:12:14   RWOLFF
 * Locked out modes that didn't work on 1M cards with STG1702 and
 * similar DACs.
 *
 *    Rev 1.33   16 Mar 1995 14:41:08   ASHANMUG
 * Limit 1024x768 24 bpp on a STG17xx DAC to 87Hz interlaced
 *
 *    Rev 1.32   03 Mar 1995 10:51:22   ASHANMUG
 * Lock-out high refresh rates on CT and '75 DACs
 *
 *    Rev 1.31   24 Feb 1995 12:29:54   RWOLFF
 * Added routine to check if the card is susceptible to 24BPP text banding
 *
 *    Rev 1.30   20 Feb 1995 18:02:28   RWOLFF
 * Locked out block write on GX rev. E with IBM RAM.
 *
 *    Rev 1.29   14 Feb 1995 15:54:22   RWOLFF
 * Now checks CFG_CHIP_TYPE field of CONFIG_CHIP_ID against values found
 * in this field for all Mach 64 ASICs, and reports "no Mach 64" if
 * no match is found. This fixes a problem on an Apricot FT\\2E with
 * a Mach 32 MCA card, where the Mach 32 supplied the BIOS signature
 * string, and the machine cached our writes to SCRATCH_PAD0 so it
 * looked like the register was present, falsely identifying a Mach 64
 * as being present.
 *
 *    Rev 1.28   09 Feb 1995 14:58:14   RWOLFF
 * Fix for GX-E IBM DAC screen tearing in 800x600 8BPP.
 *
 *    Rev 1.27   07 Feb 1995 18:21:14   RWOLFF
 * Locked out some more resolution/pixel depth/refresh rate combinations
 * that are not supported.
 *
 *    Rev 1.26   30 Jan 1995 17:44:20   RWOLFF
 * Mach 64 detection now does a low word test before the doubleword test
 * to avoid hanging a VLB Mach 32 by writing garbage to the MEM_BNDRY register.
 *
 *    Rev 1.25   30 Jan 1995 11:56:12   RWOLFF
 * Now detects CT internal DAC.
 *
 *    Rev 1.24   19 Jan 1995 15:38:18   RWOLFF
 * Removed 24BPP no-BIOS lockout and comment explaining why it was
 * locked out. 24BPP now works on no-BIOS implementations.
 *
 *    Rev 1.23   18 Jan 1995 15:41:08   RWOLFF
 * Added support for Chrontel DAC, now clips maximum colour depth from BIOS
 * mode tables to the maximum identified in the query header, locks out
 * high refresh rate 1152x864 16BPP modes (8BPP can still be handled through
 * double-pixel mode), re-enabled 24BPP on no-BIOS implementations (work
 * in progress).
 *
 *    Rev 1.22   11 Jan 1995 14:00:28   RWOLFF
 * 1280x1024 no longer restricted to 60Hz maximum on DRAM cards. This
 * restriction was a carryover from the Mach 32, since at the time I wrote
 * this code, I did not have any information to show that the Mach 64 didn't
 * need it.
 *
 *    Rev 1.21   04 Jan 1995 13:20:10   RWOLFF
 * Now uses VGA graphics memory if neither text screen is backed by
 * physical memory (needed on some DEC Alpha machines), temporarily
 * locked out 24BPP on no-BIOS implementations.
 *
 *    Rev 1.20   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.19   18 Nov 1994 11:41:54   RWOLFF
 * Added support for Mach 64 without BIOS, separated handling of STG1703 from
 * other STG170x DACs, no longer creates mode tables for resolutions that the
 * DAC doesn't support, added handling for split rasters, rejects 4BPP on
 * TVP3026 DAC, recognizes that the Power PC doesn't support block write mode.
 *
 *    Rev 1.18   14 Sep 1994 15:21:30   RWOLFF
 * Now stores most desirable supported colour ordering for 24 and 32 BPP
 * in the query structure.
 *
 *    Rev 1.17   06 Sep 1994 10:47:32   ASHANMUG
 * Force 4bpp on mach64 to have one meg ram
 *
 *    Rev 1.16   31 Aug 1994 16:26:10   RWOLFF
 * Now uses VideoPort[Read|Write]Register[Uchar|Ushort|Ulong]() instead
 * of direct assignments when accessing structures stored in VGA text
 * screen off-screen memory, added support for TVP3026 DAC and new
 * list of DAC subtypes, updates maximum supported pixel depth to
 * correspond to the card being used rather than taking the normal
 * maximum values for the DAC type, added 1152x864 and 1600x1200 support.
 *
 *    Rev 1.15   19 Aug 1994 17:11:56   RWOLFF
 * Added support for SC15026 and AT&T 49[123] DACs, fixed reporting
 * of "canned" mode tables for resolutions that do not have a
 * hardware default refresh rate, added support for 1280x1024 70Hz and 74Hz.
 *
 *    Rev 1.14   30 Jun 1994 18:14:28   RWOLFF
 * Moved IsApertureConflict_cx() to SETUP_CX.C because the new method
 * of checking for conflict requires access to definitions and data
 * structures which are only available in this module.
 *
 *    Rev 1.13   15 Jun 1994 11:08:02   RWOLFF
 * Now lists block write as unavailable on DRAM cards.
 *
 *    Rev 1.12   17 May 1994 15:59:48   RWOLFF
 * No longer sets a higher pixel clock for "canned" mode tables on some
 * DACs. The BIOS will increase the pixel clock frequency for DACs that
 * require it.
 *
 *    Rev 1.11   12 May 1994 11:15:26   RWOLFF
 * No longer does 1600x1200, now lists predefined refresh rates as available
 * instead of only the refresh rate stored in EEPROM.
 *
 *    Rev 1.10   05 May 1994 13:41:00   RWOLFF
 * Now reports block write unavailable on Rev. C and earlier ASICs.
 *
 *    Rev 1.9   27 Apr 1994 14:02:26   RWOLFF
 * Fixed detection of "LFB disabled" case, no longer creates 4BPP mode tables
 * for 68860 DAC (this DAC doesn't do 4BPP), fixed query of DAC type (DAC
 * list in BIOS guide is wrong).
 *
 *    Rev 1.8   26 Apr 1994 12:49:16   RWOLFF
 * Fixed handling of 640x480 and 800x600 if LFB configured but not available.
 *
 *    Rev 1.7   31 Mar 1994 15:03:40   RWOLFF
 * Added 4BPP support, debugging code to see why some systems were failing.
 *
 *    Rev 1.6   15 Mar 1994 16:27:00   RWOLFF
 * Rounds 8M aperture down to 8M boundary, not 16M boundary.
 *
 *    Rev 1.5   14 Mar 1994 16:34:40   RWOLFF
 * Fixed handling of 8M linear aperture installed so it doesn't start on
 * an 8M boundary (retail version of install program shouldn't allow this
 * condition to exist), fix for tearing on 2M boundary.
 *
 *    Rev 1.4   09 Feb 1994 15:32:22   RWOLFF
 * Corrected name of variable for best colour depth found, closed
 * comment that had been left open in previous revision.
 *
 *    Rev 1.3   08 Feb 1994 19:02:34   RWOLFF
 * No longer makes 1024x768 87Hz interlaced available if Mach 64 card is
 * configured with 1024x768 set to "Not installed".
 *
 *    Rev 1.2   07 Feb 1994 14:12:00   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed, removed GetMemoryNeeded_cx() which was only called by
 * LookForSubstitute(), a routine removed from ATIMP.C.
 *
 *    Rev 1.1   03 Feb 1994 16:43:20   RWOLFF
 * Fixed "ceiling check" on right scissor registers (documentation
 * had maximum value wrong).
 *
 *    Rev 1.0   31 Jan 1994 11:12:08   RWOLFF
 * Initial revision.
 *
 *    Rev 1.2   14 Jan 1994 15:23:34   RWOLFF
 * Gives unambiguous value for ASIC revision, uses deepest mode table for
 * a given resolution rather than the first one it finds, added routine
 * to check if block write mode is available, support for 1600x1200.
 *
 *    Rev 1.1   30 Nov 1993 18:26:30   RWOLFF
 * Fixed hang bug in DetectMach64(), moved query buffer off visible screen,
 * changed QueryMach64() to correspond to latest BIOS specifications,
 * added routines to check for aperture conflict and to find the
 * amount of video memory needed by a given mode.
 *
 *    Rev 1.0   05 Nov 1993 13:36:28   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
QUERY_CX.C - Functions to detect the presence of and find out the
             configuration of 68800CX-compatible ATI accelerators.

#endif

#include "dderror.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"

#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#define INCLUDE_QUERY_CX
#define STRUCTS_QUERY_CX
#include "query_cx.h"
#include "services.h"
#include "setup_cx.h"
#include "cvtddc.h"



/*
 * Prototypes for static functions.
 */
static void CleanupQuery(PUCHAR CapBuffer, PUCHAR SupBuffer, PUCHAR MappedBuffer, long BufferSeg, PUCHAR SavedScreen);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_CX, DetectMach64)
#pragma alloc_text(PAGE_CX, QueryMach64)
#pragma alloc_text(PAGE_CX, BlockWriteAvail_cx)
#pragma alloc_text(PAGE_CX, TextBanding_cx)
#pragma alloc_text(PAGE_CX, CleanupQuery)
#endif



/***************************************************************************
 *
 * int DetectMach64(void);
 *
 * DESCRIPTION:
 *  Detect whether or not a Mach 64 accelerator is present.
 *
 * RETURN VALUE:
 *  MACH64_ULTRA if Mach 64 accelerator found
 *  NO_ATI_ACCEL if no Mach 64 accelerator found
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

int DetectMach64(void)
{
    int CardType = MACH64_ULTRA;    /* Initially assume Mach 64 is present */
    DWORD ScratchReg0;              /* Saved contents of SCRATCH_REG0 */
    WORD CfgChipType;               /* CFG_CHIP_TYPE field of CONFIG_CHIP_ID */

    /*
     * Some other brands of video card will pass the write/read back
     * test for the Mach 64. To avoid falsely identifying them as
     * Mach 64 cards, check for the ATI signature string in the BIOS.
     *
     * Failure cases use DEBUG_DETAIL rather than DEBUG_ERROR because
     * failed detection of the Mach 64 is a normal case for Mach 8 and
     * Mach 32 cards, and for non-ATI cards in "run all the miniports
     * and see which ones find their cards" video determination.
     */
    if (Get_BIOS_Seg() == FALSE)
        {
        VideoDebugPrint((DEBUG_DETAIL, "DetectMach64() no ATI BIOS signature found\n"));
        }

    /*
     * On a machine with a Mach 32 to provide an ATI video BIOS
     * segment, a card with a 32 bit read/write register matching
     * SCRATCH_REG0 would be falsely detected as a Mach 64. To
     * avoid this, check the CFG_CHIP_TYPE field of CONFIG_CHIP_ID
     * against values found in this field for known Mach 64 ASICs
     * as an additional test. Since this test is non-destructive,
     * do it first.
     */
    CfgChipType = INPW(CONFIG_CHIP_ID);
    if ((CfgChipType != CONFIG_CHIP_ID_TypeGX) &&   /* GX */
        (CfgChipType != CONFIG_CHIP_ID_TypeCX) &&   /* CX */
        (CfgChipType != 0x4354) &&  /* CT */
        (CfgChipType != 0x4554) &&  /* ET */
        (CfgChipType != 0x4754) &&  /* GT */
        (CfgChipType != 0x4C54) &&  /* LT */
        (CfgChipType != 0x4D54) &&  /* MT */
        (CfgChipType != 0x5254) &&  /* RT */
        (CfgChipType != 0x5654) &&  /* VT */
        (CfgChipType != 0x3354))    /* 3T */
        {
        VideoDebugPrint((DEBUG_DETAIL, "DetectMach64() - CFG_CHIP_TYPE = 0x%X doesn't match known Mach 64 ASIC\n", CfgChipType));
        return NO_ATI_ACCEL;
        }

    /*
     * Save the contents of SCRATCH_REG0, since they are destroyed in
     * the test for Mach 64 accelerators.
     */
    ScratchReg0 = INPD(SCRATCH_REG0);

    /*
     * On a Mach 64 card, any 32 bit pattern written to SCRATCH_REG0
     * will be read back as the same value. Since unimplemented registers
     * normally drift to either all set or all clear, test this register
     * with two patterns (second is the complement of the first) containing
     * alternating set and clear bits. If either of them is not read back
     * unchanged, then assume that no Mach 64 card is present.
     *
     * After writing, we must wait long enough for the contents of
     * SCRATCH_REG0 to settle down. We can't use a WaitForIdle_cx() call
     * because this function uses a register which only exists in
     * memory-mapped form, and we don't initialize the memory-mapped
     * registers until we know that we are dealing with a Mach 64 card.
     * Instead, assume that it will settle down in 1 millisecond.
     *
     * Test the low word of SCRATCH_REG0 before testing the whole
     * doubleword. This is because the high word of this register
     * corresponds to the MEM_BNDRY register on the Mach 32 (low
     * word not used). If we do a doubleword write on a Mach 32
     * card (Mach 64 detection is before Mach 32 detection), we
     * will plug garbage data into MEM_BNDRY, which will hang the machine.
     */
    OUTPW(SCRATCH_REG0,0x05555);
    delay(1);
    if (INPW(SCRATCH_REG0) != 0x05555)
        CardType = NO_ATI_ACCEL;

    OUTPW(SCRATCH_REG0, 0x0AAAA);
    delay(1);
    if (INPW(SCRATCH_REG0) != 0x0AAAA)
        CardType = NO_ATI_ACCEL;

    /*
     * Failure - restore the register and return.
     */
    if (CardType == NO_ATI_ACCEL)
        {
        OUTPW(SCRATCH_REG0, (WORD)(ScratchReg0 & 0x0000FFFF));
        VideoDebugPrint((DEBUG_DETAIL, "DetectMach64() - SCRATCH_REG0 word readback doesn't match value written\n"));
        return CardType;
        }

    /*
     * Success - test the register as a doubleword.
     */
    OUTPD(SCRATCH_REG0, 0x055555555);
    delay(1);
    if (INPD(SCRATCH_REG0) != 0x055555555)
        CardType = NO_ATI_ACCEL;

    OUTPD(SCRATCH_REG0, 0x0AAAAAAAA);
    delay(1);
    if (INPD(SCRATCH_REG0) != 0x0AAAAAAAA)
        CardType = NO_ATI_ACCEL;

    /*
     * Restore the contents of SCRATCH_REG0 and let the caller know
     * whether or not we found a Mach 64.
     */
    OUTPD(SCRATCH_REG0, ScratchReg0);

    return CardType;

}   /* DetectMach64() */



/***************************************************************************
 *
 * VP_STATUS QueryMach64(Query);
 *
 * struct query_structure *Query;   Query structure to fill in
 *
 * DESCRIPTION:
 *  Fill in the query structure and mode tables for the
 *  Mach 64 accelerator.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  ERROR_INSUFFICIENT_BUFFER if not enough space to collect data
 *  any error code returned by operating system calls.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryMach64(struct query_structure *Query)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    VP_STATUS RetVal;                   /* Status returned by VideoPortInt10() */
    short MaxModes;                     /* Maximum number of modes possible in query structure */
    short AbsMaxDepth;                  /* Maximum pixel depth supported by the DAC */
    struct cx_query *CxQuery;           /* Query header from BIOS call */
    struct cx_mode_table *CxModeTable;  /* Mode tables from BIOS call */
    struct st_mode_table ThisRes;       /* All-depth mode table for current resolution */
    short CurrentRes;                   /* Current resolution we are working on */
    long BufferSeg;                     /* Segment of buffer used for BIOS query */
    long BufferSize;                    /* Size of buffer needed for BIOS query */
    PUCHAR MappedBuffer;                /* Pointer to buffer used for BIOS query */
    short Count;                        /* Loop counter */
    DWORD Scratch;                      /* Temporary variable */
    long MemAvail;                      /* Memory available, in bytes */
    long NumPixels;                     /* Number of pixels for the current mode */
    struct st_mode_table *pmode;        /* Mode table to be filled in */
    short StartIndex;                   /* First mode for SetFixedModes() to set up */
    short EndIndex;                     /* Last mode for SetFixedModes() to set up */
    BOOL ModeInstalled;                 /* Is this resolution configured? */
    short FreeTables;                   /* Number of remaining free mode tables */
    short FormatType;                   /* Which table format is in use */
    UCHAR DacTypeMask;                  /* Bitmask for DAC type on the card */
    UCHAR OrigDacType;                  /* DAC type before processing into AMACH1.H ordering */
    UCHAR OrigRamType;                  /* RAM type before processing into AMACH1.H ordering */
    UCHAR OrigRamSize;                  /* Amount of RAM before processing into number of 256k banks */
    PUCHAR HwCapBuffer;                 /* Pointer to buffer of hardware capabilities */
    PUCHAR HwSupBuffer;                 /* Pointer to supplemental buffer */
    PUCHAR HwCapWalker;                 /* Pointer to walk through above buffer */
    struct cx_hw_cap *HwCapEntry;       /* Pointer to single entry in table of hardware capabilities */
    UCHAR HwCapBytesPerRow;             /* Number of bytes in each hardware capability entry */
    UCHAR MaxDotClock[HOW_MANY_DEPTHS]; /* Maximum dot clock at each pixel depth for the current resolution */
    UCHAR CurrentDepth;                 /* Pixel depth for current hardware capability entry */
    /*
     * Place to save the contents of the VGA screen before making a BIOS
     * query using the VGA memory as a buffer. Needed only when using
     * the existing graphics screen as a buffer, since we use an offscreen
     * portion of the text screen, and if we have to switch into a VGA
     * graphics mode there will be nothing to save.
     */
    UCHAR SavedVgaBuffer[VGA_TOTAL_SIZE];


    /*
     * If we do not yet know the BIOS prefix for this card (i.e.
     * it is a block relocatable card where we must match the
     * BIOS prefix to the I/O base in case we have multiple
     * cards.
     */
    if (phwDeviceExtension->BiosPrefix == BIOS_PREFIX_UNASSIGNED)
        {
        /*
         * We don't support block relocatable cards in the
         * no-BIOS configuration.
         */
        phwDeviceExtension->BiosPrefix = BIOS_PREFIX_VGA_ENAB;

        /*
         * We shouldn't need to check for equality, but this allows
         * us to catch the "too many cards - this one doesn't have
         * a BIOS prefix" case by checking for an out-of-range
         * prefix after the loop exits.
         */
        while (phwDeviceExtension->BiosPrefix <= BIOS_PREFIX_MAX_DISAB)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Testing BIOS prefix 0x%X\n", phwDeviceExtension->BiosPrefix));
            VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
            Registers.Eax = BIOS_QUERY_IOBASE;
            if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - failed BIOS_QUERY_IOBASE\n"));
                return RetVal;
                }
            /*
             * If the card with the current BIOS prefix uses our I/O base
             * address, we have found the correct prefix. Otherwise,
             * try the next prefix.
             */
            if (Registers.Edx == phwDeviceExtension->BaseIOAddress)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Card with I/O base address 0x%X uses BIOS prefix 0x%X\n", Registers.Edx, phwDeviceExtension->BiosPrefix));
                break;
                }
            else
                {
                VideoDebugPrint((DEBUG_DETAIL, "Reported I/O base of 0x%X - no match\n", Registers.Edx));
                }

            phwDeviceExtension->BiosPrefix += BIOS_PREFIX_INCREMENT;

            }   /* end while (searching for the correct prefix) */

        /*
         * The equality test on the loop will result in an illegal
         * prefix on exit if there are too many cards for us to
         * handle, and this is one of the "orphans".
         */
        if (phwDeviceExtension->BiosPrefix > BIOS_PREFIX_MAX_DISAB)
            {
            VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - can't find BIOS prefix for card with I/O base 0x%X\n", phwDeviceExtension->BaseIOAddress));
            return ERROR_DEV_NOT_EXIST;
            }

        }   /* endif (unassigned BIOS prefix) */

    /*
     * Find out how large a buffer we need when making a BIOS query call.
     */
    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    Registers.Eax = BIOS_GET_QUERY_SIZE;
    Registers.Ecx = BIOS_QUERY_FULL;
    if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - failed BIOS_GET_QUERY_SIZE\n"));
        return RetVal;
        }
    BufferSize = Registers.Ecx & 0x0000FFFF;

    /*
     * Allocate a buffer to store the query information. Due to the BIOS
     * being real mode, this buffer must be below 1M. When this function
     * is called, we are on the "blue screen", so there is a 32k window
     * below 1M that we can use without risk of corrupting executable code.
     *
     * To avoid the need to save and restore our buffer, use only the
     * offscreen portion of this window (video memory contents will be
     * initialized before they are used, so the leftover query structure
     * won't harm anything). Assume a 50 line text screen.
     *
     * Check to see if the query structure is small enough to fit into
     * this region, and fail if it's too big. If it fits, try to allocate
     * the memory in the colour text window and see if there's enough
     * physical memory to meet our needs. If this fails, try again for
     * the monochrome text window (since VGA can run as either colour
     * or monochrome).
     *
     * If both fail (will happen on some DEC ALPHA machines), try using
     * the existing VGA graphics screen. Since we will be using an
     * on-screen portion of this buffer, we must save and restore the
     * contents of this buffer.
     *
     * If this fails (haven't run into any machines where this is the
     * case), switch into SVGA 640x480 8BPP and use the VGA graphics
     * screen. This is a last resort, since unlike using an existing
     * screen, this will destroy the "blue screen", and is therefore not
     * transparent to the user. If we can't even get this to work, report
     * that there isn't enough buffer space. This would only happen when
     * the onboard VGA is disabled and a low-end (MDA - even CGA has 16k
     * of memory available) card is used to provide the text screen.
     */
    /*
     * Leave some room for the EDID structure, which must also be
     * read into a buffer below 1M physical.
     */
    if (BufferSize > 0x5000)
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - query needs more buffer than we have\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    BufferSeg = 0x0BA00;    /* Colour text */
    MappedBuffer = MapFramebuffer((BufferSeg << 4), BufferSize);
    if (MappedBuffer != 0)
        {
        if (IsBufferBacked(MappedBuffer, BufferSize) == FALSE)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Colour text screen not backed by physical memory\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            MappedBuffer = 0;
            }
        }
    else
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't map colour text screen\n"));
        }

    /*
     * If we were unable to allocate a large enough buffer in the
     * colour text screen, try the monochrome text screen.
     */
    if (MappedBuffer == 0)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't use colour text screen, trying monochrome text screen\n"));
        BufferSeg = 0x0B200;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), BufferSize)) != 0)
            {
            if (IsBufferBacked(MappedBuffer, BufferSize) == FALSE)
                {
                VideoDebugPrint((DEBUG_NORMAL, "Monochrome text screen not backed by physical memory\n"));
                VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
                MappedBuffer = 0;
                }
            }
        else
            {
            VideoDebugPrint((DEBUG_NORMAL, "Can't map monochrome text screen\n"));
            }
        }

    if (MappedBuffer == 0)
        {
        /*
         * We were unable to use the offscreen portion of video memory
         * in either of the text screens. Try to use an existing graphics
         * screen.
         *
         * Currently, only the DEC Alpha will fail to find the offscreen
         * portion of either text screen.
         */
        VideoDebugPrint((DEBUG_NORMAL, "Can't use monochrome text screen, trying existing graphics screen\n"));
        BufferSeg = 0x0A000;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), BufferSize)) != 0)
            {
            /*
             * Preserve the contents of VGA registers which affect the
             * manner in which graphics memory is accessed, then set
             * the values we need.
             */
            OUTP(VGA_SEQ_IND, 2);
            SavedVgaBuffer[VGA_SAVE_SEQ02] = INP(VGA_SEQ_DATA);
            OUTP(VGA_SEQ_IND, 2);
            OUTP(VGA_SEQ_DATA, 0x01);
            OUTP(VGA_GRAX_IND, 8);
            SavedVgaBuffer[VGA_SAVE_GRA08] = INP(VGA_GRAX_DATA);
            OUTP(VGA_GRAX_IND, 8);
            OUTP(VGA_GRAX_DATA, 0xFF);
            OUTP(VGA_GRAX_IND, 1);
            SavedVgaBuffer[VGA_SAVE_GRA01] = INP(VGA_GRAX_DATA);
            OUTP(VGA_GRAX_IND, 1);
            OUTP(VGA_GRAX_DATA, 0x00);

            /*
             * Save the contents of the screen to our private
             * buffer, so we can restore the screen later.
             */
            if (BufferSize > VGA_SAVE_SIZE)
                {
                VideoDebugPrint((DEBUG_ERROR, "Buffer too big to fully save/restore\n"));
                Scratch = VGA_SAVE_SIZE;
                }
            else
                {
                Scratch = BufferSize;
                }
            SavedVgaBuffer[VGA_SAVE_SIZE] = (UCHAR)(Scratch & 0x00FF);
            SavedVgaBuffer[VGA_SAVE_SIZE_H] = (UCHAR)((ULONG)((Scratch & 0xFF00) >> 8));

            for (Count = 0; (short)Count < (short)Scratch; Count++)
                {
                SavedVgaBuffer[Count] = VideoPortReadRegisterUchar(&(MappedBuffer[Count]));
                }

            if (IsBufferBacked(MappedBuffer, BufferSize) == FALSE)
                {
                VideoDebugPrint((DEBUG_NORMAL, "Existing graphics screen not backed by physical memory\n"));
                VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
                MappedBuffer = 0;
                OUTP(VGA_SEQ_IND, 2);
                OUTP(VGA_SEQ_DATA, SavedVgaBuffer[VGA_SAVE_SEQ02]);
                OUTP(VGA_GRAX_IND, 8);
                OUTP(VGA_GRAX_DATA, SavedVgaBuffer[VGA_SAVE_GRA08]);
                OUTP(VGA_GRAX_IND, 1);
                OUTP(VGA_GRAX_DATA, SavedVgaBuffer[VGA_SAVE_GRA01]);
                }
            }
        else
            {
            VideoDebugPrint((DEBUG_NORMAL, "Can't map existing graphics screen\n"));
            }
        }   /* end if (previous buffer allocation failed) */

    /*
     * If we were unable to allocate a large enough buffer in an existing
     * screen, try the VGA graphics screen. This will wipe out
     * the Windows NT "blue screen", but it gives us one last chance
     * to get a block of memory below 1M.
     * Don't start at the beginning of the VGA graphics window, since
     * we will need to distinguish this case from the nondestructive
     * access to the VGA graphics screen at cleanup time, and the
     * different buffer segment for the two cases will allow us to
     * do this.
     */
    if (MappedBuffer == 0)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Nondestructive VGA memory access failed, trying graphics screen\n"));
        Registers.Eax = 0x62;       /* 640x480 8BPP */
        VideoPortInt10(phwDeviceExtension, &Registers);
        BufferSeg = 0x0A100;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), BufferSize)) == 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "Can't map graphics screen - aborting query\n"));
            return ERROR_INSUFFICIENT_BUFFER;
            }

        if (IsBufferBacked(MappedBuffer, BufferSize) == FALSE)
            {
            VideoDebugPrint((DEBUG_ERROR, "Graphics screen not backed by memory - aborting query\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            return ERROR_INSUFFICIENT_BUFFER;
            }
        }

    /*
     * We now have a buffer big enough to hold the query structure,
     * so make the BIOS call to fill it in.
     */
    Registers.Ebx = 0;
    Registers.Edx = BufferSeg;
    Registers.Eax = BIOS_QUERY;
    Registers.Ecx = BIOS_QUERY_FULL;
    if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - failed BIOS_QUERY_FULL call\n"));
        return RetVal;
        }
    CxQuery = (struct cx_query *)MappedBuffer;

    /*
     * The Mach 64 query structure and mode tables may be a different size
     * from their equivalents (query_structure and st_mode_table). To avoid
     * overflowing our buffer, find out how many mode tables we have space
     * to hold.
     *
     * Later, when we are filling the mode tables, we will check to see
     * whether the current mode table would exceed this limit. If it would,
     * we will return ERROR_INSUFFICIENT_BUFFER rather than overflowing
     * the table.
     */
    MaxModes = (QUERYSIZE - sizeof(struct query_structure)) / sizeof(struct st_mode_table);

    /*
     * Fill in the header of the query stucture.
     */
    Query->q_structure_rev = VideoPortReadRegisterUchar(&(CxQuery->cx_structure_rev));
    VideoDebugPrint((DEBUG_DETAIL, "Structure revision = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_structure_rev))));
    Query->q_mode_offset = VideoPortReadRegisterUshort(&(CxQuery->cx_mode_offset));
    VideoDebugPrint((DEBUG_DETAIL, "Mode offset = 0x%X\n", VideoPortReadRegisterUshort(&(CxQuery->cx_mode_offset))));
    Query->q_sizeof_mode = VideoPortReadRegisterUchar(&(CxQuery->cx_mode_size));
    VideoDebugPrint((DEBUG_DETAIL, "Mode size = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_mode_size))));

    /*
     * Currently only one revision of Mach 64. Will need to
     * set multiple values once new (production) revisions come out.
     */
    Query->q_asic_rev = CI_88800_GX;
    Query->q_number_modes = 0;      /* Initially assume no modes supported */
    Query->q_status_flags = 0;

    /*
     * If the on-board VGA is enabled, set shared VGA/accelerator memory.
     * Whether or not it is enabled, the accelerator will be able to
     * access all the video memory.
     */
    if ((Query->q_VGA_type = VideoPortReadRegisterUchar(&(CxQuery->cx_vga_type)) != 0))
        {
        Scratch = INPD(MEM_CNTL) & 0x0FFFBFFFF; /* Clear MEM_BNDRY_EN bit */
        OUTPD(MEM_CNTL, Scratch);
        VideoDebugPrint((DEBUG_DETAIL, "VGA enabled on this card\n"));
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "VGA disabled on this card\n"));
        }
    Query->q_VGA_boundary = 0;

    OrigRamSize = VideoPortReadRegisterUchar(&(CxQuery->cx_memory_size));
    VideoDebugPrint((DEBUG_DETAIL, "Raw memory size = 0x%X\n", OrigRamSize));
    Query->q_memory_size = CXMapMemSize[OrigRamSize];
    MemAvail = Query->q_memory_size * QUARTER_MEG;

    /*
     * DAC types are not contiguous, so a lookup table would be
     * larger than necessary and restrict future expansion.
     */
    OrigDacType = VideoPortReadRegisterUchar(&(CxQuery->cx_dac_type));
    VideoDebugPrint((DEBUG_DETAIL, "cx_dac_type = 0x%X\n", OrigDacType));
    switch(OrigDacType)
        {
        case 0x00:
            VideoDebugPrint((DEBUG_DETAIL, "Internal DAC\n"));
            Scratch = VideoPortReadRegisterUshort(&(CxQuery->cx_asic_rev));
            if ((Scratch & 0xFF00) == 0x4300)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Mach 64 CT internal DAC\n"));
                Query->q_DAC_type = DAC_INTERNAL_CT;
                }
            else if ((Scratch & 0xFF00) == 0x5600)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Mach 64 VT internal DAC\n"));
                Query->q_DAC_type = DAC_INTERNAL_VT;
                }
            else if ((Scratch & 0xFF00) == 0x4700)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Mach 64 GT internal DAC\n"));
                Query->q_DAC_type = DAC_INTERNAL_GT;
                }
            else
                {
                VideoDebugPrint((DEBUG_ERROR, "Unknown internal DAC (ASIC ID = 0x%X), treating as BT47x\n", Scratch));
                Query->q_DAC_type = DAC_BT47x;
                }
            DacTypeMask = 0x01;
            break;

        case 0x01:
            VideoDebugPrint((DEBUG_DETAIL, "IBM 514 DAC\n"));
            Query->q_DAC_type = DAC_IBM514;
            DacTypeMask = 0x02;
            break;

        case 0x02:
            VideoDebugPrint((DEBUG_DETAIL, "TI34075 DAC\n"));
            Query->q_DAC_type = DAC_TI34075;
            DacTypeMask = 0x04;
            break;

        case 0x72:
            VideoDebugPrint((DEBUG_DETAIL, "TVP 3026 DAC\n"));
            Query->q_DAC_type = DAC_TVP3026;
            DacTypeMask = 0x04;
            break;

        case 0x04:
            VideoDebugPrint((DEBUG_DETAIL, "BT48x DAC\n"));
            Query->q_DAC_type = DAC_BT48x;
            DacTypeMask = 0x10;
            break;

        case 0x14:
            VideoDebugPrint((DEBUG_DETAIL, "AT&T 49[123] DAC\n"));
            Query->q_DAC_type = DAC_ATT491;
            DacTypeMask = 0x10;
            break;

        case 0x05:
        case 0x15:
            VideoDebugPrint((DEBUG_DETAIL, "ATI68860 DAC\n"));
            Query->q_DAC_type = DAC_ATI_68860;
            DacTypeMask = 0x20;
            break;

        case 0x06:
            VideoDebugPrint((DEBUG_DETAIL, "STG1700 DAC\n"));
            Query->q_DAC_type = DAC_STG1700;
            DacTypeMask = 0x40;
            break;

        case 0x07:
        case 0x67:
        case 0x77:
        case 0x87:
        case 0x97:
        case 0xA7:
        case 0xB7:
        case 0xC7:
        case 0xD7:
        case 0xE7:
        case 0xF7:
            VideoDebugPrint((DEBUG_DETAIL, "STG1702 DAC\n"));
            Query->q_DAC_type = DAC_STG1702;
            DacTypeMask = 0x80;
            break;

        case 0x37:
            VideoDebugPrint((DEBUG_DETAIL, "STG1703 DAC\n"));
            Query->q_DAC_type = DAC_STG1703;
            DacTypeMask = 0x80;
            break;

        case 0x47:
            VideoDebugPrint((DEBUG_DETAIL, "CH8398 DAC\n"));
            Query->q_DAC_type = DAC_CH8398;
            DacTypeMask = 0x80;
            break;

        case 0x57:
            VideoDebugPrint((DEBUG_DETAIL, "AT&T 408 DAC\n"));
            Query->q_DAC_type = DAC_ATT408;
            DacTypeMask = 0x80;
            break;

        case 0x16:
        case 0x27:
            VideoDebugPrint((DEBUG_DETAIL, "AT&T 498 DAC\n"));
            Query->q_DAC_type = DAC_ATT498;
            DacTypeMask = 0x80;
            break;

        case 0x17:
            VideoDebugPrint((DEBUG_DETAIL, "SC15021 DAC\n"));
            Query->q_DAC_type = DAC_SC15021;
            DacTypeMask = 0x80;
            break;

        case 0x75:
            VideoDebugPrint((DEBUG_DETAIL, "TVP 3026 DAC\n"));
            Query->q_DAC_type = DAC_TVP3026;
            DacTypeMask = 0x20;
            break;

        case 0x03:
            VideoDebugPrint((DEBUG_DETAIL, "BT 47x DAC\n"));
            Query->q_DAC_type = DAC_BT47x;
            DacTypeMask = 0x04;
            break;

        default:
            VideoDebugPrint((DEBUG_ERROR, "Unknown DAC, treating as BT 47x\n"));
            Query->q_DAC_type = DAC_BT47x;
            DacTypeMask = 0x04;
            break;
            }
    VideoDebugPrint((DEBUG_DETAIL, "Raw memory type = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_memory_type))));

    /*
     * Bit 7 of the memory type is used to indicate lack of block write
     * capability on recent BIOSes, but not on older ones. Strip it
     * before mapping the RAM type in order to avoid the need for an
     * additional 128 entries, most of which are unused, in the
     * mapping table.
     *
     * Even though the absence of this flag is not a reliable indicator
     * of block write capability, its presence is a reliable indicator
     * of a lack of block write capability.
     *
     * We can strip this flag after setting the block write status since
     * this is the only place it is used, and subsequent references to
     * the memory type require only the lower 7 bits.
     */
    OrigRamType = VideoPortReadRegisterUchar(&(CxQuery->cx_memory_type));
    if (OrigRamType & 0x80)
        Query->q_BlockWrite = BLOCK_WRITE_NO;
    OrigRamType &= 0x7F;
    /*
     * A given memory type value will have different meanings for
     * different ASIC types. While the GX and CX use different
     * RAM types, none of them require special-case handling,
     * so we can treat these ASIC types as equivalent.
     */
    Scratch = INPD(CONFIG_CHIP_ID) & CONFIG_CHIP_ID_TypeMask;
    if ((Scratch == CONFIG_CHIP_ID_TypeGX) ||
        (Scratch == CONFIG_CHIP_ID_TypeCX))
        {
        VideoDebugPrint((DEBUG_DETAIL, "Setting q_memory_type for CX or GX\n"));
        Query->q_memory_type = CXMapRamType[OrigRamType];
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "Setting q_memory_type for CT/VT/GT\n"));
        Query->q_memory_type = CTMapRamType[OrigRamType];
        }

    VideoDebugPrint((DEBUG_DETAIL, "Raw bus type = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_bus_type))));
    Query->q_bus_type = CXMapBus[VideoPortReadRegisterUchar(&(CxQuery->cx_bus_type))];

    /*
     * Get the linear aperture configuration. If the linear aperture and
     * VGA aperture are both disabled, return ERROR_DEV_NOT_EXIST, since
     * some Mach 64 registers exist only in memory mapped form and are
     * therefore not available without an aperture.
     */
    Query->q_aperture_cfg = VideoPortReadRegisterUchar(&(CxQuery->cx_aperture_cfg)) & BIOS_AP_SIZEMASK;
    VideoDebugPrint((DEBUG_DETAIL, "Aperture configuration = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_aperture_cfg))));
    if (Query->q_aperture_cfg == 0)
        {
        if (Query->q_VGA_type == 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "Neither linear nor VGA aperture exists - aborting query\n"));
            return ERROR_DEV_NOT_EXIST;
            }
        Query->q_aperture_addr = 0;
        }
    else
        {
        Query->q_aperture_addr = VideoPortReadRegisterUshort(&(CxQuery->cx_aperture_addr));
        VideoDebugPrint((DEBUG_DETAIL, "Aperture at %d megabytes\n", Query->q_aperture_addr));
        /*
         * If the 8M aperture is configured on a 4M boundary that is
         * not also an 8M boundary, it will actually start on the 8M
         * boundary obtained by truncating the reported value to a
         * multiple of 8M.
         */
        if ((Query->q_aperture_cfg & BIOS_AP_SIZEMASK) == BIOS_AP_8M)
            {
            VideoDebugPrint((DEBUG_DETAIL, "8 megabyte aperture\n"));
            Query->q_aperture_addr &= 0xFFF8;
            }
        }

    /*
     * The Mach 64 does not support shadow sets, so re-use the shadow
     * set 1 definition to hold deep colour support and RAMDAC special
     * features information.
     */
    Query->q_shadow_1 = VideoPortReadRegisterUchar(&(CxQuery->cx_deep_colour)) | (VideoPortReadRegisterUchar(&(CxQuery->cx_ramdac_info)) << 8);
    VideoDebugPrint((DEBUG_DETAIL, "Deep colour support = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_deep_colour))));

    /*
     * If this card supports non-palette modes, choose which of the supported
     * colour orderings to use at each pixel depth. Record the maximum
     * pixel depth the card supports, since some of the mode tables
     * may list a maximum pixel depth beyond the DAC's capabilities.
     *
     * Assume that no DAC will support nBPP (n > 8) without also supporting
     * all colour depths between 8 and n.
     */
    AbsMaxDepth = 8;    /* Cards without high colour support */
    if (Query->q_shadow_1 & S1_16BPP_565)
        {
        Query->q_HiColourSupport = RGB16_565;
        AbsMaxDepth = 16;
        }
    if (Query->q_shadow_1 & S1_24BPP)
        {
        if (Query->q_shadow_1 & S1_24BPP_RGB)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP order RGB\n"));
            Query->q_HiColourSupport |= RGB24_RGB;
            }
        else
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP order BGR\n"));
            Query->q_HiColourSupport |= RGB24_BGR;
            }
        AbsMaxDepth = 24;
        }
    if (Query->q_shadow_1 & S1_32BPP)
        {
        if (Query->q_shadow_1 & S1_32BPP_RGBx)
            {
            VideoDebugPrint((DEBUG_DETAIL, "32BPP order RGBx\n"));
            Query->q_HiColourSupport |= RGB32_RGBx;
            }
        else if (Query->q_shadow_1 & S1_32BPP_xRGB)
            {
            VideoDebugPrint((DEBUG_DETAIL, "32BPP order xRGB\n"));
            Query->q_HiColourSupport |= RGB32_xRGB;
            }
        else if (Query->q_shadow_1 & S1_32BPP_BGRx)
            {
            VideoDebugPrint((DEBUG_DETAIL, "32BPP order BGRx\n"));
            Query->q_HiColourSupport |= RGB32_BGRx;
            }
        else
            {
            VideoDebugPrint((DEBUG_DETAIL, "32BPP order xBGR\n"));
            Query->q_HiColourSupport |= RGB32_xBGR;
            }
        AbsMaxDepth = 32;
        }

    /*
     * Get the hardware capability list.
     */
    Registers.Eax = BIOS_CAP_LIST;
    Registers.Ecx = 0xFFFF;
    if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - failed BIOS_CAP_LIST\n"));
        return RetVal;
        }

    FormatType = (short)(Registers.Eax & 0x000000FF);

    /*
     * Map in the table of hardware capabilities whose pointer was returned
     * by the BIOS call. The call does not return the size of the table,
     * but according to Steve Stefanidis 1k is plenty of space.
     *
     * We must include the 2 bytes immediately preceeding the table when
     * we map it, since they contain information about the way the table
     * is arranged.
     */
    if ((HwCapBuffer = MapFramebuffer(((Registers.Edx << 4) | (Registers.Ebx - 2)), 1024)) == 0)
        {
        VideoDebugPrint((DEBUG_ERROR, "Can't map hardware capability table at 0x%X:0x%X\n", Registers.Edx, Registers.Ebx));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * If the value in the CX register was changed, there is a second
     * table with supplemental values. According to Arthur Lai, this
     * second table will only extend the original table, and never
     * detract from it. If this table exists, but we can't map it,
     * we can still work with the primrary table rather than treating
     * the failure as a fatal error.
     *
     * While the BIOS will leave the CX register alone if the second
     * table doesn't exist, there is no guarantee that Windows NT will
     * leave the upper 16 bits of ECX alone.
     */
    if ((Registers.Ecx & 0x0000FFFF) == 0xFFFF)
        {
        HwSupBuffer = 0;
        }
    else
        {
        HwSupBuffer = MapFramebuffer(((Registers.Edx << 4) | Registers.Ecx), 1024);
        }

    HwCapBytesPerRow = VideoPortReadRegisterUchar(HwCapBuffer + 1);
    VideoDebugPrint((DEBUG_DETAIL, "Table has %d bytes per row\n", HwCapBytesPerRow));

    pmode = (struct st_mode_table *)Query;
    ((struct query_structure *)pmode)++;

    /*
     * Initially, we do not know whether to merge our "canned" mode
     * tables with tables from an EDID structure returned via DDC,
     * or with tables from a VDIF file. If we are dealing with an
     * EDID structure, we have not yet read any data, so the initial
     * checksum is zero.
     */
    phwDeviceExtension->MergeSource = MERGE_UNKNOWN;
    phwDeviceExtension->EdidChecksum = 0;

    /*
     * Search through the returned mode tables, and fill in the query
     * structure's mode tables using the information we find there.
     *
     * DOES NOT ASSUME: Order of mode tables, or number of mode
     *                  tables per resolution.
     */
    for (CurrentRes = RES_640; CurrentRes <= RES_1600; CurrentRes++)
        {
        CxModeTable = (struct cx_mode_table *)(MappedBuffer + VideoPortReadRegisterUshort(&(CxQuery->cx_mode_offset)));

        /*
         * The list of maximum pixel clock frequencies contains either
         * garbage (640x480), or the results for the previous resolution.
         * Clear it.
         */
        for (Count = DEPTH_NOTHING; Count <= DEPTH_32BPP; Count++)
            MaxDotClock[Count] = 0;

        /*
         * Search through the list of hardware capabilities. If we find
         * an entry for the current resolution, the DAC/RAM type is
         * correct, and we have enough memory, update the list of
         * maximum pixel clock frequencies.
         *
         * If we have switched to the supplemental table on a previous
         * resolution, switch back to the primrary table.
         */
        HwCapWalker = HwCapBuffer + 2;
        HwCapEntry = (struct cx_hw_cap *)HwCapWalker;
        if (FormatType >= FORMAT_DACTYPE)
            FormatType -= FORMAT_DACTYPE;

        while (VideoPortReadRegisterUchar(&(HwCapEntry->cx_HorRes)) != 0)
            {
            /*
             * Assigning HwCapEntry is redundant on the first pass
             * through the loop, but by assigning it and then incrementing
             * HwCapWalker at the beginning of the loop it reduces the
             * complexity of each "skip this entry because it doesn't
             * apply to us" decision point.
             *
             * A side effect of this is that we will check each entry
             * to see if its horizontal resolution is zero (end-of-table
             * flag) only after we have examined it in an attempt to
             * add its pixel clock data to our list. This is harmless,
             * since a horizontal resolution of zero will not match any
             * of the resolutions we are looking for, so the check to
             * see if the current entry is for the correct resolution
             * will always interpret the end-of-table flag as being
             * an entry for the wrong resolution, and skip to the next
             * entry. This will take us to the top of the loop, where
             * we will see that we have hit the end of the table.
             */
            HwCapEntry = (struct cx_hw_cap *)HwCapWalker;
            HwCapWalker += HwCapBytesPerRow;

            /*
             * If we have run into the end of the first table and
             * the second (supplemental) table exists, switch to
             * it. If we have hit the end of the supplemental
             * table, the check to see if we're looking at an
             * entry corresponding to the desired resolution will
             * catch it and get us out of the loop.
             *
             * The format type returned by the BIOS is the same
             * regardless of whether we are working with the
             * primrary or supplemental table. Since the primrary
             * table uses masks based on the type, while the
             * supplemental table requires an exact match, we
             * must distinguish between the tables when looking
             * at the format type. By making a duplicate set of
             * format types for "exact match", with each defined
             * value in this set being greater than its "mask"
             * counterpart by the number of format types the BIOS
             * can return, we can also use the format type to
             * determine which table we are working with. The
             * DAC-formatted table is the lowest (zero for "mask",
             * number of format types for "exact match").
             */
            if ((VideoPortReadRegisterUchar(&(HwCapEntry->cx_HorRes)) == 0) &&
                (FormatType < FORMAT_DACTYPE))
                {
                VideoDebugPrint((DEBUG_DETAIL, "Switching to supplemental table\n"));
                HwCapWalker = HwSupBuffer;
                HwCapEntry = (struct cx_hw_cap *)HwCapWalker;
                HwCapWalker += HwCapBytesPerRow;
                FormatType += FORMAT_DACTYPE;
                }

            /*
             * Reject entries dealing with resolutions other than the
             * one we are interested in. The cx_HorRes field is in units
             * of 8 pixels.
             */
            Scratch = VideoPortReadRegisterUchar(&(HwCapEntry->cx_HorRes));
            if (((CurrentRes == RES_640) && (Scratch != 80)) ||
                ((CurrentRes == RES_800) && (Scratch != 100)) ||
                ((CurrentRes == RES_1024) && (Scratch != 128)) ||
                ((CurrentRes == RES_1152) && (Scratch != 144)) ||
                ((CurrentRes == RES_1280) && (Scratch != 160)) ||
                ((CurrentRes == RES_1600) && (Scratch != 200)))
                {
                VideoDebugPrint((DEBUG_DETAIL, "Incorrect resolution - %d pixels wide\n", (Scratch*8)));
                continue;
                }
            VideoDebugPrint((DEBUG_DETAIL, "Correct resolution"));

            /*
             * Reject entries which require a DAC or RAM type other
             * than that installed on the card.
             *
             * Reminder - Unlike loops, switch statements are affected
             *            by "break" but not by "continue".
             */
            switch(FormatType)
                {
                case FORMAT_DACMASK:
                    if ((VideoPortReadRegisterUchar(&(HwCapEntry->cx_RamOrDacType)) & DacTypeMask) == 0)
                        {
                        VideoDebugPrint((DEBUG_DETAIL, " but wrong DAC type (mask)\n"));
                        continue;
                        }
                    break;

                case FORMAT_RAMMASK:
                    /*
                     * Although the BIOS query structure definition allows bits
                     * 0 through 3 of the memory type field to be used as a
                     * memory type identifier, we must use only bits 0 through
                     * 2 to avoid shifting past the end of the 8-bit mask. Since
                     * even the ASIC which supports the most memory types (GX)
                     * only supports 7 types according to my BIOS guide, this
                     * should not be a problem.
                     */
                    if ((VideoPortReadRegisterUchar(&(HwCapEntry->cx_RamOrDacType)) & (1 << (OrigRamType & 0x07))) == 0)
                        {
                        VideoDebugPrint((DEBUG_DETAIL, " but wrong RAM type (mask)\n"));
                        continue;
                        }
                    break;

                case FORMAT_DACTYPE:
                    if (VideoPortReadRegisterUchar(&(HwCapEntry->cx_RamOrDacType)) != OrigDacType)
                        {
                        VideoDebugPrint((DEBUG_DETAIL, " but wrong DAC type (exact match)\n"));
                        continue;
                        }
                    break;

                case FORMAT_RAMTYPE:
                    if (VideoPortReadRegisterUchar(&(HwCapEntry->cx_RamOrDacType)) != OrigRamType)
                        {
                        VideoDebugPrint((DEBUG_DETAIL, " but wrong RAM type (exact match)\n"));
                        continue;
                        }
                    break;

                default:
                    VideoDebugPrint((DEBUG_ERROR, "\nInvalid format type %d\n", FormatType));
                    continue;
                    break;
                }
            VideoDebugPrint((DEBUG_DETAIL, ", correct DAC/RAM type"));

            /*
             * Reject entries which require more RAM than is
             * installed on the card. The amount of RAM required
             * for a given mode may vary between VRAM and DRAM
             * cards.
             *
             * The same RAM type code may represent different
             * types of RAM for different Mach 64 ASICs. Since
             * only the GX supports VRAM (as of the time of printing
             * of my BIOS guide), it is safe to assume that any
             * non-GX ASIC is using DRAM.
             */
            Scratch = OrigRamType;
            if ((INPW(CONFIG_CHIP_ID) == CONFIG_CHIP_ID_TypeGX) &&
                ((Scratch == 1) ||
                (Scratch == 2) ||
                (Scratch == 5) ||
                (Scratch == 6)))
                {
                Scratch = VideoPortReadRegisterUchar(&(HwCapEntry->cx_MemReq)) & 0x0F;
                }
            else /* if (card uses DRAM) */
                {
                Scratch = VideoPortReadRegisterUchar(&(HwCapEntry->cx_MemReq)) & 0xF0;
                Scratch >>= 4;
                }

            if (Scratch > OrigRamSize)
                {
                VideoDebugPrint((DEBUG_DETAIL, " but insufficient RAM\n"));
                continue;
                }
            VideoDebugPrint((DEBUG_DETAIL, ", and enough RAM to support the mode\n"));

            /*
             * We have found an entry corresponding to this card's
             * capabilities. For each pixel depth up to and including
             * the maximum applicable for this entry, set the maximum
             * pixel clock rate to the higher of its current value
             * and the value for this entry.
             *
             * We must mask off the high bit of the maximum pixel depth
             * because it is a flag which is irrelevant for our purposes.
             */
            Scratch = VideoPortReadRegisterUchar(&(HwCapEntry->cx_MaxPixDepth)) & 0x7F;
            for (CurrentDepth = DEPTH_NOTHING; CurrentDepth <= Scratch; CurrentDepth++)
                {
                if (VideoPortReadRegisterUchar(&(HwCapEntry->cx_MaxDotClock)) > MaxDotClock[CurrentDepth])
                    {
                    MaxDotClock[CurrentDepth] = VideoPortReadRegisterUchar(&(HwCapEntry->cx_MaxDotClock));
                    VideoDebugPrint((DEBUG_DETAIL, "Increased MaxDotClock[%d] to %d MHz\n", CurrentDepth, MaxDotClock[CurrentDepth]));
                    }
                }
            }   /* end while (more entries in hardware capability table) */

        /*
         * On some cards, the BIOS will report in AX=0xA?07 maximum pixel
         * clock rates for pixel depths which AX=0xA?09 byte 0x13 reports
         * as unsupported. Since switching into these modes will produce
         * bizarre displays, we must mark these pixel depths as unavailable.
         */
        switch (AbsMaxDepth)
            {
            case 8:
                VideoDebugPrint((DEBUG_DETAIL, "Forcing cutback to 8BPP maximum\n"));
                MaxDotClock[DEPTH_16BPP] = 0;
                MaxDotClock[DEPTH_24BPP] = 0;
                MaxDotClock[DEPTH_32BPP] = 0;
                break;

            case 16:
                VideoDebugPrint((DEBUG_DETAIL, "Forcing cutback to 16BPP maximum\n"));
                MaxDotClock[DEPTH_24BPP] = 0;
                MaxDotClock[DEPTH_32BPP] = 0;
                break;

            case 24:
                VideoDebugPrint((DEBUG_DETAIL, "Forcing cutback to 24BPP maximum\n"));
                MaxDotClock[DEPTH_32BPP] = 0;
                break;

            case 32:
            default:
                VideoDebugPrint((DEBUG_DETAIL, "No forced cutback needed\n"));
                break;
            }

        /*
         * Our new source stream display driver needs a linear aperture
         * in order to handle 24BPP. Since the display driver doesn't
         * have access to the aperture information when it is deciding
         * which modes to pass on to the display applet, it can't make
         * the decision to reject 24BPP modes for cards with only a
         * VGA aperture. This decision must therefore be made in the
         * miniport, so in a paged aperture configuration there are no
         * 24BPP modes for the display driver to accept or reject.
         *
         * On the DEC Alpha, we treat machines using sparse space as
         * a synthetic no-aperture case even if the LFB is enabled,
         * so we must lock out 24BPP on these machines as well.
         */
        if (Query->q_aperture_cfg == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP not available because we don't have a linear aperture\n"));
            MaxDotClock[DEPTH_24BPP] = 0;
            }

#if defined(ALPHA)
        if (DenseOnAlpha(Query) == FALSE)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP not available in sparse space on Alpha\n"));
            MaxDotClock[DEPTH_24BPP] = 0;
            }
#endif

        VideoDebugPrint((DEBUG_NORMAL, "Horizontal resolution = %d\n", CXHorRes[CurrentRes]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 4BPP = %d MHz\n", MaxDotClock[DEPTH_4BPP]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 8BPP = %d MHz\n", MaxDotClock[DEPTH_8BPP]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 16BPP = %d MHz\n", MaxDotClock[DEPTH_16BPP]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 24BPP = %d MHz\n", MaxDotClock[DEPTH_24BPP]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 32BPP = %d MHz\n", MaxDotClock[DEPTH_32BPP]));

        /*
         * Search through the list of installed mode tables to see if there
         * are any for the current resolution. We need this information
         * in order to decide whether or not to make the hardware default
         * refresh rate available for this resolution (BIOS behaviour is
         * undefined when trying to load CRT parameters for the hardware
         * default refresh rate at a given resolution if that resolution
         * is not among the installed modes).
         */
        ModeInstalled = FALSE;
        for (Count = 1; Count <= VideoPortReadRegisterUchar(&(CxQuery->cx_number_modes)); Count++)
            {
            /*
             * If the current mode table matches the resolution we are
             * looking for, then we know that there is a hardware
             * default refresh rate available for this resolution.
             * Since we only need to find one such mode table, there
             * is no need to search the remainder of the mode tables.
             */
            if (VideoPortReadRegisterUshort(&(CxModeTable->cx_x_size)) == CXHorRes[CurrentRes])
                {
                ModeInstalled = TRUE;
                VideoDebugPrint((DEBUG_DETAIL, "%d table found\n", CXHorRes[CurrentRes]));
                break;
                }

            ((PUCHAR)CxModeTable) += VideoPortReadRegisterUchar(&(CxQuery->cx_mode_size));
            }

        /*
         * The MaxDotClock[] entry for any pixel depth will
         * contain either the maximum pixel clock for that
         * pixel depth at the current resolution, or zero
         * if that pixel depth is not supported at the
         * current resolution. For any resolution, the
         * maximum supported pixel clock rate will either
         * remain the same or decrease as the pixel depth
         * increases, but it will never increase.
         *
         * The pixel clock rate for 4BPP (lowest pixel depth
         * we support) will only be zero if the card does not
         * support the current resolution. If this is the case,
         * skip to the next resolution.
         */
        if (MaxDotClock[DEPTH_4BPP]  == 0)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Current resolution not supported on this card - skipping to next.\n"));
            continue;
            }

        Query->q_status_flags |= CXStatusFlags[CurrentRes];
        VideoPortZeroMemory(&ThisRes, sizeof(struct st_mode_table));

        /*
         * Replace the "canned" mode tables with the Mach 64 versions
         * in cases where the Mach 64 needs CRT parameters the
         * Mach 8 and Mach 32 can't handle.
         */
        SetMach64Tables();

        /*
         * Set up the ranges of "canned" mode tables to use for each
         * resolution. Initially assume that all tables at the desired
         * resolution are available, later we will cut out those that
         * are unavailable because the DAC and/or memory type doesn't
         * support them at specific resolutions.
         */
        switch (CurrentRes)
            {
            case RES_640:
                StartIndex = B640F60;
                EndIndex = B640F100;
                ThisRes.m_x_size = 640;
                ThisRes.m_y_size = 480;
                break;

            case RES_800:
                StartIndex = B800F89;
                EndIndex = B800F100;
                ThisRes.m_x_size = 800;
                ThisRes.m_y_size = 600;
                break;

            case RES_1024:
                StartIndex = B1024F87;
                EndIndex = B1024F100;
                ThisRes.m_x_size = 1024;
                ThisRes.m_y_size = 768;
                break;

            case RES_1152:
                StartIndex = B1152F87;
                EndIndex = B1152F80;
                ThisRes.m_x_size = 1152;
                ThisRes.m_y_size = 864;
                break;

            case RES_1280:
                StartIndex = B1280F87;
                EndIndex = B1280F75;
                ThisRes.m_x_size = 1280;
                ThisRes.m_y_size = 1024;
                break;

            case RES_1600:
                StartIndex = B1600F60;
                EndIndex = B1600F76;
                ThisRes.m_x_size = 1600;
                ThisRes.m_y_size = 1200;
                break;
            }

        /*
         * Use a screen pitch equal to the horizontal resolution for
         * linear aperture, and of 1024 or the horizontal resolution
         * (whichever is higher) for VGA aperture.
         */
        ThisRes.m_screen_pitch = ThisRes.m_x_size;
#if !defined (SPLIT_RASTERS)
        if (((Query->q_aperture_cfg & BIOS_AP_SIZEMASK) == 0) &&
            (ThisRes.m_x_size < 1024))
            ThisRes.m_screen_pitch = 1024;

        /*
         * Temporary until split rasters implemented.
         */
        if (((Query->q_aperture_cfg & BIOS_AP_SIZEMASK) == 0) &&
            (ThisRes.m_x_size > 1024))
            ThisRes.m_screen_pitch = 2048;
#endif

        /*
         * Get the parameters we need out of the table returned
         * by the BIOS call.
         */
        ThisRes.m_h_total = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_h_total));
        ThisRes.m_h_disp = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_h_disp));
        ThisRes.m_h_sync_strt = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_h_sync_strt));
        ThisRes.m_h_sync_wid = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_h_sync_wid));
        ThisRes.m_v_total = VideoPortReadRegisterUshort(&(CxModeTable->cx_crtc_v_total));
        ThisRes.m_v_disp = VideoPortReadRegisterUshort(&(CxModeTable->cx_crtc_v_disp));
        ThisRes.m_v_sync_strt = VideoPortReadRegisterUshort(&(CxModeTable->cx_crtc_v_sync_strt));
        ThisRes.m_v_sync_wid = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_v_sync_wid));
        ThisRes.m_h_overscan = VideoPortReadRegisterUshort(&(CxModeTable->cx_h_overscan));
        ThisRes.m_v_overscan = VideoPortReadRegisterUshort(&(CxModeTable->cx_v_overscan));
        ThisRes.m_overscan_8b = VideoPortReadRegisterUshort(&(CxModeTable->cx_overscan_8b));
        ThisRes.m_overscan_gr = VideoPortReadRegisterUshort(&(CxModeTable->cx_overscan_gr));
        ThisRes.m_clock_select = VideoPortReadRegisterUchar(&(CxModeTable->cx_clock_cntl));
        ThisRes.control = VideoPortReadRegisterUshort(&(CxModeTable->cx_crtc_gen_cntl));
        ThisRes.Refresh = DEFAULT_REFRESH;

        /*
         * For each supported pixel depth at the given resolution,
         * copy the mode table, fill in the colour depth field,
         * and increment the counter for the number of supported modes.
         * Test 4BPP before 8BPP so the mode tables will appear in
         * increasing order of pixel depth.
         *
         * If filling in the mode table would overflow the space available
         * for mode tables, return the appropriate error code instead
         * of continuing.
         *
         * All the DACs we support can handle 8 BPP at all the
         * resolutions they support if there is enough memory on
         * the card, and all but the 68860, IBM514, and TVP3026
         * can support 4BPP under the same circumstances. If a
         * DAC doesn't support a given resolution (e.g. 1600x1200),
         * the MaxDotClock[] array will be zero for the resolution,
         * and the INSTALL program won't set up any mode tables for
         * that resolution. This will result in a kick-out at an
         * earlier point in the code (when we found that 4BPP has a
         * maximum pixel clock rate of zero), so we will never reach
         * this point on resolutions the DAC doesn't support.
         *
         * 4BPP is only needed for resolutions where we don't have
         * enough video memory to support 8BPP. At Microsoft's request,
         * we must lock out 4BPP for resolutions where we can support
         * 8BPP. We only support 4BPP on 1M cards since a BIOS quirk
         * on some cards requires that we set the memory size to 1M
         * when we switch into 4BPP. The DACs where we lock out 4BPP
         * unconditionally are only found on VRAM cards, where the
         * minimum configuration is 2M.
         */
        NumPixels = ThisRes.m_screen_pitch * ThisRes.m_y_size;
        if((NumPixels < ONE_MEG*2) &&
            ((MemAvail == ONE_MEG) && (NumPixels >= ONE_MEG)) &&
            (MaxDotClock[DEPTH_4BPP] > 0) &&
            (Query->q_DAC_type != DAC_ATI_68860) &&
            (Query->q_DAC_type != DAC_TVP3026) &&
            (Query->q_DAC_type != DAC_IBM514))
            {
            if (ModeInstalled)
                {
                if (Query->q_number_modes >= MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 4;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */

            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   4,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_4BPP] * 1000000L),
                                                   &pmode);
            }
        if ((NumPixels < MemAvail) &&
            (MaxDotClock[DEPTH_8BPP] > 0))
            {
            /*
             * On some Mach 64 cards (depends on ASIC revision, RAM type,
             * and DAC type), screen tearing will occur in 8BPP if the
             * pitch is not a multiple of 64 pixels (800x600 is the only
             * resolution where this is possible).
             *
             * If the pitch has already been boosted to 1024 (VGA aperture
             * with no split rasters), it is already a multiple of 64, so
             * no change is needed.
             */
            if (ThisRes.m_screen_pitch == 800)
                ThisRes.m_screen_pitch = 832;

            if (ModeInstalled)
                {
                if (Query->q_number_modes >= MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 8;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */
            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   8,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_8BPP] * 1000000L),
                                                   &pmode);
            /*
             * If we have boosted the screen pitch to avoid tearing,
             * cut it back to normal, since the boost is only needed
             * in 8BPP. We will only have a pitch of 832 in 800x600
             * with the pitch boost in place.
             */
            if (ThisRes.m_screen_pitch == 832)
                ThisRes.m_screen_pitch = 800;
            }

        if ((NumPixels*2 < MemAvail) &&
            (MaxDotClock[DEPTH_16BPP] > 0))
            {
            if (ModeInstalled)
                {
                if (Query->q_number_modes >= MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 16;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */

            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   16,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_16BPP] * 1000000L),
                                                   &pmode);
            }

        if ((NumPixels*3 < MemAvail) &&
            (MaxDotClock[DEPTH_24BPP] > 0))
            {
            if (ModeInstalled)
                {
                if (Query->q_number_modes >= MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 24;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */
            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }

            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   24,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_24BPP] * 1000000L),
                                                   &pmode);
            }

        if ((NumPixels*4 < MemAvail) &&
            (MaxDotClock[DEPTH_32BPP] > 0))
            {
            if (ModeInstalled)
                {
                if (Query->q_number_modes > MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 32;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */

            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   32,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_32BPP] * 1000000L),
                                                   &pmode);
            }
        }   /* end for */

    Query->q_sizeof_struct = Query->q_number_modes * sizeof(struct st_mode_table) + sizeof(struct query_structure);
    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
    return NO_ERROR;

}   /* QueryMach64() */



/***************************************************************************
 *
 * BOOL BlockWriteAvail_cx(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Test to see whether block write mode is available. This function
 *  assumes that the card has been set to an accelerated mode.
 *
 * RETURN VALUE:
 *  TRUE if this mode is available
 *  FALSE if it is not available
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

#define BLOCK_WRITE_LENGTH 120

BOOL BlockWriteAvail_cx(struct query_structure *Query)
{
    BOOL RetVal = TRUE;
    ULONG ColourMask;           /* Mask off unneeded bits of Colour */
    ULONG Colour;               /* Colour to use in testing */
    USHORT Width, excess = 8;   /* Width of test block */
    USHORT Column;              /* Column being checked */
    ULONG ScreenPitch;          /* Pitch in units of 8 pixels */
    ULONG PixelDepth;           /* Colour depth of screen */
    ULONG HorScissors;          /* Horizontal scissor values */
    PULONG FrameAddress;        /* Pointer to base of LFB */
    PULONG ReadPointer;         /* Used in reading test block */
    ULONG DstOffPitch;          /* Saved contents of DST_OFF_PITCH register */

#if defined (PPC)
    /*
     * Block write does not work properly on the power PC. Under some
     * circumstances, we will detect that the card is capable of using
     * block write mode, but it will hang the machine when used for
     * a large block (our test is for a small block).
     */
    VideoDebugPrint((DEBUG_DETAIL, "Can't do block write on a PPC\n"));
    return FALSE;
#else

    /*
     * Our block write test involves an engine draw followed by
     * a read back through the linear framebuffer. If the linear
     * framebuffer is unavailable, assume that we can't do block
     * write, since all our cards are able to function without
     * block write.
     */
    if (!(Query->q_aperture_cfg))
        {
        VideoDebugPrint((DEBUG_DETAIL, "LFB unavailable, can't do block write check\n"));
        return FALSE;
        }

    /*
     * Mach 64 ASICs prior to revision D have a hardware bug that does
     * not allow transparent block writes (special handling is required
     * that in some cases can cut performance).
     */
    if ((INPD(CONFIG_CHIP_ID) & CONFIG_CHIP_ID_RevMask) < CONFIG_CHIP_ID_RevD)
        {
        VideoDebugPrint((DEBUG_DETAIL, "ASIC/memory combination doesn't allow block write\n"));
        return FALSE;
        }

    /*
     * Block write is only available on "special VRAM" cards.
     */
    if (Query->q_memory_type != VMEM_VRAM_256Kx4_SPLIT512
    &&  Query->q_memory_type != VMEM_VRAM_256Kx16_SPLIT256)
        {
        VideoDebugPrint((DEBUG_DETAIL, "*** No block write - wrong RAM type\n" ));
        return FALSE;
        }

    /*
     * Special case: block write doesn't work properly on the
     * GX rev. E with IBM RAM.
     */
    if ((INPD(CONFIG_CHIP_ID) == (CONFIG_CHIP_ID_GXRevE)) &&
        (Query->q_memory_type == VMEM_VRAM_256Kx16_SPLIT256))
        {
        VideoDebugPrint((DEBUG_DETAIL, "*** No block write - GX/E with IBM RAM\n"));
        return FALSE;
        }

    /*
     * Use a 480 byte test block. This size will fit on a single line
     * even at the lowest resolution (640x480) and pixel depth supported
     * by the display driver (8BPP), and is divisible by all the supported
     * pixel depths. Get the depth-specific values for the pixel depth we
     * are using.
     *
     * True 24BPP acceleration is not available, so 24BPP is actually
     * handled as an 8BPP engine mode with a width 3 times the display
     * width.
     */
    switch(Query->q_pix_depth)
        {
        case 4:
            ColourMask = 0x0000000F;
            Width = BLOCK_WRITE_LENGTH*8;
            ScreenPitch = Query->q_screen_pitch / 8;
            PixelDepth = BIOS_DEPTH_4BPP;
            HorScissors = (Query->q_desire_x) << 16;
            break;

        case 8:
            ColourMask = 0x000000FF;
            Width = BLOCK_WRITE_LENGTH*4;
            ScreenPitch = Query->q_screen_pitch / 8;
            PixelDepth = BIOS_DEPTH_8BPP;
            HorScissors = (Query->q_desire_x) << 16;
            break;

        case 16:
            ColourMask = 0x0000FFFF;
            Width = BLOCK_WRITE_LENGTH*2;
            ScreenPitch = Query->q_screen_pitch / 8;
            PixelDepth = BIOS_DEPTH_16BPP_565;
            HorScissors = (Query->q_desire_x) << 16;
            break;

        case 24:
            ColourMask = 0x000000FF;
            Width = BLOCK_WRITE_LENGTH*4;
            ScreenPitch = (Query->q_screen_pitch * 3) / 8;
            PixelDepth = BIOS_DEPTH_8BPP;
            /*
             * Horizontal scissors are only valid in the range
             * -4096 to +4095. If the horizontal resolution
             * is high enough to put the scissor outside this
             * range, clamp the scissors to the maximum
             * permitted value.
             */
            HorScissors = Query->q_desire_x * 3;
            if (HorScissors > 4095)
                HorScissors = 4095;
            HorScissors <<= 16;
            break;

        case 32:
            ColourMask = 0xFFFFFFFF;
            Width = BLOCK_WRITE_LENGTH;
            ScreenPitch = Query->q_screen_pitch / 8;
            PixelDepth = BIOS_DEPTH_32BPP;
            HorScissors = (Query->q_desire_x) << 16;
            break;

        default:
            return FALSE;   /* Unsupported pixel depths */
        }

    /*
     * Get a pointer to the beginning of the framebuffer. If we
     * can't do this, assume block write is unavailable.
     */
    if ((FrameAddress = MapFramebuffer(phwDeviceExtension->PhysicalFrameAddress.LowPart,
                                       phwDeviceExtension->FrameLength)) == (PVOID) 0)
        {
        VideoDebugPrint((DEBUG_ERROR, "Couldn't map LFB - assuming no block write\n"));
        return FALSE;
        }


    /*
     * To use block write mode, the pixel widths for destination,
     * source, and host must be the same.
     */
    PixelDepth |= ((PixelDepth << 8) | (PixelDepth << 16));

    /*
     * Save the contents of the DST_OFF_PITCH register.
     */
    DstOffPitch = INPD(DST_OFF_PITCH);

    /*
     * Clear the block we will be testing.
     */
    CheckFIFOSpace_cx(ELEVEN_WORDS);
    OUTPD(DP_WRITE_MASK, 0xFFFFFFFF);
    OUTPD(DST_OFF_PITCH, ScreenPitch << 22);
    OUTPD(DST_CNTL, (DST_CNTL_XDir | DST_CNTL_YDir));
    OUTPD(DP_PIX_WIDTH, PixelDepth);
    OUTPD(DP_SRC, (DP_FRGD_SRC_FG | DP_BKGD_SRC_BG | DP_MONO_SRC_ONE));
    OUTPD(DP_MIX, ((MIX_FN_PAINT << 16) | MIX_FN_PAINT));
    OUTPD(DP_FRGD_CLR, 0);
    OUTPD(SC_LEFT_RIGHT, HorScissors);
    OUTPD(SC_TOP_BOTTOM, (Query->q_desire_y) << 16);
    OUTPD(DST_Y_X, 0);
    OUTPD(DST_HEIGHT_WIDTH, ((Width+excess) << 16) | 1);
    WaitForIdle_cx();

    /*
     * To test block write mode, try painting each of the alternating bit
     * patterns, then read the block back. If there is at least one
     * mismatch, then block write is not supported.
     */
    for (Colour = 0x55555555; Colour <= 0xAAAAAAAA; Colour += 0x55555555)
        {
        /*
         * Paint the block.
         */
        CheckFIFOSpace_cx(FIVE_WORDS);
        OUTPD(GEN_TEST_CNTL, (INPD(GEN_TEST_CNTL) | GEN_TEST_CNTL_BlkWrtEna));
        OUTPD(DP_MIX, ((MIX_FN_PAINT << 16) | MIX_FN_LEAVE_ALONE));
        OUTPD(DP_FRGD_CLR, (Colour & ColourMask));
        OUTPD(DST_Y_X, 0);
        OUTPD(DST_HEIGHT_WIDTH, (Width << 16) | 1);
        WaitForIdle_cx();

        /*
         * Check to see if the block was written properly. Mach 64 cards
         * can't do a screen to host blit, but we can read the test block
         * back through the aperture.
         */
        ReadPointer = FrameAddress;
        for (Column = 0; Column < BLOCK_WRITE_LENGTH; Column++)
            {
            if (VideoPortReadRegisterUlong(ReadPointer + Column) != Colour)
                {
                VideoDebugPrint((DEBUG_NORMAL, "*** No block write - bad pattern\n" ));
                RetVal = FALSE;
                break;
                }
            }

        /*
         * Check the next dword beyond the block.
         */
        if (VideoPortReadRegisterUlong(ReadPointer + BLOCK_WRITE_LENGTH) != 0)
            {
            VideoDebugPrint((DEBUG_NORMAL, "*** No block write - corruption\n" ));
            RetVal = FALSE;
            }
        }

    /*
     * If block write is unavailable, turn off the block write bit.
     */
    if (RetVal == FALSE)
        OUTPD(GEN_TEST_CNTL, (INPD(GEN_TEST_CNTL) & ~GEN_TEST_CNTL_BlkWrtEna));

    /*
     * Restore the contents of the DST_OFF_PITCH register.
     */
    OUTPD(DST_OFF_PITCH, DstOffPitch);

    /*
     * Free the pointer to the start of the framebuffer.
     */
    VideoPortFreeDeviceBase(phwDeviceExtension, FrameAddress);

    return RetVal;

#endif  /* Not Power PC */

}   /* BlockWriteAvail_cx() */



/***************************************************************************
 *
 * BOOL TextBanding_cx(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Test to see whether the current mode is susceptible to text
 *  banding. This function assumes that the card has been set to
 *  an accelerated mode.
 *
 * RETURN VALUE:
 *  TRUE if this mode is susceptible to text banding
 *  FALSE if it is immune to text banding
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL TextBanding_cx(struct query_structure *Query)
{
    DWORD ConfigChipId;

    ConfigChipId = INPD(CONFIG_CHIP_ID);

    /*
     * Text banding only occurs in 24BPP with the Mach 64
     * GX rev. E & rev. F ASICs.
     */
    if ((Query->q_pix_depth == 24) &&
        ((ConfigChipId == (CONFIG_CHIP_ID_GXRevE)) || (ConfigChipId == (CONFIG_CHIP_ID_GXRevF))))
        {
        return TRUE;
        }
    else
        {
        return FALSE;
        }

}   /* TextBanding_cx() */



/***************************************************************************
 *
 * PWSTR IdentifyMach64Asic(Query, AsicStringLength);
 *
 * struct query_structure *Query;   Query information for the card
 * PULONG AsicStringLength;         Length of ASIC identification string
 *
 * DESCRIPTION:
 *  Generate a string describing which Mach 64 ASIC is in use on
 *  this particular card.
 *
 * RETURN VALUE:
 *  Pointer to a string identifying which Mach 64 ASIC is present. The
 *  length of this string is returned in *AsicStringLength.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  FillInRegistry()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

PWSTR IdentifyMach64Asic(struct query_structure *Query, PULONG AsicStringLength)
{
    PWSTR ChipString;       /* Identification string for the ASIC in use */
    DWORD ConfigChipId;     /* Contents of chip identification register */

    ConfigChipId = INPD(CONFIG_CHIP_ID);
    if (Query->q_DAC_type == DAC_INTERNAL_CT)
        {
        ChipString = L"Mach 64 CT";
        *AsicStringLength = sizeof(L"Mach 64 CT");
        }
    else if (Query->q_DAC_type == DAC_INTERNAL_GT)
        {
        ChipString        = L"ATI 3D RAGE (GT-A)";
        *AsicStringLength = sizeof(L"ATI 3D RAGE (GT-A)");
        }
    else if (Query->q_DAC_type == DAC_INTERNAL_VT)
        {    switch (ConfigChipId & CONFIG_CHIP_ID_RevMask)
            {
                case ASIC_ID_SGS_VT_A4:

                    ChipString        = L"ATI mach64 (SGS VT-A4)";
                    *AsicStringLength = sizeof(L"ATI mach64 (SGS VT-A4)");
                    break;

                case ASIC_ID_NEC_VT_A4:

                    ChipString        = L"ATI mach64 (NEC VT-A4)";
                    *AsicStringLength = sizeof(L"ATI mach64 (NEC VT-A4)");
                    break;

                case ASIC_ID_NEC_VT_A3:

                    ChipString        = L"ATI mach64 (NEC VT-A3)";
                    *AsicStringLength = sizeof(L"ATI mach64 (NEC VT-A3)");
                    break;

                default:

        ChipString        = L"ATI 3D RAGE (VT-A) Internal DAC";
        *AsicStringLength = sizeof(L"ATI 3D RAGE (VT-A) Internal DAC");
                    //ChipString        = L"ATI mach64 (VT-A)";
                    //*AsicStringLength = sizeof(L"ATI mach64 (VT-A)");
                    break;
            }
        }
    else if ((ConfigChipId & CONFIG_CHIP_ID_TypeMask) == CONFIG_CHIP_ID_TypeCX)
        {
        ChipString = L"Mach 64 CX";
        *AsicStringLength = sizeof(L"Mach 64 CX");
        }
    else if ((ConfigChipId & CONFIG_CHIP_ID_TypeMask) == CONFIG_CHIP_ID_TypeGX)
        {
        switch(ConfigChipId & CONFIG_CHIP_ID_RevMask)
            {
            case CONFIG_CHIP_ID_RevC:
                ChipString = L"Mach 64 GX Rev. C";
                *AsicStringLength = sizeof(L"Mach 64 GX Rev. C");
                break;

            case CONFIG_CHIP_ID_RevD:
                ChipString = L"Mach 64 GX Rev. D";
                *AsicStringLength = sizeof(L"Mach 64 GX Rev. D");
                break;

            case CONFIG_CHIP_ID_RevE:
                ChipString = L"Mach 64 GX Rev. E";
                *AsicStringLength = sizeof(L"Mach 64 GX Rev. E");
                break;

            case CONFIG_CHIP_ID_RevF:
                ChipString = L"Mach 64 GX Rev. F";
                *AsicStringLength = sizeof(L"Mach 64 GX Rev. F");
                break;

            default:
                ChipString = L"Mach 64 GX";
                *AsicStringLength = sizeof(L"Mach 64 GX");
                break;
            }
        }
    else
        {
        ChipString = L"Miscellaneous Mach 64";
        *AsicStringLength = sizeof(L"Miscelaneous Mach 64");
        }

    return ChipString;

}   /* IdentifyMach64Asic() */



/***************************************************************************
 *
 * void CleanupQuery(CapBuffer, SupBuffer, MappedBuffer, BufferSeg, SavedScreen);
 *
 * PUCHAR CapBuffer;        Pointer to the main capabilities table
 *                          for the card
 * PUCHAR SupBuffer;        Pointer to the supplementary capabilities
 *                          table for the card
 * PUCHAR MappedBuffer;     Pointer to the buffer used to query the
 *                          card's capabilities
 * long BufferSeg;          Physical segment associated with MappedBuffer
 * PUCHAR SavedScreen;      Buffer containing data to be restored to the
 *                          memory region used to store the query data.
 *                          Depending on the buffer used, this data may
 *                          or may not need to be restored.
 *
 * DESCRIPTION:
 *  Clean up after we have finished querying the card by restoring
 *  the VGA screen if needed, then freeing the buffers we used to query
 *  the card. We only need to restore the VGA screen if we used the
 *  graphics screen (either write back the information we saved if we
 *  used the existing screen, or switch into text mode if we had to
 *  switch into graphics mode) since we use the offscreen portion of
 *  video memory in cases where we use the text screen.
 *
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  QueryMach64()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static void CleanupQuery(PUCHAR CapBuffer, PUCHAR SupBuffer, PUCHAR MappedBuffer, long BufferSeg, PUCHAR SavedScreen)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    ULONG CurrentByte;                  /* Buffer byte being restored */
    ULONG BytesToRestore;               /* Number of bytes of graphics screen to restore */

    /*
     * BufferSeg will be 0xBA00 if we stored our query information on
     * the VGA colour text screen, 0xB200 if we used the VGA mono text
     * screen, 0xA000 if we switched into accelerator mode withoug
     * disturbing the VGA controller, and 0xA100 if we forced a VGA
     * graphics mode in order to use the VGA graphics screen.
     *
     * Since we use the offscreen portion of the text screens, which
     * leaves the information displayed on boot undisturbed, it is not
     * only unnecessary but also undesirable (since this would destroy pre-
     * query information printed to the blue screen) to change modes.
     * If we used the existing graphics screen, we merely need to restore
     * the screen contents and the registers we changed. If we changed
     * into a graphics mode, the pre-query information has already been
     * lost when changed modes, but switching back to text mode should
     * allow the user to see information that is printed after our query
     * is complete (not guarranteed, since we will only need to do this
     * on extremely ill-behaved systems, which may have been using something
     * other than a standard VGA text screen as the blue screen).
     */
    if (BufferSeg == 0xA000)
        {
        BytesToRestore = SavedScreen[VGA_SAVE_SIZE_H];
        BytesToRestore <<= 8;
        BytesToRestore += SavedScreen[VGA_SAVE_SIZE];
        VideoDebugPrint((DEBUG_NORMAL, "Restoring %d bytes of the VGA graphics screen\n", BytesToRestore));
        for (CurrentByte = 0; CurrentByte < BytesToRestore; CurrentByte++)
            {
            VideoPortWriteRegisterUchar(&(MappedBuffer[CurrentByte]), SavedScreen[CurrentByte]);
            }
            OUTP(VGA_SEQ_IND, 2);
            OUTP(VGA_SEQ_DATA, SavedScreen[VGA_SAVE_SEQ02]);
            OUTP(VGA_GRAX_IND, 8);
            OUTP(VGA_GRAX_DATA, SavedScreen[VGA_SAVE_GRA08]);
            OUTP(VGA_GRAX_IND, 1);
            OUTP(VGA_GRAX_DATA, SavedScreen[VGA_SAVE_GRA01]);
        }
    else if (BufferSeg == 0xA100)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Switching back to VGA text mode\n"));
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = 3;
        VideoPortInt10(phwDeviceExtension, &Registers);
        }

    /*
     * For each of the three buffers, free it if it exists.
     */
    if (CapBuffer != 0)
        VideoPortFreeDeviceBase(phwDeviceExtension, CapBuffer);

    if (SupBuffer != 0)
        VideoPortFreeDeviceBase(phwDeviceExtension, SupBuffer);

    if (MappedBuffer != 0)
        VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);

    return;

}   /* CleanupQuery() */



#if defined(ALPHA)
/***************************************************************************
 *
 * BOOL DenseOnAlpha(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Reports whether or not we can use dense space on this card
 *  in a DEC Alpha.
 *
 * RETURN VALUE:
 *  TRUE if this card can use dense space
 *  FALSE if it can't
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  Any routine after the query structure is filled in.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL DenseOnAlpha(struct query_structure *Query)
{
    /*
     * Some older Alpha machines are unable to support dense space,
     * so these must be mapped as sparse. The easiest way to distinguish
     * dense-capable from older machines is that all PCI Alpha systems
     * are dense-capable, so if we are dealing with a PCI card the
     * machine must be capable of handling dense space.
     *
     * Our older cards will generate drawing bugs if GDI handles
     * the screen in dense mode (we made different assumptions from
     * DEC about the PCI interface), so only use dense space for
     * cards which will not have this problem.
     */
    if ((Query->q_bus_type == BUS_PCI) &&
        ((Query->q_DAC_type == DAC_INTERNAL_CT) ||
         (Query->q_DAC_type == DAC_INTERNAL_GT) ||
         (Query->q_DAC_type == DAC_INTERNAL_VT)))
        return TRUE;
    else
        return FALSE;

}   /* DenseOnAlpha() */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\query_m.h ===
/************************************************************************/
/*                                                                      */
/*                              QUERY_M.H                               */
/*                                                                      */
/*       Sept 07  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.4  $
      $Date:   30 Jun 1994 18:20:40  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/query_m.h  $
 * 
 *    Rev 1.4   30 Jun 1994 18:20:40   RWOLFF
 * Removed prototype for IsApertureConflict_m() (routine moved to SETUP_M.C).
 * 
 *    Rev 1.3   27 Apr 1994 13:54:02   RWOLFF
 * Added prototype for IsMioBug_m()
 * 
 *    Rev 1.2   03 Mar 1994 12:41:16   ASHANMUG
 * Remove some get memory need stuff
 * 
 *    Rev 1.4   14 Jan 1994 15:25:58   RWOLFF
 * Added prototype for BlockWriteAvail_m()
 * 
 *    Rev 1.3   30 Nov 1993 18:29:04   RWOLFF
 * Removed defined values which were no longer used.
 * 
 *    Rev 1.2   10 Nov 1993 19:22:46   RWOLFF
 * Added definitions used by new way of checking memory size.
 * 
 *    Rev 1.1   08 Oct 1993 11:15:20   RWOLFF
 * Added prototype for new function.
 * 
 *    Rev 1.0   24 Sep 1993 11:52:50   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
QUERY_M.H - Header file for QUERY_M.C

#endif


/*
 * Prototypes for functions provided by QUERY_M.C
 */
extern VP_STATUS    QueryMach32 (struct query_structure *, BOOL);
extern VP_STATUS    Query8514Ultra (struct query_structure *);
extern VP_STATUS    QueryGUltra (struct query_structure *);
extern long         GetMemoryNeeded_m(long XPixels,
                                      long YPixels,
                                      long ColourDepth,
                                      struct query_structure *QueryPtr);
extern BOOL         BlockWriteAvail_m(struct query_structure *);
extern BOOL         IsMioBug_m(struct query_structure *);


#ifdef INCLUDE_QUERY_M
/*
 * Private definitions used in QUERY_M.C
 */
#define SETUP_ENGINE    0
#define RESTORE_ENGINE  1

/*
 * Bit pattern which is extremely unlikely to show up when reading
 * from nonexistant memory (which normally shows up as either all
 * bits set or all bits clear).
 */
#define TEST_COLOUR     0x05AA5

#endif  /* defined INCLUDE_QUERY_M */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\setup_cx.h ===
/************************************************************************/
/*                                                                      */
/*                              SETUP_CX.H                              */
/*                                                                      */
/*        Aug 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.17  $
      $Date:   15 Apr 1996 13:52:36  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/setup_cx.h_v  $
 * 
 *    Rev 1.17   15 Apr 1996 13:52:36   RWolff
 * Fallback to claiming 32k of BIOS if we can't get the full 64k, to avoid
 * conflict with Adaptec 154x adapters with their BIOS segment set to
 * 0xC800:0000 or 0xCC00:0000
 * 
 *    Rev 1.16   10 Apr 1996 17:04:48   RWolff
 * Now claims our BIOS segment in order to allow access to our hardware
 * capability table in the BIOS on P6 Alder machines.
 * 
 *    Rev 1.15   01 Mar 1996 12:12:34   RWolff
 * VGA Graphics Index and Graphics Data are now handled as separate
 * registers rather than as offsets into the block of VGA registers.
 * 
 *    Rev 1.14   29 Jan 1996 17:03:12   RWolff
 * Replaced list of device IDs for Mach 64 cards with list of device IDs
 * for non-Mach 64 cards.
 * 
 *    Rev 1.13   23 Jan 1996 17:53:04   RWolff
 * Added GT to list of Mach 64 cards capable of supporting block I/O.
 * 
 *    Rev 1.12   23 Jan 1996 11:51:24   RWolff
 * Removed conditionally-compiled code to use VideoPortGetAccessRanges()
 * to find block I/O cards, since this function remaps the I/O base
 * address and this is incompatible with the use of INT 10.
 * 
 *    Rev 1.11   12 Jan 1996 11:19:12   RWolff
 * ASIC type definitions used in workaround for VideoPortGetBaseAddress()
 * not working are now conditionally compiled.
 * 
 *    Rev 1.10   23 Nov 1995 11:35:12   RWolff
 * Temporary fixes to allow detection of block-relocatable GX-F2s until
 * Microsoft fixes VideoPortGetAccessRanges().
 * 
 *    Rev 1.9   24 Aug 1995 15:40:46   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 * 
 *    Rev 1.8   27 Feb 1995 17:47:32   RWOLFF
 * Added prototype for new routine IsPackedIO_cx().
 * 
 *    Rev 1.7   24 Feb 1995 12:28:04   RWOLFF
 * Added support for relocatable I/O
 * 
 *    Rev 1.6   04 Jan 1995 13:23:36   RWOLFF
 * Locked out two memory-mapped registers that were causing problems
 * on some platforms.
 * 
 *    Rev 1.5   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.4   18 Nov 1994 11:55:02   RWOLFF
 * Prototype for new routine, renamed register to CLOCK_CNTL to match latest
 * documentation, restricted this register to I/O operation only, since it
 * isn't reliable in memory mapped form.
 * 
 *    Rev 1.3   31 Aug 1994 16:31:20   RWOLFF
 * No longer claims VGA_SLEEP register, which we didn't access and which
 * conflicted with DigiBoard.
 * 
 *    Rev 1.3   31 Aug 1994 16:30:36   RWOLFF
 * No longer claims VGA_SLEEP register, which we didn't access and which
 * conflicted with DigiBoard.
 * 
 *    Rev 1.2   20 Jul 1994 12:58:38   RWOLFF
 * Added support for multiple I/O base addresses for accelerator registers.
 * 
 *    Rev 1.1   30 Jun 1994 18:16:08   RWOLFF
 * Added prototype and definitions for IsApertureConflict_cx() (moved from
 * QUERY_CX.C).
 * 
 *    Rev 1.0   31 Jan 1994 11:48:44   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.0   05 Nov 1993 13:37:06   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SETUP_CX.H - Header file for SETUP_CX.C

#endif

/*
 * Prototypes for functions supplied by SETUP_CX.C
 */
extern VP_STATUS CompatIORangesUsable_cx(INTERFACE_TYPE SystemBus);
extern VP_STATUS CompatMMRangesUsable_cx(void);
extern int WaitForIdle_cx(void);
extern void CheckFIFOSpace_cx(WORD SpaceNeeded);
extern BOOL IsApertureConflict_cx(struct query_structure *QueryPtr);
extern USHORT GetIOBase_cx(void);
extern BOOL IsPackedIO_cx(void);


/*
 * Definitions and global variables used in searching for
 * block I/O relocatable cards.
 */
#define ATI_MAX_BLOCK_CARDS 16  /* AH values A0 through AF for INT 10 */

extern UCHAR LookForAnotherCard;



/*
 * Definitions used internally by SETUP_CX.C
 */
#ifdef INCLUDE_SETUP_CX


/*
 * Avoid runtime bugs due to overflowing the address range arrays
 * in the HW_DEVICE_EXTENSION structure.
 *
 * If more address ranges are added without increasing
 * NUM_DRIVER_ACCESS_RANGES, we will get a compile-time error because
 * too many entries in DriverIORange[] will be initialized. If
 * NUM_DRIVER_ACCESS_RANGES is increased beyond the size of
 * the arrays in the HW_DEVICE_EXTENSION structure, the "#if"
 * statement will generate a compile-time error.
 *
 * We can't use an implicit size on DriverIORange[] and define
 * NUM_DRIVER_ACCESS_RANGES as sizeof(DriverIORange)/sizeof(VIDEO_ACCESS_RANGE)
 * because the expression in a #if statement can't use the
 * sizeof() operator.
 */
#define NUM_DRIVER_ACCESS_RANGES    107

/*
 * Indicate whether the specified address range is in I/O space or
 * memory mapped space. These values are intended to make it easier
 * to read the Driver??Range[] structures.
 */
#define ISinIO          TRUE           
#define ISinMEMORY      FALSE

/*
 * Indicate that this register is not available in the current (either
 * I/O or memory mapped) form.
 */
#define DONT_USE -1

/*
 * Definitions and arrays to allow accelerator registers with variable
 * bases to be built in DriverIORange_cx[]. Definitions mark the first
 * accelerator register in the array (VGA registers have a fixed base),
 * and the number of registers to loop through while building the
 * accelerator registers. The arrays contain the variable portions
 * of the registers in the order they appear in DriverIORange_cx[],
 * and the base addresses.
 */
#define FIRST_REG_TO_BUILD  8
#define NUM_REGS_TO_BUILD   30

USHORT VariableRegisterBases[NUM_BASE_ADDRESSES] = {
    M64_STD_BASE_ADDR,
    M64_ALT_BASE_ADDR_1,
    M64_ALT_BASE_ADDR_2
};

USHORT VariableRegisterOffsets[NUM_REGS_TO_BUILD] = {
    IO_CRTC_H_TOTAL_DISP,
    IO_CRTC_H_SYNC_STRT_WID,
    IO_CRTC_V_TOTAL_DISP,
    IO_CRTC_V_SYNC_STRT_WID,
    IO_CRTC_CRNT_VLINE,

    IO_CRTC_OFF_PITCH,
    IO_CRTC_INT_CNTL,
    IO_CRTC_GEN_CNTL,
    IO_OVR_CLR,
    IO_OVR_WID_LEFT_RIGHT,

    IO_OVR_WID_TOP_BOTTOM,
    IO_CUR_CLR0,
    IO_CUR_CLR1,
    IO_CUR_OFFSET,
    IO_CUR_HORZ_VERT_POSN,

    IO_CUR_HORZ_VERT_OFF,
    IO_SCRATCH_REG0,
    IO_SCRATCH_REG1,
    IO_CLOCK_CNTL,
    IO_BUS_CNTL,

    IO_MEM_CNTL,
    IO_MEM_VGA_WP_SEL,
    IO_MEM_VGA_RP_SEL,
    IO_DAC_REGS,
    IO_DAC_CNTL,

    IO_GEN_TEST_CNTL,
    IO_CONFIG_CNTL,
    IO_CONFIG_CHIP_ID,
    IO_CONFIG_STAT0,
    IO_CONFIG_STAT1
};

/*
 * For cards with relocatable I/O, the I/O registers
 * are in a dense block, with each register at the
 * same DWORD index into the block as it is into the
 * block of memory mapped registers.
 */
USHORT RelocatableRegisterOffsets[NUM_REGS_TO_BUILD] = {
    MM_CRTC_H_TOTAL_DISP,
    MM_CRTC_H_SYNC_STRT_WID,
    MM_CRTC_V_TOTAL_DISP,
    MM_CRTC_V_SYNC_STRT_WID,
    MM_CRTC_CRNT_VLINE,

    MM_CRTC_OFF_PITCH,
    MM_CRTC_INT_CNTL,
    MM_CRTC_GEN_CNTL,
    MM_OVR_CLR,
    MM_OVR_WID_LEFT_RIGHT,

    MM_OVR_WID_TOP_BOTTOM,
    MM_CUR_CLR0,
    MM_CUR_CLR1,
    MM_CUR_OFFSET,
    MM_CUR_HORZ_VERT_POSN,

    MM_CUR_HORZ_VERT_OFF,
    MM_SCRATCH_REG0,
    MM_SCRATCH_REG1,
    MM_CLOCK_CNTL,
    MM_BUS_CNTL,

    MM_MEM_CNTL,
    MM_MEM_VGA_WP_SEL,
    MM_MEM_VGA_RP_SEL,
    MM_DAC_REGS,
    MM_DAC_CNTL,

    MM_GEN_TEST_CNTL,
    MM_CONFIG_CNTL,
    MM_CONFIG_CHIP_ID,
    MM_CONFIG_STAT0,
    MM_CONFIG_STAT1
};

/*
 * Number of registers which exist in I/O mapped form. When we claim the
 * VGA and linear apertures, we will temporarily park their address
 * ranges immediately after the I/O mapped registers.
 */
#define NUM_IO_REGISTERS    38
#define VGA_APERTURE_ENTRY  NUM_IO_REGISTERS
#define LFB_ENTRY           1   /* Offset into DriverApertureRange_cx[] */

/*
 * Size of BIOS block to claim. On some machines, we must claim the
 * region occupied by our video BIOS in order to be able to detect
 * a Mach 64, but if we claim the full 64k when we have only a 32k
 * BIOS (Mach 64 cards are available with both 32k and 64k BIOSes)
 * and the driver for a SCSI card with its BIOS segment in the second
 * 32k claims its BIOS segment, we will be rejected.
 */
#define CLAIM_64k_BIOS      0
#define CLAIM_32k_BIOS      1
#define CLAIM_APERTURE_ONLY 2
#define NUM_CLAIM_SIZES     3

ULONG VgaResourceSize[NUM_CLAIM_SIZES] =
{
    0x30000,        /* Text and graphics screens, and 64k BIOS area */
    0x28000,        /* Text and graphics screens, and 32k BIOS area */
    0x20000         /* Text and graphics screens only */
};

/*
 * Memory ranges we need to claim. The first is the VGA aperture, which
 * is always at a fixed location. The second is the linear framebuffer,
 * which we don't yet know where or how big it is. This information
 * will be filled in when we get it.
 *
 * In the VGA aperture, we must claim the graphics screen (A0000-AFFFF)
 * since this is used as the paged aperture, the text screens (B0000-B7FFF
 * and B8000-BFFFF) since the memory-mapped registers are here when we
 * use the paged aperture, and we use off-screen memory here to store our
 * query information, and the video BIOS (C0000-CFFFF) since we must
 * retrieve some information (signature string, table of maximum pixel
 * clock frequency for each resolution/refresh pair) from this region.
 * Since these areas are contiguous, and we do not need exclusive access
 * to any of them, claim them as a single block.
 */
VIDEO_ACCESS_RANGE DriverApertureRange_cx[2] = {
    {0xA0000,   0,  0,          ISinMEMORY, TRUE,   TRUE},
    {0,         0,  0,          ISinMEMORY, TRUE,   FALSE}
};


/*
 * Structure list is address, 0 or "not available" flag, length,
 * inIOspace, visible, shareable. This order matches the enumeration
 * in AMACHCX.H.
 *
 * VGAWonder-compatible I/O ranges come first in no particular order,
 * followed by the coprocessor registers in increasing order of I/O and
 * memory mapped addresses. This order was chosen because all the VGA
 * addresses are I/O mapped, as are the non-GUI coprocessor registers,
 * while the GUI coprocessor registers are only available as memory mapped.
 *
 * Since all the I/O mapped registers are in a block at the beginning of
 * the structure, we can feed VideoPortVerifyAccessRanges() a truncated
 * version of the structure (all I/O mapped registers, but none that are
 * only available as memory-mapped) to claim the I/O address space we need.
 *
 * The I/O addresses shown for accelerator registers are for reference only,
 * to show which register goes in which location. The actual register
 * value will be built "on the fly", since these registers have variable
 * base addresses.
 */
VIDEO_ACCESS_RANGE DriverIORange_cx[NUM_DRIVER_ACCESS_RANGES] = {
    {IO_VGA_BASE_IO_PORT        , 0         , IO_VGA_START_BREAK_PORT - IO_VGA_BASE_IO_PORT + 1, ISinIO, TRUE, TRUE},
    {IO_VGA_END_BREAK_PORT      , 0         , IO_VGA_MAX_IO_PORT    - IO_VGA_END_BREAK_PORT + 1, ISinIO, TRUE, TRUE},
    {IO_VGA_SEQ_IND             , 0         , 2, ISinIO, TRUE   , TRUE},
    {IO_VGA_SEQ_DATA            , 0         , 1, ISinIO, TRUE   , TRUE},
    {IO_VGA_GRAX_IND            , 0         , 2, ISinIO, TRUE   , TRUE},

    {IO_VGA_GRAX_DATA           , 0         , 1, ISinIO, TRUE   , TRUE},
    {IO_reg1CE                  , 0         , 2, ISinIO, TRUE   , TRUE},
    {IO_reg1CF                  , 0         , 1, ISinIO, TRUE   , TRUE},
    {IO_CRTC_H_TOTAL_DISP       , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CRTC_H_SYNC_STRT_WID    , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_CRTC_V_TOTAL_DISP       , 0         , 4, ISinIO, TRUE   , FALSE},   // 10
    {IO_CRTC_V_SYNC_STRT_WID    , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CRTC_CRNT_VLINE         , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CRTC_OFF_PITCH          , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CRTC_INT_CNTL           , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_CRTC_GEN_CNTL           , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_OVR_CLR                 , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_OVR_WID_LEFT_RIGHT      , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_OVR_WID_TOP_BOTTOM      , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CUR_CLR0                , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_CUR_CLR1                , 0         , 4, ISinIO, TRUE   , FALSE},   // 20
    {IO_CUR_OFFSET              , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CUR_HORZ_VERT_POSN      , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CUR_HORZ_VERT_OFF       , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_SCRATCH_REG0            , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_SCRATCH_REG1            , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CLOCK_CNTL              , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_BUS_CNTL                , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_MEM_CNTL                , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_MEM_VGA_WP_SEL          , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_MEM_VGA_RP_SEL          , 0         , 4, ISinIO, TRUE   , FALSE},   // 30
    {IO_DAC_REGS                , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_DAC_CNTL                , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_GEN_TEST_CNTL           , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CONFIG_CNTL             , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_CONFIG_CHIP_ID          , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CONFIG_STAT0            , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CONFIG_STAT1            , 0         , 4, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 40
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 50
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 60
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 70
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 80
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 90
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 100
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE}
    };

#if NUM_DRIVER_ACCESS_RANGES > NUM_ADDRESS_RANGES_ALLOWED
    Insufficient address ranges for 68800CX-compatible graphics cards.
#endif

#define DONT_USE -1     /* Shows that this register is not memory mapped */

/*
 * Structure list is address, 0 or "not available" flag, length,
 * inIOspace, visible, shareable. This order matches the enumeration
 * in AMACHCX.H.
 *
 * The registers in this structure are in the same order as in
 * DriverIORange_cx[], except here we are defining memory mapped
 * registers instead of I/O mapped registers.
 *
 * Some registers are grouped to allow block writes larger than
 * the 32 bit register size. To allow this, let Windows NT think
 * that the size of this register is actually the total size (in
 * bytes) of all remaining registers in the group.
 */
VIDEO_ACCESS_RANGE DriverMMRange_cx[NUM_DRIVER_ACCESS_RANGES] = {
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},

    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_H_TOTAL_DISP       , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_H_SYNC_STRT_WID    , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_CRTC_V_TOTAL_DISP       , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 10
    {MM_CRTC_V_SYNC_STRT_WID    , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_CRNT_VLINE         , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_OFF_PITCH          , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_INT_CNTL           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_CRTC_GEN_CNTL           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_OVR_CLR                 , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_OVR_WID_LEFT_RIGHT      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_OVR_WID_TOP_BOTTOM      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CUR_CLR0                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_CUR_CLR1                , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 20
    {MM_CUR_OFFSET              , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CUR_HORZ_VERT_POSN      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CUR_HORZ_VERT_OFF       , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SCRATCH_REG0            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SCRATCH_REG1            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {MM_BUS_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_MEM_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_MEM_VGA_WP_SEL          , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_MEM_VGA_RP_SEL          , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 30
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {MM_GEN_TEST_CNTL           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},

    {MM_CONFIG_CHIP_ID          , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONFIG_STAT0            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONFIG_STAT1            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_OFF_PITCH           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_X                   , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_DST_Y                   , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 40
    {MM_DST_Y_X                 , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_WIDTH               , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_HEIGHT              , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_HEIGHT_WIDTH        , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_DST_X_WIDTH             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_BRES_LNTH           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_BRES_ERR            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_BRES_INC            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_BRES_DEC            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_DST_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 50
    {MM_SRC_OFF_PITCH           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_X                   , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_Y                   , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_Y_X                 , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SRC_WIDTH1              , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_HEIGHT1             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_HEIGHT1_WIDTH1      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_X_START             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_Y_START             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SRC_Y_X_START           , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 60
    {MM_SRC_WIDTH2              , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_HEIGHT2             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_HEIGHT2_WIDTH2      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_HOST_DATA0              , 0         ,64, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA1              , 0         ,60, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA2              , 0         ,56, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA3              , 0         ,52, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA4              , 0         ,48, ISinMEMORY,    TRUE,   FALSE},

    {MM_HOST_DATA5              , 0         ,44, ISinMEMORY,    TRUE,   FALSE}, // 70
    {MM_HOST_DATA6              , 0         ,40, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA7              , 0         ,36, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA8              , 0         ,32, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA9              , 0         ,28, ISinMEMORY,    TRUE,   FALSE},

    {MM_HOST_DATA10             , 0         ,24, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA11             , 0         ,20, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA12             , 0         ,16, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA13             , 0         ,12, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA14             , 0         , 8, ISinMEMORY,    TRUE,   FALSE},

    {MM_HOST_DATA15             , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 80
    {MM_HOST_CNTL               , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_PAT_REG0                , 0         , 8, ISinMEMORY,    TRUE,   FALSE},
    {MM_PAT_REG1                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_PAT_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SC_LEFT                 , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SC_RIGHT                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SC_LEFT_RIGHT           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SC_TOP                  , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SC_BOTTOM               , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SC_TOP_BOTTOM           , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 90
    {MM_DP_BKGD_CLR             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_FRGD_CLR             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_WRITE_MASK           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_CHAIN_MASK           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_DP_PIX_WIDTH            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_MIX                  , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_SRC                  , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CLR_CMP_CLR             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CLR_CMP_MSK             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_CLR_CMP_CNTL            , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 100
    {MM_FIFO_STAT               , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONTEXT_MASK            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONTEXT_SAVE_CNTL       , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONTEXT_LOAD_CNTL       , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_GUI_TRAJ_CNTL           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_GUI_STAT                , 0         , 4, ISinMEMORY,    TRUE,   FALSE}
    };


/*
 * Device IDs for PCI configuration registers. Only non-Mach 64
 * IDs are listed here, since future IDs will (for the forseeable
 * future) almost certainly be Mach 64 cards, so we can assume
 * that any ID we haven't rejected is a Mach 64, which we should
 * accept.
 *
 * Currently, the Mach 32 AX is our only PCI card which is not
 * a Mach 64.
 */
#define ATI_DEVID_M32AX 0x4158


#endif  /* defined INCLUDE_SETUP_CX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\services.c ===
/************************************************************************/
/*                                                                      */
/*                              SERVICES.C                              */
/*                                                                      */
/*        Aug 26  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.33  $
      $Date:   15 Apr 1996 16:59:44  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/services.c_v  $
 * 
 *    Rev 1.33   15 Apr 1996 16:59:44   RWolff
 * Now calls new routine to report which flavour of the Mach 64 is
 * in use, rather than reporting "Mach 64" for all ASIC types.
 * 
 *    Rev 1.32   12 Apr 1996 16:18:16   RWolff
 * Now rejects 24BPP modes if linear aperture is not present, since new
 * source stream display driver can't do 24BPP in a paged aperture. This
 * rejection should be done in the display driver (the card still supports
 * the mode, but the display driver doesn't want to handle it), but at
 * the point where the display driver must decide to either accept or reject
 * modes, it doesn't have access to the aperture information.
 * 
 *    Rev 1.31   10 Apr 1996 17:05:28   RWolff
 * Made routine delay() nonpageable.
 * 
 *    Rev 1.30   01 Mar 1996 12:16:38   RWolff
 * Fix for DEC Alpha under NT 4.0: memory-mapped register access is
 * via direct pointer read/write in dense space and via VideoPort
 * routines in sparse space (VideoPort routines no longer work in
 * dense space - this is a HAL bug).
 * 
 *    Rev 1.29   09 Feb 1996 13:27:36   RWolff
 * Now reports only accelerator memory to display applet for Mach 8 combo
 * cards.
 * 
 *    Rev 1.28   02 Feb 1996 17:20:10   RWolff
 * DDC/VDIF merge source information is now stored in hardware device
 * extension rather than static variables, added DEC's workaround to
 * Lio[Inp|Outp]([w|d])() routines for NT 4.0 memory mapped register
 * access, added routine GetVgaBuffer() to (nondestructively) obtain
 * a buffer in physical memory below 1M.
 * 
 *    Rev 1.27   23 Jan 1996 11:49:20   RWolff
 * Added debug print statements.
 * 
 *    Rev 1.26   11 Jan 1996 19:44:34   RWolff
 * SetFixedModes() now restricts modes based on pixel clock frequency.
 * 
 *    Rev 1.25   22 Dec 1995 14:54:30   RWolff
 * Added support for Mach 64 GT internal DAC, switched to TARGET_BUILD
 * to identify the NT version for which the driver is being built.
 * 
 *    Rev 1.24   21 Nov 1995 11:02:54   RWolff
 * Now reads DDC timing data rather than VDIF file if card and monitor
 * both support DDC.
 * 
 *    Rev 1.23   08 Sep 1995 16:35:52   RWolff
 * Added support for AT&T 408 DAC (STG1703 equivalent).
 * 
 *    Rev 1.22   28 Jul 1995 14:40:14   RWolff
 * Added support for the Mach 64 VT (CT equivalent with video overlay).
 * 
 *    Rev 1.21   26 Jul 1995 13:08:30   mgrubac
 * Moved mode tables merging from SetFixedModes to VDIFCallback()
 * routine.
 * 
 *    Rev 1.20   20 Jul 1995 18:00:26   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.19   02 Jun 1995 14:32:58   RWOLFF
 * Added routine UpperCase() to change string into upper case because
 * toupper() was coming back as unresolved external on some platforms.
 * 
 *    Rev 1.18   10 Apr 1995 17:05:06   RWOLFF
 * Made LioInpd() and LioOutpd() nonpageable, since they are called
 * (indirectly) by ATIMPResetHw(), which must be nonpageable.
 * 
 *    Rev 1.17   31 Mar 1995 11:53:14   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 * 
 *    Rev 1.16   08 Mar 1995 11:35:28   ASHANMUG
 * Modified return values to be correct
 * 
 *    Rev 1.15   30 Jan 1995 11:55:52   RWOLFF
 * Now reports presence of CT internal DAC.
 * 
 *    Rev 1.14   25 Jan 1995 14:08:24   RWOLFF
 * Fixed "ampersand is reserved character" bug in FillInRegistry() that
 * caused AT&T 49[123] and AT&T 498 to drop the ampersand and underline
 * the second T.
 * 
 *    Rev 1.13   18 Jan 1995 15:40:14   RWOLFF
 * Chrontel DAC now supported as separate type rather than being
 * lumped in with STG1702.
 * 
 *    Rev 1.12   11 Jan 1995 14:03:16   RWOLFF
 * Replaced VCS logfile comment that was accidentally deleted when
 * checking in the last revision.
 * 
 *    Rev 1.11   04 Jan 1995 13:22:06   RWOLFF
 * Removed dead code.
 * 
 *    Rev 1.10   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.9   18 Nov 1994 11:46:44   RWOLFF
 * GetSelector() now increases the size of the frequency "window" and checks
 * again, rather than giving up and taking the selector/divisor pair that
 * produces the highest freqency that does not exceed the target frequency,
 * if a match is not found on the first pass. Added support for split rasters.
 * 
 *    Rev 1.8   31 Aug 1994 16:28:56   RWOLFF
 * Now uses VideoPort[Read|Write]Register[Uchar|Ushort|Ulong]() instead
 * of direct memory writes for memory mapped registers under Daytona
 * (functions didn't work properly under NT retail), added support
 * for 1152x864 and 1600x1200.
 * 
 *    Rev 1.7   19 Aug 1994 17:14:50   RWOLFF
 * Added support for SC15026 DAC and non-standard pixel clock generators.
 * 
 *    Rev 1.6   20 Jul 1994 13:00:08   RWOLFF
 * Added routine FillInRegistry() which writes to new registry fields that
 * let the display applet know what chipset and DAC the graphics card is
 * using, along with the amount of video memory and the type of adapter.
 * 
 *    Rev 1.5   12 May 1994 11:20:06   RWOLFF
 * Added routine SetFixedModes() which adds predefined refresh rates
 * to list of mode tables.
 * 
 *    Rev 1.4   27 Apr 1994 13:51:30   RWOLFF
 * Now sets Mach 64 1280x1024 pitch to 2048 when disabling LFB.
 * 
 *    Rev 1.3   26 Apr 1994 12:35:58   RWOLFF
 * Added routine ISAPitchAdjust() which increases screen pitch to 1024
 * and removes mode tables for which there is no longer enough memory.
 * 
 *    Rev 1.2   14 Mar 1994 16:36:14   RWOLFF
 * Functions used by ATIMPResetHw() are not pageable.
 * 
 *    Rev 1.1   07 Feb 1994 14:13:44   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:20:16   RWOLFF
 * Initial revision.
        
           Rev 1.7   24 Jan 1994 18:10:38   RWOLFF
        Added routine TripleClock() which returns the selector/divisor pair that
        will produce the lowest clock frequency that is at least three times
        that produced by the input selector/divisor pair.
        
           Rev 1.6   14 Jan 1994 15:26:14   RWOLFF
        No longer prints message each time memory mapped registers
        are read or written.
        
           Rev 1.5   15 Dec 1993 15:31:46   RWOLFF
        Added routine used for SC15021 DAC at 24BPP and above.
        
           Rev 1.4   30 Nov 1993 18:29:38   RWOLFF
        Speeded up IsBufferBacked(), fixed LioOutpd()
        
           Rev 1.3   05 Nov 1993 13:27:02   RWOLFF
        Added routines to check whether a buffer is backed by physical memory,
        double pixel clock frequency, and get pixel clock frequency for a given
        selector/divisor pair.
        
           Rev 1.2   24 Sep 1993 11:46:06   RWOLFF
        Switched to direct memory writes instead of VideoPortWriteRegister<length>()
        calls which don't work properly.
        
           Rev 1.1   03 Sep 1993 14:24:40   RWOLFF
        Card-independent service routines.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SERVICES.C - Service routines required by the miniport.

DESCRIPTION
    This file contains routines which provide miscelaneous services
    used by the miniport. All routines in this module are independent
    of the type of ATI accelerator being used.

    To secure this independence, routines here may make calls to
    the operating system, or call routines from other modules
    which read or write registers on the graphics card, but must
    not make INP/OUTP calls directly.

OTHER FILES

#endif

#include "dderror.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#include "query_cx.h"
#define INCLUDE_SERVICES
#include "services.h"
#include "cvtvdif.h"
#include "cvtddc.h"


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, short_delay)
/* delay() can't be made pageable */
#pragma alloc_text(PAGE_COM, IsBufferBacked)
#pragma alloc_text(PAGE_COM, DoubleClock)
#pragma alloc_text(PAGE_COM, ThreeHalvesClock)
#pragma alloc_text(PAGE_COM, TripleClock)
#pragma alloc_text(PAGE_COM, GetFrequency)
#pragma alloc_text(PAGE_COM, GetSelector)
#pragma alloc_text(PAGE_COM, GetShiftedSelector)
#pragma alloc_text(PAGE_COM, ISAPitchAdjust)
#pragma alloc_text(PAGE_COM, SetFixedModes)
#pragma alloc_text(PAGE_COM, FillInRegistry)
#pragma alloc_text(PAGE_COM, MapFramebuffer)
#pragma alloc_text(PAGE_COM, Get_BIOS_Seg)
#pragma alloc_text(PAGE_COM, UpperCase)
#pragma alloc_text(PAGE_COM, GetVgaBuffer)
/* LioInp() can't be made pageable */
/* LioOutp() can't be made pageable */
/* LioInpw() can't be made pageable */
/* LioOutpw() can't be made pageable */
/* LioInpd() can't be made pageable */
/* LioOutpd() can't be made pageable */
#endif


/*
 * Static variables used by this module.
 */
static BYTE ati_signature[] = "761295520";



/*
 * void short_delay(void);
 *
 * Wait a minimum of 26 microseconds.
 */
void short_delay(void)
{
	VideoPortStallExecution (26);

    return;
}


/*
 * void delay(delay_time);
 *
 * int delay_time;      How many milliseconds to wait
 *
 * Wait for the specified amount of time to pass.
 */
void delay(int delay_time)
{
    unsigned long Counter;

    /*
     * This must NOT be done as a single call to
     * VideoPortStallExecution() with the parameter equal to the
     * total delay desired. According to the documentation for this
     * function, we're already pushing the limit in order to minimize
     * the effects of function call overhead.
     */
    for (Counter = 10*delay_time; Counter > 0; Counter--)
        VideoPortStallExecution (100);

    return;
}



/***************************************************************************
 *
 * BOOL IsBufferBacked(StartAddress, Size);
 *
 * PUCHAR StartAddress;     Pointer to the beginning of the buffer
 * ULONG Size;              Size of the buffer in bytes
 *
 * DESCRIPTION:
 *  Check to see whether the specified buffer is backed by physical
 *  memory.
 *
 * RETURN VALUE:
 *  TRUE if the buffer is backed by physical memory
 *  FALSE if the buffer contains a "hole" in physical memory
 *
 * GLOBALS CHANGED:
 *  None, but the contents of the buffer are overwritten.
 *
 * CALLED BY:
 *  This function may be called by any routine.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL IsBufferBacked(PUCHAR StartAddress, ULONG Size)
{
    ULONG Count;        /* Loop counter */
    ULONG NumDwords;    /* Number of doublewords filled by Size bytes */
    ULONG NumTailChars; /* Number of bytes in the last (partially-filled) DWORD) */
    PULONG TestAddress; /* Address to start doing DWORD testing */
    PUCHAR TailAddress; /* Address of the last (partially-filled) DWORD */

    /*
     * Fill the buffer with our test value. The value 0x5A is used because
     * it contains odd bits both set and clear, and even bits both set and
     * clear. Since nonexistent memory normally reads as either all bits set
     * or all bits clear, it is highly unlikely that we will read back this
     * value if there is no physical RAM.
     *
     * For performance reasons, check as much as possible of the buffer
     * in DWORDs, then only use byte-by-byte testing for that portion
     * of the buffer which partially fills a DWORD.
     */
    NumDwords = Size/(sizeof(ULONG)/sizeof(UCHAR));
    TestAddress = (PULONG) StartAddress;
    NumTailChars = Size%(sizeof(ULONG)/sizeof(UCHAR));
    TailAddress = StartAddress + NumDwords * (sizeof(ULONG)/sizeof(UCHAR));

    for (Count = 0; Count < NumDwords; Count++)
        {
        VideoPortWriteRegisterUlong(&(TestAddress[Count]), 0x5A5A5A5A);
        }

    if (NumTailChars != 0)
        {
        for (Count = 0; Count < NumTailChars; Count++)
            {
            VideoPortWriteRegisterUchar(&(TailAddress[Count]), (UCHAR)0x5A);
            }
        }

    /*
     * Read back the contents of the buffer. If we find even one byte that
     * does not contain our test value, then assume that the buffer is not
     * backed by physical memory.
     */
    for (Count = 0; Count < NumDwords; Count++)
        {
        if (VideoPortReadRegisterUlong(&(TestAddress[Count])) != 0x5A5A5A5A)
            {
            return FALSE;
            }
        }

    /*
     * If the buffer contains a partially filled DWORD at the end, check
     * the bytes in this DWORD.
     */
    if (NumTailChars != 0)
        {
        for (Count = 0; Count < NumTailChars; Count++)
            {
            if (VideoPortReadRegisterUchar(&(TailAddress[Count])) != 0x5A)
                {
                return FALSE;
                }
            }
        }

    /*
     * We were able to read back our test value from every byte in the
     * buffer, so we know it is backed by physical memory.
     */
    return TRUE;

}   /* IsBufferBacked() */



/***************************************************************************
 *
 * UCHAR DoubleClock(ClockSelector);
 *
 * UCHAR ClockSelector;    Initial clock selector
 *
 * DESCRIPTION:
 *  Find the clock selector and divisor pair which will produce the
 *  lowest clock frequency that is at least double that produced by
 *  the input selector/divisor pair (format 000DSSSS).
 *
 *  A divisor of 0 is treated as divide-by-1, while a divisor of 1
 *  is treated as divide-by-2.
 *
 * RETURN VALUE:
 *  Clock selector/devisor pair (format 000DSSSS) if an appropriate pair
 *  exists, 0x0FF if no such pair exists.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR DoubleClock(UCHAR ClockSelector)
{
    ULONG MinimumFreq;          /* Minimum acceptable pixel clock frequency */
    ULONG ThisFreq;             /* Current frequency being tested */
    ULONG BestFreq=0x0FFFFFFFF; /* Closest match to double the original frequency */
    UCHAR BestSelector=0x0FF;   /* Divisor/selector pair to produce BestFreq */
    short Selector;             /* Used to loop through the selector */
    short Divisor;              /* Used to loop through the divisor */

    /*
     * Easy way out: If the current pixel clock frequency is obtained by
     * dividing by 2, switch to divide-by-1.
     */
    if ((ClockSelector & DIVISOR_MASK) != 0)
        return (ClockSelector ^ DIVISOR_MASK);

    /*
     * Cycle through the selector/divisor pairs to get the closest
     * match to double the original frequency. We already know that
     * we are using a divide-by-1 clock, since divide-by-2 will have
     * been caught by the shortcut above.
     */
    MinimumFreq = ClockGenerator[ClockSelector & SELECTOR_MASK] * 2;
    for (Selector = 0; Selector < 16; Selector++)
        {
        for (Divisor = 0; Divisor <= 1; Divisor++)
            {
            ThisFreq = ClockGenerator[Selector] >> Divisor;

            /*
             * If the frequency being tested is at least equal
             * to double the original frequency and is closer
             * to the ideal (double the original) than the previous
             * "best", make it the new "best".
             */
            if ((ThisFreq >= MinimumFreq) && (ThisFreq < BestFreq))
                {
                BestFreq = ThisFreq;
                BestSelector = Selector | (Divisor << DIVISOR_SHIFT);
                }
            }
        }
    return BestSelector;

}   /* DoubleClock() */



/***************************************************************************
 *
 * UCHAR ThreeHalvesClock(ClockSelector);
 *
 * UCHAR ClockSelector;    Initial clock selector
 *
 * DESCRIPTION:
 *  Find the clock selector and divisor pair which will produce the
 *  lowest clock frequency that is at least 50% greater than that
 *  produced by the input selector/divisor pair (format 000DSSSS).
 *
 *  A divisor of 0 is treated as divide-by-1, while a divisor of 1
 *  is treated as divide-by-2.
 *
 * RETURN VALUE:
 *  Clock selector/devisor pair (format 000DSSSS) if an appropriate pair
 *  exists, 0x0FF if no such pair exists.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR ThreeHalvesClock(UCHAR ClockSelector)
{
    ULONG MinimumFreq;          /* Minimum acceptable pixel clock frequency */
    ULONG ThisFreq;             /* Current frequency being tested */
    ULONG BestFreq=0x0FFFFFFFF; /* Closest match to 1.5x the original frequency */
    UCHAR BestSelector=0x0FF;   /* Divisor/selector pair to produce BestFreq */
    short Selector;             /* Used to loop through the selector */
    short Divisor;              /* Used to loop through the divisor */

    /*
     * Cycle through the selector/divisor pairs to get the closest
     * match to 1.5 times the original frequency.
     */
    MinimumFreq = ClockGenerator[ClockSelector & SELECTOR_MASK];
    if (ClockSelector & DIVISOR_MASK)
        MinimumFreq /= 2;
    MinimumFreq *= 3;
    MinimumFreq /= 2;
    for (Selector = 0; Selector < 16; Selector++)
        {
        for (Divisor = 0; Divisor <= 1; Divisor++)
            {
            ThisFreq = ClockGenerator[Selector] >> Divisor;

            /*
             * If the frequency being tested is at least equal
             * to 1.5 times the original frequency and is closer
             * to the ideal (1.5 times the original) than the previous
             * "best", make it the new "best".
             */
            if ((ThisFreq >= MinimumFreq) && (ThisFreq < BestFreq))
                {
                BestFreq = ThisFreq;
                BestSelector = Selector | (Divisor << DIVISOR_SHIFT);
                }
            }
        }
    return BestSelector;

}   /* ThreeHalvesClock() */



/***************************************************************************
 *
 * UCHAR TripleClock(ClockSelector);
 *
 * UCHAR ClockSelector;    Initial clock selector
 *
 * DESCRIPTION:
 *  Find the clock selector and divisor pair which will produce the
 *  lowest clock frequency that is at least triple that produced by
 *  the input selector/divisor pair (format 000DSSSS).
 *
 *  A divisor of 0 is treated as divide-by-1, while a divisor of 1
 *  is treated as divide-by-2.
 *
 * RETURN VALUE:
 *  Clock selector/devisor pair (format 000DSSSS) if an appropriate pair
 *  exists, 0x0FF if no such pair exists.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR TripleClock(UCHAR ClockSelector)
{
    ULONG MinimumFreq;          /* Minimum acceptable pixel clock frequency */
    ULONG ThisFreq;             /* Current frequency being tested */
    ULONG BestFreq=0x0FFFFFFFF; /* Closest match to triple the original frequency */
    UCHAR BestSelector=0x0FF;   /* Divisor/selector pair to produce BestFreq */
    short Selector;             /* Used to loop through the selector */
    short Divisor;              /* Used to loop through the divisor */

    /*
     * Cycle through the selector/divisor pairs to get the closest
     * match to triple the original frequency.
     */
    MinimumFreq = ClockGenerator[ClockSelector & SELECTOR_MASK];
    if (ClockSelector & DIVISOR_MASK)
        MinimumFreq /= 2;
    MinimumFreq *= 3;
    for (Selector = 0; Selector < 16; Selector++)
        {
        for (Divisor = 0; Divisor <= 1; Divisor++)
            {
            ThisFreq = ClockGenerator[Selector] >> Divisor;

            /*
             * If the frequency being tested is at least equal
             * to triple the original frequency and is closer
             * to the ideal (triple the original) than the previous
             * "best", make it the new "best".
             */
            if ((ThisFreq >= MinimumFreq) && (ThisFreq < BestFreq))
                {
                BestFreq = ThisFreq;
                BestSelector = Selector | (Divisor << DIVISOR_SHIFT);
                }
            }
        }
    return BestSelector;

}   /* TripleClock() */



/***************************************************************************
 *
 * ULONG GetFrequency(ClockSelector);
 *
 * UCHAR ClockSelector;    Clock selector/divisor pair
 *
 * DESCRIPTION:
 *  Find the clock frequency for the specified selector/divisor pair
 *  (format 000DSSSS).
 *
 *  A divisor of 0 is treated as divide-by-1, while a divisor of 1
 *  is treated as divide-by-2.
 *
 * RETURN VALUE:
 *  Clock frequency in hertz.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * NOTE:
 *  This routine is the inverse of GetSelector()
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

ULONG GetFrequency(UCHAR ClockSelector)
{
    ULONG BaseFrequency;
    short Divisor;

    Divisor = (ClockSelector & DIVISOR_MASK) >> DIVISOR_SHIFT;
    BaseFrequency = ClockGenerator[ClockSelector & SELECTOR_MASK];

    return BaseFrequency >> Divisor;

}   /* GetFrequency() */



/***************************************************************************
 *
 * UCHAR GetSelector(Frequency);
 *
 * ULONG *Frequency;    Clock frequency in hertz
 *
 * DESCRIPTION:
 *  Find the pixel clock selector and divisor values needed to generate
 *  the best possible approximation of the input pixel clock frequency.
 *  The first value found which is within FREQ_TOLERANCE of the input
 *  value will be used (worst case error would be 0.6% frequency
 *  difference on 18811-1 clock chip if FREQ_TOLERANCE is 100 kHz).
 *
 *  If no selector/divisor pair produces a frequency which is within
 *  FREQ_TOLERANCE (very rare - I have only seen it happen in 24BPP
 *  on a DAC that needs the clock frequency multiplied by 1.5 at
 *  this pixel depth), increase the tolerance and try again. If we
 *  still can't find a selector/divisor pair before the tolerance
 *  gets too large, use the pair which produces the highest frequency
 *  not exceeding the input value.
 *  
 * RETURN VALUE:
 *  Clock selector/divisor pair (format 000DSSSS). A divisor of 0
 *  indicates divide-by-1, while a divisor of 1 indicates divide-by-2.
 *
 *  If all available selector/divisor pairs produce clock frequencies
 *  greater than (*Frequency + FREQ_TOLERANCE), 0xFF is returned.
 *
 * GLOBALS CHANGED:
 *  *Frequency is changed to the actual frequency produced by the
 *  selector/divisor pair.
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * NOTE:
 *  This routine is the inverse of GetFrequency()
 *  Since the input frequency may be changed, do not use a
 *  constant as the parameter.
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR GetSelector(ULONG *Frequency)
{
    long Select;        /* Clock select value */
    long Divisor;       /* Clock divisor */
    long TestFreq;      /* Clock frequency under test */
    long TPIRFreq;      /* Highest frequency found that doesn't exceed *Frequency */
    long TPIRSelect;    /* Selector to produce TIPRFreq */
    long TPIRDivisor;   /* Divisor to produce TPIRFreq */
    long Tolerance;     /* Maximum acceptable deviation from desired frequency */

    /*
     * Set up for no match.
     */
    TPIRFreq = 0;
    TPIRSelect = 0xFF;

    /*
     * To accomodate DACs which occasionally require a frequency
     * which is significantly different from the available frequencies,
     * we need a large tolerance. On the other hand, to avoid selecting
     * a poor match that happens earlier in the search sequence than
     * a better match, we need a small tolerance. These conflicting
     * goals can be met if we start with a small tolerance and increase
     * it if we don't find a match.
     *
     * The maximum tolerance before we give up and take the highest
     * frequency which does not exceed the target frequency was chosen
     * by trial-and-error. On a card with an STG1702/1703 DAC in 24BPP
     * (requires a pixel clock which is 1.5x normal, and which can
     * miss available frequencies by a wide margin), I increased
     * this value until all supported 24BPP modes remained on-screen.
     */
    for (Tolerance = FREQ_TOLERANCE; Tolerance <= 16*FREQ_TOLERANCE; Tolerance *= 2)
        {
        /*
         * Go through all the possible frequency/divisor pairs
         * looking for a match.
         */
        for(Select = 0; Select < 16; Select++)
            {
            for(Divisor = 1; Divisor <= 2; Divisor++)
                {
                TestFreq = ClockGenerator[Select] / Divisor;

                /*
                 * If this pair is close enough, use it.
                 */
                if ( ((TestFreq - (signed long)*Frequency) < Tolerance) &&
                     ((TestFreq - (signed long)*Frequency) > -Tolerance))
                    {
                    *Frequency = (unsigned long) TestFreq;
                    return ((UCHAR)(Select) | ((UCHAR)(Divisor - 1) << 4));
                    }

                /*
                 * If this pair produces a frequency higher than TPIRFreq
                 * but not exceeding *Frequency, use it as the new TPIRFreq.
                 * The equality test is redundant, since equality would
                 * have been caught in the test above.
                 *
                 * Except on the first pass through the outermost loop
                 * (tightest "window"), this test should never succeed,
                 * since TPIRFreq should already match the highest
                 * frequency that doesn't exceed the target frequency.
                 */
                if ((TestFreq > TPIRFreq) && (TestFreq <= (signed long)*Frequency))
                    {
                    TPIRFreq = TestFreq;
                    TPIRSelect = Select;
                    TPIRDivisor = Divisor;
                    }

                }   /* end for (loop on Divisor) */

            }   /* end for (loop on Select) */

        }   /* end for (loop on Tolerance) */

    /*
     * We didn't find a selector/divisor pair which was within tolerance,
     * so settle for second-best: the pair which produced the highest
     * frequency not exceeding the input frequency.
     */
    *Frequency = (unsigned long) TPIRFreq;
    return ((UCHAR)(TPIRSelect) | ((UCHAR)(TPIRDivisor - 1) << 4));

}   /* GetSelector() */



/***************************************************************************
 *
 * UCHAR GetShiftedSelector(Frequency);
 *
 * ULONG Frequency;     Clock frequency in hertz
 *
 * DESCRIPTION:
 *  Find the pixel clock selector and divisor values needed to generate
 *  the best possible approximation of the input pixel clock frequency.
 *  The first value found which is within FREQ_TOLERANCE of the input
 *  value will be used (worst case error would be 0.6% frequency
 *  difference on 18811-1 clock chip if FREQ_TOLERANCE is 100 kHz).
 *
 *  If no selector/divisor pair produces a frequency which is within
 *  FREQ_TOLERANCE, use the pair which produces the highest frequency
 *  not exceeding the input value.
 *  
 * RETURN VALUE:
 *  Clock selector/divisor pair (format 0DSSSS00). A divisor of 0
 *  indicates divide-by-1, while a divisor of 1 indicates divide-by-2.
 *  This format is the same as is used by the CLOCK_SEL register
 *  on Mach 8 and Mach 32 cards.
 *
 *  If all available selector/divisor pairs produce clock frequencies
 *  greater than (Frequency + FREQ_TOLERANCE), 0xFF is returned.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * NOTE:
 *  The selector/divisor pair returned may produce a frequency
 *  different from the input.
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR GetShiftedSelector(ULONG Frequency)
{
    UCHAR RawPair;  /* Selector/divisor pair returned by GetSelector() */
    ULONG TempFreq; /* Temporary copy of input parameter */

    TempFreq = Frequency;
    RawPair = GetSelector(&TempFreq);

    /*
     * If GetSelector() was unable to find a match, pass on this
     * information. Otherwise, shift the selector/divisor pair
     * into the desired format.
     */
    if (RawPair == 0xFF)
        return RawPair;
    else
        return (RawPair << 2);

}   /* GetShiftedSelector() */


/***************************************************************************
 *
 * void ISAPitchAdjust(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Query structure for video card
 *
 * DESCRIPTION:
 *  Eliminates split rasters by setting the screen pitch to 1024 for
 *  all mode tables with a horizontal resolution less than 1024, then
 *  packs the list of mode tables to eliminate any for which there is
 *  no longer enough video memory due to the increased pitch.
 *
 * GLOBALS CHANGED:
 *  QueryPtr->q_number_modes
 *
 * CALLED BY:
 *  IsApertureConflict_m() and IsApertureConflict_cx()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void ISAPitchAdjust(struct query_structure *QueryPtr)
{
struct st_mode_table *ReadPtr;      /* Mode table pointer to read from */
struct st_mode_table *WritePtr;     /* Mode table pointer to write to */
UCHAR AvailModes;                   /* Number of available modes */
int Counter;                        /* Loop counter */
ULONG BytesNeeded;                  /* Bytes of video memory needed for current mode */
ULONG MemAvail;                     /* Bytes of video memory available */

    /*
     * Set both mode table pointers to the beginning of the list of
     * mode tables. We haven't yet found any video modes, and all
     * video modes must fit into the memory space above the VGA boundary.
     */
    ReadPtr = (struct st_mode_table *)QueryPtr; /* First mode table at end of query structure */
    ((struct query_structure *)ReadPtr)++;
    WritePtr = ReadPtr;
    AvailModes = 0;
    MemAvail = (QueryPtr->q_memory_size - QueryPtr->q_VGA_boundary) * QUARTER_MEG;

    /*
     * Go through the list of mode tables, and adjust each table as needed.
     */
    VideoDebugPrint((DEBUG_DETAIL, "Original: %d modes\n", QueryPtr->q_number_modes));
    for (Counter = 0; Counter < QueryPtr->q_number_modes; Counter++, ReadPtr++)
        {
        /*
         * The pitch only needs to be adjusted if the horizontal resolution
         * is less than 1024.
         */
#if !defined (SPLIT_RASTERS)
        if (ReadPtr->m_x_size < 1024)
            ReadPtr->m_screen_pitch = 1024;

        /*
         * Temporary until split raster support for Mach 64 is added
         * (no engine-only driver for Mach 64).
         */
        if ((phwDeviceExtension->ModelNumber == MACH64_ULTRA) &&
            (ReadPtr->m_x_size > 1024))
            ReadPtr->m_screen_pitch = 2048;
#endif

        /*
         * Get the amount of video memory needed for the current mode table
         * now that the pitch has been increased. If there is no longer
         * enough memory for this mode, skip it.
         */
        BytesNeeded = (ReadPtr->m_screen_pitch * ReadPtr->m_y_size * ReadPtr->m_pixel_depth)/8;
        if (BytesNeeded >= MemAvail)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Rejected: %dx%d, %dBPP\n", ReadPtr->m_x_size, ReadPtr->m_y_size, ReadPtr->m_pixel_depth));
            continue;
            }

        /*
         * Our new source stream display driver needs a linear aperture
         * in order to handle 24BPP. Since the display driver doesn't
         * have access to the aperture information when it is deciding
         * which modes to pass on to the display applet, it can't make
         * the decision to reject 24BPP modes for cards with only a
         * VGA aperture. This decision must therefore be made in the
         * miniport, so in a paged aperture configuration there are no
         * 24BPP modes for the display driver to accept or reject.
         */
        if (ReadPtr->m_pixel_depth == 24)
            {
            VideoDebugPrint((1, "Rejected %dx%d, %dBPP - need LFB for 24BPP\n", ReadPtr->m_x_size, ReadPtr->m_y_size, ReadPtr->m_pixel_depth));
            continue;
            }

        /*
         * There is enough memory for this mode even with the pitch increased.
         * If we have not yet skipped a mode (read and write pointers are
         * the same), the mode table is already where we need it. Otherwise,
         * copy it to the next available slot in the list of mode tables.
         * In either case, move to the next slot in the list of mode tables
         * and increment the number of modes that can still be used.
         */
        if (ReadPtr != WritePtr)
            {
            VideoPortMoveMemory(WritePtr, ReadPtr, sizeof(struct st_mode_table));
            VideoDebugPrint((DEBUG_DETAIL, "Moved: %dx%d, %dBPP\n", ReadPtr->m_x_size, ReadPtr->m_y_size, ReadPtr->m_pixel_depth));
            }
        else
            {
            VideoDebugPrint((DEBUG_DETAIL, "Untouched: %dx%d, %dBPP\n", ReadPtr->m_x_size, ReadPtr->m_y_size, ReadPtr->m_pixel_depth));
            }
        AvailModes++;
        WritePtr++;
        }

    /*
     * Record the new number of available modes
     */
    QueryPtr->q_number_modes = AvailModes;
    VideoDebugPrint((DEBUG_DETAIL, "New: %d modes\n", QueryPtr->q_number_modes));
    return;

}   /* ISAPitchAdjust() */


/***************************************************************************
 *
 * WORD SetFixedModes(StartIndex, EndIndex, Multiplier, PixelDepth, 
 *                    Pitch, FreeTables, MaxDotClock, ppmode);
 *
 * WORD StartIndex;     First entry from "book" tables to use
 * WORD EndIndex;       Last entry from "book" tables to use
 * WORD Multiplier;     What needs to be done to the pixel clock
 * WORD PixelDepth;     Number of bits per pixel
 * WORD Pitch;          Screen pitch to use
 * WORD FreeTables;     Number of free mode tables that can be added
 * ULONG MaxDotClock;   Maximum pixel clock frequency, in hertz
 * struct st_mode_table **ppmode;   Pointer to list of mode tables
 *
 * DESCRIPTION:
 *  Generates a list of "canned" mode tables merged with tables found
 *  in VDIF file (either ASCII or binary file), so the tables are in
 *  increasing order of frame rate, with the "canned" entry discarded
 *  if two with matching frame rates are found. This allows the user 
 *  to select either a resolution which was not configured using 
 *  INSTALL, or a refresh rate other than the one which was configured,
 *  allowing the use of uninstalled cards, and dropping
 *  the refresh rate for high pixel depths.
 *
 * RETURN VALUE:
 *  Number of mode tables added to the list
 *
 * GLOBALS CHANGED:
 *  pCallbackArgs
 *
 * CALLED BY:
 *  QueryMach32(), QueryMach64(), OEMGetParms(), ReadAST()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  95 11 20  Robert Wolff
 *  Now obtains tables from EDID structure rather than VDIF file if
 *  both monitor and card support DDC
 *
 *  95 07 12  Miroslav Grubac
 *  Now produces a merged list of fixed mode tables and tables found in
 *  VDIF file
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

WORD SetFixedModes(WORD StartIndex,
                   WORD EndIndex,
                   WORD Multiplier,
                   WORD PixelDepth,
                   WORD Pitch,
                   short FreeTables,
                   ULONG MaxDotClock,
                   struct st_mode_table **ppmode)
{
    WORD HighBound;     /* The highest frame rate  */
    struct stVDIFCallbackData stCallbArgs;

    pCallbackArgs = (void *) (& stCallbArgs);

    /*
     * Assign values to members of stCallbArgs structure which is used
     * to pass input variables to VDIFCallback() and also to return output
     * values back to SetFixedModes(),i.e. this is the way these two routines 
     * exchange data, because callback routines cannot be passed arguments
     * as ordinary functions. Global pointer variable pCallbackArgs is
     * used to pass pointer to stCallbArgs from SetFixedModes to VDIFCallback().
     * In this manner only one global variable is required to transfer 
     * any number of parameters to the callback routine. 
     * 
     */
    stCallbArgs.FreeTables = FreeTables;
    stCallbArgs.NumModes = 0;
    stCallbArgs.EndIndex = EndIndex;
    stCallbArgs.LowBound = 1;
    stCallbArgs.Multiplier = Multiplier;  
    stCallbArgs.HorRes = (BookValues[StartIndex].HDisp + 1) * 8;
    stCallbArgs.VerRes = (((BookValues[StartIndex].VDisp >> 1) & 
                  0x0FFFC) | (BookValues[StartIndex].VDisp & 0x03)) + 1;
    stCallbArgs.PixelDepth = PixelDepth;
    stCallbArgs.Pitch = Pitch;
    stCallbArgs.MaxDotClock = MaxDotClock;
    stCallbArgs.ppFreeTables = ppmode;

    /*
     * Determine which method we should use to find the
     * mode tables corresponding to the monitor. Only the
     * Mach 64 supports DDC, so all non-Mach 64 cards
     * go directly to VDIF files read from disk.
     */
    if (phwDeviceExtension->MergeSource == MERGE_UNKNOWN)
        {
        if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
            {
            phwDeviceExtension->MergeSource = IsDDCSupported();
            }
        else
            {
            phwDeviceExtension->MergeSource = MERGE_VDIF_FILE;
            VideoDebugPrint((DEBUG_DETAIL, "Not Mach 64, so DDC is not supported\n"));
            }
        }
    

    for (stCallbArgs.Index = StartIndex;
         stCallbArgs.Index <= EndIndex && stCallbArgs.FreeTables > 0; 
                                                  stCallbArgs.Index++)
        {
        HighBound = BookValues[stCallbArgs.Index].Refresh;


        /*
         * If we can use DDC to get mode tables, merge the tables
         * obtained via DDC with our "canned" tables. 
         *
         * If MergeEDIDTables() can't get the mode tables via
         * DDC, it will not fill in any mode tables. For this
         * reason, we use two separate "if" statements rather
         * than an "if/else if" pair.
         */
        if (phwDeviceExtension->MergeSource == MERGE_EDID_DDC)
            {
            if (MergeEDIDTables() != NO_ERROR)
                phwDeviceExtension->MergeSource = MERGE_VDIF_FILE;
            }

        if ((stCallbArgs.LowBound <= HighBound) &&
            (BookValues[stCallbArgs.Index].ClockFreq <= MaxDotClock) &&
            (stCallbArgs.FreeTables > 0) )
            {
            /*
             * Unsuccesful MiniPort Function call to process VDIF file.
             * Fill the next table with this value of Index from
             * BookValues[] 
             */
            BookVgaTable(stCallbArgs.Index, *stCallbArgs.ppFreeTables);
            SetOtherModeParameters(PixelDepth, Pitch, Multiplier, 
                                        *stCallbArgs.ppFreeTables);

            ++ *stCallbArgs.ppFreeTables;  
            ++stCallbArgs.NumModes;  
            --stCallbArgs.FreeTables;
            stCallbArgs.LowBound = BookValues[stCallbArgs.Index].Refresh + 1;
            }
            
        }  /* for(Index in range and space left) */

    return stCallbArgs.NumModes;

}   /* SetFixedModes() */


/***************************************************************************
 *
 * void FillInRegistry(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * DESCRIPTION:
 *  Fill in the Chip Type, DAC Type, Memory Size, and Adapter String
 *  fields in the registry.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  ATIMPInitialize()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  Robert Wolff 96 04 15
 *  Now identifies specific Mach 64 ASIC types rather than reporting
 *  a single value for all types of Mach 64.
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void FillInRegistry(struct query_structure *QueryPtr)
{
    PWSTR ChipString;       /* Identification string for the ASIC in use */
    PWSTR DACString;        /* Identification string for the DAC in use */
    PWSTR AdapterString;    /* Identifies this as an ATI accelerator */
    ULONG MemorySize;       /* Number of bytes of accelerator memory */
    ULONG ChipLen;          /* Length of ChipString */
    ULONG DACLen;           /* Length of DACString */
    ULONG AdapterLen;       /* Length of AdapterString */

    /*
     * Report that this is an ATI graphics accelerator.
     */
    AdapterString = L"ATI Graphics Accelerator";
    AdapterLen = sizeof(L"ATI Graphics Accelerator");

    /*
     * Report which of our accelerators is in use.
     */
    switch (QueryPtr->q_asic_rev)
        {
        case CI_38800_1:
            ChipString = L"Mach 8";
            ChipLen = sizeof(L"Mach 8");
            break;

        case CI_68800_3:
            ChipString = L"Mach 32 rev. 3";
            ChipLen = sizeof(L"Mach 32 rev. 3");
            break;

        case CI_68800_6:
            ChipString = L"Mach 32 rev. 6";
            ChipLen = sizeof(L"Mach 32 rev. 6");
            break;

        case CI_68800_UNKNOWN:
            ChipString = L"Mach 32 unknown revision";
            ChipLen = sizeof(L"Mach 32 unknown revision");
            break;

        case CI_68800_AX:
            ChipString = L"Mach 32 AX";
            ChipLen = sizeof(L"Mach 32 AX");
            break;

        case CI_88800_GX:
            ChipString = IdentifyMach64Asic(QueryPtr, &ChipLen);
            break;

        default:
            ChipString = L"Unknown ATI accelerator";
            ChipLen = sizeof(L"Unknown ATI accelerator");
            break;
        }

    /*
     * Report which DAC we are using.
     */
    switch(QueryPtr->q_DAC_type)
        {
        case DAC_ATI_68830:
            DACString = L"ATI 68830";
            DACLen = sizeof(L"ATI 68830");
            break;

        case DAC_SIERRA:
            DACString = L"Sierra SC1148x";
            DACLen = sizeof(L"Sierra SC1148x");
            break;

        case DAC_TI34075:
            DACString = L"TI 34075/ATI 68875";
            DACLen = sizeof(L"TI 34075/ATI 68875");
            break;

        case DAC_BT47x:
            DACString = L"Brooktree BT47x";
            DACLen = sizeof(L"Brooktree BT47x");
            break;

        case DAC_BT48x:
            DACString = L"Brooktree BT48x";
            DACLen = sizeof(L"Brooktree BT48x");
            break;

        case DAC_ATI_68860:
            DACString = L"ATI 68860";
            DACLen = sizeof(L"ATI 68860");
            break;

        case DAC_STG1700:
            DACString = L"S.G. Thompson STG170x";
            DACLen = sizeof(L"S.G. Thompson STG170x");
            break;

        case DAC_SC15021:
            DACString = L"Sierra SC15021";
            DACLen = sizeof(L"Sierra SC15021");
            break;

        case DAC_ATT491:
            DACString = L"AT&&T 49[123]";
            DACLen = sizeof(L"AT&&T 49[123]");
            break;

        case DAC_ATT498:
            DACString = L"AT&&T 498";
            DACLen = sizeof(L"AT&&T 498");
            break;

        case DAC_SC15026:
            DACString = L"Sierra SC15026";
            DACLen = sizeof(L"Sierra SC15026");
            break;

        case DAC_TVP3026:
            DACString = L"Texas Instruments TVP3026";
            DACLen = sizeof(L"Texas Instruments TVP3026");
            break;

        case DAC_IBM514:
            DACString = L"IBM RGB514";
            DACLen = sizeof(L"IBM RGB514");
            break;

        case DAC_STG1702:
            DACString = L"S.G. Thompson STG1702/1703";
            DACLen = sizeof(L"S.G. Thompson STG1702/1703");
            break;

        case DAC_STG1703:
            DACString = L"S.G. Thompson STG1703";
            DACLen = sizeof(L"S.G. Thompson STG1703");
            break;

        case DAC_CH8398:
            DACString = L"Chrontel CH8398";
            DACLen = sizeof(L"Chrontel CH8398");
            break;

        case DAC_ATT408:
            DACString = L"AT&&T 408";
            DACLen = sizeof(L"AT&&T 408");
            break;

        case DAC_INTERNAL_CT:
        case DAC_INTERNAL_GT:
        case DAC_INTERNAL_VT:
            DACString = L"DAC built into ASIC";
            DACLen = sizeof(L"DAC built into ASIC");
            break;

        default:
            DACString = L"Unknown DAC type";
            DACLen = sizeof(L"Unknown DAC type");
            break;
        }

    /*
     * Report the amount of accelerator memory. On Mach 8
     * combo cards, the q_memory_size field includes VGA-only
     * memory which the accelerator can't access. On all
     * other cards, it reports accelerator-accessible memory.
     */
    if (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA)
        {
        switch (QueryPtr->q_memory_size)
            {
            case VRAM_768k:     /* 512k accelerator/256k VGA */
            case VRAM_1mb:      /* 512k accelerator/512k VGA */
                MemorySize = HALF_MEG;
                break;

            case VRAM_1_25mb:   /* 1M accelerator/256k VGA */
            case VRAM_1_50mb:   /* 1M accelerator/512k VGA */
                MemorySize = ONE_MEG;
                break;

            default:            /* Should never happen */
                VideoDebugPrint((DEBUG_ERROR, "Non-production Mach 8 combo\n"));
                MemorySize = ONE_MEG;
                break;
            }
        }
    else
        {
        MemorySize = QueryPtr->q_memory_size * QUARTER_MEG;
        }


    /*
     * Write the information to the registry.
     */
    VideoPortSetRegistryParameters(phwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   ChipString,
                                   ChipLen);

    VideoPortSetRegistryParameters(phwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   DACString,
                                   DACLen);

    VideoPortSetRegistryParameters(phwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &MemorySize,
                                   sizeof(ULONG));

    VideoPortSetRegistryParameters(phwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   AdapterString,
                                   AdapterLen);

    return;

}   /* FillInRegistry() */




/*
 * PVOID MapFramebuffer(StartAddress, Size);
 *
 * ULONG StartAddress;  Physical address of start of framebuffer
 * long Size;           Size of framebuffer in bytes
 *
 * Map the framebuffer into Windows NT's address space.
 *
 * Returns:
 *  Pointer to start of framebuffer if successful
 *  Zero if unable to map the framebuffer
 */
PVOID MapFramebuffer(ULONG StartAddress, long Size)
{
    VIDEO_ACCESS_RANGE  FramebufferData;

    FramebufferData.RangeLength = Size;
    FramebufferData.RangeStart.LowPart = StartAddress;
    FramebufferData.RangeStart.HighPart = 0;
    FramebufferData.RangeInIoSpace = 0;
    FramebufferData.RangeVisible = 0;

    return VideoPortGetDeviceBase(phwDeviceExtension,
                    FramebufferData.RangeStart,
                    FramebufferData.RangeLength,
                    FramebufferData.RangeInIoSpace);

}   /* MapFrameBuffer() */




/**************************************************************************
 *
 * unsigned short *Get_BIOS_Seg(void);
 *
 * DESCRIPTION:
 *  Verify BIOS presence and return BIOS segment
 *  Check for ATI Video BIOS, by checking for product signature
 *  near beginning of BIOS segment.  It should be ASCII string  "761295520"
 *
 * RETURN VALUE:
 *  Segment of BIOS code. If multiple ATI Video BIOS segments are
 *  found, return the highest one (probable cause: VGAWonder and
 *  8514/ULTRA, this will return the BIOS segment for the 8514/ULTRA).
 *
 *  If no ATI video BIOS segment is found, returns FALSE.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter(), DetectMach64()
 *
 **************************************************************************/

unsigned short *Get_BIOS_Seg(void)
{
    /*
     * Offset of the start of the video BIOS segment
     * from the start of the BIOS area
     */
    long SegmentOffset;
    PUCHAR SegmentStart;    /* Start address of the BIOS segment being tested */
    ULONG SigOffset;        /* Offset of signature string from start of BIOS segment */
    ULONG SigLoop;          /* Counter to check for match */
    BOOL SigFound;          /* Whether or not the signature string was found */


    /*
     * Try to allocate the block of address space where the BIOS
     * is found. If we can't, report that we didn't find the BIOS.
     */
    if ((phwDeviceExtension->RomBaseRange =
        VideoPortGetDeviceBase(phwDeviceExtension,
            RawRomBaseRange.RangeStart,
            RawRomBaseRange.RangeLength,
            RawRomBaseRange.RangeInIoSpace)) == NULL)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Get_BIOS_Seg() can't allocate BIOS address range, assuming no BIOS\n"));
        return FALSE;
        }

    /*
     * For each candidate for the start of the video BIOS segment,
     * check to see if it is the start of a BIOS segment. Start at
     * the top and work down because if the system contains both a
     * VGAWonder and an 8514/ULTRA, the 8514/ULTRA BIOS will be at
     * a higher address than the VGAWonder BIOS, and we want to get
     * information from the 8514/ULTRA BIOS.
     */
    for (SegmentOffset = MAX_BIOS_START; SegmentOffset >= 0; SegmentOffset -= ROM_GRANULARITY)
        {
        SegmentStart = (PUCHAR)phwDeviceExtension->RomBaseRange + SegmentOffset;

        /*
         * If this candidate does not begin with the "start of BIOS segment"
         * identifier, then it is not the start of the video BIOS segment.
         */
        if (VideoPortReadRegisterUshort((PUSHORT)SegmentStart) == VIDEO_ROM_ID)
            {
            /*
             * We've found the start of a BIOS segment. Search through
             * the range of offsets from the start of the segment where
             * the ATI signature string can start. If we find it,
             * then we know that this is the video BIOS segment.
             */
            for (SigOffset = SIG_AREA_START; SigOffset <= SIG_AREA_END; SigOffset++)
                {
                /*
                 * If the first character of the signature string isn't at the
                 * current offset into the segment, then we haven't found the
                 * signature string yet.
                 */
                if (VideoPortReadRegisterUchar(SegmentStart + SigOffset) != ati_signature[0])
                    continue;

                /*
                 * We have found the first character of the signature string. Scan
                 * through the following characters to see if they contain the
                 * remainder of the signature string. If, before we reach the
                 * null terminator on the test string, we find a character that
                 * does not match the test string, then what we thought was the
                 * signature string is actually unrelated data that happens to
                 * match the first few characters.
                 */
                SigFound = TRUE;
                for (SigLoop = 1; ati_signature[SigLoop] != 0; SigLoop++)
                    {
                    if (VideoPortReadRegisterUchar(SegmentStart + SigOffset + SigLoop) != ati_signature[SigLoop])
                        {
                        SigFound = FALSE;
                        continue;
                        }
                    }   /* end for (checking for entire signature string) */

                /*
                 * We have found the entire signature string.
                 */
                if (SigFound == TRUE)
                    {
                    VideoDebugPrint((DEBUG_NORMAL, "Get_BIOS_Seg() found the BIOS signature string\n"));
                    return (unsigned short *)SegmentStart;
                    }

                }   /* end for (checking BIOS segment for signature string) */

            }   /* end if (a BIOS segment starts here) */

        }   /* end for (check each possible BIOS start address) */

    /*
     * We have checked all the candidates for the start of the BIOS segment,
     * and none contained the signature string.
     */
    VideoDebugPrint((DEBUG_NORMAL, "Get_BIOS_Seg() didn't find the BIOS signature string\n"));
    return FALSE;

}   /* Get_BIOS_Seg() */




/***************************************************************************
 *
 * void UpperCase(TxtString);
 *
 * PUCHAR TxtString;        Text string to process
 *
 * DESCRIPTION:
 *  Convert a null-terminated string to uppercase. This function wouldn't
 *  be necessary if strupr() were available in all versions of the
 *  NT build environment.
 *
 * GLOBALS CHANGED:
 *  None, but the contents of the buffer are overwritten.
 *
 * CALLED BY:
 *  This function may be called by any routine.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void UpperCase(PUCHAR TxtString)
{
    PUCHAR CurrentChar;         /* Current character being processed */

    CurrentChar = TxtString;

    /*
     * Continue until we encounter the null terminator.
     */
    while (*CurrentChar != '\0')
        {
        /*
         * If the current character is a lower case letter,
         * convert it to upper case. Don't change any characters
         * that aren't lower case letters.
         */
        if ((*CurrentChar >= 'a') && (*CurrentChar <= 'z'))
            *CurrentChar -= ('a' - 'A');

        CurrentChar++;
        }

    return;

}   /* UpperCase() */



/***************************************************************************
 *
 * PUCHAR GetVgaBuffer(Size, Offset, Segment, SaveBuffer);
 *
 * ULONG Size;          Size of the buffer in bytes
 * ULONG Offset;        How far into the VGA segment we want
 *                      the buffer to start
 * PULONG Segment;      Pointer to storage location for the segment
 *                      where the buffer is located
 * PUCHAR SaveBuffer;   Pointer to temporary storage location where the
 *                      original contents of the buffer are to be saved,
 *                      NULL if there is no need to save the original
 *                      contents of the buffer.
 *
 * DESCRIPTION:
 *  Map a buffer of a specified size at a specified offset (must be
 *  a multiple of 16 bytes) into VGA memory. If desired, the original
 *  contents of the buffer are saved. This function tries the 3 VGA
 *  apertures in the following order - colour text screen, mono text
 *  screen, graphics screen - until it finds one where we can place
 *  the buffer. If we can't map the desired buffer, we return failure
 *  rather than forcing a mode set to create the buffer. On return,
 *  *Segment:0 is the physical address of the start of the buffer
 *  (this is why Offset must be a multiple of 16 bytes).
 *
 *  This function is used to find a buffer below 1 megabyte physical,
 *  since some of the Mach 64 BIOS routines require a buffer in this
 *  region. If future versions of Windows NT add a function which can
 *  give us a buffer below 1 megabyte physical, such a routine would
 *  be preferable to using VGA memory as the buffer.
 *
 * RETURN VALUE:
 *  Pointer to start of buffer if successful
 *  Zero if unable to obtain a buffer
 *
 * NOTE
 *  If zero is returned, the values returned in Segment and SaveBuffer
 *  are undefined.
 *
 *  On VGA text screens (colour and mono), we try to use the offscreen
 *  portion of video memory.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  This function may be called by any routine, so long as the entry
 *  point resulting in the call is ATIMPInitialize() or ATIMPStartIO().
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

PUCHAR GetVgaBuffer(ULONG Size, ULONG Offset, PULONG Segment, PUCHAR SaveBuffer)
{
    PUCHAR MappedBuffer;                /* Pointer to buffer under test */
    ULONG BufferSeg;                    /* Segment to use for buffer */
    ULONG Scratch;                      /* Temporary variable */

    /*
     * Check for a valid offset.
     */
    if (Offset & 0x0000000F)
        {
        VideoDebugPrint((DEBUG_ERROR, "GetVgaBuffer() - Offset must be a multiple of 16\n"));
        return 0;
        }

    BufferSeg = 0x0BA00 + Offset;           /* Colour text */
    MappedBuffer = MapFramebuffer((BufferSeg << 4), Size);
    if (MappedBuffer != 0)
        {
        if (SaveBuffer != NULL)
            {
            for (Scratch = 0; Scratch < Size; Scratch++)
                SaveBuffer[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
            }
        if (IsBufferBacked(MappedBuffer, Size) == FALSE)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Colour text screen not backed by physical memory\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            MappedBuffer = 0;
            }
        }
    else
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't map colour text screen\n"));
        }

    /*
     * If we were unable to allocate a large enough buffer in the
     * colour text screen, try the monochrome text screen.
     */
    if (MappedBuffer == 0)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't use colour text screen, trying monochrome text screen\n"));
        BufferSeg = 0x0B200 + Offset;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), Size)) != 0)
            {
            if (SaveBuffer != NULL)
                {
                for (Scratch = 0; Scratch < Size; Scratch++)
                    SaveBuffer[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
                }
            if (IsBufferBacked(MappedBuffer, Size) == FALSE)
                {
                VideoDebugPrint((DEBUG_NORMAL, "Monochrome text screen not backed by physical memory\n"));
                VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
                MappedBuffer = 0;
                }
            }
        else
            {
            VideoDebugPrint((DEBUG_NORMAL, "Can't map monochrome text screen\n"));
            }
        }

    /*
     * If we were unable to allocate a large enough buffer in either of
     * the text screens, try the VGA graphics screen.
     */
    if (MappedBuffer == 0)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't use monochrome text screen, trying graphics screen\n"));
        BufferSeg = 0x0A000 + Offset;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), Size)) == 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "Can't map graphics screen - aborting DDC query\n"));
            return 0;
            }

        if (SaveBuffer != NULL)
            {
            for (Scratch = 0; Scratch < Size; Scratch++)
                SaveBuffer[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
            }

        if (IsBufferBacked(MappedBuffer, Size) == FALSE)
            {
            VideoDebugPrint((DEBUG_ERROR, "Graphics screen not backed by memory - aborting\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            return 0;
            }
        }

    /*
     * Report the segment where we found the buffer.
     */
    *Segment = BufferSeg;

    return MappedBuffer;

}   /* GetVgaBuffer() */




/*
 * Low level Input/Output routines. These are not needed on an MS-DOS
 * platform because the standard inp<size>() and outp<size>() routines
 * are available.
 */

/*
 * UCHAR LioInp(Port, Offset);
 *
 * int Port;    Register to read from
 * int Offset;  Offset into desired register
 *
 * Read an unsigned character from a given register. Works with both normal
 * I/O ports and memory-mapped registers. Offset is zero for 8 bit registers
 * and the least significant byte of 16 and 32 bit registers, 1 for the
 * most significant byte of 16 bit registers and the second least significant
 * byte of 32 bit registers, up to 3 for the most significant byte of 32 bit
 * registers.
 *
 * Returns:
 *  Value held in the register.
 */
UCHAR LioInp(int Port, int Offset)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
        /*
         * In early versions of Windows NT, VideoPort[Read|Write]Register<size>()
         * didn't work properly, but these routines are preferable to
         * direct pointer read/write for versions where they do work.
         *
         * On the DEC Alpha, these routines no longer work for memory
         * in dense space as of NT 4.0, so we must revert to the old
         * method. Microsoft doesn't like this, but until DEC fixes
         * the HAL there's nothing else we can do. All Alpha machines
         * with PCI bus support dense space, but some older (Jensen)
         * systems only support sparse space. Since these systems have
         * only an EISA bus, we use the bus type of the card to determine
         * whether to use dense or sparse memory space (PCI cards can
         * use dense space since all machines with PCI buses support
         * it, ISA cards may be in either an older or a newer machine,
         * so they must use sparse space, no Alpha machines support
         * VLB, and there are no EISA Mach 64 cards).
         */
#if (TARGET_BUILD < 350)
        return *(PUCHAR)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset);
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            return *(PUCHAR)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset);
        else
#endif
        return VideoPortReadRegisterUchar ((PUCHAR)(((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressMM[Port]) + Offset);
#endif
        }
    else
        {
        return VideoPortReadPortUchar ((PUCHAR)(((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressIO[Port]) + Offset);
        }
}



/*
 * USHORT LioInpw(Port, Offset);
 *
 * int Port;    Register to read from
 * int Offset;  Offset into desired register
 *
 * Read an unsigned short integer from a given register. Works with both
 * normal I/O ports and memory-mapped registers. Offset is either zero for
 * 16 bit registers and the least significant word of 32 bit registers, or
 * 2 for the most significant word of 32 bit registers.
 *
 * Returns:
 *  Value held in the register.
 */
USHORT LioInpw(int Port, int Offset)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        return *(PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset);
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            return *(PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset);
        else
#endif
        return VideoPortReadRegisterUshort ((PUSHORT)((PUCHAR)(((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressMM[Port]) + Offset));
#endif
        }
    else
        {
        return VideoPortReadPortUshort ((PUSHORT)((PUCHAR)(((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressIO[Port]) + Offset));
        }
}



/*
 * ULONG LioInpd(Port);
 *
 * int Port;    Register to read from
 *
 * Read an unsigned long integer from a given register. Works with both
 * normal I/O ports and memory-mapped registers.
 *
 * Returns:
 *  Value held in the register.
 */
ULONG LioInpd(int Port)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        return *(PULONG)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]));
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            return *(PULONG)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]));
        else
#endif
        return VideoPortReadRegisterUlong (((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressMM[Port]);
#endif
        }
    else
        {
        return VideoPortReadPortUlong (((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressIO[Port]);
        }
}



/*
 * VOID LioOutp(Port, Data, Offset);
 *
 * int Port;    Register to write to
 * UCHAR Data;  Data to write
 * int Offset;  Offset into desired register
 *
 * Write an unsigned character to a given register. Works with both normal
 * I/O ports and memory-mapped registers. Offset is zero for 8 bit registers
 * and the least significant byte of 16 and 32 bit registers, 1 for the
 * most significant byte of 16 bit registers and the second least significant
 * byte of 32 bit registers, up to 3 for the most significant byte of 32 bit
 * registers.
 */
VOID LioOutp(int Port, UCHAR Data, int Offset)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        *(PUCHAR)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset) = Data;
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            *(PUCHAR)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset) = Data;
        else
#endif
        VideoPortWriteRegisterUchar ((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset, (BYTE)(Data));
#endif
        }
    else
        {
        VideoPortWritePortUchar ((PUCHAR)(phwDeviceExtension->aVideoAddressIO[Port]) + Offset, (BYTE)(Data));
        }

    return;
}



/*
 * VOID LioOutpw(Port, Data, Offset);
 *
 * int Port;    Register to write to
 * USHORT Data; Data to write
 * int Offset;  Offset into desired register
 *
 * Write an unsigned short integer to a given register. Works with both
 * normal I/O ports and memory-mapped registers. Offset is either zero for
 * 16 bit registers and the least significant word of 32 bit registers, or
 * 2 for the most significant word of 32 bit registers.
 */
VOID LioOutpw(int Port, USHORT Data, int Offset)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        *(PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset) = (WORD)(Data);
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            *(PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset) = Data;
        else
#endif
        VideoPortWriteRegisterUshort ((PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset), (WORD)(Data));
#endif
        }
    else
        {
        VideoPortWritePortUshort ((PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressIO[Port]) + Offset), (WORD)(Data));
        }

    return;
}



/*
 * VOID LioOutpd(Port, Data);
 *
 * int Port;    Register to write to
 * ULONG Data;  Data to write
 *
 * Write an unsigned long integer to a given register. Works with both
 * normal I/O ports and memory-mapped registers.
 */
VOID LioOutpd(int Port, ULONG Data)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        *(PULONG)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port])) = (ULONG)(Data);
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            *(PULONG)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port])) = Data;
        else
#endif
        VideoPortWriteRegisterUlong (phwDeviceExtension->aVideoAddressMM[Port], Data);
#endif
        }
    else
        {
        VideoPortWritePortUlong (phwDeviceExtension->aVideoAddressIO[Port], Data);
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\setup_cx.c ===
/************************************************************************/
/*                                                                      */
/*                              SETUP_CX.C                              */
/*                                                                      */
/*        Aug 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.21  $
      $Date:   15 May 1996 16:36:04  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/setup_cx.c_v  $
 * 
 *    Rev 1.21   15 May 1996 16:36:04   RWolff
 * Now records in registry if we have to cut back on BIOS claim
 * size (conflict with SCSI card having BIOS segment below 0xD000:0000)
 * so we only get event log messages on the first boot, rather
 * than on every boot.
 * 
 *    Rev 1.20   03 May 1996 15:16:42   RWolff
 * Made new temporary variable conditional on platform type to avoid
 * warning when compiling for non-Alpha platforms.
 * 
 *    Rev 1.19   03 May 1996 14:07:26   RWolff
 * Fixed drawing problem with GX-F ASIC on DEC Alpha.
 * 
 *    Rev 1.18   15 Apr 1996 13:51:30   RWolff
 * Fallback to claiming 32k of BIOS if we can't get the full 64k, to avoid
 * conflict with Adaptec 154x adapters with their BIOS segment set to
 * 0xC800:0000 or 0xCC00:0000
 * 
 *    Rev 1.17   29 Jan 1996 17:01:56   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC, now
 * rejects exhaustive list of non-Mach 64 cards and accepts all
 * others when looking for block I/O cards, rather than accepting
 * exhaustive list of Mach 64 cards and rejecting all others.
 * 
 *    Rev 1.16   23 Jan 1996 17:52:16   RWolff
 * Added GT to list of Mach 64 cards capable of supporting block I/O.
 * 
 *    Rev 1.15   23 Jan 1996 11:49:38   RWolff
 * Eliminated level 3 warnings, added debug print statements, removed
 * conditionally-compilec code to use VideoPortGetAccessRanges() to
 * find block I/O cards, since this function remaps the I/O base address
 * and this is incompatible with the use of INT 10.
 * 
 *    Rev 1.14   12 Jan 1996 11:18:50   RWolff
 * Reduced size of buffer requested through VideoPortGetBusData()
 * 
 *    Rev 1.13   23 Nov 1995 11:31:42   RWolff
 * Now searches each PCI slot for our cards, rather than using
 * VideoPortGetAccessRanges(), since that routine won't detect
 * block-relocatable GX-F2s properly. This change is not sanctioned
 * by Microsoft, and must be backed out if they fix their routine.
 * 
 *    Rev 1.12   24 Aug 1995 15:39:06   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 * 
 *    Rev 1.11   13 Jun 1995 15:11:18   RWOLFF
 * On Alpha systems, now only uses dense space for the memory mapped
 * registers on PCI cards. This is to allow support for ISA cards on
 * the Jensen (EISA machine, no PCI support), which doesn't support
 * dense space.
 * 
 *    Rev 1.10   30 Mar 1995 12:02:14   RWOLFF
 * WaitForIdle_cx() and CheckFIFOSpace_cx() now time out and reset
 * the engine after 3 seconds (no operation should take this long)
 * to clear a hung engine, changed permanent debug print statements
 * to use new debug level thresholds.
 * 
 *    Rev 1.9   08 Mar 1995 11:35:44   ASHANMUG
 * Modified return values to be correct
 * 
 *    Rev 1.7   27 Feb 1995 17:53:26   RWOLFF
 * Added routine that reports whether the I/O registers are packed
 * (relocatable) or not.
 * 
 *    Rev 1.6   24 Feb 1995 12:30:44   RWOLFF
 * Added code to support relocatable I/O. This is not yet fully
 * operational, so it is disabled for this release.
 * 
 *    Rev 1.5   23 Dec 1994 10:47:12   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.4   18 Nov 1994 11:48:18   RWOLFF
 * Added support for Mach 64 with no BIOS, routine to get the I/O base
 * address for the card being used.
 * 
 *    Rev 1.3   20 Jul 1994 12:59:12   RWOLFF
 * Added support for multiple I/O base addresses for accelerator registers.
 * 
 *    Rev 1.2   30 Jun 1994 18:16:50   RWOLFF
 * Added IsApertureConflict_cx() (moved from QUERY_CX.C). Instead of checking
 * to see if we can read back what we have written to the aperture, then
 * looking for the proper text attribute, we now make a call to
 * VideoPortVerifyAccessRanges() which includes the aperture in the list of
 * ranges we are trying to claim. If this call fails, we make another call
 * which does not include the LFB. We always claim the VGA aperture (shareable),
 * since we need to use it when querying the card.
 * 
 *    Rev 1.1   07 Feb 1994 14:14:12   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:20:42   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.1   30 Nov 1993 18:30:06   RWOLFF
 * Fixed calculation of offset for memory mapped address ranges.
 * 
 *    Rev 1.0   05 Nov 1993 13:36:14   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SETUP_CX.C - Setup routines for 68800CX accelerators.

DESCRIPTION
    This file contains routines which provide services specific to
    the 68800CX-compatible family of ATI accelerators.

OTHER FILES

#endif

#include "dderror.h"

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"

#include "query_cx.h"
#include "services.h"
#define INCLUDE_SETUP_CX
#include "setup_cx.h"


static ULONG FindNextBlockATICard(void);

/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_CX, CompatIORangesUsable_cx)
#pragma alloc_text(PAGE_CX, CompatMMRangesUsable_cx)
#pragma alloc_text(PAGE_CX, WaitForIdle_cx)
#pragma alloc_text(PAGE_CX, CheckFIFOSpace_cx)
#pragma alloc_text(PAGE_CX, IsApertureConflict_cx)
#pragma alloc_text(PAGE_CX, GetIOBase_cx)
#pragma alloc_text(PAGE_CX, IsPackedIO_cx)
#pragma alloc_text(PAGE_CX, FindNextBlockATICard)
#endif



UCHAR LookForAnotherCard = 1;


/***************************************************************************
 *
 * VP_STATUS CompatIORangesUsable_cx(void);
 *
 * DESCRIPTION:
 *  Ask Windows NT for permission to use the I/O space address ranges
 *  needed by the 68800CX accelerator.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if unable to gain access to the ranges we need.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS CompatIORangesUsable_cx(INTERFACE_TYPE SystemBus)
{
    VP_STATUS Status;               /* Value returned by operating system calls */
    short Count;                    /* Loop counter */
    VIDEO_ACCESS_RANGE SaveFirstMM; /* Place to save the first memory mapped registers */
    USHORT BaseIndex;               /* Index into register base array */
    USHORT VariableIndex;           /* Index into array of variable part of register array */
    ULONG BaseAddress;              /* I/O base address for relocatable I/O */
    ULONG ClaimSize;                /* Size of VGA aperture/BIOS block to claim */
    ULONG InitialClaimSize;         /* Initial size of the BIOS block to claim */
    BOOL FoundSafeClaim = FALSE;    /* Have we found a BIOS block we can claim safely? */


    /*
     * Check to see if someone has added or deleted I/O ranges without
     * changing the defined value. I/O registers start at index 0.
     *
     * All the I/O mapped registers are before the first register which
     * exists only in memory-mapped form.
     */
    if ((DriverIORange_cx[NUM_IO_REGISTERS-1].RangeStart.HighPart == DONT_USE) ||
        (DriverIORange_cx[NUM_IO_REGISTERS].RangeStart.HighPart != DONT_USE))
        {
        VideoDebugPrint((DEBUG_ERROR, "Wrong defined value for number of I/O ranges\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Clear the list of mapped I/O addresses so we can identify
     * which ones have been mapped in order to unmap them if
     * there is a failure partway through the mapping.
     */
    for (Count = 0; Count < NUM_IO_REGISTERS; Count++)
        {
        phwDeviceExtension->aVideoAddressIO[Count] = 0;
        }

    /*
     * Run through the list of base addresses, trying each
     * until we find the one that the Mach 64 is using.
     */
    for (BaseIndex = 0; BaseIndex < NUM_BASE_ADDRESSES; BaseIndex++)
        {
        /*
         * Possible problem area: if this is the first bus to be
         * tested which contains a fixed-base Mach 64, but a previous
         * bus had at least one block-relocatable card without
         * having the maximum number we support (which would have
         * been caught in ATIMPFindAdapter()), we don't want to
         * look for fixed-base cards. This is because we don't
         * support a mixture of fixed-base and block-relocatable
         * cards.
         */
        if (NumBlockCardsFound != 0)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Skipping fixed base because block cards found\n"));
            break;
            }

        /*
         * Build up the accelerator registers using the current
         * base address.
         */
        for (VariableIndex = 0; VariableIndex < NUM_REGS_TO_BUILD; VariableIndex++)
            {
            DriverIORange_cx[VariableIndex+FIRST_REG_TO_BUILD].RangeStart.LowPart =
                VariableRegisterBases[BaseIndex] + VariableRegisterOffsets[VariableIndex];
            }

        /*
         * If we encounter a conflict claiming the full 64k of the BIOS
         * area, it will generate two messages in the event log even
         * though this is not a fatal error. To avoid this, we must
         * store claim restrictions in the registry, and on subsequent
         * boots start claiming where we were successful last time.
         *
         * If we can't read the registry entry, assume that we can
         * claim the full 64k area starting at 0xC000:0000.
         *
         * Don't worry about a user upgrading to a Mach 64 with a 64k
         * video BIOS and moving the SCSI card above 0xD000:0000, since
         * our install script will clear this registry entry to its
         * "claim 64k" value.
         */
        if (VideoPortGetRegistryParameters(phwDeviceExtension,
                                           L"BiosClaimSize",
                                           FALSE,
                                           RegistryParameterCallback,
                                           NULL) == NO_ERROR)
            {
            InitialClaimSize = *RegistryBuffer;
            VideoDebugPrint((DEBUG_DETAIL, "Read initial claim size 0x%X\n", VgaResourceSize[InitialClaimSize]));
            }
        else
            {
            InitialClaimSize = CLAIM_32k_BIOS;
            VideoDebugPrint((DEBUG_DETAIL, "Using default initial claim size 0x%X\n", VgaResourceSize[InitialClaimSize]));
            }

        if ((InitialClaimSize < CLAIM_32k_BIOS) || (InitialClaimSize > CLAIM_APERTURE_ONLY) )
            InitialClaimSize = CLAIM_32k_BIOS;

        /*
         * Claim as much as possible of our BIOS area. If we fail to
         * claim the full 64k, try restricting ourselves to 32k and
         * finally no BIOS area, only giving up on the current I/O
         * base address if we can't claim our access ranges even with
         * no BIOS area.
         */
        for (ClaimSize = InitialClaimSize; ClaimSize <= CLAIM_APERTURE_ONLY; ClaimSize++)
            {
            /*
             * Set up our VGA resource claim size.
             */
            DriverApertureRange_cx[0].RangeLength = VgaResourceSize[ClaimSize];

            /*
             * Check to see if there is a hardware resource conflict. We must save
             * the information for the first memory mapped register, copy in
             * the information for the VGA aperture (which we always need),
             * and restore the memory mapped register information after
             * we have verified that we can use the required address ranges.
             */
            VideoPortMoveMemory(&SaveFirstMM, DriverIORange_cx+VGA_APERTURE_ENTRY, sizeof(VIDEO_ACCESS_RANGE));
            VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, DriverApertureRange_cx, sizeof(VIDEO_ACCESS_RANGE));

            Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                                NUM_IO_REGISTERS + 1,
                                                DriverIORange_cx);

            VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, &SaveFirstMM, sizeof(VIDEO_ACCESS_RANGE));

            /*
             * If there is a hardware resource conflict, we can't use this
             * base address and BIOS region size, so try the next. If there
             * is no conflict, use the current size.
             *
             * If the size of the BIOS block we were able to claim
             * differs from our initial attempt, record the "maximum
             * possible BIOS block size" in the registry so that on
             * subsequent boots we won't generate event log entries
             * by claiming a BIOS region that conflicts with another
             * card.
             */
            if (Status != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Rejecting VGA aperture/BIOS block size of 0x%X bytes\n", VgaResourceSize[ClaimSize]));
                continue;
                }
            else
                {
                VideoDebugPrint((DEBUG_DETAIL, "VGA aperture/BIOS block size = 0x%X bytes\n", VgaResourceSize[ClaimSize]));
                if (FoundSafeClaim == FALSE)
                    {
                    FoundSafeClaim = TRUE;
                    if (ClaimSize != InitialClaimSize)
                        {
                        //ClaimSize = 1;
                        VideoDebugPrint((DEBUG_DETAIL, "Writing claim size 0x%X\n", VgaResourceSize[ClaimSize]));
                        VideoPortSetRegistryParameters(phwDeviceExtension,
                                                       L"BiosClaimSize",
                                                       &ClaimSize,
                                                       sizeof(ULONG));
                        }
                    }
                break;
                }
            }   /* end for (decreasing claim size) */

        /*
         * If we fell out of the above loop, rather than breaking out,
         * go on to the next I/O base address, since we have run into
         * a hardware resource conflict.
         */
        if ((Status != NO_ERROR) && (ClaimSize > CLAIM_APERTURE_ONLY))
            continue;

        /*
         * Map the video controller address ranges we need to identify
         * our cards into the system virtual address space. If a register
         * only exists in memory-mapped form, set its I/O mapped address
         * to zero (won't be used because memory-mapped takes precedence
         * over I/O mapped).
         *
         * Initialize the mapped addresses for memory mapped registers
         * to 0 (flag to show the registers are not memory mapped) in
         * case they were initialized to a nonzero value.
         */
        for (Count=0; Count < NUM_DRIVER_ACCESS_RANGES; Count++)
            {
            if (Count < NUM_IO_REGISTERS)
                {
                if ((phwDeviceExtension->aVideoAddressIO[Count] =
                    VideoPortGetDeviceBase(phwDeviceExtension,
                        DriverIORange_cx[Count].RangeStart,
                        DriverIORange_cx[Count].RangeLength,
                        DriverIORange_cx[Count].RangeInIoSpace)) == NULL)
                    {
                    /*
                     * There was an error in mapping. Remember this
                     * so we don't try to find a Mach 64 without all
                     * the registers being mapped properly, then
                     * break out of the mapping loop. We will have
                     * another shot at mapping all the addresses
                     * when we try the next base address for the
                     * accelerator registers.
                     */
                    Status = ERROR_INVALID_PARAMETER;
                    VideoDebugPrint((DEBUG_ERROR, "Mapping error 1\n"));
                    break;
                    }
                }
            else
                {
                phwDeviceExtension->aVideoAddressIO[Count] = 0;
                }
            phwDeviceExtension->aVideoAddressMM[Count] = 0;
            }   /* End for */

        /*
         * If all I/O registers were successfully mapped, check to see
         * if a Mach 64 is present at the current base address. If it
         * is, report that we have successfully mapped our registers
         * and found a Mach 64. Since this means we have found a
         * card which is not block relocatable, we do not want to
         * look for further cards. Also, since this is the only
         * Mach 64 in the system, assume that its VGA is enabled.
         */
        if (Status == NO_ERROR)
            {
            if (DetectMach64() == MACH64_ULTRA)
                {
                FoundNonBlockCard = TRUE;
                LookForAnotherCard = 0;
                phwDeviceExtension->BiosPrefix = BIOS_PREFIX_VGA_ENAB;
                return NO_ERROR;
                }
            }

        /*
         * We did not find a Mach 64 at this base address, so unmap
         * the I/O mapped registers in preparation for trying the
         * next base address. Only unmap those registers which were
         * mapped, in case the mapping loop aborted due to a failure
         * to map one register.
         */
        for (Count = 1; Count < NUM_IO_REGISTERS; Count++)
            {
            if (phwDeviceExtension->aVideoAddressIO[Count] != 0)
                {
                VideoPortFreeDeviceBase(phwDeviceExtension,
                                        phwDeviceExtension->aVideoAddressIO[Count]);
                phwDeviceExtension->aVideoAddressIO[Count] = 0;
                }
            }

        }   /* End for (loop of base addresses) */

    /*
     * The video card in the machine isn't a Mach 64 that uses one of
     * the standard I/O base addresses. Check if it's a Mach 64 with
     * relocatable I/O.
     *
     * All our relocatable cards are PCI implementations. The code we
     * use to detect them is PCI-specific, so if the bus we are currently
     * dealing with is not PCI, don't look for relocatable cards.
     */
    if (SystemBus != PCIBus)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Not PCI bus - can't check for relocatable card\n"));
        return ERROR_DEV_NOT_EXIST;
        }

    BaseAddress = FindNextBlockATICard();

    /*
     * BaseAddress will be zero if FindNextBlockATICard()
     * couldn't find a block-relocatable ATI card.
     */
    if (BaseAddress == 0)
        {
        LookForAnotherCard = 0;
        VideoDebugPrint((DEBUG_NORMAL, "Finished checking for relocatable cards\n"));
        return ERROR_DEV_NOT_EXIST;
        }

    /*
     * We have found a block relocatable ATI card. Save its I/O base
     * address so we can (during ATIMPInitialize()) match it up to
     * the accelerator prefix for the card, and set the initial prefix
     * to show that this card needs its I/O base and accelerator prefix
     * matched.
     */
    phwDeviceExtension->BaseIOAddress = BaseAddress;
    phwDeviceExtension->BiosPrefix = BIOS_PREFIX_UNASSIGNED;
    NumBlockCardsFound++;
    VideoDebugPrint((DEBUG_NORMAL, "Block relocatable card found, I/O base 0x%X\n", BaseAddress));


    /*
     * We now have the I/O base address. Map in the I/O addresses,
     * then check to see if we have a Mach 64 card. Depending on
     * the results, either report success or unmap the addresses
     * and report failure.
     */
    VideoDebugPrint((DEBUG_DETAIL, "About to map I/O addresses\n"));
    for (VariableIndex = 0; VariableIndex < NUM_REGS_TO_BUILD; VariableIndex++)
        {
        DriverIORange_cx[VariableIndex+FIRST_REG_TO_BUILD].RangeStart.LowPart =
            BaseAddress + (RelocatableRegisterOffsets[VariableIndex] * 4);
        }

    /*
     * Claim as much as possible of our BIOS area. If we fail to
     * claim the full 64k, try restricting ourselves to 32k and
     * finally no BIOS area, only giving up on the current I/O
     * base address if we can't claim our access ranges even with
     * no BIOS area.
     */
    for (ClaimSize = InitialClaimSize; ClaimSize <= CLAIM_APERTURE_ONLY; ClaimSize++)
        {
        /*
         * Set up our VGA resource claim size.
         */
        DriverApertureRange_cx[0].RangeLength = VgaResourceSize[ClaimSize];

        /*
         * Check to see if there is a hardware resource conflict. We must save
         * the information for the first memory mapped register, copy in
         * the information for the VGA aperture (which we always need),
         * and restore the memory mapped register information after
         * we have verified that we can use the required address ranges.
         */
        VideoPortMoveMemory(&SaveFirstMM, DriverIORange_cx+VGA_APERTURE_ENTRY, sizeof(VIDEO_ACCESS_RANGE));
        VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, DriverApertureRange_cx, sizeof(VIDEO_ACCESS_RANGE));

        Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                            NUM_IO_REGISTERS + 1,
                                            DriverIORange_cx);

        VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, &SaveFirstMM, sizeof(VIDEO_ACCESS_RANGE));

        /*
         * If there is a hardware resource conflict, we are either trying
         * to claim a bigger BIOS block than we need, and someone else is
         * sitting in (and claiming as nonshareable) the "slack", or we have
         * a conflict over the I/O base address. Try the next smallest BIOS
         * block.
         *
         * If the size of the BIOS block we were able to claim
         * differs from our initial attempt, record the "maximum
         * possible BIOS block size" in the registry so that on
         * subsequent boots we won't generate event log entries
         * by claiming a BIOS region that conflicts with another
         * card.
         */
        if (Status != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Rejecting VGA aperture/BIOS block size of 0x%X bytes\n", VgaResourceSize[ClaimSize]));
            continue;
            }
        else
            {
            VideoDebugPrint((DEBUG_DETAIL, "VGA aperture/BIOS block size = 0x%X bytes\n", VgaResourceSize[ClaimSize]));
            if (FoundSafeClaim == FALSE)
                {
                FoundSafeClaim = TRUE;
                if (ClaimSize != InitialClaimSize)
                    {
                    //ClaimSize = 1;
                    VideoDebugPrint((DEBUG_DETAIL, "Writing claim size 0x%X\n", VgaResourceSize[ClaimSize]));
                    VideoPortSetRegistryParameters(phwDeviceExtension,
                                                   L"BiosClaimSize",
                                                   &ClaimSize,
                                                   sizeof(ULONG));
                    }
                }
            break;
            }
        }   /* end for (decreasing claim size) */

    /*
     * If there is a conflict over the I/O base address, we can't use
     * it. Since this is our last chance to find a Mach 64, report failure.
     */
    if (Status != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "VideoPortVerifyAccessRanges() failed in check for relocatable Mach 64\n"));
        return ERROR_DEV_NOT_EXIST;
        }

    /*
     * Map the video controller address ranges we need to identify
     * our cards into the system virtual address space. If a register
     * only exists in memory-mapped form, set its I/O mapped address
     * to zero (won't be used because memory-mapped takes precedence
     * over I/O mapped).
     *
     * Initialize the mapped addresses for memory mapped registers
     * to 0 (flag to show the registers are not memory mapped) in
     * case they were initialized to a nonzero value.
     */
    for (Count=0; Count < NUM_DRIVER_ACCESS_RANGES; Count++)
        {
        if (Count < NUM_IO_REGISTERS)
            {
            if ((phwDeviceExtension->aVideoAddressIO[Count] =
                VideoPortGetDeviceBase(phwDeviceExtension,
                    DriverIORange_cx[Count].RangeStart,
                    DriverIORange_cx[Count].RangeLength,
                    DriverIORange_cx[Count].RangeInIoSpace)) == NULL)
                {
                /*
                 * There was an error in mapping. Remember this
                 * so we don't try to find a Mach 64 without all
                 * the registers being mapped properly, then
                 * break out of the mapping loop.
                 */
                Status = ERROR_INVALID_PARAMETER;
                VideoDebugPrint((DEBUG_ERROR, "Mapping error 2\n"));
                break;
                }
            }
        else
            {
            phwDeviceExtension->aVideoAddressIO[Count] = 0;
            }
        phwDeviceExtension->aVideoAddressMM[Count] = 0;
        }   /* End for */

    /*
     * If all I/O registers were successfully mapped, check to see
     * if a Mach 64 is present at the current base address. If it
     * is, report that we have successfully mapped our registers
     * and found a Mach 64.
     */
    if (Status == NO_ERROR)
        {
        if (DetectMach64() == MACH64_ULTRA)
            {
            return NO_ERROR;
            }
        }

    /*
     * We did not find a Mach 64 at this base address, so clean
     * up after ourselves by unmapping the I/O mapped registers
     * before reporting failure. Only unmap those registers which
     * were mapped, in case the mapping loop aborted due to a
     * failure to map one register.
     */
    for (Count = 1; Count < NUM_IO_REGISTERS; Count++)
        {
        if (phwDeviceExtension->aVideoAddressIO[Count] != 0)
            {
            VideoPortFreeDeviceBase(phwDeviceExtension,
                                    phwDeviceExtension->aVideoAddressIO[Count]);
            phwDeviceExtension->aVideoAddressIO[Count] = 0;
            }
        }


    /*
     * We haven't found a Mach 64 at any of the allowable base addresses,
     * so report that there is no Mach 64 in the machine.
     */
    VideoDebugPrint((DEBUG_NORMAL, "No Mach 64 found at this address\n"));
    return ERROR_DEV_NOT_EXIST;

}   /* CompatIORangesUsable_cx() */

/***************************************************************************
 *
 * VP_STATUS CompatMMRangesUsable_cx(void);
 *
 * DESCRIPTION:
 *  Ask Windows NT for permission to use the memory mapped registers
 *  needed by the 68800CX accelerator.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if unable to gain access to the ranges we need.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS CompatMMRangesUsable_cx(void)
{
    PHYSICAL_ADDRESS MMrange;   /* Used in translating offset to memory address */
    ULONG RegisterOffset;       /* Offset of memory mapped registers start of address space */
    int Count;                  /* Loop counter */
    struct query_structure *QueryPtr;  /* Query information for the card */
    UCHAR InIOSpace;
#if defined (ALPHA)
    ULONG Scratch;
#endif


    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * Set the offset of the memory mapped registers from the start of
     * the aperture to the appropriate value for the aperture size
     * being used.
     */
    if ((QueryPtr->q_aperture_cfg & BIOS_AP_SIZEMASK) == BIOS_AP_8M)
        RegisterOffset = phwDeviceExtension->PhysicalFrameAddress.LowPart + OFFSET_8M;
    else if ((QueryPtr->q_aperture_cfg & BIOS_AP_SIZEMASK) == BIOS_AP_4M)
        RegisterOffset = phwDeviceExtension->PhysicalFrameAddress.LowPart + OFFSET_4M;
    else
        RegisterOffset = OFFSET_VGA;

    /*
     * We are working in a 32 bit address space, so the upper DWORD
     * of the quad word address is always zero.
     */
    MMrange.HighPart = 0;

#if defined (ALPHA)
    /*
     * All Alpha systems are capable of supporting sparse space
     * (normal memory mapped space for the Alpha). Newer systems
     * (those that have PCI buses) are also able to support dense
     * space, but older systems can't. In almost all cases, non-PCI
     * cards are a sign that we are using an older system, but
     * assuming this is an older system when it is actually an ISA
     * card in a newer system is mostly harmless (slight performance
     * penalty). Assuming that dense space is available on all Alpha
     * systems will crash a Jensen (older system).
     */
    if (QueryPtr->q_bus_type == BUS_PCI)
        InIOSpace = 4; // DENSE Space
    else
        InIOSpace = 0;

    /*
     * The GX-F ASIC has a bug where burst reads of a quadword of
     * memory will result in the high doubleword being corrupted.
     * The memory-mapped form of CONFIG_CHIP_ID is the high doubleword,
     * and on the Alpha in dense space (on PCI cards we always use
     * dense space for our memory-mapped registers) all read access
     * to memory is by quadwords, so we will run into the burst mode
     * problem. The I/O mapped form of this register is safe to use.
     */
    Scratch = INPD(CONFIG_CHIP_ID);
    if (((Scratch & CONFIG_CHIP_ID_TypeMask) == CONFIG_CHIP_ID_TypeGX) &&
        ((Scratch & CONFIG_CHIP_ID_RevMask) == CONFIG_CHIP_ID_RevF))
        {
        VideoDebugPrint((DEBUG_DETAIL, "GX-F detected, must use I/O mapped form of CRTC_OFF_PITCH\n"));
        DriverMMRange_cx[CRTC_OFF_PITCH].RangeStart.HighPart = DONT_USE;
        }
#else
    InIOSpace = 0; // memory mapped I/O Space
#endif

    for (Count=1; Count < NUM_DRIVER_ACCESS_RANGES;  Count++)
        {
        /*
         * In a 32-bit address space, the high doubleword of all
         * physical addresses is zero. Setting this value to DONT_USE
         * indicates that this accelerator register isn't memory mapped.
         */
        if (DriverMMRange_cx[Count].RangeStart.HighPart != DONT_USE)
            {
            /*
             * DriverMMRange_cx[Count].RangeStart.LowPart is the offset
             * (in doublewords) of the memory mapped register from the
             * beginning of the block of memory mapped registers. We must
             * convert this to bytes, add the offset of the start of the
             * memory mapped register area from the start of the aperture
             * and the physical address of the start of the linear
             * framebuffer to get the physical address of this
             * memory mapped register.
             */
            MMrange.LowPart = (DriverMMRange_cx[Count].RangeStart.LowPart * 4) + RegisterOffset;
            phwDeviceExtension->aVideoAddressMM[Count] =
                VideoPortGetDeviceBase(phwDeviceExtension,  
                    MMrange,
                    DriverMMRange_cx[Count].RangeLength,
                    InIOSpace);                     // not in IO space

            /*
             * If we were unable to claim the memory-mapped version of
             * this register, and it exists only in memory-mapped form,
             * then we have a register which we can't access. Report
             * this as an error condition.
             */
            if ((phwDeviceExtension->aVideoAddressMM[Count] == 0) &&
                (DriverIORange_cx[Count].RangeStart.HighPart == DONT_USE))
                {
                VideoDebugPrint((DEBUG_ERROR, "Mapping error 3\n"));
                return ERROR_INVALID_PARAMETER;
                }
            }
        }

    VideoDebugPrint((DEBUG_DETAIL, "CompatMMRangesUsable_cx() succeeded\n"));
    return NO_ERROR;

}   /* CompatMMRangesUsable_cx() */




/***************************************************************************
 *
 * int WaitForIdle_cx(void);
 *
 * DESCRIPTION:
 *  Poll GUI_STAT waiting for GuiActive field to go low. If it does not go
 *  low within 3 seconds (arbitrary value, but no operation should take
 *  that long), time out.
 *
 * RETURN VALUE:
 *  FALSE if timeout
 *  TRUE  if engine is idle
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Any 68800CX-specific routine may call this routine.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

int WaitForIdle_cx(void)
{
    int	i;
    ULONG Scratch;

    for (i=0; i<300; i++)
        {
        if ((INPD(GUI_STAT) & GUI_STAT_GuiActive) == 0)
            return TRUE;

        /*
         * Wait 1/100th of a second
         */
        delay(10);
        }

    /*
     * Something has happened, so reset the engine and return FALSE.
     */
    VideoDebugPrint((DEBUG_ERROR, "ATI: Timeout on WaitForIdle_cx()\n"));
    Scratch = INPD(GEN_TEST_CNTL) & ~GEN_TEST_CNTL_GuiEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    Scratch |= GEN_TEST_CNTL_GuiEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    return FALSE;

}   /* WaitForIdle_cx() */



/***************************************************************************
 *
 * void CheckFIFOSpace_cx(SpaceNeeded);
 *
 * WORD SpaceNeeded;    Number of free FIFO entries needed
 *
 * DESCRIPTION:
 *  Wait until the specified number of FIFO entries are free
 *  on a 68800CX-compatible ATI accelerator.
 *
 *  If the specified number of entries does not become free in
 *  3 seconds (arbitrary value greater than any operation should
 *  take), assume the engine has locked and reset it.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Any 68800CX-specific routine may call this routine.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void CheckFIFOSpace_cx(WORD SpaceNeeded)
{
    ULONG LoopCount;
    ULONG Scratch;

    for (LoopCount = 0; LoopCount < 300; LoopCount++)
        {
        /*
         * Return from test if enough entries are free
         */
        if (!(INPD(FIFO_STAT)&SpaceNeeded))
            return;

        /*
         * Wait 1/100th of a second
         */
        delay(10);
        }

    /*
     * Something has happened, so reset the engine and return FALSE.
     */
    VideoDebugPrint((DEBUG_ERROR, "ATI: Timeout on CheckFIFOSpace_cx()\n"));
    Scratch = INPD(GEN_TEST_CNTL) & ~GEN_TEST_CNTL_GuiEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    Scratch |= GEN_TEST_CNTL_GuiEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    return;

}   /* CheckFIFOSpace_cx() */



/*
 * BOOL IsApertureConflict_cx(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Check to see if the linear aperture conflicts with other memory.
 * If a conflict exists, disable the linear aperture.
 *
 * Returns:
 *  TRUE if a conflict exists (aperture unusable)
 *  FALSE if the aperture is usable.
 */
BOOL IsApertureConflict_cx(struct query_structure *QueryPtr)
{
DWORD Scratch;                      /* Used in manipulating registers */
VP_STATUS Status;                   /* Return value from VideoPortVerifyAccessRanges() */
VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
VIDEO_ACCESS_RANGE SaveFirstMM[2];  /* Place to save the first two memory mapped registers */
USHORT VariableIndex;               /* Index into array of variable part of register array */

    /*
     * Set up by disabling the memory boundary (must be disabled in order
     * to access accelerator memory through the VGA aperture).
     */
    Scratch = INPD(MEM_CNTL);
    Scratch &= ~MEM_CNTL_MemBndryEn;
    OUTPD(MEM_CNTL, Scratch);

    /*
     * If there is an aperture conflict, a call to
     * VideoPortVerifyAccessRanges() including our linear framebuffer in
     * the range list will return an error. If there is no conflict, it
     * will return success.
     *
     * We must save the contents of the first 2 memory mapped register
     * entries, copy in the aperture ranges (VGA and linear) we need
     * to claim, then restore the memory mapped entries after we
     * have verified that we can use the aperture(s).
     *
     * DriverIORange_cx[] contains the physical addresses of the registers
     * for the last card we have dealt with. In a single-card setup, this
     * is no problem, but in a multi-card setup we must re-load this
     * array with the physical addresses of the card we want to claim
     * the aperture for.
     */
    if (NumBlockCardsFound > 1)
        {
        for (VariableIndex = 0; VariableIndex < NUM_REGS_TO_BUILD; VariableIndex++)
            {
            DriverIORange_cx[VariableIndex+FIRST_REG_TO_BUILD].RangeStart.LowPart =
                phwDeviceExtension->BaseIOAddress + (RelocatableRegisterOffsets[VariableIndex] * 4);
            }
        }
    DriverApertureRange_cx[LFB_ENTRY].RangeStart.LowPart = QueryPtr->q_aperture_addr*ONE_MEG;
    if ((QueryPtr->q_aperture_cfg & BIOS_AP_SIZEMASK) == BIOS_AP_8M)
        DriverApertureRange_cx[LFB_ENTRY].RangeLength = 8*ONE_MEG;
    else
        DriverApertureRange_cx[LFB_ENTRY].RangeLength = 4*ONE_MEG;

    VideoPortMoveMemory(SaveFirstMM, DriverIORange_cx+VGA_APERTURE_ENTRY, 2*sizeof(VIDEO_ACCESS_RANGE));
    VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, DriverApertureRange_cx, 2*sizeof(VIDEO_ACCESS_RANGE));

    Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                         NUM_IO_REGISTERS+2,
                                         DriverIORange_cx);
    if (Status != NO_ERROR)
        {
        /*
         * If there is an aperture conflict, reclaim our I/O ranges without
         * asking for the LFB. This call should not fail, since we would not
         * have reached this point if there were a conflict.
         */
        Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                             NUM_IO_REGISTERS+1,
                                             DriverIORange_cx);
        if (Status != NO_ERROR)
            VideoDebugPrint((DEBUG_ERROR, "ERROR: Can't reclaim I/O ranges\n"));

        VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, SaveFirstMM, 2*sizeof(VIDEO_ACCESS_RANGE));
        ISAPitchAdjust(QueryPtr);
        return TRUE;
        }
    else
        {
        VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, SaveFirstMM, 2*sizeof(VIDEO_ACCESS_RANGE));

        /*
         * There is no aperture conflict, so enable the linear aperture.
         */
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_APERTURE;
        Registers.Ecx = BIOS_LINEAR_APERTURE;
        VideoPortInt10(phwDeviceExtension, &Registers);

        return FALSE;
        }

}   /* IsApertureConflict_cx() */



/***************************************************************************
 *
 * USHORT GetIOBase_cx(void);
 *
 * DESCRIPTION:
 *  Get the I/O base address being used by this card.
 *
 * RETURN VALUE:
 *  I/O base register
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Any 68800CX-specific routine may call this routine after
 *  CompatIORangesUsable_cx() has returned success. Results
 *  are undefined if this routine is called either before
 *  CompatIORangesUsable_cx() is called, or after it retunrs
 *  failure.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

USHORT GetIOBase_cx(void)
{

    /*
     * CRTC_H_TOTAL_DISP is at offset 0 from the base address.
     * In a single-card setup, after CompatIORangesUsable_cx()
     * returns, the value in
     * DriverIORange_cx[CRTC_H_TOTAL_DISP].RangeStart.LowPart
     * will be either the I/O base address in use (returned
     * success) or the last I/O base address tried (returned
     * failure).
     *
     * In a multi-card setup, this value will hold the I/O base
     * for the last card which was set up, but the I/O base for
     * each card is stored in its hardware device extension
     * structure. This second storage location is not guaranteed
     * for single-card setups, so use the DriverIORange location
     * for them.
     */
    if (NumBlockCardsFound > 1)
        return (USHORT)(phwDeviceExtension->BaseIOAddress);
    else
        return (USHORT)(DriverIORange_cx[CRTC_H_TOTAL_DISP].RangeStart.LowPart);

}   /* GetIOBase_cx() */



/***************************************************************************
 *
 * BOOL IsPackedIO_cx(void);
 *
 * DESCRIPTION:
 *  Report whether or not we are using packed (relocatable) I/O.
 *
 * RETURN VALUE:
 *  TRUE if using packed I/O
 *  FALSE if using sparse I/O
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Any 68800CX-specific routine may call this routine after
 *  CompatIORangesUsable_cx() has returned success. Results
 *  are undefined if this routine is called either before
 *  CompatIORangesUsable_cx() is called, or after it retunrs
 *  failure.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL IsPackedIO_cx(void)
{

    /*
     * CRTC_H_TOTAL_DISP and CRTC_H_SYNC_STRT_WID are the registers
     * with the lowest I/O addresses (CRTC_H_TOTAL_DISP is at
     * offset 0 from the base address). If we are using packed I/O,
     * the DriverIORange_cx[].RangeStart.LowPart entries for these
     * two registers will differ by 4 bytes, while if we are using
     * normal (sparse) I/O, they will differ by 0x400 bytes.
     */
    if (DriverIORange_cx[CRTC_H_SYNC_STRT_WID].RangeStart.LowPart -
        DriverIORange_cx[CRTC_H_TOTAL_DISP].RangeStart.LowPart == 4)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Reporting dense I/O\n"));
        return TRUE;
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "Reporting sparse I/O\n"));
        return FALSE;
        }

}   /* IsPackedIO_cx() */



/***************************************************************************
 *
 * ULONG FindNextBlockATICard(void);
 *
 * DESCRIPTION:
 *  Find the next Mach 64 which uses block relocatable I/O.
 *
 * RETURN VALUE:
 *  I/O base address if card is found
 *  0 if no card is found
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  CompatIORangesUsable_cx()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static ULONG FindNextBlockATICard(void)
{
    PCI_COMMON_CONFIG ConfigData;   /* Configuration information about PCI device */
    PCI_SLOT_NUMBER SlotNumber;     /* PCI slot under test */
    static ULONG DeviceNumber=0;    /* PCI device number */
    static ULONG FunctionNumber=0;  /* PCI function number */
    ULONG BaseAddress=0;            /* I/O base address */
    ULONG RetVal;                   /* Value returned by function calls */

    /*
     * The PCI_SLOT_NUMBER union allows 32 slot numbers with 8
     * function numbers each. The upper 24 bits are reserved.
     */
    while (DeviceNumber < 32)
        {
        while (FunctionNumber < 8)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Checking device 0x%X function 0x%X\n", DeviceNumber, FunctionNumber));
            SlotNumber.u.bits.DeviceNumber = DeviceNumber;
            SlotNumber.u.bits.FunctionNumber = FunctionNumber;
            SlotNumber.u.bits.Reserved = 0;
            ConfigData.VendorID = PCI_INVALID_VENDORID;

            RetVal = VideoPortGetBusData(phwDeviceExtension,
                                        PCIConfiguration,
                                        SlotNumber.u.AsULONG,
                                        &ConfigData,
                                        0,
                                        PCI_COMMON_HDR_LENGTH);
            FunctionNumber++;

            /*
             * If we received an error return, skip to the
             * next possible slot.
             */
            if (RetVal != PCI_COMMON_HDR_LENGTH)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Error return 0x%X, skipping to next slot\n", RetVal));
                continue;
                }

            /*
             * If this is not an ATI card, we are not interested.
             * Instead, go on to the next candidate.
             */
            VideoDebugPrint((DEBUG_DETAIL, "Vendor ID = 0x%X\n", ConfigData.VendorID));
            if (ConfigData.VendorID != 0x1002)
                continue;

            /*
             * We have found an ATI card. On all our block-relocatable
             * cards, we must mask off the lowest order bit of the
             * reported address, since this is always reported as 1
             * (I/O space), but its actual value is always 0.
             *
             * Not all ATI PCI cards are block-relocatable Mach 64
             * cards. Since we only look for block-relocatable cards
             * if we have failed to find a fixed-base Mach 64, we can
             * safely assume that any Mach 64 we find is block-relocatable.
             *
             * Despite this assumption, we must still distinguish Mach 64
             * cards from non-Mach 64 cards, either by recognizing and
             * accepting all Mach 64 device IDs and rejecting other
             * device IDs, or by recognizing and rejecting all non-Mach 64
             * device IDs and accepting other device IDs. The latter
             * route is safer, since new device IDs are more likely
             * to be Mach 64 than non-Mach 64, and this route will
             * not falsely reject new Mach 64 cards. Currently, our
             * only non-Mach 64 PCI card is the Mach 32 AX.
             *
             * Resetting BaseAddress to zero for non-Mach 64 cards
             * will result in the same treatment as for non-ATI
             * cards, i.e. we will treat the current slot as not
             * containing a block-relocatable Mach 64, and search
             * the next slot.
             */
            BaseAddress = (ConfigData.u.type0.BaseAddresses[PCI_ADDRESS_IO_SPACE]) & 0xFFFFFFFE;
            VideoDebugPrint((DEBUG_NORMAL, "Found card with device ID 0x%X\n", ConfigData.DeviceID));
            switch (ConfigData.DeviceID)
                {
                case ATI_DEVID_M32AX:
                    VideoDebugPrint((DEBUG_NORMAL, "Mach 32 AX card found, skipping it\n"));
                    BaseAddress = 0;
                    break;

                // GT, exclude GTBs
                case 0x4754:

                    if ((ConfigData.RevisionID == 0x9A) ||
                        (ConfigData.RevisionID == 0x5A) ||
                        (ConfigData.RevisionID == 0x1A) ||
                        (ConfigData.RevisionID == 0x19) ||
                        (ConfigData.RevisionID == 0x41) ||
                        (ConfigData.RevisionID == 0x01))
                        {
                        VideoDebugPrint((DEBUG_NORMAL, "Rejecting GT card with revision ID 0x%X, treating as Mach 64\n", ConfigData.RevisionID));
                        BaseAddress = 0;
                        continue;
                        }

                    VideoDebugPrint((DEBUG_NORMAL, "Found ATI card with device ID 0x%X, treating as Mach 64\n", ConfigData.DeviceID));
                    break;

                // VT, exclude VTBs
                case 0x5654:

                    if ((ConfigData.RevisionID == 0x9A) ||
                        (ConfigData.RevisionID == 0x5A) ||
                        (ConfigData.RevisionID == 0x01))
                        {
                        VideoDebugPrint((DEBUG_NORMAL, "Rejecting VT card with revision ID 0x%X, treating as Mach 64\n", ConfigData.RevisionID));
                        BaseAddress = 0;
                        continue;
                        }

                    VideoDebugPrint((DEBUG_NORMAL, "Found ATI card with device ID 0x%X, treating as Mach 64\n", ConfigData.DeviceID));
                    break;

                // Other supported PCI chips.
                case 0x00D7: // mach64 GX
                case 0x0057: // mach64 CX
                case 0x4354: /* CT */
                case 0x4554: /* ET */
                case 0x4C54: /* LT */
                case 0x4D54: /* MT */
                case 0x5254: /* RT */
                case 0x3354: /* 3T */
                VideoDebugPrint((DEBUG_NORMAL, "Found ATI card with device ID 0x%X, treating as Mach 64\n", ConfigData.DeviceID));

                    break;

                default:
                    VideoDebugPrint((DEBUG_NORMAL, "Unsupported ATI card with device ID 0x%X\n", ConfigData.DeviceID));
                    continue;

                }

            /*
             * We will only reach this point if we find an ATI card.
             * If it is a block-relocatable card, BaseAddress will
             * be set to the I/O base address, and we must get out
             * of the loop. If it is not a block-relocatable card,
             * BaseAddress will be zero, and we must continue looking.
             */
            if (BaseAddress != 0)
                break;

            }   /* end while (FunctionNumber < 8) */

        /*
         * If we have found a Mach 64 relocatable card, we will have
         * broken out of the inner loop, but we will still be in the
         * outer loop. Since BaseAddress is zero if we have not found
         * a card, and nonzero if we have found one, check this value
         * to determine whether we should break out of the outer loop.
         */
        if (BaseAddress != 0)
            break;

        VideoDebugPrint((DEBUG_DETAIL, "Finished inner loop, zeroing function number and incrementing device number\n"));
        FunctionNumber = 0;
        DeviceNumber++;

        }   /* end while (DeviceNumber < 32) */

    return BaseAddress;

}   /* FindNextBlockATICard() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\setup_m.c ===
/************************************************************************/
/*                                                                      */
/*                              SETUP_M.C                               */
/*                                                                      */
/*        Aug 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.11  $
      $Date:   23 Jan 1996 11:52:14  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/setup_m.c_v  $
 *
 *    Rev 1.11   23 Jan 1996 11:52:14   RWolff
 * Eliminated level 3 warnings.
 *
 *    Rev 1.10   31 Mar 1995 11:52:06   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.9   14 Mar 1995 18:17:18   ASHANMUG
 * Reset engine on fifo space check time-out.
 *
 *    Rev 1.8   14 Mar 1995 15:59:42   ASHANMUG
 * Timeout on idle check and fifo check.
 *
 *    Rev 1.7   08 Mar 1995 11:35:50   ASHANMUG
 * Modified return values to be correct
 *
 *    Rev 1.5   22 Jul 1994 17:47:28   RWOLFF
 * Merged with Richard's non-x86 code stream.
 *
 *    Rev 1.4   06 Jul 1994 16:41:00   RWOLFF
 * Changed a few loops that I missed for the last checkin to use
 * NUM_IO_ACCESS_RANGES instead of NUM_DRIVER_ACCESS_RANGES.
 *
 *    Rev 1.3   30 Jun 1994 18:23:14   RWOLFF
 * Moved IsApertureConflict_m() from QUERY_M.C. Instead of checking to see if
 * we can read back a value we write to the aperture, then looking for the
 * correct text attribute, we now call VideoPortVerifyAccessRanges() with
 * the LFB included in the list of address ranges we are trying to claim.
 * If the call succeeds, the aperture is enabled. If it fails, we make another
 * call that does not try to claim the LFB (this call shouldn't fail, since
 * it's a duplicate of a call which has succeeded previously). Added routine
 * IsVGAConflict_m(), which does the same thing except for the VGA aperture
 * instead of the LFB.
 *
 *    Rev 1.2   14 Mar 1994 16:36:42   RWOLFF
 * Functions used by ATIMPResetHw() are not pageable.
 *
 *    Rev 1.1   07 Feb 1994 14:14:48   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 *
 *    Rev 1.0   31 Jan 1994 11:20:58   RWOLFF
 * Initial revision.
 *
 *    Rev 1.4   14 Jan 1994 15:26:36   RWOLFF
 * Fixed de-initialization of memory mapped registers, added routine
 * to see if memory mapped registers are available.
 *
 *    Rev 1.3   15 Dec 1993 16:02:26   RWOLFF
 * No longer allows use of memory mapped registers on EISA machines,
 * starts mapping of memory mapped registers at index 0 due to removal
 * of placeholder for linear framebuffer.
 *
 *    Rev 1.2   05 Nov 1993 13:32:36   RWOLFF
 * Can now unmap I/O address ranges.
 *
 *    Rev 1.1   08 Oct 1993 11:18:24   RWOLFF
 * Now checks to see if memory mapped registers can be used, and unmaps them
 * if they aren't usable (NCR Dual Pentium fix).
 *
 *    Rev 1.0   03 Sep 1993 14:25:36   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SETUP_M.C - Setup routines for 8514/A compatible accelerators.

DESCRIPTION
    This file contains routines which provide services specific to
    the 8514/A-compatible family of ATI accelerators.

OTHER FILES

#endif

#include "dderror.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"

#include "services.h"
#define INCLUDE_SETUP_M
#include "setup_m.h"


/*
 * Allow miniport to be swapped out when not needed.
 *
 * WaitForIdle_m() is called by ATIMPResetHw(), which
 * must be in nonpageable memory.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, CompatIORangesUsable_m)
#pragma alloc_text(PAGE_M, CompatMMRangesUsable_m)
#pragma alloc_text(PAGE_M, UnmapIORanges_m)
#pragma alloc_text(PAGE_M, MemoryMappedEnabled_m)
#pragma alloc_text(PAGE_M, CheckFIFOSpace_m)
#pragma alloc_text(PAGE_M, IsApertureConflict_m)
#pragma alloc_text(PAGE_M, IsVGAConflict_m)
#endif



/*
 * VP_STATUS CompatIORangesUsable_m(void);
 *
 * Ask Windows NT for permission to use the I/O space address ranges
 * needed by the 8514/A compatible ATI accelerators.
 *
 * Returns:
 *  NO_ERROR if successful
 *  error code if unable to gain access to the ranges we need.
 */
VP_STATUS CompatIORangesUsable_m(void)
{
    VP_STATUS Status;   /* Value returned by operating system calls */
    short Count;        /* Loop counter */


    /*
     * Check to see if there is a hardware resource conflict.
     */
    Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                         NUM_IO_ACCESS_RANGES,
                                         DriverIORange_m);
    if (Status != NO_ERROR)
        {
        return Status;
        }

    /*
     * Clear the list of I/O mapped registers. This is done so
     * that if the loop below fails because one I/O range can't
     * be mapped, and we need to unmap these registers before,
     * mapping the registers needed for another accelerator type,
     * we don't unmap nonexistant address ranges due to the
     * array of processed addresses containing random data.
     */
    memset(phwDeviceExtension->aVideoAddressIO, 0, NUM_IO_ACCESS_RANGES * sizeof(ULONG));

    /*
     * Map the video controller address ranges we need to identify
     * our cards into the system virtual address space.
     *
     * Since we only use I/O mapped registers here, set the
     * mapped addresses for memory mapped registers to
     * 0 (flag to show the registers are not memory mapped)
     * in case they were initialized to a nonzero value.
     */
    for (Count=0; Count < NUM_IO_ACCESS_RANGES; Count++)
        {
        if ((phwDeviceExtension->aVideoAddressIO[Count] =
            VideoPortGetDeviceBase(phwDeviceExtension,
                DriverIORange_m[Count].RangeStart,
                DriverIORange_m[Count].RangeLength,
                DriverIORange_m[Count].RangeInIoSpace)) == NULL)
            {
            return ERROR_INVALID_PARAMETER;
            }
        phwDeviceExtension->aVideoAddressMM[Count] = 0;
        }   /* End for */

    return NO_ERROR;

}   /* CompatIORangesUsable_m() */

/*
 * void CompatMMRangesUsable_m(void);
 *
 * Ask Windows NT for permission to use the memory mapped registers
 * needed by the 8514/A compatible ATI accelerators.
 */
void CompatMMRangesUsable_m(void)
{
    PHYSICAL_ADDRESS MMrange;   /* Used in translating offset to memory address */
    USHORT USTemp;              /* Used to enable memory mapped registers */
    int Count;                  /* Loop counter */
    WORD SrcX;                  /* Saved contents of SRC_X register */
    ULONG_PTR ExtGeStatusMM;    /* Memory mapped address for EXT_GE_STATUS */
    struct query_structure *QueryPtr;   /* Query information for the card */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * Memory mapped registers are not available on EISA cards.
     */
    if (QueryPtr->q_bus_type == BUS_EISA)
        {
        return;
        }

    /*
     * ALPHA machines crash during the test to see whether memory-mapped
     * registers are usable, so on these machines we assume that
     * memory-mapped registers are not available.
     */
#if defined (ALPHA) || defined (_ALPHA_)
    return;
#endif

    /*
     * Use an I/O mapped read on the register we're going to use to see
     * if memory mapped registers are usable, because if they aren't usable
     * we won't get a valid result if we wait until we've enabled
     * memory mapped registers before reading it.
     */
    SrcX = INPW(R_SRC_X);

    USTemp = INPW(LOCAL_CONTROL);
    USTemp |= 0x0020;   // Enable memory mapped registers
    OUTPW(LOCAL_CONTROL, USTemp);
    MMrange.HighPart = 0;

    for (Count=0; Count < NUM_IO_ACCESS_RANGES;  Count++)
        {
        /*
         * In a 32-bit address space, the high doubleword of all
         * physical addresses is zero. Setting this value to DONT_USE
         * indicates that this accelerator register isn't memory mapped.
         */
        if (DriverMMRange_m[Count].RangeStart.HighPart != DONT_USE)
            {
            /*
             * DriverMMRange_m[Count].RangeStart.LowPart is the offset of
             * the memory mapped register from the beginning of the
             * block of memory mapped registers. We must add the offset
             * of the start of the memory mapped register area from
             * the start of the linear framebuffer (4M aperture assumed)
             * and the physical address of the start of the linear
             * framebuffer to get the physical address of this
             * memory mapped register.
             */
            MMrange.LowPart = DriverMMRange_m[Count].RangeStart.LowPart + 0x3FFE00 + phwDeviceExtension->PhysicalFrameAddress.LowPart;
            phwDeviceExtension->aVideoAddressMM[Count] =
                VideoPortGetDeviceBase(phwDeviceExtension,
                    MMrange,
                    DriverMMRange_m[Count].RangeLength,
                    FALSE);                     // not in IO space
            }
        }

    /*
     * Some cards use an ASIC which is capable of using memory mapped
     * registers, but an older board design which doesn't allow their
     * use. To test this, check whether the SRC_X register (this register
     * is available as memory mapped on any card which is capable of
     * supporting memory mapped registers) remembers a value that is written
     * to it. If it doesn't, then undo the memory mapping, since this
     * test shows that memory mapped registers are not available.
     */
    VideoDebugPrint((DEBUG_DETAIL, "About to test whether memory mapped registers can be used\n"));
    OUTPW(SRC_X, 0x0AAAA);

    /*
     * WaitForIdle_m() uses the EXT_GE_STATUS register, which is handled
     * as memory mapped if available. Since we don't know if memory mapped
     * registers are available, work around this by saving the address
     * of the memory mapped EXT_GE_STATUS register, setting the address
     * to zero to force the use of the I/O mapped EXT_GE_STATUS, then
     * restoring the address after WaitForIdle_m() has finished.
     */
    ExtGeStatusMM = (ULONG_PTR) phwDeviceExtension->aVideoAddressMM[EXT_GE_STATUS];
    phwDeviceExtension->aVideoAddressMM[EXT_GE_STATUS] = 0;
    WaitForIdle_m();
    phwDeviceExtension->aVideoAddressMM[EXT_GE_STATUS] = (PVOID) ExtGeStatusMM;

    if (INPW(R_SRC_X) != 0x02AA)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Can't use memory mapped ranges\n"));
        for (Count = 0; Count < NUM_IO_ACCESS_RANGES; Count++)
            {
            if (phwDeviceExtension->aVideoAddressMM[Count] != 0)
                {
                VideoPortFreeDeviceBase(phwDeviceExtension,
                                        phwDeviceExtension->aVideoAddressMM[Count]);
                phwDeviceExtension->aVideoAddressMM[Count] = 0;
                }
            }
        USTemp = INPW(LOCAL_CONTROL);
        USTemp &= 0x0FFDF;              /* Disable memory mapped registers */
        OUTPW(LOCAL_CONTROL, USTemp);
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "Memory mapped registers are usable\n"));
        }
    OUTPW(SRC_X, SrcX);
    VideoDebugPrint((DEBUG_DETAIL, "Memory mapped register test complete\n"));

    return;

}   /* CompatMMRangesUsable_m() */



/***************************************************************************
 *
 * void UnmapIORanges_m(void);
 *
 * DESCRIPTION:
 *  Unmap the I/O address ranges mapped by CompatIORangesUsable_m() prior
 *  to mapping the I/O address ranges used by a non-8514/A-compatible
 *  ATI accelerator.
 *
 * GLOBALS CHANGED:
 *  phwDeviceExtension->aVideoAddressIO[]
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void UnmapIORanges_m(void)
{
    short Count;    /* Loop counter */

    for (Count=1; Count < NUM_IO_ACCESS_RANGES;  Count++)
        {
        /*
         * Only unmap those ranges which have been mapped. We don't need
         * to worry about unmapping nonexistant addresses (due to
         * uninitialized data) if CompatIORangesUsable_m() failed
         * partway through mapping because this routine initialized all
         * phwDeviceExtension->aVideoAddressIO[] entries to zero
         * before it started mapping the I/O ranges.
         */
        if (phwDeviceExtension->aVideoAddressIO[Count] != 0)
            {
            VideoPortFreeDeviceBase(phwDeviceExtension,
                                    phwDeviceExtension->aVideoAddressIO[Count]);
            phwDeviceExtension->aVideoAddressIO[Count] = 0;
            }
        }
    return;

}   /* UnmapIORanges_m() */



/***************************************************************************
 *
 * BOOL MemoryMappedEnabled_m(void);
 *
 * DESCRIPTION:
 *  Check to see whether we are using memory mapped registers.
 *
 * RETURN VALUE:
 *  TRUE if memory mapped registers are available
 *  FALSE if they are not
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  May be called by any function after CompatMMRangesUsable_m()
 *  has been called.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL MemoryMappedEnabled_m(void)
{
    /*
     * If memory mapped registers are enabled, EXT_GE_STATUS will be
     * available in memory mapped form.
     */
    if (phwDeviceExtension->aVideoAddressMM[EXT_GE_STATUS] != 0)
        return TRUE;
    else
        return FALSE;

}   /* MemoryMappedEnabled_m() */




/*
 * int WaitForIdle_m(void);
 *
 * Poll GE_STAT waiting for GE_BUSY to go low. If GE_BUSY does not go
 * low within a reasonable number of attempts, time out.
 *
 * Returns:
 *  FALSE if timeout: 3 seconds is an arbitrary value
 *  TRUE  if engine is idle
 */
int WaitForIdle_m(void)
{
    int	i;

    for (i=0; i<300; i++)
        {
        if ((INPW(EXT_GE_STATUS) & GE_ACTIVE) == 0)
            return(TRUE);

        /* Delay for 1/100th of a second */
        delay(10);
        }

    /* Something has happened, reset the engine and return false */
    VideoDebugPrint((DEBUG_ERROR, "ATI: Timeout on WaitForIdle_m()\n"));
    OUTPW(SUBSYS_CNTL, 0x900F);
    OUTPW(SUBSYS_CNTL, 0x500F);

    return(FALSE);

}   /* WaitForIdle_m() */



/*
 * void CheckFIFOSpace_m(SpaceNeeded);
 *
 * WORD SpaceNeeded;    Number of free FIFO entries needed
 *
 * Wait until the specified number of FIFO entries are free
 * on an 8514/A-compatible ATI accelerator.
 *
 * Timeout after 3 seconds
 */
void CheckFIFOSpace_m(WORD SpaceNeeded)
{
    int i;

    for (i=0; i<300; i++)
        {
        /* Return from test if no more space is needed */
        if ( !(INPW(EXT_FIFO_STATUS)&SpaceNeeded) )
            return;

        delay(10);
        }

    /* Something bad has happened, just return */
    VideoDebugPrint((DEBUG_ERROR, "ATI: Timeout on CheckFIFOSpace_m()\n"));
    OUTPW(SUBSYS_CNTL, 0x900F);
    OUTPW(SUBSYS_CNTL, 0x500F);
    return;

}   /* CheckFIFOSpace_m() */



/*
 * BOOL IsApertureConflict_m(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Check to see if the linear aperture conflicts with other memory.
 * If a conflict exists, disable the linear aperture.
 *
 * Returns:
 *  TRUE if a conflict exists (aperture unusable)
 *  FALSE if the aperture is usable.
 */
BOOL IsApertureConflict_m(struct query_structure *QueryPtr)
{
WORD ApertureData;                  /* Value read from MEM_CFG register */
VP_STATUS Status;                   /* Return value from VideoPortVerifyAccessRanges() */

    /*
     * If there is an aperture conflict, a call to
     * VideoPortVerifyAccessRanges() including our linear framebuffer in
     * the range list will return an error. If there is no conflict, it
     * will return success.
     */
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeStart.LowPart = QueryPtr->q_aperture_addr*ONE_MEG;
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeLength = 4*ONE_MEG;
    Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                         NUM_DRIVER_ACCESS_RANGES,
                                         DriverIORange_m);
    if (Status != NO_ERROR)
        {
        /*
         * If there is an aperture conflict, reclaim our I/O ranges without
         * asking for the LFB. This call should not fail, since we would not
         * have reached this point if there were a conflict.
         */
        Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                             NUM_IO_ACCESS_RANGES,
                                             DriverIORange_m);
        if (Status != NO_ERROR)
            VideoDebugPrint((DEBUG_ERROR, "ERROR: Can't reclaim I/O ranges\n"));

        /*
         * Adjust the list of mode tables to take into account the
         * fact that we're using the VGA aperture instead of the LFB.
         */
        ISAPitchAdjust(QueryPtr);
        return TRUE;
        }
    else
        {
        /*
         * Enable the linear aperture
         */
        ApertureData = INPW(MEM_CFG) & 0x0fffc;     /* Preserve bits 2-15 */
        ApertureData |= 0x0002;                     /* 4M aperture        */
        OUTPW(MEM_CFG, ApertureData);

        return FALSE;
        }

}   /* IsApertureConflict_m() */



/*
 * BOOL IsVGAConflict_m(void);
 *
 * Check to see if the VGA aperture conflicts with other memory.
 *
 * Returns:
 *  TRUE if a conflict exists (VGA aperture unusable)
 *  FALSE if the VGA aperture is usable.
 */
BOOL IsVGAConflict_m(void)
{
VP_STATUS Status;                   /* Return value from VideoPortVerifyAccessRanges() */

    /*
     * If there is an aperture conflict, a call to
     * VideoPortVerifyAccessRanges() including the VGA aperture in
     * the range list will return an error. If there is no conflict, it
     * will return success.
     */
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeStart.LowPart = 0xA0000;
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeLength = 0x10000;
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeShareable = TRUE;
    Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                         NUM_DRIVER_ACCESS_RANGES,
                                         DriverIORange_m);
    if (Status != NO_ERROR)
        {
        /*
         * If there is an aperture conflict, reclaim our I/O ranges without
         * asking for the LFB. This call should not fail, since we would not
         * have reached this point if there were a conflict.
         */
        Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                             NUM_IO_ACCESS_RANGES,
                                             DriverIORange_m);
        if (Status != NO_ERROR)
            VideoDebugPrint((DEBUG_ERROR, "ERROR: Can't reclaim I/O ranges\n"));

        return TRUE;
        }
    else
        {
        return FALSE;
        }

}   /* IsVGAConflict_m() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\query_m.c ===
/************************************************************************/
/*                                                                      */
/*                              QUERY_M.C                               */
/*                                                                      */
/*  Copyright (c) 1992, ATI Technologies Incorporated.                  */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.24  $
    $Date:   01 May 1996 14:11:40  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/query_m.c_v  $
 * 
 *    Rev 1.24   01 May 1996 14:11:40   RWolff
 * Locked out 24BPP on Alpha.
 * 
 *    Rev 1.23   23 Apr 1996 17:27:24   RWolff
 * Expanded lockout of 800x600 16BPP 72Hz to all Mach 32 cards, since
 * some VRAM cards are also affected.
 * 
 *    Rev 1.22   12 Apr 1996 16:16:36   RWolff
 * Now rejects 24BPP modes if linear aperture is not present, since new
 * source stream display driver can't do 24BPP in a paged aperture. This
 * rejection should be done in the display driver (the card still supports
 * the mode, but the display driver doesn't want to handle it), but at
 * the point where the display driver must decide to either accept or reject
 * modes, it doesn't have access to the aperture information.
 * 
 *    Rev 1.21   10 Apr 1996 17:02:04   RWolff
 * Locked out 800x600 16BPP 72Hz on DRAM cards, fix for checking
 * resolution-dependent special cases against a value which is
 * only set if the mode is installed.
 * 
 * 
 *    Rev 1.20   23 Jan 1996 11:48:12   RWolff
 * Eliminated level 3 warnings, protected against false values of
 * TARGET_BUILD, added debug print statements, now assumes DEC Alpha
 * has a 2M card since the memory size check routine generates a
 * false value (4M) on this platform.
 * 
 *    Rev 1.19   11 Jan 1996 19:37:10   RWolff
 * Added maximum pixel clock rate to all calls to SetFixedModes().
 * This is required as part of a Mach 64 fix.
 * 
 *    Rev 1.18   20 Jul 1995 17:58:56   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.17   31 Mar 1995 11:52:36   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 * 
 *    Rev 1.16   14 Mar 1995 15:59:58   ASHANMUG
 * Check wait for idle status before continuing block write test.
 * This fixes an Intel AX problem where the engine was hanging.
 * 
 *    Rev 1.15   23 Dec 1994 10:47:42   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.14   18 Nov 1994 11:44:22   RWOLFF
 * Now detects STG1702/1703 DACs in native mode, added support for
 * split rasters.
 * 
 *    Rev 1.13   19 Aug 1994 17:13:16   RWOLFF
 * Added support for SC15026 DAC, Graphics Wonder, non-standard pixel
 * clock generators, and 1280x1024 70Hz and 74Hz.
 * 
 *    Rev 1.12   22 Jul 1994 17:48:24   RWOLFF
 * Merged with Richard's non-x86 code stream.
 * 
 *    Rev 1.11   30 Jun 1994 18:21:06   RWOLFF
 * Removed routine IsApertureConflict_m() (moved to SETUP_M.C), no longer
 * enables aperture while querying the card (aperture is now enabled in
 * IsApertureConflict_m() after we find that there is no conflict).
 * 
 *    Rev 1.10   15 Jun 1994 11:08:34   RWOLFF
 * Now lists block write as unavailable on DRAM cards, gives correct
 * vertical resolution if CRT parameters are stored in skip-1-2 format
 * (as is the case on some Graphics Ultra cards which were upgraded from
 * 512k to 1M) instead of the normal skip-2 format.
 * 
 *    Rev 1.9   20 May 1994 19:19:38   RWOLFF
 * No longer inserts phantom 16BPP mode table for resolutions where
 * 16BPP can be supported but which are not configured.
 * 
 *    Rev 1.8   20 May 1994 16:08:44   RWOLFF
 * Fix for 800x600 screen tearing on Intel BATMAN PCI motherboards.
 * 
 *    Rev 1.7   20 May 1994 14:02:58   RWOLFF
 * Ajith's change: no longer falsely detects NCR dual Pentium MCA card
 * as being susceptible to MIO bug.
 * 
 *    Rev 1.6   12 May 1994 11:17:44   RWOLFF
 * For Mach 32, now lists predefined refresh rates as available instead of
 * only the refresh rate stored in EEPROM, no longer makes 1024x768 87Hz
 * interlaced available if no 1024x768 mode configured, since the predefined
 * rates will allow all resolutions even on uninstalled cards.
 * For all cards, writes refresh rate to mode tables.
 * 
 *    Rev 1.5   27 Apr 1994 13:56:30   RWOLFF
 * Added routine IsMioBug_m() which checks to see if card has multiple
 * input/output bug.
 * 
 *    Rev 1.4   26 Apr 1994 12:43:44   RWOLFF
 * Put back use of 1024x768 interlaced when no 1024 resolution installed,
 * no longer uses 32BPP.
 * 
 *    Rev 1.3   31 Mar 1994 15:07:16   RWOLFF
 * Added debugging code.
 * 
 *    Rev 1.2   08 Feb 1994 19:01:32   RWOLFF
 * Removed unused routine get_num_modes_m(), no longer makes 1024x768 87Hz
 * interlaced available if Mach 32 card is configured with 1024x768
 * set to "Not installed".
 * 
 *    Rev 1.1   07 Feb 1994 14:03:26   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed, removed routine GetMemoryNeeded_m() which was only called
 * by LookForSubstitute(), a routine removed from ATIMP.C.
 * 
 *    Rev 1.0   31 Jan 1994 11:12:34   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.7   24 Jan 1994 18:08:16   RWOLFF
 * Now fills in 16 and 24 BPP mode tables for BT48x and AT&T 49[123] DACs
 * using dedicated (and undocumented) mode tables in the EEPROM rather
 * than expecting the mode set routine to multiply the pixel clock from
 * the 8BPP mode tables.
 * 
 *    Rev 1.6   14 Jan 1994 15:25:32   RWOLFF
 * Uses defined values for bus types, added routine to see if block write
 * mode is available.
 * 
 *    Rev 1.5   15 Dec 1993 15:28:14   RWOLFF
 * Added support for SC15021 DAC, hardcoded aperture location for
 * DEC ALPHA (BIOS can't initialize the registers).
 * 
 *    Rev 1.4   30 Nov 1993 18:28:44   RWOLFF
 * Added support for AT&T 498 DAC, removed dead code.
 * 
 *    Rev 1.3   10 Nov 1993 19:26:00   RWOLFF
 * GetTrueMemSize_m() now handles 1M cards correctly, doesn't depend on the
 * VGA aperture being available.
 * 
 *    Rev 1.2   05 Nov 1993 13:26:34   RWOLFF
 * Added support for PCI bus and STG1700 DAC.
 * 
 *    Rev 1.1   08 Oct 1993 11:13:40   RWOLFF
 * Added routine to get true amount of memory needed for a particular mode
 * on 8514/A-compatible ATI accelerators, and fix for BIOS bug that reports
 * less than the true amount of memory in MEM_SIZE_ALIAS field of MISC_OPTIONS.
 * 
 *    Rev 1.0   24 Sep 1993 11:52:28   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.0   03 Sep 1993 14:24:08   RWOLFF
 * Initial revision.
        
           Rev 1.0   16 Aug 1993 13:28:54   Robert_Wolff
        Initial revision.
        
           Rev 1.31   06 Jul 1993 15:52:08   RWOLFF
        No longer sets mach32_split_fixup (support for non-production hardware).
        
           Rev 1.30   24 Jun 1993 16:18:18   RWOLFF
        Now inverts COMPOSITE_SYNC bit of m_clock_select field on Mach 8 cards,
        since the EEPROM holds the value to use when using the shadow sets and
        we use the primrary CRT register set. Now takes the proper byte of
        EEPROM word 0x13 when calculating the clock select for 1280x1024
        on an 8514/ULTRA.
        
           Rev 1.29   18 Jun 1993 16:09:40   RWOLFF
        Fix for 68800 Rev. 3 hardware problem (screen pitch must be a multiple of
        128 pixels, but no symptoms exhibited except at high colour depths with
        fast pixel clock).
        
           Rev 1.28   10 Jun 1993 15:55:18   RWOLFF
        Now uses static buffer rather than dynamic allocation for CRT
        parameter read by BIOS function call.
        Change originated by Andre Vachon at Microsoft.
        
           Rev 1.27   07 Jun 1993 11:44:00   BRADES
        Rev 6 split transfer fixup.
        
           Rev 1.25   12 May 1993 16:33:42   RWOLFF
        Changed test order for aperture calculations to avoid trouble due to
        undefined bits being 1 instead of 0.
        
           Rev 1.24   10 May 1993 16:39:28   RWOLFF
        Now recognizes maximum pixel depth of each possible DAC at all supported
        resolutions rather than assuming that TI34075 can handle 32 BPP at all
        resolutions while all other DACs can do 16 BPP at all resolutions but
        can't do 24 BPP.
        
           Rev 1.23   30 Apr 1993 16:42:24   RWOLFF
        Buffer for CRT parameter read via BIOS call is now dynamically allocated.
        
           Rev 1.22   24 Apr 1993 16:32:24   RWOLFF
        Now recognizes that 800x600 8BPP is not available on Mach 8 cards with
        512k of accelerator memory, Mach 32 ASIC revision number is now recorded
        as the value read from the "revision code" register rather than the chip
        revision (i.e. Rev. 3 chip is recorded as Rev. 0), no longer falls back to
        56Hz in 800x600 16BPP on 1M Mach 32 cards.
        
           Rev 1.21   21 Apr 1993 17:33:38   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        Added include file for error definitions.
        Added function to fill in the CRT tables on a Mach 32 using the BIOS
        function call <video segment>:006C if extended BIOS functions are available.
        
           Rev 1.20   15 Apr 1993 13:35:58   BRADES
        will not report a mode if Mach32 and 1 Meg and 1280 res.
        add ASIC revision from register.
        
           Rev 1.19   25 Mar 1993 11:21:50   RWOLFF
        Brought a function header comment up to date, assumes that 1024x768
        87Hz interlaced is available if no 1024x768 mode is configured,
        query functions return failure if no EEPROM is present. It is assumed
        that an absent EEPROM will produce a read value of 0xFFFF, and the
        check is made at the start of mode table filling so the remainder
        of the query structure will contain valid data in the fields our
        driver uses.
        
           Rev 1.18   21 Mar 1993 15:58:28   BRADES
        use 1024 pitch for Mach32 if using VGA aperture.
        
           Rev 1.17   16 Mar 1993 17:00:54   BRADES
        Set Pitch to 1024 on the Mach32 for 640 and 800 resolutions.
        Allows VGA bank mgr to function.
        
           Rev 1.16   15 Mar 1993 22:21:04   BRADES
        use m_screen_pitch for the # pixels per display line
        
           Rev 1.15   08 Mar 1993 19:30:10   BRADES
        clean up, submit to MS NT
        
           Rev 1.13   19 Jan 1993 09:35:38   Robert_Wolff
        Removed commented-out code.
        
           Rev 1.12   13 Jan 1993 13:46:16   Robert_Wolff
        Added support for the Corsair and other machines where the aperture
        location is not kept in the EEPROM.
        
           Rev 1.11   06 Jan 1993 11:06:04   Robert_Wolff
        Eliminated dead code and compile warnings.
        
           Rev 1.10   24 Dec 1992 14:38:02   Chris_Brady
        fix up warnings
        
           Rev 1.9   09 Dec 1992 10:28:48   Robert_Wolff
        Mach 8 information gathering routines now accept a parameter to
        indicate whether 1280x1024 mode table should be ignored. This is
        because on cards with an old BIOS which can't do 1280x1024, the
        same mode table is used for 132 column text mode, so if we don't
        ignore the mode table we'd generate a garbage entry in the query
        structure.
        
           Rev 1.8   02 Dec 1992 18:26:08   Robert_Wolff
        On a Mach32 card with 1M of memory and 800x600 installed for
        a noninterlaced mode with a vertical frequency other than 56Hz,
        force the mode table for 800x600 16 bits per pixel to use the
        parameters for the 56Hz (lowest vertical frequency available for
        800x600) mode in the Programmer's Guide to the Mach 32 Registers.
        This is done because this hardware is unable to deliver video data
        fast enough to do 800x600 16 BPP in noninterlaced modes with a
        higher vertical frequency than 56Hz.
        
           Rev 1.7   27 Nov 1992 18:39:16   Chris_Brady
        update ASIC rev to 3.
        
           Rev 1.6   25 Nov 1992 09:37:58   Robert_Wolff
        Routine s_query() now accepts an extra parameter which tells it to
        check for modes available when VGA boundary is set to shared, rather
        than left at its current value. This is for use with programs that force
        the boundary to shared, so that they will have access to all modes.
        
           Rev 1.5   20 Nov 1992 16:01:52   Robert_Wolff
        Functions Query8514Ultra() and QueryGUltra() are now
        available to Windows NT driver.
        
           Rev 1.4   17 Nov 1992 17:16:18   Robert_Wolff
        Fixed gathering of CRT parameters for 68800 card with minimal
        install (EEPROM blank, then predefined monitor type selected).
        
           Rev 1.3   13 Nov 1992 17:10:20   Robert_Wolff
        Now includes 68801.H, which consists of the now-obsolete MACH8.H
        and elements moved from VIDFIND.H.
        
           Rev 1.2   12 Nov 1992 17:10:32   Robert_Wolff
        Same source file can now be used for both Windows NT driver and
        VIDEO.EXE test program. Code specific to one or the other is
        under conditional compilation.
        
           Rev 1.1   06 Nov 1992 19:04:28   Robert_Wolff
        Moved prototypes for routines to initialize DAC to specified pixel
        depths to VIDFIND.H.
    
           Rev 1.0   05 Nov 1992 14:03:40   Robert_Wolff
        Initial revision.
        
           Rev 1.4   15 Oct 1992 16:26:36   Robert_Wolff
        Now builds one mode table for each resolution/colour depth
        combination, rather than one for each resolution. Mode tables
        no longer trash memory beyond the query structure.
        
           Rev 1.3   01 Oct 1992 17:31:08   Robert_Wolff
        Routines get_num_modes() and s_query() now count only those modes
        which are available with the monitor selected in "Power on configuration"
        when the install program is run.
        
           Rev 1.2   01 Oct 1992 15:23:54   Robert_Wolff
        Now handles the case where EEPROM values are stored in VGA format
        rather than 8514 format, Mach 32 card with shared memory now reports
        VGA boundary as 0 rather than -256.
        
           Rev 1.1   09 Sep 1992 17:42:40   Chris_Brady
        CRTC table for Graphics Ultra NOT enabled if == 0xFFFF
        
           Rev 1.0   02 Sep 1992 12:12:26   Chris_Brady
        Initial revision.
        

End of PolyTron RCS section                             *****************/

#ifdef DOC
    QUERY_M.C - Functions to find out the configuration of 8514/A-compatible
                ATI accelerators.

#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"

#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#include "eeprom.h"

#define INCLUDE_QUERY_M
#include "modes_m.h"
#include "query_m.h"
#include "services.h"
#include "setup_m.h"

/*
 * String written to the aperture to see if we can read it back, and
 * its length (including the null terminator).
 */
#define APERTURE_TEST       "ATI"
#define APERTURE_TEST_LEN   4

//  
// HACK to remove call to exallocate pool
//  

UCHAR gBiosRaw[QUERYSIZE];

//----------------------------------------------------------------------
//  Local  Prototyping statements

static void short_query_m (struct query_structure *query, struct st_eeprom_data *ee);
short   fill_mode_table_m (WORD, struct st_mode_table *, struct st_eeprom_data *);
BOOL BiosFillTable_m(short, PUCHAR, struct st_mode_table *, struct query_structure *);
static UCHAR BrooktreeOrATT_m(void);
static void ClrDacCmd_m(BOOL ReadIndex);
static BOOL ChkATTDac_m(BYTE MaskVal);
static UCHAR ThompsonOrATT_m(void);
static UCHAR SierraOrThompson_m(void);
short GetTrueMemSize_m(void);
void SetupRestoreEngine_m(int DesiredStatus);
USHORT ReadPixel_m(short XPos, short YPos);
void WritePixel_m(short XPos, short YPos, short Colour);
void SetupRestoreVGAPaging_m(int DesiredStatus);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, Query8514Ultra)
#pragma alloc_text(PAGE_M, QueryGUltra)
#pragma alloc_text(PAGE_M, short_query_m)
#pragma alloc_text(PAGE_M, QueryMach32)
#pragma alloc_text(PAGE_M, fill_mode_table_m)
#pragma alloc_text(PAGE_M, BiosFillTable_m)
#pragma alloc_text(PAGE_M, BrooktreeOrATT_m)
#pragma alloc_text(PAGE_M, ChkATTDac_m)
#pragma alloc_text(PAGE_M, ClrDacCmd_m)
#pragma alloc_text(PAGE_M, ThompsonOrATT_m)
#pragma alloc_text(PAGE_M, SierraOrThompson_m)
#pragma alloc_text(PAGE_M, GetTrueMemSize_m)
#pragma alloc_text(PAGE_M, SetupRestoreEngine_m)
#pragma alloc_text(PAGE_M, ReadPixel_m)
#pragma alloc_text(PAGE_M, WritePixel_m)
#pragma alloc_text(PAGE_M, BlockWriteAvail_m)
#pragma alloc_text(PAGE_M, IsMioBug_m)
#endif



//----------------------------------------------------------------------
//                        Query8514Ultra
//  
//  Fill in the query structure with the eeprom and register info
//  for the 8514/Ultra  adapters.
//
//  Returns:
//      NO_ERROR if successful
//      ERROR_DEV_NOT_EXIST if unable to read EEPROM
//  

VP_STATUS Query8514Ultra (struct query_structure *query)
{
//  8514/Ultra initially only supported 1024x768 and 640x480.
//  Later 800x600 and then 1280x1024 support was added.

struct st_eeprom_data *ee = phwDeviceExtension->ee;
BOOL    is800, is1280;
WORD    jj, kk;
struct st_mode_table *pmode;    /* CRT table parameters */
long    MemAvail;   /* Bytes of memory available for the accelerator */
struct st_mode_table    ThisRes;    /* Mode table for the given resolution */


    query->q_structure_rev      = 0;
    query->q_mode_offset        = sizeof(struct query_structure);
    query->q_sizeof_mode        = sizeof(struct st_mode_table);
    query->q_status_flags       = 0;            // will indicate resolutions 

    query->q_mouse_cfg = 0;             // no MOUSE
    query->q_DAC_type  = DAC_ATI_68830; // one DAC type similar to 68830
    query->q_aperture_addr = 0;         // no aperture address
    query->q_aperture_cfg  = 0;         // no aperture configuration
    query->q_asic_rev  = CI_38800_1;    // only one ASIC revision  

    query->q_VGA_type = 0;              // 8514_ONLY == no VGA ever installed
    query->q_VGA_boundary = 0;      /* No VGA, so accelerator gets all the memory */

    kk = INPW (CONFIG_STATUS_1);
    query->q_memory_size = (kk & MEM_INSTALLED) ? VRAM_1mb : VRAM_512k;
    query->q_memory_type = (kk & DRAM_ENA) ? VMEM_DRAM_256Kx4 : VMEM_VRAM_256Kx4_SER512; 

    if (kk & MC_BUS)                    // is microchannel bus
        query->q_bus_type = BUS_MC_16;  // 16 bit bus
    else
        query->q_bus_type = kk & BUS_16 ? BUS_ISA_16 : BUS_ISA_8;

    /*
     * We don't use the q_monitor_alias field, so plug in a typical
     * value rather than reading it from the EEPROM, in case we are
     * dealing with a card that doesn't have an EEPROM.
     */
    query->q_monitor_alias = 0x0F;
    query->q_shadow_1  = 0;             // do not know what to put here
    query->q_shadow_2  = 0;

    /*
     * Record the number of bytes available for the coprocessor, so we
     * can determine what pixel depths are available at which resolutions.
     */
    MemAvail = (query->q_memory_size == VRAM_1mb) ? ONE_MEG : HALF_MEG;

    /*
     * If the EEPROM is not present, we can't fill in the mode
     * tables. Return and let the user know that the mode tables
     * have not been filled in.
     */
    if (query->q_eeprom == FALSE)
        return ERROR_DEV_NOT_EXIST;

    /*
     * Fill in the mode tables. The mode tables are sorted in increasing
     * order of resolution, and in increasing order of pixel depth.
     * Ensure pmode is initialized to the END of query structure
     */
    pmode = (struct st_mode_table *) query;
    ((struct query_structure *) pmode)++;

    /*
     * Initially assume 640x480 4BPP.
     */
    query->q_number_modes = 1;
    query->q_status_flags |= VRES_640x480;

    ThisRes.control = 0x140;    // no equal to 68800 CRT 0 entry
    ThisRes.m_reserved = 3;     /* Put EEPROM base address here, shadow sets are combined */
    jj = (ee->EEread) (3);      /* Composite and Vfifo */
    kk = (ee->EEread) (4);      /* Clock select and divisor */
    ThisRes.m_clock_select = ((jj & 0x1F) << 8) | ((kk & 0x003F) << 2);
    ThisRes.ClockFreq = GetFrequency((BYTE)((ThisRes.m_clock_select & 0x007C) >> 2));

    /*
     * The COMPOSITE_SYNC bit of the m_clock_select field is set up
     * to handle composite sync with shadow sets. We use the primrary
     * CRT register set, so we must invert it.
     */
    ThisRes.m_clock_select ^= 0x1000;

    kk = (ee->EEread) (17);                     // H_total
    ThisRes.m_h_total =  kk & 0xFF;
    kk = (ee->EEread) (16);                     // H_display
    ThisRes.m_h_disp  =  kk & 0xFF;
    ThisRes.m_x_size  = (ThisRes.m_h_disp+1) * 8;
    ThisRes.m_screen_pitch = ThisRes.m_x_size;

    kk = (ee->EEread) (15);                     // H_sync_strt
    ThisRes.m_h_sync_strt =  kk & 0xFF;

    kk = (ee->EEread) (14);                     // H_sync_width
    ThisRes.m_h_sync_wid  =  kk & 0xFF;

    kk = (ee->EEread) (7);                      // V_sync_width
    ThisRes.m_v_sync_wid =  kk & 0xFF;

    kk = (ee->EEread) (6);                      // Display_cntl
    ThisRes.m_disp_cntl  =  kk & 0xFF;

    ThisRes.m_v_total = (ee->EEread) (13);
    ThisRes.m_v_disp  = (ee->EEread) (11);
    ThisRes.m_y_size  = (((ThisRes.m_v_disp >> 1) & 0xFFFC) | (ThisRes.m_v_disp & 0x03)) +1;

    ThisRes.m_v_sync_strt = (ee->EEread) (9);

    ThisRes.enabled  = 0x80;            // use stored values from eeprom

    ThisRes.m_status_flags = 0;

    ThisRes.m_h_overscan  = 0;     // not supported
    ThisRes.m_v_overscan  = 0;
    ThisRes.m_overscan_8b = 0;
    ThisRes.m_overscan_gr = 0;
    ThisRes.m_vfifo_24    = 0;   
    ThisRes.m_vfifo_16    = 0;
    ThisRes.Refresh       = DEFAULT_REFRESH;

    /*
     * Copy the mode table we have just built into the 4 BPP
     * mode table, and fill in the pixel depth field.
     */
    VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
    pmode->m_pixel_depth = 4;
    pmode++;

    /*
     * We don't support 640x480 256 colour minimum mode, so 8BPP
     * is only available on 1M cards.
     */
    if (query->q_memory_size == VRAM_1mb)
        {
        VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
        pmode->m_pixel_depth = 8;
        pmode++;
        query->q_number_modes++;
        }

    /*
     * Look for more mode tables defined.  Original 8514 did not define these
     *   -- undefined if = 0xFFFF
     *
     * Some cards with a BIOS too early to support 1280x1024 use the
     * same mode table for 132 column text mode. On these cards,
     * query->q_ignore1280 will be TRUE when this function is called.
     */
    kk = (ee->EEread) (20);             // are 800 and 1280 defined ??
    jj = kk & 0xFF00;                   // 1280 by 1024
    kk &= 0xFF;                         // 800 by 600
    if ((kk == 0) || (kk == 0xFF))
        is800 = FALSE;
    else
        is800 = TRUE;
    if ((jj == 0) || (jj == 0xFF00) || (query->q_ignore1280 == TRUE))
        is1280 = FALSE;
    else
        is1280 = TRUE;

    /*
     * If we support 800x600, fill in its mode tables. Both 4 and 8 BPP
     * can be handled by a 512k card.
     */
    if (is800)
        {
        query->q_status_flags |= VRES_800x600;

        ThisRes.control  = 0x140;                // no equal to 68800 CRT 0 entry
        ThisRes.m_reserved = 19;                 // shadow sets are combined

        jj = (ee->EEread) (19);                  // Composite and Vfifo
        kk = (ee->EEread) (20);                  // clock select and divisor
        ThisRes.m_clock_select = ((jj & 0x1F) << 8) | ((kk & 0x003F) << 2);
        ThisRes.m_clock_select ^= 0x1000;
        ThisRes.ClockFreq = GetFrequency((BYTE)((ThisRes.m_clock_select & 0x007C) >> 2));
    
        kk = (ee->EEread) (30);                  // H_total
        ThisRes.m_h_total = kk & 0xFF;
        kk = (ee->EEread) (29);                  // H_display
        ThisRes.m_h_disp  = kk & 0xFF;
        ThisRes.m_x_size  = (ThisRes.m_h_disp+1) * 8;
        // Mach8 must be a multiple of 128
        ThisRes.m_screen_pitch = 896;    
    
        kk = (ee->EEread) (28);                  // H_sync_strt
        ThisRes.m_h_sync_strt = kk & 0xFF;
    
        kk = (ee->EEread) (27);                  // H_sync_width
        ThisRes.m_h_sync_wid  = kk & 0xFF;
    
        kk = (ee->EEread) (23);                  // V_sync_width
        ThisRes.m_v_sync_wid = kk & 0xFF;
    
        kk = (ee->EEread) (22);                  // Display_cntl
        ThisRes.m_disp_cntl  = kk & 0xFF;
    
        ThisRes.m_v_total = (ee->EEread) (26);
        ThisRes.m_v_disp  = (ee->EEread) (25);
        ThisRes.m_y_size  = (((ThisRes.m_v_disp >> 1) & 0xFFFC) | (ThisRes.m_v_disp & 0x03)) +1;
    
        ThisRes.m_v_sync_strt = (ee->EEread) (24);
    
        ThisRes.enabled  = 0x80;       // use stored values from eeprom

        ThisRes.m_status_flags = 0;
        ThisRes.m_h_overscan  = 0;     // not supported
        ThisRes.m_v_overscan  = 0;
        ThisRes.m_overscan_8b = 0;
        ThisRes.m_overscan_gr = 0;
        ThisRes.m_vfifo_24    = 0;   
        ThisRes.m_vfifo_16    = 0;
        ThisRes.Refresh       = DEFAULT_REFRESH;

        /*
         * Copy the mode table we have just built into the 4 and 8 BPP
         * mode tables, and fill in the pixel depth field of each.
         */
        VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
        pmode->m_pixel_depth = 4;
        pmode++;
        query->q_number_modes++;
        /*
         * 800x600 8BPP needs 1M because it is actually 896x600
         * (screen pitch must be a multiple of 128).
         */
        if (MemAvail == ONE_MEG)
            {
            VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
            pmode->m_pixel_depth = 8;
            pmode++;
            query->q_number_modes++;
            }
        }

    /*
     * Take care of 1024x768, which is always supported (even though
     * a 512k card can only do 4 BPP).
     */
    query->q_status_flags |= VRES_1024x768;

    ThisRes.control = 0x140;    // no equal to 68800 CRT 0 entry
    ThisRes.m_reserved = 3;     /* Put EEPROM base address here, shadow sets are combined */
    ThisRes.enabled  = 0x80;    /* Use stored values from EEPROM */

    kk = (ee->EEread) (16);                     // H_display
    ThisRes.m_h_disp  = (kk >> 8) & 0xFF;

    /*
     * An 8514/ULTRA configured for a monitor which does not support
     * 1024x768 will have the 640x480 parameters in the high-res
     * shadow set. Force the use of 1024x768 87Hz interlaced instead.
     */
    if (ThisRes.m_h_disp != 0x7F)
        {
        BookVgaTable(B1024F87, &ThisRes);
        ThisRes.m_screen_pitch = ThisRes.m_x_size;
        }
    else{
        /*
         * Configured for a monitor which supports 1024x768,
         * so use actual parameters.
         */
        jj = (ee->EEread) (3);                  /* Composite and Vfifo */
        kk = (ee->EEread) (4);                  /* Clock select and divisor */
        ThisRes.m_clock_select = (jj & 0x1F00) | ((kk & 0x3F00) >> 6);
        ThisRes.m_clock_select ^= 0x1000;
        ThisRes.ClockFreq = GetFrequency((BYTE)((ThisRes.m_clock_select & 0x007C) >> 2));

        kk = (ee->EEread) (17);                 // H_total
        ThisRes.m_h_total = (kk >> 8) & 0xFF;
        ThisRes.m_x_size  = (ThisRes.m_h_disp+1) * 8;
        ThisRes.m_screen_pitch = ThisRes.m_x_size;

        kk = (ee->EEread) (15);                 // H_sync_strt
        ThisRes.m_h_sync_strt = (kk >> 8) & 0xFF;

        kk = (ee->EEread) (14);                 // H_sync_width
        ThisRes.m_h_sync_wid  = (kk >> 8) & 0xFF;

        kk = (ee->EEread) (7);                  // V_sync_width
        ThisRes.m_v_sync_wid = (kk >> 8) & 0xFF;

        kk = (ee->EEread) (6);                  // Display_cntl
        ThisRes.m_disp_cntl  = (kk >> 8) & 0xFF;

        ThisRes.m_v_total = (ee->EEread) (12);
        ThisRes.m_v_disp  = (ee->EEread) (10);
        ThisRes.m_y_size  = (((ThisRes.m_v_disp >> 1) & 0xFFFC) | (ThisRes.m_v_disp & 0x03)) +1;

        ThisRes.m_v_sync_strt = (ee->EEread) (8);

        ThisRes.m_status_flags = 0;

        ThisRes.m_h_overscan  = 0;     // not supported
        ThisRes.m_v_overscan  = 0;
        ThisRes.m_overscan_8b = 0;
        ThisRes.m_overscan_gr = 0;
        ThisRes.m_vfifo_24    = 0;   
        ThisRes.m_vfifo_16    = 0;
        }

    ThisRes.Refresh = DEFAULT_REFRESH;

    /*
     * Copy the mode table we have just built into the 4 and 8 BPP
     * mode tables.
     */
    VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
    pmode->m_pixel_depth = 4;
    pmode++;
    query->q_number_modes++;

    if (MemAvail == ONE_MEG)            // 1024 needs this memory amount
        {
        VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
        pmode->m_pixel_depth = 8;
        pmode++;
        query->q_number_modes++;
        }

    // Finally do 1280x1024. 4 bpp is the only color depth supported
    if (is1280 && (MemAvail == ONE_MEG))
        {
        query->q_number_modes++;
        query->q_status_flags |= VRES_1280x1024;

        pmode->control  = 0x140;                // no equal to 68800 CRT 0 entry
        pmode->m_pixel_depth = 4;               // 4 bits per pixel
        pmode->m_reserved = 19;                 // shadow sets are combined

        jj = (ee->EEread) (19);                 // Composite and Vfifo
        kk = (ee->EEread) (20);                 // clock select and divisor
        pmode->m_clock_select = (jj & 0x1F00) | ((kk & 0x3F00) >> 6);
        pmode->m_clock_select ^= 0x1000;
        ThisRes.ClockFreq = GetFrequency((BYTE)((ThisRes.m_clock_select & 0x007C) >> 2));
    
        kk = (ee->EEread) (30);                 // H_total
        pmode->m_h_total = (kk >> 8) & 0xFF;
        kk = (ee->EEread) (29);                 // H_display
        pmode->m_h_disp  = (kk >> 8) & 0xFF;
        pmode->m_x_size  = (pmode->m_h_disp+1) * 8;
        pmode->m_screen_pitch = pmode->m_x_size;
    
        kk = (ee->EEread) (28);                 // H_sync_strt
        pmode->m_h_sync_strt = (kk >> 8) & 0xFF;
    
        kk = (ee->EEread) (27);                 // H_sync_width
        pmode->m_h_sync_wid  = (kk >> 8) & 0xFF;
    
        kk = (ee->EEread) (23);                 // V_sync_width
        pmode->m_v_sync_wid = (kk >> 8) & 0xFF;
    
        kk = (ee->EEread) (22);                 // Display_cntl
        pmode->m_disp_cntl  = (kk >> 8) & 0xFF;
    
        pmode->m_v_total = (ee->EEread) (51);
        pmode->m_v_disp  = (ee->EEread) (50);
        pmode->m_y_size  = (((pmode->m_v_disp >> 1) & 0xFFFC) | (pmode->m_v_disp & 0x03)) +1;
    
        pmode->m_v_sync_strt = (ee->EEread) (49);
    
        pmode->enabled  = 0x80;       // use stored values from eeprom

        pmode->m_status_flags = 0;
        pmode->m_h_overscan  = 0;     // not supported
        pmode->m_v_overscan  = 0;
        pmode->m_overscan_8b = 0;
        pmode->m_overscan_gr = 0;
        pmode->m_vfifo_24    = 0;   
        pmode->m_vfifo_16    = 0;
        pmode->Refresh       = DEFAULT_REFRESH;
        }

    query->q_sizeof_struct = query->q_number_modes * sizeof(struct st_mode_table) + sizeof(struct query_structure);

    return NO_ERROR;

}   /* Query8514Ultra */



//----------------------------------------------------------------------
//                        QueryGUltra
//  
//  Fill in the query structure with the eeprom and register info
//  for the Graphics Ultra  adapters.  (Similar to Mach32 layout)
//  There are a maximum of 7 mode tables, two each for 640x480,
//  800x600, and 1024x768, and one for 1280x1024.
//
//  Returns:
//      NO_ERROR if successful
//      ERROR_DEV_NOT_EXIST if EEPROM read fails
//  

VP_STATUS QueryGUltra (struct query_structure *query)
{

struct st_eeprom_data *ee = phwDeviceExtension->ee;
short   crttable[4] = {13, 24, 35, 46};         // start of eeprom crt table
WORD    ee_value, table_offset,  jj, kk, ee_word;
BYTE    bhigh, blow;
struct st_mode_table *pmode;                    // CRT table parameters
short   VgaTblEntry;    /* VGA parameter table entry to use if translation needed */
short   BookTblEntry;   /* Appendix D parameter table entry to use if parameters not in EEPROM */
long    NumPixels;  /* Number of pixels at the selected resolution */
long    MemAvail;   /* Bytes of memory available for the accelerator */
struct st_mode_table    ThisRes;    /* Mode table for the given resolution */
BYTE    VgaMem;     /* Code for amount of VGA memory on board */


    query->q_structure_rev      = 0;
    query->q_mode_offset        = sizeof(struct query_structure);
    query->q_sizeof_mode        = sizeof(struct st_mode_table);
    query->q_status_flags       = 0;            // will indicate resolutions

    /*
     * We don't use the q_mouse_cfg field, so fill in a typical value
     * (mouse disabled) rather than reading from the EEPROM in case we
     * are dealing with a card without an EEPROM.
     */
    kk = 0x0000;
    bhigh    = (kk >> 8) & 0xFF;
    blow     = kk & 0xFF;
    query->q_mouse_cfg = (bhigh >> 3) | ((blow & 0x18) >> 1);    // mouse configuration

    query->q_DAC_type  = DAC_ATI_68830; // one DAC type similar to 68830
    query->q_aperture_addr = 0;         // no aperture address
    query->q_aperture_cfg  = 0;         // no aperture configuration
    query->q_asic_rev  = CI_38800_1;    // only one ASIC revision  

    query->q_VGA_type = 1;              // VGA always Enabled

    OUTP (ati_reg, 0xB0);		    // find out how much VGA memory
    VgaMem = INP(ati_reg+1);
    switch (VgaMem & 0x18)
        {
        case 0x00:          
            jj =  256;      
            query->q_VGA_boundary = VRAM_256k;
            break;

        case 0x10:          
            jj =  512;      
            query->q_VGA_boundary = VRAM_512k;
            break;

        case 0x08:          
            jj = 1024;      
            query->q_VGA_boundary = VRAM_1mb; 
            break;

        default:            // assume most likely VGA amount
            jj = 512;
            query->q_VGA_boundary = VRAM_512k;
            break;
        }

    kk = INPW (CONFIG_STATUS_1);
    query->q_memory_type = kk & DRAM_ENA ? VMEM_DRAM_256Kx4 : VMEM_VRAM_256Kx4_SER512; 
    jj += (kk & MEM_INSTALLED) ? 1024 : 512;            // 8514 memory
    switch (jj)
        {
        case  0x300:
            jj = VRAM_768k;
            MemAvail = HALF_MEG;            // Accelerator amount
            break;

        case  0x400:
            jj = VRAM_1mb;
            MemAvail = HALF_MEG;            // Accelerator amount
            break;

        case  0x500:
            jj = VRAM_1_25mb;
            MemAvail = ONE_MEG;
            break;

        case  0x600:
            jj = VRAM_1_50mb;
            if (query->q_VGA_boundary == VRAM_1mb)
                    MemAvail = HALF_MEG;        // Accelerator amount
            else    MemAvail = ONE_MEG;
            break;

        case  0x800:
            jj = VRAM_2mb;
            MemAvail = ONE_MEG;
            break;
        }
    query->q_memory_size = (UCHAR)jj;

    if (kk & MC_BUS)                    // is microchannel bus
        query->q_bus_type = BUS_MC_16;  // 16 bit bus
    else
        query->q_bus_type = kk & BUS_16 ? BUS_ISA_16 : BUS_ISA_8;

    /*
     * We don't use the q_monitor_alias field, so fill in a typical
     * value rather than reading from the EEPROM in case we are
     * dealing with a card without an EEPROM.
     */
    query->q_monitor_alias = 0x0F;
    query->q_shadow_1  = 0;             // do not know what to put here
    query->q_shadow_2  = 0;


    /*
     * If the EEPROM is not present, we can't fill in the mode
     * tables. Return and let the user know that the mode tables
     * have not been filled in.
     */
    if (query->q_eeprom == FALSE)
        return ERROR_DEV_NOT_EXIST;

    /*
     * Fill in the mode tables. The mode tables are sorted in increasing
     * order of resolution, and in increasing order of pixel depth.
     * Ensure pmode is initialized to the END of query structure
     */
    pmode = (struct st_mode_table *) query;
    ((struct query_structure *) pmode)++;     // first  mode table at end of query
    query->q_number_modes       = 0;

    ee_word = 7;            // starting ee word to read, 7,8,9 and 10 are 
                            // the resolutions supported.

    for (jj=0; jj < 4; jj++, ee_word++)
        {
        ee_value = (ee->EEread) (ee_word);

        /*
         * If no 1024x768 mode is configured, assume that
         * 87Hz interlaced is avialable (Windows 3.1 compatibility).
         */
        if ((ee_word == 9) && !(ee_value & 0x001F))
            ee_value |= M1024F87;

        table_offset = crttable[jj];    // offset to resolution table

        /*
         * If we have found a resolution which is supported with
         * the currently installed card and monitor, set the flag
         * to show that this resolution is available, record which
         * VGA parameter table to use if translation is needed,
         * get the #define for the 4BPP mode at that resolution,
         * and get the pixel count for the resolution.
         *
         * In 640x480, ee_value will be zero if IBM Default
         * was selected for vertical scan frequency,
         * For all other resolutions, the resolution is unsupported if
         * ee_value is zero.
         *
         * Some Graphics Ultra cards (due to an early BIOS)
         * have a 132 column text mode where the 1280x1024
         * graphics mode should be. If we have one of these
         * cards, we must treat it as if the mode table
         * were empty, otherwise we'd generate a 1280x1024
         * mode table full of garbage values.
         */
        if ((ee_value | (jj == 0))
            && !((ee_word == 10) && (query->q_ignore1280 == TRUE)))
            {    
            switch (ee_word)
                {
                case 7:
                    query->q_status_flags |= VRES_640x480;
                    ThisRes.m_screen_pitch = 640;
                    if (ee_value & M640F72)
                        {
                        VgaTblEntry = T640F72;
                        BookTblEntry = B640F72;
                        }
                    else{
                        VgaTblEntry = T640F60;
                        BookTblEntry = B640F60;
                        }
                    NumPixels = (long) 640*480;
                    break;

                case 8:
                    query->q_status_flags |= VRES_800x600;
                    // mach8 must be multiple of 128
                    ThisRes.m_screen_pitch = 896;  
                    if (ee_value & M800F72)
                        {
                        VgaTblEntry = T800F72;
                        BookTblEntry = B800F72;
                        }
                    else if (ee_value & M800F70)
                        {
                        VgaTblEntry = T800F70;
                        BookTblEntry = B800F70;
                        }
                    else if (ee_value & M800F60)
                        {
                        VgaTblEntry = T800F60;
                        BookTblEntry = B800F60;
                        }
                    else if (ee_value & M800F56)
                        {
                        VgaTblEntry = T800F56;
                        BookTblEntry = B800F56;
                        }
                    else if (ee_value & M800F89)
                        {
                        VgaTblEntry = T800F89;
                        BookTblEntry = B800F89;
                        }
                    else if (ee_value & M800F95)
                        {
                        VgaTblEntry = T800F95;
                        BookTblEntry = B800F95;
                        }
                    else
                        {
                        VgaTblEntry = NO_TBL_ENTRY;
                        BookTblEntry = NO_TBL_ENTRY;
                        }
                    NumPixels = (long) ThisRes.m_screen_pitch*600;
                    break;

                case 9:
                    query->q_status_flags |= VRES_1024x768;
                    ThisRes.m_screen_pitch = 1024;  
                    if (ee_value & M1024F66)
                        {
                        VgaTblEntry = T1024F66;
                        BookTblEntry = B1024F66;
                        }
                    else if (ee_value & M1024F72)
                        {
                        VgaTblEntry = T1024F72;
                        BookTblEntry = B1024F72;
                        }
                    else if (ee_value & M1024F70)
                        {
                        VgaTblEntry = T1024F70;
                        BookTblEntry = B1024F70;
                        }
                    else if (ee_value & M1024F60)
                        {
                        VgaTblEntry = T1024F60;
                        BookTblEntry = B1024F60;
                        }
                    else if (ee_value & M1024F87)
                        {
                        VgaTblEntry = T1024F87;
                        BookTblEntry = B1024F87;
                        }
                    else
                        {
                        VgaTblEntry = NO_TBL_ENTRY;
                        BookTblEntry = NO_TBL_ENTRY;
                        }
                    NumPixels = (long) 1024*768;
                    break;

                case 10:
                    query->q_status_flags |= VRES_1280x1024;
                    ThisRes.m_screen_pitch = 1280;  
                    if (ee_value & M1280F95)
                        {
                        VgaTblEntry = T1280F95;
                        BookTblEntry = B1280F95;
                        }
                    else if (ee_value & M1280F87)
                        {
                        VgaTblEntry = T1280F87;
                        BookTblEntry = B1280F87;
                        }
                    else
                        {
                        VgaTblEntry = NO_TBL_ENTRY;
                        BookTblEntry = NO_TBL_ENTRY;
                        }
                    NumPixels = (long) 1280*1024;
                    break;
                }

            /*
             * For a given resolution, there will be one mode table
             * per colour depth. Replicate it for ALL pixel depths
             */
            ThisRes.enabled = ee_value;     /* Which vertical scan frequency */
            ThisRes.m_reserved = table_offset;  /* Put EEPROM base address here */

        
            /*
             * Assume that the EEPROM parameters are in 8514 format
             * and try to fill the pmode table. If they are in
             * VGA format, translate them and fill as much of the
             * table as we can.
             * The case where the CRT parameters aren't stored in
             * the EEPROM is handled inside XlateVgaTable().
             * If the parameters aren't stored in the EEPROM, 
             * both the FMT_8514 bit and the CRTC_USAGE bit 
             * will be clear.
             */
            if (!fill_mode_table_m (table_offset, &ThisRes, ee))
                {
                XlateVgaTable(phwDeviceExtension, table_offset, &ThisRes, VgaTblEntry, BookTblEntry, ee, FALSE);
                }
            else{
                ThisRes.m_h_overscan  = 0;
                ThisRes.m_v_overscan  = 0;
                ThisRes.m_overscan_8b = 0;
                ThisRes.m_overscan_gr = 0;
                }

            ThisRes.Refresh = DEFAULT_REFRESH;

            /*
             * The COMPOSITE_SYNC bit of the m_clock_select field is
             * set up to handle composite sync with shadow sets. We use
             * the primrary CRT register set, so we must invert it.
             */
            ThisRes.m_clock_select ^= 0x1000;

            ThisRes.m_status_flags = 0;
            ThisRes.m_vfifo_24 = 0;
            ThisRes.m_vfifo_16 = 0;

            /*
             * For each supported pixel depth at the given resolution,
             * copy the mode table, fill in the colour depth field, set
             * a flag to show that this resolution/depth pair is supported,
             * and increment the counter for the number of supported modes.
             * Test 4BPP before 8BPP so the mode tables will appear in
             * increasing order of pixel depth.
             *
             * We don't support 640x480 256 colour minimum mode, so there
             * are no 8BPP modes available on a 512k card.
             */
            if (NumPixels <= MemAvail*2)
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 4;
                query->q_number_modes++;
                pmode++;
                }

            if ((NumPixels <= MemAvail) && (MemAvail == ONE_MEG))
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 8;
                query->q_number_modes++;
                pmode++;
                }

            }
        }
    query->q_sizeof_struct = query->q_number_modes * sizeof(struct st_mode_table) + sizeof(struct query_structure);

    return NO_ERROR;

}   /* QueryGUltra */


//----------------------------------------------------------------------
//;   QueryMach32                   Mach32 -- 68800 query function
//;
//;   INPUT: QUERY_GET_SIZE, return query structure size   (varying modes)
//;          QUERY_LONG    , return query structure filled in
//;          QUERY_SHORT   , return short query
//;
//;   OUTPUT: ax = size of query structure
//;       or  query structure is filled in
//----------------------------------------------------------------------
                

static void short_query_m (struct query_structure *query, struct st_eeprom_data *ee)
{
WORD    kk;
BYTE    bhigh, blow;
WORD    ApertureLocation;   /* Aperture location, in megabytes */

    
    /*
     * We don't use the q_mouse_cfg field, so fill in a typical value
     * (mouse disabled) rather than reading from the EEPROM in case we
     * are dealing with a card without an EEPROM.
     */
    kk = 0x0000;
    bhigh    = (kk >> 8) & 0xFF;
    blow     = kk & 0xFF;

    query->q_mouse_cfg = (bhigh >> 3) | ((blow & 0x18) >> 1);    // mouse configuration
    kk	= INPW (CONFIG_STATUS_1);		    // get DAC type
    query->q_DAC_type  = ((kk >> 8) & 0x0E) >> 1;

    /*
     * The BT48x and AT&T 491/2/3 families of DAC are incompatible, but
     * CONFIG_STATUS_1 reports the same value for both. If this value
     * was reported, determine which DAC type we have.
     */
    if (query->q_DAC_type == DAC_BT48x)
        query->q_DAC_type = BrooktreeOrATT_m();
    /*
     * The STG1700 and AT&T498 are another pair of incompatible DACs that
     * share a reporting code.
     */
    else if (query->q_DAC_type == DAC_STG1700)
        query->q_DAC_type = ThompsonOrATT_m();

    /*
     * The SC15021 and STG1702/1703 are yet another pair of DACs that
     * share a reporting code.
     */
    else if (query->q_DAC_type == DAC_SC15021)
        query->q_DAC_type = SierraOrThompson_m();

    /*
     * Chip subfamily is stored in bits 0-9 of ASIC_ID. Each subfamily
     * starts the revision counter over from 0.
     */
    switch (INPW(ASIC_ID) & 0x03FF)
        {
        /*
         * 68800-3 does not implement this register, a read returns
         * all 0 bits.
         */
        case 0:
            query->q_asic_rev = CI_68800_3;
            break;

        /*
         * Subsequent revisions of 68800 store the revision count.
         * 68800-6 stores a "2" in the top 4 bits.
         */
        case 0x2F7:
            VideoDebugPrint(( DEBUG_DETAIL, "ASIC_ID = 0x%X\n", INPW(ASIC_ID) ));
            if ((INPW(ASIC_ID) & 0x0F000) == 0x2000)
                {
                query->q_asic_rev = CI_68800_6;
                }
            else
                {
                query->q_asic_rev = CI_68800_UNKNOWN;
                VideoDebugPrint(( DEBUG_ERROR, "*/n*/n* ASIC_ID has invalid value/n*/n*/n"));
                }
            break;

        /*
         * 68800AX
         */
        case 0x17:
            query->q_asic_rev = CI_68800_AX;
            break;

        /*
         * Chips we don't know about yet.
         */
        default:
            query->q_asic_rev = CI_68800_UNKNOWN;
            VideoDebugPrint((DEBUG_ERROR, "*/n*/n* Unknown Mach 32 ASIC type/n*/n*/n"));
            break;
        }


    /*
     * If the query->q_m32_aper_calc field is set, then we read bits
     * 0-6 of the aperture address from bits 8-14 of MEM_CFG
     * and bits 7-11 from bits 0-4 of the high word of SCRATCH_PAD_0.
     */
    if (query->q_m32_aper_calc)
        {
        ApertureLocation = (INPW(MEM_CFG) & 0x7F00) >> 8;
        ApertureLocation |= ((INPW(SCRATCH_PAD_0) & 0x1F00) >> 1);
        }
    /*
     * If the query->q_m32_aper_calc field is clear, and we have an ASIC
     * other than 68800-3 set up to allow the aperture anywhere in the
     * CPU's address space, bits 0-11 of the aperture address are read
     * from bits 4-15 of MEM_CFG. PCI bus always uses this setup, even
     * if CONFIG_STATUS_2 says to use 128M aperture range.
     */
    else if (((query->q_asic_rev != CI_68800_3) && (INPW(CONFIG_STATUS_2) & 0x2000))
        || ((INPW(CONFIG_STATUS_1) & 0x0E) == 0x0E))
        {
        ApertureLocation = (INPW(MEM_CFG) & 0xFFF0) >> 4;
        }
    /*
     * If the query->q_m32_aper_calc field is clear, and we have either
     * a revision 0 ASIC or a newer ASIC set up for a limited range of
     * aperture locations, bits 0-7 of the aperture address are read
     * from bits 8-15 of MEM_CFG.
     */
    else
        {
    	ApertureLocation = (INPW(MEM_CFG) & 0xFF00) >> 8;
        }

#if !defined (i386) && !defined (_i386_)

    //RKE: MEM_CFG expect aperture location in <4:15> for PCI and <8:15>
    //     for VLB.
    kk = (query->q_system_bus_type == PCIBus)? 4:8;
#if defined (ALPHA)
    kk = 4; // Problem with alpha
#endif

    /*
     * Force aperture location to a fixed address.
     * Since there is no BIOS on Alpha, can't depend on MEM_CFG being preset.
     */
    ApertureLocation = 0x78;   // 120 Mb
    OUTPW(MEM_CFG, (USHORT)((ApertureLocation << kk) | 0x02));
    VideoDebugPrint(( DEBUG_DETAIL, "ATI.SYS: MEM_CFG = %x (%x)\n", 
                    (INPW(MEM_CFG)), ((ApertureLocation << kk) | 0x02) ));

#endif  /* defined Alpha */
    query->q_aperture_addr = ApertureLocation;

    /*
     * If the aperture address is zero, then the aperture has not
     * been set up. We can't use the aperture size field of
     * MEM_CFG, since it is cleared on system boot, disabling the
     * aperture until an application explicitly enables it.
     */
    if (ApertureLocation == 0)
        {
        query->q_aperture_cfg = 0;
        }
    /*
     * If the aperture has been set up and the card has no more
     * than 1M of memory, indicate that a 1M aperture could be
     * used, otherwise indicate that a 4M aperture is needed.
     *
     * In either case, set memory use to shared VGA/coprocessor.
     * When the aperture is enabled later in the execution of the
     * miniport, we will always use a 4M aperture. No address space
     * will be wasted, because we will only ask NT to use a block the
     * size of the installed video memory.
     *
     * The format of data in bits 2-15 of MEM_CFG differs
     * between various Mach 32 cards. To avoid having to identify
     * which Mach 32 we are dealing with, read the current value
     * and only change the aperture size bits.
     */
    else{
        if ((INP(MISC_OPTIONS) & MEM_SIZE_ALIAS) <= MEM_SIZE_1M) 
            query->q_aperture_cfg = 1;
        else
            query->q_aperture_cfg = 2;

        OUTP(MEM_BNDRY,0);
        }

    return;

}   /* short_query_m */


//---------------------------------------------------------------------

VP_STATUS   QueryMach32 (struct query_structure *query, BOOL ForceShared)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;
struct st_mode_table *pmode;
short   jj, kk, ee_word;
WORD    pitch, ee_value, table_offset, config_status_1, current_mode;
short   VgaTblEntry;  /* VGA parameter table entry to use if translation needed */
short   BookTblEntry;   /* Appendix D parameter table entry to use if parameters not in EEPROM */
long    NumPixels;  /* Number of pixels at the selected resolution */
long    MemAvail;   /* Bytes of memory available for the accelerator */
struct st_mode_table    ThisRes;    /* Mode table for the given resolution */
PUCHAR   BiosRaw;       /* Storage for information retrieved by BIOS call */
short   CurrentRes;     /* Array index based on current resolution. */
UCHAR   Scratch;        /* Scratch variable */
short   StartIndex;     /* First mode for SetFixedModes() to set up */
short   EndIndex;       /* Last mode for SetFixedModes() to set up */
BOOL    ModeInstalled;  /* Is this resolution configured? */
WORD    Multiplier;     /* Pixel clock multiplier */
short MaxModes;         /* Maximum number of modes possible */
short FreeTables;        /* Number of remaining free mode tables */



    /*
     * Checking the number of modes available would involve
     * duplicating most of the code to fill in the mode tables.
     * Since this is to determine how much memory is needed
     * to hold the query structure, we can assume the worst
     * case (all possible modes are present). This would be:
     *
     * Resolution   Pixel Depths (BPP)  Refresh rates (Hz)      Number of modes
     * 640x480      4,8,16,24           HWD,60,72               12
     * 800x600      4,8,16,24           HWD,56,60,70,72,89,95   28
     * 1024x768     4,8,16              HWD,60,66,70,72,87      18
     * 1280x1024    4,8                 HWD,60,70,74,87,95      12
     *
     * HWD = hardware default refresh rate (rate set by INSTALL)
     *
     * Total: 70 modes
     */
    if (QUERYSIZE < (70 * sizeof(struct st_mode_table) + sizeof(struct query_structure)))
        return ERROR_INSUFFICIENT_BUFFER;
    MaxModes = (QUERYSIZE - sizeof(struct query_structure)) /
                                          sizeof(struct st_mode_table); 

    query->q_structure_rev      = 0;
    query->q_mode_offset        = sizeof(struct query_structure);
    query->q_sizeof_mode        = sizeof(struct st_mode_table);

    query->q_number_modes = 0;  /* Initially assume no modes available */
    query->q_status_flags       = 0;            // will indicate resolutions 

    short_query_m (query, ee);

    config_status_1   = INPW (CONFIG_STATUS_1);
    query->q_VGA_type = config_status_1  & 0x01 ? 0 : 1;

    /*
     * If the program using this routine is going to force the
     * use of shared memory, assume a VGA boundary of 0 when
     * calculating the amount of available memory.
     */
    kk = INP (MEM_BNDRY);
    if ((kk & 0x10) && !ForceShared)
        query->q_VGA_boundary = kk & 0x0F;
    else    query->q_VGA_boundary = 0x00;       // shared by both

    switch (INPW(MISC_OPTIONS) & MEM_SIZE_ALIAS)
        {
        case  MEM_SIZE_512K:
            jj = VRAM_512k;
            MemAvail = HALF_MEG;
            VideoDebugPrint((DEBUG_NORMAL, "MISC_OPTIONS register reports 512k of video memory\n"));
            break;

        case  MEM_SIZE_1M:
            jj = VRAM_1mb;
            MemAvail = ONE_MEG;
            VideoDebugPrint((DEBUG_NORMAL, "MISC_OPTIONS register reports 1M of video memory\n"));
            break;

        case  MEM_SIZE_2M:
            jj = VRAM_2mb;
            MemAvail = 2*ONE_MEG;
            VideoDebugPrint((DEBUG_NORMAL, "MISC_OPTIONS register reports 2M of video memory\n"));
            break;

        case  MEM_SIZE_4M:
            jj = VRAM_4mb;
            MemAvail = 4*ONE_MEG;
            VideoDebugPrint((DEBUG_NORMAL, "MISC_OPTIONS register reports 4M of video memory\n"));
            break;
        }

    query->q_memory_type = (config_status_1 >> 4)  &  0x07;  // CONFIG_STATUS_1.MEM_TYPE

    /*
     * Some 68800-6 and later cards have a bug where one VGA mode (not used
     * by Windows NT VGA miniport, so we don't need to worry about it in
     * full-screen sessions) doesn't work properly if the card has more than
     * 1M of memory. The "fix" for this bug involves telling the memory size
     * field of MISC_OPTIONS to report a memory size smaller than the true
     * amount of memory (most cards with this "fix" report 1M, but some
     * only report 512k).
     *
     * On these cards (DRAM only), get the true memory size.
     *
     * On non-x86 platforms, GetTrueMemSize_m() may either hang
     * (MIPS) or report a false value (Alpha) (on the Power PC,
     * we only support Mach 64). Since we can't rely on the value
     * in MISC_OPTIONS being correct either (the video BIOS may
     * not be executed properly on startup, or we may have a card
     * that reports 1M instead of the true size), assume that
     * non-x86 machines have 2M of video memory available.
     */
#if defined (i386) || defined (_i386_)

    if (((query->q_asic_rev == CI_68800_6) || (query->q_asic_rev == CI_68800_AX)) &&
        (query->q_VGA_type == 1) &&
        ((query->q_memory_type == VMEM_DRAM_256Kx4) ||
         (query->q_memory_type == VMEM_DRAM_256Kx16) ||
         (query->q_memory_type == VMEM_DRAM_256Kx4_GRAP)))
        {
        jj = GetTrueMemSize_m();
        MemAvail = jj * QUARTER_MEG;
        }

#else   /* non-x86 system */

    jj = VRAM_2mb;
    MemAvail = 2*ONE_MEG;

#endif

    query->q_memory_size = (UCHAR)jj;

    /*
     * Subtract the "reserved for VGA" memory size from the total
     * memory to get the amount available to the accelerator.
     */
    MemAvail -= (query->q_VGA_boundary) * QUARTER_MEG;



    jj = (config_status_1 >> 1) & 0x07; // CONFIG_STATUS_1.BUS_TYPE
    if (jj == BUS_ISA_16)               // is ISA bus
        {
        if (query->q_VGA_type)          // is VGA enabled  and  ISA BUS
            jj = BUS_ISA_8;
        }
    query->q_bus_type = (UCHAR)jj;

    /*
     * We don't use the q_monitor_alias field, so fill in a typical
     * value rather than reading from the EEPROM in case we are
     * dealing with a card without an EEPROM.
     */
    query->q_monitor_alias = 0x0F;

    kk = INPW (SCRATCH_PAD_1);
    pitch = (kk & 0x20) | ((kk & 0x01) << 4);

    kk = INP (SCRATCH_PAD_0+1) & 0x07;
    switch (kk)
        {
        case 0:                             // 800x600?
            pitch |=  0x01;
            break;

        case 1:                             // 1280x1024?
            pitch |=  0x03;
            break;

        case 4:                             // alternate mode?
            pitch |=  0x04;
            break;

        case 2:                             // 640x480?
            pitch |=  0x0;
            break;

        default:                            // 1024x768
            pitch |=  0x02;
            break;
        }

    query->q_shadow_1  = pitch + 1;


    kk = INP(SCRATCH_PAD_1+1);
    pitch = (kk & 0x20) | ((kk & 0x01) << 4);

    kk = INP(SCRATCH_PAD_0+1) & 0x30;
    switch (kk)
        {
        case 0:                             // 800x600?
            pitch |=  0x01;
            break;

        case 0x10:                          // 1280x1024?
            pitch |=  0x03;
            break;

        case 0x40:                          // alternate mode?
            pitch |=  0x04;
            break;

        case 0x20:                          // 640x480?
            pitch |=  0x0;
            break;

        default:                            // 1024x768
            pitch |=  0x02;
            break;
        }
    query->q_shadow_2  = pitch + 1;


    /*
     * If extended BIOS functions are available, set up a buffer
     * for the call to the BIOS query function, then make the call.
     */
    if (query->q_ext_bios_fcn)
        {
        BiosRaw = gBiosRaw;
        /* Make the BIOS call (not yet supported by Windows NT) */
        }

    /*
     * If neither the extended BIOS functions nor the EEPROM
     * is present, we can't fill in the mode tables. Return
     * and let the user know that the mode tables have not
     * been filled in.
     */
    else if (query->q_eeprom == FALSE)
        return ERROR_DEV_NOT_EXIST;

    /*
     * Fill in the mode tables. The mode tables are sorted in increasing
     * order of resolution, and in increasing order of pixel depth.
     * Ensure pmode is initialized to the END of query structure
     */
    pmode = (struct st_mode_table *)query;  // first mode table at end of query
    ((struct query_structure *)pmode)++;
    ee_word = 7;            // starting ee word to read, 7,8,9,10 and 11 are 
                            // the resolutions supported.

    for (jj=0; jj < 4; jj++, ee_word++)
        {
        /*
         * Get the pixel depth-independent portion of the
         * mode tables at the current resolution. Use the
         * extended BIOS functions if available, otherwise
         * read from the EEPROM.
         */
        if (query->q_ext_bios_fcn)
            {
            if (BiosFillTable_m(ee_word, BiosRaw, &ThisRes, query) == FALSE)
                ModeInstalled = FALSE;
            else
                ModeInstalled = TRUE;
            switch (ee_word)
                {
                case 7:
                    CurrentRes = RES_640;
                    StartIndex = B640F60;
                    EndIndex = B640F72;
                    break;

                case 8:
                    CurrentRes = RES_800;
                    StartIndex = B800F89;
                    EndIndex = B800F72;
                    break;

                case 9:
                    CurrentRes = RES_1024;
                    StartIndex = B1024F87;
                    EndIndex = B1024F72;
                    break;

                case 10:
                    CurrentRes = RES_1280;
                    StartIndex = B1280F87;
                    /*
                     * 1280x1024 modes above 60Hz noninterlaced
                     * are only available on VRAM cards.
                     */
                    if ((query->q_memory_type == VMEM_DRAM_256Kx4) ||
                        (query->q_memory_type == VMEM_DRAM_256Kx16) ||
                        (query->q_memory_type == VMEM_DRAM_256Kx4_GRAP))
                        EndIndex = B1280F60;
                    else
                        EndIndex = B1280F74;
                    break;
                }
            }
        else{
            ee_value = (ee->EEread) (ee_word);

            current_mode = ee_value & 0x00FF;
            table_offset = (ee_value >> 8) & 0xFF;   // offset to resolution table

            /*
             * Record whether or not this resolution is enabled.
             * We will report "canned" mode tables for all resolutions,
             * but calculations dependent on the configured refresh
             * rate can only be made if this resolution was enabled
             * by the install program.
             *
             * For all modes except 640x480, there will be a bit set
             * to show which vertical scan rate is used. If no bit is
             * set, then that resolution is not configured.
             *
             * In 640x480, no bit is set if "IBM Default" was selected
             * during monitor configuration, so we assume that 640x480
             * is configured.
             */
            if ((!jj) | ((current_mode) && (current_mode != 0xFF)))
                ModeInstalled = TRUE;
            else
                ModeInstalled = FALSE;

            switch (ee_word)            // are defined for resolutions
                {
                case 7:
                    query->q_status_flags |= VRES_640x480;
                    CurrentRes = RES_640;
                    StartIndex = B640F60;
                    EndIndex = B640F72;

                    // 1024 pitch ONLY if NO aperture on a Mach32
#if !defined (SPLIT_RASTERS)
                    if (query->q_aperture_cfg == 0)
                        ThisRes.m_screen_pitch = 1024;  
                    else
#endif
                        ThisRes.m_screen_pitch = 640;  

                    NumPixels = (long) ThisRes.m_screen_pitch * 480;
                    if (ModeInstalled)
                        {
                        if (ee_value & M640F72)
                            {
                            VgaTblEntry = T640F72;
                            BookTblEntry = B640F72;
                            }
                        else
                            {
                            VgaTblEntry = T640F60;
                            BookTblEntry = B640F60;
                            }
                        }
                    break;

                case 8:
                    query->q_status_flags |= VRES_800x600;
                    CurrentRes = RES_800;
                    StartIndex = B800F89;
                    EndIndex = B800F72;

#if defined (SPLIT_RASTERS)
                    if ((query->q_asic_rev == CI_68800_3) ||
#else
                    // 1024 pitch ONLY if NO aperture on a Mach32
                    if (query->q_aperture_cfg == 0)
                        ThisRes.m_screen_pitch = 1024;
                    // Original production revision has trouble
                    // with deep colour if screen pitch not
                    // divisible by 128.
                    else if ((query->q_asic_rev == CI_68800_3) ||
#endif
                            (query->q_bus_type == BUS_PCI))
                        ThisRes.m_screen_pitch = 896;
                    else
                        ThisRes.m_screen_pitch = 800;

                    NumPixels = (long) ThisRes.m_screen_pitch * 600;
                    if (ModeInstalled)
                        {
                        if (ee_value & M800F72)
                            {
                            VgaTblEntry = T800F72;
                            BookTblEntry = B800F72;
                            }
                        else if (ee_value & M800F70)
                            {
                            VgaTblEntry = T800F70;
                            BookTblEntry = B800F70;
                            }
                        else if (ee_value & M800F60)
                            {
                            VgaTblEntry = T800F60;
                            BookTblEntry = B800F60;
                            }
                        else if (ee_value & M800F56)
                            {
                            VgaTblEntry = T800F56;
                            BookTblEntry = B800F56;
                            }
                        else if (ee_value & M800F89)
                            {
                            VgaTblEntry = T800F89;
                            BookTblEntry = B800F89;
                            }
                        else if (ee_value & M800F95)
                            {
                            VgaTblEntry = T800F95;
                            BookTblEntry = B800F95;
                            }
                        else
                            {
                            VgaTblEntry = NO_TBL_ENTRY;
                            BookTblEntry = NO_TBL_ENTRY;
                            }
                        }
                    break;

                case 9:
                    query->q_status_flags |= VRES_1024x768;
                    CurrentRes = RES_1024;
                    StartIndex = B1024F87;
                    EndIndex = B1024F72;
                    ThisRes.m_screen_pitch = 1024;  
                    NumPixels = (long) ThisRes.m_screen_pitch * 768;
                    if (ModeInstalled)
                        {
                        if (ee_value & M1024F66)
                            {
                            VgaTblEntry = T1024F66;
                            BookTblEntry = B1024F66;
                            }
                        else if (ee_value & M1024F72)
                            {
                            VgaTblEntry = T1024F72;
                            BookTblEntry = B1024F72;
                            }
                        else if (ee_value & M1024F70)
                            {
                            VgaTblEntry = T1024F70;
                            BookTblEntry = B1024F70;
                            }
                        else if (ee_value & M1024F60)
                            {
                            VgaTblEntry = T1024F60;
                            BookTblEntry = B1024F60;
                            }
                        else if (ee_value & M1024F87)
                            {
                            VgaTblEntry = T1024F87;
                            BookTblEntry = B1024F87;
                            }
                        else
                            {
                            VgaTblEntry = NO_TBL_ENTRY;
                            BookTblEntry = NO_TBL_ENTRY;
                            }
                        }
                    break;

                case 10:
                    query->q_status_flags |= VRES_1280x1024;
                    CurrentRes = RES_1280;
                    ThisRes.m_screen_pitch = 1280;  
                    StartIndex = B1280F87;
                    /*
                     * 1280x1024 modes above 60Hz noninterlaced
                     * are only available on VRAM cards.
                     */
                    if ((query->q_memory_type == VMEM_DRAM_256Kx4) ||
                        (query->q_memory_type == VMEM_DRAM_256Kx16) ||
                        (query->q_memory_type == VMEM_DRAM_256Kx4_GRAP))
                        EndIndex = B1280F60;
                    else
                        EndIndex = B1280F74;
                    NumPixels = (long) ThisRes.m_screen_pitch * 1024;

                    // 68800-3 cannot support 4 bpp with 1 meg ram.
                    if ((query->q_asic_rev == CI_68800_3) && (MemAvail == ONE_MEG))
                        NumPixels *= 2;             //ensures mode failure

                    if (ModeInstalled)
                        {
                        if (ee_value & M1280F95)
                            {
                            VgaTblEntry = T1280F95;
                            BookTblEntry = B1280F95;
                            }
                        else if (ee_value & M1280F87)
                            {
                            VgaTblEntry = T1280F87;
                            BookTblEntry = B1280F87;
                            }
                        else
                            {
                            VgaTblEntry = NO_TBL_ENTRY;
                            BookTblEntry = NO_TBL_ENTRY;
                            }
                        }
                    break;

                }   /* end switch(ee_word) */

            /*
             * For a given resolution, there will be one mode table
             * per colour depth. Since the mode tables will differ
             * only in the bits per pixel field, make up one mode
             * table and copy its contents as many times as needed,
             * changing only the colour depth field.
             */
            ThisRes.enabled = ee_value;     /* Which vertical scan frequency */

    
            /*
             * Assume that the EEPROM parameters are in 8514
             * format and try to fill the pmode table. If they
             * are in VGA format, translate them and fill as much
             * of the table as we can.
             * The case where the CRT parameters aren't stored in
             * the EEPROM is handled inside XlateVgaTable().
             * If the parameters aren't stored in the EEPROM, 
             * both the FMT_8514 bit and the CRTC_USAGE bit 
             * will be clear.
             */
            if (!fill_mode_table_m (table_offset, &ThisRes, ee))
                XlateVgaTable(phwDeviceExtension, table_offset, &ThisRes, VgaTblEntry, BookTblEntry, ee, TRUE);
            }   /* endif reading CRT parameters from EEPROM */

        ThisRes.Refresh = DEFAULT_REFRESH;

        /*
         * For each supported pixel depth at the given resolution,
         * copy the mode table, fill in the colour depth field, set
         * a flag to show that this resolution/depth pair is supported,
         * and increment the counter for the number of supported modes.
         * Test 4BPP before 8BPP so the mode tables will appear in
         * increasing order of pixel depth.
         *
         * All the DACs we support can handle 4 and 8 BPP if there
         * is enough memory on the card.
         */
        if (NumPixels <= MemAvail*2)
            {
            if (ModeInstalled)
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 4;
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Some DAC and card types don't support 1280x1024 noninterlaced.
             */
            if ((CurrentRes == RES_1280) &&
                ((query->q_DAC_type == DAC_BT48x) ||
                 (query->q_DAC_type == DAC_ATT491) ||
                 (query->q_DAC_type == DAC_SC15026) ||
                 (query->q_DAC_type == DAC_ATI_68830) ||
                 (query->q_GraphicsWonder == TRUE)))
                EndIndex = B1280F95;

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   4,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }
        if (NumPixels <= MemAvail)
            {
            if (ModeInstalled)
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 8;
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Some DAC and card types don't support 1280x1024 noninterlaced.
             */
            if ((CurrentRes == RES_1280) &&
                ((query->q_DAC_type == DAC_BT48x) ||
                 (query->q_DAC_type == DAC_ATT491) ||
                 (query->q_DAC_type == DAC_SC15026) ||
                 (query->q_DAC_type == DAC_ATI_68830) ||
                 (query->q_GraphicsWonder == TRUE)))
                EndIndex = B1280F95;

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   8,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }

        /*
         * 16, 24, and 32 BPP require a DAC which can support
         * the selected pixel depth at the current resolution
         * as well as enough memory.
         *
         * The BT48x and AT&T 49[123] DACs have separate mode
         * tables for 4/8, 16, and 24 BPP (32 BPP not supported).
         * Since the refresh rate for 16 and 24 BPP may differ from
         * that for the paletted modes, we can't be sure that the
         * same tables can be used for translation from VGA to
         * 8514 format. Fortunately, the 16 and 24 BPP tables
         * are always supposed to be written in 8514 format.
         * If the high colour depth is not supported, the
         * table will be empty.
         */
        if ((NumPixels*2 <= MemAvail) &&
            (MaxDepth[query->q_DAC_type][CurrentRes] >= 16))
            {
            if ((query->q_DAC_type == DAC_BT48x) ||
                (query->q_DAC_type == DAC_SC15026) ||
                (query->q_DAC_type == DAC_ATT491))
                {
                Multiplier = CLOCK_DOUBLE;
                if (CurrentRes == RES_640)
                    {
                    Scratch = (UCHAR)fill_mode_table_m(0x49, pmode, ee);
                    }
                else if (CurrentRes == RES_800)
                    {
                    Scratch = (UCHAR)fill_mode_table_m(0x67, pmode, ee);
                    EndIndex = B800F60;     /* 70 Hz and up not supported at 16BPP */
                    }
                else /* Should never hit this case */
                    {
                    Scratch = 0;
                    }

                /*
                 * If the mode table is present and in 8514 format,
                 * move to the next mode table and increment the
                 * table counter. If it is not usable, the table
                 * will be overwritten by the table for the next
                 * resolution.
                 */
                if (ModeInstalled && (Scratch != 0))
                    {
                    pmode->m_screen_pitch = ThisRes.m_screen_pitch;
                    pmode->m_pixel_depth = 16;
                    pmode->Refresh = DEFAULT_REFRESH;
                    pmode++;    /* ptr to next mode table */
                    query->q_number_modes++;
                    }
                }
            else
                {
                Multiplier = CLOCK_SINGLE;
                if (ModeInstalled)
                    {
                    VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                    pmode->m_pixel_depth = 16;
                    pmode++;    /* ptr to next mode table */
                    query->q_number_modes++;
                    }

                /*
                 * If this is a Graphics Wonder with a TI34075 DAC
                 * (only other DAC is BT48x, which is handled in
                 * "if" section above), 70 Hz and up are not
                 * supported in 800x600 16BPP.
                 *
                 * On some but not all non-Graphics Wonder cards, 800x600
                 * 16BPP 72Hz will overdrive the DAC (cards with fast
                 * RAM are less likely to be affected than cards with
                 * slow RAM, VRAM or DRAM does not seem to make a
                 * difference). Since we have no way to tell whether
                 * or not any given card is affected, we must lock out
                 * this mode for all non-Graphics Wonder cards (this
                 * mode and a number of others are already locked out
                 * on the Graphics Wonder).
                 */
                if ((query->q_GraphicsWonder) && (CurrentRes == RES_800))
                    {
                    EndIndex = B800F60;
                    }
                else if (CurrentRes == RES_800)
                    {
                    EndIndex = B800F70;
                    }

                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   Multiplier,
                                                   16,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }


        /*
         * Our new source stream display driver needs a linear aperture
         * in order to handle 24BPP. Since the display driver doesn't
         * have access to the aperture information when it is deciding
         * which modes to pass on to the display applet, it can't make
         * the decision to reject 24BPP modes for cards with only a
         * VGA aperture. This decision must therefore be made in the
         * miniport, so in a paged aperture configuration there are no
         * 24BPP modes for the display driver to accept or reject.
         *
         * On the Alpha, we can't use dense space on the Mach 32 LFB,
         * so we treat it as a no-aperture case.
         */
        if (query->q_aperture_cfg == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP not available because we don't have a linear aperture\n"));
            continue;
            }

#if defined(ALPHA)
        VideoDebugPrint((DEBUG_DETAIL, "24BPP not available in sparse space on Alpha\n"));
        continue;
#endif

        /*
         * 800x600 24BPP exhibits screen tearing unless the pitch
         * is a multiple of 128 (only applies to Rev. 6, since Rev. 3
         * and PCI implementations already have a pitch of 896).
         * Other pixel depths are not affected, and other resolutions
         * are already a multiple of 128 pixels wide.
         *
         * Expand the 800x600 pitch to 896 here, rather than for
         * all pixel depths, because making the change for all
         * pixel depths would disable 16BPP (which doesn't have
         * the problem) on 1M cards. The screen pitch will only
         * be 800 on cards which will exhibit this problem - don't
         * check for a resolution of 800x600 because we don't want
         * to cut the pitch from 1024 down to 896 if SPLIT_RASTERS
         * is not defined.
         */
        if (ThisRes.m_screen_pitch == 800)
            {
            ThisRes.m_screen_pitch = 896;
            NumPixels = (long) ThisRes.m_screen_pitch * 600;
            }

        if ((NumPixels*3 <= MemAvail) &&
            (MaxDepth[query->q_DAC_type][CurrentRes] >= 24))
            {
            if ((query->q_DAC_type == DAC_BT48x) ||
                (query->q_DAC_type == DAC_SC15026) ||
                (query->q_DAC_type == DAC_ATT491))
                {
                Multiplier = CLOCK_TRIPLE;
                if (CurrentRes == RES_640)
                    {
                    EndIndex = B640F60; /* Only refresh rate supported at 24BPP */
                    Scratch = (UCHAR)fill_mode_table_m(0x58, pmode, ee);
                    }
                else /* Should never hit this case */
                    {
                    Scratch = 0;
                    }

                /*
                 * If the mode table is present and in 8514 format,
                 * move to the next mode table and increment the
                 * table counter. If it is not usable, the table
                 * will be overwritten by the table for the next
                 * resolution.
                 */
                if (ModeInstalled && (Scratch != 0))
                    {
                    pmode->m_screen_pitch = ThisRes.m_screen_pitch;
                    pmode->m_pixel_depth = 24;
                    pmode->Refresh = DEFAULT_REFRESH;
                    pmode++;    /* ptr to next mode table */
                    query->q_number_modes++;
                    }
                }
            else
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 24;

                /*
                 * Handle DACs that require higher pixel clocks for 24BPP.
                 */
                Scratch = 0;
                if ((query->q_DAC_type == DAC_STG1700) ||
                    (query->q_DAC_type == DAC_ATT498))
                    {
                    Multiplier = CLOCK_DOUBLE;
                    Scratch = (UCHAR)(pmode->m_clock_select & 0x007C) >> 2;
                    Scratch = DoubleClock(Scratch);
                    pmode->m_clock_select &= 0x0FF83;
                    pmode->m_clock_select |= (Scratch << 2);
                    pmode->ClockFreq <<= 1;
                    }
                else if ((query->q_DAC_type == DAC_SC15021) ||
                    (query->q_DAC_type == DAC_STG1702) ||
                    (query->q_DAC_type == DAC_STG1703))
                    {
                    Multiplier = CLOCK_THREE_HALVES;
                    Scratch = (UCHAR)(pmode->m_clock_select & 0x007C) >> 2;
                    Scratch = ThreeHalvesClock(Scratch);
                    pmode->m_clock_select &= 0x0FF83;
                    pmode->m_clock_select |= (Scratch << 2);
                    pmode->ClockFreq *= 3;
                    pmode->ClockFreq >>= 1;
                    }
                else
                    {
                    Multiplier = CLOCK_SINGLE;
                    if ((query->q_DAC_type == DAC_TI34075) && (CurrentRes == RES_800))
                        EndIndex = B800F70;
                    }

                /*
                 * If we needed to alter the clock frequency, and couldn't
                 * generate an appropriate selector/divisor pair,
                 * then ignore this mode.
                 */
                if (ModeInstalled && (Scratch != 0x0FF))
                    {
                    pmode++;    /* ptr to next mode table */
                    query->q_number_modes++;
                    }

                /*
                 * If this is a Graphics Wonder with a TI34075 DAC
                 * (only other DAC is BT48x, which is handled in
                 * "if" section above), 72 Hz is not supported in
                 * 640x480 24BPP.
                 */
                if ((query->q_GraphicsWonder) && (CurrentRes == RES_640))
                    {
                    EndIndex = B640F60;
                    }
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   Multiplier,
                                                   24,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }

        }   /* end for (list of resolutions) */

    query->q_sizeof_struct = query->q_number_modes * sizeof(struct st_mode_table) + sizeof(struct query_structure);

    return NO_ERROR;

}   /* QueryMach32 */


/****************************************************************
 * fill_mode_table_m
 *   INPUT: table_offset = EEPROM address to start of table
 *          pmode        = ptr to mode table to fill in
 *
 *   RETURN: Nonzero if EEPROM data was in 8514 format.
 *           Zero if EEPROM data was in VGA format. Only those
 *            table entries which are the same in both formats
 *            will be filled in.
 *
 ****************************************************************/

short fill_mode_table_m(WORD table_offset, struct st_mode_table *pmode, 
                        struct st_eeprom_data *ee)
{
    WORD    kk;

    /*
     * Fill in the values which are the same in 8514 and VGA formats.
     */
    pmode->control  = (ee->EEread) ((WORD)(table_offset+0));

    pmode->m_pixel_depth = (pmode->control >> 8) & 0x07;
    pmode->m_reserved = table_offset;       /* EEPROM word with start of mode table */

    /*
     * Check the VGA/8514 mode bit of the control word. 
     * If the parameters are in VGA format, fail so can be translated
     */
    if (!(pmode->control & FMT_8514))
        return 0;

    /*
     * The parameters in the EEPROM are in 8514 format, so we can
     * fill in the structure.
     */
    kk = (ee->EEread) ((WORD)(table_offset+3));
    pmode->m_h_total = (kk >> 8) & 0xFF;
    pmode->m_h_disp  =  kk & 0xFF;
    pmode->m_x_size  = (pmode->m_h_disp+1) * 8;

    kk = (ee->EEread) ((WORD)(table_offset+4));
    pmode->m_h_sync_strt = (kk >> 8) & 0xFF;
    pmode->m_h_sync_wid  =  kk & 0xFF;

    kk = (ee->EEread) ((WORD)(table_offset+8));
    pmode->m_v_sync_wid = (kk >> 8) & 0xFF;
    pmode->m_disp_cntl  =  kk & 0xFF;

    pmode->m_v_total = (ee->EEread) ((WORD)(table_offset+5));
    pmode->m_v_disp  = (ee->EEread) ((WORD)(table_offset+6));

    //  y_size is derived by removing bit 2
    pmode->m_y_size  = (((pmode->m_v_disp >> 1) & 0xFFFC) | (pmode->m_v_disp & 0x03)) +1;

    pmode->m_v_sync_strt = (ee->EEread) ((WORD)(table_offset+7));

    /*
     * On some cards, the vertical information may be stored in skip-1-2
     * format instead of the normal skip-2 format. If this happens, m_y_size
     * will exceed m_x_size (we don't support any resolutions that are
     * taller than they are wide). Re-calculate m_y_size for skip-1-2 format.
     */
    if (pmode->m_y_size > pmode->m_x_size)
        {
        pmode->m_y_size  = (((pmode->m_v_disp >> 2) & 0xFFFE) | (pmode->m_v_disp & 0x01)) +1;
        }


    pmode->m_h_overscan = (ee->EEread)  ((WORD)(table_offset+11));
    pmode->m_v_overscan = (ee->EEread)  ((WORD)(table_offset+12));
    pmode->m_overscan_8b = (ee->EEread) ((WORD)(table_offset+13));
    pmode->m_overscan_gr = (ee->EEread) ((WORD)(table_offset+14));

    pmode->m_status_flags = ((ee->EEread) ((WORD)(table_offset+10)) >> 8) & 0xC0;
    pmode->m_clock_select = (ee->EEread)  ((WORD)(table_offset+9));
    pmode->ClockFreq = GetFrequency((BYTE)((pmode->m_clock_select & 0x007C) >> 2));

    kk = (ee->EEread) ((WORD)(table_offset+2));
    pmode->m_vfifo_24 = (kk >> 8) & 0xFF;
    pmode->m_vfifo_16 =  kk & 0xFF;

    return 1;                   // table filled in successfully

}   /* fill_mode_table_m() */


/*
 * BOOL BiosFillTable_m(ResWanted, BiosRaw, OutputTable, QueryPtr);
 *
 * short ResWanted;     Indicates which resolution is wanted
 * PUCHAR BiosRaw;      Raw data read in from BIOS query function
 * struct st_mode_table *OutputTable;   Mode table to fill in
 * struct query_structure *QueryPtr;    Query structure for video card
 *
 * Fill in pixel depth-independent fields of OutputTable using
 * CRT parameters retrieved from a BIOS query.
 *
 * Returns:
 *  TRUE if table filled in
 *  FALSE if table not filled in (resolution not supported?)
 */
BOOL BiosFillTable_m(short ResWanted, PUCHAR BiosRaw,
                    struct st_mode_table *OutputTable,
                    struct query_structure *QueryPtr)
{
WORD ResFlag;       /* Flag to show which mode is supported */
short PixelsWide;   /* Horizontal resolution of desired mode */
long NumPixels;     /* Number of pixels on-screen at desired resolution */
short Count;        /* Loop counter */
struct query_structure *BiosQuery;  /* QueryStructure read in by BIOS query */
struct st_mode_table *BiosMode;     /* Pointer to first mode table returned by BIOS query */

    /*
     * Set up pointers to the query information and first mode table
     * stored in BiosRaw.
     */
    BiosQuery = (struct query_structure *)BiosRaw;
    BiosMode = (struct st_mode_table *)BiosRaw;
    ((PUCHAR)BiosMode) += BiosQuery->q_mode_offset;

    /*
     * Determine which resolution we are looking for.
     */
    switch (ResWanted)
        {
        case 7:
            ResFlag = VRES_640x480;
            PixelsWide = 640;
            /*
             * 1024 pitch ONLY if NO aperture on a Mach32
             */
#if !defined (SPLIT_RASTERS)
            if (QueryPtr->q_aperture_cfg == 0)
                OutputTable->m_screen_pitch = 1024;  
            else
#endif
                OutputTable->m_screen_pitch = 640;
            NumPixels = (long) OutputTable->m_screen_pitch * 480;
            break;

        case 8:
            ResFlag = VRES_800x600;
            PixelsWide = 800;
            /*
             * 1024 pitch ONLY if NO aperture on a Mach32
             */
#if defined (SPLIT_RASTERS)
            if (QueryPtr->q_asic_rev != CI_68800_3)
#else
            if (QueryPtr->q_aperture_cfg == 0)
                OutputTable->m_screen_pitch = 1024;
            /*
             * Original production revision has trouble with deep colour
             * if screen pitch not divisible by 128.
             */
            else if (QueryPtr->q_asic_rev != CI_68800_3)
#endif
                OutputTable->m_screen_pitch = 896;
            else
                OutputTable->m_screen_pitch = 800;
            NumPixels = (long) OutputTable->m_screen_pitch * 600;
            break;

        case 9:
            ResFlag = VRES_1024x768;
            PixelsWide = 1024;
            OutputTable->m_screen_pitch = 1024;  
            NumPixels = (long) OutputTable->m_screen_pitch * 768;
            break;

        case 10:
            ResFlag = VRES_1280x1024;
            PixelsWide = 1280;
            OutputTable->m_screen_pitch = 1280;  
            NumPixels = (long) OutputTable->m_screen_pitch * 1024;
            /*
             * 68800-3 cannot support 4 bpp with 1 meg ram.
             */
            if ((QueryPtr->q_asic_rev == CI_68800_3) && (QueryPtr->q_memory_size == VRAM_1mb))
                NumPixels *= 2;     /* Ensures mode failure */
            break;

        case 11:
            ResFlag = VRES_ALT_1;
            PixelsWide = 1120;
            OutputTable->m_screen_pitch = 1120;  
            NumPixels = (long) OutputTable->m_screen_pitch * 750;
            break;
        }

    /*
     * Check if the card is configured for the desired mode.
     */
    for (Count = 0; Count < BiosQuery->q_number_modes; Count++)
        {
        /*
         * If the current mode is the one we want, go to the
         * next step. Otherwise, look at the next mode table.
         */
        if (BiosMode->m_x_size == PixelsWide)
            break;
        else
            ((PUCHAR)BiosMode) += BiosQuery->q_sizeof_mode;
        }

    /*
     * Special case: If 1024x768 is not configured, assume that
     * it is available at 87Hz interlaced (Windows 3.1 compatibility).
     */
    if ((Count == BiosQuery->q_number_modes) && (PixelsWide == 1024))
        {
        BookVgaTable(B1024F87, OutputTable);
        QueryPtr->q_status_flags |= ResFlag;
        return TRUE;
        }

    /*
     * All other cases where mode is not configured: report
     * that the mode is not available.
     */
    else if (Count == BiosQuery->q_number_modes)
        return FALSE;

    /*
     * We have found the mode table for the current resolution.
     * Transfer it to OutputTable.
     */
    QueryPtr->q_status_flags |= ResFlag;
    OutputTable->m_h_total = BiosMode->m_h_total;
    OutputTable->m_h_disp = BiosMode->m_h_disp;
    OutputTable->m_x_size = BiosMode->m_x_size;
    OutputTable->m_h_sync_strt = BiosMode->m_h_sync_strt;
    OutputTable->m_h_sync_wid = BiosMode->m_h_sync_wid;
    OutputTable->m_v_total = BiosMode->m_v_total;
    OutputTable->m_v_disp = BiosMode->m_v_disp;
    OutputTable->m_y_size = BiosMode->m_y_size;
    OutputTable->m_v_sync_strt = BiosMode->m_v_sync_strt;
    OutputTable->m_v_sync_wid = BiosMode->m_v_sync_wid;
    OutputTable->m_disp_cntl = BiosMode->m_disp_cntl;
    OutputTable->m_clock_select = BiosMode->m_clock_select;
    OutputTable->ClockFreq = GetFrequency((BYTE)((OutputTable->m_clock_select & 0x007C) >> 2));
    OutputTable->m_h_overscan = BiosMode->m_h_overscan;
    OutputTable->m_v_overscan = BiosMode->m_v_overscan;
    OutputTable->m_overscan_8b = BiosMode->m_overscan_8b;
    OutputTable->m_overscan_gr = BiosMode->m_overscan_gr;
    OutputTable->m_status_flags = BiosMode->m_status_flags;

    /*
     * Assume 8 FIFO entries for 16 and 24 bit colour.
     */
    OutputTable->m_vfifo_24 = 8;
    OutputTable->m_vfifo_16 = 8;
    return TRUE;

}   /* BiosFillTable_m() */



/*
 * static UCHAR BrooktreeOrATT_m(void);
 *
 * Function to determine whether the DAC is a BT48x, a SC15026,
 * or an AT&T 49x. These three DAC families are incompatible,
 * but CONFIG_STATUS_1 contains the same value for all.
 *
 * Returns:
 *  DAC_BT48x if Brooktree DAC found
 *  DAC_ATT491 if AT&T 49[123] DAC found
 *  DAC_SC15026 if Sierra SC15026 DAC found
 *
 * NOTE: Results are undefined if called after CONFIG_STATUS_1
 *       reports a DAC that does not belong to either of these
 *       two families.
 */
static UCHAR BrooktreeOrATT_m(void)
{
    BYTE OriginalMask;  /* Original value from VGA DAC_MASK register */
    WORD ValueRead;     /* Value read during AT&T 490 check */
    BYTE Scratch;       /* Temporary variable */
    short RetVal;       /* Value to be returned */

    /*
     * Get the DAC to a known state and get the original value
     * from the VGA DAC_MASK register.
     */
    ClrDacCmd_m(TRUE);
    OriginalMask = LioInp(regVGA_END_BREAK_PORT, 6);    /* VGA DAC_MASK */

    /*
     * Re-clear the DAC state, and set the extended register
     * programming flag in the DAC command register.
     */
    ClrDacCmd_m(TRUE);
    Scratch = (BYTE)((OriginalMask & 0x00FF) | 0x10);
    LioOutp(regVGA_END_BREAK_PORT, Scratch, 6);     /* VGA DAC_MASK */

    /*
     * Select ID register byte #1, and read its contents.
     */
    LioOutp(regVGA_END_BREAK_PORT, 0x09, 7);        /* Look-up table read index */
    Scratch = LioInp(regVGA_END_BREAK_PORT, 8);     /* Look-up table write index */

    /*
     * Put the DAC back in a known state and restore
     * the original pixel mask value.
     */
    ClrDacCmd_m(TRUE);
    LioOutp(regVGA_END_BREAK_PORT, OriginalMask, 6);    /* VGA DAC_MASK */

    /*
     * Sierra SC15026 DACs will have 0x53 in ID register byte 1.
     */
    if (Scratch == 0x53)
        {
        VideoDebugPrint((DEBUG_DETAIL, "BrooktreeOrATT_m() - SC15026 found\n"));
        return DAC_SC15026;
        }

    /*
     * Get the DAC to a known state and get the original value
     * from the VGA DAC_MASK register. Assume AT&T DAC.
     */
    ClrDacCmd_m(FALSE);
    OriginalMask = LioInp(regVGA_END_BREAK_PORT, 6);    /* VGA DAC_MASK */
    RetVal = DAC_ATT491;

    /*
     * Check the two opposite alternating bit patterns. If both succeed,
     * this is an AT&T 491 DAC. If either or both fails, it is either
     * another AT&T DAC or a Brooktree DAC. In either case, restore
     * the value from the VGA DAC_MASK register, since the test will
     * have corrupted it.
     */
    if (!ChkATTDac_m(0x0AA))
        {
        RetVal = DAC_BT48x;
        }
    if (!ChkATTDac_m(0x055))
        {
        RetVal = DAC_BT48x;
        }
    ClrDacCmd_m(FALSE);
    LioOutp(regVGA_END_BREAK_PORT, OriginalMask, 6);    /* VGA DAC_MASK */
    LioOutp(regVGA_END_BREAK_PORT, 0x0FF, 6);           /* VGA DAC_MASK */

    /*
     * If we know that the DAC is an AT&T 491, we don't need
     * to do further testing.
     */
    if (RetVal == DAC_ATT491)
        {
        VideoDebugPrint((DEBUG_DETAIL, "BrooktreeOrATT_m() - AT&T 491 found\n"));
        return (UCHAR)RetVal;
        }

    /*
     * The DAC is either an AT&T 490 or a Brooktree 48x. Determine
     * which one.
     */
    ClrDacCmd_m(TRUE);        /* Get the DAC to a known state */
    LioOutp(regVGA_END_BREAK_PORT, 0x0FF, 6);       /* VGA DAC_MASK */
    ClrDacCmd_m(TRUE);
    Scratch = LioInp(regVGA_END_BREAK_PORT, 6);     /* VGA DAC_MASK */
    ValueRead = Scratch << 8;

    ClrDacCmd_m(TRUE);
    LioOutp(regVGA_END_BREAK_PORT, 0x07F, 6);       /* VGA DAC_MASK */
    ClrDacCmd_m(TRUE);
    Scratch = LioInp(regVGA_END_BREAK_PORT, 6);     /* VGA DAC_MASK */
    ValueRead |= Scratch;
    ValueRead &= 0x0E0E0;

    ClrDacCmd_m(TRUE);
    LioOutp(regVGA_END_BREAK_PORT, 0, 6);           /* VGA_DAC_MASK */
    if (ValueRead == 0x0E000)
        {
        VideoDebugPrint((DEBUG_DETAIL, "BrooktreeOrATT_m() - AT&T 490 found\n"));
        return DAC_ATT491;
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "BrooktreeOrATT_m() - BT48x found\n"));
        /*
         * The test to find an AT&T 491 scrambles the DAC_MASK register
         * on a BT48x. Simply resetting this register doesn't work -
         * the DAC needs to be re-initialized. This is done when the
         * video mode is set, but for now the "blue screen" winds up
         * as magenta on blue instead of white on blue.
         *
         * This "blue screen" change is harmless, but may result in
         * user complaints. To get around it, change palette entry 5
         * from magenta to white.
         */
        LioOutp(regVGA_END_BREAK_PORT, 5, 8);       /* VGA DAC_W_INDEX */
        LioOutp(regVGA_END_BREAK_PORT, 0x2A, 9);    /* VGA DAC_DATA */
        LioOutp(regVGA_END_BREAK_PORT, 0x2A, 9);    /* VGA DAC_DATA */
        LioOutp(regVGA_END_BREAK_PORT, 0x2A, 9);    /* VGA DAC_DATA */
        return DAC_BT48x;
        }

}   /* BrooktreeOrATT_m() */
    


/*
 * static BOOL ChkATTDac_m(MaskVal);
 *
 * BYTE MaskVal;    Value to write to VGA DAC_MASK register
 *
 * Low-level test routine called by BrooktreeOrATT_m() to determine
 * whether an AT&T 491 DAC is present.
 *
 * Returns:
 *  TRUE if AT&T 491 DAC found
 *  FALSE if AT&T 491 DAC not found (may still be other AT&T DAC)
 */
static BOOL ChkATTDac_m(BYTE MaskVal)
{
    BYTE ValueRead;     /* Value read back from VGA DAC_MASK register */

    ClrDacCmd_m(FALSE);   /* Get things to a known state */
    LioOutp(regVGA_END_BREAK_PORT, MaskVal, 6);     /* VGA DAC_MASK */
    short_delay();
    LioOutp(regVGA_END_BREAK_PORT, (BYTE)(~MaskVal), 6);    /* VGA DAC_MASK */
    ClrDacCmd_m(FALSE);   /* See if inverted value was cleared */
    ValueRead = LioInp(regVGA_END_BREAK_PORT, 6);   /* VGA DAC_MASK */

    return (ValueRead == MaskVal);

}   /* ChkATTDac_m() */



/*
 * static void ClrDacCmd_m(ReadIndex);
 *
 * BOOL ReadIndex;  TRUE if VGA DAC_W_INDEX must be read
 *
 * Read various VGA registers from the DAC. This is done as part
 * of the BT48x/ATT491 identification.
 */
static void ClrDacCmd_m(BOOL ReadIndex)
{
    short Count;    /* Loop counter */
    BYTE Dummy;     /* Used to collect the values we read */

    if (ReadIndex)
        {
        Dummy = LioInp(regVGA_END_BREAK_PORT, 8);   /* VGA DAC_W_INDEX */
        }

    for (Count = 4; Count > 0; Count--)
        {
        short_delay();
        Dummy = LioInp(regVGA_END_BREAK_PORT, 6);   /* VGA DAC_MASK */
        }
    return;

}   /* ClrDacCmd_m() */



/***************************************************************************
 *
 * static UCHAR ThompsonOrATT_m(void);
 *
 * DESCRIPTION:
 *  Checks the AT&T 498 device identification number register to
 *  determine whether we are dealing with an AT&T 498 or a
 *  STG 1700 DAC (both types report the same value in CONFIG_STATUS_1).
 *  This is a non-destructive test, since no register writes
 *  are involved.
 *
 * RETURN VALUE:
 *  DAC_STG1700 if S.G. Thompson 1700 DAC found
 *  DAC_ATT498 if AT&T 498 DAC found
 *
 * NOTE:
 *  Results are undefined if called after CONFIG_STATUS_1 reports
 *  a DAC that does not belong to either of these two families.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  short_query_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static UCHAR ThompsonOrATT_m(void)
{
    BYTE Scratch;       /* Temporary variable */
    UCHAR DacType;      /* Type of DAC we are dealing with */

    VideoDebugPrint((DEBUG_NORMAL, "ThompsonOrATT_m() entry\n"));
    /*
     * The extended registers hidden behind DAC_MASK on the AT&T 498
     * and STG1700 are accessed by making a specified number of reads
     * from the DAC_MASK register. Read from another register to reset
     * the read counter to 0.
     */
    Scratch = INP(DAC_W_INDEX);

    /*
     * The AT&T 498 Manufacturer Identification Register is accessed on
     * the sixth read from DAC_MASK, and the Device Identification
     * Register is accessed on the seventh. If these registers contain
     * 0x84 and 0x98 respectively, then this is an AT&T 498. Initially
     * assume that an AT&T 498 is present.
     */
    DacType = DAC_ATT498;
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    if (Scratch != 0x84)
        {
        VideoDebugPrint((DEBUG_DETAIL, "STG1700 found\n"));
        DacType = DAC_STG1700;
        }
    Scratch = INP(DAC_MASK);
    if (Scratch != 0x98)
        {
        VideoDebugPrint((DEBUG_DETAIL, "STG1700 found\n"));
        DacType = DAC_STG1700;
        }

    VideoDebugPrint((DEBUG_DETAIL, "If no STG1700 message, AT&T498 found\n"));
    /*
     * Reset the read counter so subsequent accesses to DAC_MASK don't
     * accidentally write a hidden register.
     */
    Scratch = INP(DAC_W_INDEX);
    return DacType;

}   /* ThompsonOrATT_m() */
    


/***************************************************************************
 *
 * static UCHAR SierraOrThompson_m(void);
 *
 * DESCRIPTION:
 *  Checks the first 2 bytes of the Sierra SC15021 device
 *  identification register to determine whether we are dealing
 *  with an SC15021 or a STG1702/1703 in native mode (STG170x
 *  can also be strapped to emulate the STG1700, but this DAC
 *  has different capabilities, and so strapped STG170x DACs won't
 *  be reported as SC15021).
 *
 * RETURN VALUE:
 *  DAC_STG1702 if S.G. Thompson 1702/1703 DAC found
 *  DAC_SC15021 if Sierra SC15021 DAC found
 *
 * NOTE:
 *  Results are undefined if called after CONFIG_STATUS_1 reports
 *  a DAC that does not belong to either of these two families.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  short_query_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static UCHAR SierraOrThompson_m(void)
{
    BYTE Scratch;       /* Temporary variable */
    UCHAR DacType;      /* Type of DAC we are dealing with */

    VideoDebugPrint((DEBUG_NORMAL, "SierraOrThompson_m() entry\n"));
    /*
     * The extended registers hidden behind DAC_MASK on the SC15021
     * and STG1702/1703 are accessed by making a specified number of
     * reads from the DAC_MASK register. Read from another register
     * to reset the read counter to 0.
     */
    Scratch = INP(DAC_W_INDEX);

    /*
     * Set the extended register programming flag in the DAC command
     * register so we don't need to hit the "magic" reads for each
     * register access. Initially assume that a SC15021 is present.
     */
    DacType = DAC_SC15021;
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    OUTP(DAC_MASK, 0x10);

    /*
     * Check the ID registers. If either of them doesn't match the
     * values for the SC15021, we are dealing with a STG1702/1703.
     */
    OUTP(DAC_R_INDEX, 0x09);
    Scratch = INP(DAC_W_INDEX);
    if (Scratch != 0x53)
        {
        VideoDebugPrint((DEBUG_DETAIL, "STG1702/1703 found\n"));
        DacType = DAC_STG1702;
        }
    OUTP(DAC_R_INDEX, 0x0A);
    Scratch = INP(DAC_W_INDEX);
    if (Scratch != 0x3A)
        {
        VideoDebugPrint((DEBUG_DETAIL, "STG1702/1703 found\n"));
        DacType = DAC_STG1702;
        }

    VideoDebugPrint((DEBUG_DETAIL, "If no STG1702/1703 message, SC15021 found\n"));
    /*
     * Clear the ERPF and reset the read counter so subsequent accesses
     * to DAC_MASK don't accidentally write a hidden register.
     */
    OUTP(DAC_MASK, 0);
    Scratch = INP(DAC_W_INDEX);
    return DacType;

}   /* SierraOrThompson_m() */
    


/***************************************************************************
 *
 * short GetTrueMemSize_m(void);
 *
 * DESCRIPTION:
 *  Determine the amount of video memory installed on the graphics card.
 *  This is done because the 68800-6 contains a bug which causes MISC_OPTIONS
 *  to report 1M rather than the true amount of memory.
 *
 * RETURN VALUE:
 *  Enumerated value for amount of memory (VRAM_512k, VRAM_1mb, VRAM_2mb,
 *  or VRAM_4mb)
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  QueryMach32()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

short GetTrueMemSize_m(void)
{
    USHORT SavedPixel;      /* Saved value from pixel being tested */

    /*
     * Switch into accelerator mode, and initialize the engine to
     * a pitch of 1024 pixels in 16BPP.
     */
    SetupRestoreEngine_m(SETUP_ENGINE);


    /*
     * Given the current engine settings, only a 4M card will have
     * enough memory to back up the 1025th line of the display.
     * Since the pixel coordinates are zero-based, line 1024 will
     * be the first one which is only backed on 4M cards.
     *
     * Save the first pixel of line 1024, paint it in our test colour,
     * then read it back. If it is the same as the colour we painted
     * it, then this is a 4M card.
     */
    SavedPixel = ReadPixel_m(0, 1024);
    WritePixel_m(0, 1024, TEST_COLOUR);
    if (ReadPixel_m(0, 1024) == TEST_COLOUR)
        {
        /*
         * This is a 4M card. Restore the pixel and the graphics engine.
         */
        VideoDebugPrint((DEBUG_NORMAL, "GetTrueMemSize_m() found 4M card\n"));
        WritePixel_m(0, 1024, SavedPixel);
        SetupRestoreEngine_m(RESTORE_ENGINE);
        return VRAM_4mb;
        }

    /*
     * We know this card has 2M or less. On a 1M card, the first 2M
     * of the card's memory will have even doublewords backed by
     * physical memory and odd doublewords unbacked.
     *
     * Pixels 0 and 1 of a row will be in the zeroth doubleword, while
     * pixels 2 and 3 will be in the first. Check both pixels 2 and 3
     * in case this is a pseudo-1M card (one chip pulled to turn a 2M
     * card into a 1M card).
     */
    SavedPixel = ReadPixel_m(2, 0);
    WritePixel_m(2, 0, TEST_COLOUR);
    if (ReadPixel_m(2, 0) == TEST_COLOUR)
        {
        /*
         * This is a either a 2M card or a pseudo-1M card. Restore
         * the pixel, then test the other half of the doubleword.
         */
        WritePixel_m(2, 0, SavedPixel);
        SavedPixel = ReadPixel_m(3, 0);
        WritePixel_m(3, 0, TEST_COLOUR);
        if (ReadPixel_m(3, 0) == TEST_COLOUR)
            {
            /*
             * This is a 2M card. Restore the pixel and the graphics engine.
             */
            VideoDebugPrint((DEBUG_NORMAL, "GetTrueMemSize_m() found 2M card\n"));
            WritePixel_m(3, 0, SavedPixel);
            SetupRestoreEngine_m(RESTORE_ENGINE);
            return VRAM_2mb;
            }
        }

    /*
     * This is a either a 1M card or a 512k card. Test pixel 1, since
     * it is an odd word in an even doubleword.
     *
     * NOTE: We have not received 512k cards for testing - this is an
     *       extrapolation of the 1M/2M determination code.
     */
    SavedPixel = ReadPixel_m(1, 0);
    WritePixel_m(1, 0, TEST_COLOUR);
    if (ReadPixel_m(1, 0) == TEST_COLOUR)
        {
        /*
         * This is a 1M card. Restore the pixel and the graphics engine.
         */
        VideoDebugPrint((DEBUG_NORMAL, "GetTrueMemSize_m() found 1M card\n"));
        WritePixel_m(1, 0, SavedPixel);
        SetupRestoreEngine_m(RESTORE_ENGINE);
        return VRAM_1mb;
        }

    /*
     * This is a 512k card.
     */
    VideoDebugPrint((DEBUG_NORMAL, "GetTrueMemSize_m() found 512k card\n"));
    SetupRestoreEngine_m(RESTORE_ENGINE);
    return VRAM_512k;

}   /* GetTrueMemSize_m() */



/***************************************************************************
 *
 * void SetupRestoreEngine_m(DesiredStatus);
 *
 * int DesiredStatus;   Whether the user wants to set up or restore
 *
 * DESCRIPTION:
 *  Set engine to 1024 pitch 16BPP with 512k of VGA memory,
 *  or restore the engine and boundary status, as selected by the user.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  GetTrueMemSize_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/
void SetupRestoreEngine_m(int DesiredStatus)
{
    static WORD MiscOptions;    /* Contents of MISC_OPTIONS register */
    static WORD ExtGeConfig;    /* Contents of EXT_GE_CONFIG register */
    static WORD MemBndry;       /* Contents of MEM_BNDRY register */


    if (DesiredStatus == SETUP_ENGINE)
        {
        Passth8514_m(SHOW_ACCEL);

        /*
         * Set up a 512k VGA boundary so "blue screen" writes that happen
         * when we are in accelerator mode won't show up in the wrong place.
         */
        MemBndry = INPW(MEM_BNDRY);     /* Set up shared memory */
        OUTPW(MEM_BNDRY, 0);

        /*
         * Save the contents of the MISC_OPTIONS register, then
         * tell it that we have 4M of video memory. Otherwise,
         * video memory will wrap when it hits the boundary
         * in the MEM_SIZE_ALIAS field.
         */
        MiscOptions = INPW(MISC_OPTIONS);
        OUTPW(MISC_OPTIONS, (WORD) (MiscOptions | MEM_SIZE_4M));

        /*
         * Set 16BPP with pitch of 1024. Only set up the drawing
         * engine, and not the CRT, since the results of this test
         * are not intended to be seen.
         */
        ExtGeConfig = INPW(R_EXT_GE_CONFIG);
        OUTPW(EXT_GE_CONFIG, (WORD)(PIX_WIDTH_16BPP | ORDER_16BPP_565 | 0x000A));
        OUTPW(GE_PITCH, (1024 >> 3));
        OUTPW(GE_OFFSET_HI, 0);
        OUTPW(GE_OFFSET_LO, 0);
        }
    else    /* DesiredStatus == RESTORE_ENGINE */
        {
        /*
         * Restore the memory boundary, MISC_OPTIONS register,
         * and EXT_GE_CONFIG. It is not necessary to reset the
         * drawing engine pitch and offset, because they don't
         * affect what is displayed and they will be set to
         * whatever values are needed when the desired video
         * mode is set.
         */
        OUTPW(EXT_GE_CONFIG, ExtGeConfig);
        OUTPW(MISC_OPTIONS, MiscOptions);
        OUTPW(MEM_BNDRY, MemBndry);

        /*
         * Give the VGA control of the screen.
         */
        Passth8514_m(SHOW_VGA);
        }
    return;

}   /* SetupRestoreEngine_m() */



/***************************************************************************
 *
 * USHORT ReadPixel_m(XPos, YPos);
 *
 * short XPos;      X coordinate of pixel to read
 * short YPos;      Y coordinate of pixel to read
 *
 * DESCRIPTION:
 *  Read a single pixel from the screen.
 *
 * RETURN VALUE:
 *  Colour of pixel at the desired location.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  GetTrueMemSize_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

USHORT ReadPixel_m(short XPos, short YPos)
{
    USHORT RetVal;

    /*
     * Don't read if the engine is busy.
     */
    WaitForIdle_m();

    /*
     * Set up the engine to read colour data from the screen.
     */
    CheckFIFOSpace_m(SEVEN_WORDS);
    OUTPW(RD_MASK, 0x0FFFF);
    OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_BLIT | DATA_WIDTH | DRAW | DATA_ORDER));
    OUTPW(CUR_X, XPos);
    OUTPW(CUR_Y, YPos);
    OUTPW(DEST_X_START, XPos);
    OUTPW(DEST_X_END, (WORD)(XPos+1));
    OUTPW(DEST_Y_END, (WORD)(YPos+1));

    /*
     * Wait for the engine to process the orders we just gave it and
     * start asking for data.
     */
    CheckFIFOSpace_m(SIXTEEN_WORDS);
    while (!(INPW(GE_STAT) & DATA_READY));

    RetVal = INPW(PIX_TRANS);
    WaitForIdle_m();
    return RetVal;

}   /* ReadPixel_m() */



/***************************************************************************
 *
 * void WritePixel_m(XPos, YPos, Colour);
 *
 * short XPos;      X coordinate of pixel to read
 * short YPos;      Y coordinate of pixel to read
 * short Colour;    Colour to paint the pixel
 *
 * DESCRIPTION:
 *  Write a single pixel to the screen.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  GetTrueMemSize_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void WritePixel_m(short XPos, short YPos, short Colour)
{
    /*
     * Set up the engine to paint to the screen.
     */
    CheckFIFOSpace_m(EIGHT_WORDS);
    OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | DRAW | READ_WRITE));
    OUTPW(ALU_FG_FN, MIX_FN_PAINT);
    OUTPW(FRGD_COLOR, Colour);
    OUTPW(CUR_X, XPos);
    OUTPW(CUR_Y, YPos);
    OUTPW(DEST_X_START, XPos);
    OUTPW(DEST_X_END, (WORD)(XPos+1));
    OUTPW(DEST_Y_END, (WORD)(YPos+1));

    return;

}   /* WritePixel_m() */



/***************************************************************************
 *
 * BOOL BlockWriteAvail_m(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Test to see whether block write mode is available. This function
 *  assumes that the card has been set to an accelerated mode.
 *
 * RETURN VALUE:
 *  TRUE if this mode is available
 *  FALSE if it is not available
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL BlockWriteAvail_m(struct query_structure *Query)
{
    BOOL RetVal = TRUE;
    ULONG ColourMask;   /* Masks off unneeded bits of Colour */
    ULONG Colour;       /* Colour to use in testing */
    USHORT LimitColumn; /* Used to determine when we have finished reading */
    USHORT Column;      /* Column being checked */


    /*
     * Block write mode is only possible on 68800-6 and later cards.
     * If we don't have an appropriate card, then report that this
     * mode is not available.
     */
    if ((Query->q_asic_rev != CI_68800_6) && (Query->q_asic_rev != CI_68800_AX))
        return FALSE;

    /*
     * Block write is only available on VRAM cards.
     */
    if ((Query->q_memory_type == VMEM_DRAM_256Kx4) ||
        (Query->q_memory_type == VMEM_DRAM_256Kx16) ||
        (Query->q_memory_type == VMEM_DRAM_256Kx4_GRAP))
        return FALSE;

    /*
     * Acceleration is not available for pixel depths above 16BPP.
     * Since block write is only used when we are in an accelerated
     * mode, it is not available for high pixel depths.
     */
    if (Query->q_pix_depth > 16)
        return FALSE;

    /*
     * Set up according to the current pixel depth. At 16BPP, we must make
     * one read per pixel, but at 8BPP we only make one read per two pixels,
     * since we will be reading 16 bits at a time. Our display driver
     * does not support 4BPP.
     */
    if (Query->q_pix_depth == 16)
        {
        ColourMask = 0x0000FFFF;
        LimitColumn = 512;
        }
    else
        {
        ColourMask = 0x000000FF;
        LimitColumn = 256;
        }

    /*
     * Clear the block we will be testing.
     */
    CheckFIFOSpace_m(TEN_WORDS);
    OUTPW(WRT_MASK, 0x0FFFF);
    OUTPW(DEST_CMP_FN, 0);
    OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | DRAW | READ_WRITE));
    OUTPW(ALU_FG_FN, MIX_FN_PAINT);
    OUTPW(FRGD_COLOR, 0);
    OUTPW(CUR_X, 0);
    OUTPW(CUR_Y, 0);
    OUTPW(DEST_X_START, 0);
    OUTPW(DEST_X_END, 512);
    OUTPW(DEST_Y_END, 1);
    WaitForIdle_m();

    /*
     * To test block write mode, try painting each of the alternating bit
     * patterns, then read the block back one pixel at a time. If there
     * is at least one mismatch, then block write is not supported.
     */
    for (Colour = 0x5555; Colour < 0x10000; Colour *= 2)
        {
        /*
         * Paint the block.
         */
        CheckFIFOSpace_m(ELEVEN_WORDS);
        OUTPW(MISC_OPTIONS, (WORD)(INPW(MISC_OPTIONS) | BLK_WR_ENA));
        OUTPW(WRT_MASK, 0x0FFFF);
        OUTPW(DEST_CMP_FN, 0);
        OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | DRAW | READ_WRITE));
        OUTPW(ALU_FG_FN, MIX_FN_PAINT);
        OUTPW(FRGD_COLOR, (WORD)(Colour & ColourMask));
        OUTPW(CUR_X, 0);
        OUTPW(CUR_Y, 0);
        OUTPW(DEST_X_START, 0);
        OUTPW(DEST_X_END, 512);
        OUTPW(DEST_Y_END, 1);

        if(!WaitForIdle_m())
            {
            RetVal = FALSE;
            break;
            }

        /*
         * Set up the engine to read colour data from the screen.
         */
        CheckFIFOSpace_m(SEVEN_WORDS);
        OUTPW(RD_MASK, 0x0FFFF);
        OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_BLIT | DATA_WIDTH | DRAW | DATA_ORDER));
        OUTPW(CUR_X, 0);
        OUTPW(CUR_Y, 0);
        OUTPW(DEST_X_START, 0);
        OUTPW(DEST_X_END, 512);
        OUTPW(DEST_Y_END, 1);

        /*
         * Wait for the engine to process the orders we just gave it and
         * start asking for data.
         */
        CheckFIFOSpace_m(SIXTEEN_WORDS);
        for (Column = 0; Column < LimitColumn; Column++)
            {
            /*
             * Ensure that the next word is available to be read
             */
            while (!(INPW(GE_STAT) & DATA_READY));
            
            /*
             * If even one pixel is not the colour we tried to paint it,
             * then block write is not available.
             */
            if (INPW(PIX_TRANS) != (WORD)Colour)
                {
                RetVal = FALSE;
                }
            }
        }


    /*
     * If block write is unavailable, turn off the block write bit.
     */
    if (RetVal == FALSE)
        OUTPW(MISC_OPTIONS, (WORD)(INPW(MISC_OPTIONS) & ~BLK_WR_ENA));

    return RetVal;

}   /* BlockWriteAvail_m() */



/***************************************************************************
 *
 * BOOL IsMioBug_m(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Test to see whether the card has the multiple input/output
 *  hardware bug, which results in corrupted draw operations
 *  on fast machines.
 *
 * RETURN VALUE:
 *  TRUE if this bug is present
 *  FALSE if it is not present
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL IsMioBug_m(struct query_structure *Query)
{
    /*
     * This hardware problem is only present on 68800-3 VLB cards.
     * Assume that all these cards are affected.
     */
    if ((Query->q_asic_rev == CI_68800_3) &&
        (Query->q_system_bus_type != MicroChannel) &&
        ((Query->q_bus_type == BUS_LB_386SX) ||
         (Query->q_bus_type == BUS_LB_386DX) ||
         (Query->q_bus_type == BUS_LB_486)))
        {
        VideoDebugPrint((DEBUG_DETAIL, "MIO bug found\n"));
        return TRUE;
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "MIO bug not found\n"));
        return FALSE;
        }

}   /* IsMioBug_m() */

//********************   end  of  QUERY_M.C   ***************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\services.h ===
/************************************************************************/
/*                                                                      */
/*                              SERVICES.H                              */
/*                                                                      */
/*        Aug 26  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.9  $
      $Date:   02 Feb 1996 17:22:20  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/services.h_v  $
 * 
 *    Rev 1.9   02 Feb 1996 17:22:20   RWolff
 * Added prototype for new routine GetVgaBuffer().
 * 
 *    Rev 1.8   11 Jan 1996 19:45:02   RWolff
 * SetFixedModes() now restricts modes based on pixel clock frequency.
 * 
 *    Rev 1.7   20 Jul 1995 18:01:16   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.6   02 Jun 1995 14:34:06   RWOLFF
 * Added prototype for UpperCase().
 * 
 *    Rev 1.5   23 Dec 1994 10:48:14   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.4   19 Aug 1994 17:14:34   RWOLFF
 * Added support for non-standard pixel clock generators.
 * 
 *    Rev 1.3   20 Jul 1994 13:01:36   RWOLFF
 * Added prototype for new routine FillInRegistry().
 * 
 *    Rev 1.2   12 May 1994 11:05:06   RWOLFF
 * Prototype and definitions for new function SetFixedModes()
 * 
 *    Rev 1.1   26 Apr 1994 12:35:44   RWOLFF
 * Added prototype for ISAPitchAdjust()
 * 
 *    Rev 1.0   31 Jan 1994 11:49:22   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.3   24 Jan 1994 18:10:24   RWOLFF
 * Added prototype for new routine TripleClock().
 * 
 *    Rev 1.2   15 Dec 1993 15:32:16   RWOLFF
 * Added prototype for new clock multiplier routine.
 * 
 *    Rev 1.1   05 Nov 1993 13:27:50   RWOLFF
 * Headers for new routines in SERVICES.C, added array of pixel clock
 * frequencies (initialized for 18811-1 clock chip, may be changed by other
 * routines for other clock chips).
 * 
 *    Rev 1.0   03 Sep 1993 14:29:06   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SERVICES.H - Header file for SERVICES.C

#endif

/*
 * Global definitions used in detecting card capabilities.
 */
#define VIDEO_ROM_ID    0x0AA55     /* Found at start of any BIOS block */

/*
 * Permitted values for clock multiplication at high pixel depths.
 */
enum {
    CLOCK_SINGLE = 1,
    CLOCK_THREE_HALVES,
    CLOCK_DOUBLE,
    CLOCK_TRIPLE
    };

/*
 * Prototypes for functions supplied by SERVICES.C
 */
extern void short_delay (void);
extern void delay(int);
extern BOOL IsBufferBacked(PUCHAR StartAddress, ULONG Size);
extern UCHAR DoubleClock(UCHAR ClockSelector);
extern UCHAR ThreeHalvesClock(UCHAR ClockSelector);
extern UCHAR TripleClock(UCHAR ClockSelector);
extern ULONG GetFrequency(UCHAR ClockSelector);
extern UCHAR GetSelector(ULONG *Frequency);
extern UCHAR GetShiftedSelector(ULONG Frequency);
extern void ISAPitchAdjust(struct query_structure *QueryPtr);
extern WORD SetFixedModes(WORD StartIndex,
                          WORD EndIndex,
                          WORD Multiplier,
                          WORD PixelDepth,
                          WORD Pitch,
                          short FreeTables,
                          ULONG MaxDotClock,
                          struct st_mode_table **ppmode);
extern void FillInRegistry(struct query_structure *QueryPtr);

extern PVOID MapFramebuffer(ULONG StartAddress, long Size);

extern unsigned short *Get_BIOS_Seg(void);
extern void UpperCase(PUCHAR TxtString);
extern PUCHAR GetVgaBuffer(ULONG Size, ULONG Offset, PULONG Segment, PUCHAR SaveBuffer);

extern UCHAR LioInp(int Port, int Offset);
extern USHORT LioInpw(int Port, int Offset);
extern ULONG LioInpd(int Port);
extern VOID LioOutp(int Port, UCHAR Data, int Offset);
extern VOID LioOutpw(int Port, USHORT Data, int Offset);
extern VOID LioOutpd(int Port, ULONG Data);

#ifdef INCLUDE_SERVICES
/*
 * Definitions and variables used in SERVICES.C
 */

/*
 * The following definitions are used in finding the video BIOS segment.
 */
#define ISA_ROM_BASE        0xC0000 /* Lowest address where BIOS can be found */
#define ROM_LOOK_SIZE       0x40000 /* Size of block where BIOS can be found */
#define ROM_GRANULARITY     0x00800 /* BIOS starts on a 2k boundary */
/*
 * Offset from ISA_ROM_BASE of highest possible start of video BIOS segment
 */
#define MAX_BIOS_START      ROM_LOOK_SIZE - ROM_GRANULARITY
/*
 * The ATI signature string will start at an offset into the video BIOS
 * segment no less than SIG_AREA_START and no greater than SIG_AREA_END.
 */
#define SIG_AREA_START      0x30
#define SIG_AREA_END        0x80

/*
 * ROM block containing ATI Graphics product signature,
 * extended base address, and ASIC chip revision
 */
VIDEO_ACCESS_RANGE RawRomBaseRange = {
    ISA_ROM_BASE, 0, ROM_LOOK_SIZE, FALSE, FALSE, FALSE
    };

/*
 * Clock selector and divisor as used by DoubleClock(). These do not
 * match the divisor ans selector masks in the CLOCK_SEL register.
 */
#define SELECTOR_MASK   0x0F
#define DIVISOR_MASK    0x10
#define DIVISOR_SHIFT   4       /* Bits to shift divisor before ORing with selector */

/*
 * Frequencies (in hertz) produced by the clock generator for
 * each select value. External clock values should be set to 0
 * (won't match anything).
 */
ULONG ClockGenerator[16] =
{
    100000000L,
    126000000L,
     92400000L,
     36000000L,
     50350000L,
     56640000L,
            0L,
     44900000L,
    135000000L,
     32000000L,
    110000000L,
     80000000L,
     39910000L,
     44900000L,
     75000000L,
     65000000L
};

/*
 * Frequency tolerance (in hertz) used by GetSelector().
 * Any selector/divisor pair which produces a frequency
 * within FREQ_TOLERANCE of the input is considered a match.
 */
#define FREQ_TOLERANCE  100000L

#else   /* Not defined INCLUDE_SERVICES */

extern ULONG ClockGenerator[16];

#endif  /* defined INCLUDE_SERVICES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\vdpdata.h ===
/************************************************************************/
/*                                                                      */
/*                              VDPDATA.H                               */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.1  $
    $Date:   20 Jul 1995 18:02:24  $
    $Author:   mgrubac  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/vdpdata.h  $
 * 
 *    Rev 1.1   20 Jul 1995 18:02:24   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.0   31 Jan 1994 11:50:04   RWOLFF
 * Initial revision.
        
           Rev 1.1   05 Nov 1993 13:33:58   RWOLFF
        Fixed clock frequency table.
        
           Rev 1.0   16 Aug 1993 13:32:32   Robert_Wolff
        Initial revision.
        
           Rev 1.1   04 May 1993 16:51:10   RWOLFF
        Switched from floating point to long integers due to lack of floating point
        support in Windows NT kernel-mode code.
        
           Rev 1.0   30 Apr 1993 16:47:18   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    VDPDATA.H -  Definitions and structures used internally by VDPTOCRT.C.

#endif



/*
 * Sync polarities. INTERNAL_ERROR is an error code for functions
 * which have 0 as a legitimate return (e.g. GetPolarity). Functions
 * which do not have zero as a legitimate return value should follow
 * the "Zero = failure, Nonzero = success" convention.
 */
#define POSITIVE        0
#define NEGATIVE        1
#define INTERNAL_ERROR -1

// GENERAL CONSTANTS
#define NONINTERLACED	0
#define INTERLACED		1

/*
 * Constants used in pseudo-floating point calculations
 */
#define THOUSAND          1000L
#define HALF_MILLION    500000L
#define MILLION        1000000L


/*
 * Data structure used for horz and vert information from the vddp file
 */
typedef struct _HALFDATA
    {
    long    Resolution;             // pixels
    unsigned long ScanFrequency;    // horz - Hz, vert - mHz
    char    Polarity;               // positive or negative
    unsigned long SyncWidth,        // horz - ns, vert - us
                    FrontPorch,     // horz - ns, vert - us
                    BackPorch,      // horz - ns, vert - us
                    ActiveTime,     // horz - ns, vert - us
                    BlankTime;      // horz - ns, vert - us
    } HALFDATA, *P_HALFDATA;



/*
 * Data structure used for complete preadjusted timing data set
 */
typedef struct _TIMINGDATA
    {
    char ModeName[33];  // name of the video mode
    char Interlaced;    // interlaced or non-interlaced mode
    HALFDATA HorzData;  // horizontal data
    HALFDATA VertData;  // vertical data
    } TIMINGDATA, *P_TIMINGDATA;

/*
 * Data structure used to hold number of timings sections and pointers to
 * timings buffer for each limits section
 */
typedef struct _LIMITSDATA
    {	
    unsigned long DotClock;     // maximum pixel clock -- for all assoc. timings
    long  TimingsCount;         // number of timings section for this limits sec.
    P_TIMINGDATA TimingsPtr;    // pointer to buffer holding timings data
    }LIMITSDATA, *P_LIMITSDATA;

typedef struct {
    char video_mode[33];
    unsigned char h_total, h_disp, h_sync_strt, h_sync_wid;
    unsigned long v_total, v_disp, v_sync_strt;
    unsigned char v_sync_wid, disp_cntl, crt_pitch, clk_sel;
    unsigned long pixel_clk;

	 // ***** the values below this comment were added for instvddp.exe *****

	 unsigned char lock,fifo_depth,vga_refresh_rate_code;
	 unsigned long control,hi_color_ctl,hi_color_vfifo;
} crtT;


#if 0
typedef enum {
    clk_43MHz  = 0,
    clk_49MHz  = 1,
    clk_93MHz  = 2,
    clk_36MHz  = 3,
    clk_50MHz  = 4,
    clk_57MHz  = 5,
    clk_extrn1 = 6,
    clk_45MHz  = 7,
    clk_30MHz  = 8,
    clk_32MHz  = 9,
    clk_110MHz = 10,
    clk_80MHz  = 11,
    clk_40MHz  = 12,
    clk_75MHz  = 14,
    clk_65MHz  = 15
} clockT;
#endif


#if 1
typedef enum {
    clk_100MHz = 0,
    clk_126MHz = 1,
    clk_93MHz  = 2,
    clk_36MHz  = 3,
    clk_50MHz  = 4,
    clk_57MHz  = 5,
    clk_extrn1 = 6,
    clk_45MHz  = 7,
    clk_135MHz = 8,
    clk_32MHz  = 9,
    clk_110MHz = 10,
    clk_80MHz  = 11,
    clk_40MHz  = 12,
    clk_75MHz  = 14,
    clk_65MHz  = 15
} clockT;
#endif

typedef struct {
    long clock_selector;
    long clock_freq;
} clk_infoT;

#ifdef INCLUDE_VDPDATA
#if 0
/* These are the pixel clocks for the 18810 Clock Chip */
clk_infoT clock_info[16] = {
    { clk_43MHz  , 42.95E+6 },
    { clk_49MHz  , 48.77E+6 },
    { clk_93MHz  , 92.40E+6 },
    { clk_36MHz  , 36.00E+6 },
    { clk_50MHz  , 50.35E+6 },
    { clk_57MHz  , 56.64E+6 },
    { clk_extrn1 , 0.000000 },
    { clk_45MHz  , 44.90E+6 },
    { clk_30MHz  , 30.24E+6 },
    { clk_32MHz  , 32.00E+6 },
    { clk_110MHz , 110.0E+6 },
    { clk_80MHz  , 80.00E+6 },
    { clk_40MHz  , 40.00E+6 },
    { clk_75MHz  , 75.00E+6 },
    { clk_65MHz  , 65.00E+6 },
    { -1         , 0.000000 }
};
#endif

#if 1
/* These are the pixel clocks for the 18811-1 Clock Chip */
clk_infoT clock_info[16] = {
    { clk_100MHz , 100000000L },
    { clk_126MHz , 126000000L },
    { clk_93MHz  ,  92400000L },
    { clk_36MHz  ,  36000000L },
    { clk_50MHz  ,  50350000L },
    { clk_57MHz  ,  56640000L },
    { clk_extrn1 ,         0L },
    { clk_45MHz  ,  44900000L },
    { clk_135MHz , 135000000L },
    { clk_32MHz  ,  32000000L },
    { clk_110MHz , 110000000L },
    { clk_80MHz  ,  80000000L },
    { clk_40MHz  ,  40000000L },
    { clk_75MHz  ,  75000000L },
    { clk_65MHz  ,  65000000L },
    { -1         ,         0L }
};
#endif
#else
extern clk_infoT clock_info[16];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\vdptocrt.c ===
/************************************************************************/
/*                                                                      */
/*                              VDPTOCRT.C                              */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.8  $
    $Date:   20 Jul 1995 18:03:48  $
    $Author:   mgrubac  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/vdptocrt.c  $
 * 
 *    Rev 1.8   20 Jul 1995 18:03:48   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.7   02 Jun 1995 14:34:28   RWOLFF
 * Switched from toupper() to UpperCase(), since toupper() led to unresolved
 * externals on some platforms.
 * 
 *    Rev 1.6   08 Mar 1995 11:35:52   ASHANMUG
 * Cleaned-up Warnings
 * 
 *    Rev 1.5   31 Aug 1994 16:33:38   RWOLFF
 * Now gets resolution definitions from ATIMP.H.
 * 
 *    Rev 1.4   19 Aug 1994 17:15:14   RWOLFF
 * Added support for non-standard pixel clock generators.
 * 
 *    Rev 1.3   22 Mar 1994 15:39:12   RWOLFF
 * Workaround for abs() not working properly.
 * 
 *    Rev 1.2   03 Mar 1994 12:38:46   ASHANMUG
 * 
 *    Rev 1.0   31 Jan 1994 11:24:14   RWOLFF
 * Initial revision.
        
           Rev 1.1   05 Nov 1993 13:34:12   RWOLFF
        Fixed "Hang on read from file" bug.
        
           Rev 1.0   16 Aug 1993 13:21:32   Robert_Wolff
        Initial revision.
        
           Rev 1.2   24 Jun 1993 14:30:12   RWOLFF
        Microsoft-originated change: added #include statements for additional
        NT-supplied headers which are needed in build 47x of NT
        
           Rev 1.1   04 May 1993 16:52:14   RWOLFF
        Switched from floating point calculations to long integer calculations due
        to lack of floating point support in Windows NT kernel-mode code.
        
           Rev 1.0   30 Apr 1993 16:45:18   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    VDPTOCRT.C - Source file for Windows NT function to return a table of 
                 register values for setting a requested mode. The values
                 are calculated from a raw ASCII list of timing values
                 following the .VDP standard.  The entry point to this module
                 is the function "VdpToCrt" found at the end of the file.

    Written by Bill Hopkins

#endif


// COMPILER INCLUDES
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>

// NT INCLUDES
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

// APPLICATION INCLUDES
#define INCLUDE_VDPDATA
#define INCLUDE_VDPTOCRT

#include "stdtyp.h"       
#include "amach1.h"
#include "atimp.h"
#include "cvtvga.h"
#include "services.h"
#include "vdptocrt.h"
#include "vdpdata.h"      

/*
 * STATIC VARIABLES
 */
static long MaxHorz,MaxVert;     // used to record maximum resolution
static unsigned long MaxRate;    // used to record maximum vert scan rate


/*
 * FUNCTION PROTYPES
 */


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, normal_to_skip2)
#endif



/*
 *****************************************************************************
 */
/*
 * long normal_to_skip2(normal_number);
 *
 * long normal_number;  Number to be converted
 *
 * Convert a number into either skip_1_2 or skip_2 representation.
 * Representation chosen depends on global skip1, which is nonzero
 * if skip_1_2 is desired and zero if skip_2 is desired.
 *
 * Returns
 *  Number converted into desired representation
 */
long normal_to_skip2(long normal_number)
{
    if (skip1)
        return (((normal_number << 2) & 0xFFF8) | (normal_number & 0x1));
    else
        return (((normal_number << 1) & 0xFFF8) | (normal_number & 0x3));
}   /* end normal_to_skip2() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\stdtyp.h ===
#ifndef STDTYP_H
#define STDTYP_H
/*******************************************************************
    Filename: STDTYP.H
   (c) 1989, ATI Technologies Incorporated.
  $Revision:   1.1  $
      $Date:   23 Dec 1994 10:48:20  $
   $Author:   ASHANMUG  $
      $Log:   S:/source/wnt/ms11/miniport/vcs/stdtyp.h  $
 *
 *    Rev 1.1   23 Dec 1994 10:48:20   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.0   31 Jan 1994 11:49:02   RWOLFF
 * Initial revision.

           Rev 1.1   03 Sep 1993 14:29:46   RWOLFF
        Type definitions used by Windows NT driver.

           Rev 1.1   24 Feb 1993 11:05:20   Ajith_S
        Check for MSDOS and not far as #ifdef far always returns FALSE

           Rev 1.0   13 Jan 1993 14:16:12   Robert_Wolff
        Initial revision.

      Rev 1.14   15 Apr 1991 16:26:30   Bryan_Sniderman
   Corrected WORD definition from 'unsigned int' to 'unsigned short'
   This will force a WORD to 16-bits (even in HIGH-C)

      Rev 1.13   06 Dec 1990 12:02:22   Chris_Brady
   Added support for Metaware HIGHC compiler.  Define P386.

      Rev 1.12   04 Jun 1990 15:54:18   Sandy_Lum
   Corrected syntax error

      Rev 1.11   17 May 1990 10:02:00   Robin_Davies
   Added TINY, UTINY base types.

      Rev 1.10   28 Sep 1989 11:41:14   Robin_Davies
   Made PRIVATE declarator conditional, allowing all PRIVATE labels
   to be published from the command line by adding /DPRIVATE option
   to CL options. Useful for debugging purposes.

      Rev 1.9   17 Sep 1989 16:10:16   Robin_Davies
   "define HUGE huge" conflicts with ANSI definition of HUGE in
   MATH.H. Replaced with "define ENORMOUSE huge".

      Rev 1.8   15 Sep 1989 16:39:10   Peter Liepa
   added HUGE keyword

      Rev 1.7   30 Jun 1989 11:06:52   Peter Michalek
   FALSE , TRUE added

      Rev 1.6   28 Jun 1989 15:00:28   Robin_Davies
   Added FLOAT and DOUBLE.

      Rev 1.5   28 Jun 1989 14:34:54   Robin_Davies
   Removed double-slash comments.

      Rev 1.4   21 Jun 1989 15:34:06   Peter Liepa
   removed hard tabs

      Rev 1.3   20 Jun 1989 15:45:20   Peter Liepa
   corrected spelling of "SUCCESS", fixed up line overflows

      Rev 1.2   16 Jun 1989  9:51:56   Robin_Davies
   Made headers consistent.

      Rev 1.1   14 Jun 1989 15:27:38   Robin_Davies
   Added OFFSET, SEGMENT macros.

      Rev 1.0   14 Jun 1989  9:20:24   Robin_Davies
   Initial revision.
********************************************************************/

#ifdef DOC
STDTYP.H - Portable types for C programs.

DESCRIPTION
     This file contains standard augmented types for C programs. Types
     are based on and are compatible with Microsoft OS/2 types.
     In addition, several Plum-Hall/Whitesmith standard types
     have been added.

     This header currently supports the Microsoft C 5.1 compiler.
     and the Metaware High C 386 Protected mode Version 1.6  compiler
     by defining P386.
#endif

#ifndef INT_MAX /* Defined in limits.h */
#include <limits.h> /* Ansi type limits, matching augmented types */
#endif
/*
*****************************
    Standard Defines
*****************************
*/
#define YES 1
#define NO 0

/*
 * Some platforms have already defined TRUE and/or FALSE.
 */
#ifndef TRUE
    #define TRUE    (1)     /* Function TRUE  value */
#endif
#ifndef FALSE
    #define FALSE   (0)     /* Function FALSE value */
#endif

#ifndef  P386
#define SUCCESS 0
#define FAIL 1
#endif

/*
 * Non-portable types. Data size references are not needed
 * for Windows NT, since it's a 32 bit operating system.
 * Only define the basic types for platforms (e.g. Windows NT)
 * where they aren't already defined.
 */

typedef unsigned char BYTE;     /* 8 bits unsigned  */
typedef unsigned short WORD;    /* 16 bits unsigned */

/*
**************************
    BASE TYPES
**************************
*/
typedef char CHAR;              /* At least 8 bits, sign indeterminate */
typedef short SHORT;            /* At least 16 bits signed */
typedef long LONG;              /* At least 32 bits signed */
typedef float FLOAT;            /* Floating point, unspecified precision */
typedef double DOUBLE;          /* Floating point, unspecified precision */

typedef unsigned char UCHAR;    /* At least 8 bits, unsigned */
typedef signed char SCHAR;      /* At least 8 bits, signed */
typedef unsigned short USHORT;  /* At least 16 bits, unsigned */
typedef unsigned long ULONG;    /* At least 32 bits, signed */

typedef unsigned char UTINY;    /* Scalar, at least 8 bits , unsigned */
typedef char TINY;              /* Scalar, at least 8 bits, signed */

/*
****************************
    ARTIFICIAL TYPES
****************************
*/
#ifndef PRIVATE
   #define PRIVATE static           /* Local functions and variables */
#endif

typedef int METACHAR;            /* Sufficient to hold any character and EOF */
typedef int BOOL;                /* Most efficient Boolean,
                                         compare against zero only! */
typedef char TBOOL;              /* Smallest boolean, e.g. for use in arrays.
                                        Compare against zero only */
typedef unsigned int BITS;       /* At least 16 bits, used for bit manipulation */
typedef unsigned char TBITS;     /* At least 8 bits, used for bit manipulation */
typedef unsigned long int LBITS; /* At least 32 bits, used for bit manipulation */

#ifndef  _BASETSD_H_
typedef unsigned int SIZE_T;    /* sufficent for sizeof(anything)
                                 e.g. malloc size. Equivalent to ansi size_t */
#endif

#if     defined(__LARGE__) || defined(__HUGE__) || defined(__COMPACT__)
typedef long    PTRDIFF_T;      /* difference between pointers.
                                         Equivalent to ansi ptrdiff_t */
#else
typedef int     PTRDIFF_T;      /* difference between pointers.
                                        Equivalent to ansi ptrdiff_t */
#endif


/*
****************************
     POINTERS
****************************
*/


typedef void *PVOID;                   /* Generic untyped pointer */

typedef int (*PFUNC)();                /* Pointer to Function (model dependent) */

/*
****************************
   Useful Macros
****************************
*/

#define FOREVER for(;;)
#define NOTHING /**/        /* e.g. while (condition) NOTHING */

/* Create untyped far pointer from selector and offset */
#define MAKEP(sel, off)     ((PVOID)MAKEULONG(off, sel))

/* Extract selector or offset from far pointer. e.g. OFFSET(&x) */
#define OFFSET(p)           LOWORD((VOID FAR *) (p))
#define SEGMENT(p)          HIWORD((VOID FAR *) (p))

/* Cast any variable to an instance of the specified type. */
#define MAKETYPE(v, type)   (*((type *)&v))

/* Calculate the byte offset of a field in a structure of type type. */
#define FIELDOFFSET(type, field)    ((SHORT)&(((type *)0)->field))

/* Combine l & h to form a 32 bit quantity. */
#define MAKEULONG(l, h)  ((ULONG)(((USHORT)(l)) | ((ULONG)((USHORT)(h))) << 16))
#define MAKELONG(l, h)   ((LONG)MAKEULONG(l, h))

/* Combine l & h to form a 16 bit quantity. */
#define MAKEWORD(l, h) (((WORD)(l)) | ((WORD)(h)) << 8)
#define MAKESHORT(l, h)  ((SHORT)MAKEUSHORT(l, h))

/* Extract high and low order parts of 16 and 32 bit quantity */
#define LOBYTE(w)       ((BYTE)(w))
#define HIBYTE(w)       ((BYTE)(((WORD)(w) >> 8) & 0xff))
#define LOWORD(l)     ((WORD)(l))
#define HIWORD(l)     ((WORD)(((ULONG)(l) >> 16) & 0xffff))

#endif /* defined STDTYP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\setup_m.h ===
/************************************************************************/
/*                                                                      */
/*                              SETUP_M.H                               */
/*                                                                      */
/*        Aug 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.5  $
      $Date:   18 May 1995 14:14:34  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/setup_m.h  $
 * 
 *    Rev 1.5   18 May 1995 14:14:34   RWOLFF
 * No longer uses the memory-mapped form of CLOCK_SEL (sometimes the
 * value written wouldn't "take" even though a readback showed the
 * correct value).
 * 
 *    Rev 1.4   23 Dec 1994 10:48:16   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.3   07 Jul 1994 14:00:48   RWOLFF
 * Andre Vachon's fix: re-sized DriverMMRange_m[] from NUM_DRIVER_ACCESS_RANGES
 * entries to NUM_IO_ACCESS_RANGES entries because this array doesn't need
 * a slot for the framebuffer.
 * 
 *    Rev 1.2   30 Jun 1994 18:22:38   RWOLFF
 * Added prototypes for IsApertureConflict_m() and IsVGAConflict_m(), and
 * definitions used by these routines.
 * 
 *    Rev 1.1   20 May 1994 14:04:18   RWOLFF
 * Ajith's change: removed unused register SRC_CMP_COLOR from lists to be mapped
 * 
 *    Rev 1.0   31 Jan 1994 11:49:36   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.5   14 Jan 1994 15:27:02   RWOLFF
 * Added prototype for MemoryMappedEnabled_m()
 * 
 *    Rev 1.4   15 Dec 1993 15:32:40   RWOLFF
 * No longer claims EISA configuration registers and placeholder for
 * the linear framebuffer.
 * 
 *    Rev 1.3   05 Nov 1993 13:32:50   RWOLFF
 * Added prototype of function to unmap I/O address ranges.
 * 
 *    Rev 1.1   08 Oct 1993 11:16:46   RWOLFF
 * Added I/O vs. Memory Mapped definitions formerly in ATIMP.H.
 * 
 *    Rev 1.0   03 Sep 1993 14:29:26   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SETUP_M.H - Header file for SETUP_M.C

#endif

/*
 * Prototypes for functions supplied by SETUP_M.C
 */
extern VP_STATUS CompatIORangesUsable_m(void);
extern void CompatMMRangesUsable_m(void);
extern void UnmapIORanges_m(void);
extern BOOL MemoryMappedEnabled_m(void);
extern int WaitForIdle_m(void);
extern void CheckFIFOSpace_m(WORD SpaceNeeded);
extern BOOL IsApertureConflict_m(struct query_structure *QueryPtr);
extern BOOL IsVGAConflict_m(void);


/*
 * Definitions used internally by SETUP_M.C
 */
#ifdef INCLUDE_SETUP_M


/*
 * Avoid runtime bugs due to overflowing the address range arrays
 * in the HW_DEVICE_EXTENSION structure.
 *
 * If more address ranges are added without increasing
 * NUM_DRIVER_ACCESS_RANGES, we will get a compile-time error because
 * too many entries in DriverIORange[] will be initialized. If
 * NUM_DRIVER_ACCESS_RANGES is increased beyond the size of
 * the arrays in the HW_DEVICE_EXTENSION structure, the "#if"
 * statement will generate a compile-time error.
 *
 * We can't use an implicit size on DriverIORange[] and define
 * NUM_DRIVER_ACCESS_RANGES as sizeof(DriverIORange)/sizeof(VIDEO_ACCESS_RANGE)
 * because the expression in a #if statement can't use the
 * sizeof() operator.
 */
#define NUM_DRIVER_ACCESS_RANGES    20*5+2
#define FRAMEBUFFER_ENTRY           NUM_DRIVER_ACCESS_RANGES - 1
#define NUM_IO_ACCESS_RANGES        FRAMEBUFFER_ENTRY

/*
 * Indicate whether the specified address range is in I/O space or
 * memory mapped space. These values are intended to make it easier
 * to read the Driver??Range[] structures.
 */
#define ISinIO          TRUE           
#define ISinMEMORY      FALSE


//------------------------------------------------------------------
// struct list is address, 0, length, inIOspace, visible, sharable   
// this order MATCHES  AMACH.H ENUM data  structure
// all entries are in INCREASING IO address.
VIDEO_ACCESS_RANGE DriverIORange_m[NUM_DRIVER_ACCESS_RANGES] = {
     {IO_DAC_MASK          , 0, 1, ISinIO, 1, FALSE},    // Mach DAC registers
     {IO_DAC_R_INDEX       , 0, 1, ISinIO, 1, FALSE},
     {IO_DAC_W_INDEX       , 0, 1, ISinIO, 1, FALSE},       
     {IO_DAC_DATA          , 0, 3, ISinIO, 1, FALSE},       
     {IO_DISP_STATUS       , 0, 1, ISinIO, 1, FALSE},    // First Mach register

     {IO_OVERSCAN_COLOR_8  , 0, 2, ISinIO, 1, FALSE},
     {IO_H_DISP            , 0, 2, ISinIO, 1, FALSE},
     {IO_OVERSCAN_GREEN_24 , 0, 2, ISinIO, 1, FALSE},
     {IO_H_SYNC_STRT       , 0, 1, ISinIO, 1, FALSE},
     {IO_CURSOR_OFFSET_LO  , 0, 2, ISinIO, 1, FALSE},

     {IO_H_SYNC_WID        , 0, 1, ISinIO, 1, FALSE},                // 10
     {IO_CURSOR_OFFSET_HI  , 0, 2, ISinIO, 1, FALSE},
     {IO_V_TOTAL           , 0, 2, ISinIO, 1, FALSE},
     {IO_CONFIG_STATUS_1   , 0, 2, ISinIO, 1, FALSE},
     {IO_V_DISP            , 0, 2, ISinIO, 1, FALSE},

     {IO_CONFIG_STATUS_2   , 0, 2, ISinIO, 1, FALSE},
     {IO_V_SYNC_STRT       , 0, 2, ISinIO, 1, FALSE},
     {IO_CURSOR_COLOR_0    , 0, 2, ISinIO, 1, FALSE},
     {IO_CURSOR_COLOR_1    , 0, 1, ISinIO, 1, FALSE},
     {IO_V_SYNC_WID        , 0, 2, ISinIO, 1, FALSE},

     {IO_HORZ_CURSOR_OFFSET, 0, 1, ISinIO, 1, FALSE},                // 20
     {IO_VERT_CURSOR_OFFSET, 0, 1, ISinIO, 1, FALSE},
     {IO_DISP_CNTL         , 0, 1, ISinIO, 1, FALSE},
     {IO_CRT_PITCH         , 0, 2, ISinIO, 1, FALSE},
     {IO_CRT_OFFSET_LO     , 0, 2, ISinIO, 1, FALSE},

     {IO_CRT_OFFSET_HI     , 0, 2, ISinIO, 1, FALSE},
     {IO_LOCAL_CONTROL     , 0, 2, ISinIO, 1, FALSE},
     {IO_FIFO_OPT          , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_CURSOR_COLOR_0, 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_CURSOR_COLOR_1, 0, 2, ISinIO, 1, FALSE},

     {IO_SUBSYS_CNTL       , 0, 2, ISinIO, 1, FALSE},                // 30
     {IO_MEM_BNDRY         , 0, 1, ISinIO, 1, FALSE},
     {IO_ROM_PAGE_SEL      , 0, 2, ISinIO, 1, FALSE},
     {IO_SHADOW_CTL        , 0, 2, ISinIO, 1, FALSE},
     {IO_ADVFUNC_CNTL      , 0, 2, ISinIO, 1, FALSE},

     {IO_CLOCK_SEL         , 0, 2, ISinIO, 1, FALSE},
     {IO_ROM_ADDR_1        , 0, 2, ISinIO, 1, FALSE},
     {IO_ROM_ADDR_2        , 0, 2, ISinIO, 1, FALSE},
     {IO_SHADOW_SET        , 0, 2, ISinIO, 1, FALSE},
     {IO_MEM_CFG           , 0, 2, ISinIO, 1, FALSE},

     {IO_EXT_GE_STATUS     , 0, 2, ISinIO, 1, FALSE},                // 40
     {IO_VERT_OVERSCAN     , 0, 2, ISinIO, 1, FALSE},
     {IO_MAX_WAITSTATES    , 0, 2, ISinIO, 1, FALSE},
     {IO_GE_OFFSET_LO      , 0, 2, ISinIO, 1, FALSE},
     {IO_BOUNDS_LEFT       , 0, 2, ISinIO, 1, FALSE},

     {IO_BOUNDS_TOP        , 0, 2, ISinIO, 1, FALSE},
     {IO_BOUNDS_RIGHT      , 0, 2, ISinIO, 1, FALSE},
     {IO_BOUNDS_BOTTOM     , 0, 2, ISinIO, 1, FALSE},
     {IO_CUR_Y             , 0, 2, ISinIO, 1, FALSE},
     {IO_PATT_DATA_INDEX   , 0, 2, ISinIO, 1, FALSE},

     {IO_CUR_X             , 0, 2, ISinIO, 1, FALSE},                // 50
     {IO_SRC_Y             , 0, 2, ISinIO, 1, FALSE},
     {IO_SRC_X             , 0, 2, ISinIO, 1, FALSE},
     {IO_PATT_DATA         , 0, 2, ISinIO, 1, FALSE},
     {IO_ERR_TERM          , 0, 2, ISinIO, 1, FALSE},

     {IO_R_MISC_CNTL       , 0, 2, ISinIO, 1, FALSE},
     {IO_MAJ_AXIS_PCNT     , 0, 2, ISinIO, 1, FALSE},
     {IO_BRES_COUNT        , 0, 2, ISinIO, 1, FALSE},
     {IO_CMD               , 0, 2, ISinIO, 1, FALSE},
     {IO_LINEDRAW_INDEX    , 0, 2, ISinIO, 1, FALSE},

     {IO_SHORT_STROKE      , 0, 2, ISinIO, 1, FALSE},                // 60
     {IO_BKGD_COLOR        , 0, 2, ISinIO, 1, FALSE},
     {IO_LINEDRAW_OPT      , 0, 2, ISinIO, 1, FALSE},
     {IO_FRGD_COLOR        , 0, 2, ISinIO, 1, FALSE},
     {IO_DEST_X_START      , 0, 2, ISinIO, 1, FALSE},

     {IO_WRT_MASK          , 0, 2, ISinIO, 1, FALSE},
     {IO_DEST_X_END        , 0, 2, ISinIO, 1, FALSE},
     {IO_RD_MASK           , 0, 2, ISinIO, 1, FALSE},
     {IO_DEST_Y_END        , 0, 2, ISinIO, 1, FALSE},
     {IO_CMP_COLOR         , 0, 2, ISinIO, 1, FALSE},

     {IO_SRC_X_START       , 0, 2, ISinIO, 1, FALSE},                // 70
     {IO_BKGD_MIX          , 0, 2, ISinIO, 1, FALSE},
     {IO_ALU_BG_FN         , 0, 2, ISinIO, 1, FALSE},
     {IO_FRGD_MIX          , 0, 2, ISinIO, 1, FALSE},
     {IO_ALU_FG_FN         , 0, 2, ISinIO, 1, FALSE},

     {IO_MULTIFUNC_CNTL    , 0, 2, ISinIO, 1, FALSE},
     {IO_SRC_X_END         , 0, 2, ISinIO, 1, FALSE},
     {IO_SRC_Y_DIR         , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_SSV           , 0, 2, ISinIO, 1, FALSE},
     {IO_SCAN_X            , 0, 2, ISinIO, 1, FALSE},

     {IO_DP_CONFIG         , 0, 2, ISinIO, 1, FALSE},                // 80
     {IO_PATT_LENGTH       , 0, 2, ISinIO, 1, FALSE},
     {IO_PATT_INDEX        , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_SCISSOR_L     , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_SCISSOR_T     , 0, 2, ISinIO, 1, FALSE},

     {IO_PIX_TRANS         , 0, 2, ISinIO, 1, FALSE},
     {IO_PIX_TRANS_HI      , 0, 1, ISinIO, 1, FALSE},
     {IO_EXT_SCISSOR_R     , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_SCISSOR_B     , 0, 2, ISinIO, 1, FALSE},
     {IO_DEST_CMP_FN       , 0, 2, ISinIO, 1, FALSE},

     {IO_ASIC_ID           , 0, 2, ISinIO, 1, FALSE},                // 90
     {IO_LINEDRAW          , 0, 2, ISinIO, 1, FALSE},
     {IO_SEQ_IND           , 0, 1, ISinIO, 1, TRUE},           // VGA
     {IO_HI_SEQ_ADDR       , 0, 2, ISinIO, TRUE, TRUE},
     {IO_SEQ_DATA          , 0, 1, ISinIO, TRUE, TRUE},     

     {VGA_BASE_IO_PORT     , 0, VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, ISinIO, TRUE, TRUE},
     {VGA_END_BREAK_PORT   , 0, VGA_MAX_IO_PORT    - VGA_END_BREAK_PORT + 1, ISinIO, TRUE, TRUE},
     {0x000001ce           , 0, 1, ISinIO, TRUE, TRUE},   /* VGAWonder uses these ports for bank switching */
     {0x000001cf           , 0, 1, ISinIO, TRUE, TRUE},
     {IO_EXT_CUR_Y         , 0, 2, ISinIO, 1, FALSE},

     {0x000003CE           , 0, 2, ISinIO, TRUE, TRUE},              // 100
     {0x00000000, 0, 0, ISinMEMORY, TRUE, FALSE}
    };

#if NUM_DRIVER_ACCESS_RANGES > NUM_ADDRESS_RANGES_ALLOWED
    Insufficient address ranges for 8514/A-compatible graphics cards.
#endif

#define DONT_USE -1     /* Shows that this register is not memory mapped */

/* struct list is address, 0, length, inIOspace, visible, sharable      */
// this order MATCHES  AMACH.H ENUM data  structure

VIDEO_ACCESS_RANGE DriverMMRange_m[NUM_IO_ACCESS_RANGES] = {
     {FALSE                 , DONT_USE  , 4, ISinMEMORY , TRUE  , FALSE},   // Mach DAC registers
     {FALSE                 , DONT_USE  , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 4, ISinMEMORY , TRUE  , FALSE},       
     {FALSE                 , DONT_USE  , 4, ISinMEMORY , TRUE  , FALSE},       
     {MM_DISP_STATUS        , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // First Mach register

     {FALSE                 , DONT_USE  , 2, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , FALSE},
     {MM_CURSOR_OFFSET_LO   , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 1, ISinIO     , TRUE  , FALSE},   // 10
     {MM_CURSOR_OFFSET_HI   , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_CONFIG_STATUS_1    , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},

     {MM_CONFIG_STATUS_2    , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_CURSOR_COLOR_0     , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CURSOR_COLOR_1     , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},

     {MM_HORZ_CURSOR_OFFSET , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 20
     {MM_VERT_CURSOR_OFFSET , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DISP_CNTL          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CRT_PITCH          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CRT_OFFSET_LO      , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_CRT_OFFSET_HI      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_EXT_CURSOR_COLOR_0 , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_CURSOR_COLOR_1 , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_SUBSYS_CNTL        , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 30
     {FALSE                 , DONT_USE  , 1, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_ADVFUNC_CNTL       , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},

     {MM_EXT_GE_STATUS      , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 40
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_GE_OFFSET_LO       , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_BOUNDS_LEFT        , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_BOUNDS_TOP         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_BOUNDS_RIGHT       , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_BOUNDS_BOTTOM      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CUR_Y              , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_PATT_DATA_INDEX    , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_CUR_X              , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 50
     {MM_SRC_Y              , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_SRC_X              , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_PATT_DATA          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_ERR_TERM           , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_MAJ_AXIS_PCNT      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_BRES_COUNT         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_LINEDRAW_INDEX     , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_SHORT_STROKE       , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 60
     {MM_BKGD_COLOR         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_LINEDRAW_OPT       , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_FRGD_COLOR         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DEST_X_START       , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_WRT_MASK           , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DEST_X_END         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_RD_MASK            , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DEST_Y_END         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CMP_COLOR          , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_SRC_X_START        , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 70
     {MM_BKGD_MIX           , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_ALU_BG_FN          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_FRGD_MIX           , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_ALU_FG_FN          , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_MULTIFUNC_CNTL     , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_SRC_X_END          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_SRC_Y_DIR          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SSV            , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_SCAN_X             , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_DP_CONFIG          , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 80
     {MM_PATT_LENGTH        , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_PATT_INDEX         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SCISSOR_L      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SCISSOR_T      , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_PIX_TRANS          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_PIX_TRANS_HI       , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SCISSOR_R      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SCISSOR_B      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DEST_CMP_FN        , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},   // 90
     {MM_LINEDRAW           , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},    // VGA
     {FALSE                 , DONT_USE  , 2, ISinMEMORY , TRUE  , TRUE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},     

     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},
     {MM_EXT_CUR_Y          , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , TRUE}     // 100
    };



#endif  /* defined INCLUDE_SETUP_M */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\ati\mini\vdptocrt.h ===
/************************************************************************/
/*                                                                      */
/*                              VDPTOCRT.H                              */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.2  $
    $Date:   20 Jul 1995 18:04:36  $
    $Author:   mgrubac  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/vdptocrt.h  $
 * 
 *    Rev 1.2   20 Jul 1995 18:04:36   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.1   31 Aug 1994 16:33:56   RWOLFF
 * Eliminated redundant resolution definitions.
 * 
 *    Rev 1.0   31 Jan 1994 11:51:12   RWOLFF
 * Initial revision.
        
           Rev 1.0   16 Aug 1993 13:31:18   Robert_Wolff
        Initial revision.
        
           Rev 1.0   30 Apr 1993 16:46:06   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    VDPTOCRT.H -  Constants and prototypes for the VDPTOCRT.C module.

#endif



// constants

/*
 * Headers for the VDP file sections we are interested in
 */
#define LIMITSSECTION   "[OPERATIONAL_LIMITS]"
#define TIMINGSSECTION  "[PREADJUSTED_TIMINGS]"

/*
 * Frequently-referenced character definitions
 */
#define HORIZTAB    '\x09'  /* Horizontal tab */
#define LINEFEED    '\x0A'  /* Line feed */

extern long normal_to_skip2(long normal_number);

#ifdef INCLUDE_VDPTOCRT
BOOL skip1 = FALSE;
#else
extern BOOL skip1;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\7555over.c ===
/**********************************************************
*  Copyright (c) 1996-1997 Microsoft Corporation.
*  Copyright (c) 1996-1997 Cirrus Logic, Inc.
***********************************************************
*       File Name:  7555OVER.C
*
*       Module Abstract:
*       ----------------
*       This contains functions needed to support overlay hardware.
*
*       Functions:
*       ----------
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
* myf31 :02-24-97 : Fixed enable HW Video, panning scrolling enable,screen move
*                   video window have follow moving
* myf34 :04-15-97 : Supported YUY2 format for NT.
***********************************************************/


/* #includes ---------------------------------------------*/
#include "PreComp.h"

#if DIRECTDRAW
#include "overlay.h"
#include "7555bw.h"

static int ScaleMultiply(DWORD   dw1,
                         DWORD   dw2,
                         LPDWORD pdwResult);


/**********************************************************
*
*       Name:  RegInit7555Video
*
*       Module Abstract:
*       ----------------
*       This function is called to program the video format and
*       the physicall offset of the video data in the frame buffer.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/

VOID RegInit7555Video (PDEV * ppdev,PDD_SURFACE_LOCAL lpSurface)
{
    DWORD dwTemp;
    DWORD dwFourcc;
    WORD  wBitCount;

    LONG lPitch;
    WORD wTemp;
    RECTL rDest;
    WORD wSrcWidth;
    WORD wSrcWidth_clip;
    WORD wDestWidth;
    WORD wSrcHeight;
    WORD wSrcHeight_clip;
    WORD wDestHeight;
    DWORD dwFBOffset;
    BYTE bRegCR31;
    BYTE bRegCR32;
    BYTE bRegCR33;
    BYTE bRegCR34;
    BYTE bRegCR35;
    BYTE bRegCR36;
    BYTE bRegCR37;
    BYTE bRegCR38;
    BYTE bRegCR39;
    BYTE bRegCR3A;
    BYTE bRegCR3B;
    BYTE bRegCR3C;
    BYTE bRegCR3D;
    BYTE bRegCR3E;
    BYTE bRegCR3F;
    BYTE bRegCR40;
    BYTE bRegCR41;
    BYTE bRegCR42;
    BYTE bRegCR51;
    BYTE bRegCR5D;              //myf32
    BYTE bRegCR5F;              //myf32
    BYTE bRegSR2F;              //myf32
    BYTE bRegSR32;              //myf32
    BYTE bRegSR34;              //myf32
    BYTE bTemp;
    BYTE bVZoom;
    WORD fTemp=0;
    ULONG ulTemp=0;
    BOOL  bOverlayTooSmall = FALSE;
    static DWORD giAdjustSource;

    //myf32 added
    bRegSR2F = Regs.bSR2F;
    bRegSR32 = Regs.bSR32;
    bRegSR34 = Regs.bSR34;

    bRegCR5D = Regs.bCR5D;
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x5F);
    bRegCR5F = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
    bRegCR5F |= (Regs.bCR5F & 0x80);
    //myf32 end

    /*
     * Init some values
     */
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x42);
//  bRegCR42 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC;  //mask Chroma key
                                                              // & FIFO
    bRegCR42 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xF0;  //mask Chroma key
                                                              // & FIFO, myf32
    bRegCR42 |= (Regs.bCR42 & CR42_MVWTHRESH);   //myf32
    bRegCR42 |= 0x10;
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x36);              //myf29
    bRegCR36 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x40;    //myf29
    bRegCR36 |= 0x20;                   //set Excess 128 Data Format, myf29

    /*
     * Determine the format of the video data
     */
    if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        GetFormatInfo (ppdev,&(lpSurface->lpGbl->ddpfSurface),
                             &dwFourcc, &wBitCount);
    }
    else
    {
        // This needs to be changed when primary surface is RGB 5:6:5
        dwFourcc = BI_RGB;
        wBitCount = (WORD) ppdev->cBitsPerPixel;
    }

    /*
     * Determine the rectangle for the video window
     */
    PanOverlay1_Init(ppdev, lpSurface, &rDest, &ppdev->rOverlaySrc,
                     &ppdev->rOverlayDest, dwFourcc, wBitCount);
    // rVideoRect is now adjusted and clipped to the panning viewport.
    // disable overlay if totally clipped by viewport

    if (((rDest.right - rDest.left) <= 0) ||
        ((rDest.bottom - rDest.top) <= 0))
    {
        bOverlayTooSmall = TRUE;
    }
    dwTemp = (DWORD)(ppdev->min_Yscreen - ppdev->rOverlayDest.top);
    if ((ppdev->rOverlaySrc.bottom - ppdev->rOverlaySrc.top -(LONG)dwTemp) <=0)
        bOverlayTooSmall = TRUE;

    lPitch = lpSurface->lpGbl->lPitch;

    wSrcWidth_clip  = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
    wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - srcTop_clip);

    wSrcWidth  = (WORD)(LONG)(ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left);
    wDestWidth = (WORD)(LONG)(ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
    wSrcHeight = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - ppdev->rOverlaySrc.top);
    wDestHeight = (WORD)(LONG)(ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top);

    // Determine horizontal upscale coefficient (CR31[7:0],CR39[7:4])
    wTemp = ((WORD)(((DWORD)wSrcWidth  << 12) / (DWORD)wDestWidth)) & 0x0FFF;
    if (wTemp != 0 && bLeft_clip)
    {
        srcLeft_clip = srcLeft_clip *(LONG)wTemp/4096 + ppdev->rOverlaySrc.left;
        wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
    }
    else if (bLeft_clip)
    {
        srcLeft_clip = srcLeft_clip + ppdev->rOverlaySrc.left;
        wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
    }

    bRegCR39 = (BYTE)((wTemp & 0x0F) << 4);
    bRegCR31 = (BYTE)(wTemp >> 4) & 0xFF;

    // Determine vertical upscale coefficient (CR32[7:0],CR39[3:0])
    bVZoom=0;
    wTemp = ((WORD)(((DWORD)wSrcHeight << 12) / (DWORD)wDestHeight)) & 0x0FFF;
    if (wTemp != 0) {
        bVZoom=1;
        fTemp = wTemp;
        if (fTemp < 2048 ) // Zoom > 2.0
            wTemp=((WORD)(((DWORD)wSrcHeight << 12) / (DWORD)(wDestHeight+1))) & 0x0FFF;
    }
    if (wTemp != 0 && bTop_clip)
    {
        srcTop_clip = srcTop_clip * (LONG)wTemp/4096 + ppdev->rOverlaySrc.top;
        wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom -srcTop_clip);
    }
    else if (bTop_clip)
    {
        srcTop_clip = srcTop_clip + ppdev->rOverlaySrc.top;
        wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom -srcTop_clip);
    }

    bRegCR39 |= (BYTE)(wTemp & 0x0F);
    bRegCR32 = (BYTE)(wTemp >> 4) & 0xFF;
    DISPDBG((0,"wTemp = 0x%x",wTemp));

    // Determine Vertical Height (CR38[7:0], CR36[3:2])
//    wTemp = wSrcHeight;
    wTemp = wSrcHeight_clip;    //myf32
    DISPDBG((0,"fTemp = 0x%x",fTemp));
    if (wTemp != 0 &&
        (fTemp > 2730 || fTemp ==0 || ( fTemp > 1365 && fTemp < 2048 ) ) )
        wTemp--;       //#tt10, Height minus one only if upscale rate <1.5
                       //#tt10  2 <    <3

    bRegCR38 = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0300) >> 6;


    // Determine Horizontal position start (CR34[7:0], CR33[7:5])
    // handle 7555-BB MVA pitch bug (QWORD should be DWORD)
    wTemp    = (WORD)rDest.left;
    bRegCR34 = (BYTE)wTemp;
    bRegCR33 = (wTemp & 0x0700) >> 3;

    // Reset Brightness control (CR35[7:0])
    bRegCR35 = 0x0;

    // Determine Vertical Start (CR37[7:0], CR36[1:0])
    wTemp    = (WORD)rDest.top;
    bRegCR37 = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0300) >> 8;


    // Determine Video Start Address (CR40[0], CR3A[6:0], CR3E[7:0], CR3F[3:0])
    giAdjustSource = (srcTop_clip * lpSurface->lpGbl->lPitch)
                   + ((srcLeft_clip * wBitCount) >> 3); //myf32
//  giAdjustSource = (ppdev->rOverlaySrc.top * lpSurface->lpGbl->lPitch)
//                     + ((ppdev->rOverlaySrc.left * wBitCount) >> 3);
    ppdev->sOverlay1.lAdjustSource = giAdjustSource;    //myf32
    dwFBOffset = (DWORD)(lpSurface->lpGbl->fpVidMem + giAdjustSource);
//  dwFBOffset = (lpSurface->lpGbl->fpVidMem - ppdev->dwScreenFlatAddr)
//             + giAdjustSource;        //myf32

    DISPDBG((0,"lpSurface->lpGbl->fpVidMem = 0x%08x",
                                  lpSurface->lpGbl->fpVidMem));
    DISPDBG((0,"giAdjustSource = 0x%08x",giAdjustSource));
    DISPDBG((0,"dwFBOffset = 0x%08x",dwFBOffset));

    dwFBOffset >>= 2;

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3A);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;

    bRegCR3A = (bTemp & ~0x7F) | (BYTE)((dwFBOffset & 0x0FE000) >> 13);
    bRegCR3E = (BYTE)((dwFBOffset & 0x001FE0) >> 5);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
    bRegCR3F = (bTemp & ~0x0F) | (BYTE)((dwFBOffset & 0x00001E) >> 1);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x40);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
    bRegCR40 = (bTemp & ~0x01) | (BYTE)(dwFBOffset & 0x000001);

    //Determine Video Pitch (CR3B[7:0], CR36[4])
    wTemp = (WORD)(lpSurface->lpGbl->lPitch >> 4);              //QWORDs

    bRegCR3B = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0100) >> 4;

    // Determine Data Format (CR3E[3:0])
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3C);
    bRegCR3C = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x10;
                                                //mask out prev VW width

    switch (dwFourcc)
    {
       case FOURCC_PACKJR:
           bRegCR3C |= 0x02;                    // Pack JR
           break;

       case BI_RGB:
           switch(wBitCount)
           {
             case 8:
                bRegCR3C |= 0x09;               // 8 bit palettized
                break;

             case 16:
                bRegCR3C |= 0x01;               // RGB 5:5:5
                break;
           }
           break;

       //myf32 added
       case BI_BITFIELDS:
           switch(wBitCount)
           {
             case 8:
                bRegCR3C |= 0x09;               // 8 bit palettized
                break;

             case 16:
                bRegCR3C |= 0x04;               // RGB 5:6:5
                break;
           }
           break;
       //myf32 end

       case FOURCC_YUV422:
           bRegCR3C |= 0x03;                    // YUV 4:2:2
           break;

       case FOURCC_YUY2:                //myf34 test
           bRegCR3C |= 0x03;                    // YUY2
//         CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x2C);
//         bRegSR2C = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) ;
//         bRegSR2C |= 0x40;            //SR2c[6] = 1
//         CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x2C |(WORD)bRegSR2C << 8);
           break;
    }


    // Determine Horizontal width (CR3D[7:0], CR3C[7:5])
    // NOTE: assumes Horz Pixel Width [0] = 0

    wTemp = wSrcWidth_clip;     //myf32
//  wTemp = wSrcWidth;

    if (wTemp != 0 ) wTemp--;                   //Width minus one for laptop
    bRegCR3D = (BYTE)((WORD)wTemp >> 1);
    bRegCR3C |= (wTemp & 0x0600) >> 3;
    bRegCR3C |= (BYTE)((wTemp & 0x0001) << 5) ;


    // Enable Horizontal Pixel Interpolation (CR3F[7])
    bRegCR3F |= 0x80;

    // Enable Vertical Pixel Interpolation (CR3F[6])
    //#tt Debug- The CE rev. has problem when vertical interpolation is on
    //#tt Debug- Disable it for now.
    //#tt   bRegCR3F |= 0x40;

    // Enable Right Side transition threshold (CR41[5:0])
    bRegCR41 = 0x3E;

    // Disable V-PORT (CR58[7:0])
    bRegCR51 = 0x0;

    /*
     * If we are color keying, we will set that up now
     */
    if (lpSurface->dwReserved1 & OVERLAY_FLG_COLOR_KEY)
    {
        bRegCR3F |= 0x20;               //Enable Occlusion
        bRegCR42 &= ~0x1;               //Disable Chroma Key
        bRegCR5F &= ~0x80;      //myf32 //Disable CR5D[7:0] if color key,
                                        //so disable CR5F[7]
        bRegCR5D = 0;           //myf32

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x1A);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

        // Set CR1A[3:2] to timing ANDed w/ color
        bTemp &= ~0x0C;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, bTemp);

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x1D);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;

        if (ppdev->cBitsPerPixel == 8)
        {
            CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (bTemp & ~0x38));
            ulTemp= 0x0C | (ppdev->wColorKey << 8);
            CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, ulTemp);// Output color to GRC
            ulTemp= 0x0D;
            CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, ulTemp);// Output color to GRD

        }
        else
        {
            CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (bTemp & ~0x30) | 0x08);
            ulTemp= 0x0C | (ppdev->wColorKey << 8);
            CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, ulTemp);// Output color to GRC
            ulTemp= 0x0D | (ppdev->wColorKey & 0xff00);
            CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, ulTemp);// Output color to GRD

        }
    }
    else if (lpSurface->dwReserved1 & OVERLAY_FLG_SRC_COLOR_KEY)
    {
        BYTE bYMax, bYMin, bUMax, bUMin, bVMax, bVMin;

        bRegCR3F |= 0x20;               //Enable Occlusion
        bRegCR42 |= 0x1;                //Enable Chroma Key
        bRegCR5F &= ~0x80;      //myf32 //Disable CR5D[7:0] if color key,
                                        //so disable CR5F[7]
        bRegCR5D = 0;           //myf32

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX,  0x1A);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        // Set CR1A[3:2] to timing ANDed w/ color
        bTemp &= ~0x0C;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA,  bTemp);

        /*
         * Determine min/max values
         */
        if ((dwFourcc == FOURCC_YUV422) || (dwFourcc == FOURCC_YUVPLANAR) ||
            (dwFourcc == FOURCC_YUY2) ||                //myf34
            (dwFourcc == FOURCC_PACKJR))                //myf32
        {
            bYMax = (BYTE)(DWORD)(ppdev->dwSrcColorKeyHigh >> 16);
            bYMin = (BYTE)(DWORD)(ppdev->dwSrcColorKeyLow >> 16);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 8) & 0xff);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 8) & 0xff);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh & 0xff);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow & 0xff);
            if (dwFourcc == FOURCC_PACKJR)
            {
                bYMax |= 0x07;
                bUMax |= 0x03;
                bVMax |= 0x03;
                bYMin &= ~0x07;
                bUMin &= ~0x03;
                bVMin &= ~0x03;
            }
        }
        else if ((dwFourcc == 0) && (wBitCount == 16))
        {
            /*
             * RGB 5:5:5
             */
            bYMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 7) & 0xF8);
            bYMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 7) & 0xF8);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 2) & 0xF8);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 2) & 0xF8);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh << 3);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow << 3);
            bYMax |= 0x07;
            bUMax |= 0x07;
            bVMax |= 0x07;

        }
        else if (dwFourcc == BI_BITFIELDS)
        {
            /*
             * RGB 5:6:5
             */
            bYMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 8) & 0xF8);
            bYMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 8) & 0xF8);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 3) & 0xFC);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 3) & 0xFC);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh << 3);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow << 3);
            bYMax |= 0x07;
            bUMax |= 0x03;
            bVMax |= 0x07;
        }
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x0C | (WORD)bYMin <<8));//GRC
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x0D | (WORD)bYMax <<8));//GRd
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x1C | (WORD)bUMin <<8));//GR1C
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x1D | (WORD)bUMax <<8));//GR1D
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x1E | (WORD)bVMin <<8));//GR1E
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x1F | (WORD)bVMax <<8));//GR1F

    }
    else
    {
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX,  0x1A);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX,  (bTemp & ~0x0C));
        bRegCR3F &= ~0x20;                      // disable occlusion

    }

    /*
     * Set up alignment info
     */
    if (ppdev->cBitsPerPixel != 24)
    {
        WORD wXAlign;
        WORD wXSize;

        if (ppdev->cBitsPerPixel == 8)
        {
            wXAlign = (WORD)rDest.left & 0x03;
            wXSize = (WORD)(rDest.right - rDest.left) & 0x03;
        }
        else
        {
            wXAlign = (WORD)(rDest.left & 0x01) << 1;
            wXSize = (WORD)((rDest.right - rDest.left) & 0x01) << 1;
        }
    }

    //  disable overlay if totally clipped by viewport
    //  or overlay is too small to be supported by HW
    //
    if (bOverlayTooSmall)
    {
        DisableVideoWindow(ppdev);                      // disable overlay
        ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;  // totally clipped
    }
    else
    {

        /*
         * Program the video window registers
        */
        //myf32 added
        CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x2F |(WORD)bRegSR2F << 8);//SR2F
        CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x32 |(WORD)bRegSR32 << 8);//SR32
        CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x34 |(WORD)bRegSR34 << 8);//SR34
        //myf32 end

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x31 | (WORD)bRegCR31 << 8);//CR31
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x32 | (WORD)bRegCR32 << 8);//CR32

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x34 | (WORD)bRegCR34 << 8);//CR34
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x33 | (WORD)bRegCR33 << 8);//CR33

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x35 | (WORD)bRegCR35 << 8);//CR35
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x36 | (WORD)bRegCR36 << 8);//CR36
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x37 | (WORD)bRegCR37 << 8);//CR37
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x38 | (WORD)bRegCR38 << 8);//CR38
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x39 | (WORD)bRegCR39 << 8);//CR39
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3B | (WORD)bRegCR3B << 8);//CR3B

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3C | (WORD)bRegCR3C << 8);//CR3C
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3D | (WORD)bRegCR3D << 8);//CR3D
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x41 | (WORD)bRegCR41 << 8);//CR41
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x42 | (WORD)bRegCR42 << 8);//CR42
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x51 | (WORD)bRegCR51 << 8);//CR51

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x40 | (WORD)bRegCR40 << 8);//CR40
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3A | (WORD)bRegCR3A << 8);//CR3A
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3E | (WORD)bRegCR3E << 8);//CR3E
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3F | (WORD)bRegCR3F << 8);//CR3F
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x5D | (WORD)bRegCR5D << 8);//CR5D
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x5F | (WORD)bRegCR5F << 8);//CR5F

        if (lpSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR)
            CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3F |(WORD)0x10 <<8);

        EnableVideoWindow (ppdev);
    }
}
/**********************************************************
*
*       Name:  RegMoveVideo
*
*       Module Abstract:
*       ----------------
*       This function is called to move the video window that has
*       already been programed.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/

VOID RegMove7555Video (PDEV * ppdev,PDD_SURFACE_LOCAL lpSurface)
{
     RegInitVideo (ppdev,lpSurface);
}



/**********************************************************
*
*       Name:  DisableVideoWindow
*
*       Module Abstract:
*       ----------------
*       turn off video window
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/
VOID DisableVideoWindow (PDEV * ppdev)
{
    UCHAR    temp;

    DISPDBG((0, "DisableVideoWindow"));

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3c);
    temp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (temp & ~0x10));

}

/**********************************************************
*
*       Name:  EnableVideoWindow
*
*       Module Abstract:
*       ----------------
*       turn on video window
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/
VOID EnableVideoWindow (PDEV * ppdev)
{
    UCHAR    temp;
    DISPDBG((0, "EnableVideoWindow"));

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3c);
    temp  = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (temp | 0x10));

}

/**********************************************************
*
*       Name:  ClearAltFIFOThreshold
*
*       Module Abstract:
*       ----------------
*
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/
VOID ClearAltFIFOThreshold (PDEV * ppdev)
{
    UCHAR    temp;
    DISPDBG((0, "ClearAltFIFOThreshold"));

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x41);
    temp  = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (temp & ~0x20));
}



/**********************************************************
*
*       Name:  Is7555SufficientBandwidth
*
*       Module Abstract:
*       ----------------
*       Determines is sufficient bandwidth exists for the requested
*       configuration.
*
*       Output Parameters:
*       ------------------
*       TRUE/FALSE
*       It also sets the global parameter lFifoThresh, which gets
*       programed in RegInitVideo().
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*
*
***********************************************************
*
* The FIFOs:
*
*       CRT  FIFO is 28 levels x 64-bits wide (SR7[0])
*       MVA  FIFO is ?? levels x ??-bits wide (????)
*       DSTN FIFO is 16 levels x 32-bits wide (SR2F[3:0])
*
*
***********************************************************/
BOOL Is7555SufficientBandwidth (PDEV * ppdev,WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags)
{
    //myf33 - New Bandwith Code
    BOOL  fSuccess = FALSE;
    DWORD dwVCLK, dwMCLK;

    USHORT  uMCLKsPerRandom;      //RAS# cycles in MCLKs
    USHORT  uMCLKsPerPage;        //CAS# cycles in MCLKs
    USHORT  uGfxThresh;           //Graphic FIFO Threshold (always 8)
    USHORT  uMVWThresh;           //MVW FIFO Threshold (8,16 or 32)
    USHORT  uDSTNGfxThresh, uDSTNMVWThresh;

    //VPort BW document variables
    USHORT  uGfx, uMVW;           //Graphics, Video Window
    USHORT  uDSTNGfxA, uDSTNGfxB, uDSTNMVWA, uDSTNMVWB;

    USHORT  nVW = 0;              //n (VW), n (Graphics)
    USHORT  nGfx = 0x40;          //n (VW), n (Graphics)
    USHORT  vVW, vGfx;            //v (VW), v (Gfx)

    DWORD dwTemp;
    BOOL fDSTN;
    BYTE bSR0F, bSR20, bSR2F, bSR32, bSR34;
    BYTE bGR18, bCR42;
    BYTE bCR51, bCR5A, bCR5D, bCR01, bCR5F;
    BYTE b3V;
    BOOL fColorKey = FALSE;     //myf32
    DWORD dwSrcWidth, dwDestWidth;

    if (dwFlags & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))
        fColorKey = TRUE;

//  if ((ppdev->cBitsPerPixel == 16) && (ppdev->cxScreen == 1024))
//      fColorKey = FALSE;

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
    bSR0F = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
    if ((ppdev->cBitsPerPixel == 16) && fColorKey)
    {
        if (((ppdev->Hres == 1024) && (bSR0F & 1)) ||
            (ppdev->cxScreen == 1024))
        {
            DISPDBG((0, "IsSufficientBandwidth() : 16bpp XGA PANEL || 1K mode"));
            return (FALSE);
        }
    }

    //myf32 begin
    if (ppdev->flCaps & CAPS_TV_ON)            //if TV on disable HW video
    {
//      ppdev->ulCAPS |= CAPS_SW_POINTER;
        DISPDBG((0, "IsSufficientBandwidth() : TV Enable"));
        return (FALSE);
    }

#if 0           //don't support panning scrolling
    if ((ppdev->cxScreen > ppdev->Hres) && (bSR0F & 1))
    {
        DISPDBG((0, "IsSufficientBandwidth() : Panning Scroll Enable"));
        return (FALSE);
    }
#endif

     //myf32 end

    /*
     * Don's support overlay if >=24bpp
     */
    if (ppdev->cBitsPerPixel == 24 || ppdev->cBitsPerPixel == 32)
    {
        DISPDBG((0, "IsSufficientBandwidth() : 24bpp Mode enable"));
        return (FALSE);
    }

    /*
     * Get current register settings from the chip
     */
    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x0f);
    bSR0F = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) ;

    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x20);
    bSR20 = CP_IN_BYTE(ppdev->pjPorts, SR_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x2f);
    bSR2F = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) & ~(BYTE)SR2F_HFAFIFOGFX_THRESH;

    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x32);
    bSR32 = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) & ~(BYTE)SR32_HFAFIFOMVW_THRESH;

    CP_OUT_BYTE(ppdev->pjPorts, INDEX_REG, 0x18);
    bGR18 = CP_IN_BYTE(ppdev->pjPorts, DATA_REG) ;

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x01);
    bCR01 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x5F);
    bCR5F = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & ~0x80;

    bCR5D = 0;
    bCR51 = 0;
    bCR5A = 0x40;       //Alan Kobayashi
    bSR34 = 0;  // @@@ Is this right?


    /*
     * Determine MCLK and VCLK
     */
    dwMCLK = Get7555MCLK(ppdev);        // Measured in KHz
    dwVCLK = GetVCLK(ppdev);            // Measured in KHz
    if ( dwVCLK ==0 )
        return (FALSE);

//myf32 added
    // check if 3.3 voltage, (SR2F[5] =0 : 3V, =1 : 5V)
    if (bSR2F & 0x40)
        b3V = 0;
    else
        b3V = 1;

    if (ppdev->ulChipID == CL7556_ID)
    {
        if (dwVCLK > 80000)
        {
            DISPDBG ((0,"Insuffieint bandwidth() : dwVCLK > 80MHz"));
            return(FALSE);
        }
    }
    else if (ppdev->ulChipID == CL7555_ID)
    {
        if (b3V)
        {
            if (dwVCLK > 65000)
            {
                DISPDBG ((0,"Insuffieint bandwidth() : dwVCLK > 65MHz"));
                return(FALSE);
            }
        }
        else
        {
            if (dwVCLK > 75000)
            {
                DISPDBG ((0,"Insuffieint bandwidth() : dwVCLK > 75MHz"));
                return(FALSE);
            }
        }
    }
//myf32 end


    /*
     * See if there is enough bandwidth.
     *
     * CL-GD7555 has sufficient bandwidth when the following
     *  equation is satisfied:
     *
     * (Gfx + MVW + VP + DSTN) * MCLK Period <= v * VCLK period
     *
     * (Gfx = Graphics, MVW = Motion Video Window, VP = Video
     *  Port, DSTN = Dual Scan Transistor Network, MCLK =
     *  Memory Clock, VCLK = Video Clock)
     *
     * In color/chroma key mode, this equation is checked once
     *  with VP based on n(Gfx), and using v(Gfx).  In non-color/chroma
     *  key mode, this equation is checked twice, once without the
     *  MVW term, basing VP on n(Gfx), using DSTN for Gfx, and using
     *  v(Gfx), and once without the Gfx term, basing VP on n(MVW),
     *  using DSTN for MVW, and using v(MVW).
     */

    /*
     * Graphics = R + (GFX FIFO Threshold - 1)P
     */

    // Get R based on the table (from AHRM v1.1):
    //
    // SR20[6] GR18[2] SR0F[2]  R(MCLKs)
    //
    //   0       1       0         8
    //   1       1       0         9
    //
    uMCLKsPerRandom = 100;    // Start with an invalid value
    if (!(bSR20 & SR20_9MCLK_RAS))
    {
        if (bGR18 & GR18_LONG_RAS)
        {
            if (!(bSR0F & SR0F_DISPLAY_RAS))
                uMCLKsPerRandom = 8;
        }
    }
    else
    {
        if (bGR18 & GR18_LONG_RAS)
        {
            if (!(bSR0F & SR0F_DISPLAY_RAS))
                uMCLKsPerRandom = 9;
        }
    }

    // See if we got a valid value
    if (100 == uMCLKsPerRandom)
    {
        DISPDBG ((0,"IsSufficientBandwidth(): Unknown RAS# cycle timing."));
        goto Error;
    }
    DISPDBG ((0," uMCLKsPerRandom = %u", uMCLKsPerRandom));

    // Get P - We assume 2 MCLKs per page cycle
    uMCLKsPerPage = 2;
    DISPDBG ((0," uMCLKsPerPage = %u", uMCLKsPerPage));

    // Get GFX FIFO Threshold - It's hardwired to 8
    uGfxThresh = GFXFIFO_THRESH;
    DISPDBG ((0," uGfxThresh = %u", uGfxThresh));

    // Graphics = R + (GFX FIFO Threshold - 1) * P
    uGfx = uMCLKsPerRandom + ((uGfxThresh - 1) * uMCLKsPerPage);
    DISPDBG ((0," uGfx = %u", uGfx));


    /*
     * Video Window = R + (VW FIFO Threshold - 1) * P
     */

    // Get VW FIFO Threshold - From table (on BW sheet)
    //
    // GFX Depth  MVW Depth  VW FIFO Thresh
    //
    //     8          8            8
    //    16          8            8
    //     8         16           16
    //    16         16            8
    //
    if (fColorKey)
    {
        if (wVideoDepth > 8)
        {
            if (ppdev->cBitsPerPixel > 8)
                uMVWThresh = 8;
            else
                uMVWThresh = 16;
        }
        else
            uMVWThresh = 8;
    }
    else
    {
        if (wVideoDepth > 8)
            uMVWThresh = 8;
        else
            uMVWThresh = 16;
    }
    DISPDBG ((0," uMVWThresh = %u", uMVWThresh));

    // Video Window = R + (VW FIFO Threshold - 1) * P
    uMVW = uMCLKsPerRandom + ((uMVWThresh - 1) * uMCLKsPerPage);
    DISPDBG ((0," uMVW = %u", uMVW));


    // Determine Source and Destination VW Widths
    dwSrcWidth = lpSrc->right - lpSrc->left;
    dwDestWidth = lpDest->right - lpDest->left;
    DISPDBG ((0," dwSrcWidth = %d", dwSrcWidth));
    DISPDBG ((0," dwDestWidth = %d", dwDestWidth));


    // If the video port capture is enabled, calculate VPort stuff
#if 0   //00 for New structure Code
    if (dwFlags & OVERLAY_FLG_CAPTURE )
    {
        int iNumShift, iDenomShift;
        DWORD dwNum, dwDenom;
        DWORD dwXferRate;
        DWORD dwVPortFreq;

        // Convert transfer rate to video port frequency, which assumes
        //  16-bits per clock
        if (!dwMaxPixelsPerSecond)
            dwXferRate = 14750000ul;
        else
            dwXferRate = dwMaxPixelsPerSecond;

         dwXferRate = 14750000ul;       //hardcoded temporarily

         dwVPortFreq = (dwXferRate * (DWORD)wVideoDepth) / 16;
         DISPDBG ((0," dwVPortFreq = %lu", dwVPortFreq));

        /*
         * V-Port = R + (n - 1) * P
         *
         * n is calculated for graphics and video window.
         */

        // Calculate n(Gfx) and VPort(Gfx)

        // n(Gfx) = VPort freq * Gfx Thresh * VPort depth   cap wdth
        //          ------------------------------------- * ---------
        //                    VCLK * Gfx depth              xfer wdth

        // Being very careful to avoid overflows while maintaining decent
        //  accuracy.

        iNumShift = ScaleMultiply(dwVPortFreq, (DWORD)uGfxThresh, &dwNum);
        DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
        iNumShift += ScaleMultiply(dwNum, (DWORD)wVideoDepth, &dwNum);
        DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
        iNumShift += ScaleMultiply(dwNum, (DWORD)dwPrescaleWidth, &dwNum);
        DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));

        iDenomShift = ScaleMultiply(dwVCLK, (DWORD)wGfxDepth,&dwDenom);
        DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));
        iDenomShift += ScaleMultiply(dwDenom, (DWORD)dwCropWidth, &dwDenom);
        DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));

        // Even things up for the divide
        if (iNumShift > iDenomShift)
        {
            dwDenom >>= (iNumShift - iDenomShift);
        }
        else if (iDenomShift > iNumShift)
        {
            dwNum >>= (iDenomShift - iNumShift);
        }
        DISPDBG ((0," dwNum = %lu, dwDenom = %lu", dwNum, dwDenom));

        // Be sure rounding below doesn't overflow
        if ((0xFFFFFFFF - dwDenom) < dwNum)
        {
            dwNum >>= 1;
            dwDenom >>= 1;
        }
        DISPDBG ((0," dwNum = %lu, dwDenom = %lu", dwNum, dwDenom));

        // Protect from a divide by 0 - this should never happen
        if (0 == dwDenom)
        {
            DISPDBG ((0,"ChipCheckBandwidth(): Invalid n(Gfx) denominator (0)."));
            goto Error;
        }

        // Round up
        nGfx = (UINT)((dwNum + dwDenom - 1ul) / dwDenom);
        DISPDBG ((0," nGfx = %u", nGfx));

        // Only 3 bits for nGfx, so scale it and save factor
        uGfxFactor = 1;
        while (nGfx > 7)
        {
            nGfx++;
            nGfx >>= 1;
            uGfxFactor <<= 1;
            DISPDBG ((0," nGfx = %u, uGfxFactor = %u", nGfx, uGfxFactor));
        }

        // For a 0 n(Gfx), we assume the overhead is negligible.
        if (0 == nGfx)
        {
            uVPortGfx = 0;
        }
        else
        {
            // V-Port = R + (n - 1) * P
            uVPortGfx = uMCLKsPerRandom + ((nGfx - 1) * uMCLKsPerPage);
            uVPortGfx *= uGfxFactor;
        }
        DISPDBG ((0," uVPortGfx = %u", uVPortGfx));

        // If the video window is enabled, calculate n(MVW) and VPort(MVW)
        if (dwFlags & OVERLAY_FLG_CAPTURE)
        {
            // n(VW) = VPort freq * VW Thresh * VPort depth   disp wdth   cap wdth
            //         ------------------------------------ * --------- * ---------
            //                   VCLK * VW depth              src wdth    xfer wdth

            // Being very careful to avoid overflows while maintaining decent
            //  accuracy.

            iNumShift = ScaleMultiply(dwVPortFreq, (DWORD)uMVWThresh, &dwNum);
            DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
            iNumShift += ScaleMultiply(dwNum, (DWORD)wVideoDepth, &dwNum);
            DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
            iNumShift += ScaleMultiply(dwNum, (DWORD)dwDestWidth, &dwNum);
            DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
            iNumShift += ScaleMultiply(dwNum, (DWORD)dwPrescaleWidth, &dwNum);
            DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));

            iDenomShift = ScaleMultiply(dwVCLK, (DWORD)wVideoDepth, &dwDenom);
            DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));
            iDenomShift += ScaleMultiply(dwDenom, (DWORD)dwSrcWidth, &dwDenom);
            DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));
            iDenomShift += ScaleMultiply(dwDenom, (DWORD)dwCropWidth, &dwDenom);
            DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));

            // Even things up for the divide
            if (iNumShift > iDenomShift)
            {
                dwDenom >>= (iNumShift - iDenomShift);
            }
            else if (iDenomShift > iNumShift)
            {
                dwNum >>= (iDenomShift - iNumShift);
            }
            DISPDBG ((0," dwNum = %lu, dwDenom = %lu", dwNum, dwDenom));

            // Be sure rounding below doesn't overflow
            if ((0xFFFFFFFF - dwDenom) < dwNum)
            {
                dwNum >>= 1;
                dwDenom >>= 1;
            }
            DISPDBG ((0," dwNum = %lu, dwDenom = %lu", dwNum, dwDenom));

            // Protect from a divide by 0 even though this should never happen
            if (0 == dwDenom)
            {
                DISPDBG ((0,"ChipCheckBandwidth(): Invalid n(VW) denominator (0)."));
                goto Error;
            }

            // Divide (round up)
            nVW = (UINT)((dwNum + dwDenom - 1) / dwDenom);
            DISPDBG ((0," nVW = %u", nVW));

            // Only 3 bits for nVW, so scale it and save factor
            uMVWFactor = 1;
            while (nVW > 7)
            {
                nVW++;
                nVW >>= 1;
                uMVWFactor <<= 1;
                DISPDBG ((0," nVW = %u, uMVWFactor = %u", nVW, uMVWFactor));
            }

            // For a 0 n(VW), we assume the overhead is negligible.
            if (0 == nVW)
            {
                uVPortMVW = 0;
            }
            else
            {
                // V-Port = R + (n - 1) * P
                uVPortMVW = uMCLKsPerRandom + ((nVW - 1) * uMCLKsPerPage);
                uVPortMVW *= uMVWFactor;
            }
            DISPDBG((0," uVPortMVW = %u", uVPortMVW));
        }
    }
#endif  //00 -- fr new structure code

    /*
     * DSTN Frame Buffer = [R + P] + [1 + (2 * P)]           (a)
     *                or = [R + (2 * P)] + [1 + (3 * P)]     (b)
     */
    dwTemp = (DWORD)(uMCLKsPerRandom + uMCLKsPerPage + 1 + (2 * uMCLKsPerPage));
    uDSTNGfxA = (UINT)dwTemp;
    dwTemp *= dwDestWidth;
    dwTemp /= dwSrcWidth;
    uDSTNMVWA = (UINT)dwTemp;

    dwTemp = (DWORD)(uMCLKsPerRandom + (2 * uMCLKsPerPage) + 1 + (3 * uMCLKsPerPage));
    uDSTNGfxB = (UINT)dwTemp;
    dwTemp *= dwDestWidth;
    dwTemp /= dwSrcWidth;
    uDSTNMVWB = (UINT)dwTemp;

    DISPDBG((0,"uDSTNGfxA = %u, uDSTNMVWA = %u, uDSTNGfxB = %u,uDSTNMVWB = %u",
                uDSTNGfxA, uDSTNMVWA, uDSTNGfxB, uDSTNMVWB));

    /*
     * (Gfx + MVW + VP + DSTN) * MCLK Period <= VCLK period
     */

    // Calculate v(VW) and v(Graphics) for comparison below

    // Div 0 Protection done above
    vVW = (UINT)((64ul * (DWORD)uMVWThresh * dwDestWidth)
                 / (wVideoDepth * dwSrcWidth));
    DISPDBG((0," vVW = %u", vVW));

    // Div 0 Protection done above
    vGfx = (USHORT)((64 * uGfxThresh) / ppdev->cBitsPerPixel);
    DISPDBG((0," vGfx = %u", vGfx));

    // See if DSTN is enabled
    fDSTN = IsDSTN(ppdev);

    // Check main equation, starting with Gfx-based equation (we won't
    //  do MVW-based equation below unless we are non-color/chroma keyed
    //  and the MVW is enabled.

    {
        DWORD dwLeft, dwRight, dwScaledRandomMCLKPeriod;

        // Begin building left side of equation with DSTN contribution
        if (fDSTN)
        {
            if (16 == ppdev->cBitsPerPixel)
            {
                dwLeft = (DWORD)uDSTNGfxA;
                uDSTNGfxThresh = 4;
            }
            else
            {
                dwLeft = (DWORD)uDSTNGfxB;
                uDSTNGfxThresh = 6;
            }
            if (uMVWThresh == wVideoDepth)
                uDSTNMVWThresh = 6;
            else
                uDSTNMVWThresh = 4;
        }
        else
        {
            dwLeft = 0;
        }
        DISPDBG((0," dwLeft = %lu", dwLeft));

        // Are we being displayed and color or chroma keyed?
        if (fColorKey)
        {
            // Add graphics contribution (scaled)
            dwLeft += ((DWORD)uGfx * dwDestWidth) / dwSrcWidth;

            DISPDBG((0," dwLeft = %lu", dwLeft));

            // Add video window contribution
            dwLeft += (DWORD)uMVW;
        }
        else
        {
            // Add graphics contribution (1x)
            dwLeft += (DWORD)uGfx;
        }
        DISPDBG((0," dwLeft = %lu", dwLeft));

        if (fColorKey)
            dwRight = (DWORD)vVW;
        else
            dwRight = (DWORD)vGfx;
        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));

        // Only add video port if it's in use
#if 0   //00 - for new structure code
        if (dwFlags & OVERLAY_FLG_CAPTURE)
        {
            if (fColorKey)
                dwLeft += (DWORD)uVPortMVW;
            else
                dwLeft += (DWORD)uVPortGfx;
        }
#endif  //0 - for new structure code

        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));

        // To avoid the divisions in (left/MCLK) <= (right/VCLK), we'll
        // instead multiply left * VCLK and right * MCLK since the relationship
        // will be the same.
        {
           int iLeftShift, iRightShift, iRandomMCLKShift;

            iLeftShift = ScaleMultiply(dwLeft, dwVCLK, &dwLeft);
            DISPDBG((0," dwLeft = %lu, iLeftShift = %d", dwLeft, iLeftShift));

            iRightShift = ScaleMultiply(dwRight, dwMCLK, &dwRight);
            DISPDBG((0," dwRight = %lu, iRightShift = %d", dwRight, iRightShift));

            iRandomMCLKShift = ScaleMultiply((DWORD)uMCLKsPerRandom, dwVCLK,
                                         &dwScaledRandomMCLKPeriod);
            DISPDBG((0," dwScaledRandomMCLKPeriod = %lu,iRandomMCLKShift = %d",
                         dwScaledRandomMCLKPeriod, iRandomMCLKShift));

            // Even things up
            {
            int iShift = iLeftShift;

                if (iRightShift > iShift)
                    iShift = iRightShift;

                if (iRandomMCLKShift > iShift)
                    iShift = iRandomMCLKShift;

                if (iShift > iLeftShift)
                    dwLeft >>= (iShift - iLeftShift);

                if (iShift > iRightShift)
                    dwRight >>= (iShift - iRightShift);

                if (iShift > iRandomMCLKShift)
                    dwScaledRandomMCLKPeriod >>= (iShift - iRandomMCLKShift);
            }
        }
        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));
        DISPDBG((0," dwScaledRandomMCLKPeriod = %lu", dwScaledRandomMCLKPeriod));

        // See if there is enough bandwidth
        if (dwLeft > dwRight)
        {
            DISPDBG((0,"IsSufficientBandwidth(): Insufficient bandwidth (Gfx)."));
           goto Error;
        }

        if (dwLeft > (dwRight - dwScaledRandomMCLKPeriod))
        {
            // Set CPU stop bits
            DISPDBG((0,"IsSufficientBandwidth(): CPU stop bits set (Gfx)."));
            bSR34 = SR34_CPUSTOP_ENABLE | SR34_GFX_CPUSTOP | SR34_MVW_CPUSTOP;
            if (fDSTN)
                bSR34 |= SR34_DSTN_CPUSTOP;
            DISPDBG((0," bSR34 = 0x%x", bSR34));
        }
    }

    // Check main equation using MVW-based values if we are not
    //  color/chroma keyed and the MVW is enabled.
    if (!fColorKey)
    {
        DWORD dwLeft, dwRight, dwScaledRandomMCLKPeriod;

        // Begin building left side of equation with DSTN contribution
        if (fDSTN)
        {
            if (uMVWThresh == wVideoDepth)
                dwLeft = (DWORD)uDSTNMVWB;
            else
                dwLeft = (DWORD)uDSTNMVWA;
        }
        else
        {
            dwLeft = 0;
        }
        DISPDBG((0," dwLeft = %lu", dwLeft));

        // Add MVW contribution
        dwLeft += (DWORD)uMVW;
        DISPDBG((0," dwLeft = %lu", dwLeft));

        // Use v(MVW) for right
        dwRight = (DWORD)vVW;
        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));

        // To avoid the divisions in (left/MCLK) <= (right/VCLK), we'll
        // instead multiply left * VCLK and right * MCLK since the relationship
        // will be the same.
        {
            int iLeftShift, iRightShift, iRandomMCLKShift;

            iLeftShift = ScaleMultiply(dwLeft, dwVCLK, &dwLeft);
            DISPDBG((0," dwLeft = %lu, iLeftShift = %d", dwLeft, iLeftShift));

            iRightShift = ScaleMultiply(dwRight, dwMCLK, &dwRight);
            DISPDBG((0," dwRight = %lu, iRightShift = %d", dwRight, iRightShift));

            iRandomMCLKShift = ScaleMultiply((DWORD)uMCLKsPerRandom, dwVCLK,
                                         &dwScaledRandomMCLKPeriod);
            DISPDBG((0," dwScaledRandomMCLKPeriod = %lu, iRandomMCLKShift = %d",
                         dwScaledRandomMCLKPeriod, iRandomMCLKShift));

            // Even things up
            {
                int iShift = iLeftShift;

                if (iRightShift > iShift)
                    iShift = iRightShift;

                if (iRandomMCLKShift > iShift)
                    iShift = iRandomMCLKShift;

                if (iShift > iLeftShift)
                    dwLeft >>= (iShift - iLeftShift);

                if (iShift > iRightShift)
                    dwRight >>= (iShift - iRightShift);

                if (iShift > iRandomMCLKShift)
                    dwScaledRandomMCLKPeriod >>= (iShift - iRandomMCLKShift);
            }
        }

        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));
        DISPDBG((0," dwScaledRandomMCLKPeriod = %lu", dwScaledRandomMCLKPeriod));

        // See if there is enough bandwidth
        if (dwLeft > dwRight)
        {
            DISPDBG((0,"IsSufficientBandwidth(): Insufficient bandwidth (MVW)."));
            goto Error;
        }

        if (dwLeft > (dwRight - dwScaledRandomMCLKPeriod))
        {
            // Set CPU stop bits
            DISPDBG((0,"IsSufficientBandwidth(): CPU stop bits set (MVW)."));

            bSR34 = SR34_CPUSTOP_ENABLE | SR34_MVW_CPUSTOP;

            if (fDSTN)
                bSR34 |= SR34_DSTN_CPUSTOP;
            DISPDBG((0," bSR34 = 0x%x", bSR34));
        }
    }

    // Return register settings
    bSR2F |= (BYTE)uDSTNGfxThresh & SR2F_HFAFIFOGFX_THRESH;
    bSR32 |= (BYTE)uDSTNMVWThresh & SR32_HFAFIFOMVW_THRESH;

    switch (uMVWThresh)
    {
        case 8:
           bCR42 = 0x04;
           break;

        case 16:
           bCR42 = 0x00;
           break;

        default:
          DISPDBG((0,"IsSufficientBandwidth(): Illegal MVW Thresh (%u).", uMVWThresh));
          goto Error;
    }

    bCR51 |= ((BYTE)nVW << 5) & CR51_VPORTMVW_THRESH;
    DISPDBG((0," bCR51 = 0x%02X", (int)bCR51));

    bCR5A |= (BYTE)nGfx & CR5A_VPORTGFX_THRESH;
    DISPDBG((0," bCR5A = 0x%02X", (int)bCR5A));

     bCR5D=(BYTE)(((8 * (WORD)(bCR01 + 1)) + dwSrcWidth - dwDestWidth) / 8);
     DISPDBG((0," bCR5D = 0x%02X", (int)bCR5D));
     if (bCR5D)
         bCR5F |= 0x80;


     // Set global registers to be programmed in RegInitVideo()
//myf33   if (lpRegs)
     {
         Regs.bSR2F = bSR2F;
         Regs.bSR32 = bSR32;
         Regs.bSR34 = bSR34;

         Regs.bCR42 = bCR42;
         Regs.bCR51 = bCR51;
         Regs.bCR5A = bCR5A;
         Regs.bCR5D = bCR5D;
         Regs.bCR5F = bCR5F;
    }

    fSuccess = TRUE;
    DISPDBG((0,"IsSufficientBandwidth: OK!"));
Error:
    return(fSuccess);
}

/**********************************************************
*
* Get7555MCLK()
*
* Determines the current MCLK frequency.
*
* Return: The MCLK frequency in KHz (Since the frequency
*         could exceed 65535KHz, a DWORD is used).
*
***********************************************************
* Author: Rick Tillery
* Date:   09/27/95
*
* Revision History:
* -----------------
* WHO             WHEN     WHAT/WHY/HOW
* ---             ----     ------------
*
*********************************************************/
DWORD Get7555MCLK(PDEV * ppdev)
{
    DWORD dwMCLK;
    int   nMCLK;
    BYTE  bTemp;

    // Get MCLK register value
    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x1f);
    nMCLK = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) & 0x3F;


    // Calculate actual MCLK frequency
    dwMCLK = (14318l * (DWORD)nMCLK) >> 3;
    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x12);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) ;

    // Account for MCLK scaling
    if (bTemp & 0x10)
    {
        dwMCLK >>= 1;
    }

    return(dwMCLK);
}

/**********************************************************
*
* IsDSTN()
*
* Determines whether a DSTN panel is being used for display.
*
* Return: TRUE/FALSE
*
***********************************************************
* Author: Teresa Tao
* Date:   10/22/96
*
* Revision History:
* -----------------
* WHO             WHEN     WHAT/WHY/HOW
* ---             ----     ------------
*
*********************************************************/
BOOL IsDSTN(PDEV * ppdev)
{
    BOOL bTemp;

    /*
     * Is this an LCD?
     */
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    if (bTemp & 0x01)
    {
        /*
         * Determine type of LCD.
         */
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x83);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x70;
        bTemp >>= 4 ;
        if (bTemp == 0)
            return (TRUE);
    }
    return(FALSE);
}

/**********************************************************
*
* IsXGA()
*
* Determines whether a XGA panel is being used for display.
*
* Return: TRUE/FALSE
*
***********************************************************
* Author: Teresa Tao
* Date:   10/22/96
*
* Revision History:
* -----------------
* WHO             WHEN     WHAT/WHY/HOW
* ---             ----     ------------
*
*********************************************************/
BOOL IsXGA(PDEV * ppdev)
{
    BOOL bTemp;

    /*
     * Is this an LCD?
     */
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    if (bTemp & 0x01)
    {
        /*
         * Determine size of LCD.
         */
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x83);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x03;
        if (bTemp == 0x02)
            return (TRUE);
    }
    return (FALSE);
}


/**********************************************************
*
* ScaleMultiply()
*
* Calculates product of two DWORD factors supplied.  If the
*  result would overflow a DWORD, the larger of the two factors
*  is divided by 2 (shifted right) until the overflow will
*  not occur.
*
* Returns: Number of right shifts applied to the product.
*          Product of the factors shifted by the value above.
*
***********************************************************
* Author: Rick Tillery
* Date:   11/18/95
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
static int ScaleMultiply(DWORD   dw1,
                         DWORD   dw2,
                         LPDWORD pdwResult)
{
    int   iShift = 0;   // Start with no shifts
    DWORD dwLimit;

    // Either factor 0 will be a zero result and also cause a problem
    //  in our divide below.
    if ((0 == dw1) || (0 == dw2))
    {
        *pdwResult = 0;
    }
    else
    {
        // Determine which factor is larger
        if (dw1 > dw2)
        {
            // Determine largest number by with dw2 can be multiplied without
            // overflowing a DWORD.
            dwLimit = 0xFFFFFFFFul / dw2;

            // Shift dw1, keeping track of how many times, until it won't
            //  overflow when multiplied by dw2.
            while (dw1 > dwLimit)
            {
                dw1 >>= 1;
                iShift++;
            }
        }
        else
        {
            // Determine largest number by with dw1 can be multiplied without
            //  overflowing a DWORD.
            dwLimit = 0xFFFFFFFFul / dw1;

            // Shift dw2, keeping track of how many times, until it won't
            //  overflow when multiplied by dw1.
            while (dw2 > dwLimit)
            {
                dw2 >>= 1;
                iShift++;
            }
        }
        // Calculate (scaled) product
        *pdwResult = dw1 * dw2;
    }
    // Return the number of shifts we had to use
    return(iShift);
}


//myf31 :
#if 1
/**********************************************************
*
* PanOverlay7555
*
* If panning scrolling enable, and enable HW video, modified video window value
*
* Return: none
*
***********************************************************
* Author: Rita Ma
* Date:   02/24/97
*
* Revision History:
* -----------------
*********************************************************/
VOID PanOverlay7555 (PDEV * ppdev,LONG x,LONG y)
// RegInit7555Video (PDEV * ppdev,PDD_SURFACE_LOCAL lpSurface)
{
    DWORD dwTemp;
    DWORD dwFourcc;
    WORD  wBitCount;

    LONG lPitch;
    WORD wTemp;
    RECTL rDest;
    WORD wSrcWidth;
    WORD wSrcWidth_clip;
    WORD wDestWidth;
    WORD wSrcHeight;
    WORD wSrcHeight_clip;
    WORD wDestHeight;
    DWORD dwFBOffset;
    BYTE bRegCR31;
    BYTE bRegCR32;
    BYTE bRegCR33;
    BYTE bRegCR34;
    BYTE bRegCR35;
    BYTE bRegCR36;
    BYTE bRegCR37;
    BYTE bRegCR38;
    BYTE bRegCR39;
    BYTE bRegCR3A;
    BYTE bRegCR3B;
    BYTE bRegCR3C;
    BYTE bRegCR3D;
    BYTE bRegCR3E;
    BYTE bRegCR3F;
    BYTE bRegCR40;
    BYTE bRegCR41;
    BYTE bRegCR42;

    BYTE bRegCR51;
    BYTE bTemp;
    BYTE bVZoom;
    WORD fTemp=0;
    ULONG ulTemp=0;
    BOOL  bOverlayTooSmall = FALSE;
    static DWORD giAdjustSource;

//  USHORT VW_h_position, VW_v_position;
//  USHORT VW_h_width, VW_v_height;
//  ULONG  VW_s_addr;

    // PanOverlay1_Init return FALSE, exit here
    if (!PanOverlay1_7555(ppdev, &rDest))
        return;

	// rDest is now adjusted & clipped to the panning viewport
    // Disable overlay if totally clipped by viewport
    //
    if (((rDest.right - rDest.left) <= 15) ||
        ((rDest.bottom - rDest.top) <= 0) )
    {
        DisableVideoWindow(ppdev);                      // disable overlay
        return;
    }

    // Initial some value

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x42);
    bRegCR42 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC; //mask Chroma Key

    // keep bit6 video LUT enable
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x36);
    bRegCR36 = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x40) | 0x20;

    //
    // Get video format and color depth of overlay data
    //
    dwFourcc = ppdev->sOverlay1.dwFourcc;
    wBitCount= ppdev->sOverlay1.wBitCount;
    lPitch = ppdev->lPitch_gbls;                //??????????

    wSrcWidth = (WORD)(LONG)(ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left);
    wSrcHeight = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - ppdev->rOverlaySrc.top);

    wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
    wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - srcTop_clip);

    wDestWidth = (WORD)(LONG)(ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
    wDestHeight = (WORD)(LONG)(ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top);

    // Determine horizontal upscale coefficient (CR39[7:4],CR31[7:0])
    wTemp = ((WORD)(((DWORD)wSrcWidth  << 12) / (DWORD)wDestWidth)) & 0x0FFF;

    if (wTemp != 0 && bLeft_clip)
    {
        srcLeft_clip = srcLeft_clip * (LONG)wTemp/4096 +ppdev->rOverlaySrc.left;
        wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
        DISPDBG((0,"srcLeft_clip after zoom:%x",srcLeft_clip));
    }
    else if (bLeft_clip)
    {
        srcLeft_clip = srcLeft_clip + ppdev->rOverlaySrc.left;
        wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
        DISPDBG((0,"srcLeft_clip after zoom:%x",srcLeft_clip));
    }

    bRegCR39 = (BYTE)((wTemp & 0x0F) << 4);
    bRegCR31 = (BYTE)(wTemp >> 4) & 0xFF;

    // Determine vertical upscale coefficient (CR39[3:0],CR32[7:0])
    bVZoom=0;
    wTemp = ((WORD)(((DWORD)wSrcHeight << 12) / (DWORD)wDestHeight)) & 0x0FFF;
    if (wTemp != 0) {
        bVZoom=1;
        fTemp = wTemp;
        if ( fTemp < 2048 ) // Zoom > 2.0
             wTemp=((WORD)(((DWORD)wSrcHeight << 12) / (DWORD)(wDestHeight+1))) & 0x0FFF;
    }
    if (wTemp != 0 && bTop_clip)
    {
        srcTop_clip = srcTop_clip * (LONG)wTemp/4096 + ppdev->rOverlaySrc.top;
        wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - srcTop_clip);
        DISPDBG((0,"srcTop_clip after zoom:%x",srcTop_clip));
    }
    else if (bTop_clip)
    {
        srcTop_clip = srcTop_clip + ppdev->rOverlaySrc.top;
        wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - srcTop_clip);
        DISPDBG((0,"srcTop_clip after zoom:%x",srcTop_clip));
    }

    bRegCR39 |= (BYTE)(wTemp & 0x0F);
    bRegCR32 = (BYTE)(wTemp >> 4) & 0xFF;
    DISPDBG((0,"wTemp = 0x%x",wTemp));

    // Determine Vertical Height (CR38[7:0], CR36[3:2])
    wTemp = wSrcHeight_clip;
    if (wTemp != 0 &&
        ( fTemp > 2730 || fTemp ==0 || ( fTemp > 1365 && fTemp < 2048 ) ) )
        wTemp--; //#tt10, Height minus one only if upscale rate <1.5
              //#tt10  2 <    <3

    bRegCR38 = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0300) >> 6;

    // Determine Horizontal position start (CR34[7:0], CR33[7:5])
    wTemp    = (WORD)rDest.left;
    bRegCR34 = (BYTE)wTemp;
    bRegCR33 = (wTemp & 0x0700) >> 3;

    // Reset Brightness control (CR35[7:0])
    bRegCR35 = 0x0;

    // Determine Vertical Start (CR37[7:0], CR36[1:0])
    wTemp    = (WORD)rDest.top;
    bRegCR37 = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0300) >> 8;


    // Determine Video Start Address (CR40[0], CR3A[6:0], CR3E[7:0], CR3F[3:0])
//  giAdjustSource = (ppdev->rOverlaySrc.top * lpSurface->lpGbl->lPitch)
//                     + ((ppdev->rOverlaySrc.left * wBitCount) >> 3);
    dwTemp = srcTop_clip * lPitch;
    dwTemp = (srcLeft_clip * wBitCount) >> 3;
    giAdjustSource = (srcTop_clip * lPitch)
                       + ((srcLeft_clip * wBitCount) >> 3);

    ppdev->sOverlay1.lAdjustSource = giAdjustSource;    //myf32
    dwFBOffset = (DWORD)(ppdev->fpVidMem_gbls + giAdjustSource);

    DISPDBG((0,"giAdjustSource = 0x%08x",giAdjustSource));
    DISPDBG((0,"dwFBOffset = 0x%08x",dwFBOffset));

    dwFBOffset >>= 2;

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3A);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;

    bRegCR3A = (bTemp & ~0x7F) | (BYTE)((dwFBOffset & 0x0FE000) >> 13);
    bRegCR3E = (BYTE)((dwFBOffset & 0x001FE0) >> 5);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
    bRegCR3F = (bTemp & ~0x0F) | (BYTE)((dwFBOffset & 0x00001E) >> 1);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x40);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
    bRegCR40 = (bTemp & ~0x01) | (BYTE)(dwFBOffset & 0x000001);

    //Determine Video Pitch (CR3B[7:0], CR36[4])
    wTemp = (WORD)(lPitch >> 4);              //QWORDs

    bRegCR3B = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0100) >> 4;

    // Determine Data Format (CR3E[3:0])
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3C);
    bRegCR3C = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x10;

    switch (dwFourcc)
    {
       case FOURCC_PACKJR:
           bRegCR3C |= 0x02;                    // Pack JR
           break;

       case BI_RGB:
           switch(wBitCount)
           {
             case 8:
                bRegCR3C |= 0x09;               // 8 bit palettized
                break;

             case 16:
                bRegCR3C |= 0x01;               // RGB 5:5:5
                break;
           }
           break;

       case BI_BITFIELDS:
           switch(wBitCount)
           {
             case 8:
                bRegCR3C |= 0x09;               // 8 bit palettized
                break;

             case 16:
                bRegCR3C |= 0x04;               // RGB 5:6:5
                break;
           }
           break;

       case FOURCC_YUV422:
           bRegCR3C |= 0x03;                    // YUV 4:2:2
           break;

       case FOURCC_YUY2:                //myf34 test
           bRegCR3C |= 0x03;                    // YUY2
//         CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x2C);
//         bRegSR2C = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) ;
//         bRegSR2C |= 0x40;            //SR2c[6] = 1
//         CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x2C |(WORD)bRegSR2C << 8);
           break;
    }


    // Determine Horizontal width (CR3D[7:0], CR3C[7:5])
    // NOTE: assumes Horz Pixel Width [0] = 0

    wTemp = wSrcWidth_clip;

    if (wTemp != 0 ) wTemp--;                   //Width minus one for laptop
    bRegCR3D = (BYTE)((WORD)wTemp >> 1);
    bRegCR3C |= (wTemp & 0x0600) >> 3;
    bRegCR3C |= (BYTE)((wTemp & 0x0001) << 5) ;

    // Enable Horizontal Pixel Interpolation (CR3F[7])
    bRegCR3F |= 0x80;

    // Enable Vertical Pixel Interpolation (CR3F[6])
    //#tt Debug- The CE rev. has problem when vertical interpolation is on
    //#tt Debug- Disable it for now.
    //#tt   bRegCR3F |= 0x40;

    // Enable Right Side transition threshold (CR41[5:0])
    bRegCR41 = 0x3E;

    // Disable V-PORT (CR58[7:0])
    bRegCR51 = 0x0;

    // Disable CR5D if in panning & upscaling
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
//myf33 if (bVZoom && (BYTE)wPanFlag)
    if (bVZoom && (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x01))     //myf33
    {
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x5F);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & ~0x80;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (UCHAR)bTemp);
    }

#if 0   // bad ideal code
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3C);
    bRegCR3C = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x10;

    if (bRegCR3C)
    {
        // Horizontal position start (CR33[7:5], CR34[7:0])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x34);
        bRegCR34 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x33);
        bRegCR33 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        VW_h_position = ((USHORT)(bRegCR33 & 0xE0)) << 3;
        VW_h_position |= (USHORT)bRegCR34;

        // Vertical position start (CR36[1:0], CR37[7:0])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x37);
        bRegCR37 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x36);
        bRegCR36 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        VW_v_position = ((USHORT)(bRegCR36 & 0x03)) << 8;
        VW_v_position |= (USHORT)bRegCR37;

        //Video horizontal width (CR3C[7:6], CR3D[7:0], CR3C[5])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3D);
        bRegCR3D = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3C);
        bRegCR3C = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        VW_h_width = (WORD)(bRegCR3C & 0x01);
        VW_h_width |= (((USHORT)(bRegCR3C & 0xC0)) << 3);
        VW_h_width |= (((USHORT)bRegCR3D) << 1);

        //Video vertical height (CR36[3:2], CR38[7:0])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x38);
        bRegCR38 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
//      CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x36);
//      bRegCR36 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        VW_v_height = ((USHORT)(bRegCR36 & 0x0C)) << 6;
        VW_v_height |= ((USHORT)bRegCR38);

        //Video memory offset register (CR36[4], CR3B[7:0])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3B);
        bRegCR3B = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        lPitch = ((USHORT)(bRegCR36 & 0x10)) << 4;
        lPitch |= ((USHORT)bRegCR3B);
        lPitch <<= 4;

        //Video memory start address (CR3A[6:0], CR3E[7:0], CR3F[3:0], CR40[0])
        // update sequence CR40[0], CR3A[6:0], CR3E[7:0], CR3F[3:0]
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x40);
        bRegCR40 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3A);
        bRegCR3A = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3E);
        bRegCR3E = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F);
        bRegCR3F = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
#if 0
        VW_s_addr = (ULONG)(bRegCR40 & 0x01);
        VW_s_addr |= (((ULONG)(bRegCR3F & 0x0F)) << 1);
        VW_s_addr |= (((ULONG)bRegCR3E) << 5);
        VW_s_addr |= (((ULONG)(bRegCR3A & 0x7F)) << 13);
        VW_s_addr <<= 2;
#endif

        // Update Video window Horizontal & Vertical position
        DISPDBG((0,"PAN--Xmin=%x, Xmax=%x\n",ppdev->min_Xscrren,ppdev->max_Xscrren));
        DISPDBG((0,"PAN--Ymin=%x, Ymax=%x\n",ppdev->min_Yscrren,ppdev->max_Yscrren));
        DISPDBG((0,"PAN--h_position=%x, v_position=%x\n",VW_h_position,
                         VW_v_position));
        DISPDBG((0,"PAN--h_height=%x, v_width=%x\n",VW_h_height,VW_v_width));

        if (((ppdev->min_Xscreen <= VW_h_position) &&
             (ppdev->max_Xscreen >= VW_h_position)) &&
            ((ppdev->min_Yscreen <= VW_v_position) &&
             (ppdev->max_Yscreen >= VW_v_position)))
        {
            VW_h_position -= ppdev->min_Xscreen;
            VW_v_position -= ppdev->min_Yscreen;
        DISPDBG((0,"(1)--h_position=%x, v_position=%x\n",VW_h_position,
                         VW_v_position));
        DISPDBG((0,"(1)--h_height=%x, v_width=%x\n",VW_h_height,VW_v_width));
        }
        // Video window in the left or right
        else if ((ppdev->max_Xscreen < VW_h_position) ||
                 (ppdev->min_Xscreen > (VW_h_position+VW_h_width)))
        {
            DisableVideoWindow(ppdev);                      // disable overlay
            ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;  // totally clipped
        DISPDBG((0,"(2)--DisableVideoWindow\n"));
        }
        // Video window in the top or bottom
        else if ((ppdev->max_Yscreen < VW_v_position) ||
                 (ppdev->min_Yscreen > (VW_v_position+VW_v_height)))
        {
            DisableVideoWindow(ppdev);                      // disable overlay
            ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;  // totally clipped
        DISPDBG((0,"(3)--DisableVideoWindow\n"));
        }
        // Update Video window memory start address
        else if ((ppdev->min_Xscreen > VW_h_position) &&
                 (ppdev->min_Xscreen < (VW_h_position+VW_h_width)))
        {
            if ((ppdev->min_Xscreen-VW_h_position) > 0)
            {
                ppdev->rOverlaySrc.left = ppdev->min_Xscreen - VW_h_position;
                VW_h_position = ppdev->min_Xscreen;
                VW_h_width -= ppdev->rOverlaySrc.left;
            }
            if ((ppdev->min_Yscreen-VW_v_position) > 0)
            {
                ppdev->rOverlaySrc.top = ppdev->min_Yscreen - VW_v_position;
                VW_v_position = ppdev->min_Yscreen;
                VW_v_height -= ppdev->rOverlaySrc.top;
            }
        DISPDBG((0,"(4)--h_position=%x, v_position=%x\n",VW_h_position,
                         VW_v_position));
        DISPDBG((0,"(4)--h_height=%x, v_width=%x\n",VW_h_height,VW_v_width));
        DISPDBG((0,"(4)--Overlay.top=%x, left=%x\n",ppdev->rOverlaySrc.top,
                         ppdev->rOverlaySrc.left));
        }
        else if  ((ppdev->min_Yscreen > VW_v_position) &&
                  (ppdev->min_Yscreen < (VW_v_position+VW_v_height)))
        {
            if ((ppdev->min_Xscreen-VW_h_position) > 0)
            {
                ppdev->rOverlaySrc.left = ppdev->min_Xscreen - VW_h_position;
                VW_h_position = ppdev->min_Xscreen;
                VW_h_width -= ppdev->rOverlaySrc.left;
            }
            if ((ppdev->min_Yscreen-VW_v_position) > 0)
            {
                ppdev->rOverlaySrc.top = ppdev->min_Yscreen - VW_v_position;
                VW_v_position = ppdev->min_Yscreen;
                VW_v_height -= ppdev->rOverlaySrc.top;
            }
        DISPDBG((0,"(5)--h_position=%x, v_position=%x\n",VW_h_position,
                         VW_v_position));
        DISPDBG((0,"(5)--h_height=%x, v_width=%x\n",VW_h_height,VW_v_width));
        }
        giAdjustSource = (ppdev->rOverlaySrc.top * lPitch)
//                        ppdev->lpSrcColorSurface->lpGbl->lPitch)
                       + ((ppdev->rOverlaySrc.left
                          * ppdev->sOverlay1.wBitCount) >> 3);

//      DISPDBG((0,"lpSurface->fpVisibleOverlay= \n0x%08x\n",
//                             ppdev->fpVisibleOverlay));
//      DISPDBG((0,"lpSurface->fpBaseOverlay = 0x%08x\n",
//                             ppdev->fpBaseOverlay));
        DISPDBG((0,"PAN--fpVidMem=0x%8x\t",ppdev->fpVidMem));
        DISPDBG((0,"PAN--giAdjustSource = 0x%08x\n",giAdjustSource));
        dwFBOffset = (ppdev->fpVidMem_gbls - ) + giAdjustSource;

        DISPDBG((0,"PAN--dwFBOffset = 0x%08x\n",dwFBOffset));

        dwFBOffset >>= 2;

        //Update Horizontal position start (CR33[7:5], CR34[7:0])
        bRegCR34 = (BYTE)(VW_h_position & 0xFF);
        bRegCR33 &= 0x1F;
        bRegCR33 |= ((BYTE)((VW_h_position & 0x0700) >> 3));

        // Vertical position start (CR36[1:0], CR37[7:0])
        bRegCR37 = (BYTE)(VW_v_position & 0xFF);
        bRegCR36 &= 0xFC;
        bRegCR36 |= ((BYTE)((VW_v_position & 0x0300) >> 8));

        //Video horizontal width (CR3C[7:6], CR3D[7:0], CR3C[5])
        bRegCR3D = (BYTE)((VW_h_width & 0x1FE) >> 1);
        bRegCR3C &= 0x1F;
        bRegCR3C |= ((BYTE)(VW_h_width & 0x01)) << 5;
        bRegCR3C |= ((BYTE)((VW_h_width & 0x0600) >> 3));

        //Video vertical height (CR36[3:2], CR38[7:0])
        bRegCR38 = (BYTE)(VW_v_height & 0xFF);
        bRegCR36 &= 0xF3;
        bRegCR36 |= ((BYTE)((VW_v_height & 0x0300) >> 6));

        //Video memory start address (CR3A[6:0], CR3E[7:0], CR3F[3:0], CR40[0])
        // update sequence CR40[0], CR3A[6:0], CR3E[7:0], CR3F[3:0]
        bRegCR40 &= 0xFE;
        bRegCR40 |= (BYTE)(dwFBOffset & 0x01);
        bRegCR3F &= 0xF0;
        bRegCR3F |= ((BYTE)(dwFBOffset & 0x1E)) >> 1;
        bRegCR3E = (BYTE)((dwFBOffset & 0x1FE0) >> 5);
        bRegCR3A &= 0x80;
        bRegCR3A |= ((BYTE)((dwFBOffset & 0xFE000) >> 13));
#endif  /0 - bad ideal
//
        /*
         * Program the video window registers
        */
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x31 | (WORD)bRegCR31 << 8);//CR31
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x32 | (WORD)bRegCR32 << 8);//CR32
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x33 | (WORD)bRegCR33 << 8);//CR33
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x34 | (WORD)bRegCR34 << 8);//CR34

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x35 | (WORD)bRegCR35 << 8);//CR35
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x36 | (WORD)bRegCR36 << 8);//CR36
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x37 | (WORD)bRegCR37 << 8);//CR37
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x38 | (WORD)bRegCR38 << 8);//CR38
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x39 | (WORD)bRegCR39 << 8);//CR39
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3B | (WORD)bRegCR3B << 8);//CR3B
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3C | (WORD)bRegCR3C << 8);//CR3C
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3D | (WORD)bRegCR3D << 8);//CR3D
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x41 | (WORD)bRegCR41 << 8);//CR41
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x42 | (WORD)bRegCR42 << 8);//CR42
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x51 | (WORD)bRegCR51 << 8);//CR51

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x40 | (WORD)bRegCR40 << 8);//CR40
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3A | (WORD)bRegCR3A << 8);//CR3A
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3E | (WORD)bRegCR3E << 8);//CR3E
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3F | (WORD)bRegCR3F << 8);//CR3F

        // enable overlay if overlay was totally clipped by pnning viewport
        //
        if (ppdev->dwPanningFlag & OVERLAY_OLAY_REENABLE)
            EnableVideoWindow (ppdev);
}
#endif
//myf31 end

#endif   // DirectDraw
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Contains all the banking code for the display driver.
*
* It's helpful not to have to implement all the DDI drawing functionality
* in a driver (who wants to write the code to support true ROP4's with
* arbitrary sized patterns?).  Fortunately, we can punt to GDI for any
* drawing we don't want to do.  And if GDI can write directly on the frame
* buffer bits, performance won't even be toooo bad.
*
* NT's GDI can draw on any standard format frame buffer.  When the entire
* frame buffer can be mapped into main memory, it's very simple to set up:
* the display driver tells GDI the frame buffer format and location, and
* GDI can then just draw directly.
*
* When only one bank of the frame buffer can be mapped into main memory
* at one time (e.g., there is a moveable 64k aperture) things are not
* nearly so easy.  For every bank spanned by a drawing operation, we have
* to set the hardware to the bank, and call back to GDI.  We tell GDI
* to draw only on the mapped-in bank by mucking with the drawing call's
* CLIPOBJ.
*
* This module contains the code for doing all banking support.
*
* This code supports 8, 16 and 32bpp colour depths, arbitrary bank
* sizes, and handles 'broken rasters' (which happens when the bank size
* is not a multiple of the scan length; some scans will end up being
* split over two separate banks).
*
* Note:  If you mess with this code and break it, you can expect to get
*        random access violations on call-backs in internal GDI routines
*        that are very hard to debug.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

typedef struct _BANKDATA {
    ULONG nothing_yet;
} BANKDATA;                      /* bd, pbd */

////////////////////////////////////////////////////////////////////////////
// Banking code
//

VOID vBankSelectMode(
PPDEV       ppdev,
BANK_MODE   bankm)
{
    // BANK_ENABLE   - We've exited full-screen; re-enable banking
    // BANK_ON       - We're about to use the memory aperture
    // BANK_OFF      - We've finished using the memory aperture
    // BANK_DISABLE  - We're about to enter full-screen; shut down banking

    switch(bankm){

        case BANK_ENABLE:   DISPDBG((115,"vBankSelectMode(BANK_ENABLE)"));
                            break;

        case BANK_ON:       DISPDBG((115,"vBankSelectMode(BANK_ON)"));
                            //
                            // [BUGFIX] -   I don't know why, but the CL542x
                            //              needs the color register set to
                            //              0 when drawing to the framebuffer
                            //
                            if (ppdev->flCaps & CAPS_MM_IO)
                            {
                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjBase);
                                CP_MM_FG_COLOR(ppdev, ppdev->pjBase, 0);
                            }
                            else
                            {
                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjPorts);
                                CP_IO_FG_COLOR(ppdev, ppdev->pjPorts, 0);
                            }
                            CP_EIEIO();
                            break;

        case BANK_OFF:      DISPDBG((115,"vBankSelectMode(BANK_OFF)"));
                            break;

        case BANK_DISABLE:  DISPDBG((115,"vBankSelectMode(BANK_DISABLE)"));
                            break;

        default:            DISPDBG((115,"vBankSelectMode(UNKNOWN=%d)", bankm));
                            RIP("Bad BANK_MODE selected");
                            break;
    }
}

VOID vBankMap(
PPDEV       ppdev,
LONG        iBank)
{
    WORD w;

    //
    // map the segement to iBank
    //

    DISPDBG((10,"vBankMap(iBank=%d)", iBank));

    w = (WORD) (0x9 | (iBank << ppdev->ulBankShiftFactor));
    CP_OUT_WORD(ppdev->pjPorts,INDEX_REG,w);
    CP_EIEIO();
}

VOID vBankInitialize(
PPDEV       ppdev,
BOOL        bMmIo)
{
}

/******************************Public*Routine******************************\
* BOOL bEnableBanking
*
\**************************************************************************/

BOOL bEnableBanking(
PDEV*   ppdev)
{
    CLIPOBJ*            pcoBank;
    SURFOBJ*            psoBank;
    SIZEL               sizl;
    HSURF               hsurf;
    static FNBANKINITIALIZE*   pfnBankInitialize;
    LONG                lDelta;
    LONG                cjBank;
    LONG                cPower2;

    // This routine may be called multiple times (e.g., each time
    // full-screen is exited), so make sure we do any allocations
    // only once:

    if (ppdev->pcoBank == NULL)
    {
        // Create a temporary clip object that we'll use for the bank
        // when we're given a Null or DC_TRIVIAL clip object:

        pcoBank = EngCreateClip();
        if (pcoBank == NULL)
            goto ReturnFalse;

        // We break every per-bank GDI call-back into simple rectangles:

        pcoBank->iDComplexity = DC_RECT;
        pcoBank->fjOptions    = OC_BANK_CLIP;

        // Create a GDI surface that we'll wrap around our bank in
        // call-backs:

        sizl.cx = ppdev->cxMemory;
        sizl.cy = ppdev->cyMemory;

        hsurf = (HSURF) EngCreateBitmap(sizl,
                                        ppdev->lDelta,
                                        ppdev->iBitmapFormat,
                                        BMF_TOPDOWN,
                                        ppdev->pjScreen);

        // Note that we hook zero calls -- after all, the entire point
        // of all this is to have GDI do all the drawing on the bank.
        // Once we're done the association, we can leave the surface
        // permanently locked:

        if ((hsurf == 0)                                        ||
            (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0))    ||
            (!(psoBank = EngLockSurface(hsurf))))
        {
            DISPDBG((0, "Failed wrapper surface creation"));

            EngDeleteSurface(hsurf);
            EngDeleteClip(pcoBank);

            goto ReturnFalse;
        }

        ppdev->pcoBank    = pcoBank;
        ppdev->psoBank    = psoBank;
        ppdev->pvBankData = &ppdev->aulBankData[0];

        DISPDBG((2, "pcoBank = %x", pcoBank));
        DISPDBG((2, "psoBank = %x", psoBank));

        ppdev->pfnBankMap        = vBankMap;
        ppdev->pfnBankSelectMode = vBankSelectMode;
        pfnBankInitialize        = vBankInitialize;

        lDelta = ppdev->lDelta;
        cjBank = ppdev->cjBank;

        ASSERTDD(lDelta > 0, "Bad things happen with negative lDeltas");
        ASSERTDD(cjBank > lDelta, "Worse things happen with bad bank sizes");

        if (((lDelta & (lDelta - 1)) != 0) || ((cjBank & (cjBank - 1)) != 0))
        {
            // When either the screen stride or the bank size is not a power
            // of two, we have to use the slower 'bBankComputeNonPower2'
            // function for bank calculations, 'cause there can be broken
            // rasters and stuff:

            ppdev->pfnBankCompute = bBankComputeNonPower2;
        }
        else
        {
            // We can use the super duper fast bank calculator.  Yippie,
            // yahoo!  (I am easily amused.)

            cPower2 = 0;
            while (cjBank != lDelta)
            {
                cjBank >>= 1;
                cPower2++;
            }

            // We've just calculated that cjBank / lDelta = 2 ^ cPower2:

            ppdev->cPower2ScansPerBank = cPower2;

            while (cjBank != 1)
            {
                cjBank >>= 1;
                cPower2++;
            }

            // Continuing on, we've calculated that cjBank = 2 ^ cPower2:

            ppdev->cPower2BankSizeInBytes = cPower2;

            ppdev->pfnBankCompute = bBankComputePower2;
        }

    }

	// Warm up the hardware:

	pfnBankInitialize(ppdev, FALSE);

	ppdev->pfnBankSelectMode(ppdev, BANK_ENABLE);

    DISPDBG((5, "Passed bEnableBanking"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableBanking!"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableBanking
*
\**************************************************************************/

VOID vDisableBanking(PDEV* ppdev)
{
    HSURF hsurf;

    if (ppdev->psoBank != NULL)
    {
        hsurf = ppdev->psoBank->hsurf;
        EngUnlockSurface(ppdev->psoBank);
        EngDeleteSurface(hsurf);
    }

    if (ppdev->pcoBank != NULL)
        EngDeleteClip(ppdev->pcoBank);
}

/******************************Public*Routine******************************\
* VOID vAssertModeBanking
*
\**************************************************************************/

VOID vAssertModeBanking(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Inform the miniport bank code about the change in state:

    ppdev->pfnBankSelectMode(ppdev,
                             bEnable ? BANK_ENABLE : BANK_DISABLE);
}

/******************************Public*Routine******************************\
* BOOL bBankComputeNonPower2
*
* Given the bounds of the drawing operation described by 'prclDraw',
* computes the bank number and rectangle bounds for the first engine
* call back.
*
* Returns the bank number, 'prclBank' is the bounds for the first
* call-back, and 'pcjOffset' is the adjustment for 'pvScan0'.
*
* This routine does a couple of divides for the bank calculation.  We
* don't use a look-up table for banks because it's not straight forward
* to use with broken rasters, and with large amounts of video memory
* and small banks, the tables could get large.  We'd probably use it
* infrequently enough that the memory manager would be swapping it
* in and out whenever we touched it.
*
* Returns TRUE if prclDraw is entirely contained in one bank; FALSE if
* prclDraw spans multiple banks.
*
\**************************************************************************/

BOOL bBankComputeNonPower2( // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG cjBufferOffset;
    LONG iBank;
    LONG cjBank;
    LONG cjBankOffset;
    LONG cjBankRemainder;
    LONG cjScan;
    LONG cScansInBank;
    LONG cjScanRemainder;
    LONG lDelta;
    BOOL bOneBank;

    bOneBank = FALSE;
    lDelta   = ppdev->lDelta;

    cjBufferOffset  = prclDraw->top * lDelta
                    + PELS_TO_BYTES(prclDraw->left);

    cjBank          = ppdev->cjBank;

    // iBank        = cjBufferOffset / cjBank;
    // cjBankOffset = cjBufferOffset % cjBank;

    QUOTIENT_REMAINDER(cjBufferOffset, cjBank, iBank, cjBankOffset);

    *piBank         = iBank;
    *pcjOffset      = iBank * cjBank;
    cjBankRemainder = cjBank - cjBankOffset;
    cjScan          = PELS_TO_BYTES(prclDraw->right - prclDraw->left);

    if (cjBankRemainder < cjScan)
    {
        // Oh no, we've got a broken raster!

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->left +
                           BYTES_TO_PELS(cjBankRemainder);
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + 1;
    }
    else
    {
        // cScansInBank    = cjBankRemainder / lDelta;
        // cjScanRemainder = cjBankRemainder % lDelta;

        ASSERTDD(lDelta > 0, "We assume positive lDelta here");

        QUOTIENT_REMAINDER(cjBankRemainder, lDelta,
                           cScansInBank, cjScanRemainder);

        if (cjScanRemainder >= cjScan)
        {
            // The bottom scan of the bank may be broken, but it breaks after
            // any drawing we'll be doing on that scan.  So we can simply
            // add the scan to this bank:

            cScansInBank++;
        }

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->right;
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + cScansInBank;

        if (prclBank->bottom >= prclDraw->bottom)
        {
            prclBank->bottom  = prclDraw->bottom;
            bOneBank          = TRUE;
        }
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* BOOL bBankComputePower2
*
* Functions the same as 'bBankComputeNonPower2', except that it is
* an accelerated special case for when both the screen stride and bank
* size are powers of 2.
*
\**************************************************************************/

BOOL bBankComputePower2(    // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG iBank;
    LONG yTopNextBank;
    BOOL bOneBank;

    iBank        = prclDraw->top >> ppdev->cPower2ScansPerBank;
    yTopNextBank = (iBank + 1) << ppdev->cPower2ScansPerBank;
    *piBank      = iBank;
    *pcjOffset   = iBank << ppdev->cPower2BankSizeInBytes;

    prclBank->left   = prclDraw->left;
    prclBank->right  = prclDraw->right;
    prclBank->top    = prclDraw->top;
    prclBank->bottom = yTopNextBank;

    bOneBank = FALSE;
    if (prclBank->bottom >= prclDraw->bottom)
    {
        prclBank->bottom  = prclDraw->bottom;
        bOneBank          = TRUE;
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* VOID vBankStart
*
* Given the bounds of the drawing operation described by 'prclDraw' and
* the original clip object, maps in the first bank and returns in
* 'pbnk->pco' and 'pbnk->pso' the CLIPOBJ and SURFOBJ to be passed to the
* engine for the first banked call-back.
*
* Note: This routine only supports the screen being the destination, and
*       not the source.  We have a separate, faster routine for doing
*       SRCCOPY reads from the screen, so it isn't worth the extra code
*       size to implement.
*
\**************************************************************************/

VOID vBankStart(
PDEV*       ppdev,      // Physical device information.
RECTL*      prclDraw,   // Rectangle bounding the draw area, in relative
                        //  coordinates.  Note that 'left' and 'right'
                        //  should be set for correct handling with broken
                        //  rasters.
CLIPOBJ*    pco,        // Original drawing clip object (may be modified).
BANK*       pbnk)       // Resulting bank information.
{
    LONG cjOffset;
    LONG xOffset;
    LONG yOffset;
    LONG xyOffset;

    DISPDBG((3, "vBankStart"));

    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    xyOffset = ppdev->xyOffset;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        pco = ppdev->pcoBank;

        // Reset the clipping flag to trivial because we may have left
        // it as rectangular in a previous call:

        pco->iDComplexity = DC_TRIVIAL;

        // At the same time we convert to absolute coordinates, make sure
        // we won't try to enumerate past the bounds of the screen:

        pbnk->rclDraw.left       = prclDraw->left   + xOffset;
        pbnk->rclDraw.right      = prclDraw->right  + xOffset;

        pbnk->rclDraw.top
            = max(0,               prclDraw->top    + yOffset);
        pbnk->rclDraw.bottom
            = min(ppdev->cyMemory, prclDraw->bottom + yOffset);
    }
    else
    {
        pbnk->rclSaveBounds    = pco->rclBounds;
        pbnk->iSaveDComplexity = pco->iDComplexity;
        pbnk->fjSaveOptions    = pco->fjOptions;

        // Let GDI know that it has to pay attention to the clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        // We have to honour the original clip object's rclBounds, so
        // intersect the drawing region with it, then convert to absolute
        // coordinates:

        pbnk->rclDraw.left
            = max(prclDraw->left,   pco->rclBounds.left)   + xOffset;
        pbnk->rclDraw.right
            = min(prclDraw->right,  pco->rclBounds.right)  + xOffset;
        pbnk->rclDraw.top
            = max(prclDraw->top,    pco->rclBounds.top)    + yOffset;
        pbnk->rclDraw.bottom
            = min(prclDraw->bottom, pco->rclBounds.bottom) + yOffset;
    }

    if ((pbnk->rclDraw.left > pbnk->rclDraw.right)
     || (pbnk->rclDraw.top  > pbnk->rclDraw.bottom))
    {
        // It's conceivable that we could get a situation where we have
        // an empty draw rectangle.  Make sure we won't puke on our shoes:

        pbnk->rclDraw.left   = 0;
        pbnk->rclDraw.right  = 0;
        pbnk->rclDraw.top    = 0;
        pbnk->rclDraw.bottom = 0;
    }

    if (!ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                               &cjOffset, &pbnk->iBank))
    {
        // The drawing operation spans multiple banks.  If the original
        // clip object was marked as trivial, we have to make sure to
        // change it to rectangular so that GDI knows to pay attention
        // to the bounds of the bank:

        if (pco->iDComplexity == DC_TRIVIAL)
            pco->iDComplexity = DC_RECT;
    }

    pbnk->ppdev = ppdev;
    pbnk->pco   = pco;
    pbnk->pso   = ppdev->psoBank;

    // Convert rclBounds and pvScan0 from absolute coordinates back to
    // relative.  When GDI calculates where to start drawing, it computes
    // pjDst = pso->pvScan0 + y * pso->lDelta + PELS_TO_BYTES(x), where 'x'
    // and 'y' are relative coordinates.  We'll muck with pvScan0 to get
    // it pointing to the correct spot in the bank:

    pbnk->pso->pvScan0 = (ppdev->pjScreen - cjOffset) + xyOffset;

    pbnk->pso->lDelta = ppdev->lDelta;  // Other functions muck with this value

    ASSERTDD((((ULONG_PTR) pbnk->pso->pvScan0) & 3) == 0,
             "Off-screen bitmaps must be dword aligned");

    pco->rclBounds.left   -= xOffset;
    pco->rclBounds.right  -= xOffset;
    pco->rclBounds.top    -= yOffset;
    pco->rclBounds.bottom -= yOffset;

    // Enable banking and map in bank iBank:

    ppdev->pfnBankSelectMode(ppdev, BANK_ON);
    ppdev->pfnBankMap(ppdev, pbnk->iBank);
}

/******************************Public*Routine******************************\
* BOOL bBankEnum
*
* If there is another bank to be drawn on, maps in the bank and returns
* TRUE and the CLIPOBJ and SURFOBJ to be passed in the banked call-back.
*
* If there were no more banks to be drawn, returns FALSE.
*
\**************************************************************************/

BOOL bBankEnum(
BANK* pbnk)
{
    LONG     iBank;
    LONG     cjOffset;
    PDEV*    ppdev;
    CLIPOBJ* pco;
    LONG     xOffset;
    LONG     yOffset;

    DISPDBG((3, "vBankEnum"));

    ppdev   = pbnk->ppdev;
    pco     = pbnk->pco;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    // We check here to see if we have to handle the second part of
    // a broken raster.  Recall that pbnk->rclDraw is in absolute
    // coordinates, but pco->rclBounds is in relative coordinates:

    if (pbnk->rclDraw.right - xOffset != pco->rclBounds.right)
    {
        // The clip object's 'top' and 'bottom' are already correct:

        pco->rclBounds.left  = pco->rclBounds.right;
        pco->rclBounds.right = pbnk->rclDraw.right - xOffset;

        pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;
        pbnk->iBank++;

        ppdev->pfnBankMap(ppdev, pbnk->iBank);

        return(TRUE);
    }

    if (pbnk->rclDraw.bottom > pco->rclBounds.bottom + yOffset)
    {
        // Advance the drawing area 'top' to account for the bank we've
        // just finished, and map in the new bank:

        pbnk->rclDraw.top = pco->rclBounds.bottom + yOffset;

        ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                              &cjOffset, &iBank);

        // Convert rclBounds back from absolute to relative coordinates:

        pco->rclBounds.left   -= xOffset;
        pco->rclBounds.right  -= xOffset;
        pco->rclBounds.top    -= yOffset;
        pco->rclBounds.bottom -= yOffset;

        // If we just finished handling a broken raster, we've already
        // got the bank mapped in:

        if (iBank != pbnk->iBank)
        {
            pbnk->iBank = iBank;
            pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;
            ppdev->pfnBankMap(ppdev, iBank);
        }

        return(TRUE);
    }

    // We're done!  Turn off banking and reset the clip object if necessary:

    ppdev->pfnBankSelectMode(ppdev, BANK_OFF);

    if (pco != ppdev->pcoBank)
    {
        pco->rclBounds    = pbnk->rclSaveBounds;
        pco->iDComplexity = pbnk->iSaveDComplexity;
        pco->fjOptions    = pbnk->fjSaveOptions;
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vAlignedCopy
*
* Copies the given portion of a bitmap, using dword alignment for the
* screen.  Note that this routine has no notion of banking.
*
* Updates ppjDst and ppjSrc to point to the beginning of the next scan.
*
\**************************************************************************/

VOID vAlignedCopy(
PDEV*   ppdev,
BYTE**  ppjDst,
LONG    lDstDelta,
BYTE**  ppjSrc,
LONG    lSrcDelta,
LONG    cjScan,
LONG    cyScan,
BOOL    bDstIsScreen)
{
    BYTE* pjDst;
    BYTE* pjSrc;
    LONG  cjMiddle;
    LONG  culMiddle;
    LONG  cjStartPhase;
    LONG  cjEndPhase;

    pjSrc = *ppjSrc;
    pjDst = *ppjDst;

    cjStartPhase = (ULONG)((0 - ((bDstIsScreen) ? (ULONG_PTR)pjDst
                                                : (ULONG_PTR)pjSrc)) & 3);
    cjMiddle     = cjScan - cjStartPhase;

    if (cjMiddle < 0)
    {
        cjStartPhase = 0;
        cjMiddle     = cjScan;
    }

    lSrcDelta -= cjScan;
    lDstDelta -= cjScan;            // Account for middle

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    if (DIRECT_ACCESS(ppdev))
    {
        LONG i;

        ///////////////////////////////////////////////////////////////////
        // Portable bus-aligned copy
        //
        // 'memcpy' usually aligns to the destination, so we could call
        // it for that case, but unfortunately we can't be sure.  We
        // always want to align to the frame buffer:

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    *((ULONG*) pjDst) = *((ULONG UNALIGNED *) pjSrc);
                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    *((ULONG UNALIGNED *) pjDst) = *((ULONG*) (pjSrc));

                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }

#if !defined(_X86_)

    else
    {
        LONG i;

        ///////////////////////////////////////////////////////////////////
        // No direct dword reads bus-aligned copy
        //
        // We go through this code path if doing dword reads would
        // crash a non-x86 system.

        MEMORY_BARRIER();

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    *((ULONG UNALIGNED *) pjDst) = READ_REGISTER_ULONG(pjSrc);

                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }

#endif

}

/******************************Public*Routine******************************\
* VOID vPutBits
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBits(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,            // Absolute coordinates!
POINTL*     pptlSrc)            // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    BYTE* pjPorts = ppdev->pjPorts;

    // We need a local copy of 'rclDraw' because we'll be iteratively
    // modifying 'top' and passing the modified rectangle back into
    // bBankComputeNonPower2:

    DISPDBG((5, "vPutBits -- enter"));

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank:

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, BANK_ON);
    ppdev->pfnBankMap(ppdev, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + PELS_TO_BYTES(rclDraw.left)
                                - cjOffset;

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + pptlSrc->y * lSrcDelta
                                        + PELS_TO_BYTES(pptlSrc->x);

    while (TRUE)
    {
        cjScan = PELS_TO_BYTES(rclBank.right  - rclBank.left);
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     TRUE);             // Screen is the destination

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;
            ppdev->pfnBankMap(ppdev, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = PELS_TO_BYTES(rclDraw.right - rclBank.right);

            // Account for the fact that we're now one bank lower in the
            // destination:

            pjDst -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan:

            if (DIRECT_ACCESS(ppdev))
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(ppdev, &pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             TRUE);    // Screen is the destination
            }
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjDst -= ppdev->cjBank;
                iBank = iNewBank;
                ppdev->pfnBankMap(ppdev, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ppdev->pfnBankSelectMode(ppdev, BANK_OFF);
            DISPDBG((5, "vPutBits -- exit"));
            return;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vPutBitsLinear
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBitsLinear(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;

    BYTE* pjPorts = ppdev->pjPorts;

    DISPDBG((5, "vPutBitsLinear -- enter"));

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "vPutBitsLinear: rectangle wasn't fully clipped");

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + PELS_TO_BYTES(rclDraw.left);

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + (pptlSrc->y  * lSrcDelta)
                                        + PELS_TO_BYTES(pptlSrc->x);

    cjScan = PELS_TO_BYTES(rclDraw.right  - rclDraw.left);
    cyScan = (rclDraw.bottom - rclDraw.top);

    ppdev->pfnBankSelectMode(ppdev, BANK_ON);

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                 TRUE);            // Screen is the dest
    DISPDBG((5, "vPutBitsLinear -- exit"));
}

/******************************Public*Routine******************************\
* VOID vGetBits
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBits(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    BYTE* pjPorts = ppdev->pjPorts;

    DISPDBG((5, "vGetBits -- enter"));

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank.

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, BANK_ON);
    ppdev->pfnBankMap(ppdev, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + PELS_TO_BYTES(rclDraw.left)
                                - cjOffset;

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + PELS_TO_BYTES(prclDst->left);

    while (TRUE)
    {
        cjScan = PELS_TO_BYTES(rclBank.right  - rclBank.left);
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     FALSE);            // Screen is the source

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;
            ppdev->pfnBankMap(ppdev, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = PELS_TO_BYTES(rclDraw.right - rclBank.right);

            // Account for the fact that we're now one bank lower in the
            // source:

            pjSrc -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan.  Note that we don't have to
            // advance the pointers because they're already pointing to the
            // beginning of the next scan:

            if (DIRECT_ACCESS(ppdev))
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(ppdev, &pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             FALSE);    // Screen is the source
            }
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjSrc -= ppdev->cjBank;
                iBank = iNewBank;
                ppdev->pfnBankMap(ppdev, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ppdev->pfnBankSelectMode(ppdev, BANK_OFF);
            DISPDBG((5, "vGetBits -- exit"));
            return;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vGetBitsLinear
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBitsLinear(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;

    BYTE* pjPorts = ppdev->pjPorts;

    DISPDBG((5, "vGetBitsLinear -- enter"));

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "vGetBitsLinear: rectangle wasn't fully clipped");

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + PELS_TO_BYTES(rclDraw.left);

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + PELS_TO_BYTES(prclDst->left);

    cjScan = PELS_TO_BYTES(rclDraw.right  - rclDraw.left);
    cyScan = (rclDraw.bottom - rclDraw.top);

    ppdev->pfnBankSelectMode(ppdev, BANK_ON);

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                 FALSE);            // Screen is the source
    DISPDBG((5, "vGetBitsLinear -- exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\7555bw.h ===
/**********************************************************
* Copyright Cirrus Logic, Inc. 1996. All rights reserved.
***********************************************************
*
* 7555BW.H
*
* Contains preprocessor definitions needed for CL-GD7555
*  bandwidth equations.
*
***********************************************************
*
*  WHO WHEN     WHAT/WHY/HOW
*  --- ----     ------------
*  RT  11/07/96 Created.
*  TT  02-24-97 Modified from 5446misc.h for 7555.
*
***********************************************************/

//#ifndef _7555BW_H
//#define _7555BW_H
//
//#include <Windows.h>
//#include <Windowsx.h>
//
//#include "VPM_Cir.h"
//#include "Debug.h"
//#include "BW.h"

/* type definitions & structures -------------------------*/

typedef struct _BWEQ_STATE_INFO
{
    RECTL rVPort;            /* Rect. at video port, if capture enabled */
    RECTL rCrop;             /* Rect. after cropping, if capture enabled */
    RECTL rPrescale;         /* Rect. after scaling, if capture enabled */
    RECTL rSrc;              /* Rect. in memory for display */
    RECTL rDest;             /* Rect. on the screen for display */
    DWORD dwSrcDepth;       /* Bits per pixel of data, in memory */
    DWORD dwPixelsPerSecond;/* Rate of data into video port, if capture enabled */
    DWORD dwFlags;          /* See FLG_ in OVERLAY.H */
} BWEQ_STATE_INFO, *PBWEQ_STATE_INFO;

/* preprocessor definitions ------------------------------*/
#define WIDTH(a)  ((a).right - (a).left)
#define HEIGHT(a) ((a).bottom - (a).top)

#define REF_XTAL  (14318182ul)      // Crystal reference frequency (Hz)

/*
 * VGA MISC Register
 */
#define MISC_WRITE            0x03C2  // Miscellaneous Output Register (Write)
#define MISC_READ             0x03CC  // Miscellaneous Output Register (Read)
#define MISC_VCLK_SELECT      0x0C    // Choose one of the four VCLKs
#define MISC_MEMORY_ACCESS    0x02    // Enable memory access

/*
 * VGA CRTC Registers
 */

#define CR01                  0x01    // Horizontal Display End Register
#define CR01_HORZ_END         0xFF    // Horizontal Display End

#define CR42                  0x42    // VW FIFO Threshold and Chroma Key
                                      //  Mode Select Register
#define CR42_MVWTHRESH        0x0C    // VW FIFO Threshold

#define CR51                  0x51    // V-Port Data Format Register
#define CR51_VPORTMVW_THRESH  0xE0    // V-Port FIFO Threshold in VW

#define CR5A                  0x5A    // V-Port Cycle and V-Port FIFO Control
#define CR5A_VPORTGFX_THRESH  0x07    // V-Port FIFO Threshold in Surrounding
                                      //  graphics

#define CR5D                  0x5D    // Number of Memory Cycles per Scanline
                                      //  Override Register
#define CR5D_MEMCYCLESPERSCAN 0xFF    // Number of Memory Cycles per Scanline
                                      //  Override

#define CR80                  0x80    // Power Management Control Register
#define CR80_LCD_ENABLE       0x01    // Flat Panel Enable

#define CR83                  0x83    // Flat Panel Type Register
#define CR83_LCD_TYPE         0x70    // Flat Panel Type Select

/*
 * VGA GRC Registers
 */
#define GRC_INDEX             0x03CE  // Graphics controller index register
#define GRC_DATA              0x03CF  // Graphics controller data register

#define GR18                  0x18    // EDO RAM Control Register
#define GR18_LONG_RAS         0x04    // EDO DRAM Long RAS# Cycle Enable

/*
 * VGA Sequencer Registers
 */
#define SR0F                  0x0F    // Display Memory Control Register
#define SR0F_DISPLAY_RAS      0x04    // Display Memory RAS# Cycle Select

#define SR0B                  0x0B    // VCLK0 Numerator
#define SR0C                  0x0C    // VCLK1 Numerator
#define SR0D                  0x0D    // VCLK2 Numerator
#define SR0E                  0x0E    // VCLK3 Numerator
#define SR0X_VCLK_NUMERATOR   0x7F    // VCLK Numerator

#define SR1B                  0x1B    // VCLK0 Denomintor and Post-Scalar
#define SR1C                  0x1C    // VCLK1 Denomintor and Post-Scalar
#define SR1D                  0x1D    // VCLK2 Denomintor and Post-Scalar
#define SR1E                  0x1E    // VCLK3 Denomintor and Post-Scalar
#define SR1X_VCLK_DENOMINATOR 0x3E    // VCLK Denominator
#define SR1X_VCLK_POST_SCALAR 0x01    // VCLK Post-Scalar
#define SR1E_VCLK_MCLK_DIV2   0x01    // MCLK Divide by 2 (when SR1F[6] = 1)

#define SR1F                  0x1F    // MCLK Frequency and VCLK Source Select
#define SR1F_VCLK_SRC         0x40    // VCLK Source Select
#define SR1F_MCLK_FREQ        0x3F    // MCLK Frequency

#define SR20                  0x20    // Miscellaneous Control Register 2
#define SR20_9MCLK_RAS        0x40    // Select 9-MCLK RAS# Cycles for EDO DRAMs
#define SR20_VCLKDIV4         0x02    // Set VCLK0, 1 Source to VCLK VCO/4

#define SR2F                  0x2F    // HFA FIFO Threshold for Surrounding
                                      //  Graphics Register
#define SR2F_HFAFIFOGFX_THRESH 0x0F    // HFA FIFO Threshold for Surr. Gfx

#define SR32                  0x32    // HFA FIFO Threshold in VW and DAC
                                      //  IREF Power Control Register
#define SR32_HFAFIFOMVW_THRESH 0x07    // HFA FIFO Thresh in VW

#define SR34                  0x34    // Host CPU Cycle Stop Control Register
#define SR34_CPUSTOP_ENABLE   0x10    // Terminate Paged Host CPU Cycles when
                                      //  Re-starting is Disabled
#define SR34_DSTN_CPUSTOP     0x08    // Stop Host CPU Cycle before Half-
                                      //  Frame Accelerator Cycle
#define SR34_VPORT_CPUSTOP    0x04    // Stop Host CPU Cycle before V-Port cycle
#define SR34_MVW_CPUSTOP      0x02    // Stop Host CPU Cycle before VW cycle
#define SR34_GFX_CPUSTOP      0x01    // Stop Host CPU Cycle before CRT
                                      //  Monitor cycle

#define GFXFIFO_THRESH        8

//typedef struct PROGREGS_
//{
//  BYTE bSR2F;
//  BYTE bSR32;
//  BYTE bSR34;
//
//  BYTE bCR42;
//  BYTE bCR51;
//  BYTE bCR5A;
//  BYTE bCR5D;
//}PROGREGS, FAR *LPPROGREGS;
//
#if 0   //myf32
typedef struct BWREGS_
{
  BYTE bSR2F;
  BYTE bSR32;
  BYTE bSR34;
  BYTE bCR42;

  BYTE bCR51;
  BYTE bCR5A;
  BYTE bCR5D;
  BYTE bCR5F;



}BWREGS, FAR *LPBWREGS;
#endif

/*
 * Function prototypes
 */
//BOOL IsSufficientBandwidth7555 (WORD, WORD, DWORD, DWORD, DWORD, DWORD,
//DWORD, DWORD, LPBWREGS);
//BOOL IsSufficientBandwidth7555 (WORD, LPRECTL, LPRECTL, DWORD);

// 7555BW.c
//static int ScaleMultiply(DWORD,         // Factor 1
//                         DWORD,         // Factor 2
//                         LPDWORD);      // Pointer to returned product
//BOOL ChipCalcMCLK(LPBWREGS,             // Current register settings
//                  LPDWORD);             // Pointer to returned MCLK
//BOOL ChipCalcVCLK(LPBWREGS,             // Current register settings
//                  LPDWORD);             // Pointer to returned VCLK
//BOOL ChipGetMCLK(LPDWORD);              // Pointer to returned MCLK
//BOOL ChipGetVCLK(LPDWORD);              // Pointer to returned VCLK
//BOOL ChipIsDSTN(LPBWREGS);              // Current register settings
//BOOL ChipCheckBandwidth(LPVIDCONFIG,    // Current video configuration
//                        LPBWREGS,       // Current register values
//                        LPPROGREGS);    // Holds return value for regs
//                                        //  (may be NULL)
//BOOL ChipIsEnoughBandwidth(LPVIDCONFIG, // Current video configuration
//                           LPPROGREGS); // Holds return value for regs
//                                        //  (may be NULL)
//// 7555IO.c
//BOOL ChipIOReadBWRegs(LPBWREGS);        // Filled with current reg settings
//BOOL ChipIOWriteProgRegs(LPPROGREGS);   // Writes register values
//BOOL ChipIOReadProgRegs(LPPROGREGS);    // Get current register settings
//
//#endif // _7555BW_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\brush.c ===
/******************************************************************************\
*
* $Workfile:   brush.c  $
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/brush.c_v  $
 * 
 *    Rev 1.3   Nov 26 1996 14:28:48   unknown
 * Use second aperture for blt.
 * 
 *    Rev 1.2   Nov 07 1996 16:44:50   unknown
 * Clean up CAPS flags
 * 
 *    Rev 1.1   Oct 10 1996 15:36:16   unknown
 *  
* 
*    Rev 1.5   13 Aug 1996 11:55:34   frido
* Fixed misalignment in brush cache.
* 
*    Rev 1.4   12 Aug 1996 17:08:08   frido
* Commented brush cache.
* Removed unaccessed local variables.
* 
*    Rev 1.3   05 Aug 1996 11:17:50   frido
* Added more check for XLATEOBJ.
* 
*    Rev 1.2   31 Jul 1996 15:43:28   frido
* Added new brush caches.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
*
*    sge01   11/26/96   Use second aperture when doing 24bpp cache blt.
* 
*
\******************************************************************************/

#include "precomp.h"

//bc#1 Handy macros.
#define BUSY_BLT(ppdev, pjBase)        (CP_MM_ACL_STAT(ppdev, pjBase) & 0x10)

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the color ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG        ulNumVertices;
    VERTEX_DATA  vVertexData[4];
    VERTEX_DATA* pvVertexData;

    // Calculate what color subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    // Initialize the fields we need:

    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;
    prb->pbe = NULL;
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It may be called directly by GDI at SelectObject time, or
* it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
* to create a realized brush in a function like DrvBitBlt.
*
* Note that we have no way of determining what the current Rop or brush
* alignment are at this point.
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    ULONG    iPatternFormat;
    BYTE*    pjSrc;
    BYTE*    pjDst;
    LONG     lSrcDelta;
    LONG     cj;
    LONG     i;
    LONG     j;
    RBRUSH*  prb;
    ULONG*   pulXlate;
    SURFOBJ* psoPunt;
    RECTL    rclDst;
    FLONG     flXlate;    //bc#1

    PDEV* ppdev = (PPDEV)psoDst->dhpdev;

#if 1 //bc#1 Dither cache.
    // Dithers...
    if (iHatch & RB_DITHERCOLOR)
    {
        if (ppdev->flStatus & STAT_DITHER_CACHE)
        {
            DITHERCACHE* pdc;
            ULONG        ulColor;
        
            // Save the color.
            ulColor = iHatch & 0xFFFFFF;

            // Allocate the brush.
            prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH));
            if (prb == NULL)
            {
                DISPDBG((2, "DrvRealizeBrush: BRUSHOBJ_pvAllocRbrush failed"));
                return(FALSE);
            }
    
            // Set the dithered brush flags.
            prb->fl     = RBRUSH_DITHER;
            prb->ulUniq = ulColor;

            // Look for a match with the cached dithers.
            pdc = &ppdev->aDithers[0];
            for (i = 0; i < NUM_DITHERS; i++)
            {
                if (pdc->ulColor == ulColor)
                {
                    // We have a match, just set the brush pointers.
                    DISPDBG((20, "DrvRealizeBrush: DitherCache match (0x%06X)",
                             ulColor));
                    prb->ulSlot  = (ULONG)((ULONG_PTR)pdc - (ULONG_PTR)ppdev);
                    prb->ulBrush = pdc->ulBrush;
                    return(TRUE);
                }
                pdc++;
            }

            // Create the dither and cache it.
            return(bCacheDither(ppdev, prb));
        }

        if (!(ppdev->flStatus & (STAT_BRUSH_CACHE | STAT_PATTERN_CACHE)))
        {
            DISPDBG((2, "DrvRealizeBrush: No brush cache to create dither"));
            return(FALSE);
        }

        // Allocate the brush.
        prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) +
                                          PELS_TO_BYTES(TOTAL_BRUSH_SIZE));
        if (prb == NULL)
        {
            DISPDBG((2, "DrvRealizeBrush: BRUSHOBJ_pvAllocRbrush failed"));
            return(FALSE);
        }

        // Realize the dither.
        vRealizeDitherPattern(prb, iHatch);
        if (ppdev->flStatus & STAT_PATTERN_CACHE)
        {
            prb->cjBytes = PELS_TO_BYTES(8) * 8;
            prb->ulSlot  = 0;
            return(bCachePattern(ppdev, prb));
        }

        return(TRUE);
    }
#endif

    // We only accelerate 8x8 patterns.
    if ((psoPattern->sizlBitmap.cx != 8) || (psoPattern->sizlBitmap.cy != 8))
    {
        DISPDBG((2, "DrvRealizeBrush: psoPattern too big (%d x %d)",
                 psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
        return(FALSE);
    }

    // We don't support masks just yet.
    if ((psoMask != NULL) && (psoMask->pvScan0 != psoPattern->pvScan0))
    {
        DISPDBG((2, "DrvRealizeBrush: psoMask not supported"));
        return(FALSE);
    }

    // Get the brush type.
    iPatternFormat = psoPattern->iBitmapFormat;
    if (psoPattern->iType != STYPE_BITMAP)
    {
        DISPDBG((2, "DrvRealizeBrush: psoPattern->iType (=%d) not supported",
                 psoPattern->iType));
        return(FALSE);
    }

    // Get the color translation table.
    flXlate = (pxlo == NULL) ? XO_TRIVIAL : pxlo->flXlate;
    if (flXlate & XO_TRIVIAL)
    {
        pulXlate = NULL;
    }
    else if (flXlate & XO_TABLE)
    {
        pulXlate = pxlo->pulXlate;
    }
    else
    {
        pulXlate = XLATEOBJ_piVector(pxlo);
    }

#if 1 //bc#1 Monochrome cache.
    if ((iPatternFormat == BMF_1BPP) &&
        (ppdev->flStatus & STAT_MONOCHROME_CACHE))
    {
        MONOCACHE* pmc;

        // We need a translation table.
        if (pulXlate == NULL)
        {
            DISPDBG((2, "DrvRealizeBrush: psoPattern(monochrome) pxlo=NULL"));
            return(FALSE);
        }

        // Allocate the brush.
        prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + 8);
        if (prb == NULL)
        {
            DISPDBG((2, "DrvRealizeBrush: BRUSHOBJ_pvAllocRbrush failed"));
            return(FALSE);
        }

        // Initialize the realized brush.
        prb->fl             = RBRUSH_MONOCHROME;
        prb->ulBackColor = pulXlate[0];
        prb->ulForeColor = pulXlate[1];

        pjSrc     = psoPattern->pvScan0;
        lSrcDelta = psoPattern->lDelta;

        // Copy the pattern to the realized brush.
        for (i = 0; i < 8; i++)
        {
            ((BYTE*) prb->aulPattern)[i] = *pjSrc;

            pjSrc += lSrcDelta;
        }

        // Lookup the pattern in te monochrome cache.
        pmc = &ppdev->aMonochromes[0];
        if (ppdev->cBpp == 3)
        {
            for (i = 0; i < NUM_MONOCHROMES; i++)
            {
                if ((pmc->aulPattern[0] == prb->aulPattern[0]) &&
                    (pmc->aulPattern[1] == prb->aulPattern[1]) &&
                    (pmc->ulBackColor   == prb->ulBackColor)   &&
                    (pmc->ulForeColor   == prb->ulForeColor))
                {
                    // We have a match! Just copy the brush pointers.
                    DISPDBG((20, "DrvRealizeBrush: Monochrome hit"));
                    prb->ulUniq  = pmc->ulUniq;
                    prb->ulSlot  = (ULONG)((ULONG_PTR)pmc - (ULONG_PTR)ppdev);
                    prb->ulBrush = pmc->ulBrush;
                    return(TRUE);
                }
                pmc++;
            }
        }
        else
        {
            for (i = 0; i < NUM_MONOCHROMES; i++)
            {
                if ((pmc->aulPattern[0] == prb->aulPattern[0]) &&
                    (pmc->aulPattern[1] == prb->aulPattern[1]))
                {
                    // We have a match! Just copy the brush pointers.
                    DISPDBG((20, "DrvRealizeBrush: Monochrome hit"));
                    prb->ulUniq  = pmc->ulUniq;
                    prb->ulSlot  = (ULONG)((ULONG_PTR)pmc - (ULONG_PTR)ppdev);
                    prb->ulBrush = pmc->ulBrush;
                    return(TRUE);
                }
                pmc++;
            }
        }

        return(bCacheMonochrome(ppdev, prb));
    }
#endif

    // We must have either an old-style brush cache or a new-style pattern
    // cache to continue.
    if (!(ppdev->flStatus & (STAT_BRUSH_CACHE | STAT_PATTERN_CACHE)))
    {
        DISPDBG((2, "DrvRealizeBrush: No brush cache"));
        return(FALSE);
    }

    // Allocate the brush.
    prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) +
                                      PELS_TO_BYTES(TOTAL_BRUSH_SIZE));
    if (prb == NULL)
    {
        DISPDBG((2, "DrvRealizeBrush: BRUSHOBJ_pvAllocRbrush failed"));
        return(FALSE);
    }

    // Initialize the realized brush.
    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = RBRUSH_PATTERN;
    prb->pbe           = NULL;

    lSrcDelta = psoPattern->lDelta;
    pjSrc     = (BYTE*) psoPattern->pvScan0;
    pjDst     = (BYTE*) &prb->aulPattern[0];

    //bc#1
    if ((ppdev->iBitmapFormat == iPatternFormat) && (flXlate & XO_TRIVIAL))
    {
        // The pattern is the same color depth as the screen, and there's no
        // translation to be done.
        cj = PELS_TO_BYTES(8);

        // Copy the pattern to the realized brush.
        for (i = 8; i != 0; i--)
        {
            RtlCopyMemory(pjDst, pjSrc, cj);

            pjSrc += lSrcDelta;
            pjDst += cj;
        }
    }
    else if ((iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))
    {
        // Translate the 16-color brush.
        for (i = 8; i != 0; i--)
        {
            // Inner loop is repeated only 4 times because each loop handles 2
            // pixels.
            for (j = 4; j != 0; j--)
            {
                *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                *pjDst++ = (BYTE) pulXlate[*pjSrc & 0x0F];
                pjSrc++;
            }

            pjSrc += lSrcDelta - 4;
        }
    }
    else
    {
        // We've got a brush whose format we haven't special cased. No problem,
        // we can have GDI convert it to our device's format. We simply use a
        // temporary surface object that was created with the same format as
        // the display, and point it to our brush realization.
        psoPunt          = ppdev->psoBank;
        psoPunt->pvScan0 = pjDst;
        psoPunt->lDelta  = PELS_TO_BYTES(8);

        rclDst.left   = 0;
        rclDst.top    = 0;
        rclDst.right  = 8;
        rclDst.bottom = 8;

        if (!EngCopyBits(psoPunt, psoPattern, NULL, pxlo, &rclDst,
                         (POINTL*) &rclDst))
        {
            DISPDBG((2, "DrvRealizeBrush: Unable to create funky brush"));
            return(FALSE);
        }
    }

#if 1 //bc#1
    // If we have a pattern cache, cache the brush now.
    if (ppdev->flStatus & STAT_PATTERN_CACHE)
    {
        prb->cjBytes = PELS_TO_BYTES(8) * 8;
        return(bCachePattern(ppdev, prb));
    }
#endif
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
\**************************************************************************/

BOOL bEnableBrushCache(
PDEV*   ppdev)
{
    OH*         poh;                // Points to off-screen chunk of memory
    BRUSHENTRY* pbe;                // Pointer to the brush-cache entry
    LONG        i;
    LONG        cBrushAlign;        // 0 = no alignment,
                                    //   n = align to n pixels
    LONG x;
    LONG y;

#if 1 //bc#1 Dither cache.
    if ((ppdev->cBpp == 1) &&
        (ppdev->flCaps & CAPS_AUTOSTART) &&
        (ppdev->bLinearMode))
    {
        LONG lDelta;

        // Allocate the dither cache horizontally.
        poh    = pohAllocatePermanent(ppdev, 64 * NUM_DITHERS + 63, 1);
        lDelta = 64;
        if (poh == NULL)
        {
            // Allocate the dither cache vertically.
            poh    = pohAllocatePermanent(ppdev, 64 + 63, NUM_DITHERS);
            lDelta = ppdev->lDelta;
        }

        if (poh != NULL)
        {
            // Align the cache to a 64-byte boundary.
            ULONG ulBase = (poh->xy + 63) & ~63;

            // Initialize the dither cache.
            DISPDBG((4, "DitherCache allocated at %d,%d (%d x %d)",
                     poh->x, poh->y, poh->cx, poh->cy));
            for (i = 0; i < NUM_DITHERS; i++)
            {
                ppdev->aDithers[i].ulColor = (ULONG) -1;
                ppdev->aDithers[i].ulBrush = ulBase;

                ulBase += lDelta;
            }

            // The dither cache has been initialized.
            ppdev->iDitherCache = 0;
            ppdev->flStatus    |= STAT_DITHER_CACHE;
        }
    }
#endif

#if 1 //bc#1 Pattern cache.
    if ((ppdev->flCaps & CAPS_AUTOSTART) &&
        (ppdev->bLinearMode))
    {
        LONG  lDelta;
        LONG  cBrushSize;
        ULONG ulAlignment;

        // Calculate the width of brush in pixels.
        if (ppdev->cBpp == 3)
        {
            cBrushSize  = (256 + 2) / 3;
            ulAlignment = 256;
        }
        else
        {
            cBrushSize  = 64;
            ulAlignment = PELS_TO_BYTES(64);
        }

        // Allocate the pattern cache horizontally.
        poh    = pohAllocatePermanent(ppdev, cBrushSize * NUM_PATTERNS +
                                             (cBrushSize - 1), 1);
        lDelta = ulAlignment;
        if (poh == NULL)
        {
            // Allocate the pattern cache vertically.
            poh    = pohAllocatePermanent(ppdev, cBrushSize + (cBrushSize - 1),
                                          NUM_PATTERNS);
            lDelta = ppdev->lDelta;
        }

        if (poh != NULL)
        {
            // Align the cache to a 64-pixel boundary.
            ULONG ulBase = (poh->xy + (ulAlignment - 1)) & ~(ulAlignment - 1);

            // Initialize the pattern cache.
            DISPDBG((4, "PatternCache allocated at %d,%d (%d x %d)",
                     poh->x, poh->y, poh->cx, poh->cy));
            for (i = 0; i < NUM_PATTERNS; i++)
            {
                ppdev->aPatterns[i].ulBrush = ulBase;
                ppdev->aPatterns[i].prbUniq = NULL;

                ulBase += lDelta;
            }

            // The pattern cache has been initialized.
            ppdev->iPatternCache = 0;
            ppdev->flStatus     |= STAT_PATTERN_CACHE;
        }
    }
#endif

#if 1 //bc#1 Monochrome cache.
    if ((ppdev->flCaps & CAPS_AUTOSTART) &&
        (ppdev->bLinearMode))
    {
        LONG  lDelta;
        LONG  cBrushSize;
        ULONG ulAlignment;

        // Calculate the width of brush in pixels.
        if (ppdev->cBpp == 3)
        {
            cBrushSize  = (256 + 2) / 3;
            ulAlignment = 256;
        }
        else
        {
            cBrushSize  = BYTES_TO_PELS(8);
            ulAlignment = 8;
        }

        // Allocate the pattern cache horizontally.
        poh       = pohAllocatePermanent(ppdev, cBrushSize * NUM_MONOCHROMES +
                                             (cBrushSize - 1), 1);
        lDelta = ulAlignment;
        if (poh == NULL)
        {
            // Allocate the pattern cache vertically.
            poh    = pohAllocatePermanent(ppdev, cBrushSize + (cBrushSize - 1),
                                          NUM_MONOCHROMES);
            lDelta = ppdev->lDelta;
        }

        if (poh != NULL)
        {
            // Align the cache to an 8-byte boundary.
            ULONG ulBase = (poh->xy + (ulAlignment - 1)) & ~(ulAlignment - 1);

            // Initialize the monochrome cache.
            DISPDBG((4, "MonochromeCache allocated at %d,%d (%d x %d)",
                     poh->x, poh->y, poh->cx, poh->cy));
            for (i = 0; i < NUM_MONOCHROMES; i++)
            {
                ppdev->aMonochromes[i].ulBrush          = ulBase;
                ppdev->aMonochromes[i].aulPattern[0] = 0;
                ppdev->aMonochromes[i].aulPattern[1] = 0;

                ulBase += lDelta;
            }

            // The monochrome cache has been initialized.
            ppdev->iMonochromeCache = 0;
            ppdev->flStatus        |= STAT_MONOCHROME_CACHE;
        }
    }
#endif

       cBrushAlign = 64;               // Align all brushes to 64 pixels

    DISPDBG((2, "cBrushAlign = %d", cBrushAlign));

       pbe = &ppdev->abe[0];           // Points to where we'll put the first
                                       //   brush cache entry

    {

           // Reserve the offscreen space that is required for the CP to do
        // solid fills.  If this fails, our solid fill code will not work.
        // We need two DWORD storage locations if we're going to do any
        // monochrome expansion stuff (font painting...).

           // Note: these must be 8 byte aligned for the cirrus chips

           // Not having a solid color work area is a
        // fatal error for this driver.

        DISPDBG((2,"Allocating solid brush work area"));
        poh = pohAllocatePermanent(ppdev, 16, 1);

        ASSERTDD((poh != NULL),
                 "We couldn't allocate offscreen space for the solid colors");

        ppdev->ulSolidColorOffset = ((((poh->y * ppdev->lDelta) +
                                           PELS_TO_BYTES(poh->x)) + 7) & ~7);

        DISPDBG((2,"ppdev->ulSolidColorOffset = %xh", ppdev->ulSolidColorOffset));


#if 1 //bc#1 Only one pattern cache.
        if (ppdev->flStatus & STAT_PATTERN_CACHE)
        {
            goto ReturnTrue;
        }
#endif

        ///////////////////////////////////////////////////////////////////////
        // Special cases where we want no brush cache...
        //
        // There are a couple of instances where we have no xfer buffer to
        // the HW blt engine.  In that case, we are unable to realize
        // patterns, so don't enable the cache.
        //
        // (1)  NEC Mips nachines lock up on xfers, so they're diabled.
        // (2)  At 1280x1024 on a 2MB card, we currently have no room for
        //      the buffer because of stretched scans.  This will be fixed.

        {
            if (ppdev->pulXfer == NULL)
                goto ReturnTrue;

        }

        //
        // Allocate single brush location for intermediate alignment purposes
        //
#if 1 //bc#1
        if (ppdev->cBpp == 3)
        {
            poh = pohAllocatePermanent(ppdev,
                                       (8 * 8 * 4) / 3 + (cBrushAlign - 1), 1);
        }
        else
#endif
        {
            poh = pohAllocatePermanent(ppdev, (8 * 8) + (cBrushAlign - 1), 1);
        }

        if (poh == NULL)
           {
               DISPDBG((2,"Failed to allocate aligned brush area"));
               goto ReturnTrue;    // See note about why we can return TRUE...
        }
           ppdev->ulAlignedPatternOffset = ((poh->xy) +
                                         (PELS_TO_BYTES(cBrushAlign) - 1)) &
                                           ~(PELS_TO_BYTES(cBrushAlign) - 1);
        DISPDBG((2,"ppdev->ulAlignedPatternOffset = %xh", ppdev->ulAlignedPatternOffset));

           //
           // Allocate brush cache
        //

#if 1 //bc#1
        if (ppdev->cBpp == 3)
        {
            poh = pohAllocatePermanent(ppdev,
                       (BRUSH_TILE_FACTOR * 8 * 8 * 4) / 3 + cBrushAlign - 1,
                       FAST_BRUSH_COUNT);
        }
        else
#endif
        {
            poh = pohAllocatePermanent(ppdev,
                       // remember this is pixels, not bytes
                       (BRUSH_TILE_FACTOR * 8 * 8) + (cBrushAlign - 1),
                    FAST_BRUSH_COUNT);
        }

           if (poh == NULL)
        {
               DISPDBG((2,"Failed to allocate brush cache"));
               goto ReturnTrue;    // See note about why we can return TRUE...
        }

           ppdev->cBrushCache = FAST_BRUSH_COUNT;

           // Hardware brushes require that the bits start on a 64 (height*width)
        // pixel boundary.  The heap manager doesn't guarantee us any such
        // alignment, so we allocate a bit of extra room so that we can
        // do the alignment ourselves:

           x = poh->x;
           y = poh->y;

        for (i = FAST_BRUSH_COUNT; i != 0; i--)
           {
               ULONG ulOffset;
               ULONG ulCeil;
            ULONG ulDiff;

               // Note:  I learned the HARD way that you can't just align x
            //        to your pattern size, because the lDelta of your screen
            //        is not guaranteed to be a multiple of your pattern size.
            //        Since y is changing in this loop, the recalc must
            //        be done inside this loop.  I really need to set these
            //        up with a hardcoded linear buffer or else make the
            //        heap linear.

               ulOffset = (y * ppdev->lDelta) + PELS_TO_BYTES(x);
               ulCeil = (ulOffset + (PELS_TO_BYTES(cBrushAlign)-1)) & ~(PELS_TO_BYTES(cBrushAlign)-1);
               ulDiff = (ulCeil - ulOffset)/ppdev->cBpp;

            // If we hadn't allocated 'ppdev' with FL_ZERO_MEMORY,
               // we would have to initialize pbe->prbVerify too...

               pbe->x = x + ulDiff;
               pbe->y = y;
            pbe->xy = (pbe->y * ppdev->lDelta) + PELS_TO_BYTES(pbe->x);

               DISPDBG((2, "BrushCache[%d] pos(%d,%d) offset(%d)", i, pbe->x,
                        pbe->y, pbe->xy ));

               y++;
               pbe++;
        }
       }

    // Note that we don't have to remember 'poh' for when we have
       // to disable brushes -- the off-screen heap frees any
    // off-screen heap allocations automatically.

    // We successfully allocated the brush cache, so let's turn
    // on the switch showing that we can use it:
    
    ppdev->flStatus |= STAT_BRUSH_CACHE;

ReturnTrue:

    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:

    vAssertModeBrushCache(ppdev, TRUE);

    DISPDBG((5, "Passed bEnableBrushCache"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache
*
* Cleans up anything done in bEnableBrushCache.
\**************************************************************************/

VOID vDisableBrushCache(PDEV* ppdev)
{
    // We ain't gotta do nothin'
}

/******************************Public*Routine******************************\
* VOID vAssertModeBrushCache
*
* Resets the brush cache when we exit out of full-screen.
\**************************************************************************/

VOID vAssertModeBrushCache(
PDEV*   ppdev,
BOOL    bEnable)
{
    BRUSHENTRY* pbe;
    LONG        i;

    if (bEnable)
    {
        //bc#1 Invalidate the dither cache.
        if (ppdev->flStatus & STAT_DITHER_CACHE)
        {
            for (i = 0; i < NUM_DITHERS; i++)
            {
                ppdev->aDithers[i].ulColor = (ULONG) -1;
            }
        }

        //bc#1 Invalidate the pattern cache.
        if (ppdev->flStatus & STAT_PATTERN_CACHE)
        {
            for (i = 0; i < NUM_PATTERNS; i++)
            {
                ppdev->aPatterns[i].prbUniq = NULL;
            }
        }

        //bc#1 Invalidate the monochrome cache.
        if (ppdev->flStatus & STAT_MONOCHROME_CACHE)
        {
            for (i = 0; i < NUM_MONOCHROMES; i++)
            {
                ppdev->aMonochromes[i].ulUniq         = 0;
                ppdev->aMonochromes[i].aulPattern[0] = 0;
                ppdev->aMonochromes[i].aulPattern[1] = 0;
            }
        }

        // Invalidate the brush cache.
        if (ppdev->flStatus & STAT_BRUSH_CACHE)
        {
            pbe = &ppdev->abe[0];
    
            for (i = ppdev->cBrushCache; i != 0; i--)
            {
                pbe->prbVerify = NULL;
                pbe++;
            }
        }

        // Create a solid 8 x 8 monochrome bitmap in offscreen memory which
        // will be used for solid fills.
        if (ppdev->flCaps & CAPS_MM_IO)
        {
            BYTE* pjBase = ppdev->pjBase;

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
            CP_MM_XCNT(ppdev, pjBase, 7);
            CP_MM_YCNT(ppdev, pjBase, 0);
            CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);
            CP_MM_BLT_MODE(ppdev, pjBase, 0);
            CP_MM_ROP(ppdev, pjBase, CL_WHITENESS);
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->ulSolidColorOffset);
            CP_MM_START_BLT(ppdev, pjBase);
        }
        else
        {
            BYTE* pjPorts = ppdev->pjPorts;

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
            CP_IO_XCNT(ppdev, pjPorts, 7);
            CP_IO_YCNT(ppdev, pjPorts, 0);
            CP_IO_BLT_MODE(ppdev, pjPorts, 0);
            CP_IO_ROP(ppdev, pjPorts, CL_WHITENESS);
            CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->ulSolidColorOffset);
            CP_IO_START_BLT(ppdev, pjPorts);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                              //
//                        B R U S H   C A C H E   S T U F F                      //
//                                                                              //
////////////////////////////////////////////////////////////////////////////////
/*
    Dither Cache:
    ============
    The dither cache is very important (at least with a slow CPU). Since the
    dithering process (in 8-bpp) takes quite a long time we must somehow cache
    the dithering process so it doesn't have to be executed over and over again.
    We do this by comparing the requested logical color with the cached dithers.
    If we have a match we simply copy the cached parameters and return. If we
    don't have a match we create a new cache slot and create the dither in
    off-screen memory.

    Pattern Cache:
    =============
    The pattern cache holds the colored brushes. Whenever we are requested to
    realize the same brush again, we can simply return. We don't check for the
    brush bits since that will take up too much time.

    Monochrome Cache:
    ================
    The monochrome cache holds the monochrome brushes. Whenever a monochrome
    brush needs to be realized we check to see if it is already cached
    off-screen. If it is we simply copy the cached parameters and return.
    Otherwise we have to create a new cache slot and realize the monochrome
    brush directly in off-screen memory. This has a slight performance hit since
    the bitblt engine is interrupted (on CL5436) or must be idle (in 24-bpp).

    Translation Cache:
    =================
    Is not yet implemented.
*/

/******************************************************************************\
*
* Function:     bCacheDither
*
* Cache a dithered color.
*
* Parameters:   ppdev        Pointer to physicsl device.
*                prb            Pointer to physical brush.
*
* Returns:      TRUE.
*
\******************************************************************************/
BOOL bCacheDither(
PDEV*   ppdev,
RBRUSH* prb)
{
    ULONG         ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA* pvVertexData;
    DITHERCACHE* pdc;
    ULONG         ulIndex;

    // New dither cache entry.
    ulIndex = ppdev->iDitherCache++ % NUM_DITHERS;
    pdc        = &ppdev->aDithers[ulIndex];

    // Store the color in the cache slot.
    pdc->ulColor = prb->ulUniq;

    // Update the brush cache variables.
    prb->ulSlot  = (ULONG)((ULONG_PTR)pdc - (ULONG_PTR)ppdev);
    prb->ulBrush = pdc->ulBrush;

    // Create the dither.
    pvVertexData  = vComputeSubspaces(prb->ulUniq, vVertexData);
    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
    vDitherColorToVideoMemory((ULONG*) (ppdev->pjScreen + pdc->ulBrush), vVertexData,
                 pvVertexData, ulNumVertices);

    DISPDBG((20, "Caching dithered brush ulIndex=%d ulColor=%06X",
             ulIndex, pdc->ulColor));
    return(TRUE);
}

/******************************************************************************\
*
* Function:     bCacheColor
*
* Cache a patterned brush.
*
* Parameters:   ppdev        Pointer to physicsl device.
*                prb            Pointer to physical brush.
*
* Returns:      TRUE.
*
\******************************************************************************/
BOOL bCachePattern(
PDEV*   ppdev,
RBRUSH* prb
)
{
    PATTERNCACHE* ppc;
    LONG          lDstDelta;
    SIZEL          sizlDst;
    ULONG*          pulSrc;
    LONG          i;
    ULONG*          pulDst;
    ULONG          ulIndex;

    BYTE* pjBase = ppdev->pjBase;

    // New pattern cache entry.
    ulIndex = ppdev->iPatternCache++ % NUM_PATTERNS;
    ppc     = &ppdev->aPatterns[ulIndex];

    // Update the brush cache variables.
    ppc->prbUniq = prb;
    prb->ulSlot  = (ULONG)((ULONG_PTR)ppc - (ULONG_PTR)ppdev);
    prb->ulBrush = ppc->ulBrush;

    // Calculate the sizes for the pattern.
    pulSrc     = prb->aulPattern;
    pulDst       = (ULONG*) ppdev->pulXfer;
    lDstDelta  = (ppdev->cBpp == 3) ? (8 * 4) : PELS_TO_BYTES(8);
    sizlDst.cx = PELS_TO_BYTES(8) - 1;
    sizlDst.cy = 8 - 1;

    // Wait for the bitblt engine.
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    // Setup the blit registers.
    CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
    CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDstDelta);
    CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);
    CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
    CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppc->ulBrush);

    // Copy the brush to off-screen cache memory.
    for (i = prb->cjBytes; i > 0; i -= sizeof(ULONG))
    {
        WRITE_REGISTER_ULONG(pulDst, *pulSrc++);
    }

    DISPDBG((20, "Caching patterned brush at slot %d", ulIndex));
    return(TRUE);
}

/******************************************************************************\
*
* Function:     bCacheMonochrome
*
* Cache a monochrome brush.
*
* Parameters:   ppdev        Pointer to physicsl device.
*                prb            Pointer to physical brush.
*
* Returns:      TRUE.
*
\******************************************************************************/
BOOL bCacheMonochrome(
PDEV*   ppdev,
RBRUSH* prb
)
{
    MONOCACHE* pmc;
    ULONG       ulIndex;
    BYTE*       pjDst;
    ULONG*     pulDst;

    // New monochrome cache entry.
    ulIndex = ppdev->iMonochromeCache++ % NUM_MONOCHROMES;
    pmc     = &ppdev->aMonochromes[ulIndex];

    // Update the brush cache variables.
    pmc->aulPattern[0] = prb->aulPattern[0];
    pmc->aulPattern[1] = prb->aulPattern[1];

    pmc->ulUniq     = ppdev->iMonochromeCache;
    prb->ulUniq     = ppdev->iMonochromeCache;
    prb->ulSlot  = (ULONG)((ULONG_PTR)pmc - (ULONG_PTR)ppdev);
    prb->ulBrush = pmc->ulBrush;

    // Copy the brush to off-screen cache memory.
    if (ppdev->cBpp == 3)
    {
        BYTE* pjBase = ppdev->pjBase;

        // Copy colors to brush cache.
        pmc->ulBackColor = prb->ulBackColor;
        pmc->ulForeColor = prb->ulForeColor;

        pulDst = (ULONG*)ppdev->pulXfer;

        // Wait for bitblt engine.
        while (BUSY_BLT(ppdev, pjBase));

        // Fill the background.
        CP_MM_FG_COLOR(ppdev, pjBase, pmc->ulBackColor);
        CP_MM_XCNT(ppdev, pjBase, (8 * 3) - 1);
        CP_MM_YCNT(ppdev, pjBase, (8) - 1);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, 8 * 4);
        CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);
        CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND |
                                      ENABLE_8x8_PATTERN_COPY |
                                      SET_24BPP_COLOR);
        CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
        CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, pmc->ulBrush);

        // Wait for bitblt engine.
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        // Expand the pattern.
        CP_MM_FG_COLOR(ppdev, pjBase, pmc->ulForeColor);
        CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND |
                                      SET_24BPP_COLOR |
                                      ENABLE_TRANSPARENCY_COMPARE |
                                      SRC_CPU_DATA);
        CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0)                // jl01
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, pmc->ulBrush);

        WRITE_REGISTER_ULONG(pulDst, pmc->aulPattern[0]);
        WRITE_REGISTER_ULONG(pulDst, pmc->aulPattern[1]);
    }

    else
    {
        pulDst = (ULONG *)(ppdev->pjScreen + prb->ulBrush);

        WRITE_REGISTER_ULONG(pulDst++, prb->aulPattern[0]);
        WRITE_REGISTER_ULONG(pulDst,   prb->aulPattern[1]);
    }

    DISPDBG((20, "Caching monochrome brush ulIndex=%d pattern=%08X%08X",
             ulIndex, prb->aulPattern[0], prb->aulPattern[1]));
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\bltio.c ===
/******************************************************************************\
*
* $Workfile:   bltio.c  $
*
* Contains the low-level IO blt functions.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/bltio.c_v  $
 * 
 *    Rev 1.2   Nov 07 1996 16:47:52   unknown
 * Clean up CAPS flags
 * 
 *    Rev 1.1   Oct 10 1996 15:36:10   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:49:42   frido
* Removed unaccessed local parameters.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
\******************************************************************************/

#include "precomp.h"

/**************************************************************************
* VOID vIoFastPatRealize
*
* Realizes a pattern into offscreen memory.
*
**************************************************************************/

VOID vIoFastPatRealize(
PDEV*   ppdev,
RBRUSH* prb)                    // Points to brush realization structure
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    BYTE*       pjPattern;
    LONG        cjPattern;
    BYTE*       pjPorts = ppdev->pjPorts;
    LONG        lDelta = ppdev->lDelta;
    LONG        lDeltaPat;
    LONG        xCnt;
    LONG        yCnt;
    ULONG       ulDst;

    DISPDBG((10,"vFastPatRealize called"));

    pbe = prb->pbe;
    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new offscreen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify           = prb;
        prb->pbe = pbe;
    }

    //
    // Download brush into cache
    //

    pjPattern = (PBYTE) &prb->aulPattern[0];        // Copy from brush buffer
    cjPattern = PELS_TO_BYTES(TOTAL_BRUSH_SIZE);

    lDeltaPat = PELS_TO_BYTES(8);
    xCnt = PELS_TO_BYTES(8);
    yCnt = 8;

    ulDst = (pbe->y * ppdev->lDelta) + PELS_TO_BYTES(pbe->x);

    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, (lDeltaPat * 2));
    CP_IO_XCNT(ppdev, pjPorts, (xCnt - 1));
    CP_IO_YCNT(ppdev, pjPorts, (yCnt - 1));
    CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);
    CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
    CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDst);

    CP_IO_START_BLT(ppdev, pjPorts);

    vImageTransfer(ppdev, pjPattern, lDeltaPat, xCnt, yCnt);

    //
    // Duplicate brush horizontally
    //

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_XCNT(ppdev, pjPorts, (xCnt - 1));
    CP_IO_YCNT(ppdev, pjPorts, (yCnt - 1));
    CP_IO_BLT_MODE(ppdev, pjPorts, 0);
    CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, (lDeltaPat * 2));
    CP_IO_SRC_ADDR(ppdev, pjPorts, ulDst);
    CP_IO_DST_ADDR_ABS(ppdev, pjPorts, (ulDst + lDeltaPat));

    CP_IO_START_BLT(ppdev, pjPorts);

    //
    // Duplicate brush vertically
    //

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, (xCnt * 2));
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, (xCnt * 2));
    CP_IO_BLT_MODE(ppdev, pjPorts, 0);
    CP_IO_XCNT(ppdev, pjPorts, ((xCnt * 2) - 1));
    CP_IO_YCNT(ppdev, pjPorts, (yCnt - 1));
    CP_IO_SRC_ADDR(ppdev, pjPorts, ulDst);
    CP_IO_DST_ADDR_ABS(ppdev, pjPorts, (ulDst + PELS_TO_BYTES(128)));
    CP_IO_START_BLT(ppdev, pjPorts);

    #if 0
    {
        ////////////////////////////////////////////////////////////////
        // DEBUG TILED PATTERNS
        //
        // The following code helps to debug patterns if you break the
        // realization code.  It copies the 2x2 tiled copy of the brush
        // to the visible screen.
        //

        POINTL ptl;
        RECTL rcl;

        ptl.x = pbe->x;
        ptl.y = pbe->y;

        rcl.left = 10;
        rcl.right = 10 + 16;
        rcl.top = ppdev->cyScreen - 10 - 16;
        rcl.bottom = ppdev->cyScreen - 10;

        {
            LONG        lDelta = ppdev->lDelta;
            BYTE        jHwRop;
            BYTE        jMode;

            //
            // Make sure we can write to the video registers.
            //

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

            CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
            CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, PELS_TO_BYTES(16));
            CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

            {
                //
                // Top to Bottom - Left to Right
                //

                jMode |= DIR_TBLR;
                CP_IO_BLT_MODE(ppdev, pjPorts, ppdev->jModeColor);

                {

                    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

                    CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(rcl.right - rcl.left) - 1));
                    CP_IO_YCNT(ppdev, pjPorts, (rcl.bottom - rcl.top - 1));

                    CP_IO_SRC_ADDR(ppdev, pjPorts, (0 + ((ptl.y) * lDelta) + PELS_TO_BYTES(ptl.x)));
                    CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ((rcl.top * lDelta) + PELS_TO_BYTES(rcl.left)));
                    CP_IO_START_BLT(ppdev, pjPorts);
                }
            }
        }
    }
    #endif
}

/**************************************************************************
* VOID vIoFillPat
*
* This routine uses the pattern hardware to draw a patterned list of
* rectangles.
*
**************************************************************************/

VOID vIoFillPat(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  //
{
    BYTE*       pjPorts = ppdev->pjPorts;
    LONG        lDelta = ppdev->lDelta;
    ULONG       ulAlignedPatternOffset = ppdev->ulAlignedPatternOffset;
    ULONG       ulPatternAddrBase;
    BYTE        jHwRop;
    BYTE        jMode;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    DISPDBG((10,"vFillPat called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->cBpp < 3, "vFillPat only works at 8bpp and 16bpp");

    if ((rbc.prb->pbe == NULL) ||
        (rbc.prb->pbe->prbVerify != rbc.prb))
    {
        vIoFastPatRealize(ppdev, rbc.prb);
        DISPDBG((5, " -- Brush cache miss, put it at (%d,%d)", rbc.prb->pbe->x, rbc.prb->pbe->y));
    }
    else
    {
        DISPDBG((5, " -- Brush cache hit on brush at (%d,%d)", rbc.prb->pbe->x, rbc.prb->pbe->y));
    }

    pbe = rbc.prb->pbe;

    //
    // Fill the list of rectangles
    //

    ulPatternAddrBase = pbe->xy;
    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];
    jMode = ppdev->jModeColor | ENABLE_8x8_PATTERN_COPY;

    do {
        ULONG offset = 0;

        offset = PELS_TO_BYTES(
            (((prcl->top-pptlBrush->y)&7) << 4)
            +((prcl->left-pptlBrush->x)&7)
        );

        // align the pattern to a new location

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_BLT_MODE(ppdev, pjPorts, 0);
        CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
        CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, PELS_TO_BYTES(16));
        CP_IO_DST_Y_OFFSET(ppdev, pjPorts, PELS_TO_BYTES(8));
        CP_IO_SRC_ADDR(ppdev, pjPorts, (ulPatternAddrBase + offset));
        CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(8) - 1));
        CP_IO_YCNT(ppdev, pjPorts, (8 - 1));
        CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulAlignedPatternOffset);
        CP_IO_START_BLT(ppdev, pjPorts);

        // fill using aligned pattern

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_BLT_MODE(ppdev, pjPorts, jMode);
        CP_IO_ROP(ppdev, pjPorts, jHwRop);
        CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
        CP_IO_SRC_ADDR(ppdev, pjPorts, ulAlignedPatternOffset);
        CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
        CP_IO_YCNT(ppdev, pjPorts, (prcl->bottom - prcl->top - 1));
        CP_IO_DST_ADDR(ppdev, pjPorts, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
        CP_IO_START_BLT(ppdev, pjPorts);

        prcl++;

    } while (--c != 0);
}


/**************************************************************************
* VOID vIoFillSolid
*
* Does a solid fill to a list of rectangles.
*
**************************************************************************/

VOID vIoFillSolid(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  // Not used
{
    BYTE*       pjPorts = ppdev->pjPorts;
    LONG        lDelta = ppdev->lDelta;
    LONG        cBpp = ppdev->cBpp;
    ULONG       ulSolidColor;
    BYTE        jHwRop;

    DISPDBG((10,"vFillSolid called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    ulSolidColor = rbc.iSolidColor;

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];

    //
    // Make sure we can write to the video registers.
    //

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_ROP(ppdev, pjPorts, jHwRop);
    CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_BLT_MODE(ppdev, pjPorts, ENABLE_COLOR_EXPAND |
                                ENABLE_8x8_PATTERN_COPY |
                                ppdev->jModeColor);
    CP_IO_FG_COLOR(ppdev, pjPorts, ulSolidColor);

    //
    // Fill the list of rectangles
    //

    while (TRUE)
    {
        CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
        CP_IO_YCNT(ppdev, pjPorts, (prcl->bottom - prcl->top - 1));
        CP_IO_DST_ADDR(ppdev, pjPorts, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
        CP_IO_START_BLT(ppdev, pjPorts);

        if (--c == 0)
            return;

        prcl++;
        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
    }
}


/**************************************************************************
* VOID vIoCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
**************************************************************************/

VOID vIoCopyBlt(
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ROP4    rop4,       // Obvious?
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG        dx;
    LONG        dy;     // Add delta to destination to get source

    LONG        xyOffset = ppdev->xyOffset;
    BYTE*       pjPorts = ppdev->pjPorts;
    LONG        lDelta = ppdev->lDelta;
    BYTE        jHwRop;

    DISPDBG((10,"vCopyBlt called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    //
    // Make sure we can write to the video registers.
    //

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    jHwRop = gajHwMixFromRop2[rop4 & 0xf];
    CP_IO_ROP(ppdev, pjPorts, jHwRop);

    CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

    //
    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:
    //

    if (!OVERLAP(prclDst, pptlSrc) ||
        (prclDst->top < pptlSrc->y) ||
        ((prclDst->top == pptlSrc->y) && (prclDst->left <= pptlSrc->x))
        )
    {
        //
        // Top to Bottom - Left to Right
        //

        DISPDBG((12,"Top to Bottom - Left to Right"));

        CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);

        while (TRUE)
        {
            CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
            CP_IO_YCNT(ppdev, pjPorts, (prcl->bottom - prcl->top - 1));

            CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((prcl->top + dy) * lDelta) + PELS_TO_BYTES(prcl->left + dx)));
            CP_IO_DST_ADDR(ppdev, pjPorts, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
            CP_IO_START_BLT(ppdev, pjPorts);

            if (--c == 0)
                return;

            prcl++;
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }
    }
    else
    {
        //
        // Bottom to Top - Right to Left
        //

        DISPDBG((12,"Bottom to Top - Right to Left"));

        CP_IO_BLT_MODE(ppdev, pjPorts, DIR_BTRL);

        while (TRUE)
        {
            CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
            CP_IO_YCNT(ppdev, pjPorts, (prcl->bottom - prcl->top - 1));

            CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((prcl->bottom - 1 + dy) * lDelta) + PELS_TO_BYTES(prcl->right + dx) - 1));
            CP_IO_DST_ADDR(ppdev, pjPorts, (((prcl->bottom - 1) * lDelta) + PELS_TO_BYTES(prcl->right) - 1));
            CP_IO_START_BLT(ppdev, pjPorts);

            if (--c == 0)
                return;

            prcl++;
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vIoXfer1bpp
*
* Low-level routine used to transfer monochrome data to the screen using
* DWORD writes to the blt engine.
*
* This can handle opaque or transparent expansions.  It does opaque
* expansions by drawing the opaque rectangle first and then transparently
* expands the foreground bits.
*
\**************************************************************************/
VOID vIoXfer1bpp(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // Actually had better be a rop3
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides color-expansion information
{
    ULONG* pulXfer;
    ULONG* pul;
    LONG   ix;
    LONG   iy;
    LONG   cxWidthInBytes;
    BYTE*  pjBits;
    POINTL ptlDst;
    POINTL ptlSrc;
    SIZEL  sizlDst;
    LONG   cxLeftMask;
    LONG   cxRightMask;
    ULONG  ulDstAddr;
    INT    nDwords;
    ULONG  ulLeftMask;
    ULONG  ulRightMask;
    LONG   dx;
    LONG   dy;

    BYTE* pjPorts   = ppdev->pjPorts;
    LONG  lDelta    = ppdev->lDelta;
    LONG  lDeltaSrc = psoSrc->lDelta;
    LONG  cBpp      = ppdev->cBpp;
    ULONG ulFgColor = pxlo->pulXlate[1];
    ULONG ulBgColor = pxlo->pulXlate[0];

    // Since the hardware clipping on some of the Cirrus chips is broken, we
    // do the clipping by rounding out the edges to dword boundaries and then
    // doing the blt transparently.  In the event that we want the expansion
    // to be opaque, we do the opaquing blt in advance.  One side effect of
    // this is that the destination bits are no longer valid for processing
    // the rop.  This could probably be optimized by doing the edges seperately
    // and then doing the middle section in one pass.  However, this is
    // complicated by a 5434 bug that breaks blts less than 10 pixels wide.

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) == 0xcc00), "Expected foreground rop of 0xcc");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    if (cBpp == 1)
    {
        ulFgColor = (ulFgColor << 8) | (ulFgColor & 0xff);
        ulBgColor = (ulBgColor << 8) | (ulBgColor & 0xff);
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }
    else if (cBpp == 2)
    {
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }

    pulXfer = ppdev->pulXfer;
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

    if (rop4 != 0xCCAA)
    {
        LONG    lCnt = c;
        RECTL*  prclTmp = prcl;
        BYTE    jHwBgRop = gajHwMixFromRop2[rop4 & 0xf];

        CP_IO_ROP(ppdev, pjPorts, jHwBgRop);
        CP_IO_FG_COLOR(ppdev, pjPorts, ulBgColor);
        CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
        CP_IO_BLT_MODE(ppdev, pjPorts, ppdev->jModeColor |
                                    ENABLE_COLOR_EXPAND |
                                    ENABLE_8x8_PATTERN_COPY);
		
        do
        {
            // calculate the size of the blt

            ptlDst.x = prclTmp->left;
            ptlDst.y = prclTmp->top;
            sizlDst.cx = prclTmp->right - ptlDst.x;
            sizlDst.cy = prclTmp->bottom - ptlDst.y;

            //
            // Fill the background rectangle with the background color
            //

            // Set the dest addresses

            ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

			//
			// Tell the hardware how many bytes we'd like to write:
			// sizlDst.cx * sizelDst.cy
			//
            CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(sizlDst.cx) - 1);
            CP_IO_YCNT(ppdev, pjPorts, sizlDst.cy - 1);
            CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

            // Start the blt operation

            CP_IO_START_BLT(ppdev, pjPorts);
            prclTmp++;
        } while (--lCnt != 0);

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
    }

    CP_IO_FG_COLOR(ppdev, pjPorts, ulFgColor);

    CP_IO_BG_COLOR(ppdev, pjPorts, ~ulFgColor);
    CP_IO_XPAR_COLOR(ppdev, pjPorts, ~ulFgColor);
    CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
    CP_IO_BLT_MODE(ppdev, pjPorts, ppdev->jModeColor |
                                ENABLE_COLOR_EXPAND |
                                ENABLE_TRANSPARENCY_COMPARE |
                                SRC_CPU_DATA);
    CP_IO_BLT_EXT_MODE(ppdev, pjPorts, 0);            // jl01

    do
    {
        // calculate the size of the blt

        ptlDst.x = prcl->left;
        ptlDst.y = prcl->top;
        sizlDst.cx = prcl->right - ptlDst.x;
        sizlDst.cy = prcl->bottom - ptlDst.y;

        // calculate the number of dwords per scan line

        ptlSrc.x = prcl->left + dx;
        ptlSrc.y = prcl->top + dy;

        // Floor the source.
        // Extend the width by the amount required to floor to a dword boundary.
        // Set the size of the left mask.
        // Floor the dest, so it aligns with the floored source.

        if ((cxLeftMask = (ptlSrc.x & 31)))
        {
            sizlDst.cx += cxLeftMask;
            ptlSrc.x &= ~31;
            ptlDst.x -= cxLeftMask;
        }

        ulLeftMask = gaulLeftClipMask[cxLeftMask];

        // Ceil the cx to a dword boundary.

        if (cxRightMask = (sizlDst.cx & 31))
        {
            cxRightMask = 32 - cxRightMask;
            sizlDst.cx = (sizlDst.cx + 31) & ~31;
        }

        ulRightMask = gaulRightClipMask[cxRightMask];

        if (sizlDst.cx == 32)
        {
            ulLeftMask &= ulRightMask;
            ulRightMask = 0;
        }

        // Note: At this point sizlDst.cx is the width of the blt in pixels,
        //       floored to a dword boundary, and ceiled to a dword boundary.

        // Calculate the width in Bytes

        cxWidthInBytes  = sizlDst.cx >> 3;

        // Calculate the number of Dwords and any remaining bytes

        nDwords = cxWidthInBytes >> 2;

        ASSERTDD(((cxWidthInBytes & 0x03) == 0),
                 "cxWidthInBytes is not a DWORD multiple");

        // Calculate the address of the source bitmap
        // This is to a byte boundary.

        pjBits  = (PBYTE) psoSrc->pvScan0;
        pjBits += ptlSrc.y * lDeltaSrc;
        pjBits += ptlSrc.x >> 3;

        ASSERTDD((((ULONG_PTR)pjBits & 0x03) == 0),
                 "pjBits not DWORD aligned like it should be");

        //
        // Blt the 1 bpp bitmap
        //

        ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(sizlDst.cx) - 1);
        CP_IO_YCNT(ppdev, pjPorts, sizlDst.cy - 1);

        //
        // The 542x chips require a write to the Src Address Register when
        // doing a host transfer with color expansion.  The value is
        // irrelevant, but the write is crucial.  This is documented in
        // the manual, not the errata.  Go figure.
        //

        CP_IO_SRC_ADDR(ppdev, pjPorts, 0);
        CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

        CP_IO_START_BLT(ppdev, pjPorts);

        //
        // Transfer the host bitmap.
        //
        if (ulRightMask)
        {
            //
            // Blt is > 1 DWORD wide (nDwords > 1)
            //

            for (iy = 0; iy < sizlDst.cy; iy++)
            {
                pul = (ULONG*) pjBits;

                //*pulXfer++ = *(((ULONG*)pul)++) & ulLeftMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul) & ulLeftMask));
                pul++;

                for (ix = 0; ix < (nDwords-2); ix++)
                {
                    //*pulXfer++ = *(((ULONG*)pul)++);
                    WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul)));
                    pul++;
                }
                //*pulXfer++ = *(((ULONG*)pul)++) & ulRightMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul) & ulRightMask));
                pul++;

                pjBits += lDeltaSrc;
                //pulXfer = ppdev->pulXfer;
                CP_MEMORY_BARRIER();     // Flush memory cache when we reset the address

            }
        }
        else
        {
            //
            // Blt is 1 DWORD wide (nDwords == 1)
            //

            for (iy = 0; iy < sizlDst.cy; iy++)
            {
                //*pulXfer = *((ULONG*)pjBits) & ulLeftMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pjBits) & ulLeftMask));
                pjBits += lDeltaSrc;
                CP_MEMORY_BARRIER();     // Flush memory cache
            }
        }

        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vIoXfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* NOTE: The screen must be 8bpp for this function to be called!
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.

#define XLATE_BUFFER_SIZE 256

VOID vIoXfer4bpp(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    ULONG*          pulXfer = ppdev->pulXfer;
    BYTE*           pjPorts = ppdev->pjPorts;
    LONG            lDelta  = ppdev->lDelta;
    ULONG           ulDstAddr;
    LONG            dx;
    LONG            dy;
    LONG            cx;
    LONG            cy;
    LONG            lSrcDelta;
    BYTE*           pjSrcScan0;
    BYTE*           pjScan;
    BYTE*           pjSrc;
    BYTE*           pjDst;
    LONG            cxThis;
    LONG            cxToGo;
    LONG            xSrc;
    LONG            iLoop;
    BYTE            jSrc;
    ULONG*          pulXlate;
    LONG            cdwThis;
    BYTE*           pjBuf;
    BYTE            ajBuf[XLATE_BUFFER_SIZE];

    ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP, "Screen must be 8bpp");
    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    DISPDBG((5, "vXfer4bpp: entry"));

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_ROP(ppdev, pjPorts, gajHwMixFromRop2[rop4 & 0xf]);
    CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);

    while(TRUE)
    {
        ulDstAddr = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(cx) - 1);
        CP_IO_YCNT(ppdev, pjPorts, cy - 1);
        CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

        pulXlate  =  pxlo->pulXlate;
        xSrc      =  prcl->left + dx;
        pjScan    =  pjSrcScan0 + (prcl->top + dy) * lSrcDelta + (xSrc >> 1);

        CP_IO_START_BLT(ppdev, pjPorts);

        do {
            pjSrc  = pjScan;
            cxToGo = cx;            // # of pels per scan in 4bpp source
            do {
                cxThis  = XLATE_BUFFER_SIZE;
                                    // We can handle XLATE_BUFFER_SIZE number
                                    //   of pels in this xlate batch
                cxToGo -= cxThis;   // cxThis will be the actual number of
                                    //   pels we'll do in this xlate batch
                if (cxToGo < 0)
                    cxThis += cxToGo;

                pjDst = ajBuf;      // Points to our temporary batch buffer

                // We handle alignment ourselves because it's easy to
                // do, rather than pay the cost of setting/resetting
                // the scissors register:

                if (xSrc & 1)
                {
                    // When unaligned, we have to be careful not to read
                    // past the end of the 4bpp bitmap (that could
                    // potentially cause us to access violate):

                    iLoop = cxThis >> 1;        // Each loop handles 2 pels;
                                                //   we'll handle odd pel
                                                //   separately
                    jSrc  = *pjSrc;
                    while (iLoop-- != 0)
                    {
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];
                        jSrc = *(++pjSrc);
                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                    }

                    if (cxThis & 1)
                        *pjDst = (BYTE) pulXlate[jSrc & 0xf];
                }
                else
                {
                    iLoop = (cxThis + 1) >> 1;  // Each loop handles 2 pels
                    do {
                        jSrc = *pjSrc++;

                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];

                    } while (--iLoop != 0);
                }

                // The number of bytes we'll transfer is equal to the number
                // of pels we've processed in the batch.  Since we're
                // transferring words, we have to round up to get the word
                // count:

                cdwThis = (cxThis + 3) >> 2;
                pjBuf  = ajBuf;

                TRANSFER_DWORD_ALIGNED(ppdev, pulXfer, pjBuf, cdwThis);

            } while (cxToGo > 0);

            pjScan += lSrcDelta;        // Advance to next source scan.  Note
                                        //   that we could have computed the
                                        //   value to advance 'pjSrc' directly,
                                        //   but this method is less
                                        //   error-prone.

        } while (--cy != 0);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vIoXferNative
*
* Transfers a bitmap that is the same color depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vIoXferNative(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    ULONG*          pulXfer = ppdev->pulXfer;
    BYTE*           pjPorts = ppdev->pjPorts;
    LONG            lDelta  = ppdev->lDelta;
    ULONG           ulDstAddr;
    LONG            dx;
    LONG            dy;
    LONG            cx;
    LONG            cy;
    LONG            lSrcDelta;
    BYTE*           pjSrcScan0;
    BYTE*           pjSrc;
    LONG            cjSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same color depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_ROP(ppdev, pjPorts, gajHwMixFromRop2[rop4 & 0xf]);
    CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);

    while(TRUE)
    {
        ulDstAddr = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(cx) - 1);
        CP_IO_YCNT(ppdev, pjPorts, cy - 1);
        CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

        cjSrc = PELS_TO_BYTES(cx);
        pjSrc = pjSrcScan0 + (prcl->top  + dy) * lSrcDelta
                           + (PELS_TO_BYTES(prcl->left + dx));

        CP_IO_START_BLT(ppdev, pjPorts);
        vImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy);

        if (--c == 0)
            return;

        prcl++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in the 'blt??.c' files.
*
* !!! Change note about 'iType'
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).  So throughout
*       this code, we will compare a surface's 'iType' to STYPE_BITMAP:
*       if it's equal, we've got a true DIB, and if it's unequal, we have
*       a screen-to-screen operation.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Table********************************\
* BYTE gajLeftMask[] and BYTE gajRightMask[]
*
* Edge tables for vXferScreenTo1bpp.
\**************************************************************************/

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* VOID vXferNativeSrccopy
*
* Does a SRCCOPY transfer of a bitmap to the screen using the frame
* buffer, because on the Cirrus chips it's faster than using the data
* transfer register.
*
\**************************************************************************/

VOID vXferNativeSrccopy(        // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       rop4,               // Not used
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Not used
{
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    RECTL   rclDst;
    POINTL  ptlSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(rop4 == 0xcccc, "Must be a SRCCOPY rop");

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    while (TRUE)
    {
        ptlSrc.x      = prcl->left   + dx;
        ptlSrc.y      = prcl->top    + dy;

        // 'ppdev->pfnPutBits' takes only absolute coordinates, so add in the
        // off-screen bitmap offset here:

        rclDst.left   = prcl->left   + xOffset;
        rclDst.right  = prcl->right  + xOffset;
        rclDst.top    = prcl->top    + yOffset;
        rclDst.bottom = prcl->bottom + yOffset;

        ppdev->pfnPutBits(ppdev, psoSrc, &rclDst, &ptlSrc);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vXferScreenTo1bpp
*
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp
* bitmap.
*
\**************************************************************************/

#if defined(_X86_)

VOID vXferScreenTo1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       ulHwMix,            // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{
    LONG    cBpp;
    VOID*   pfnCompute;
    SURFOBJ soTmp;
    ULONG*  pulXlate;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    BYTE*   pjDst;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    LONG    cyTmpScans;
    LONG    cyThis;
    LONG    cyToGo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(TMP_BUFFER_SIZE >= PELS_TO_BYTES(ppdev->cxMemory),
                "Temp buffer has to be larger than widest possible scan");

    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // When the source is 8bpp or less, we find the forground colour
        // by searching the translate table for the only '1':

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        ulForeColor = pulXlate - pxlo->pulXlate;
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
    }

    // We use the temporary buffer to keep a copy of the source
    // rectangle:

    soTmp.pvScan0 = ppdev->pvTmpBuffer;

    do {
        // ptlSrc points to the upper-left corner of the screen rectangle
        // for the current batch:

        ptlSrc.x = prcl->left + (pptlSrc->x - prclDst->left);
        ptlSrc.y = prcl->top  + (pptlSrc->y - prclDst->top);

        // ppdev->pfnGetBits takes absolute coordinates for the source point:

        ptlSrc.x += ppdev->xOffset;
        ptlSrc.y += ppdev->yOffset;

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        cBpp = ppdev->cBpp;

        soTmp.lDelta = PELS_TO_BYTES(((prcl->right + 7L) & ~7L) - (prcl->left & ~7L));

        // Our temporary buffer, into which we read a copy of the source,
        // may be smaller than the source rectangle.  In that case, we
        // process the source rectangle in batches.
        //
        // cyTmpScans is the number of scans we can do in each batch.
        // cyToGo is the total number of scans we have to do for this
        // rectangle.
        //
        // We take the buffer size less four so that the right edge case
        // can safely read one dword past the end:

        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta;
        cyToGo     = prcl->bottom - prcl->top;

        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan");

        // Initialize variables that don't change within the batch loop:

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;

        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        if (cjMiddle < 0)
        {
            // The blt starts and ends in the same byte:

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
        }

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;
        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                // Delta from the end of the destination
                                //  to the start on the next scan, accounting
                                //  for 'left' and 'right' bytes

        lSrcDelta     = soTmp.lDelta - PELS_TO_BYTES(8 * (cjMiddle + 2));
                                // Compute source delta for special cases
                                //  like when cjMiddle gets bumped up to '0',
                                //  and to correct aligned cases

        do {
            // This is the loop that breaks the source rectangle into
            // manageable batches.

            cyThis  = cyTmpScans;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            rclTmp.bottom = cyThis;

            ppdev->pfnGetBits(ppdev, &soTmp, &rclTmp, &ptlSrc);

            ptlSrc.y += cyThis;         // Get ready for next batch loop

            _asm {
                mov     eax,ulForeColor     ;eax = foreground colour
                                            ;ebx = temporary storage
                                            ;ecx = count of middle dst bytes
                                            ;dl  = destination byte accumulator
                                            ;dh  = temporary storage
                mov     esi,soTmp.pvScan0   ;esi = source pointer
                mov     edi,pjDst           ;edi = destination pointer

                ; Figure out the appropriate compute routine:

                mov     ebx,cBpp
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

            Do_Left_Byte:
                call    pfnCompute
                and     dl,jLeftMask
                mov     dh,jNotLeftMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi
                mov     ecx,cjMiddle
                dec     ecx
                jl      short Do_Right_Byte

            Do_Middle_Bytes:
                call    pfnCompute
                mov     [edi],dl
                inc     edi
                dec     ecx
                jge     short Do_Middle_Bytes

            Do_Right_Byte:
                call    pfnCompute
                and     dl,jRightMask
                mov     dh,jNotRightMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi

                add     edi,lDstDelta
                add     esi,lSrcDelta
                dec     cyThis
                jnz     short Do_Left_Byte

                mov     pjDst,edi               ;save for next batch

                jmp     All_Done

            Compute_Destination_Byte_From_8bpp:
                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 7

                add     esi,8                   ;advance the source
                ret

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 7

                add     esi,16                  ;advance the source
                ret

            Compute_Destination_Byte_From_32bpp:
                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 7

                add     esi,32                  ;advance the source
                ret

            All_Done:
            }
        } while (cyToGo > 0);

        prcl++;
    } while (--c != 0);
}

#endif // i386

/******************************Public*Routine******************************\
* BOOL bPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*    ppdev;

    if (psoDst->dhsurf != NULL)
        ppdev = (PDEV*) psoDst->dhpdev;
    else
        ppdev = (PDEV*) psoSrc->dhpdev;

    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((4, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
        {
            DISPDBG((4, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

            if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                DISPDBG((4, "        << Foreground: %lx  Background: %lx",
                    pxlo->pulXlate[1], pxlo->pulXlate[0]));
            }
        }

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->dhsurf == NULL) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->dhsurf == NULL) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((4, "        << With xlate"));
            }
        }

        // If the rop4 requires a pattern, and it's a non-solid brush...

        if (((((rop4 >> 4) ^ (rop4)) & 0x0f0f) != 0) &&
            (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((4, "        << With brush -- Not created"));
            else
                DISPDBG((4, "        << With brush -- Created Ok"));
        }
    }
    #endif

    if (DIRECT_ACCESS(ppdev))
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;
        BOOL     b;
        HSURF    hsurfTmp;
        SURFOBJ* psoTmp;
        SIZEL    sizl;
        POINTL   ptlSrc;
        RECTL    rclTmp;
        RECTL    rclDst;

        if (ppdev->bLinearMode)
        {
            DSURF*  pdsurfDst;
            DSURF*  pdsurfSrc;
            OH*     pohSrc;
            OH*     pohDst;

            if (psoDst->dhsurf != NULL)
            {
                pdsurfDst       = (DSURF*) psoDst->dhsurf;
                psoDst          = ppdev->psoPunt;
                psoDst->pvScan0 = pdsurfDst->poh->pvScan0;

                if (psoSrc != NULL)
                {
                    pdsurfSrc = (DSURF*) psoSrc->dhsurf;
                    if ((pdsurfSrc != NULL) &&
                        (pdsurfSrc != pdsurfDst))
                    {
                        // If we're doing a BitBlt between different off-screen
                        // surfaces, we have to be sure to give GDI different
                        // surfaces, otherwise it may get confused when it has
                        // to do screen-to-screen blts with a translate...

                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        psoSrc          = ppdev->psoPunt2;
                        psoSrc->pvScan0 = pohSrc->pvScan0;

                        // Undo the source pointer adjustment we did earlier:

                        ptlSrc.x = pptlSrc->x + (pohDst->x - pohSrc->x);
                        ptlSrc.y = pptlSrc->y + (pohDst->y - pohSrc->y);
                        pptlSrc  = &ptlSrc;
                    }
                }
            }
            else
            {
                ppdev           = (PDEV*)  psoSrc->dhpdev;
                pdsurfSrc       = (DSURF*) psoSrc->dhsurf;
                psoSrc          = ppdev->psoPunt;
                psoSrc->pvScan0 = pdsurfSrc->poh->pvScan0;
            }

            ppdev->pfnBankSelectMode(ppdev, BANK_ON);
            return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                             pptlMsk, pbo, pptlBrush, rop4));
        }

        // We copy the original destination rectangle, and use that in every
        // GDI call-back instead of the original because sometimes GDI is
        // sneaky and points 'prclDst' to '&pco->rclBounds'.  Because we
        // modify 'rclBounds', that would affect 'prclDst', which we don't
        // want to happen:

        rclDst = *prclDst;

        if ((psoSrc == NULL) || (psoSrc->iType == STYPE_BITMAP))
        {
            ASSERTDD(psoDst->iType != STYPE_BITMAP,
                     "Dest should be the screen when given a DIB source");

            // Do a memory-to-screen blt:

            vBankStart(ppdev, &rclDst, pco, &bnk);

            b = TRUE;
            do {
                b &= EngBitBlt(bnk.pso, psoSrc, psoMsk, bnk.pco, pxlo,
                               &rclDst, pptlSrc, pptlMsk, pbo, pptlBrush,
                               rop4);
            } while (bBankEnum(&bnk));
        }
        else
        {
            b = FALSE;  // Assume failure

            // The screen is the source (it may be the destination too...)

            ptlSrc.x = pptlSrc->x + ppdev->xOffset;
            ptlSrc.y = pptlSrc->y + ppdev->yOffset;

            if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
            {
                // We have to intersect the destination rectangle with
                // the clip bounds if there is one (consider the case
                // where the app asked to blt a really, really big
                // rectangle from the screen -- prclDst would be really,
                // really big but pco->rclBounds would be the actual
                // area of interest):

                rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

                // Correspondingly, we have to offset the source point:

                ptlSrc.x += (rclDst.left - prclDst->left);
                ptlSrc.y += (rclDst.top - prclDst->top);
            }

            // We're now either going to do a screen-to-screen or screen-to-DIB
            // blt.  In either case, we're going to create a temporary copy of
            // the source.  (Why do we do this when GDI could do it for us?
            // GDI would create a temporary copy of the DIB for every bank
            // call-back!)

            sizl.cx = rclDst.right  - rclDst.left;
            sizl.cy = rclDst.bottom - rclDst.top;

            // Don't forget to convert from relative to absolute coordinates
            // on the source!  (vBankStart takes care of that for the
            // destination.)

            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;
            rclTmp.left   = 0;
            rclTmp.top    = 0;

            // GDI does guarantee us that the blt extents have already been
            // clipped to the surface boundaries (we don't have to worry
            // here about trying to read where there isn't video memory).
            // Let's just assert to make sure:

            ASSERTDD((ptlSrc.x >= 0) &&
                     (ptlSrc.y >= 0) &&
                     (ptlSrc.x + sizl.cx <= ppdev->cxMemory) &&
                     (ptlSrc.y + sizl.cy <= ppdev->cyMemory),
                     "Source rectangle out of bounds!");

            hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                               0,    // Let GDI choose ulWidth
                                               ppdev->iBitmapFormat,
                                               0,    // Don't need any options
                                               NULL);// Let GDI allocate

            if (hsurfTmp != 0)
            {
                psoTmp = EngLockSurface(hsurfTmp);

                if (psoTmp != NULL)
                {
                    ppdev->pfnGetBits(ppdev, psoTmp, &rclTmp, &ptlSrc);

                    if (psoDst->iType == STYPE_BITMAP)
                    {
                        // It was a Screen-to-DIB blt; now it's a DIB-to-DIB
                        // blt.  Note that the source point is (0, 0) in our
                        // temporary surface:

                        b = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo,
                                      &rclDst, (POINTL*) &rclTmp, pptlMsk,
                                      pbo, pptlBrush, rop4);
                    }
                    else
                    {
                        // It was a Screen-to-Screen blt; now it's a DIB-to-
                        // screen blt.  Note that the source point is (0, 0)
                        // in our temporary surface:

                        vBankStart(ppdev, &rclDst, pco, &bnk);

                        b = TRUE;
                        do {
                            b &= EngBitBlt(bnk.pso, psoTmp, psoMsk, bnk.pco,
                                           pxlo, &rclDst, (POINTL*) &rclTmp,
                                           pptlMsk, pbo, pptlBrush, rop4);

                        } while (bBankEnum(&bnk));
                    }

                    EngUnlockSurface(psoTmp);
                }

                EngDeleteSurface(hsurfTmp);
            }
        }

        return(b);
    }

#if !defined(_X86_)

    else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntBlt
        //
        // Here we handle a PuntBlt when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will be at least one bitmap
        // allocation and extra copy involved; there could be two if it's a
        // screen-to-screen operation.

        POINTL  ptlSrc;
        RECTL   rclDst;
        SIZEL   sizl;
        BOOL    bSrcIsScreen;
        HSURF   hsurfSrc;
        RECTL   rclTmp;
        BOOL    b;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        b = FALSE;          // For error cases, assume we'll fail

        rclDst = *prclDst;
        if (pptlSrc != NULL)
            ptlSrc = *pptlSrc;

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

            ptlSrc.x += (rclDst.left - prclDst->left);
            ptlSrc.y += (rclDst.top  - prclDst->top);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // We only need to make a copy from the screen if the source is
        // the screen, and the source is involved in the rop.  Note that
        // we have to check the rop before dereferencing 'psoSrc'
        // (because 'psoSrc' may be NULL if the source isn't involved):

        bSrcIsScreen = (((((rop4 >> 2) ^ (rop4)) & 0x3333) != 0) &&
                        (psoSrc->iType != STYPE_BITMAP));

        if (bSrcIsScreen)
        {
            // We need to create a copy of the source rectangle:

            hsurfSrc = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                               0, NULL);
            if (hsurfSrc == 0)
                goto Error_0;

            psoSrc = EngLockSurface(hsurfSrc);
            if (psoSrc == NULL)
                goto Error_1;

            rclTmp.left   = 0;
            rclTmp.top    = 0;
            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;

            // ppdev->pfnGetBits takes absolute coordinates for the source point:

            ptlSrc.x += ppdev->xOffset;
            ptlSrc.y += ppdev->yOffset;

            ppdev->pfnGetBits(ppdev, psoSrc, &rclTmp, &ptlSrc);

            // The source will now come from (0, 0) of our temporary source
            // surface:

            ptlSrc.x = 0;
            ptlSrc.y = 0;
        }

        if (psoDst->iType == STYPE_BITMAP)
        {
            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);
        }
        else
        {
            // We need to create a temporary work buffer.  We have to do
            // some fudging with the offsets so that the upper-left corner
            // of the (relative coordinates) clip object bounds passed to
            // GDI will be transformed to the upper-left corner of our
            // temporary bitmap.

            // The alignment doesn't have to be as tight as this at 16bpp
            // and 32bpp, but it won't hurt:

            lDelta = PELS_TO_BYTES(((rclDst.right + 3) & ~3L) -
                                   ((rclDst.left) & ~3L));

            // We're actually only allocating a bitmap that is 'sizl.cx' x
            // 'sizl.cy' in size:

            pjBits = EngAllocMem(0, lDelta * sizl.cy, ALLOC_TAG);
            if (pjBits == NULL)
                goto Error_2;

            // We now adjust the surface's 'pvScan0' so that when GDI thinks
            // it's writing to pixel (rclDst.top, rclDst.left), it will
            // actually be writing to the upper-left pixel of our temporary
            // bitmap:

            pjScan0 = pjBits - (rclDst.top * lDelta)
                             - (PELS_TO_BYTES(rclDst.left & ~3L));

            ASSERTDD((((ULONG_PTR)pjScan0) & 3) == 0,
                    "pvScan0 must be dword aligned!");

            // The checked build of GDI sometimes checks on blts that
            // prclDst->right <= pso->sizl.cx, so we lie to it about
            // the size of our bitmap:

            sizl.cx = rclDst.right;
            sizl.cy = rclDst.bottom;

            hsurfDst = (HSURF) EngCreateBitmap(
                        sizl,                   // Bitmap covers rectangle
                        lDelta,                 // Use this delta
                        ppdev->iBitmapFormat,   // Same colour depth
                        BMF_TOPDOWN,            // Must have a positive delta
                        pjScan0);               // Where (0, 0) would be

            if ((hsurfDst == 0) ||
                (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                goto Error_3;

            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
                goto Error_4;

            // Make sure that the rectangle we Get/Put from/to the screen
            // is in absolute coordinates:

            rclScreen.left   = rclDst.left   + ppdev->xOffset;
            rclScreen.right  = rclDst.right  + ppdev->xOffset;
            rclScreen.top    = rclDst.top    + ppdev->yOffset;
            rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

            // It would be nice to get a copy of the destination rectangle
            // only when the ROP involves the destination (or when the source
            // is an RLE), but we can't do that.  If the brush is truly NULL,
            // GDI will immediately return TRUE from EngBitBlt, without
            // modifying the temporary bitmap -- and we would proceed to
            // copy the uninitialized temporary bitmap back to the screen.

            ppdev->pfnGetBits(ppdev, psoDst, &rclDst, (POINTL*) &rclScreen);

            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

            ppdev->pfnPutBits(ppdev, psoDst, &rclScreen, (POINTL*) &rclDst);

            EngUnlockSurface(psoDst);

        Error_4:

            EngDeleteSurface(hsurfDst);

        Error_3:

            EngFreeMem(pjBits);
        }

        Error_2:

        if (bSrcIsScreen)
        {
            EngUnlockSurface(psoSrc);

        Error_1:

            EngDeleteSurface(hsurfSrc);
        }

        Error_0:

        return(b);
    }

#endif

}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    OH*             poh;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    BYTE            rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;        // Realized brush or solid colour
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;
    BOOL            bRet;
    XLATECOLORS     xlc;
    XLATEOBJ        xlo;

    bRet = TRUE;                // Assume success

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre", so we handle them
        // as quickly as possible:

        ASSERTDD(pdsurfDst != NULL,
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt == DT_SCREEN)
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            poh = pdsurfDst->poh;
            ppdev->xOffset  = poh->x;
            ppdev->yOffset  = poh->y;
            ppdev->xyOffset = poh->xy;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

            // Fill_It:

                pfnFill = ppdev->pfnFillSolid;   // Default to solid fill

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)
                {
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):

                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {

                        if (ppdev->cBpp > 3)
                        {
                            // [HWBUG]
                            goto Punt_It;
                        }

                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                goto Punt_It;
                            }
                        }
                        pfnFill = ppdev->pfnFillPat;
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);

                    } while (bMore);
                    goto All_Done;
                }
            }
        }
    }

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if ((psoSrc != NULL) && (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                ppdev = (PDEV*) psoSrc->dhpdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            psoSrc = pdsurfSrc->pso;

            // Handle the case where the source is a DIB DFB and the
            // destination is a regular bitmap:

            if (psoDst->dhsurf == NULL)
                goto EngBitBlt_It;

        }
    }

Continue_It:

    if (pdsurfDst != NULL)
    {
        if (pdsurfDst->dt == DT_DIB)
        {
            psoDst = pdsurfDst->pso;

            // If the destination is a DIB, we can only handle this
            // call if the source is not a DIB:

            if ((psoSrc == NULL) || (psoSrc->dhsurf == NULL))
                goto EngBitBlt_It;
        }
    }

    // At this point, we know that either the source or the destination is
    // not a DIB.  Check for a DFB to screen, DFB to DFB, or screen to DFB
    // case:

    if ((psoSrc != NULL) &&
        (psoDst->dhsurf != NULL) &&
        (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD(pdsurfSrc->dt == DT_SCREEN, "Expected screen source");
        ASSERTDD(pdsurfDst->dt == DT_SCREEN, "Expected screen destination");

        ptlSrc.x = pptlSrc->x - (pdsurfDst->poh->x - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y - (pdsurfDst->poh->y - pdsurfSrc->poh->y);

        pptlSrc  = &ptlSrc;
    }

    if (psoDst->dhsurf != NULL)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        ppdev     = (PDEV*)  psoDst->dhpdev;

        ppdev->xOffset  = pdsurfDst->poh->x;
        ppdev->yOffset  = pdsurfDst->poh->y;
        ppdev->xyOffset = pdsurfDst->poh->xy;
    }
    else
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        ppdev     = (PDEV*)  psoSrc->dhpdev;

        ppdev->xOffset  = pdsurfSrc->poh->x;
        ppdev->yOffset  = pdsurfSrc->poh->y;
        ppdev->xyOffset = pdsurfSrc->poh->xy;
    }

    if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (BYTE) rop4;     // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (psoDst->dhsurf != NULL)
        {
            // The destination is the screen:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // The ROP3 doesn't require a pattern:

                if (psoSrc->dhsurf == NULL)
                {
                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    if (HOST_XFERS_DISABLED(ppdev))
                    {
                        goto Punt_It;
                    }

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        if (rop3 == 0xcc)
                        {
                            //
                            // 542x and 5446 family chips will hang when doing
                            // monochrome expansion. We have seen this problem
                            // extremely infrequently in stress testing. Often
                            // on 32x16 blts with the 2x chips. We were unable
                            // to programmatically reproduce it with the exact
                            // machine that was causing the problem. We even
                            // wrote some testing program to excessively test
                            // this function while running stress. The test
                            // run several weeks and we couldn't repro it.
                            // 
                            // So, for the sake of boosting stress success rate,
                            // we just ask GDI do the work for us 
                            //
                            if ( ( ppdev->flCaps & CAPS_IS_542x )   // 542x
                               ||( ppdev->ulChipID == 0xB8) )       // 5446
                            {
                                //
                                // For chips like 542x, 5446, it will cause
                                // hang from time to time when doing stress
                                // testing. So we have to let GDI to do it
                                //
                                goto Punt_It;
                            }
                            else
                            {
                                // [HWBUG]

                                // This driver can't handle a monochrome
                                // expansion with a foreground rop other
                                // than SRCCOPY.  The reason is that we
                                // separately blt the opaque part first and
                                // then blt the foreground over it.  The
                                // destination bits are no longer valid to
                                // be used in a rop requiring them.

                                pfnXfer = ppdev->pfnXfer1bpp;
                                goto Xfer_It;
                            }// if 542x or 5446 chips
                        }
                    }
                    else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
                             ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                    {
                        if ((rop3 & 0xf) != 0xc)
                        {
                            pfnXfer = ppdev->pfnXferNative;
                        }
                        else
                        {
                            // Plain SRCCOPY blts will be somewhat faster
                            // if we go through the memory aperture:

                            pfnXfer = vXferNativeSrccopy;
                        }
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == BMF_4BPP) &&
                             (ppdev->iBitmapFormat == BMF_8BPP))
                    {
                        pfnXfer = ppdev->pfnXfer4bpp;
                        goto Xfer_It;
                    }
                }
                else // psoSrc->dhsurf != NULL
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        if (jClip == DC_TRIVIAL)
                        {
                            (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, rop4,
                                                pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                (ppdev->pfnCopyBlt)(ppdev, 1, &rcl, rop4,
                                                    pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    (ppdev->pfnCopyBlt)(ppdev, c, ce.arcl,
                                            rop4, pptlSrc, prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
            else if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                if (HOST_XFERS_DISABLED(ppdev))
                {
                    goto Punt_It;
                }

                if ((rop4 == 0xE2E2) &&
                    (pbo->iSolidColor != 0xffffffff) &&
                    //pxlo must be non NULL since the rop is E2E2
                    (pxlo->pulXlate[0] == 0) &&
                    (pxlo->pulXlate[1] == (ULONG)((1<<PELS_TO_BYTES(8)) - 1)))
                {
                    if ( (ppdev->flCaps & CAPS_IS_542x)
                       ||(ppdev->ulChipID == 0xB8) )
                    {
                        //
                        // For chips like 542x, 5446, it will cause
                        // hang from time to time when doing stress
                        // testing. We have seen this problem
                        // extremely infrequently in stress testing. Often
                        // on 32x16 blts with the 2x chips. We were unable
                        // to programmatically reproduce it with the exact
                        // machine that was causing the problem. We even
                        // wrote some testing program to excessively test
                        // this function while running stress. The test
                        // run several weeks and we couldn't repro it.
                        //
                        // So, for the sake of boosting stress success rate,
                        // we just ask GDI do the work for us 
                        //
                        goto Punt_It;
                    }
                    else
                    {
                        //
                        // A BitBlt with the rop E2E2 (DSPDxax), a monochrome
                        // source, a foreground color of white, and a background
                        //color of black is equivalent to a monochrome expansion
                        // with transparency.  All ones in the source expand to
                        //the brush color, and all zeros in the source expand to
                        // the destination color.
                        //

                        xlo.pulXlate   = (ULONG*) &xlc;
                        xlc.iForeColor = pbo->iSolidColor;
                        xlc.iBackColor = 0;
                        pxlo = &xlo;
                        rop4 = 0xCCAA;

                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }// if 542x or 5446 chips
                }
            }
        }
        else
        {
            #if defined(_X86_)
            {
                // We special case screen to monochrome blts because they
                // happen fairly often.  We only handle SRCCOPY rops and
                // monochrome destinations (to handle a true 1bpp DIB
                // destination, we would have to do near-colour searches
                // on every colour; as it is, the foreground colour gets
                // mapped to '1', and everything else gets mapped to '0'):

                if ((psoDst->iBitmapFormat == BMF_1BPP) &&
                    (rop3 == 0xcc) &&
                    (pxlo->flXlate & XO_TO_MONO) &&
                    (ppdev->iBitmapFormat != BMF_24BPP))
                {
                    pfnXfer = vXferScreenTo1bpp;
                    psoSrc  = psoDst;               // A misnomer, I admit
                    goto Xfer_It;
                }
            }
            #endif // i386
        }
    }

#if 0
    // [WORK] - Implement transparent brushes and then uncomment this block
    //          and the Fill_It label above.

    else if ((psoMsk == NULL) &&
             (rop4 & 0xff00) == (0xaa00) &&
             ((((rop4 >> 2) ^ (rop4)) & 0x33) == 0))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):

        rop3 = (BYTE) rop4;

        goto Fill_It;
    }
#endif

    // Just fall through to Punt_It...

Punt_It:

    bRet = bPuntBlt(psoDst,
                    psoSrc,
                    psoMsk,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMsk,
                    pbo,
                    pptlBrush,
                    rop4);
    goto All_Done;

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    bRet = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

All_Done:
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
* It's faster to do straight SRCCOPY bitblt's through the memory
* aperture than to use the data transfer register; as such, this
* routine is the logical place to put this special case.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    RECTL   rcl;
    POINTL  ptl;
    OH*     pohSrc;
    OH*     pohDst;

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        if (psoDst->dhsurf != NULL)
        {
            // We know the destination is either a DFB or the screen:

            ppdev     = (PDEV*)  psoDst->dhpdev;
            pdsurfDst = (DSURF*) psoDst->dhsurf;

            // See if the source is a plain DIB:

            if (psoSrc->dhsurf != NULL)
            {
                pdsurfSrc = (DSURF*) psoSrc->dhsurf;

                // Make sure the destination is really the screen or an
                // off-screen DFB (i.e., not a DFB that we've converted
                // to a DIB):

                if (pdsurfDst->dt == DT_SCREEN)
                {
                    ASSERTDD(psoSrc->dhsurf != NULL, "Can't be a DIB");

                    if (pdsurfSrc->dt == DT_SCREEN)
                    {

                    Screen_To_Screen:

                        //////////////////////////////////////////////////////
                        // Screen-to-screen

                        ASSERTDD((psoSrc->dhsurf != NULL) &&
                                 (pdsurfSrc->dt == DT_SCREEN)    &&
                                 (psoDst->dhsurf != NULL) &&
                                 (pdsurfDst->dt == DT_SCREEN),
                                 "Should be a screen-to-screen case");

                        // pfnCopyBlt takes relative coordinates (relative
                        // to the destination surface, that is), so we have
                        // to change the start point to be relative to the
                        // destination surface too:


                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
                        ptl.y = pptlSrc->y - (pohDst->y - pohSrc->y);

                        ppdev->xOffset  = pohDst->x;
                        ppdev->yOffset  = pohDst->y;
                        ppdev->xyOffset = pohDst->xy;

                        (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, 0xcccc, &ptl,
                            prclDst);

                        return(TRUE);
                    }
                    else // (pdsurfSrc->dt != DT_SCREEN)
                    {
                        // Ah ha, the source is a DFB that's really a DIB.

                        ASSERTDD(psoDst->dhsurf != NULL,
                                "Destination can't be a DIB here");

                        /////////////////////////////////////////////////////
                        // Put It Back Into Off-screen?
                        //
                        // We take this opportunity to decide if we want to
                        // put the DIB back into off-screen memory.  This is
                        // a pretty good place to do it because we have to
                        // copy the bits to some portion of the screen,
                        // anyway.  So we would incur only an extra screen-to-
                        // screen blt at this time, much of which will be
                        // over-lapped with the CPU.
                        //
                        // The simple approach we have taken is to move a DIB
                        // back into off-screen memory only if there's already
                        // room -- we won't throw stuff out to make space
                        // (because it's tough to know what ones to throw out,
                        // and it's easy to get into thrashing scenarios).
                        //
                        // Because it takes some time to see if there's room
                        // in off-screen memory, we only check one in
                        // HEAP_COUNT_DOWN times if there's room.  To bias
                        // in favour of bitmaps that are often blt, the
                        // counters are reset every time any space is freed
                        // up in off-screen memory.  We also don't bother
                        // checking if no space has been freed since the
                        // last time we checked for this DIB.

                        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                        {
                            if (--pdsurfSrc->cBlt == 0)
                            {
                                if (bMoveDibToOffscreenDfbIfRoom(ppdev,
                                                                 pdsurfSrc))
                                    goto Screen_To_Screen;
                            }
                        }
                        else
                        {
                            // Some space was freed up in off-screen memory,
                            // so reset the counter for this DFB:

                            pdsurfSrc->iUniq = ppdev->iHeapUniq;
                            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                        }

                        // Since the destination is definitely the screen,
                        // we don't have to worry about creating a DIB to
                        // DIB copy case (for which we would have to call
                        // EngCopyBits):

                        psoSrc = pdsurfSrc->pso;

                        goto DIB_To_Screen;
                    }
                }
                else // (pdsurfDst->dt != DT_SCREEN)
                {
                    // Because the source is not a DIB, we don't have to
                    // worry about creating a DIB to DIB case here (although
                    // we'll have to check later to see if the source is
                    // really a DIB that's masquerading as a DFB...)

                    ASSERTDD(psoSrc->dhsurf != NULL,
                             "Source can't be a DIB here");

                    psoDst = pdsurfDst->pso;

                    goto Screen_To_DIB;
                }
            }
            else if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
            {
                // Make sure the destination is really the screen:

                if (pdsurfDst->dt == DT_SCREEN)
                {

                DIB_To_Screen:

                    //////////////////////////////////////////////////////
                    // DIB-to-screen

                    ASSERTDD((psoDst->dhsurf != NULL) &&
                             (pdsurfDst->dt == DT_SCREEN)    &&
                             (psoSrc->dhsurf == NULL) &&
                             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a DIB-to-screen case");

                    // ppdev->pfnPutBits takes absolute screen coordinates, so
                    // we have to muck with the destination rectangle:

                    pohDst = pdsurfDst->poh;

                    rcl.left   = prclDst->left   + pohDst->x;
                    rcl.right  = prclDst->right  + pohDst->x;
                    rcl.top    = prclDst->top    + pohDst->y;
                    rcl.bottom = prclDst->bottom + pohDst->y;

                    // We use the memory aperture to do the transfer,
                    // because that is supposed to be faster for SRCCOPY
                    // blts than using the data-transfer register:

                    ppdev->pfnPutBits(ppdev, psoSrc, &rcl, pptlSrc);
                    return(TRUE);
                }
            }
        }
        else // (psoDst->dhsurf == NULL)
        {

        Screen_To_DIB:

            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            ppdev     = (PDEV*)  psoSrc->dhpdev;

            if (psoDst->iBitmapFormat == ppdev->iBitmapFormat)
            {
                if (pdsurfSrc->dt == DT_SCREEN)
                {
                    //////////////////////////////////////////////////////
                    // Screen-to-DIB

                    ASSERTDD((psoSrc->dhsurf != NULL) &&
                             (pdsurfSrc->dt == DT_SCREEN)    &&
                             (psoDst->dhsurf == NULL) &&
                             (psoDst->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a screen-to-DIB case");

                    // ppdev->pfnGetBits takes absolute screen coordinates, so we have
                    // to muck with the source point:

                    pohSrc = pdsurfSrc->poh;

                    ptl.x = pptlSrc->x + pohSrc->x;
                    ptl.y = pptlSrc->y + pohSrc->y;

                    ppdev->pfnGetBits(ppdev, psoDst, prclDst, &ptl);
                    return(TRUE);
                }
                else
                {
                    // The source is a DFB that's really a DIB.  Since we
                    // know that the destination is a DIB, we've got a DIB
                    // to DIB operation, and should call EngCopyBits:

                    psoSrc = pdsurfSrc->pso;
                    goto EngCopyBits_It;
                }
            }
        }
    }

    // We can't call DrvBitBlt if we've accidentally converted both
    // surfaces to DIBs, because it isn't equipped to handle it:

    ASSERTDD((psoSrc->dhsurf != NULL) ||
             (psoDst->dhsurf != NULL),
             "Accidentally converted both surfaces to DIBs");

    /////////////////////////////////////////////////////////////////
    // A DrvCopyBits is after all just a simplified DrvBitBlt:

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0x0000CCCC));

EngCopyBits_It:

    ASSERTDD((psoDst->dhsurf == NULL) &&
             (psoSrc->dhsurf == NULL),
             "Both surfaces should be DIBs to call EngCopyBits");

    return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\ddraw.c ===
/******************************************************************************\
*
* Copyright (c) 1996-1997  Microsoft Corporation.
* Copyright (c) 1996-1997  Cirrus Logic, Inc.
*
* Module Name:
*
*    D    D    R    A    W  .  C
*
*
* Implements all the DirectDraw components for the driver.
*
*
* $Log:   S:/projects/drivers/ntsrc/display/ddraw.c_v  $
 *
 *    Rev 1.14   07 Apr 1997 11:37:02   PLCHU
 *
 *
 *    Rev 1.13   Apr 03 1997 15:38:44   unknown
 *
*
 *
 *    Rev 1.10   Jan 14 1997 15:15:12   unknown
 * Add new double clock detecting method.
 *
 *    Rev 1.8   Jan 08 1997 11:23:34   unknown
 * Add 2x clock support and double scan line counter support
 *
 *    Rev 1.7   Dec 17 1996 18:31:12   unknown
 * Update the bandwidth equation again.
 *
 *    Rev 1.6   Dec 13 1996 12:15:04   unknown
 * update bandwith equation.
 *
 *    Rev 1.5   Dec 12 1996 11:09:52   unknown
 * Add double scan line counter support
 *
 *    Rev 1.5   Dec 12 1996 11:02:12   unknown
 * Add double scan line counter support.
 *
 *    Rev 1.5   Nov 26 1996 14:29:58   unknown
 * Turn off the video window before the moving and then turn it on.
 *
 *    Rev 1.4   Nov 25 1996 14:39:32   unknown
 * Fixed AVI file playback and 16bpp transparent Blt bugs.
 *
 *    Rev 1.4   Nov 18 1996 13:58:58   JACKIEC
 *
*
*    Rev 1.3   Nov 07 1996 16:47:56   unknown
*
*
*    Rev 1.2   Oct 16 1996 14:41:04   unknown
* NT 3.51 does not have DDRAW support, So turn off overlay.h in NT 3.51
*
*    Rev 1.1   Oct 10 1996 15:36:28   unknown
*
*
*    Rev 1.10   12 Aug 1996 16:51:04   frido
* Added NT 3.5x/4.0 auto detection.
*
*    Rev 1.9   06 Aug 1996 18:37:12   frido
* DirectDraw works! Video mapping is the key!
*
*    Rev 1.8   24 Jul 1996 14:38:44   frido
* Cleaned up font cache after DirectDraw is done.
*
*    Rev 1.7   24 Jul 1996 14:30:04   frido
* Added a call to destroy all cached fonts to make more room.
*
*    Rev 1.6   20 Jul 1996 00:00:44   frido
* Fixed filling of DirectDraw in 24-bpp.
* Changed off-screen alignment to 4 bytes.
* Added compile switch to manage DirectDraw support in 24-bpp.
*
*    Rev 1.5   16 Jul 1996 18:55:22   frido
* Fixed DirectDraw in 24-bpp mode.
*
*    Rev 1.4   15 Jul 1996 18:03:22   frido
* Changed CP_MM_DST_ADDR to CP_MM_DST_ADDR_ABS.
*
*    Rev 1.3   15 Jul 1996 10:58:28   frido
* Changed back to S3 base.
*
*    Rev 1.1   09 Jul 1996 14:52:30   frido
* Only support chips 5436 and 5446.
*
*    Rev 1.0   03 Jul 1996 13:53:02   frido
* Ported from S3 DirectDraw code.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
*
* chu01 11-17-96  For 24-bpp, aligned destination boundary/size values are
*                 wrong.  Refer to PDR#7312.
*
* sge01 11-19-96  Write CR37 at last For 5480.
*
*
* sge02 11-21-96  We have to set the Color Expand Width even in
*                 non-expand transparency mode.
*
*
* sge03 12-04-96  Add double scan line counter support .
*
* sge04 12-13-96  Change bandwidth for 5446BE and later chips.
*
* sge05 01-07-97  Use dword align for double clock mode.
*
* chu02 01-08-97  Disable ActiveX/Active Movie Player for interlaced modes.
*                 Refer to PDR#7312, 7866.
*
* jc01  10-18-96  Port Microsoft recent change.
* tao1  10-21-96  Added direct draw support for CL-GD7555.
* myf21 11-21-96  Change CAPS_IS_7555 to check ppdev->ulChipID
*
* sge06 01-27-97  Extend VCLK Denominator to 7 bits from 5 bits.
* sge07 02-13-97  Use replication when in 1280x1024x8 mode.
* myf31 02-24-97  Fixed enable HW Video, panning scrolling enable,screen move
*                 video window have follow moving
* chu03 03-26-97  Bandwidth eqution for the CL-GD5480.
* myf33 :03-31-97 : Fixed PDR #8709, read true VCLK in getVCLK()
*                   & panning scrolling enable, support HW Video
* chu04 04-02-97  No matterwhat color depth is, always turn on COLORKEY and
*                 SRCBLT in the DD/DD colorkey capabilities for the 5480.
*
\******************************************************************************/

#include "PreComp.h"
#if DIRECTDRAW
#include "overlay.h"

LONG MIN_OLAY_WIDTH = 4;

//#define ONLY54x6    // Comment this line out if DirectDraw should be 'generic'

// The next flag controls DirectDraw support in 24-bpp.
#define DIRECTX_24        2    // 0 - no support
                               // 1 - blt support, no heap (flip)
                               // 2 - full support

//
// Some handy macros.
//
#define BLT_BUSY(ppdev, pjBase)  (CP_MM_ACL_STAT(ppdev, pjBase) & 0x01)
#ifdef ONLY54x6
#define BLT_READY(ppdev, pjBase) (!(CP_MM_ACL_STAT(ppdev, pjBase) & 0x10))
#else
#define BLT_READY(ppdev, pjBase) (!(CP_MM_ACL_STAT(ppdev, pjBase) &     \
                                 ((ppdev->flCaps & CAPS_AUTOSTART) ? 0x10 : 0x01)))
#endif

#define NUM_VBLANKS_TO_MEASURE   1
#define NUM_MEASUREMENTS_TO_TAKE 8


/******************************Public*Routine******************************\
*
* DWORD dwGetPaletteEntry
*
\**************************************************************************/

DWORD dwGetPaletteEntry(
PDEV* ppdev,
DWORD iIndex)
{
    BYTE*   pjPorts;
    DWORD   dwRed;
    DWORD   dwGreen;
    DWORD   dwBlue;

    pjPorts = ppdev->pjPorts;

    CP_OUT_BYTE(pjPorts, DAC_PEL_READ_ADDR, iIndex);

    dwRed   = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
    dwGreen = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
    dwBlue  = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);

    return((dwRed << 16) | (dwGreen << 8) | (dwBlue));
}

/******************************Public*Routine******************************\
* VOID vGetDisplayDuration
*
* Get the length, in EngQueryPerformanceCounter() ticks, of a refresh cycle.
*
* If we could trust the miniport to return back and accurate value for
* the refresh rate, we could use that.  Unfortunately, our miniport doesn't
* ensure that it's an accurate value.
*
\**************************************************************************/

VOID vGetDisplayDuration(
PDEV* ppdev)
{
    BYTE*    pjPorts;
    DWORD    dwTemp;
    LONG     i, j;
    LONGLONG li;
    LONGLONG liMin;
    LONGLONG aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

    pjPorts = ppdev->pjPorts;

    memset(&ppdev->flipRecord, 0, sizeof(ppdev->flipRecord));

    // Warm up EngQUeryPerformanceCounter to make sure it's in the working set.
    EngQueryPerformanceCounter(&li);

    // Unfortunately, since NT is a proper multitasking system, we can't just
    // disable interrupts to take an accurate reading. We also can't do anything
    // so goofy as dynamically change our thread's priority to real-time.
    //
    // So we just do a bunch of short measurements and take the minimum.
    //
    // It would be 'okay' if we got a result that's longer than the actual
    // VBlank cycle time -- nothing bad would happen except that the app would
    // run a little slower. We don't want to get a result that's shorter than
    // the actual VBlank cycle time -- that could cause us to start drawing over
    // a frame before the Flip has occured.

    while (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
        ;
    while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
        ;

    for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        // We're at the start of the VBlank active cycle!
        EngQueryPerformanceCounter(&aliMeasurement[i]);

        // Okay, so life in a multi-tasking environment isn't all that simple.
        // What if we had taken a context switch just before the above
        // EngQueryPerformanceCounter call, and now were half way through the
        // VBlank inactive cycle? Then we would measure only half a VBlank
        // cycle, which is obviously bad. The worst thing we can do is get a
        // time shorter than the actual VBlank cycle time.
        //
        // So we solve this by making sure we're in the VBlank active time
        // before and after we query the time. If it's not, we'll sync up to the
        // next VBlank (it's okay to measure this period -- it will be
        // guaranteed to be longer than the VBlank cycle and will likely be
        // thrown out when we select the minimum sample). There's a chance that
        // we'll take a context switch and return just before the end of the
        // active VBlank time -- meaning that the actual measured time would be
        // less than the true amount -- but since the VBlank is active less than
        // 1% of the time, this means that we would have a maximum of 1% error
        // approximately 1% of the times we take a context switch. An acceptable
        // risk.
        //
        // This next line will cause us wait if we're no longer in the VBlank
        // active cycle as we should be at this point.
        while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
            ;

        for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
        {
            while (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
                ;
            while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
                ;
        }
    }

    EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

    // Use the minimum.
    liMin = aliMeasurement[1] - aliMeasurement[0];

    DISPDBG((2, "Refresh count: %li - %li", 1, (ULONG) liMin));

    for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        li = aliMeasurement[i] - aliMeasurement[i - 1];

        DISPDBG((2, "               %li - %li", i, (ULONG) li));

        if (li < liMin)
        {
            liMin = li;
        }
    }

    // Round the result:

    ppdev->flipRecord.liFlipDuration =
        (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

    DISPDBG((2, "Frequency %li.%03li Hz",
             (ULONG) (EngQueryPerformanceFrequency(&li),
                      li / ppdev->flipRecord.liFlipDuration),
             (ULONG) (EngQueryPerformanceFrequency(&li),
                      ((li * 1000) / ppdev->flipRecord.liFlipDuration) % 1000)));

    ppdev->flipRecord.liFlipTime = aliMeasurement[NUM_MEASUREMENTS_TO_TAKE];
    ppdev->flipRecord.bFlipFlag  = FALSE;
    ppdev->flipRecord.fpFlipFrom = 0;

    // sge
    // Get the line on which the VSYNC occurs
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x7);
    dwTemp = (DWORD)CP_IN_BYTE(pjPorts, CRTC_DATA);
    ppdev->dwVsyncLine = ((dwTemp & 0x80) << 2);
    ppdev->dwVsyncLine |= ((dwTemp & 0x04) << 6);
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x10);
    ppdev->dwVsyncLine |= CP_IN_BYTE(pjPorts, CRTC_DATA);
}

/******************************Public*Routine******************************\
* HRESULT dwUpdateFlipStatus
*
* Checks and sees if the most recent flip has occurred.
*
\**************************************************************************/

HRESULT UpdateFlipStatus(PDEV* ppdev, FLATPTR fpVidMem)
{
    BYTE*    pjPorts;
    LONGLONG liTime;

    pjPorts = ppdev->pjPorts;

    if ((ppdev->flipRecord.bFlipFlag) &&
//#jc01        ((fpVidMem == 0) || (fpVidMem == ppdev->flipRecord.fpFlipFrom)))
        ((fpVidMem == 0xffffffff) || (fpVidMem == ppdev->flipRecord.fpFlipFrom))) //#jc01
    {
#if 0 // sge use scanline
        if (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
        {
            if (ppdev->flipRecord.bWasEverInDisplay)
            {
                ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;
            }
        }
        else if (!(CP_IN_BYTE(pjPorts, STATUS_1) & DISPLAY_MODE_INACTIVE))
        {
            if( ppdev->flipRecord.bHaveEverCrossedVBlank )
            {
                ppdev->flipRecord.bFlipFlag = FALSE;
                return(DD_OK);
            }
            ppdev->flipRecord.bWasEverInDisplay = TRUE;
        }

        EngQueryPerformanceCounter(&liTime);

        if (liTime - ppdev->flipRecord.liFlipTime
                                <= ppdev->flipRecord.liFlipDuration)
        {
            return(DDERR_WASSTILLDRAWING);
        }
#else
        /*
        * if we aren't in the vertical retrace, we can use the scanline
        * to help decide on what to do
        */
        if( !(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE) )
        {
            if( ppdev->flipRecord.bHaveEverCrossedVBlank == FALSE )
            {
                ppdev->flipRecord.bWasEverInDisplay = TRUE;
                if( GetCurrentVLine(ppdev) >= ppdev->flipRecord.dwFlipScanLine )
                {
                    EngQueryPerformanceCounter(&liTime);

                    if (liTime - ppdev->flipRecord.liFlipTime
                                        <= ppdev->flipRecord.liFlipDuration)
                    {
                        return(DDERR_WASSTILLDRAWING);
                    }
                }
            }
        }
        /*
        * in the vertical retrace, scanline is useless
        */
        else
        {
            if( ppdev->flipRecord.bWasEverInDisplay )
            {
                ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;
//                return DD_OK;
            }
            EngQueryPerformanceCounter(&liTime);
            if (liTime - ppdev->flipRecord.liFlipTime
                                <= ppdev->flipRecord.liFlipDuration)
            {
                return(DDERR_WASSTILLDRAWING);
            }
        }
#endif // endif use scanline
        ppdev->flipRecord.bFlipFlag = FALSE;
    }

    return(DD_OK);
}

/******************************Public*Routine******************************\
* DWORD DdBlt
*
\**************************************************************************/

DWORD DdBlt(
PDD_BLTDATA lpBlt)
{
    PDD_SURFACE_GLOBAL srcSurf;
    PDD_SURFACE_GLOBAL dstSurf;
    PDEV*              ppdev;
    BYTE*              pjBase;
    DWORD              dstOffset;
    DWORD              dstPitch;
    DWORD              dstX, dstY;
    DWORD              dwFlags;
    DWORD              width, height;
    DWORD              srcOffset;
    DWORD              srcPitch;
    DWORD              srcX, srcY;
    ULONG              ulBltCmd;
    DWORD              xExt, yExt;
    DWORD              xDiff, yDiff;

    ppdev   = lpBlt->lpDD->dhpdev;
    pjBase  = ppdev->pjBase;
    dstSurf = lpBlt->lpDDDestSurface->lpGbl;

    // Is a flip in progress?
    if (UpdateFlipStatus(ppdev, dstSurf->fpVidMem) != DD_OK)
    {
        lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    dwFlags = lpBlt->dwFlags;

    if (dwFlags & DDBLT_ASYNC)
    {
        // If async, then only work if we won't have to wait on the accelerator
        // to start the command.
        if (!BLT_READY(ppdev, pjBase))
        {
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
               return(DDHAL_DRIVER_HANDLED);
        }
    }

    DISPDBG((2, "DdBlt Entered"));

    // Calculate destination parameters.
    dstX      = lpBlt->rDest.left;
    dstY      = lpBlt->rDest.top;
    width     = PELS_TO_BYTES(lpBlt->rDest.right - dstX) - 1;
    height    = (lpBlt->rDest.bottom - dstY) - 1;
    dstPitch  = dstSurf->lPitch;
    dstOffset = (DWORD)(dstSurf->fpVidMem + PELS_TO_BYTES(dstX)
                    + (dstY * dstPitch));

    // Color fill?
    if (dwFlags & DDBLT_COLORFILL)
    {
        ULONG ulBltMode = ENABLE_COLOR_EXPAND
                        | ENABLE_8x8_PATTERN_COPY
                        | ppdev->jModeColor;

        // Wait for the accelerator.
        while (!BLT_READY(ppdev, pjBase))
            ;

        // Program bitblt engine.
        CP_MM_ROP(ppdev, pjBase, HW_P);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, dstPitch);
        CP_MM_BLT_MODE(ppdev, pjBase, ulBltMode);
        CP_MM_FG_COLOR(ppdev, pjBase, lpBlt->bltFX.dwFillColor);
        if (ppdev->flCaps & CAPS_AUTOSTART)
        {
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
        }
        else
        {
            CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
        }
        CP_MM_XCNT(ppdev, pjBase, width);
        CP_MM_YCNT(ppdev, pjBase, height);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, dstOffset);
        CP_MM_START_BLT(ppdev, pjBase);

        lpBlt->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }


    // We specified with Our ddCaps.dwCaps that we handle a limited number of
    // commands, and by this point in our routine we've handled everything
    // except DDBLT_ROP. DirectDraw and GDI shouldn't pass us anything else;
    // we'll assert on debug builds to prove this.
    ASSERTDD((dwFlags & DDBLT_ROP) && (lpBlt->lpDDSrcSurface),
        "Expected dwFlags commands of only DDBLT_ASYNC and DDBLT_COLORFILL");

    // Get offset, width, and height for source.
    srcSurf   = lpBlt->lpDDSrcSurface->lpGbl;
    srcX      = lpBlt->rSrc.left;
    srcY      = lpBlt->rSrc.top;
    srcPitch  = srcSurf->lPitch;
    srcOffset = (DWORD)(srcSurf->fpVidMem + PELS_TO_BYTES(srcX)
                    + (srcY * srcPitch));

    /*
     * Account for PackJR.  If the start and the width are not 4 pixel
     * aligned, we need to BLT this by hand.  Otherwsie, if they think
     * they are BLTing 16 bit data, we must adjust the parameters now.
     *
     * This is also a good place to check that YUV BLTs are 2 pixel
     * aligned.
     */
    if (lpBlt->lpDDDestSurface->dwReserved1 & (OVERLAY_FLG_PACKJR | OVERLAY_FLG_YUV422))
    {

        ASSERTDD(0, "Who will get here?");
#if 0  // software blt
        /*
         * Check YUV first.  We can fail this if incorrect because the client
         * should know better (since they are explicitly use YUV).
         */
        if ((lpBlt->lpDDDestSurface->dwReserved1 & OVERLAY_FLG_YUV422) &&
            ((lpBlt->rSrc.left & 0x01) != (lpBlt->rDest.left & 0x01)))
        {
            lpBlt->ddRVal = DDERR_XALIGN;
            return (DDHAL_DRIVER_HANDLED);
        }

        /*
         * If PackJR is wrong, we must make this work ourselves because we
         * may be converting to this w/o the client knowing.
         */
        else if (lpBlt->lpDDDestSurface->dwReserved1 & OVERLAY_FLG_PACKJR)
        {
            if (dwFlags & DDBLT_COLORFILL)
            {
                lpBlt->ddRVal = DDERR_XALIGN;
                return (DDHAL_DRIVER_HANDLED);
            }

            if ((lpBlt->rSrc.left & 0x03) || (lpBlt->rDest.left & 0x03))
            {
                /*
                 * The start doesn't align - we have to do this the slow way
                 */
                PackJRBltAlign ((LPBYTE) ppdev->pjScreen + srcOffset,
                (LPBYTE) ppdev->pjScreen + dstOffset,
                lpBlt->rDest.right - lpBlt->rDest.left,
                lpBlt->rDest.bottom - lpBlt->rDest.top,
                srcPitch, dstPitch);

                lpBlt->ddRVal = DD_OK;
                return (DDHAL_DRIVER_HANDLED);
            }
            else if (lpBlt->rSrc.right & 0x03)
            {
                /*
                 * The end doesn't align - we will do the BLT as normal, but
                 * write the last pixels the slow way
                 */
                if (lpBlt->lpDDDestSurface->dwReserved1 & (OVERLAY_FLG_CONVERT_PACKJR | OVERLAY_FLG_MUST_RASTER))
                {
                    srcPitch  >>= 1;
                    srcOffset = srcSurf->fpVidMem + PELS_TO_BYTES(srcX) + (srcY * srcPitch);
                    dstPitch  >>= 1;
                    dstOffset = dstSurf->fpVidMem + PELS_TO_BYTES(dstX) + (dstY * dstPitch);
                }
                width = ((WORD)lpBlt->rSrc.right & ~0x03) - (WORD)lpBlt->rSrc.left;
                PackJRBltAlignEnd ((LPBYTE) ppdev->pjScreen + srcOffset + width,
                (LPBYTE) ppdev->pjScreen + dstOffset + width,
                lpBlt->rSrc.right & 0x03,
                lpBlt->rDest.bottom - lpBlt->rDest.top, srcPitch, dstPitch);
            }
            else if (lpBlt->lpDDDestSurface->dwReserved1 & (OVERLAY_FLG_CONVERT_PACKJR | OVERLAY_FLG_MUST_RASTER))
            {
                /*
                 * Everything aligns, but we have to re-calculate the start
                 * address and the pitch.
                 */
                srcPitch  >>= 1;
                srcOffset = srcSurf->fpVidMem + PELS_TO_BYTES(srcX) + (srcY * srcPitch);
                dstPitch  >>= 1;
                dstOffset = dstSurf->fpVidMem + PELS_TO_BYTES(dstX) + (dstY * dstPitch);
                width     >>= 1;
            }
        }
#endif
    }

    if ((dstSurf == srcSurf) && (srcOffset < dstOffset))
    {
        // Okay, we have to do the blt bottom-to-top, right-to-left.
        ulBltCmd = DIR_BTRL;
;
        srcOffset += width + (srcPitch * height);
        dstOffset += width + (dstPitch * height);
    }
    else
    {
        // Okay, we have to do the blt top-to-bottom, left-to-right.
        ulBltCmd = DIR_TBLR;
    }

    // Wait for the accelerator.
    while (!BLT_READY(ppdev, pjBase))
        ;

    //
    // What about source color key
    //
    ASSERTDD((!(dwFlags & DDBLT_KEYSRC)), "Do not expected source color key");

    if (dwFlags & DDBLT_KEYSRCOVERRIDE)
    {
        ULONG ulColor;

        //
        // sge02
        //
        ulBltCmd |= ENABLE_TRANSPARENCY_COMPARE | ppdev->jModeColor;
        ulColor = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
        if (ppdev->cBpp == 1)
        {
            ulColor |= ulColor << 8;
        }
        CP_WRITE_USHORT(pjBase, MM_BLT_COLOR_KEY, ulColor);
    }

	if (   (ulBltCmd & DIR_BTRL)
		&& (ulBltCmd & ENABLE_TRANSPARENCY_COMPARE)
		&& (ppdev->cBpp > 1)
	)
	{
		ulBltCmd &= ~DIR_BTRL;
		xExt = lpBlt->rDest.right - lpBlt->rDest.left;
		yExt = lpBlt->rDest.bottom - lpBlt->rDest.top;
		xDiff = dstX - srcX;
		yDiff = dstY - srcY;

		if (yDiff == 0)
		{
	        srcOffset -= srcPitch * height - 1;
	        dstOffset -= dstPitch * height - 1;

			while (xExt)
			{
				width = PELS_TO_BYTES(min(xDiff, xExt));
				srcOffset -= width;
				dstOffset -= width;

			    while (!BLT_READY(ppdev, pjBase)) ;

			    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
			    CP_MM_BLT_MODE(ppdev, pjBase, ulBltCmd);
			    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
			    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, srcPitch);
			    CP_MM_DST_Y_OFFSET(ppdev, pjBase, dstPitch);
			    CP_MM_XCNT(ppdev, pjBase, width - 1);
			    CP_MM_YCNT(ppdev, pjBase, height);
			    CP_MM_SRC_ADDR(ppdev, pjBase, srcOffset);
			    CP_MM_DST_ADDR_ABS(ppdev, pjBase, dstOffset);
			    CP_MM_START_BLT(ppdev, pjBase);

				xExt -= min(xDiff, xExt);
			}
		}
		else
		{
			srcOffset -= width - srcPitch;
			dstOffset -= width - dstPitch;

			while (yExt)
			{
				height = min(yDiff, yExt);
				srcOffset -= height * srcPitch;
				dstOffset -= height * dstPitch;

			    while (!BLT_READY(ppdev, pjBase)) ;

			    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
			    CP_MM_BLT_MODE(ppdev, pjBase, ulBltCmd);
			    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
			    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, srcPitch);
			    CP_MM_DST_Y_OFFSET(ppdev, pjBase, dstPitch);
			    CP_MM_XCNT(ppdev, pjBase, width);
			    CP_MM_YCNT(ppdev, pjBase, height - 1);
			    CP_MM_SRC_ADDR(ppdev, pjBase, srcOffset);
			    CP_MM_DST_ADDR_ABS(ppdev, pjBase, dstOffset);
			    CP_MM_START_BLT(ppdev, pjBase);

				yExt -= min(yDiff, yExt);
			}
		}
	}

	else
	{
	    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
	    CP_MM_BLT_MODE(ppdev, pjBase, ulBltCmd);
	    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);                // jl01
	    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, srcPitch);
	    CP_MM_DST_Y_OFFSET(ppdev, pjBase, dstPitch);
	    CP_MM_XCNT(ppdev, pjBase, width);
	    CP_MM_YCNT(ppdev, pjBase, height);
	    CP_MM_SRC_ADDR(ppdev, pjBase, srcOffset);
	    CP_MM_DST_ADDR_ABS(ppdev, pjBase, dstOffset);
	    CP_MM_START_BLT(ppdev, pjBase);
	}

    lpBlt->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdFlip
*
\**************************************************************************/

DWORD DdFlip(
PDD_FLIPDATA lpFlip)
{
    PDEV* ppdev;
    BYTE* pjPorts;
    ULONG ulMemoryOffset;
    ULONG ulLowOffset;
    ULONG ulMiddleOffset;
    ULONG ulHighOffset1, ulHighOffset2;

    ppdev    = lpFlip->lpDD->dhpdev;
    pjPorts  = ppdev->pjPorts;

    DISPDBG((2, "DdFlip: %d x %d at %08x(%d, %d) Pitch=%d",
                 lpFlip->lpSurfTarg->lpGbl->wWidth,
                 lpFlip->lpSurfTarg->lpGbl->wHeight,
                 lpFlip->lpSurfTarg->lpGbl->fpVidMem,
                 lpFlip->lpSurfTarg->lpGbl->xHint,
                 lpFlip->lpSurfTarg->lpGbl->yHint,
                 lpFlip->lpSurfTarg->lpGbl->lPitch));

    // Is the current flip still in progress?
    //
    // Don't want a flip to work until after the last flip is done, so we ask
    // for the general flip status and ignore the vmem.
//#jc01    if ((UpdateFlipStatus(ppdev, 0) != DD_OK) ||
    if ((UpdateFlipStatus(ppdev, 0xffffffff) != DD_OK) ||   /* #jc01 */
        (BLT_BUSY(ppdev, ppdev->pjBase)))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    ulMemoryOffset = (ULONG)(lpFlip->lpSurfTarg->lpGbl->fpVidMem);
    // Make sure that the border/blanking period isn't active; wait if it is. We
    // could return DDERR_WASSTILLDRAWING in this case, but that will increase
    // the odds that we can't flip the next time.
    while (CP_IN_BYTE(pjPorts, STATUS_1) & DISPLAY_MODE_INACTIVE)
       ;
    DISPDBG((2, "DdFlip Entered"));
#if 1 // OVERLAY #sge
    if (lpFlip->lpSurfCurr->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
    {
        DWORD   dwOffset;
        BYTE    bRegCR3A;
        BYTE    bRegCR3B;
        BYTE    bRegCR3C;
        // Make sure that the overlay surface we're flipping from is
        // currently visible.  If you don't do this check, you'll get
        // really weird results when someone starts up two ActiveMovie
        // or DirectVideo movies simultaneously!

        if (lpFlip->lpSurfCurr->lpGbl->fpVidMem == ppdev->fpVisibleOverlay)
        {
            ppdev->fpVisibleOverlay = ulMemoryOffset;
            /*
            * Determine the offset to the new area.
            */
//            dwOffset = ((ulMemoryOffset - (ULONG)ppdev->pjScreen) + ppdev->sOverlay1.lAdjustSource) >> 2; // sss
            dwOffset = ((ulMemoryOffset + ppdev->sOverlay1.lAdjustSource) >> 2);

            /*
            * Flip the overlay surface by changing CR3A, CR3B, and CR3C
            */
            bRegCR3A = (BYTE) dwOffset & 0xfe;    // Align on word boundary (5446 bug)
            dwOffset >>= 8;
            bRegCR3B = (BYTE) dwOffset;
            dwOffset >>= 8;
            bRegCR3C = (BYTE) (dwOffset & 0x0f);
//            if(GetOverlayFlipStatus(0) != DD_OK || DRAW_ENGINE_BUSY || IN_VBLANK)
//            {
//                lpFlipData->ddRVal = DDERR_WASSTILLDRAWING;
//                return DDHAL_DRIVER_HANDLED;
//            }

            CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x3C);
            CP_OUT_BYTE(pjPorts, CRTC_DATA, (CP_IN_BYTE(pjPorts, CRTC_DATA) & 0xf0) | bRegCR3C);
            CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD)bRegCR3A << 8) | 0x3A);
            CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD)bRegCR3B << 8) | 0x3B);
        }
        else
        {
            lpFlip->ddRVal = DDERR_OUTOFCAPS;
            return(DDHAL_DRIVER_HANDLED);
        }
    }
    else
#endif // OVERLAY
    {
        // Do the flip.
        ulMemoryOffset >>= 2;

        ulLowOffset    = 0x0D | ((ulMemoryOffset & 0x0000FF) << 8);
        ulMiddleOffset = 0x0C | ((ulMemoryOffset & 0x00FF00));
        ulHighOffset1  = 0x1B | ((ulMemoryOffset & 0x010000) >> 8)
                              | ((ulMemoryOffset & 0x060000) >> 7)
                              | ppdev->ulCR1B;
        ulHighOffset2  = 0x1D | ((ulMemoryOffset & 0x080000) >> 4)
                              | ppdev->ulCR1D;

        // Too bad that the Cirrus flip can't be done in a single atomic register
        // write; as it is, we stand a small chance of being context-switched out
        // and exactly hitting the vertical blank in the middle of doing these outs,
        // possibly causing the screen to momentarily jump.
        //
        // There are some hoops we could jump through to minimize the chances of
        // this happening; we could try to align the flip buffer such that the minor
        // registers are ensured to be identical for either flip position, ans so
        // that only the high address need be written, an obviously atomic
        // operation.
        //
        // However, I'm simply not going to worry about it.

        CP_OUT_WORD(pjPorts, CRTC_INDEX, ulHighOffset2);
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ulHighOffset1);
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ulMiddleOffset);
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ulLowOffset);
    }
    // Remember where and when we were when we did the flip.
    EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

    ppdev->flipRecord.bFlipFlag              = TRUE;
    ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;

    ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

    if((CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
    {
        ppdev->flipRecord.dwFlipScanLine = 0;
        ppdev->flipRecord.bWasEverInDisplay = FALSE;
    }
    else
    {
        ppdev->flipRecord.dwFlipScanLine = GetCurrentVLine(ppdev);
        ppdev->flipRecord.bWasEverInDisplay = TRUE;
    }

    lpFlip->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdLock
*
\**************************************************************************/

DWORD DdLock(PDD_LOCKDATA lpLock)
{
    PDEV*   ppdev = lpLock->lpDD->dhpdev;
    BYTE*   pjPorts = ppdev->pjPorts;

    // Check to see if any pending physical flip has occurred. Don't allow a
    // lock if a blt is in progress.
    if (UpdateFlipStatus(ppdev, lpLock->lpDDSurface->lpGbl->fpVidMem)
            != DD_OK)
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }
    if (lpLock->dwFlags & DDLOCK_WAIT)
    {
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjBase);
    }
    if (BLT_BUSY(ppdev, ppdev->pjBase))
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    /*
     * Force them to use the video apperture
     */
    if ((lpLock->lpDDSurface->dwReserved1 & OVERLAY_FLG_OVERLAY) &&
        (lpLock->dwFlags == DDLOCK_SURFACEMEMORYPTR) &&
		(ppdev->fpBaseOverlay != 0xffffffff))
    {

        if (lpLock->lpDDSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
        {
            /*
            * Turn on decimation
            */
            CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x3f);
            CP_OUT_BYTE(pjPorts, CRTC_DATA, CP_IN_BYTE(pjPorts, CRTC_DATA) | 0x10);

        }
        if( lpLock->lpDDSurface->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2)
            lpLock->lpSurfData = (LPVOID)(ppdev->fpBaseOverlay + lpLock->lpDDSurface->lpGbl->fpVidMem + 0x400000);
        else
            lpLock->lpSurfData = (LPVOID)(ppdev->fpBaseOverlay + lpLock->lpDDSurface->lpGbl->fpVidMem + 0x400000 * 3);

        // When a driver returns DD_OK and DDHAL_DRIVER_HANDLED from DdLock,
        // DirectDraw expects it to have adjusted the resulting pointer
        // to point to the upper left corner of the specified rectangle, if
        // any:

        if (lpLock->bHasRect)
        {
            lpLock->lpSurfData = (VOID*) ((BYTE*) lpLock->lpSurfData
                + lpLock->rArea.top * lpLock->lpDDSurface->lpGbl->lPitch
                + lpLock->rArea.left
                    * (lpLock->lpDDSurface->lpGbl->ddpfSurface.dwYUVBitCount >> 3));
        }

        lpLock->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdUnlock
*
\**************************************************************************/

DWORD DdUnlock(PDD_UNLOCKDATA lpUnlock)
{
    PDEV*   ppdev = lpUnlock->lpDD->dhpdev;
    BYTE*   pjPorts = ppdev->pjPorts;

    if ((lpUnlock->lpDDSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR) &&
        !(lpUnlock->lpDDSurface->dwReserved1 & OVERLAY_FLG_ENABLED))
    {
        CP_OUT_WORD(pjPorts, CRTC_INDEX, (0x00 << 8) | 0x3f);  // Turn off YUV Planar
    }

    else if (lpUnlock->lpDDSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
    {
        CP_OUT_WORD(pjPorts, CRTC_INDEX, (0x00 << 8) | 0x3f);  // Turn off YUV Planar
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetBltStatus
*
* Doesn't currently really care what surface is specified, just checks
* and goes.
*
\**************************************************************************/

DWORD DdGetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
    PDEV*   ppdev;
    HRESULT ddRVal;
    PBYTE   pjBase;

    ppdev  = lpGetBltStatus->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
    {
        // DDGBS_CANBLT case: can we add a blt?
        ddRVal = UpdateFlipStatus(ppdev, lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

        if (ddRVal == DD_OK)
        {
            // There was no flip going on, so can the blitter accept new
            // register writes?
            if (!BLT_READY(ppdev, pjBase))
            {
                ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
    }
    else
    {
        // DDGBS_ISBLTDONE case: is a blt in progress?
        if (BLT_BUSY(ppdev, pjBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    lpGetBltStatus->ddRVal = ddRVal;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdMapMemory
*
* This is a new DDI call specific to Windows NT that is used to map
* or unmap all the application modifiable portions of the frame buffer
* into the specified process's address space.
*
\**************************************************************************/

DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*                          ppdev;
    VIDEO_SHARE_MEMORY             ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION ShareMemoryInformation;
    DWORD                          ReturnedDataLength;

    ppdev = lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL.
        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer.
        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that we
        //       have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must not be
        //       modified by an application, that portion of memory MUST NOT be
        //       mapped in by this call. This would include any data that, if
        //       modified by a malicious application, would cause the driver to
        //       crash. This could include, for example, any DSP code that is
        //       kept in off-screen memory.

        ShareMemory.ViewSize = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta + 0x400000 * 3);

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               &ShareMemoryInformation,
                               sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                               &ReturnedDataLength))
        {
            DISPDBG((0, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess  =(FLATPTR)ShareMemoryInformation.VirtualAddress;
        ppdev->fpBaseOverlay = lpMapMemory->fpProcess;
    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;
        //
        // Active movie will unmap memory twice
        //
        //if (ppdev->fpBaseOverlay == lpMapMemory->fpProcess)
        //    ppdev->fpBaseOverlay = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetFlipStatus
*
* If the display has gone through one refresh cycle since the flip
* occurred, we return DD_OK.  If it has not gone through one refresh
* cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
* is still busy "drawing" the flipped page.   We also return
* DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
* to know if they could flip yet.
*
\**************************************************************************/

DWORD DdGetFlipStatus(
PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    HRESULT ddRVal;
    PDEV*   ppdev = lpGetFlipStatus->lpDD->dhpdev;

    // We don't want a flip to work until after the last flip is done, so we ask
    // for the general flip status and ignore the vmem.

//#jc01    ddRVal = UpdateFlipStatus(ppdev, 0);
    ddRVal = UpdateFlipStatus(ppdev, 0xffffffff);  //#jc01

    // Check if the blitter is busy if someone wants to know if they can flip.
    if ((lpGetFlipStatus->dwFlags == DDGFS_CANFLIP) && (ddRVal == DD_OK))
    {
        if (BLT_BUSY(ppdev, ppdev->pjBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    lpGetFlipStatus->ddRVal = ddRVal;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdWaitForVerticalBlank
*
\**************************************************************************/

DWORD DdWaitForVerticalBlank(
PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    PDEV* ppdev;
    BYTE* pjPorts;

    ppdev    = lpWaitForVerticalBlank->lpDD->dhpdev;
    pjPorts = ppdev->pjPorts;

    lpWaitForVerticalBlank->ddRVal = DD_OK;

    switch (lpWaitForVerticalBlank->dwFlags)
    {
    case DDWAITVB_I_TESTVB:

        // If TESTVB, it's just a request for the current vertical blank status.
        if (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
            lpWaitForVerticalBlank->bIsInVB = TRUE;
        else
            lpWaitForVerticalBlank->bIsInVB = FALSE;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:

        // If BLOCKBEGIN is requested, we wait until the vertical blank is over,
        // and then wait for the display period to end.
        while (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
            ;
        while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
            ;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:

        // If BLOCKEND is requested, we wait for the vblank interval to end.
        while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
            ;
        while (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
            ;

        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetScanLine
*
* Reads the scan line currently being scanned by the CRT.
*
\**************************************************************************/

DWORD DdGetScanLine(
PDD_GETSCANLINEDATA lpGetScanLine)
{
    PDEV*   ppdev;
    BYTE*   pjPorts;

    ppdev   = (PDEV*) lpGetScanLine->lpDD->dhpdev;
    pjPorts = ppdev->pjPorts;

    /*
     * If a vertical blank is in progress the scan line is in
     * indeterminant. If the scan line is indeterminant we return
     * the error code DDERR_VERTICALBLANKINPROGRESS.
     * Otherwise we return the scan line and a success code
     */
    if( CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE )
    {
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
    }
    else
    {
        lpGetScanLine->dwScanLine = GetCurrentVLine(ppdev);
        lpGetScanLine->ddRVal = DD_OK;
    }
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdCanCreateSurface
*
\**************************************************************************/

DWORD DdCanCreateSurface(
PDD_CANCREATESURFACEDATA lpCanCreateSurface)
{
    PDEV*           ppdev;
    DWORD           dwRet;
    LPDDSURFACEDESC lpSurfaceDesc;

    ppdev = (PDEV*) lpCanCreateSurface->lpDD->dhpdev;
    lpSurfaceDesc = lpCanCreateSurface->lpDDSurfaceDesc;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    DISPDBG((2, "DdCanCreateSurface Entered"));

    if (!lpCanCreateSurface->bIsDifferentPixelFormat)
    {
        // It's trivially easy to create plain surfaces that are the same
        // type as the primary surface:

        dwRet = DDHAL_DRIVER_HANDLED;
    }

    else if (ppdev->flStatus & STAT_STREAMS_ENABLED)
    {
        // When using the Streams processor, we handle only overlays of
        // different pixel formats -- not any off-screen memory:

        if (lpSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
        {
            /*
            * YUV Planar surfaces cannot co-exist with other overlay surfaces.
            */
            if (ppdev->OvlyCnt >= 1)
            {
                lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                return (DDHAL_DRIVER_HANDLED);
            }
            if ((lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUVPLANAR) &&
                ppdev->OvlyCnt)
            {
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (DDHAL_DRIVER_HANDLED);
            }
            else if (ppdev->PlanarCnt)
            {
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (DDHAL_DRIVER_HANDLED);
            }
            // We handle four types of YUV overlay surfaces:

            if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
            {
                // Check first for a supported YUV type:

                if (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUV422)
                {
                    lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
                else if ((lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUY2) &&
                         ((ppdev->ulChipID != 0x40) && (ppdev->ulChipID != 0x4C)) )     //tao1
                {
                    lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
                else if (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_PACKJR)
                {
                    if( ppdev->cBitsPerPixel <= 16)
                    {
                        lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 8;
                        dwRet = DDHAL_DRIVER_HANDLED;
                    }
                }
                else if (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUVPLANAR)
                {
                    lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 8;
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
            }

            else if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB)
            {
                if((lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) &&
                    ppdev->cBitsPerPixel == 16 )
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
                else if (lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 16)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                }

            }
        }
    }


    // Print some spew if this was a surface we refused to create:

    if (dwRet == DDHAL_DRIVER_NOTHANDLED)
    {
        if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB)
        {
            DISPDBG((0, "Failed creation of %libpp RGB surface %lx %lx %lx",
                lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount,
                lpSurfaceDesc->ddpfPixelFormat.dwRBitMask,
                lpSurfaceDesc->ddpfPixelFormat.dwGBitMask,
                lpSurfaceDesc->ddpfPixelFormat.dwBBitMask));
        }
        else
        {
            DISPDBG((0, "Failed creation of type 0x%lx YUV 0x%lx surface",
                lpSurfaceDesc->ddpfPixelFormat.dwFlags,
                lpSurfaceDesc->ddpfPixelFormat.dwFourCC));
        }
    }


    lpCanCreateSurface->ddRVal = DD_OK;
    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DdCreateSurface
*
\**************************************************************************/

DWORD DdCreateSurface(
PDD_CREATESURFACEDATA lpCreateSurface)
{
    PDEV*               ppdev;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;
    DD_SURFACE_GLOBAL*  lpSurfaceGlobal;
    LPDDSURFACEDESC     lpSurfaceDesc;
    DWORD               dwByteCount;
    LONG                lLinearPitch;
    DWORD               dwHeight;

    ppdev = (PDEV*) lpCreateSurface->lpDD->dhpdev;

    DISPDBG((2, "DdCreateSurface Entered"));
    // On Windows NT, dwSCnt will always be 1, so there will only ever
    // be one entry in the 'lplpSList' array:

    lpSurfaceLocal  = lpCreateSurface->lplpSList[0];
    lpSurfaceGlobal = lpSurfaceLocal->lpGbl;
    lpSurfaceDesc   = lpCreateSurface->lpDDSurfaceDesc;

    // We repeat the same checks we did in 'DdCanCreateSurface' because
    // it's possible that an application doesn't call 'DdCanCreateSurface'
    // before calling 'DdCreateSurface'.

    ASSERTDD(lpSurfaceGlobal->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT),
        "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    // DdCanCreateSurface already validated whether the hardware supports
    // the surface, so we don't need to do any validation here.  We'll
    // just go ahead and allocate it.
    //
    // Note that we don't do anything special for RGB surfaces that are
    // the same pixel format as the display -- by returning DDHAL_DRIVER_
    // NOTHANDLED, DirectDraw will automatically handle the allocation
    // for us.
    //
    // Also, since we'll be making linear surfaces, make sure the width
    // isn't unreasonably large.
    //
    // Note that on NT, an overlay can be created only if the driver
    // okay's it here in this routine.  Under Win95, the overlay will be
    // created automatically if it's the same pixel format as the primary
    // display.

    if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)   ||
        (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC) ||
        (lpSurfaceGlobal->ddpfSurface.dwRBitMask != ppdev->flRed))
    {
        if (lpSurfaceGlobal->wWidth <= (DWORD) ppdev->cxMemory)
        {

            lLinearPitch = (lpSurfaceGlobal->wWidth + 7) & ~7;
            if (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC)
            {
                ASSERTDD((lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUV422) ||
                         (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUY2)   ||
                         (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_PACKJR) ||
                         (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUVPLANAR),
                        "Expected our DdCanCreateSurface to allow only UYVY, YUY2, CLPJ, CLPL");
                if((lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUV422) ||
                   (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUY2))
                {
                    dwByteCount = 2;
                    lLinearPitch <<= 1;
                    lpSurfaceLocal->dwReserved1 |= OVERLAY_FLG_YUV422;
                }
                else if((lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_PACKJR))
                {
                    dwByteCount = 1;
                    lpSurfaceLocal->dwReserved1 |= OVERLAY_FLG_PACKJR;
                }
                else if((lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUVPLANAR))
                {
                    dwByteCount = 1;
                    lpSurfaceLocal->dwReserved1 |= OVERLAY_FLG_YUVPLANAR;
                }
                else
                {
                    dwByteCount = 1;
                    DISPDBG((1, "Created RGB %libpp: %li x %li Red: %lx",
                        8 * dwByteCount, lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight,
                        lpSurfaceGlobal->ddpfSurface.dwRBitMask));
                }

                // We have to fill in the bit-count for FourCC surfaces:

                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 8 * dwByteCount;
                lpSurfaceGlobal->ddpfSurface.dwYBitMask = (DWORD)-1;
                lpSurfaceGlobal->ddpfSurface.dwUBitMask = (DWORD)-1;
                lpSurfaceGlobal->ddpfSurface.dwVBitMask = (DWORD)-1;

                DISPDBG((1, "Created YUV: %li x %li",
                    lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight));
            }
            else
            {
                dwByteCount = lpSurfaceGlobal->ddpfSurface.dwRGBBitCount >> 3;


                if (dwByteCount == 2)
                    lLinearPitch <<= 1;

                DISPDBG((1, "Created RGB %libpp: %li x %li Red: %lx",
                    8 * dwByteCount, lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight,
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask));

            }

            // We want to allocate a linear surface to store the FourCC
            // surface, but DirectDraw is using a 2-D heap-manager because
            // the rest of our surfaces have to be 2-D.  So here we have to
            // convert the linear size to a 2-D size.
            //
            // The stride has to be a dword multiple:

            dwHeight = (lpSurfaceGlobal->wHeight * lLinearPitch
                     + ppdev->lDelta - 1) / ppdev->lDelta;

            // Now fill in enough stuff to have the DirectDraw heap-manager
            // do the allocation for us:

            lpSurfaceGlobal->fpVidMem     = DDHAL_PLEASEALLOC_BLOCKSIZE;
            lpSurfaceGlobal->dwBlockSizeX = ppdev->lDelta; // Specified in bytes
            lpSurfaceGlobal->dwBlockSizeY = dwHeight;
            lpSurfaceGlobal->lPitch       = lLinearPitch;

            lpSurfaceDesc->lPitch   = lLinearPitch;
            lpSurfaceDesc->dwFlags |= DDSD_PITCH;
            lpSurfaceLocal->dwReserved1 |= OVERLAY_FLG_OVERLAY;
            if (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUVPLANAR)
            {
                ppdev->PlanarCnt++;
            }
            else
            {
                ppdev->OvlyCnt++;
            }
            ppdev->fpBaseOverlay = 0xffffffff;
        }
        else
        {
            DISPDBG((1, "Refused to create surface with large width"));
        }
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdDestroySurface
*
\**************************************************************************/

DWORD DdDestroySurface (PDD_DESTROYSURFACEDATA lpDestroySurface)
{
    PDEV*   ppdev;
    BYTE*   pjPorts;

    ppdev = (PDEV*) lpDestroySurface->lpDD->dhpdev;
    pjPorts = ppdev->pjPorts;

    DISPDBG((2, "In DestroyOverlaySurface"));
    if (lpDestroySurface->lpDDSurface->dwReserved1 & OVERLAY_FLG_ENABLED)
    {
        BYTE bTemp;
        /*
         * Turn the video off
         */
        DISPDBG((1,"Turning off video in DestroySurface"));
        ppdev->pfnDisableOverlay(ppdev);
        ppdev->pfnClearAltFIFOThreshold(ppdev);

        if (lpDestroySurface->lpDDSurface->dwReserved1 & OVERLAY_FLG_COLOR_KEY)
        {
            CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
            bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Clear CR1A[3:2]
            CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x0C);
        }

        /*
         * Turn off YUV Planar
         */
        if (lpDestroySurface->lpDDSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR)
        {
            CP_OUT_WORD(pjPorts, CRTC_INDEX, (0x00 << 8) | 0x3f);  // Turn off YUV Planar
        }
        ppdev->fpVisibleOverlay = (FLATPTR)NULL;

        ppdev->dwPanningFlag &= ~OVERLAY_OLAY_SHOW;
    }
    if (lpDestroySurface->lpDDSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR)
    {
        if (ppdev->PlanarCnt > 0)
            ppdev->PlanarCnt--;
    }
    else
    {
        if (ppdev->OvlyCnt > 0)
            ppdev->OvlyCnt--;
    }

    if (lpDestroySurface->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_LIVEVIDEO)
    {
        BYTE bTemp;
        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x51);
        bTemp= CP_IN_BYTE(pjPorts, CRTC_DATA);
        CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x08);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdSetColorKey
*
\**************************************************************************/

DWORD DdSetColorKey(
PDD_SETCOLORKEYDATA lpSetColorKey)
{
    PDEV*               ppdev;
    BYTE*               pjPorts;
    BYTE*               pjBase;
    DD_SURFACE_GLOBAL*  lpSurface;
    DWORD               dwKeyLow;
    DWORD               dwKeyHigh;

    ppdev = (PDEV*) lpSetColorKey->lpDD->dhpdev;

    DISPDBG((2, "DdSetColorKey Entered"));

    ASSERTDD(ppdev->flStatus & STAT_STREAMS_ENABLED, "Shouldn't have hooked call");

    pjPorts  = ppdev->pjPorts;
    pjBase   = ppdev->pjBase;
    lpSurface = lpSetColorKey->lpDDSurface->lpGbl;

    // We don't have to do anything for normal blt source colour keys:

    if (lpSetColorKey->dwFlags & DDCKEY_SRCBLT)
    {
        lpSetColorKey->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    else if ((lpSetColorKey->dwFlags & DDCKEY_DESTOVERLAY) &&
             (lpSetColorKey->lpDDSurface == ppdev->lpColorSurface))
    {
        if (lpSurface->fpVidMem == ppdev->fpVisibleOverlay)
        {
            ppdev->wColorKey = (WORD) lpSetColorKey->ckNew.dwColorSpaceLowValue;
            ppdev->pfnRegInitVideo(ppdev, lpSetColorKey->lpDDSurface);
        }
        lpSetColorKey->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    else if ((lpSetColorKey->dwFlags & DDCKEY_SRCOVERLAY) &&
             (lpSetColorKey->lpDDSurface == ppdev->lpSrcColorSurface))
    {
        if (lpSurface->fpVidMem == ppdev->fpVisibleOverlay)
        {
            ppdev->dwSrcColorKeyLow = lpSetColorKey->ckNew.dwColorSpaceLowValue;
            ppdev->dwSrcColorKeyHigh = lpSetColorKey->ckNew.dwColorSpaceHighValue;
            if (ppdev->dwSrcColorKeyLow > ppdev->dwSrcColorKeyHigh)
            {
                ppdev->dwSrcColorKeyHigh = ppdev->dwSrcColorKeyLow;
            }
            ppdev->pfnRegInitVideo(ppdev, lpSetColorKey->lpDDSurface);
        }
        lpSetColorKey->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    DISPDBG((1, "DdSetColorKey: Invalid command"));
    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdUpdateOverlay
*
\**************************************************************************/

DWORD DdUpdateOverlay(
PDD_UPDATEOVERLAYDATA lpUpdateOverlay)
{
    PDEV*               ppdev;
    BYTE*               pjPorts;
    BYTE*               pjBase;
    DD_SURFACE_GLOBAL*  lpSource;
    DD_SURFACE_GLOBAL*  lpDestination;
    DWORD               dwStride;
    LONG                srcWidth;
    LONG                srcHeight;
    LONG                dstWidth;
    LONG                dstHeight;
    DWORD               dwBitCount;
    DWORD               dwStart;
    DWORD               dwTmp;
    BOOL                bColorKey;
    DWORD               dwKeyLow;
    DWORD               dwKeyHigh;
    DWORD               dwBytesPerPixel;

    DWORD               dwSecCtrl;
    DWORD               dwBlendCtrl;

    DWORD               dwFourcc;
    BOOL                bCheckBandwidth;
    WORD                wBitCount;
    DWORD_PTR           dwOldStatus;
    BYTE                bTemp;

    ppdev = (PDEV*) lpUpdateOverlay->lpDD->dhpdev;

    DISPDBG((2, "DdUpdateOverlay Entered"));
    ASSERTDD(ppdev->flStatus & STAT_STREAMS_ENABLED, "Shouldn't have hooked call");

    pjPorts = ppdev->pjPorts;
    pjBase  = ppdev->pjBase;

    //myf33 begin
    // Initialize the bandwidth registers
    Regs.bSR2F = 0;
    Regs.bSR32 = 0;
    Regs.bSR34 = 0;
    Regs.bCR42 = 0;
    //myf33 end

    if (lpUpdateOverlay->lpDDSrcSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        GetFormatInfo(ppdev, &(lpUpdateOverlay->lpDDSrcSurface->lpGbl->ddpfSurface),
            &dwFourcc, &wBitCount);
    }
    else
    {
        // This needs to be changed when primary surface is RGB 5:6:5
        dwFourcc = BI_RGB;
        wBitCount = (WORD) ppdev->cBitsPerPixel;
    }

    /*
     * Are we color keying?
     */
    bCheckBandwidth = TRUE;
    ppdev->lpColorSurface = ppdev->lpSrcColorSurface = NULL;
    dwOldStatus = lpUpdateOverlay->lpDDSrcSurface->dwReserved1;
    if ((lpUpdateOverlay->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)) &&
        (lpUpdateOverlay->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE)))
    {
        /*
         * Cannot perform src colorkey and dest colorkey at the same time
         */
        lpUpdateOverlay->ddRVal = DDERR_NOCOLORKEYHW;
        return (DDHAL_DRIVER_HANDLED);
    }
    lpUpdateOverlay->lpDDSrcSurface->dwReserved1 &= ~(OVERLAY_FLG_COLOR_KEY|OVERLAY_FLG_SRC_COLOR_KEY);
    if (lpUpdateOverlay->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE))
    {
        if (ppdev->pfnIsSufficientBandwidth(ppdev, wBitCount, &(lpUpdateOverlay->rSrc),
            &(lpUpdateOverlay->rDest), OVERLAY_FLG_COLOR_KEY))
        {
            bCheckBandwidth = FALSE;
            lpUpdateOverlay->lpDDSrcSurface->dwReserved1 |= OVERLAY_FLG_COLOR_KEY;
            if (lpUpdateOverlay->dwFlags & DDOVER_KEYDEST)
            {
                ppdev->wColorKey = (WORD)
                    lpUpdateOverlay->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
                ppdev->lpColorSurface = lpUpdateOverlay->lpDDDestSurface;
            }
            else
            {
                ppdev->wColorKey = (WORD)
                    lpUpdateOverlay->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
            }
        }
        else
        {
            lpUpdateOverlay->ddRVal = DDERR_NOCOLORKEYHW;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    else if (lpUpdateOverlay->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE))
    {
        if (ppdev->pfnIsSufficientBandwidth(ppdev, wBitCount, &(lpUpdateOverlay->rSrc),
            &(lpUpdateOverlay->rDest), OVERLAY_FLG_SRC_COLOR_KEY))
        {
            bCheckBandwidth = FALSE;
            lpUpdateOverlay->lpDDSrcSurface->dwReserved1 |= OVERLAY_FLG_SRC_COLOR_KEY;
            ppdev->lpSrcColorSurface = lpUpdateOverlay->lpDDSrcSurface;
            if (lpUpdateOverlay->dwFlags & DDOVER_KEYSRC)
            {
                ppdev->dwSrcColorKeyLow =
                    lpUpdateOverlay->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
                ppdev->dwSrcColorKeyHigh =
                    lpUpdateOverlay->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceHighValue;
            }
            else
            {
                ppdev->dwSrcColorKeyLow =
                    lpUpdateOverlay->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
                ppdev->dwSrcColorKeyHigh =
                    lpUpdateOverlay->overlayFX.dckSrcColorkey.dwColorSpaceHighValue;
            }
            if (ppdev->dwSrcColorKeyHigh < ppdev->dwSrcColorKeyHigh)
            {
                ppdev->dwSrcColorKeyHigh = ppdev->dwSrcColorKeyLow;
            }
        }
        else
        {
            DISPDBG((0, "Insufficient bandwidth for colorkeying"));
            lpUpdateOverlay->ddRVal = DDERR_NOCOLORKEYHW;
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    // 'Source' is the overlay surface, 'destination' is the surface to
    // be overlayed:

    lpSource = lpUpdateOverlay->lpDDSrcSurface->lpGbl;

    if (lpUpdateOverlay->dwFlags & DDOVER_HIDE)
    {
        if (lpSource->fpVidMem == ppdev->fpVisibleOverlay)
        {
            /*
             * Turn the video off
             */
            ppdev->pfnDisableOverlay(ppdev);
            ppdev->pfnClearAltFIFOThreshold(ppdev);

            /*
             * If we are color keying, we will disable that now
             */
            if (dwOldStatus & OVERLAY_FLG_COLOR_KEY)
            {
                CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
                bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Clear CR1A[3:2]
                CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x0C);
            }

            ppdev->dwPanningFlag &= ~OVERLAY_OLAY_SHOW;
            lpUpdateOverlay->lpDDSrcSurface->dwReserved1 &= ~OVERLAY_FLG_ENABLED;
            ppdev->fpVisibleOverlay = 0;
        }

        lpUpdateOverlay->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    // Dereference 'lpDDDestSurface' only after checking for the DDOVER_HIDE
    // case:
#if 0
    /*
     * Turn the video off first to protect side effect when moving.
     * Later RegIniVideo will turn it on if needed.
     */
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x3e);
    bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x01);  // Clear CR3E[0]
#endif

    lpDestination = lpUpdateOverlay->lpDDDestSurface->lpGbl;

    if (lpSource->fpVidMem != ppdev->fpVisibleOverlay)
    {
        if (lpUpdateOverlay->dwFlags & DDOVER_SHOW)
        {
            if (ppdev->fpVisibleOverlay != 0)
            {
                // Some other overlay is already visible:

                DISPDBG((0, "DdUpdateOverlay: An overlay is already visible"));

                lpUpdateOverlay->ddRVal = DDERR_OUTOFCAPS;
                return(DDHAL_DRIVER_HANDLED);
            }
            else
            {
                // We're going to make the overlay visible, so mark it as
                // such:

                ppdev->fpVisibleOverlay = lpSource->fpVidMem;
            }
        }
        else
        {
            // The overlay isn't visible, and we haven't been asked to make
            // it visible, so this call is trivially easy:

            lpUpdateOverlay->ddRVal = DD_OK;
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    /*
     * Is there sufficient bandwidth to work?
     */
    if (bCheckBandwidth && !ppdev->pfnIsSufficientBandwidth(ppdev, wBitCount,
        &(lpUpdateOverlay->rSrc), &(lpUpdateOverlay->rDest), 0))
    {
        lpUpdateOverlay->ddRVal = DDERR_OUTOFCAPS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Save the rectangles
     */
    ppdev->rOverlaySrc  =  lpUpdateOverlay->rSrc;
    ppdev->rOverlayDest =  lpUpdateOverlay->rDest;

    if (lpUpdateOverlay->lpDDSrcSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
    {
        ppdev->rOverlaySrc.right = ppdev->rOverlaySrc.left +
            ((ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left) >> 1);
    }

    if (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left <= MIN_OLAY_WIDTH)
    {
        lpUpdateOverlay->ddRVal = DDERR_OUTOFCAPS;
        return (DDHAL_DRIVER_HANDLED);
    }

    lpUpdateOverlay->lpDDSrcSurface->dwReserved1 |= OVERLAY_FLG_ENABLED;

    //
    // Assign 5c to 1F when video is on while no color key for 5446BE.
    //
    // sge04
    //if (bCheckBandwidth && ppdev->flCaps & CAPS_SECOND_APERTURE)
    if (ppdev->flCaps & CAPS_SECOND_APERTURE)
        ppdev->lFifoThresh = 0x0E;

    ppdev->pfnRegInitVideo(ppdev, lpUpdateOverlay->lpDDSrcSurface);

    lpUpdateOverlay->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdSetOverlayPosition
*
\**************************************************************************/

DWORD DdSetOverlayPosition(
PDD_SETOVERLAYPOSITIONDATA lpSetOverlayPosition)
{
    PDEV*   ppdev;
    BYTE*   pjPorts;
    BYTE*   pjBase;

    ppdev = (PDEV*) lpSetOverlayPosition->lpDD->dhpdev;
    pjPorts = ppdev->pjPorts;
    pjBase  = ppdev->pjBase;

    DISPDBG((2, "DdSetOverlayPosition Entered"));
    ASSERTDD(ppdev->flStatus & STAT_STREAMS_ENABLED, "Shouldn't have hooked call");

    if(lpSetOverlayPosition->lpDDSrcSurface->lpGbl->fpVidMem == ppdev->fpVisibleOverlay)
    {
        /*
         * Update the rectangles
         */
        ppdev->rOverlayDest.right = (ppdev->rOverlayDest.right - ppdev->rOverlayDest.left)
            + lpSetOverlayPosition->lXPos;
        ppdev->rOverlayDest.left = lpSetOverlayPosition->lXPos;
        ppdev->rOverlayDest.bottom = (ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top)
            + lpSetOverlayPosition->lYPos;
        ppdev->rOverlayDest.top = lpSetOverlayPosition->lYPos;

//myf29 RegMoveVideo(ppdev, lpSetOverlayPosition->lpDDSrcSurface);
        ppdev->pfnRegMoveVideo(ppdev, lpSetOverlayPosition->lpDDSrcSurface);
    }

    lpSetOverlayPosition->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}


/******************************************************************************\
*
* Function:     DrvGetDirectDrawInfo
*
* This function returns te capabilities of the DirectDraw implementation. It is
* called twice during the connect phase.
*
* Parameters:   dhpdev            Handle to physical device.
*                pHalInfo        Pointer to a DD_HALINFO structure.
*                pdwNumHeaps        Pointer to a variable that holds the number of
*                                heaps.
*                pvmList            Pointer to the heap array.
*                pdwNumFourCC    Pointer to a variable that holds the number of
*                                FourCC IDs.
*                pdwFourCC        Pointer to FourCC IDs.
*
* Returns:      TRUE if successful.
*
\******************************************************************************/
BOOL DrvGetDirectDrawInfo(
DHPDEV       dhpdev,
DD_HALINFO*  pHalInfo,
DWORD*       pdwNumHeaps,
VIDEOMEMORY* pvmList,
DWORD*       pdwNumFourCC,
DWORD*       pdwFourCC)
{
    BOOL        bCanFlip;
    PDEV*       ppdev = (PPDEV) dhpdev;
    LONGLONG    li;
    OH*         poh;
    RECTL       rSrc, rDest;
    LONG        lZoom;
    BYTE*       pjPorts = ppdev->pjPorts;
    BYTE        bTemp;

    // We may not support DirectDraw on this card.
    if (!(ppdev->flStatus & STAT_DIRECTDRAW))
    {
        return(FALSE);
    }

    DISPDBG((2, "DrvGetDirectDrawInfo Entered"));
    pHalInfo->dwSize = sizeof(DD_HALINFO);

    // Current primary surface attributes. Since HalInfo is zero-initialized by
    // GDI, we only have to fill in the fields which should be non-zero.

    pHalInfo->vmiData.pvPrimary        = ppdev->pjScreen;
    pHalInfo->vmiData.dwDisplayWidth   = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight  = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch    = ppdev->lDelta;
    pHalInfo->vmiData.dwOffscreenAlign = 4;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBitsPerPixel;

    if (ppdev->cBpp == 1)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp.
    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    if (ppdev->cBpp == 4)
    {
        pHalInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask =
                            ~(ppdev->flRed | ppdev->flGreen | ppdev->flBlue);
    }

    // Set up the pointer to the first available video memory after the primary
    // surface.
    bCanFlip     = FALSE;
    *pdwNumHeaps = 0;

    // Free up as much off-screen memory as possible.
    bMoveAllDfbsFromOffscreenToDibs(ppdev);    // Move all DFBs to DIB.s
    vAssertModeText(ppdev, FALSE);            // Destroy all cached fonts.

    if ((ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))//myf32
    {
        MIN_OLAY_WIDTH = 16;
#if (_WIN32_WINNT >= 0x0400)
        ppdev->flCaps |= CAPS_VIDEO;
#endif
        ppdev->pfnIsSufficientBandwidth=Is7555SufficientBandwidth;
        ppdev->pfnRegInitVideo=RegInit7555Video;
        ppdev->pfnRegMoveVideo=RegMove7555Video;
        ppdev->pfnDisableOverlay=DisableVideoWindow;
        ppdev->pfnClearAltFIFOThreshold=ClearAltFIFOThreshold;
    }
    else
    {
        ppdev->pfnIsSufficientBandwidth =
            (ppdev->ulChipID != 0xBC) ?
                IsSufficientBandwidth : Is5480SufficientBandwidth ;  // chu03

        ppdev->pfnRegInitVideo=RegInitVideo;
        ppdev->pfnRegMoveVideo=RegMoveVideo;
        ppdev->pfnDisableOverlay=DisableOverlay_544x;
        ppdev->pfnClearAltFIFOThreshold=ClearAltFIFOThreshold_544x;
    }

    // Now simply reserve the biggest chunk for use by DirectDraw.
    poh = ppdev->pohDirectDraw;
#if (DIRECTX_24 < 2)
    if ((poh == NULL) && (ppdev->cBpp != 3))
#else
    if (poh == NULL)
#endif
    {
        LONG cxMax, cyMax;

        cxMax = ppdev->heap.cxMax & ~(HEAP_X_ALIGNMENT - 1);
        cyMax = ppdev->heap.cyMax;

        poh = pohAllocatePermanent(ppdev, cxMax, cyMax);
        if (poh == NULL)
        {
            // Could not allocate all memory, find the biggest area now.
            cxMax = cyMax = 0;
            for (poh = ppdev->heap.ohAvailable.pohNext;
                 poh != &ppdev->heap.ohAvailable; poh = poh->pohNext)
            {
                if ((poh->cx * poh->cy) > (cxMax * cyMax))
                {
                    cxMax = poh->cx & ~(HEAP_X_ALIGNMENT - 1);
                    cyMax = poh->cy;
                }
            }

            poh = pohAllocatePermanent(ppdev, cxMax, cyMax);
        }

        ppdev->pohDirectDraw = poh;
    }

    if (poh != NULL)
    {
        *pdwNumHeaps = 1;

        // Fill in the list of off-screen rectangles if we've been asked to do
        // so.
        if (pvmList != NULL)
        {
            DISPDBG((1, "DirectDraw gets %d x %d surface at (%d, %d)",
                     poh->cx, poh->cy, poh->x, poh->y));

#if 0
            if (PELS_TO_BYTES(poh->cx) != ppdev->lDelta)
            {
#endif
                pvmList->dwFlags  = VIDMEM_ISRECTANGULAR;
                pvmList->fpStart  = poh->xy;
                pvmList->dwWidth  = PELS_TO_BYTES(poh->cx);
                pvmList->dwHeight = poh->cy;
#if 0
            }
            else
            {
                pvmList->dwFlags = VIDMEM_ISLINEAR;
                pvmList->fpStart = poh->xy;
                pvmList->fpEnd   = poh->xy - 1
                    + PELS_TO_BYTES(poh->cx)
                    + poh->cy * ppdev->lDelta;
            }
#endif

            pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
            if ((poh->cx >= ppdev->cxScreen) && (poh->cy >= ppdev->cyScreen))
            {
                bCanFlip = TRUE;
            }
        }
    }

    // Capabilities supported.
    pHalInfo->ddCaps.dwFXCaps = 0;
    pHalInfo->ddCaps.dwCaps   = DDCAPS_BLT
                              | DDCAPS_BLTCOLORFILL
                              | DDCAPS_READSCANLINE;                                // sge08 add this bit

    pHalInfo->ddCaps.dwCaps2  = DDCAPS2_COPYFOURCC;

    if ( (ppdev->flCaps & CAPS_VIDEO) && (ppdev->cBpp <= 2) )
    {
        pHalInfo->ddCaps.dwCaps    |= DDCAPS_COLORKEY;
        pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT;
    }

    pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                    | DDSCAPS_PRIMARYSURFACE;
    if (bCanFlip)
    {
        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;
    }

    // FourCCs supported.
    *pdwNumFourCC = 0;

#if 0    // smac - disable overlays due to too many bugs
{

    //
    // Interlaced mode ?
    //
    BOOL Interlaced ;                                                // chu02

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a) ;
    Interlaced = CP_IN_BYTE(pjPorts, CRTC_DATA) & 0x01 ;

    //
    // Needs check more later
    //
    if ((ppdev->flCaps & CAPS_VIDEO) && (!Interlaced))               // chu02
        ppdev->flStatus |= STAT_STREAMS_ENABLED;

    if (ppdev->flStatus & STAT_STREAMS_ENABLED)
    {

        /*
         * Are we double clocked?
        */
        ppdev->bDoubleClock = FALSE;
        //
        // use SR7 to check the double clock instead of hidden register
        //
        //
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x7);
        bTemp = CP_IN_BYTE(pjPorts, SR_DATA);

        if ((((bTemp & 0x0E) == 0x06) && ppdev->cBitsPerPixel == 8) ||
            (((bTemp & 0x0E) == 0x08) && ppdev->cBitsPerPixel == 16))
        {
            ppdev->bDoubleClock = TRUE;
        }

        pHalInfo->vmiData.dwOverlayAlign = 8;

        pHalInfo->ddCaps.dwCaps |= DDCAPS_OVERLAY
                                | DDCAPS_OVERLAYSTRETCH
                                | DDCAPS_OVERLAYFOURCC
                                | DDCAPS_OVERLAYCANTCLIP
                                | DDCAPS_ALIGNSTRIDE;

        pHalInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYSTRETCHX
                                  | DDFXCAPS_OVERLAYSTRETCHY
                                  | DDFXCAPS_OVERLAYARITHSTRETCHY;

        pHalInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_DESTOVERLAY
                                    | DDCKEYCAPS_DESTOVERLAYYUV
                                    | DDCKEYCAPS_DESTOVERLAYONEACTIVE;

        pHalInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_SRCOVERLAY
                                    | DDCKEYCAPS_SRCOVERLAYCLRSPACE
                                    | DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV
                                    | DDCKEYCAPS_SRCOVERLAYONEACTIVE
                                    | DDCKEYCAPS_SRCOVERLAYYUV;

        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_OVERLAY;

        *pdwNumFourCC = 3;
        if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))   //tao1
            *pdwNumFourCC = 2;                                        //tao1

        if (pdwFourCC)
        {
            pdwFourCC[0] = FOURCC_YUV422;
            pdwFourCC[1] = FOURCC_PACKJR;
            if ((ppdev->ulChipID != 0x40) && (ppdev->ulChipID != 0x4C)) //tao1
                pdwFourCC[2] = FOURCC_YUY2;                             //tao1
        }

        pHalInfo->ddCaps.dwMaxVisibleOverlays = 1;
        pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;
        pHalInfo->ddCaps.dwNumFourCCCodes = 2;
# if 1
        pHalInfo->ddCaps.dwAlignBoundarySrc = 1;
        pHalInfo->ddCaps.dwAlignSizeSrc = 1;
// chu01 sge05
#if 1
        if ((ppdev->cBpp == 3) || ppdev->bDoubleClock )
        {
            pHalInfo->ddCaps.dwAlignBoundaryDest = 4;
            pHalInfo->ddCaps.dwAlignSizeDest = 4;
        }
        else
        {
            pHalInfo->ddCaps.dwAlignBoundaryDest = 1;
            pHalInfo->ddCaps.dwAlignSizeDest = 1;
        }
#else
        pHalInfo->ddCaps.dwAlignBoundaryDest = 1;
        pHalInfo->ddCaps.dwAlignSizeDest = 1;
#endif // 1
        pHalInfo->ddCaps.dwAlignStrideAlign = 8;
        pHalInfo->ddCaps.dwMinOverlayStretch    = 8000;
        pHalInfo->ddCaps.dwMinLiveVideoStretch  = 8000;
        pHalInfo->ddCaps.dwMinHwCodecStretch    = 8000;
        pHalInfo->ddCaps.dwMaxOverlayStretch    = 8000;
        pHalInfo->ddCaps.dwMaxLiveVideoStretch  = 8000;
        pHalInfo->ddCaps.dwMaxHwCodecStretch    = 8000;
        //
        // maybe there are special requirement for VCLK > 85Hz
        //
#endif
        rSrc.left = rSrc.top = 0;
        rSrc.right = 320;
        rSrc.bottom = 240;
        rDest.left = rDest.top = 0;
        rDest.right = 1280;
        rDest.bottom = 960;
        lZoom = 1000;
        do
        {
            rDest.right = (320 * lZoom)/ 1000;
            rDest.bottom = (240 * lZoom)/1000;
            if (ppdev->pfnIsSufficientBandwidth(ppdev, 16, (LPRECTL) &rSrc, (LPRECTL) &rDest, 0))
            {
                DISPDBG((1, "Minimum zoom factor: %d", lZoom));
                pHalInfo->ddCaps.dwMinOverlayStretch    = lZoom;
                pHalInfo->ddCaps.dwMinLiveVideoStretch  = lZoom;
                pHalInfo->ddCaps.dwMinHwCodecStretch    = lZoom;
                lZoom = 4000;
            }
            lZoom += 100;
        } while (lZoom < 4000);
    }
}
#endif // smac

    return(TRUE);
}


/******************************************************************************\
*
* Function:     DrvEnableDirectDraw
*
* Enable DirectDraw. This function is called when an application opens a
* DirectDraw connection.
*
* Parameters:   dhpdev                Handle to physical device.
*                pCallBacks            Pointer to DirectDraw callbacks.
*                pSurfaceCallBacks    Pointer to surface callbacks.
*                pPaletteCallBacks    Pointer to palette callbacks.
*
* Returns:      TRUE if successful.
*
\******************************************************************************/
BOOL DrvEnableDirectDraw(
DHPDEV               dhpdev,
DD_CALLBACKS*        pCallBacks,
DD_SURFACECALLBACKS* pSurfaceCallBacks,
DD_PALETTECALLBACKS* pPaletteCallBacks)
{
    PDEV*    ppdev = (PPDEV) dhpdev;

    pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank;
    pCallBacks->MapMemory            = DdMapMemory;
    pCallBacks->GetScanLine          = DdGetScanLine;
    pCallBacks->dwFlags              = DDHAL_CB32_WAITFORVERTICALBLANK
                                     | DDHAL_CB32_MAPMEMORY
                                     | DDHAL_CB32_GETSCANLINE;

    pSurfaceCallBacks->Blt           = DdBlt;
    pSurfaceCallBacks->Flip          = DdFlip;
    pSurfaceCallBacks->Lock          = DdLock;
    pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus;
    pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus;
    pSurfaceCallBacks->dwFlags       = DDHAL_SURFCB32_BLT
                                     | DDHAL_SURFCB32_FLIP
                                     | DDHAL_SURFCB32_LOCK
                                     | DDHAL_SURFCB32_GETBLTSTATUS
                                     | DDHAL_SURFCB32_GETFLIPSTATUS;

    if (ppdev->flStatus & STAT_STREAMS_ENABLED)
    {
        pCallBacks->CreateSurface             = DdCreateSurface;
        pCallBacks->CanCreateSurface          = DdCanCreateSurface;
        pCallBacks->dwFlags                  |= DDHAL_CB32_CREATESURFACE
                                              | DDHAL_CB32_CANCREATESURFACE;

        pSurfaceCallBacks->SetColorKey        = DdSetColorKey;
        pSurfaceCallBacks->UpdateOverlay      = DdUpdateOverlay;
        pSurfaceCallBacks->SetOverlayPosition = DdSetOverlayPosition;
        pSurfaceCallBacks->DestroySurface     = DdDestroySurface;
        pSurfaceCallBacks->dwFlags           |= DDHAL_SURFCB32_SETCOLORKEY
                                              | DDHAL_SURFCB32_UPDATEOVERLAY
                                              | DDHAL_SURFCB32_SETOVERLAYPOSITION
                                              | DDHAL_SURFCB32_DESTROYSURFACE;

        // The DrvEnableDirectDraw call can occur while we're in full-
        // screen DOS mode.  Do not turn on the streams processor now
        // if that's the case, instead wait until AssertMode switches
        // us back to graphics mode:

    }

    // Note that we don't call 'vGetDisplayDuration' here, for a couple of
    // reasons:
    //
    //  o Because the system is already running, it would be disconcerting
    //    to pause the graphics for a good portion of a second just to read
    //    the refresh rate;
    //  o More importantly, we may not be in graphics mode right now.
    //
    // For both reasons, we always measure the refresh rate when we switch
    // to a new mode.

    return(TRUE);
}

/******************************************************************************\
*
* Function:     DrvDisableDirectDraw
*
* Disable DirectDraw. This function is called when an application closes the
* DirectDraw connection.
*
* Parameters:   dhpdev        Handle to physical device.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID DrvDisableDirectDraw(
DHPDEV dhpdev)
{
    PDEV* ppdev;
    OH*   poh;

    // DirectDraw is done with the display, so we can go back to using
    // all of off-screen memory ourselves.
    ppdev = (PPDEV) dhpdev;
    poh   = ppdev->pohDirectDraw;

    if (poh)
    {
        DISPDBG((1, "Releasing DirectDraw surface %d x %d at (%d, %d)",
                 poh->cx, poh->cy, poh->x, poh->y));
    }

    pohFree(ppdev, poh);
    ppdev->pohDirectDraw = NULL;

    // Invalidate all cached fonts.
    vAssertModeText(ppdev, TRUE);
}

/******************************************************************************\
*
* Function:     vAssertModeDirectDraw
*
* Perform specific DirectDraw initialization when the screen switches focus
* (from graphics to full screen MS-DOS and vice versa).
*
* Parameters:   ppdev        Pointer to physical device.
*                bEnabled    True if the screen is in graphics mode.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vAssertModeDirectDraw(
PDEV* ppdev,
BOOL  bEnabled)
{
}

/******************************************************************************\
*
* Function:     bEnableDirectDraw
*
* Enable DirectDraw. Called from DrvEnableSurface.
*
* Parameters:   ppdev        Pointer to phsyical device.
*
* Returns:      Nothing.
*
\******************************************************************************/
BOOL bEnableDirectDraw(
PDEV* ppdev)
{

    if (DIRECT_ACCESS(ppdev) &&             // Direct access must be enabled.
#if (DIRECTX_24 < 1)
       (ppdev->cBpp != 3) &&                // Turn off DirectDraw in 24-bpp.
#endif
       (ppdev->flCaps & CAPS_ENGINEMANAGED) &&  // Only support CL-GD5436/5446.
       (ppdev->flCaps & CAPS_MM_IO))        // Memory Mapped I/O must be on.
    {
        // We have to preserve the contents of the CR1B and CR1D registers on a
        // page flip.
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x1B);
        ppdev->ulCR1B = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xF2) << 8;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x1D);
        ppdev->ulCR1D = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x7F) << 8;

        // Accurately measure the refresh rate for later.
        vGetDisplayDuration(ppdev);

        // DirectDraw is all set to be used on this card.
        ppdev->flStatus |= STAT_DIRECTDRAW;

#if 1 // sge
        EnableStartAddrDoubleBuffer(ppdev);
#endif // sge
    }

    return(TRUE);
}

/******************************************************************************\
*
* Function:     vDisableDirectDraw
*
* Disbale DirectDraw. Called from DrvDisableSurface.
*
* Parameters:   ppdev        Pointer to physical device.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vDisableDirectDraw(
PDEV* ppdev)
{
}

#if 1 // OVERLAY #sge
/******************************************************************************\
*
* Function:     GetFormatInfo
*
* Get DirectDraw information,
*
* Parameters:   ppdev        Pointer to physical device.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID GetFormatInfo(PDEV* ppdev, LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc,
                   LPWORD lpBitCount)
{

    if (lpFormat->dwFlags & DDPF_FOURCC)
    {
        *lpFourcc = lpFormat->dwFourCC;
        if (lpFormat->dwFourCC == BI_RGB)
        {
            *lpBitCount = (WORD) lpFormat->dwRGBBitCount;
#ifdef DEBUG
            if (lpFormat->dwRGBBitCount == 8)
            {
               DISPDBG((1, "Format: RGB 8"));
            }
            else if (lpFormat->dwRGBBitCount == 16)
            {
               DISPDBG ((1,"Format: RGB 5:5:5"));
            }
#endif
        }
        else if (lpFormat->dwFourCC == BI_BITFIELDS)
        {
            if ((lpFormat->dwRGBBitCount != 16) ||
                (lpFormat->dwRBitMask != 0xf800) ||
                (lpFormat->dwGBitMask != 0x07e0) ||
                (lpFormat->dwBBitMask != 0x001f))
            {
                *lpFourcc = (DWORD) -1;
            }
            else
            {
                *lpBitCount = 16;
                DISPDBG((1,"Format: RGB 5:6:5"));
            }
        }
        else
        {
            lpFormat->dwRBitMask = (DWORD) -1;
            lpFormat->dwGBitMask = (DWORD) -1;
            lpFormat->dwBBitMask = (DWORD) -1;
            if (lpFormat->dwFourCC == FOURCC_PACKJR)
            {
                *lpBitCount = 8;
                DISPDBG((1, "Format: CLJR"));
            }
            else if (lpFormat->dwFourCC == FOURCC_YUY2)
            {
                *lpBitCount = 16;
                DISPDBG((1,"Format: YUY2"));
            }
            else
            {
                *lpBitCount = 16;
                DISPDBG((1,"Format: UYVY"));
            }
        }
    }
    else if (lpFormat->dwFlags & DDPF_RGB)
    {
         if (lpFormat->dwRGBBitCount == 8)
         {
              *lpFourcc = BI_RGB;
              DISPDBG((1, "Format: RGB 8"));
         }
         else if ((lpFormat->dwRGBBitCount == 16) &&
              (lpFormat->dwRBitMask == 0xf800) &&
              (lpFormat->dwGBitMask == 0x07e0) &&
              (lpFormat->dwBBitMask == 0x001f))
         {
              *lpFourcc = BI_BITFIELDS;
              DISPDBG((1,"Format: RGB 5:6:5"));
         }
         else if ((lpFormat->dwRGBBitCount == 16) &&
              (lpFormat->dwRBitMask == 0x7C00) &&
              (lpFormat->dwGBitMask == 0x03e0) &&
              (lpFormat->dwBBitMask == 0x001f))
         {
              *lpFourcc = BI_RGB;
              DISPDBG((1,"Format: RGB 5:5:5"));
         }
         else if (((lpFormat->dwRGBBitCount == 24) ||
              (lpFormat->dwRGBBitCount == 32)) &&
              (lpFormat->dwRBitMask == 0xff0000) &&
              (lpFormat->dwGBitMask == 0x00ff00) &&
              (lpFormat->dwBBitMask == 0x0000ff))
         {
              *lpFourcc = BI_RGB;
              DISPDBG((1, "Format: RGB 8:8:8"));
         }
         else
         {
              *lpFourcc = (DWORD) -1;
         }
         *lpBitCount = (WORD) lpFormat->dwRGBBitCount;
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
         *lpFourcc = BI_RGB;
         *lpBitCount = (WORD) lpFormat->dwRGBBitCount;
    }
    else
    {
         *lpFourcc = (DWORD) -1;
    }
}

/**********************************************************
*
*       Name:  RegInitVideo
*
*       Module Abstract:
*       ----------------
*       This function is called to program the video format and
*       the physicall offset of the video data in the frame buffer.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/24/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID RegInitVideo(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface)
{
    DWORD dwTemp;
    DWORD dwFourcc;
    LONG  lPitch;
    LONG  lLeft;
    WORD  wTemp;
    WORD  wBitCount = 0;
    RECTL rVideoRect;
    BYTE  bRegCR31;
    BYTE  bRegCR32;
    BYTE  bRegCR33;
    BYTE  bRegCR34;
    BYTE  bRegCR35;
    BYTE  bRegCR36;
    BYTE  bRegCR37;
    BYTE  bRegCR38;
    BYTE  bRegCR39;
    BYTE  bRegCR3A;
    BYTE  bRegCR3B;
    BYTE  bRegCR3C;
    BYTE  bRegCR3D;
    BYTE  bRegCR3E;
    BYTE  bRegCR5C;
    BYTE  bRegCR5D;
    BYTE  bTemp;
    DWORD dwTemp1;
    BOOL  bOverlayTooSmall = FALSE;
    BYTE*   pjPorts = ppdev->pjPorts;


    /*
     * Determine the format of the video data
     */
    if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        GetFormatInfo(ppdev, &(lpSurface->lpGbl->ddpfSurface),
            &dwFourcc, &wBitCount);
    }
    else
    {
        // This needs to be changed when primary surface is RGB 5:6:5
        dwFourcc = BI_RGB;
        wBitCount = (WORD) ppdev->cBitsPerPixel;
    }

    rVideoRect = ppdev->rOverlayDest;
    lPitch = lpSurface->lpGbl->lPitch;

    /*
     * Determine value in CR31 (Horizontal Zoom Code)
     */
    if ((ppdev->rOverlayDest.right - ppdev->rOverlayDest.left) ==
        (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left))
    {
        /*
         * No zooming is occuring
         */
        bRegCR31 = 0;
    }
    else
    {
        /*
         * The zoom code = (256 * <src width>) / <dest width>
         */
        dwTemp = (DWORD) ((DWORD) (ppdev->rOverlaySrc.right
            - ppdev->rOverlaySrc.left)) *  256;
        if (ppdev->bDoubleClock)
        {
            dwTemp <<= 1;
        }
        dwTemp1= (DWORD) (ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
        dwTemp= ((2 * dwTemp) + dwTemp1) / (2*dwTemp1);
        bRegCR31= (BYTE) dwTemp;
    }

    /*
     * Determine value in CR32 (Vertical Zoom Code)
     */
    if ((ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top) ==
        (ppdev->rOverlaySrc.bottom - ppdev->rOverlaySrc.top))
    {
        /*
         * No zooming is occuring
         */
        bRegCR32 = 0;
    }
    else
    {
        /*
         * The zoom code = (256 * <src height>) / <dest height>
         * The -1 is so that it won't mangle the last line by mixing it
         * with garbage data while Y interpolating.
         */
        dwTemp = (DWORD) ((DWORD) ((ppdev->rOverlaySrc.bottom - 1)
            - ppdev->rOverlaySrc.top)) * 256;
        dwTemp /= (DWORD) (ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top);
        bRegCR32 = (BYTE) dwTemp;
    }

    /*
     * Determine value in CR33 (Region 1 Size)
     */
    wTemp = (WORD) rVideoRect.left;
    if (ppdev->cBitsPerPixel == 8)
    {
        wTemp >>= 2;     // 4 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        wTemp >>= 1;     // 2 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        wTemp *= 3;
        wTemp /= 4;
    }
    bRegCR33 = (BYTE) wTemp;
    bRegCR36 = (BYTE) (WORD) (wTemp >> 8);

    /*
     * Determine value in CR34 (Region 2 size)
     */
    wTemp = (WORD) (rVideoRect.right - rVideoRect.left);
    if (ppdev->cBitsPerPixel == 8)
    {
        wTemp >>= 2;                           // 4 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        wTemp >>= 1;                           // 2 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        wTemp *= 3;
        wTemp /= 4;
    }
    bRegCR34 = (BYTE) wTemp;
    wTemp >>= 6;
    bRegCR36 |= (BYTE) (wTemp & 0x0C);

    /*
     * Determine value in CR35 (Region 2 SDSize)
     */
    dwTemp = (DWORD) (rVideoRect.right - rVideoRect.left);
    dwTemp *= (DWORD) (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left);
    dwTemp /= (DWORD) (ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
    wTemp = (WORD) dwTemp;
    if ((dwFourcc == FOURCC_PACKJR) || (wBitCount == 8))
    {
        wTemp >>= 2;                           // 4 Pixels per DWORD
    }
    else
    {
        wTemp >>= 1;                           // 2 Pixels per DWORD
    }
    bRegCR35 = (BYTE) wTemp;
    wTemp >>= 4;
    bRegCR36 |= (BYTE) (wTemp & 0x30);

    //
    // Check double scan line counter feature
    //
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x17);
    bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    if (bTemp & 0x04)
    {
        //
        // Double scan line count
        //
        /*
         * Determine value in CR37 (Vertical Start)
         */
        wTemp = (WORD) rVideoRect.top;
        bRegCR37 = (BYTE)(wTemp >> 1);
        if ( wTemp & 0x01 )
        {
            wTemp >>= 9;
            bRegCR39 = (BYTE) wTemp | 0x10;
            //
            // Odd scan line trigger
            // Hardware has a bug now.
            // So reduce dest end by 1
            //
            wTemp = (WORD) rVideoRect.bottom - 1 - 1;
        }
        else
        {
            wTemp >>= 9;
            bRegCR39 = (BYTE) wTemp;
            /*
             * Determine value in CR38 (Vertical End)
             */
            wTemp = (WORD) rVideoRect.bottom - 1;
        }
        bRegCR38 = (BYTE)(wTemp >> 1);
        if (wTemp & 0x01)
            bRegCR39 |= 0x20;
        wTemp >>= 7;
        bRegCR39 |= (BYTE) (wTemp & 0x0C);
    }
    else
    {
        /*
         * Determine value in CR37 (Vertical Start)
         */
        wTemp = (WORD) rVideoRect.top;
        bRegCR37 = (BYTE) wTemp;
        wTemp >>= 8;
        bRegCR39 = (BYTE) wTemp;

        /*
         * Determine value in CR38 (Vertical End)
         */
        wTemp = (WORD) rVideoRect.bottom - 1;
        bRegCR38 = (BYTE) wTemp;
        wTemp >>= 6;
        bRegCR39 |= (BYTE) (wTemp & 0x0C);
    }
    /*
     * Determine values in CR3A, CR3B, CR3C (Start Address)
     */
    dwTemp = 0;


    if (bRegCR31 != 0)
    {
        //
        // overlay is zoomed, re-initialize zoom factor
        //
        CalculateStretchCode(ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left,
          ppdev->rOverlayDest.right - ppdev->rOverlayDest.left, ppdev->HorStretchCode);
    }

    //
    // Here, we want to ensure the source rectangle's clipped width is bigger
    // than what the HW can support, sigh!
    //
    if (!bOverlayTooSmall)
    {
        LONG   lSrcPels;

        //
        // compute non-clip amount on right edge
        //
        lSrcPels = rVideoRect.right - rVideoRect.left;

        if (bRegCR31 != 0)         // source is zoomed if non-zero
        {
            WORD  wRightCnt;

            wRightCnt = 0;
            while (lSrcPels > 0)
            {
                lSrcPels -= ppdev->HorStretchCode[wRightCnt];
                if (lSrcPels >= 0)
                {
                    wRightCnt++;
                }
            }
            lSrcPels = (LONG)wRightCnt;
        }

        if ((lSrcPels == 0) || (lSrcPels <= MIN_OLAY_WIDTH))
        {
            bOverlayTooSmall = TRUE;
        }
    }

    lLeft = ppdev->rOverlaySrc.left;
    if (dwFourcc == FOURCC_PACKJR)
    {
        lLeft &= ~0x03;
    }
    else if (dwFourcc == FOURCC_YUV422 || dwFourcc == FOURCC_YUY2 )
    {
        lLeft &= ~0x01;
    }

    //
    // dwTemp has adjusted dest. rect., add in source adjustment
    //
    dwTemp += (ppdev->rOverlaySrc.top * lPitch) + ((lLeft * wBitCount) >>3);

    ppdev->sOverlay1.lAdjustSource = dwTemp;
//    dwTemp += ((BYTE*)lpSurface->lpGbl->fpVidMem - ppdev->pjScreen); // sss
    dwTemp += (DWORD)(lpSurface->lpGbl->fpVidMem);

    bRegCR5D = (BYTE) ((dwTemp << 2) & 0x0C);
    dwTemp >>= 2;
    bRegCR3A = (BYTE) dwTemp & 0xfe;  // Align to even byte (5446 bug)
    dwTemp >>= 8;
    bRegCR3B = (BYTE) dwTemp;
    dwTemp >>= 8;
    bRegCR3C = (BYTE) (dwTemp & 0x0f);

    /*
     * Determine value in CR3D (Address Offset/Pitch)
     */
    wTemp = (WORD) (lPitch >> 3);
    if (lpSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
    {
        wTemp >>= 1;
    }
    bRegCR3D = (BYTE) wTemp;
    wTemp >>= 3;
    bRegCR3C |= (BYTE) (wTemp & 0x20);

    /*
     * Determine value in CR3E (Master Control Register)
     */
    bRegCR3E = 0;
    if (lpSurface->dwReserved1 & OVERLAY_FLG_ENABLED)
    {
        bRegCR3E = 0x01;
    }
    if (dwFourcc == FOURCC_PACKJR)
    {
        bRegCR3E |= 0x20;          // Always error difuse when using PackJR
    }
    if ((bRegCR32 == 0) || MustLineReplicate (ppdev, lpSurface, wBitCount))
    {
        bRegCR3E |= 0x10;
        lpSurface->dwReserved1 &= ~OVERLAY_FLG_INTERPOLATE;
    }
    else
    {
        lpSurface->dwReserved1 |= OVERLAY_FLG_INTERPOLATE;
    }
    if (dwFourcc == FOURCC_PACKJR)
    {
        bRegCR3E |= 0x02;
    }
    else if (dwFourcc == BI_RGB)
    {
        if (wBitCount == 16)
        {
            bRegCR3E |= 0x08;
        }
        else if (wBitCount == 8)
        {
            bRegCR3E |= 0x04;
        }
    }
    else if (dwFourcc == BI_BITFIELDS)
    {
        bRegCR3E |= 0x0A;
    }

    /*
     * If we are color keying, we will set that up now
     */
    if (lpSurface->dwReserved1 & OVERLAY_FLG_COLOR_KEY)
    {
        bRegCR3E |= 0x80;

        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
        bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Set CR1A[3:2] to timing ANDed w/ color
        bTemp &= ~0x0C;
        CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp);

        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1d);       // Clear CR1D[5:4]
        bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
        if (ppdev->cBitsPerPixel == 8)
        {
            CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x38);
            CP_OUT_WORD(pjPorts, INDEX_REG, (ppdev->wColorKey << 8) | 0x0c); // Output color to GRC
            CP_OUT_WORD(pjPorts, INDEX_REG, 0x0d);                     // Output color to GRD
        }
        else
        {
            CP_OUT_BYTE(pjPorts, CRTC_DATA, (bTemp & ~0x30) | 0x08);
            CP_OUT_WORD(pjPorts, INDEX_REG, (ppdev->wColorKey << 8) | 0x0c);    // Output color to GRC
            CP_OUT_WORD(pjPorts, INDEX_REG, (ppdev->wColorKey & 0xff00) | 0x0d);// Output color to GRD
        }
    }
    else if (lpSurface->dwReserved1 & OVERLAY_FLG_SRC_COLOR_KEY)
    {
        BYTE bYMax, bYMin, bUMax, bUMin, bVMax, bVMin;

        bRegCR3E |= 0x80;

        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
        bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Set CR1A[3:2] to timing ANDed w/ color
        bTemp &= ~0x0C;
        CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp);

        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1d);       // Set CR1D[5:4] to 10
        CP_OUT_BYTE(pjPorts, CRTC_DATA, CP_IN_BYTE(pjPorts, CRTC_DATA) | 0x20);

        /*
         * Determine min/max values
         */
        if ((dwFourcc == FOURCC_YUV422) ||
            (dwFourcc == FOURCC_YUY2) ||
            (dwFourcc == FOURCC_PACKJR))
        {
            bYMax = (BYTE)(DWORD)(ppdev->dwSrcColorKeyHigh >> 16);
            bYMin = (BYTE)(DWORD)(ppdev->dwSrcColorKeyLow >> 16);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 8) & 0xff);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 8) & 0xff);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh & 0xff);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow & 0xff);
            if (dwFourcc == FOURCC_PACKJR)
            {
                bYMax |= 0x07;
                bUMax |= 0x03;
                bVMax |= 0x03;
                bYMin &= ~0x07;
                bUMin &= ~0x03;
                bVMin &= ~0x03;
            }
        }
        else if ((dwFourcc == 0) && (wBitCount == 16))
        {
            /*
             * RGB 5:5:5
             */
            bYMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 7) & 0xF8);
            bYMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 7) & 0xF8);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 2) & 0xF8);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 2) & 0xF8);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh << 3);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow << 3);
            bYMax |= 0x07;
            bUMax |= 0x07;
            bVMax |= 0x07;

        }
        else if (dwFourcc == BI_BITFIELDS)
        {
            /*
             * RGB 5:6:5
             */
            bYMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 8) & 0xF8);
            bYMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 8) & 0xF8);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 3) & 0xFC);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 3) & 0xFC);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh << 3);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow << 3);
            bYMax |= 0x07;
            bUMax |= 0x03;
            bVMax |= 0x07;
        }

        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bYMin << 8) | 0x0C);  // GRC
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bYMax << 8) | 0x0D);  // GRD
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bUMin << 8) | 0x1C);  // GR1C
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bUMax << 8) | 0x1D);  // GR1D
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bVMin << 8) | 0x1E);  // GR1E
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bVMax << 8) | 0x1F);  // GR1F
    }
    else
    {
        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
        bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Clear CR1A[3:2]
        CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x0C);
    }

    /*
     * Set up alignment info
     */
    if (ppdev->cBitsPerPixel != 24)
    {
        WORD wXAlign;
        WORD wXSize;

        if (ppdev->cBitsPerPixel == 8)
        {
            wXAlign = (WORD)rVideoRect.left & 0x03;
            wXSize = (WORD)(rVideoRect.right - rVideoRect.left) & 0x03;
        }
        else
        {
            wXAlign = (WORD)(rVideoRect.left & 0x01) << 1;
            wXSize = (WORD)((rVideoRect.right - rVideoRect.left) & 0x01) << 1;
        }
        bRegCR5D |= (BYTE) (wXAlign | (wXSize << 4));
    }
    else
    {
        bRegCR5D = 0;
    }

    /*
     * Set up the FIFO threshold value.  Make sure that the value we use is
     * not less than the default value.
     */
    CP_OUT_BYTE(pjPorts, SR_INDEX, 0x16);
    bTemp = CP_IN_BYTE(pjPorts, SR_DATA) & 0x0f;
    if (bTemp > (ppdev->lFifoThresh & 0x0f))
    {
        ppdev->lFifoThresh = bTemp;
    }
    if (ppdev->lFifoThresh < 0x0f)
    {
        ppdev->lFifoThresh++;      // Eliminates possible errata
    }
    bRegCR5C = 0x10 | ((BYTE) ppdev->lFifoThresh & 0x0f);


    /*
     * Now start programming the registers
     */
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR31 << 8) | 0x31);   // CR31
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR32 << 8) | 0x32);   // CR32
    if (lpSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR)
    {
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) 0x10 << 8) | 0x3F);   // CR3F
    }
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR5C << 8) | 0x5C);   // CR5C

    //
    // disable overlay if overlay is too small to be supported by HW
    //
    if (bOverlayTooSmall)
    {
        bRegCR3E &= ~0x01;                                    // disable overlay
        ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;        // totally clipped
    }
    else
    {
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR33 << 8) | 0x33);   // CR33
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR34 << 8) | 0x34);   // CR34
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR35 << 8) | 0x35);   // CR35
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR36 << 8) | 0x36);   // CR36
//        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR37 << 8) | 0x37);   // CR37
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR38 << 8) | 0x38);   // CR38
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR39 << 8) | 0x39);   // CR39
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3A << 8) | 0x3A);   // CR3A
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3B << 8) | 0x3B);   // CR3B
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3C << 8) | 0x3C);   // CR3C
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3D << 8) | 0x3D);   // CR3D
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR5D << 8) | 0x5D);   // CR5D
        //
        // Write Vertical start first
        //
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR37 << 8) | 0x37);   // CR37
    }
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3E << 8) | 0x3E);   // CR3E
}


/**********************************************************
 *  Name: DisableOverlay_544x
 *
 *  Module Abstract:
 *  ----------------
 *  This is called when an overlay window is totally clipped by
 *  the panning viewport.
 **********************************************************/
VOID DisableOverlay_544x(PDEV* ppdev)
{
    WORD wCR3E;
    BYTE*   pjPorts = ppdev->pjPorts;

    ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;
    CP_OUT_BYTE(pjPorts, CRTC_INDEX,0x3e);            //Video Window Master Control
    wCR3E = CP_IN_WORD(pjPorts, CRTC_INDEX) & ~0x100; //clear bit one
    CP_OUT_WORD(pjPorts, CRTC_INDEX, wCR3E);          //disable overlay window
}


/**********************************************************
 *  Name: EnableOverlay_544x
 *
 *  Module Abstract:
 *  ----------------
 *  Show the overlay window.
 **********************************************************/
VOID EnableOverlay_544x(PDEV* ppdev)
{
    WORD wCR3E;
    BYTE*   pjPorts = ppdev->pjPorts;

    ppdev->dwPanningFlag &= ~OVERLAY_OLAY_REENABLE;
    CP_OUT_BYTE(pjPorts, CRTC_INDEX,0x3e);            //Video Window Master Control
    wCR3E = CP_IN_WORD(pjPorts, CRTC_INDEX) | 0x100;  //clear bit one
    CP_OUT_WORD(pjPorts, CRTC_INDEX, wCR3E);          //disable overlay window
}


/**********************************************************
*
*       Name:  ClearAltFIFOThreshold_544x
*
*       Module Abstract:
*       ----------------
*
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   02/03/97
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/
VOID ClearAltFIFOThreshold_544x(PDEV * ppdev)
{
    UCHAR    bTemp;

    BYTE*   pjPorts = ppdev->pjPorts;
    DISPDBG((1, "ClearAltFIFOThreshold"));

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x5c);          // Clear Alt FIFO Threshold
    bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x10);
}

/**********************************************************
*
*       Name:  RegMoveVideo
*
*       Module Abstract:
*       ----------------
*       This function is called to move the video window that has
*       already been programed.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID RegMoveVideo(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface)
{
    BOOL    bZoomX;
    DWORD   dwTemp;
    DWORD   dwFourcc;
    LONG    lLeft;
    LONG    lPitch;
    WORD    wTemp;
    WORD    wBitCount = 0;
    RECTL   rVideoRect;
    BYTE    bRegCR33;
    BYTE    bRegCR34;
    BYTE    bRegCR35;
    BYTE    bRegCR36;
    BYTE    bRegCR37;
    BYTE    bRegCR38;
    BYTE    bRegCR39;
    BYTE    bRegCR3A;
    BYTE    bRegCR3B;
    BYTE    bRegCR3C;
    BYTE    bRegCR3D;
    BYTE    bRegCR5D;
    BYTE    bTemp;
    BYTE*   pjPorts = ppdev->pjPorts;

    /*
     * Determine the format of the video data
     */
    if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        GetFormatInfo(ppdev, &(lpSurface->lpGbl->ddpfSurface),
            &dwFourcc, &wBitCount);
    }
    else
    {
        // This needs to be changed when primary surface is RGB 5:6:5
        dwFourcc = BI_RGB;
        wBitCount = (WORD) ppdev->cBitsPerPixel;
    }

    rVideoRect = ppdev->rOverlayDest;
    //
    // rVideoRect is now adjusted and clipped to the panning viewport.
    // Disable overlay if totally clipped by viewport.
    //
    if (((rVideoRect.right - rVideoRect.left) <= 0) ||
        ((rVideoRect.bottom- rVideoRect.top ) <= 0))
    {
       DisableOverlay_544x(ppdev);  // #ew1 cannot display below min. overlay size
       return;
    }

    lPitch = lpSurface->lpGbl->lPitch;

    /*
     * Determine value in CR33 (Region 1 Size)
     */
    wTemp = (WORD) rVideoRect.left;
    if (ppdev->cBitsPerPixel == 8)
    {
        wTemp >>= 2;     // 4 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        wTemp >>= 1;     // 2 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        wTemp *= 3;
        wTemp /= 4;
    }
    bRegCR33 = (BYTE) wTemp;
    bRegCR36 = (BYTE) (WORD) (wTemp >> 8);

    /*
     * Determine value in CR34 (Region 2 size)
     */
    wTemp = (WORD) (rVideoRect.right - rVideoRect.left);
    if (ppdev->cBitsPerPixel == 8)
    {
        wTemp >>= 2;                           // 4 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        wTemp >>= 1;                           // 2 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        wTemp *= 3;
        wTemp /= 4;
    }
    bRegCR34 = (BYTE) wTemp;
    wTemp >>= 6;
    bRegCR36 |= (BYTE) (wTemp & 0x0C);

    /*
     * Determine value in CR35 (Region 2SD Size)
     */
    dwTemp = (DWORD) (rVideoRect.right - rVideoRect.left);
    dwTemp *= (DWORD) (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left);
    dwTemp /= (DWORD) (ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
    wTemp = (WORD) dwTemp;
    if ((dwFourcc == FOURCC_PACKJR) || (wBitCount == 8))
    {
        wTemp >>= 2;                           // 4 Pixels per DWORD
    }
    else
    {
        wTemp >>= 1;                           // 2 Pixels per DWORD
    }
    bRegCR35 = (BYTE) wTemp;
    wTemp >>= 4;
    bRegCR36 |= (BYTE) (wTemp & 0x30);

    //
    // Check double scan line counter feature
    //
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x17);
    bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    if (bTemp & 0x04)
    {
        //
        // Double scan line count
        //
        /*
         * Determine value in CR37 (Vertical Start)
         */
        wTemp = (WORD) rVideoRect.top;
        bRegCR37 = (BYTE)(wTemp >> 1);
        if ( wTemp & 0x01 )
        {
            wTemp >>= 9;
            bRegCR39 = (BYTE) wTemp | 0x10;
            //
            // Odd scan line trigger
            // Hardware has a bug now.
            // So reduce dest end by 1
            //
            wTemp = (WORD) rVideoRect.bottom - 1 - 1;
        }
        else
        {
            wTemp >>= 9;
            bRegCR39 = (BYTE) wTemp;
            /*
             * Determine value in CR38 (Vertical End)
             */
            wTemp = (WORD) rVideoRect.bottom - 1;
        }
        bRegCR38 = (BYTE)(wTemp >> 1);
        if (wTemp & 0x01)
            bRegCR39 |= 0x20;
        wTemp >>= 7;
        bRegCR39 |= (BYTE) (wTemp & 0x0C);
    }
    else
    {
        /*
         * Determine value in CR37 (Vertical Start)
        */
        wTemp = (WORD) rVideoRect.top;
        //if (ppdev->bDoubleClock)
        //{
        //    wTemp >>= 1;
        //}
        bRegCR37 = (BYTE) wTemp;
        wTemp >>= 8;
        bRegCR39 = (BYTE) wTemp;

        /*
         * Determine value in CR38 (Vertical End)
        */
        wTemp = (WORD) rVideoRect.bottom - 1;
        //if (ppdev->bDoubleClock)
        //{
        //    wTemp >>= 1;
        //}
        bRegCR38 = (BYTE) wTemp;
        wTemp >>= 6;
        bRegCR39 |= (BYTE) (wTemp & 0x0C);
    }


    /*
     * Determine values in CR3A, CR3B, CR3C (Start Address)
     */
    dwTemp = 0;


    bZoomX = ((ppdev->rOverlayDest.right - ppdev->rOverlayDest.left) !=
             (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left));

    if (bZoomX)
    {
       //
       // overlay is zoomed, re-initialize zoom factor
       //
       CalculateStretchCode(ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left,
          ppdev->rOverlayDest.right - ppdev->rOverlayDest.left, ppdev->HorStretchCode);
    }


    //
    // Here, we want to ensure the source rectangle's clipped width is bigger
    // than what the HW can support, sigh!
    //
//    if (grOverlayDest.right > sData->rViewport.right)
    {
       int   iSrcPels;

       //
       // compute non-clip amount on right edge
       //
       iSrcPels = (int)(rVideoRect.right - rVideoRect.left);

       if (bZoomX)
       {
          WORD  wRightCnt;

          wRightCnt = 0;
          while (iSrcPels > 0)
          {
             iSrcPels -= ppdev->HorStretchCode[wRightCnt];
             if (iSrcPels >= 0)
             {
                wRightCnt++;
             }
          }
          iSrcPels = (int)wRightCnt;
       }

       if ((iSrcPels == 0) || (iSrcPels <= MIN_OLAY_WIDTH))
       {
          DisableOverlay_544x(ppdev);  // cannot display below min. overlay size
          return;
       }
     }


    lLeft = ppdev->rOverlaySrc.left;
    if (dwFourcc == FOURCC_PACKJR)
    {
        lLeft &= ~0x03;
    }
    else if (dwFourcc == FOURCC_YUV422 || dwFourcc == FOURCC_YUY2)
    {
        lLeft &= ~0x01;
    }

    //
    // #ew1 dwTemp has adjusted dest. rect., add in source adjustment
    //
    dwTemp += (ppdev->rOverlaySrc.top * lPitch) + ((lLeft * wBitCount) >>3);

    ppdev->sOverlay1.lAdjustSource = dwTemp;

//    dwTemp += ((BYTE*)lpSurface->lpGbl->fpVidMem - ppdev->pjScreen); // sss
    dwTemp += (DWORD)(lpSurface->lpGbl->fpVidMem);

    bRegCR5D = (BYTE) ((dwTemp << 2) & 0x0C);
    dwTemp >>= 2;
    bRegCR3A = (BYTE) dwTemp & 0xfe;  // Align to even byte (5446 bug)
    dwTemp >>= 8;
    bRegCR3B = (BYTE) dwTemp;
    dwTemp >>= 8;
    bRegCR3C = (BYTE) (dwTemp & 0x0f);

    /*
     * Determine value in CR3D (Address Offset/Pitch)
     */
    wTemp = (WORD) (lPitch >> 3);
    if (lpSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
    {
        wTemp >>= 1;
    }
    bRegCR3D = (BYTE) wTemp;
    wTemp >>= 3;
    bRegCR3C |= (BYTE) (wTemp & 0x20);

    /*
     * Set up alignment info
     */
    if (ppdev->cBitsPerPixel != 24)
    {
        WORD wXAlign;
        WORD wXSize;

        if (ppdev->cBitsPerPixel == 8)
        {
            wXAlign = (WORD)rVideoRect.left & 0x03;
            wXSize = (WORD)(rVideoRect.right - rVideoRect.left) & 0x03;
        }
        else
        {
            wXAlign = (WORD)(rVideoRect.left & 0x01) << 1;
            wXSize = (WORD)((rVideoRect.right - rVideoRect.left) & 0x01) << 1;
        }
        bRegCR5D |= (BYTE) (wXAlign | (wXSize << 4));
    }

    /*
     * Now we will write the actual register values.
     */
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR33 << 8) | 0x33);   // CR33
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR34 << 8) | 0x34);   // CR34
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR35 << 8) | 0x35);   // CR35
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR36 << 8) | 0x36);   // CR36
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR38 << 8) | 0x38);   // CR38
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR39 << 8) | 0x39);   // CR39
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3A << 8) | 0x3A);   // CR3A
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3B << 8) | 0x3B);   // CR3B
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3C << 8) | 0x3C);   // CR3C
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3D << 8) | 0x3D);   // CR3D
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR5D << 8) | 0x5D);   // CR5D
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR37 << 8) | 0x37);   // CR37

    if (ppdev->dwPanningFlag & OVERLAY_OLAY_REENABLE)
       EnableOverlay_544x(ppdev);
}


/**********************************************************
*
*       Name:  CalculateStretchCode
*
*       Module Abstract:
*       ----------------
*       This code was originally written by Intel and distributed
*       with the DCI development kit.
*
*       This function takes the zoom factor and determines exactly
*       how many times we need to replicate each row/column.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Intel
*       Date:   ??/??/??
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*       Scott MacDonald 10/06/94 Incorporated code into DCI provider.
*
*********************************************************/

VOID CalculateStretchCode (LONG srcLength, LONG dstLength, LPBYTE code)
{
    LONG  dwDeltaX, dwDeltaY, dwConst1, dwConst2, dwP;
    LONG  i, j, k;
    BYTE  bStretchIndex = 0;
    LONG  total = 0;

    /*
     * for some strange reason I'd like to figure out but haven't got time to, the
     * replication code generation seems to have a problem between 1:1 and 2:1 stretch
     * ratios.  Fix is to zero-initialize index (the problem occurs in the first one
     * generated) when stretch is betw. those ratios, and one-initialize it otherwise.
     */
    if ((dstLength <= srcLength * 2L) && (dstLength >= srcLength))
    {
         bStretchIndex = 0;
    }
    else
    {
         bStretchIndex = 1;
    }

    /*
     * initialize code array, to get rid of anything which might have been
     * left over in it.
     */
    for (i = 0; i < srcLength; i++)
    {
         code[i] = 0;
    }

    /*
     * Variable names roughly represent what you will find in any graphics
     * text.  Consult text for an explanation of Bresenham line alg., it's
     * beyond the scope of my comments here.
     */
    dwDeltaX = srcLength;
    dwDeltaY = dstLength;

    if (dstLength < srcLength)
    {
         /*
          * Size is shrinking, use standard Bresenham alg.
          */
         dwConst1 = 2L * dwDeltaY;
         dwConst2 = 2L * (dwDeltaY - dwDeltaX);
         dwP = 2L * dwDeltaY - dwDeltaX;

         for (i = 0; i < dwDeltaX; i++)
         {
              if (dwP <= 0L)
              {
                   dwP += dwConst1;
              }
              else
              {
                   dwP += dwConst2;
                   code[i]++;
                   total++;
              }
         }
    }
    else
    {
         /*
          * Size is increasing.  Use Bresenham adapted for slope > 1, and
          * use a loop invariant to generate code array.  Run index i from
          * 0 to dwDeltaY - 1, and when i = dwDeltaY - 1, j will
          * be = dwDeltaX - 1.
          */
         dwConst1 = 2L * dwDeltaX;
         dwConst2 = 2L * (dwDeltaX - dwDeltaY);
         dwP = 2L * dwDeltaX - dwDeltaY;
         j = 0;

         for (i = 0; i < dwDeltaY; i++)
         {
              if (dwP <= 0L)
              {
                   dwP += dwConst1;
                   bStretchIndex++;
              }
              else
              {
                   dwP += dwConst2;
                   code[j++] = ++bStretchIndex;
                   bStretchIndex = 0;
                   total += (int)code[j - 1];
              }
         }

         /*
          * UGLY fix up for wacky bug which I have no time to fix properly.
          * The 'total' of entries is messed up for slopes > 4, so add the
          * difference back into the array.
          */
         if (total < dwDeltaY)
         {
              while (total < dwDeltaY)
              {
                   j = (int)dwDeltaY - total;
                   k = (int)dwDeltaY / j;
                   for (i = 0; i < dwDeltaX; i++)
                   {
                        if (!(i % k) && (total < dwDeltaY))
                        {
                             code[i]++;
                             total++;
                        }
                   }
              }
         }
    }
}


/**********************************************************
*
*       Name:  GetThresholdValue
*
*       Module Abstract:
*       ----------------
*       Determines the best threshold for the specified
*       surface.
*
*       Output Parameters:
*       ------------------
*       Threshold
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/95
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

BYTE GetThresholdValue(VOID)
{
    return ((BYTE) 0x0A);
}


/**********************************************************
*
*       Name:  MustLineRelicate
*
*       Module Abstract:
*       ----------------
*       Checks to see if we must line replicate or if we can
*       interpolate.
*
*       Output Parameters:
*       ------------------
*       TRUE/FALSE
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

BOOL MustLineReplicate (PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface, WORD wVideoDepth)
{
    LONG lTempThresh;

    /*
     * If we are double clocking the data (1280x1024 mode), we must
     * replicate.  We should also always replicate in Performance mode
     */
    if (ppdev->bDoubleClock)
    {
        return (TRUE);
    }

                                //
    // Check the VCLK
    //
    // sge07
    if (GetVCLK(ppdev) > 130000)
    {
        return (TRUE);
    }

    /*
     * If we are using the chroma key feature, we can't interpolate
     */
    if (lpSurface->dwReserved1 & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))
    {
         return (TRUE);
    }

    lTempThresh = ppdev->lFifoThresh;
    if (ppdev->pfnIsSufficientBandwidth(ppdev, wVideoDepth,
        &ppdev->rOverlaySrc, &ppdev->rOverlayDest, OVERLAY_FLG_INTERPOLATE))
    {
        ppdev->lFifoThresh = lTempThresh;
        return (FALSE);
    }
    ppdev->lFifoThresh = lTempThresh;

    return (TRUE);
}


/**********************************************************
*
*       Name:  IsSufficientBandwidth
*
*       Module Abstract:
*       ----------------
*       Determines is sufficient bandwidth exists for the requested
*       configuration.
*
*       Output Parameters:
*       ------------------
*       TRUE/FALSE
*       It also sets the global parameter lFifoThresh, which gets
*       programed in RegInitVideo().
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

BOOL IsSufficientBandwidth(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags)
{
    LONG lVideoPixelsPerDWORD;
    LONG lGraphicsPixelsPerDWORD;
    LONG lVCLKPeriod;
    LONG lTransferTime;
    LONG lDWORDsWritten;
    LONG lZoom;
    LONG lReadPeriod;
    LONG lEffReadPeriod;
    LONG lWritePeriod;
    LONG lEffWritePeriod;
    LONG K1,K2;
    LONG lTrFifoAFirst4;
    LONG lTrFifoB2;
    LONG lDWORDsRead;
    LONG lFifoAReadPeriod;
    LONG lFifoBReadPeriod;
    LONG lFifoAEffWritePeriod;
    LONG lFifoBEffWritePeriod;
    LONG lFifoALevels;
    LONG lFifoBLevels;
    LONG lFifoAThresh;
    LONG lFifoBThresh;
    LONG lVCLK;

    BYTE*   pjPorts = ppdev->pjPorts;

//#define BLIT_LATENCY  8
#define CRT_FIFO_DEPTH 28

    //
    // Add 8 clock for BLT_LATENCY for 54446BE and later chips
    //
    // sge04

    LONG BLIT_LATENCY = 8;
    if (ppdev->flCaps & CAPS_SECOND_APERTURE)
        BLIT_LATENCY += 2;

    /*
     * Convert input parameters
     */
    if (wVideoDepth == 16)
    {
        lVideoPixelsPerDWORD = 2;
    }
    else
    {
        lVideoPixelsPerDWORD = 4;
    }

    if (ppdev->cBitsPerPixel == 8)
    {
        lGraphicsPixelsPerDWORD = 4;
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        lGraphicsPixelsPerDWORD = 2;
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        lGraphicsPixelsPerDWORD = 1;
    }
    else
        return (FALSE);

    lZoom = ((lpDest->right - lpDest->left) * 256) /
        (lpSrc->right - lpSrc->left);

    /*
     * If we are double clocked, fail if we are not zoomed at least 2X
     */
    if (ppdev->bDoubleClock && (lZoom < 512))
    {
        return (FALSE);
    }

    /*
     * We need to get the VCLK every time since this can change
     * at run-time
     */
    lVCLK = GetVCLK(ppdev);
    if (lVCLK == 0)
    {
        return (FALSE);
    }
    lVCLKPeriod = (LONG) ((1000000/lVCLK) + 1);

    /*
     * We only need to setup the following variables once!
     */
    if (!ppdev->lBusWidth)
    {
        /*
         * We will read the bus width from SR0F[4:3]
         */
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x0F);
        if ((CP_IN_BYTE(pjPorts, SR_DATA) & 0x18) == 0x18)
        {
            ppdev->lBusWidth = 8;  // 64 bit bus
        }
        else
        {
            ppdev->lBusWidth = 4;  // 32 bit bus
        }
    }
    if (!ppdev->lRandom)
    {
        /*
         * Is this EDO or regular?
         */
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x0f);
        if (!(CP_IN_BYTE(pjPorts, SR_DATA) & 0x4))
        {
            ppdev->lRandom   = 7;
            ppdev->lPageMiss = 7;
        }
        else
        {
            ppdev->lRandom   = 6;
            ppdev->lPageMiss = 6;
        }
    }

    if (!ppdev->lMCLKPeriod)
    {
        LONG lMCLK;

        /*
         * The MCLK period is the amount of time required for one cycle.
         * We will round up.
         */
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x1f);   // First get the MCLK frequency
        lMCLK = CP_IN_BYTE(pjPorts, SR_DATA);
        lMCLK *= 14318;
        lMCLK >>= 3;
        ppdev->lMCLKPeriod = ((1000000/lMCLK) + 1);
    }

    /*
     * Check for the case with no color key or Y interpolation
     */
    if (dwFlags == 0)
    {
        /*
         * This mode utilizes only FIFO A. The fifo is filled with
         * graphics data during regions 1 and 3, and video data during
         * region 2.
         *
         * The normal memory sequence for this mode goes as follows.
         *
         *      ------------------------------------------------
         *     | cpu/blit cycle | FIFO A fill   | cpu/blit cycle ....
         *      ------------------------------------------------
         *
         *     The cpu/blit cycle is interrupted when the CRT
         *     fifo is depleted to its threshold. Once the
         *     crt cycle is started, it continues until the
         *     FIFO A is full.
         *
         *     Worst case condition for filling the CRT fifo :
         *
         *     1) CPU/blit latency ->
         *     2)  Random cycle for region 2 video ->
         *     3)   Page miss for region 2 video ->
         *     4)    Page miss for region 2 to region 3 transition ->
         *     5)     Page miss for region 3 graphics
         *
         *     Conditions 3 and 5 depend on the location of the
         *     graphic screen within display memory. For 1024x768, where
         *     the graphics screen starts at location 0 and is offset by
         *     1024 or 2048 bytes each line, condition 5 is never met.
         *     If a video window starts at beginning of a memory page,
         *     and is offset at the beggining of each line by an even
         *     multiple of a memory page, condition 3 is never met.
         *
         *     Based on this worst case condition, the amount of time
         *     required to complete 4 transfers into the crt fifo
         *     is approximately:
         *        lTransferTime = (BLIT_LATENCY + lRandom + 3*(lPageMiss)) *
         *                         lMCLKPeriod.
         *        the number of dwords transferred to the fifo
         *        during this time is 4 for 32 bit memory interface
         *        or 8 for 64 bit interface.
         *        lDWORDsWritten = 4 * (lBusWidth/4)
         *
         *     During this period, data continues to be read from the crt
         *     fifo for screen refresh. The amount of data read,
         *     assuming a 1x scale is approximately:
         *        lDWORDsRead = tr_time/(lVideoPixelsPerDWORD * lVCLKPeriod)
         *
         *     The difference between the dwords read and dwords
         *     written must be accounted for in the fifo trheshold setting
         *
         *     lFifoThresh = (lDWORDsRead - lDWORDsWritten) rounded
         *                 up to next even value.
         *
         *     To determine if there is adequate bandwidth to support
         *     the mode, the lFifoThresh must not exceed the fifo depth.
         *     For the mode to work, the fifo read rate must not exceed the
         *     fifo write rate.
         *        read_rate = min(lGraphicsPixelsPerDWORD,lVideoPixelsPerDWORD) * lVCLKPeriod.
         *        write_rate = lMCLKPeriod * 2;  -- 2 clocks per cas
         *
         * A special case occurs if the fifo read rate is very close to the peak
         * fifo write rate. In this case the crt fill may result in a continuous
         * page cycle for the entire active line. This could result in 1 extra
         * page miss at the start of region2. To account for this, I will
         * add 3 DWORDS to the trheshold if the read and write rates are very close
         * (arbitrarily defined as within 10% of each other.
         *
         * Zooming
         *  Some modes can only be supported at video scale factors greater than 1X.
         *  Even when the video is zoomed, a small number of  dwords must be read
         *  from the crt fifo at the unzoomed rate in order to prime the video
         *  pipeline. The video pipeline requires 10 pixel before it slows the fifo
         *  reads to the zoomed rate.
         *
         *                    tr_time - (lVCLKPeriod * 10/lVideoPixelsPerDWORD)
         *    lDWORDsRead =   --------------------------------------------- + 10/lVideoPixelsPerDWORDord
         *                    (lVideoPixelsPerDWORD * lVCLKPeriod * lZoom)
         */
        lTransferTime = (BLIT_LATENCY + ppdev->lRandom + (3*(ppdev->lPageMiss))) *
            ppdev->lMCLKPeriod;

        lDWORDsWritten = 3 * (ppdev->lBusWidth/4);

        /*
         * If read rate exceeds write rate, calculate minumum zoom
         * to keep everything as ints, spec the zoom as 256 times
         * the fractional zoom
         */
        lWritePeriod = ppdev->lMCLKPeriod * 2/(ppdev->lBusWidth/4);
        lReadPeriod   = lVideoPixelsPerDWORD * lVCLKPeriod;

        /*
         * Pick worst case of graphics and video depths for calculation
         * of dwords read. This may be a little pessimistic for the
         * when the graphics bits per pixel exceeds the video bits per pixel.
         */
        lEffReadPeriod = (lVideoPixelsPerDWORD * lVCLKPeriod * lZoom)/256;
        if (lEffReadPeriod < lWritePeriod)
        {
            /*
             * Cannot support overlay at this zoom factor
             */
            return (0);
        }

        if (lGraphicsPixelsPerDWORD > lVideoPixelsPerDWORD)   // handle zoom factor
        {
            lDWORDsRead =   ((lTransferTime -
                (lVCLKPeriod * 10/lVideoPixelsPerDWORD))/
                (lEffReadPeriod)) +
                (10 / lVideoPixelsPerDWORD) + 1;
        }
        else
        {
            lDWORDsRead    = (lTransferTime/
                (lGraphicsPixelsPerDWORD * lVCLKPeriod)) + 1;
        }

        // Calculate the fifo threshold setting
        ppdev->lFifoThresh = lDWORDsRead - lDWORDsWritten;

        // if read rate is within 10% of write rate, up by 3 dwords
        if ((11*lEffReadPeriod) < ((10*lWritePeriod*256)/lZoom))
        {
            ppdev->lFifoThresh += 3;
        }

        // fifo trheshold spec'd in QWORDS, so round up by 1 and divide by 2)
        ppdev->lFifoThresh = (ppdev->lFifoThresh + 1)/2;

        // Add a extra QWORD to account for fifo level sync logic
        ppdev->lFifoThresh = ppdev->lFifoThresh + 1;
        if (ppdev->bDoubleClock)
        {
            ppdev->lFifoThresh <<= 1;
        }

        if ((ppdev->lFifoThresh >= CRT_FIFO_DEPTH) ||
            ((lEffReadPeriod) < lWritePeriod))
        {
            return (0);
        }
        else
        {
            return (1);
        }
    }

    /*
     * Check bandwidth for Y Interpolation
     */
    else if (dwFlags & OVERLAY_FLG_INTERPOLATE)
    {
        /*
         * This mode utilizes both FIFOs A and B. During horizontal blank,
         * both fifos are filled.  FIFO a is then filled with graphics
         * data during regions 1 and 3, and video data during region 2.
         * FIFO B is filled with video data during region 2, and is idle
         * during regions 1 and 3.
         *
         * The normal memory sequence for this mode goes as follows.
         *
         *      ----------------------------------------------------------------
         *     | cpu/blit cycle | FIFO A fill   | FIFO B fill | cpu/blit cycle .
         *      ----------------------------------------------------------------
         *     or
         *      ----------------------------------------------------------------
         *     | cpu/blit cycle | FIFO B fill   | FIFO A fill | cpu/blit cycle .
         *      ----------------------------------------------------------------
         *
         * For this mode, the FIFO threshold must be set high enough to allow
         * enough time to abort the cpu/blt, fill FIFO A, then transfer data
         * into FIFO B before underflow occurs.
         *
         * Worst case condition for filling the CRT fifo :
         *
         * 1) CPU/blit latency ->
         * 2) FIFO A random cycle for region 2 video ->
         * 3) FIFO A page miss for region 2 video ->
         * 4) FIFO A page miss for region 2 to region 3 transition ->
         * 5) FIFO A page miss for region 3 graphics
         * 6) FIFO A page mode fill
         * 7) FIFO B random cycle
         * 8) FIFO B page miss
         *
         * lTransferTime = lMCLKPeriod *
         *                 (BLIT_LATENCY + lRandom + 3*(lPageMiss) +
         *                 fifoa_remaining +
         *                 lRandom + lPageMiss;
         *
         *
         * The time required to fill FIFO A depends upon the read rate
         * of FIFO A and the number of levels that must be filled,
         * as determined by the threshold setting.
         *
         * The worst case fill time for the first four levels of fifo A is
         *   lTrFifoAFirst4   = (BLIT_LATENCY + lRandom + 3*(lPageMiss)) *
         *                        lMCLKPeriod;
         *
         * The number of dwords depleted from fifo A during the
         * fill of the first four levels is
         *     lReadPeriod        = lVCLKPeriod * lVideoPixelsPerDWORD * lZoom;
         *     fifoa_reads_4      = lTrFifoAFirst4/lReadPeriod;
         *
         * The number of empty levels remaining in the fifo after
         * the fill of the first four levels is
         *     fifoa_remaining = FIFO_DEPTH - lFifoThresh + ((4*ramwidth)/4)
         *                       - lTrFifoAFirst4/lReadPeriod;
         *
         * The amount of time required to fill the remaining levels of
         * fifo A is determined by the write rate and the read rate.
         *    lWritePeriod = lMCLKPeriod * 2; // 2 clks per cas
         *    lEffWritePeriod = ((lReadPeriod * lWritePeriod)/
         *                       (lReadPeriod - lWritePeriod));
         *
         *    tr_fifoa_remaining = fifoa_remaining * lEffWritePeriod;
         *
         *
         * The total amount of time for the cpu/blt latency and the
         * fifo A fill is
         *    tr_fifoa_total = lTrFifoAFirst4  + tr_fifoa_remaining;
         *
         * The worse case fill time for fifo B is as follows:
         *    lTrFifoB2 = (lRandom + lPageMiss) * lMCLKPeriod;
         *
         * The total amount of time elapsed from the crt request until
         * the first 2 fifob cycles are completed is
         *    lTransferTime = tr_fifoa_total + lTrFifoB2;
         *
         * The number of dwords transferred to the fifo during this
         * time is 2 for 32 bit memory interface or 4 for 64 bit interface.
         *    lDWORDsWritten = 2 * (lBusWidth/4)
         *
         * During this period, data continues to be read from the crt
         * fifo B for screen refresh. The amount of data read,
         * is approximately:
         *    dwords_read = lTransferTime/lReadPeriod
         *
         * The difference between the dwords read and dwords
         * written must be accounted for in the fifo trheshold setting
         *
         *    lFifoThresh = (dwords_read - lDWORDsWritten) rounded
         *               up to next even value.
         *
         * Since the lTransferTime and dwords_read depends on
         * the threshold setting, a bit of algebra is required to determine
         * the minimum setting to prevent fifo underflow.
         *
         *    lFifoThresh = (lTransferTime/lReadPeriod) - lDWORDsWritten;
         *             = ((tr_fifoa_4 + lTrFifoB2 + tr_fifoa_remaining)/lReadPeriod)
         *               - lDWORDsWritten
         * to simplify calcuation, break out constant part of equation
         *    K1        = ((tr_fifoa_4 + lTrFifoB2)/lReadPeriod) - lDWORDsWritten;
         *
         *    lFifoThresh =  K1 + (tr_fifoa_remaining/lReadPeriod);
         *             =  K1 + (fifoa_remaining * lEffWritePeriod)/lReadPeriod;
         *    lFifoThresh =  K1 +
         *                ((FIFO_DEPTH - lFifoThresh + 4 - (lTrFifoAFirst4/lReadPeriod)) *
         *                 lEffWritePeriod)/lReadPeriod;
         *
         * break out another constant to simplify reduction
         *    K2       =  (FIFO_DEPTH + 4 - (lTrFifoAFirst4/lReadPeriod))
         *                * (lEffWritePeriod/lReadPeriod);
         *    lFifoThresh = K1 + K2 - (lFifoThresh * (lEffWritePeriod/lReadPeriod));
         *    lFifoThresh * (1 +  (lEffWritePeriod/lReadPeriod)) = K1 + K2;
         *    lFifoThresh = (K1 + K2)/(1 +  (lEffWritePeriod/lReadPeriod);
         *
         * Once the threshold setting is determined, another calculation must
         * be performed to determine if available bandwidth exists given the
         * zoom factor. The worst case is assumed to be when FIFO A and
         * FIFO B reach the threshold point at the same time. The sequence
         * is then to abort the cpu/blt, fill fifo a, then fill fifo b.
         *
         * Since FIFO A is full when the fill B operation starts, I only have
         * to determine how long it takes to fill FIFO B and then calculate
         * the the number of dwords read from A during that time.
         *
         *   lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * lEffWritePeriod))/lReadPeriod;
         *   lFifoALevels = CRT_FIFO_DEPTH - (lTransferTime/lReadPeriod);
         *
         * if lFifoALevels < 1, then underflow condition may occur.
         */
        if (lZoom < 512)
        {
            // 5446 requires at least a 2X zoom for Y interpolation
            return (FALSE);
        }

        lWritePeriod = ppdev->lMCLKPeriod * 2/(ppdev->lBusWidth/4);
        lReadPeriod  = (lVideoPixelsPerDWORD * lVCLKPeriod * lZoom)/256;

        lEffWritePeriod = ((lReadPeriod * lWritePeriod)/
                           (lReadPeriod - lWritePeriod));
        lTrFifoAFirst4 = (BLIT_LATENCY + ppdev->lRandom + 3*(ppdev->lPageMiss)) *
                          ppdev->lMCLKPeriod;
        lTrFifoB2 = (ppdev->lRandom + ppdev->lPageMiss) * ppdev->lMCLKPeriod;

        lDWORDsWritten = 2 * (ppdev->lBusWidth/4);
        K1 = ((lTrFifoAFirst4 + lTrFifoB2)/lReadPeriod) - lDWORDsWritten;
        K2 = (CRT_FIFO_DEPTH + (4*(ppdev->lBusWidth/4)) -
             (lTrFifoAFirst4/lReadPeriod))
             * (lEffWritePeriod/lReadPeriod);
        ppdev->lFifoThresh = (1 + ((K1 + K2)/(1 +  (lEffWritePeriod/lReadPeriod))));

        ppdev->lFifoThresh += 3;

        lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * lEffWritePeriod));
        lFifoALevels = ((CRT_FIFO_DEPTH - (lTransferTime/lReadPeriod))/2);
        if (ppdev->bDoubleClock)
        {
            ppdev->lFifoThresh <<= 1;
        }

        if ((lFifoALevels < 2) || (ppdev->lFifoThresh > (CRT_FIFO_DEPTH/2)))
        {
            return (0);
        }
        else
        {
            return (1);
        }
    }

    /*
     * Check bandwidth for color keying
     */
    else if (dwFlags & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))
    {
        /*
         * This mode utilizes both FIFOs A and B.  During horizontal blank,
         * both fifos are filled.  FIFO a is then filled with graphics data
         * during regions 1,2 and 3.  FIFO B is filled with video data
         * during region 2, and is idle during regions 1 and 3.
         *
         * The normal memory sequence for this mode goes as follows.
         *
         *      ----------------------------------------------------------------
         *     | cpu/blit cycle | FIFO A fill   | FIFO B fill | cpu/blit cycle .
         *      ----------------------------------------------------------------
         *     or
         *      ----------------------------------------------------------------
         *     | cpu/blit cycle | FIFO B fill   | FIFO A fill | cpu/blit cycle .
         *      ----------------------------------------------------------------
         *
         * For this mode, the FIFO threshold must be set high enough to allow
         * enough time to abort the cpu/blt, fill FIFO A, then transfer data
         * into FIFO B before underflow occurs. If the fifob read rate is
         * greater than the fifoa read rate, then allow eough time for
         * a t CPU/blt abort, followed by a fifo B fill, then a FIFO A fill.
         *
         * Worst case condition for filling the CRT fifo :
         *
         *   1) CPU/blit latency ->
         *   2) FIFO A random  ->
         *   3) FIFO A page miss  ->
         *   6) FIFO A page mode fill -->
         *   7) FIFO B random  -->
         *   8) FIFO B page miss
         *
         *  or
         *
         *   1) CPU/blit latency ->
         *   2) FIFO B random  ->
         *   3) FIFO A page miss  ->
         *   6) FIFO A page mode fill -->
         *   7) FIFO B random -->
         *   8) FIFO B page miss
         *
         *
         * 1)  lTransferTime = lMCLKPeriod *
         *                   (BLIT_LATENCY + lRandom + lPageMiss +
         *                    fifoa_remaining +
         *                    lRandom + lPageMiss;
         *
         * or
         * 2)  lTransferTime = lMCLKPeriod *
         *                   (BLIT_LATENCY + lRandom + lPageMiss +
         *                    fifob_remaining +
         *                    lRandom + lPageMiss;
         *
         *
         *     lFifoAReadPeriod  = lVCLKPeriod * lGraphicsPixelsPerDWORD;
         *     lFifoBReadPeriod  = (lVCLKPeriod * lVideoPixelsPerDWORD * lZoom)*256;
         *
         * if (lFifoAReadPeriod > lFifoBReadPeriod), then
         * first fifo is fifo B, otherwise first is fifo A.
         * The followinf euqations are written for a fifoa->fifob,
         * sequence, but the fifob->fifoa sequence can be obtained simply
         * by swapping the fifo read periods.
         *
         * The time required to fill a FIFO depends upon the read rate
         * of the FIFO and the number of levels that must be filled,
         * as determined by the threshold setting.
         *
         * The worst case fill time for the first four levels of fifo A is
         *     lTrFifoAFirst4   = (BLIT_LATENCY + lRandom + lPageMiss) *
         *                          lMCLKPeriod;
         *
         * The number of dwords depleted from fifo A during the
         *   fill of the first four levels is
         *     fifoa_reads_4      = lTrFifoAFirst4/lFifoAReadPeriod;
         *
         * The number of empty levels remaining in the fifo after
         * the fill of the first four levels is
         *     fifoa_remaining = FIFO_DEPTH - lFifoThresh + ((4*ramwidth)/4)
         *                             - lTrFifoAFirst4/lFifoAReadPeriod;
         *
         * The amount of time required to fill the remaining levels of
         * fifo A is determined by the write rate and the read rate.
         *     lWritePeriod = lMCLKPeriod * 2; * 2 clks per cas
         *     eff_write_period = ((lFifoAReadPeriod * lWritePeriod)/
         *                           (lFifoAReadPeriod - lWritePeriod));
         *
         *     tr_fifoa_remaining = fifoa_remaining * eff_write_period;
         *
         *
         * The total amount of time for the cpu/blt latency and the
         * fifo A fill is
         *     tr_fifoa_total = lTrFifoAFirst4  + tr_fifoa_remaining;
         *
         * The worse case fill time for fifo B is as follows:
         *     lTrFifoB2 = (lRandom + lPageMiss) * lMCLKPeriod;
         *
         * The total amount of time elapsed from the crt request until
         * the first 2 fifob cycles are completed is
         *     lTransferTime = tr_fifoa_total + lTrFifoB2;
         *
         * The number of dwords transferred to the fifo during this time
         * is 2 for 32 bit memory interface or 4 for 64 bit interface.
         *     lDWORDsWritten = 2 * (lBusWidth/4)
         *
         * During this period, data continues to be read from the crt
         * fifo B for screen refresh. The amount of data read,
         * is approximately:
         *     lFifoBReadPeriod  = (lVCLKPeriod * lVideoPixelsPerDWORD * lZoom)/256;
         *     dwords_read = lTransferTime/lFifoBReadPeriod
         *
         * The difference between the dwords read and dwords
         * written must be accounted for in the fifo trheshold setting
         *
         *     lFifoThresh = (dwords_read - lDWORDsWritten) rounded
         *                 up to next even value.
         *
         * Since the lTransferTime and dwords_read depends on the
         * threshold setting, a bit of algebra is required to determine
         * the minimum setting to prevent fifo underflow.
         *
         *    lFifoThresh = (lTransferTime/lFifoBReadPeriod) - lDWORDsWritten;
         *             = ((tr_fifoa_4 + lTrFifoB2 + tr_fifoa_remaining)/lFifoBReadPeriod)
         *                - lDWORDsWritten
         * to simplify calcuation, break out constant part of equation
         *    K1        = ((tr_fifoa_4 + lTrFifoB2)/lFifoBReadPeriod) - lDWORDsWritten;
         *
         *    lFifoThresh =  K1 + (tr_fifoa_remaining/lFifoBReadPeriod);
         *             =  K1 + (fifoa_remaining * eff_write_period)/lFifoBReadPeriod;
         *    lFifoThresh =  K1 +
         *                ((FIFO_DEPTH - lFifoThresh + 4 - (lTrFifoAFirst4/lFifoAReadPeriod)) *
         *                 eff_write_period)/read_period;
         *
         * break out another constant to simplify reduction
         *    K2       =  (FIFO_DEPTH + 4 - (lTrFifoAFirst4/lFifoAReadPeriod))
         *                   * (eff_write_period/lFifoBReadPeriod);
         *    lFifoThresh = K1 + K2 - (lFifoThresh * (eff_write_period/lFifoBReadPeriod));
         *    lFifoThresh * (1 +  (eff_write_period/read_period)) = K1 + K2;
         *    lFifoThresh = (K1 + K2)/(1 +  (eff_write_period/lFifoBReadPeriod);
         *
         * Once the threshold setting is determined, another calculation must
         * be performed to determine if available bandwidth exists given the
         * zoom factor. The worst case is assumed to be when FIFO A and
         * FIFO B reach the threshold point at the same time. The sequence
         * is then to abort the cpu/blt, fill fifo a, then fill fifo b.
         *
         * Since FIFO A is full when the fill B operation starts, I only have
         * to determine how long it takes to fill FIFO B and then calculate
         * the the number of dwords read from A during that time.
         *
         *   lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * fifob_eff_write_period))/read_period;
         *   fifoa_levels = CRT_FIFO_DEPTH - (lTransferTime/read_period);
         *
         * if fifoa_levels < 1, then underflow condition may occur.
         */
        lWritePeriod = ppdev->lMCLKPeriod * 2/(ppdev->lBusWidth/4);
        lFifoAReadPeriod = lGraphicsPixelsPerDWORD  * lVCLKPeriod;
        lFifoBReadPeriod = (lVideoPixelsPerDWORD * lVCLKPeriod * lZoom)/256;

        if (lFifoAReadPeriod <= lWritePeriod) // this fails, so set a big#
        {
            lFifoAEffWritePeriod = 5000;
        }
        else
        {
            lFifoAEffWritePeriod = ((lFifoAReadPeriod * lWritePeriod)/
                (lFifoAReadPeriod - lWritePeriod));
        }

        if (lFifoBReadPeriod <= lWritePeriod) // this fails, so set a big#
        {
            lFifoBEffWritePeriod = 5000;
        }
        else
        {
            lFifoBEffWritePeriod = ((lFifoBReadPeriod * lWritePeriod)/
                (lFifoBReadPeriod - lWritePeriod));
        }

        if ((lFifoAReadPeriod == 0) || (lFifoBReadPeriod == 0) ||
            (lWritePeriod == 0))
        {
            return (FALSE);
        }

        // These values should be the same for bot the fifoa->fifob
        // and fifob->fifoa sequences
        lTrFifoAFirst4 = (BLIT_LATENCY + ppdev->lRandom + 2*(ppdev->lPageMiss)) *
                         ppdev->lMCLKPeriod;
        lTrFifoB2 = (ppdev->lRandom + ppdev->lPageMiss) * ppdev->lMCLKPeriod;

        lDWORDsWritten     = 2 * (ppdev->lBusWidth/4);

        // Since I'm not sure which sequence is worse
        // Try both then pick worse case results

        // For fifoa->fifob sequence
        K1 = ((lTrFifoAFirst4 + lTrFifoB2)/lFifoBReadPeriod) - lDWORDsWritten;
        K2 = (CRT_FIFO_DEPTH + (4*(ppdev->lBusWidth/4)) -
            (lTrFifoAFirst4/lFifoAReadPeriod))
            * (lFifoAEffWritePeriod/lFifoBReadPeriod);
        lFifoAThresh   = (1 + ((K1 + K2)/
            (1 +  (lFifoAEffWritePeriod/lFifoBReadPeriod))));

        lFifoAThresh += 3;

        lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * lFifoBEffWritePeriod));
        lFifoALevels = ((CRT_FIFO_DEPTH - (lTransferTime/lFifoAReadPeriod))/2);

        // For fifob->fifoa sequence
        K1 = ((lTrFifoAFirst4 + lTrFifoB2)/lFifoAReadPeriod) - lDWORDsWritten;
        K2 = (CRT_FIFO_DEPTH + (4*(ppdev->lBusWidth/4)) -
            (lTrFifoAFirst4/lFifoBReadPeriod))
            * (lFifoBEffWritePeriod/lFifoAReadPeriod);

        lFifoBThresh = (1 + ((K1 + K2)/
            (1 +  (lFifoBEffWritePeriod/lFifoAReadPeriod))));

        lFifoBThresh += 3;

        lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * lFifoAEffWritePeriod));
        lFifoBLevels = ((CRT_FIFO_DEPTH - (lTransferTime/lFifoBReadPeriod))/2);

        if (lFifoAThresh > lFifoBThresh)
        {
            ppdev->lFifoThresh = lFifoAThresh;
        }
        else
        {
            ppdev->lFifoThresh = lFifoBThresh;
        }
        if (ppdev->bDoubleClock)
        {
            ppdev->lFifoThresh <<= 1;
        }

        if ((lFifoBLevels <0) || (lFifoALevels < 0) ||
            (ppdev->lFifoThresh > (CRT_FIFO_DEPTH/2)))
        {
            return (0);
        }
        else
        {
            return (1);
        }
    }
    return (1);  // Should never get here!!
}



// chu03
/**********************************************************
*
*       Name:  Is5480SufficientBandwidth
*
*       Module Abstract:
*       ----------------
*       This function reads the current MCLK, VLCK, bus width, etc.
*       and determines whether the chip has sufficient bandwidth
*       to handle the requested mode.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************/

// -------------------------------------------------------------
// Overview by John Schafer
// -------------------------------------------------------------
// The memory arbitration scheme for the 5480 has changed
// significantly from the 5446. The 5480 is set up on a first
// come, first serve basis. If more than 1 request arrive at
// the same clock edge, then the BankSelect is used to determine
// which request to acknowledge first. Using SDRAM, the row
// access to a differennt bank can be hidden, which saves up to
// 7 MCLKs. If all bank selects for the concurrent requests are
// the same, the default prority is FIFOA->FIFOB->FIFOC->VCAP.
//
// The FIFO sizes for the 5480 are as follows:
//      FIFOA, FIFOB, FIFOC :  32x64
//      VCAP                :  16x64 (two 8x64 fifos)
//
// The Y interpolation mode for the 5480 is "free" due to
// the embedded line store. The available mode combinations
// for the 5480 which effect bandwidth are :
//
//  1)  Capture enabled,  1 video window, no occlusion, not 420 format
//  2)  Capture enabled,  1 video window, no occlusion, 420 format
//  3)  Capture enabled,  1 video window, occlusion, not 420 format
//  4)  Capture enabled,  1 video window, occlusion, 420 format
//  5)  Capture enabled,  2 video windows (occlusion implied)
//  6)  Capture disabled, 1 video window, no occlusion, not 420 format
//  7)  Capture disabled, 1 video window, no occlusion, 420 format
//  8)  Capture disabled, 1 video window, occlusion, not 420 format
//  9)  Capture disabled, 1 video window, occlusion, 420 format
//  10) Capture disabled, 2 video windows (occlusion implied)
//
//
// -------------------------------------------------------------
// FIFO threshold description
// -------------------------------------------------------------
// The memory requests are generated based on the threshold settings
// of each FIFO. CRT FIFO thresholds during non-video window lines
// are determined by SR16(3:0). CRT FIFO thresholds during video
// window lines are determined by CR5C(3:0).
// The VCAP fifo threshold is a fixed setting of 8 QWORDS (half).
//
// The 4 bit threshold for FIFOs A,B, and C indicate the FIFO
// level in double QWORDS at which the FIFO request is asserted.
// For example, a setting of 4 indicates that the request is
// generated when the FIFO level is reduced to 8 QWORDS.
// A setting of 0 is a special case which indicates that the
// FIFO must be full to prevent a request (i.e. 32 QWORDS).
//
// The objective of the bandwidth equations is to calculate
// the optimum threshold setting and determine which display
// modes may be supported for given MCLK and VCLK frequencies.
//
// The critical parameters which determine the bandwidth limits
// are the read and effective write rates for each FIFO.
//
// -------------------------------------------------------------
// FIFO read/write rates for CRT FIFOs
// -------------------------------------------------------------
// The read rate for FIFO A (graphics FIFO) is determined by
// the graphics pixel depth and the VCLK frequency.
//     fa_read_rate = gr_bytes_per_pixel * vclk_period
//
// The read rates for FIFO B and C are determined differently
// depending on display mode. For 420 format the read periods
// in nanosecs per byte are as follows:
//     fb_read_period = ((vclk_period*4) * hzoom) / hdecimate;
//     fc_read_period = ((vclk_period*4) * hzoom) / hdecimate;
//
// In this equation hdecimate is specified as 1/decimation_scale,
// i.e a 1/2 decimate implies hdecimate = 2
//
// For non 420 format the rates are:
//     fb_read_period = ((vclk_period/vw_bytes_per_pixel) * hzoom) /
//                      hdecimate;
//     fc_read_period = (vclk_period/vw_bytes_per_pixel);
//
// Since the FIFOs can be read and written simultaneously,
// the effective write rate is determined by the actual fifo
// write rate and tje fifo read rate. The actual write rate is based
// on single mclk display memory reads. The memory read period is
// calculated in terms of nanoseconds per byte.
//
//    bytes_per_memory_transfer is equal to 4 for 32 bit i/f, 8 for 64 bit i/f
//    mem_read_period     = mclk_period/bytes_per_mem_transfer
//    fa_eff_write_period = (mem_read_period * fa_read_period)/
//                           (fa_read_period - mem_read_period);
//    fb_eff_write_period = (mem_read_period * fb_read_period)/
//                           (fb_read_period - mem_read_period);
//    fc_eff_write_period = (mem_read_period * fc_read_period)/
//                           (fc_read_period - mem_read_period);
// -------------------------------------------------------------
// FIFO read/write rates for VCAP fifo
// -------------------------------------------------------------
//  The video capture write rate is based on the data rate
// from the video capture interface. Since the video capture
// interface can perform format conversion (e.g. 422->PackJR) and
// decimation, the capture data rate may be smaller than the actual
// video port data rate. The capture period in the following equation
// is defined in terms of nanoseconds per byte. The decimation factor
// may vary from 1 to 1/256.
//
//     vcap_write_period  = (vport_pixel_period/capture_bytes_per_pixel) *
//                        (vport_decimation);
// In this equation vport_decimation is specified as 1/decimation_scale,
// i.e a 1/2 decimate implies vport_decimation = 2
//
//
// Since the VCAP fifo can be read and written simultaneously,
// the effective read rate is determined by the fifo write rate as well
// as the actual fifo read rate. The actual fifo read rate is based on two
// memory clock cycle display memory writes. The calculations are in terms
// of nanoseconds per byte.
//    bytes_per_memory_transfer = 4 for 32 bit i/f, or 8 for 64 bit i/f
//   mem_write_period = 2 *  mclk_period/bytes_per_mem_transfer
//
//   vcap_eff_read_period = (mem_write_period * vcap_write_period)/
//                           (vcap_write_period - mem_write_period);
//
// -------------------------------------------------------------------
// How to determine if FIFO ABC underflow or VCAP fifo overflow occurs
// -------------------------------------------------------------------
//
// I will examine a few worst case scenarios to determine if adequate
// bandwidth exists to support a given mode.
//
// Case #1 - start of graphics line where all 3 CRT fifos must be filled
//
//     This condition occurs after hsync when the 3 CRT FIFOs are being
//  prefilled before the start of the active line. The only risk here is
//  that the video capture fifo may overflow during the consecutive fills
//  of fifos A,B, and C. The threshold setting does not matter since the
//  CRT fifos are cleared on reset and thus guaranteed to be empty.
//
//  For a 32 bit memory interface :
//      fabc_fill_time = (BLIT_LATENCY * mclk_period) +
//                       3 * ((RAS_PRECHARGE + 64) * mclk_period)
//
//  For a 64 bit memory interface :
//      fabc_fill_time = (BLIT_LATENCY * mclk_period) +
//                       3 * ((RAS_PRECHARGE + 32) * mclk_period)
//
//  A capture fifo overflow occurs if fabc_fill_time is greater than
//  VCAP fill time based on the worst case 30 MB/s capture rate.
//
//  For a worst case memory interface scenario, let's assume a 32 bit
//  interface with a 66 MHz memory clock, a blit latency of 10 mclks,
//  and a ras precharge of 7 mclks. The fabc_fill_time is
//  then
//      fabc_fill_time =   (10 * 15.2) +
//                          3 * ((64 + 7) * 15.2) = 3390 ns
//
//  Assuming the worst case 30 MB/s capture rate, the number of
//  bytes written to the capture fifo during the fabc_fill_time is
//       3390 ns * (1 byte/33 ns)  = 103 bytes
//
//  Since the capture fifo is 128 bytes deep, the worst case scenario
//  is OK so long as the capture fifo is emptied prior to the fabc_fill.
//
//
//
// Case #2 - Consecutive requests
//
//  It seems that the worst case for servicing of requests is when the requests occur
//  on consecutive mclks with the order of requests being from the slowest to the
//  fastest data consumer. In other words, the first to be serviced is the capture fifo,
//  then the 3 CRT fifos in the order of decreasing read_period.
//
//  First calculate actual and effective read and write periods as decribed above.
//  Then determine how many requests are active, this is a maximum of 4 if capture
//  is enabled and all 3 CRT fifos are enabled. Assume that the capture rate
//  is the slowest and thus is always serviced first. Then order the active
//  CRT requests as f1 through f3, where f1 has the longest read period and
//  f3 has the shortest.
//
//  The sequence of events then becomes:
//    empty vcap -> fill 1 -> fill 2 -> fill 3
//
//
//  Depending on the number of active crt fifos, the fill 2 and fill 3 operations may
//  be ommitted. The vcap empty is obviously ommitted if capture is not enabled.
//
//  Now step through the sequence and verify that crt fifo underflows and capture
//  underflows do not occur.
//
//     If capture is enabled, calculate the latency and empty times
//         vcap_latency        =  (BLIT_LATENCY + RAS_PRECHARGE) * mclk_period;
//         vcap_bytes_to_empty   = CAP_FIFO_DEPTH;
//         vcap_empty_time       = (vcap_read_period * vcap_bytes_to_empty);
//      Since one of the capture fifos continues to fill while the other is being
//      emptied, calculate the number of filled levels in the capture fifo at
//      the end of the memory transfer.
//         vcap_levels_remaining =  (vcap_latency + vcap_empty_time)/vcap_write_period;
//      If the number of levels filled exceeds the fifo depth, then an overflow occurred.
//
//  Note that the VCAP FIFO operates differently than the CRT fifos. The VCAP
//  FIFO operates as 2 8x64 FIFOs. A memory request is asserted when one of the
//  FIFOs is full. The capture interface then fills the other fifo while the
//  full fifo is being serviced by the sequencer. Using this method, the transfer
//  to memory is always 16 QWORDs for VCAP data (except special end of line conditions).
//
//     Now check fifo 1. If capture was enabled then the latency for fifo 1 is:
//         f1_latency       = vcap_latency + vcap_empty_time +
//                           (BLIT_LATENCY + RAS_PRECHARGE) * mclk_period;
//
//     otherwise the latency is:
//         f1_latency     =  (BLIT_LATENCY + RAS_PRECHARGE) * mclk_period;
//
//     Calculate the number of empty levels in fifo 1, i.e. the number of bytes
//     that must be filled.
//       f1_bytes_to_fill = ((16-threshold) * 16) + (f1_latency/f1_read_period);
//      If the number of levels to be filled exceeds the fifo depth, then an underflow occurred.
//     Calculate the fill time based on the effective fifo write rate.
//       f1_fill_time     = (f1_eff_write_period * f1_bytes_to_fill);
//
//     If fifo_2 is active, calculate its latency and bytes to be filled.
//          f2_latency       = f1_latency + f1_fill_time +
//                          (RAS_PRECHARGE * mclk_period);
//          f2_bytes_to_fill = ((16-threshold) * 16) + (f2_latency/f2_read_period);
//      If the number of levels to be filled exceeds the fifo depth, then an underflow occurred.
//     Calculate the fill time based on the effective fifo write rate.
//          f2_fill_time     = (f2_eff_write_period * f2_bytes_to_fill);
//
//     If fifo_2 is active, calculate its latency and bytes to be filled.
//          f3_latency       = f2_latency + f2_fill_time +
//                             (RAS_PRECHARGE * mclk_period);
//          f3_bytes_to_fill = ((16-threshold) * 16) + (f3_latency/f3_read_period);
//      If the number of levels to be filled exceeds the fifo depth, then an underflow occurred.
//     Calculate the fill time based on the effective fifo write rate.
//          f3_fill_time     = (f3_eff_write_period * f3_bytes_to_fill);
//
//      Now go back to the start of sequence and make sure that none of the FIFOs
//      have already initiated another request. The totla latency is the amount
//      of time required to execute the entire sequence.
//
//      Check vcap fif status if capture is enabled,
//        vcap_latency        = total_latency;
//        vcap_bytes_to_empty = (total_latency/vcap_write_period);
//
//      Check fifo 1 status
//        f1_latency = (total_latency - f1_latency - f1_fill_time);
//        f1_bytes_to_fill = (f1_latency/f1_read_period);
//
//      Check fifo 2 status if active
//        f2_latency = (total_latency - f1_latency - f1_fill_time);
//        f3_bytes_to_fill = (f1_latency/f1_read_period);
//
//***************************************************************************
static BOOL Is5480SufficientBandwidth (PDEV* ppdev,
                                   WORD wVideoDepth,
                                   LPRECTL lpSrc,
                                   LPRECTL lpDest,
                                   DWORD dwFlags)
{
    long  lVideoPixelsPerDWORD;
    long  lGraphicsPixelsPerDWORD;
    long  lCapturePixelsPerDWORD;
    long  lVideoBytesPerPixel;
    long  lGraphicsBytesPerPixel;
    long  lCaptureBytesPerPixel;
    long  lVCLKPeriod;
    long  lZoom;
    long  lFifoAReadPeriod;
    long  lFifoBReadPeriod;
    long  lFifoCReadPeriod;
    long  lFifoAEffWritePeriod;
    long  lFifoBEffWritePeriod;
    long  lFifoCEffWritePeriod;
    long  lMemReadPeriod;
    long  lVPortPixelPeriod;
    long  lVCapReadPeriod;
    long  lVCapWritePeriod;
    long  lFifo1ReadPeriod;
    long  lFifo2ReadPeriod;
    long  lFifo3ReadPeriod;
    long  lFifo1EffWritePeriod;
    long  lFifo2EffWritePeriod;
    long  lFifo3EffWritePeriod;
    long  lVCapLatency;
    long  lVCapBytesToEmpty;
    long  lVCapEmptyTime;
    long  lVCapLevelRemaining;
    long  lFifo1Latency;
    long  lFifo1BytesToFill;
    long  lFifo1FillTime;
    long  lFifo2Latency;
    long  lFifo2BytesToFill;
    long  lFifo2FillTime;
    long  lFifo3Latency;
    long  lFifo3BytesToFill;
    long  lFifo3FillTime;
    long  lThreshold;
    int   CrtFifoCount;
    BOOL  bCapture;
    BOOL  bFifoAEnable;
    BOOL  bFifoBEnable;
    BOOL  bFifoCEnable;
    BOOL  bModePass;
    long  lHorizDecimate;
    long  lVPortDecimate;
    long  lTotalLatency;
    long  lVCLK;
    UCHAR tempB ;
    BYTE* pjPorts = ppdev->pjPorts ;

#define  CAP_FIFO_DEPTH 64
#define  RAS_PRECHARGE   7
#define  BLIT_LATENCY    9

    //
    // Parameter checking
    //
    lHorizDecimate = 1;
    lVPortDecimate = 1;

    //
    // Convert input parameters
    //
    if (wVideoDepth == 16)
    {
        lVideoPixelsPerDWORD   = 2;
        lCapturePixelsPerDWORD = 2;
    }
    else if (wVideoDepth == 8)
    {
        lVideoPixelsPerDWORD   = 4;
        lCapturePixelsPerDWORD = 4;
    }
    else return (FALSE);

    if (ppdev->cBitsPerPixel == 8)
    {
        lGraphicsPixelsPerDWORD = 4;
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        lGraphicsPixelsPerDWORD = 2;
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        lGraphicsPixelsPerDWORD = 1;
    }
    else return (FALSE);


    lGraphicsBytesPerPixel = 4 / lGraphicsPixelsPerDWORD;
    lVideoBytesPerPixel =  4 / lVideoPixelsPerDWORD;
    lCaptureBytesPerPixel = 4 / lCapturePixelsPerDWORD;

    lZoom = (lpDest->right - lpDest->left) /
        (lpSrc->right - lpSrc->left);

    if (lZoom < 1)
        lZoom = 1;

    //
    // We need to get the VCLK every time since this can change at run-time
    //
    lVCLK = GetVCLK(ppdev);
    lVCLKPeriod = (long) ((1024000000l/lVCLK) + 1);

    //
    // Video port at 13.5 MHz
    //
    lVPortPixelPeriod = (long) ((10240000) / 135);


    //
    // Graphics CRT FIFO read rate
    //
    lFifoAReadPeriod = lGraphicsBytesPerPixel * lVCLKPeriod;

    //
    // Video FIFO read rate
    //
    if(dwFlags & OVERLAY_FLG_YUVPLANAR)
    {
        lFifoBReadPeriod = ((lVCLKPeriod * 4) * lZoom) / lHorizDecimate;
        lFifoCReadPeriod = ((lVCLKPeriod * 4) * lZoom) / lHorizDecimate;
    }
    else
    {
        lFifoBReadPeriod = ((lVCLKPeriod / lVideoBytesPerPixel) * lZoom)
                / lHorizDecimate;
        lFifoCReadPeriod = lVCLKPeriod / lVideoBytesPerPixel;
    }


    DISPDBG ((2, "lFifoAReadPeriod = %ld, lFifoBReadPeriod=%ld\n",
        lFifoAReadPeriod, lFifoBReadPeriod));

    DISPDBG ((2, "lFifoCReadPeriod = %ld\n", lFifoCReadPeriod));

    //
    // Video capture write period
    //
    lVCapWritePeriod = (lVPortPixelPeriod / lCaptureBytesPerPixel)
                                                * lVPortDecimate;

    if (!ppdev->lBusWidth)
    {
        //
        // We will read the bus width from SR0F[4:3]
        //
        CP_OUT_BYTE (pjPorts, SR_INDEX, 0x0F) ;

        if ((CP_IN_BYTE(pjPorts, SR_DATA) & 0x18) == 0x18)
            ppdev->lBusWidth = 8;  // 64 bit bus
        else
            ppdev->lBusWidth = 4;  // 32 bit bus
    }

    if (!ppdev->lMCLKPeriod)
    {
        LONG lMCLK;

        //
        // The MCLK period is the amount of time required for one cycle.
        // We will round up.
        //
        CP_OUT_BYTE (pjPorts, SR_INDEX, 0x1F) ; // First get the MCLK frequency
        lMCLK = CP_IN_BYTE(pjPorts, SR_DATA);
        lMCLK *= 14318;
        lMCLK >>= 3;
        ppdev->lMCLKPeriod = (long) ((1024000000l/lMCLK) + 1);
    }

    //
    // Calculate CRT effective read and write periods
    //
    lMemReadPeriod = ppdev->lMCLKPeriod / ppdev->lBusWidth;

    if (lFifoAReadPeriod == lMemReadPeriod)
        lFifoAEffWritePeriod = 1000000000;
    else
        lFifoAEffWritePeriod = (lMemReadPeriod * lFifoAReadPeriod) /
                                    (lFifoAReadPeriod - lMemReadPeriod);

    if (lFifoBReadPeriod == lMemReadPeriod)
        lFifoBEffWritePeriod = 1000000000;
    else
        lFifoBEffWritePeriod = (lMemReadPeriod * lFifoBReadPeriod) /
                                    (lFifoBReadPeriod - lMemReadPeriod);

    if (lFifoCReadPeriod == lMemReadPeriod)
        lFifoCEffWritePeriod = 1000000000;
    else
        lFifoCEffWritePeriod = (lMemReadPeriod * lFifoCReadPeriod) /
                                    (lFifoCReadPeriod - lMemReadPeriod);

    //
    // Video capture read period
    //
    lVCapReadPeriod = (2 * ppdev->lMCLKPeriod) / ppdev->lBusWidth;


    if (dwFlags & OVERLAY_FLG_CAPTURE)  // is capture enable ?
        bCapture = TRUE;
    else
        bCapture = FALSE;


    if (dwFlags & OVERLAY_FLG_YUVPLANAR)    // is 420 format
    {
        if (dwFlags & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))  // occlusion
        {   // one video window, occlusion, 420 format
            bFifoAEnable = TRUE;
            bFifoBEnable = TRUE;
            bFifoCEnable = TRUE;
        }
        else
        {   // one video window, no occlusion, 420 format
            bFifoAEnable = FALSE;
            bFifoBEnable = TRUE;
            bFifoCEnable = TRUE;
        }
    }
    else    // not 420 format
    {
        if (dwFlags & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))  // occlusion
        {
            if (dwFlags & OVERLAY_FLG_TWO_VIDEO)
            {   // Two video windows, occlusion, not 420 format
                bFifoAEnable = TRUE;
                bFifoBEnable = TRUE;
                bFifoCEnable = TRUE;
            }
            else
            {   // one video window, occlusion, not 420 format
                bFifoAEnable = TRUE;
                bFifoBEnable = TRUE;
                bFifoCEnable = FALSE;
            }
        }
        else
        {
            // one video window, no occlusion, not 420 format
            bFifoAEnable = FALSE;
            bFifoBEnable = TRUE;
            bFifoCEnable = FALSE;
        }
    }

    DISPDBG ((4, "   FIFOA = %s, FIFOB= %s, FIFOC = %s\n",
        bFifoAEnable ? "yes" : "no",
        bFifoBEnable ? "yes" : "no",
        bFifoCEnable ? "yes" : "no"));

    lFifo1ReadPeriod = 0;
    lFifo2ReadPeriod = 0;
    lFifo3ReadPeriod = 0;

    if (bFifoAEnable)
    {
        if (((lFifoAReadPeriod >= lFifoBReadPeriod) || !bFifoBEnable) &&
        // A slower than or equal than B) and
            ((lFifoAReadPeriod >= lFifoCReadPeriod) || !bFifoCEnable))
        // A slower than or equal C
        {
            lFifo1ReadPeriod = lFifoAReadPeriod;
            lFifo1EffWritePeriod = lFifoAEffWritePeriod;
        }
        else if (((lFifoAReadPeriod >= lFifoBReadPeriod) || !bFifoBEnable) ||
        // A slower than or equal B
                ((lFifoAReadPeriod >= lFifoCReadPeriod) || !bFifoCEnable))
        // A slower than or equal C
        {
            lFifo2ReadPeriod = lFifoAReadPeriod;
            lFifo2EffWritePeriod = lFifoAEffWritePeriod;
        }
        else    // A not slower than A or B
        {
            lFifo3ReadPeriod = lFifoAReadPeriod;
            lFifo3EffWritePeriod = lFifoAEffWritePeriod;
        }
    }

    DISPDBG ((2, "After bFifoAEnable")) ;
    DISPDBG ((2, "lFifo1ReadPeriod = %ld, lFifo2ReadPeriod=%ld",
        lFifo1ReadPeriod, lFifo2ReadPeriod)) ;
    DISPDBG ((2, "lFifo3ReadPeriod = %ld", lFifo3ReadPeriod)) ;


    if (bFifoBEnable)
    {
        if (((lFifoBReadPeriod > lFifoAReadPeriod) || !bFifoAEnable) &&
        // B slower than A and
            ((lFifoBReadPeriod >= lFifoCReadPeriod) || !bFifoCEnable))
        // slower than or equal A
        {
            lFifo1ReadPeriod = lFifoBReadPeriod;
            lFifo1EffWritePeriod = lFifoBEffWritePeriod;
        }
        else if (((lFifoBReadPeriod > lFifoAReadPeriod) || !bFifoAEnable) ||
        // B slower than A or
                    ((lFifoBReadPeriod >= lFifoCReadPeriod) || !bFifoCEnable))
        // B slower than or equal C
        {

            lFifo2ReadPeriod = lFifoBReadPeriod;
            lFifo2EffWritePeriod = lFifoBEffWritePeriod;

        }
        else
        // (B not slower than A ) and (B not slower than or equal C)
        {
            lFifo3ReadPeriod = lFifoBReadPeriod;
            lFifo3EffWritePeriod = lFifoBEffWritePeriod;
        }
    }


    DISPDBG ((4, "After bFifoBEnable")) ;
    DISPDBG ((4, "lFifo1ReadPeriod = %ld, lFifo2ReadPeriod=%ld",
        lFifo1ReadPeriod, lFifo2ReadPeriod)) ;
    DISPDBG ((4, "lFifo3ReadPeriod = %ld", lFifo3ReadPeriod)) ;

    if (bFifoCEnable)
    {
        if (((lFifoCReadPeriod > lFifoAReadPeriod) || !bFifoAEnable) &&
        // C slower than A  and
            ((lFifoCReadPeriod > lFifoBReadPeriod) || !bFifoBEnable))
        // C slower than B
        {
            lFifo1ReadPeriod = lFifoCReadPeriod;
            lFifo1EffWritePeriod = lFifoCEffWritePeriod;
        }
        else if (((lFifoCReadPeriod > lFifoAReadPeriod) || !bFifoAEnable) ||
        // C slower than A or
                 ((lFifoCReadPeriod > lFifoBReadPeriod) || !bFifoBEnable))
        // C slower than B
        {
            lFifo2ReadPeriod = lFifoCReadPeriod;
            lFifo2EffWritePeriod = lFifoCEffWritePeriod;
        }
        else
        {
        // C not slower than A and C not slower than B
            lFifo3ReadPeriod = lFifoCReadPeriod;
            lFifo3EffWritePeriod = lFifoCEffWritePeriod;
        }
    }

    DISPDBG ((4, "After bFifoCEnable")) ;
    DISPDBG ((4, "lFifo1ReadPeriod = %ld, lFifo2ReadPeriod=%ld",
        lFifo1ReadPeriod, lFifo2ReadPeriod)) ;
    DISPDBG ((4, "lFifo3ReadPeriod = %ld", lFifo3ReadPeriod)) ;
    DISPDBG ((4, "lFifo1EffWritePeriod = %ld, lFifo2EffWritePeriod = %ld",
         lFifo1EffWritePeriod, lFifo2EffWritePeriod)) ;
    DISPDBG ((4, " lFifo3EffWritePeriod = %ld", lFifo3EffWritePeriod)) ;
    DISPDBG ((4, " lFifoAEffWritePeriod = %ld, lFifoBEffWritePeriod = %ld",
         lFifoAEffWritePeriod, lFifoBEffWritePeriod)) ;
    DISPDBG ((4, " lFifoCEffWritePeriod = %ld", lFifoCEffWritePeriod)) ;

    bModePass = FALSE;
    lThreshold = 1;

    CrtFifoCount = 0;
    if (bFifoAEnable) CrtFifoCount++;
    if (bFifoBEnable) CrtFifoCount++;
    if (bFifoCEnable) CrtFifoCount++;

    while ((!bModePass) && (lThreshold < 16))
    {
        bModePass = TRUE;   // assume pass until proven otherwise.

        //
        // Checking capture
        //
        if (bCapture)
        {
            lVCapLatency = (BLIT_LATENCY + RAS_PRECHARGE) * ppdev->lMCLKPeriod;
            lVCapBytesToEmpty = CAP_FIFO_DEPTH;
            lVCapEmptyTime = lVCapReadPeriod * lVCapBytesToEmpty;
            lVCapLevelRemaining = (lVCapLatency + lVCapEmptyTime) / lVCapWritePeriod;
            if (lVCapLevelRemaining > CAP_FIFO_DEPTH)
                  return(FALSE);
        }

        //
        // Fill FIFO 1
        //
        if (bCapture)
            lFifo1Latency = lVCapLatency + lVCapEmptyTime + (BLIT_LATENCY + RAS_PRECHARGE) * ppdev->lMCLKPeriod;
        else
            lFifo1Latency = (BLIT_LATENCY + RAS_PRECHARGE) * ppdev->lMCLKPeriod;

        lFifo1BytesToFill = ((16 - lThreshold) * 16)
                        + (lFifo1Latency / lFifo1ReadPeriod);
        lFifo1FillTime = lFifo1EffWritePeriod * lFifo1BytesToFill;
        if (lFifo1BytesToFill > 256)
            bModePass = FALSE;

        DISPDBG ((4, "After Fill FIFO1, lFifo1BytesToFillb=%ld, ModePass = %s",
            lFifo1BytesToFill, bModePass ? "yes" : "no")) ;
        DISPDBG ((4, "f1_latency=%ld, f1_read_period=%ld",
            lFifo1Latency, lFifo1ReadPeriod)) ;
        DISPDBG ((4, "mclkperiod= %ld, vclkperiod=%ld",
            ppdev->lMCLKPeriod, lVCLKPeriod)) ;

        //
        // Fill FIFO 2
        //
        if (CrtFifoCount > 1)
        {
            lFifo2Latency = lFifo1Latency + lFifo1FillTime +
                                    (RAS_PRECHARGE * ppdev->lMCLKPeriod);
            lFifo2BytesToFill = ((16 - lThreshold) * 16) +
                                (lFifo2Latency / lFifo2ReadPeriod);
            lFifo2FillTime = lFifo2EffWritePeriod * lFifo2BytesToFill;
            if (lFifo2BytesToFill > 256)
                bModePass = FALSE;
        }
        else
        {
            lFifo2Latency = lFifo1Latency + lFifo1FillTime;
            lFifo2BytesToFill = 0;
            lFifo2FillTime = 0;
        }

        DISPDBG ((4, "After Fill FIFO2, lFifo2BytesToFill=%ld, ModePass = %s",
            lFifo2BytesToFill, bModePass ? "yes" : "no"));

        //
        // Fill FIFO 3
        //
        if (CrtFifoCount > 2)
        {
            lFifo3Latency = lFifo2Latency + lFifo2FillTime + (RAS_PRECHARGE * ppdev->lMCLKPeriod);
            lFifo3BytesToFill = ((16 - lThreshold) * 16) + (lFifo3Latency / lFifo3ReadPeriod);
            lFifo3FillTime = lFifo3EffWritePeriod * lFifo3BytesToFill;
            if (lFifo3BytesToFill > 256)
                bModePass = FALSE;
        }
        else
        {
            lFifo3Latency = lFifo2Latency + lFifo2FillTime;
            lFifo3BytesToFill = 0;
            lFifo3FillTime = 0;
        }

        DISPDBG ((4, "After Fill FIFO3, lFifo3BytesToFill=%ld, ModePass = %s",
            lFifo3BytesToFill, bModePass ? "yes" : "no")) ;

        //
        // Determine total latency through the sequence
        //
        lTotalLatency = lFifo3Latency + lFifo3FillTime;

        //
        // Now back to start of sequence, make sure that none of the FIFOs
        //   have already initiated another request.
        //

        //
        // Check capture FIFO status
        //
        if (bCapture)
        {
            lVCapLatency = lTotalLatency;
            lVCapBytesToEmpty = lTotalLatency / lVCapWritePeriod;
            if (lVCapBytesToEmpty > CAP_FIFO_DEPTH)
                  bModePass = FALSE;
        }

        //
        // Check FIFO 1 status
        //
        lFifo1Latency = lTotalLatency - lFifo1Latency - lFifo1FillTime;
        lFifo1BytesToFill = lFifo1Latency / lFifo1ReadPeriod;
        if (lFifo1BytesToFill > ((16 - lThreshold) * 16))
            bModePass = FALSE;

        DISPDBG ((4, "After CheckF FIFO1, fifo1bytestofill %ld,bModePass = %s",
            lFifo1BytesToFill, bModePass ? "yes" : "no")) ;

        //
        // Check FIFO 2 status
        //
        if (CrtFifoCount > 1)
        {
            lFifo2Latency = lTotalLatency - lFifo2Latency - lFifo2FillTime;
            lFifo2BytesToFill = lFifo2Latency / lFifo2ReadPeriod;
            if (lFifo2BytesToFill > ((16 - lThreshold) * 16))
                  bModePass = FALSE;

        DISPDBG ((4, "After Check FIFO 2, fifo1bytestofill=%ld, bModePass = %s",
            lFifo2BytesToFill, bModePass ? "yes" : "no")) ;

        }

        if (!bModePass)
            lThreshold++;

    }


    if (bModePass)
    {

        DISPDBG ((1, "Is sufficient Bandwidth, thresh = %ld, return TRUE\n", lThreshold));

        if (ppdev->cBitsPerPixel == 24)
            lThreshold = 0x0F;

        ppdev->lFifoThresh = lThreshold;

        return TRUE ;
    }

    DISPDBG ((2, "Is sufficient Bandwidth, thresh = %ld, rerurn FALSE", lThreshold));
    return FALSE;

}



/**********************************************************
*
*       Name:  GetVCLK
*
*       Module Abstract:
*       ----------------
*       Returns the VCLK frequency * 1000.
*
*       Input Parameters:
*       -----------------
*       none
*
*       Output Parameters:
*       ------------------
*       MCLK
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

LONG GetVCLK(PDEV* ppdev)
{
    LONG    lTemp;
    LONG    lRegSR1F;
    LONG    lRegMISC;
    LONG    lNR;
    LONG    lDR;
    LONG    lPS;
    BYTE*   pjPorts = ppdev->pjPorts;

    /*
     * First read SR1F.  This tells us if VCLK is derived from MCLK
     * or if it's derived normally.
     */
    CP_OUT_BYTE(pjPorts, SR_INDEX, 0x1f);
    lRegSR1F = (LONG) CP_IN_BYTE(pjPorts, SR_DATA);
    if (lRegSR1F & 0x40)
    {
         LONG lMCLK;

         /*
          * It is derived from MCLK, but now we need to read SR1E to see
          * if VCLK = MCLK or if VCLK = MCLK/2.
          */
         lMCLK = (lRegSR1F & 0x3F) * 14318;
         CP_OUT_BYTE(pjPorts, SR_INDEX, 0x1e);
         if (CP_IN_BYTE(pjPorts, SR_DATA) & 0x01)
         {
              return (lMCLK >> 4);
         }
         else
         {
              return (lMCLK >> 3);
         }
    }
    else
    {
         /*
          * Read MISC[3:2], which tells us where to find our VCLK
          */
         lRegMISC = (LONG) CP_IN_BYTE(pjPorts, 0x3cc);
         lRegMISC >>= 2;

        //myf33 begin
         CP_OUT_BYTE(pjPorts, CRTC_INDEX, (BYTE)0x80);
         if (((ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID)) &&
			 (CP_IN_BYTE(pjPorts, CRTC_DATA) & 0x01))
             lRegMISC &= 0x02;          // Fixed PDR 8709
         else
        //myf33 end
         lRegMISC &= 0x03;

         lNR = 0x0B + lRegMISC;
         lDR = 0x1B + lRegMISC;

         /*
          * Read the values for bP, bDR, and bNR
          */
         CP_OUT_BYTE(pjPorts, SR_INDEX, (BYTE) lDR);
         lPS = lDR = (LONG)CP_IN_BYTE(pjPorts, SR_DATA);
         CP_OUT_BYTE(pjPorts, SR_INDEX, (BYTE) lNR);
         lNR = (LONG)CP_IN_BYTE(pjPorts, SR_DATA);
         lPS &= 0x01;
         lPS += 1;
         lDR >>= 1;
         //
         // Extended the VCLK bits.
         //
         // sge06
         lDR &= 0x7f;
         lNR &= 0x7f;

         /*
          * VCLK = (14.31818 * bNR) / (bDR * bPS)
          */
         lTemp = (14318 * lNR);
         if (!lPS || !lDR)
         {
             return (0);
         }
         lTemp /= (lDR * lPS);
    }

    return (lTemp);
}
/**********************************************************
*
*       Name:  EnableStartAddrDoubleBuffer
*
*       Module Abstract:
*       ----------------
*       Enable the double buffering of the start addresses.   This allows the page
*       flipping operation to proceed without the system CPU waiting for VRT.
*
*       Input Parameters:
*       -----------------
*       none
*
*       Output Parameters:
*       ------------------
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   10/01/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/
VOID EnableStartAddrDoubleBuffer(PDEV* ppdev)
{

    BYTE*   pjPorts = ppdev->pjPorts;
    BYTE    cTemp;


    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
    cTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, cTemp | 2);
}

/**********************************************************
*
*       Name:  GetCurrentVLine
*
*       Module Abstract:
*       ----------------
*       Get the current scan line
*
*       Input Parameters:
*       -----------------
*       none
*
*       Output Parameters:
*       ------------------
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   10/01/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/
DWORD GetCurrentVLine(PDEV* ppdev)
{

    DWORD   dwLine;
    BYTE    cTemp;
    BYTE*   pjPorts = ppdev->pjPorts;

    CP_OUT_BYTE(pjPorts, INDEX_REG, 0x16);  /* Index to the low byte. */
    dwLine = (ULONG)CP_IN_BYTE(pjPorts, DATA_REG);

    CP_OUT_BYTE(pjPorts, INDEX_REG, 0x17);  /* Index to the high bits. */
    cTemp = CP_IN_BYTE(pjPorts, DATA_REG);
    dwLine |= (cTemp & 3) << 8;

    CP_OUT_BYTE(pjPorts, INDEX_REG, 0x16);  /* Index to the low byte. */

    /* If we wrapped around while getting the high bits we have a problem. */
    /* The high bits may be wrong. */
    if((CP_IN_BYTE(pjPorts, DATA_REG)) < (dwLine & 0xff))
    {
        DISPDBG((1, "Recursive call to GetCurrentVLine."));
        return GetCurrentVLine(ppdev);
    }
    if (dwLine > ppdev->dwVsyncLine)
    {
        return 0;
    }
    return dwLine;
}
#endif

#endif // DIRECTDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\debug.c ===
/******************************************************************************\
*
* $Workfile:   debug.c  $
*
* Debug helpers routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/debug.c_v  $
 * 
 *    Rev 1.2   Nov 26 1996 14:30:30   unknown
 * change to debug level 0
 * 
 *    Rev 1.1   Oct 10 1996 15:36:30   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:51:20   frido
* Added NT 3.5x/4.0 auto detection.
*
\******************************************************************************/

#include "precomp.h"

//#if DBG
#if (DBG_STRESS_FAILURE || DBG)

ULONG DebugLevel = 0;
ULONG PerfLevel = 0;

ULONG gulLastBltLine = 0;
CHAR* glpszLastBltFile = "Uninitialized";
BOOL  gbResetOnTimeout = TRUE;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
#if (NT_VERSION < 0x0400)
        char szBuffer[256];

        vsprintf(szBuffer, DebugMessage, ap);
        OutputDebugString(szBuffer);
#else
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
#endif
    }

    va_end(ap);

}


/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive Perf print
 *      routine.
 *      If the specified Perf level for the print statement is lower or equal
 *      to the current Perf level, the message will be printed.
 *
 *   Arguments:
 *
 *      PerfPrintLevel - Specifies at which perf level the string should
 *          be printed
 *
 *      PerfMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
PerfPrint(
    ULONG PerfPrintLevel,
    PCHAR PerfMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, PerfMessage);

    if (PerfPrintLevel <= PerfLevel)
    {
#if (NT_VERSION < 0x0400)
        char szBuffer[256];

        vsprintf(szBuffer, PerfMessage, ap);
        OutputDebugString(szBuffer);
#else
        EngDebugPrint(STANDARD_PERF_PREFIX, PerfMessage, ap);
        EngDebugPrint("", "\n", ap);
#endif
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\clioctl.h ===
//---------------------------------------------------------------------------
//
//  file: CLIOCTL.H
//
// (c) Copyright 1993, Cirrus Logic, Inc.
// Copyright (c) 1996-1997  Microsoft Corporation
// Copyright (c) 1996-1997  Cirrus Logic, Inc.,
// All rights reserved.
//
//  date: 1 July 1993
//---------------------------------------------------------------------------
// The maximum GDI ESCAPE value defined in WINGDI.H is 4110(decimal). So here
// we pick an arbitrary value of...
//
// chu01 : 12-16-96 Enable color correction
// myf17 : 10-29-96 supported special Escape call
// myf28 : 01-23-96 supported 755x gamma correction
// jl01  : 02-24-97 Implement Feature Connector's functions


//---------------------------------------------------------------------------
//
// The following macro(CTL_CODE) is defined in WINIOCTL.H. That file states
// that functions 2048-4095 are reserved for "customers". So I picked an
// arbitrary value of 0x900=2304.
//
#define IOCTL_CIRRUS_GET_CAPABILITIES  \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CIRRUS_SET_DISPLAY_PITCH \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// chu01 : GAMMACORRECT
//
#define IOCTL_CIRRUS_GET_GAMMA_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x908, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CIRRUS_GET_CONTRAST_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x909, METHOD_BUFFERED, FILE_ANY_ACCESS)

//myf28
#define IOCTL_CIRRUS_GET_755x_GAMMA_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x90A, METHOD_BUFFERED, FILE_ANY_ACCESS)


//---------------------------------------------------------------------------
// Structure for miniport to indicate to display driver the capabilities
// of the chip.  The flag currently indicates HW Cursor and BLT Engine
// support.
//
// Also included is the size of memory, and the top of available offscreen
// memory. (Actually it's top+1).
//
typedef struct {
   ULONG size;              // size of this structure
   ULONG fl;                // see bit description below
   ULONG ulChipId;          // Chip ID read from CR27[7:2] - e.g CL5434 = 0x2A
   ULONG ulMemSize;         // Size of memory in bytes=end of HW cursor buffers
   ULONG ulOffscreenMemTop; // Offset of 1st byte of unusable video memory
                            // [1st byte of cursor buffers on all but 754x]
                            // [1st byte of split screen buffer on 754x]
} CIRRUS_CAPABILITIES, *PCIRRUS_CAPABILITIES;

//#define CL_ALLOW_HW_CURSOR 0x01     // Flag to enable HW Cursor in
//capabilities
//#define CL_BLT_SUPPORT 0x02         // Flag set if chip has BLT Engine
//support
//#define CL_ALLOW_OPAQUE_TEXT 0x04   // Flag to enable HW Cursor in
//capabilities
//#define CL_LINEAR_MODE 0x08         // Flag set if addressing mode is linear
//#define CL_CURSOR_VERT_EXP 0x10     // Flag set if 8x6 panel, 6x4 resolution
//#define CL_DSTN_PANEL      0x20     // Flag set if DSTN panel connect

//---------------------------------------------------------------------------
//
// this is the structure used to pass arguments to the CIRRUS_PRIVATE_ESCAPE
// call done in DrvEscape(). The size of this struct limits the size of the
// returned arguments also. See the DrvEscape() function in enable.c (in the
// display driver DLL) for more information.
//
// NOTE: to enable the definition of these parameters, the following sequence
//       is recommended!
//
// #define ENABLE_BIOS_ARGUMENTS    // put this before the include
// #include "clioctl.h"


#ifdef ENABLE_BIOS_ARGUMENTS

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

#endif

//---------------------------------------------------------------------------

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\bltmm.c ===
/******************************************************************************\
*
* $Workfile:   bltmm.c  $
*
* Contains the low-level MM blt functions.
*
* Hopefully, if you're basing your display driver on this code, to support all
* of DrvBitBlt and DrvCopyBits, you'll only have to implement the following
* routines. You shouldn't have to modify much in 'bitblt.c'. I've tried to make
* these routines as few, modular, simple, and efficient as I could, while still
* accelerating as many calls as possible that would be cost-effective in terms
* of performance wins versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates that
*        haven't yet had the offscreen bitmap (DFB) offset applied. 'Absolute'
*        coordinates have had the offset applied. For example, we may be told to
*        blt to (1, 1) of the bitmap, but the bitmap may be sitting in offscreen
*        memory starting at coordinate (0, 768) -- (1, 1) would be the
*        'relative' start coordinate, and (1, 769) would be the 'absolute' start
*        coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/bltmm.c_v  $
 * 
 *    Rev 1.4   Jan 14 1997 15:16:14   unknown
 * take out GR33 clearing after 80 blt.
 * 
 *    Rev 1.2   Nov 07 1996 16:47:52   unknown
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:36:14   unknown
 *  
* 
*    Rev 1.4   12 Aug 1996 16:58:56   frido
* Removed unaccessed local variables.
* Renamed vMmPatternBlt into vMmFillPat36.
* 
*    Rev 1.3   08 Aug 1996 16:55:10   frido
* Added new vMmCopyBlt36 routine.
* 
*    Rev 1.2   08 Aug 1996 12:59:28   frido
* bank#1 - Removed banking code since MMIO is always linear.
*
*    Rev 1.1   31 Jul 1996 15:43:14   frido
* Added new pattern blit.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
* chu01 01-09-97  Make sure to reset GR33.
*
\******************************************************************************/

#include "precomp.h"


/**************************************************************************
* VOID vMmFastPatRealize
*
* Realizes a pattern into offscreen memory.
*
**************************************************************************/

VOID vMmFastPatRealize(
PDEV*   ppdev,
RBRUSH* prb)                    // Points to brush realization structure
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    BYTE*       pjPattern;
    LONG        cjPattern;
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    LONG        lDeltaPat;
    LONG        lDeltaSrc;
    LONG        xCnt;
    LONG        yCnt;
    ULONG       ulDst;

    DISPDBG((10,"vFastPatRealize called"));

    pbe = prb->pbe;

    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new offscreen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify = prb;
        prb->pbe       = pbe;
    }

    //
    // Download brush into cache
    //

    pjPattern = (PBYTE) &prb->aulPattern[0];        // Copy from brush buffer
    cjPattern = PELS_TO_BYTES(TOTAL_BRUSH_SIZE);

    lDeltaPat = PELS_TO_BYTES(8);
    xCnt = PELS_TO_BYTES(8);
    yCnt = 8;

    if (ppdev->cBitsPerPixel == 24)
    {
        lDeltaSrc = 32;  // same as PELS_TO_BYTES(8) for 32bpp
    }
    else
    {
        lDeltaSrc = lDeltaPat;  // PELS_TO_BYTES(8)
    }

    ulDst = (pbe->y * ppdev->lDelta) + PELS_TO_BYTES(pbe->x);

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_DST_Y_OFFSET(ppdev, pjBase, (lDeltaSrc * 2));
    CP_MM_XCNT(ppdev, pjBase, (xCnt - 1));
    CP_MM_YCNT(ppdev, pjBase, (yCnt - 1));
#if 1 // D5480
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, CL_PACKED_SRC_COPY | SRC_CPU_DATA);
#else
    CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
#endif // D5480
    CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDst);

    CP_MM_START_BLT(ppdev, pjBase);

    vImageTransfer(ppdev, pjPattern, lDeltaPat, xCnt, yCnt);

    //
    // Duplicate brush horizontally
    //

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_XCNT(ppdev, pjBase, (xCnt - 1));
    CP_MM_YCNT(ppdev, pjBase, (yCnt - 1));
    CP_MM_BLT_MODE(ppdev, pjBase, 0);
    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, (lDeltaSrc * 2));
    CP_MM_SRC_ADDR(ppdev, pjBase, ulDst);
    CP_MM_DST_ADDR_ABS(ppdev, pjBase, (ulDst + lDeltaPat));

    CP_MM_START_BLT(ppdev, pjBase);

    //
    // Duplicate brush vertically
    //

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, (lDeltaSrc * 2));
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, (lDeltaSrc * 2));
    CP_MM_BLT_MODE(ppdev, pjBase, 0);
    CP_MM_XCNT(ppdev, pjBase, ((lDeltaSrc * 2) - 1));
    CP_MM_YCNT(ppdev, pjBase, (yCnt - 1));
    CP_MM_SRC_ADDR(ppdev, pjBase, ulDst);

    if (ppdev->cBitsPerPixel == 24)
    {
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, (ulDst + 512)); // 128 * 4
    }
    else
    {
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, (ulDst + PELS_TO_BYTES(128)));
    }

    CP_MM_START_BLT(ppdev, pjBase);

    #if 0
    {
        ////////////////////////////////////////////////////////////////
        // DEBUG TILED PATTERNS
        //
        // The following code helps to debug patterns if you break the
        // realization code.  It copies the 2x2 tiled copy of the brush
        // to the visible screen.
        //

        POINTL ptl;
        RECTL rcl;

        ptl.x = pbe->x;
        ptl.y = pbe->y;

        rcl.left = 10;
        rcl.right = 10 + 16;
        rcl.top = ppdev->cyScreen - 10 - 16;
        rcl.bottom = ppdev->cyScreen - 10;

        {
            LONG        lDelta = ppdev->lDelta;
            BYTE        jHwRop;
            BYTE        jMode;

            //
            // Make sure we can write to the video registers.
            //

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, PELS_TO_BYTES(16));
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

            {
                //
                // Top to Bottom - Left to Right
                //

                jMode |= DIR_TBLR;
                CP_MM_BLT_MODE(ppdev, pjBase, ppdev->jModeColor);

                {

                    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

                    CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(rcl.right - rcl.left) - 1));
                    CP_MM_YCNT(ppdev, pjBase, (rcl.bottom - rcl.top - 1));

                    CP_MM_SRC_ADDR(ppdev, pjBase, (0 + ((ptl.y) * lDelta) + PELS_TO_BYTES(ptl.x)));
                    CP_MM_DST_ADDR_ABS(ppdev, pjBase, ((rcl.top * lDelta) + PELS_TO_BYTES(rcl.left)));
                    CP_MM_START_BLT(ppdev, pjBase);
                }
            }
        }
    }
    #endif
}

/**************************************************************************
* VOID vMmFillPat
*
* This routine uses the pattern hardware to draw a patterned list of
* rectangles.
*
**************************************************************************/

VOID vMmFillPat(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  //
{
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    ULONG       ulAlignedPatternOffset = ppdev->ulAlignedPatternOffset;
    ULONG       ulPatternAddrBase;
    BYTE        jHwRop;
    BYTE        jMode;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    DISPDBG((10,"vFillPat called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->cBpp < 4, "vFillPat only works at 8bpp, 16bpp, and 24bpp");

    if ((rbc.prb->pbe == NULL) ||
        (rbc.prb->pbe->prbVerify != rbc.prb))
    {
        vMmFastPatRealize(ppdev, rbc.prb);
        DISPDBG((5, " -- Brush cache miss, put it at (%d,%d)", rbc.prb->pbe->x, rbc.prb->pbe->y));
    }
    else
    {
        DISPDBG((5, " -- Brush cache hit on brush at (%d,%d)", rbc.prb->pbe->x, rbc.prb->pbe->y));
    }

    pbe = rbc.prb->pbe;

    //
    // Fill the list of rectangles
    //

    ulPatternAddrBase = pbe->xy;
    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];
    jMode = ppdev->jModeColor | ENABLE_8x8_PATTERN_COPY;

    do {
        ULONG offset = 0;
        ULONG XOffset, YOffset;

        YOffset = ((prcl->top - pptlBrush->y) & 7) << 4;
        XOffset = (prcl->left - pptlBrush->x) & 7;

        // align the pattern to a new location

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
#if 1 // D5480
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, CL_PACKED_SRC_COPY);
#else
        CP_MM_BLT_MODE(ppdev, pjBase, 0);
        CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
#endif // D5480
        if (ppdev->cBitsPerPixel == 24)
        {
            offset = (YOffset * 4) + (XOffset * 3);

            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, 64);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, 32);
        }
        else
        {
            offset = PELS_TO_BYTES(YOffset + XOffset);

            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, PELS_TO_BYTES(16));
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, PELS_TO_BYTES(8));
        }

        CP_MM_SRC_ADDR(ppdev, pjBase, (ulPatternAddrBase + offset));
        CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(8) - 1));
        CP_MM_YCNT(ppdev, pjBase, (8 - 1));
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulAlignedPatternOffset);
        CP_MM_START_BLT(ppdev, pjBase);

        // fill using aligned pattern

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        CP_MM_BLT_MODE(ppdev, pjBase, jMode);
        CP_MM_ROP(ppdev, pjBase, jHwRop);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
        CP_MM_SRC_ADDR(ppdev, pjBase, ulAlignedPatternOffset);
        CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));
        CP_MM_DST_ADDR(ppdev, pjBase, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
        CP_MM_START_BLT(ppdev, pjBase);

        prcl++;

    } while (--c != 0);
}


/**************************************************************************
* VOID vMmFillSolid
*
* Does a solid fill to a list of rectangles.
*
**************************************************************************/

VOID vMmFillSolid(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  // Not used
{
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    LONG        cBpp = ppdev->cBpp;
    ULONG       ulSolidColor;
    BYTE        jHwRop;

    DISPDBG((10,"vFillSolid called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    ulSolidColor = rbc.iSolidColor;

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];

    //
    // Make sure we can write to the video registers.
    //

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_ROP(ppdev, pjBase, jHwRop);
    CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND |
                                ENABLE_8x8_PATTERN_COPY |
                                ppdev->jModeColor);
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);

    if (ppdev->flCaps & CAPS_AUTOSTART)
    {
        CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
    }

    //
    // Fill the list of rectangles
    //

    while (TRUE)
    {
        CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));
        CP_MM_DST_ADDR(ppdev, pjBase, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
        CP_MM_START_BLT(ppdev, pjBase);

        if (--c == 0)
            return;

        prcl++;
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    }
}


/**************************************************************************
* VOID vMmCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
**************************************************************************/

VOID vMmCopyBlt(
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ROP4    rop4,       // Obvious?
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG        dx;
    LONG        dy;     // Add delta to destination to get source

    LONG        xyOffset = ppdev->xyOffset;
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    BYTE        jHwRop;

    DISPDBG((10,"vCopyBlt called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    //
    // Make sure we can write to the video registers.
    //

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    jHwRop = gajHwMixFromRop2[rop4 & 0xf];
    CP_MM_ROP(ppdev, pjBase, jHwRop);

    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    //
    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:
    //

    if (!OVERLAP(prclDst, pptlSrc) ||
        (prclDst->top < pptlSrc->y) ||
        ((prclDst->top == pptlSrc->y) && (prclDst->left <= pptlSrc->x))
        )
    {
        //
        // Top to Bottom - Left to Right
        //

        DISPDBG((12,"Top to Bottom - Left to Right"));

        CP_MM_BLT_MODE(ppdev, pjBase, DIR_TBLR);

        while (TRUE)
        {
            CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
            CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

            CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->top + dy) * lDelta) + PELS_TO_BYTES(prcl->left + dx)));
            CP_MM_DST_ADDR(ppdev, pjBase, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
            CP_MM_START_BLT(ppdev, pjBase);

            if (--c == 0)
                return;

            prcl++;
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
    }
    else
    {
        //
        // Bottom to Top - Right to Left
        //

        DISPDBG((12,"Bottom to Top - Right to Left"));

        CP_MM_BLT_MODE(ppdev, pjBase, DIR_BTRL);

        while (TRUE)
        {
            CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
            CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

            CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->bottom - 1 + dy) * lDelta) + PELS_TO_BYTES(prcl->right + dx) - 1));
            CP_MM_DST_ADDR(ppdev, pjBase, (((prcl->bottom - 1) * lDelta) + PELS_TO_BYTES(prcl->right) - 1));
            CP_MM_START_BLT(ppdev, pjBase);

            if (--c == 0)
                return;

            prcl++;
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vMmXfer1bpp
*
* Low-level routine used to transfer monochrome data to the screen using
* DWORD writes to the blt engine.
*
* This can handle opaque or transparent expansions.  It does opaque
* expansions by drawing the opaque rectangle first and then transparently
* expands the foreground bits.
*
\**************************************************************************/

VOID vMmXfer1bpp(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // Actually had better be a rop3
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides color-expansion information
{
    ULONG* pulXfer;
    ULONG* pul;
    LONG   ix;
    LONG   iy;
    LONG   cxWidthInBytes;
    BYTE*  pjBits;
    POINTL ptlDst;
    POINTL ptlSrc;
    SIZEL  sizlDst;
    LONG   cxLeftMask;
    LONG   cxRightMask;
    ULONG  ulDstAddr;
    INT    nDwords;
    ULONG  ulLeftMask;
    ULONG  ulRightMask;
    LONG   dx;
    LONG   dy;

    BYTE* pjBase    = ppdev->pjBase;
    LONG  lDelta    = ppdev->lDelta;
    LONG  lDeltaSrc = psoSrc->lDelta;
    LONG  cBpp      = ppdev->cBpp;
    ULONG ulFgColor = pxlo->pulXlate[1];
    ULONG ulBgColor = pxlo->pulXlate[0];

    // Since the hardware clipping on some of the Cirrus chips is broken, we
    // do the clipping by rounding out the edges to dword boundaries and then
    // doing the blt transparently.  In the event that we want the expansion
    // to be opaque, we do the opaquing blt in advance.  One side effect of
    // this is that the destination bits are no longer valid for processing
    // the rop.  This could probably be optimized by doing the edges seperately
    // and then doing the middle section in one pass.  However, this is
    // complicated by a 5434 bug that breaks blts less than 10 pixels wide.

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) == 0xcc00), "Expected foreground rop of 0xcc");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    if (cBpp == 1)
    {
        ulFgColor = (ulFgColor << 8) | (ulFgColor & 0xff);
        ulBgColor = (ulBgColor << 8) | (ulBgColor & 0xff);
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }
    else if (cBpp == 2)
    {
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }

    pulXfer = ppdev->pulXfer;
#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    if (rop4 != 0xCCAA)
    {
        LONG    lCnt = c;
        RECTL*  prclTmp = prcl;
        BYTE    jHwBgRop = gajHwMixFromRop2[rop4 & 0xf];

        CP_MM_ROP(ppdev, pjBase, jHwBgRop);
        CP_MM_FG_COLOR(ppdev, pjBase, ulBgColor);
        CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
        CP_MM_BLT_MODE(ppdev, pjBase, ppdev->jModeColor |
                                    ENABLE_COLOR_EXPAND |
                                    ENABLE_8x8_PATTERN_COPY);

        do
        {
            // calculate the size of the blt

            ptlDst.x = prclTmp->left;
            ptlDst.y = prclTmp->top;
            sizlDst.cx = prclTmp->right - ptlDst.x;
            sizlDst.cy = prclTmp->bottom - ptlDst.y;

            //
            // Fill the background rectangle with the background color
            //

            // Set the dest addresses

            ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

            CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);

            // Start the blt operation

            CP_MM_START_BLT(ppdev, pjBase);
            prclTmp++;
        } while (--lCnt != 0);

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    }

    CP_MM_FG_COLOR(ppdev, pjBase, ulFgColor);
    CP_MM_BG_COLOR(ppdev, pjBase, ~ulFgColor);
    CP_IO_XPAR_COLOR(ppdev, pjBase, ~ulFgColor);
    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
    CP_MM_BLT_MODE(ppdev, pjBase, ppdev->jModeColor |
                                ENABLE_COLOR_EXPAND |
                                ENABLE_TRANSPARENCY_COMPARE |
                                SRC_CPU_DATA);
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);                // jl01

    do
    {
        // calculate the size of the blt

        ptlDst.x = prcl->left;
        ptlDst.y = prcl->top;
        sizlDst.cx = prcl->right - ptlDst.x;
        sizlDst.cy = prcl->bottom - ptlDst.y;

        // calculate the number of dwords per scan line

        ptlSrc.x = prcl->left + dx;
        ptlSrc.y = prcl->top + dy;

        // Floor the source.
        // Extend the width by the amount required to floor to a dword boundary.
        // Set the size of the left mask.
        // Floor the dest, so it aligns with the floored source.

        if ((cxLeftMask = (ptlSrc.x & 31)))
        {
            sizlDst.cx += cxLeftMask;
            ptlSrc.x &= ~31;
            ptlDst.x -= cxLeftMask;
        }

        ulLeftMask = gaulLeftClipMask[cxLeftMask];

        // Ceil the cx to a dword boundary.

        if (cxRightMask = (sizlDst.cx & 31))
        {
            cxRightMask = 32 - cxRightMask;
            sizlDst.cx = (sizlDst.cx + 31) & ~31;
        }

        ulRightMask = gaulRightClipMask[cxRightMask];

        if (sizlDst.cx == 32)
        {
            ulLeftMask &= ulRightMask;
            ulRightMask = 0;
        }

        // Note: At this point sizlDst.cx is the width of the blt in pixels,
        //       floored to a dword boundary, and ceiled to a dword boundary.

        // Calculate the width in Bytes

        cxWidthInBytes  = sizlDst.cx >> 3;

        // Calculate the number of Dwords and any remaining bytes

        nDwords = cxWidthInBytes >> 2;

        ASSERTDD(((cxWidthInBytes & 0x03) == 0),
                 "cxWidthInBytes is not a DWORD multiple");

        // Calculate the address of the source bitmap
        // This is to a byte boundary.

        pjBits  = (PBYTE) psoSrc->pvScan0;
        pjBits += ptlSrc.y * lDeltaSrc;
        pjBits += ptlSrc.x >> 3;

        ASSERTDD((((ULONG_PTR)pjBits & 0x03) == 0),
                 "pjBits not DWORD aligned like it should be");

        //
        // Blt the 1 bpp bitmap
        //

        ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

		//
		// Tell the hardware that we want to write (sizlDst.cx) X amd (sizlDst.cy) Y bytes
		//
        CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
        CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);

        //
        // The 542x chips require a write to the Src Address Register when
        // doing a host transfer with color expansion.  The value is
        // irrelevant, but the write is crucial.  This is documented in
        // the manual, not the errata.  Go figure.
        //

        CP_MM_SRC_ADDR(ppdev, pjBase, 0);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);

        CP_MM_START_BLT(ppdev, pjBase);

        //
        // Transfer the host bitmap.
        //

        if (ulRightMask)
        {
            //
            // Blt is > 1 DWORD wide (nDwords > 1)
            //			
            for (iy = 0; iy < sizlDst.cy; iy++)
            {
                pul = (ULONG*) pjBits;

                //*pulXfer++ = *(((ULONG*)pul)++) & ulLeftMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul) & ulLeftMask));
                pul++;

                for (ix = 0; ix < (nDwords-2); ix++)
                {
                    //*pulXfer++ = *(((ULONG*)pul)++);
                    WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul)));
                    pul++;
                }
                //*pulXfer++ = *(((ULONG*)pul)++) & ulRightMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul) & ulRightMask));
                pul++;

                pjBits += lDeltaSrc;
                //pulXfer = ppdev->pulXfer;
                CP_MEMORY_BARRIER();     // Flush memory cache when we reset the address

            }
        }
        else
        {
            //
            // Blt is 1 DWORD wide (nDwords == 1)
            //

            for (iy = 0; iy < sizlDst.cy; iy++)
            {
                //*pulXfer = *((ULONG*)pjBits) & ulLeftMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pjBits) & ulLeftMask));
                pjBits += lDeltaSrc;
                
                CP_MEMORY_BARRIER();     // Flush memory cache
            }
        }

        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vMmXfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* NOTE: The screen must be 8bpp for this function to be called!
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.

#define XLATE_BUFFER_SIZE 256

VOID vMmXfer4bpp(
PDEV*     ppdev,
LONG      c,          // Count of rectangles, can't be zero
RECTL*    prcl,       // List of destination rectangles, in relative coordinates
ULONG     rop4,       // rop4
SURFOBJ*  psoSrc,     // Source surface
POINTL*   pptlSrc,    // Original unclipped source point
RECTL*    prclDst,    // Original unclipped destination rectangle
XLATEOBJ* pxlo)       // Translate that provides colour-expansion information
{
    ULONG  ulDstAddr;
    LONG   dx;
    LONG   dy;
    LONG   cx;
    LONG   cy;
    LONG   lSrcDelta;
    BYTE*  pjSrcScan0;
    BYTE*  pjScan;
    BYTE*  pjSrc;
    BYTE*  pjDst;
    LONG   cxThis;
    LONG   cxToGo;
    LONG   xSrc;
    LONG   iLoop;
    BYTE   jSrc;
    ULONG* pulXlate;
    LONG   cdwThis;
    BYTE*  pjBuf;
    BYTE   ajBuf[XLATE_BUFFER_SIZE];

    ULONG* pulXfer = ppdev->pulXfer;
    BYTE*  pjBase  = ppdev->pjBase;
    LONG   lDelta  = ppdev->lDelta;

    ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP, "Screen must be 8bpp");
    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    DISPDBG((5, "vXfer4bpp: entry"));

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

#if 1 // D5480
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, gajHwPackedMixFromRop2[rop4 & 0xf] | SRC_CPU_DATA);
#else
    CP_MM_ROP(ppdev, pjBase, gajHwMixFromRop2[rop4 & 0xf]);
    CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
#endif

    while(TRUE)
    {
        ulDstAddr = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(cx) - 1);
        CP_MM_YCNT(ppdev, pjBase, cy - 1);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);

        pulXlate  =  pxlo->pulXlate;
        xSrc      =  prcl->left + dx;
        pjScan    =  pjSrcScan0 + (prcl->top + dy) * lSrcDelta + (xSrc >> 1);

        CP_MM_START_BLT(ppdev, pjBase);

        do {
            pjSrc  = pjScan;
            cxToGo = cx;            // # of pels per scan in 4bpp source
            do {
                cxThis  = XLATE_BUFFER_SIZE;
                                    // We can handle XLATE_BUFFER_SIZE number
                                    //   of pels in this xlate batch
                cxToGo -= cxThis;   // cxThis will be the actual number of
                                    //   pels we'll do in this xlate batch
                if (cxToGo < 0)
                    cxThis += cxToGo;

                pjDst = ajBuf;      // Points to our temporary batch buffer

                // We handle alignment ourselves because it's easy to
                // do, rather than pay the cost of setting/resetting
                // the scissors register:

                if (xSrc & 1)
                {
                    // When unaligned, we have to be careful not to read
                    // past the end of the 4bpp bitmap (that could
                    // potentially cause us to access violate):

                    iLoop = cxThis >> 1;        // Each loop handles 2 pels;
                                                //   we'll handle odd pel
                                                //   separately
                    jSrc  = *pjSrc;
                    while (iLoop-- != 0)
                    {
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];
                        jSrc = *(++pjSrc);
                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                    }

                    if (cxThis & 1)
                        *pjDst = (BYTE) pulXlate[jSrc & 0xf];
                }
                else
                {
                    iLoop = (cxThis + 1) >> 1;  // Each loop handles 2 pels
                    do {
                        jSrc = *pjSrc++;

                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];

                    } while (--iLoop != 0);
                }

                // The number of bytes we'll transfer is equal to the number
                // of pels we've processed in the batch.  Since we're
                // transferring words, we have to round up to get the word
                // count:

                cdwThis = (cxThis + 3) >> 2;
                pjBuf  = ajBuf;

                TRANSFER_DWORD_ALIGNED(ppdev, pulXfer, pjBuf, cdwThis);

            } while (cxToGo > 0);

            pjScan += lSrcDelta;        // Advance to next source scan.  Note
                                        //   that we could have computed the
                                        //   value to advance 'pjSrc' directly,
                                        //   but this method is less
                                        //   error-prone.

        } while (--cy != 0);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vMmXferNative
*
* Transfers a bitmap that is the same color depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vMmXferNative(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    ULONG ulDstAddr;
    LONG  dx;
    LONG  dy;
    LONG  cx;
    LONG  cy;
    LONG  lSrcDelta;
    BYTE* pjSrcScan0;
    BYTE* pjSrc;
    LONG  cjSrc;

    ULONG* pulXfer = ppdev->pulXfer;
    BYTE*  pjBase  = ppdev->pjBase;
    LONG   lDelta  = ppdev->lDelta;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same color depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
#if 1 // D5480
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, gajHwPackedMixFromRop2[rop4 & 0xf] | SRC_CPU_DATA);
#else
    CP_MM_ROP(ppdev, pjBase, gajHwMixFromRop2[rop4 & 0xf]);
    CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
#endif

    while(TRUE)
    {
        ulDstAddr = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(cx) - 1);
        CP_MM_YCNT(ppdev, pjBase, cy - 1);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);

        cjSrc = PELS_TO_BYTES(cx);
        pjSrc = pjSrcScan0 + (prcl->top  + dy) * lSrcDelta
                           + (PELS_TO_BYTES(prcl->left + dx));

        CP_MM_START_BLT(ppdev, pjBase);
        vImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy);

        if (--c == 0)
            return;

        prcl++;
    }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                              //
//         N E W   B L T   R O U T I N E S   F O R   B R U S H   C A C H E      //
//                                                                              //
////////////////////////////////////////////////////////////////////////////////

VOID vMmFillSolid36(
PDEV*        ppdev,
LONG         c,
RECTL*       prcl,
ROP4         rop4,
RBRUSH_COLOR rbc,
POINTL*      pptlBrush)
{
    BYTE* pjBase = ppdev->pjBase;
    LONG  lDelta = ppdev->lDelta;
    BYTE  jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0x0F];
    BYTE  jMode  = ppdev->jModeColor
                 | ENABLE_8x8_PATTERN_COPY
                 | ENABLE_COLOR_EXPAND;

    while (c-- > 0)
    {
        ULONG ulDstOffset;
        SIZEL sizlDst;

        // Calculate the destination address and size.
        ulDstOffset = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        sizlDst.cx    = PELS_TO_BYTES(prcl->right - prcl->left) - 1;
        sizlDst.cy    = (prcl->bottom - prcl->top) - 1;

        // Wait for the bitblt engine.
        WAIT_BUSY_BLT(ppdev, pjBase);

        // Setup the bitblt registers.
        CP_MM_FG_COLOR(ppdev, pjBase, rbc.iSolidColor);
        CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
        CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
        CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);        // Disable clipping.
        CP_MM_BLT_MODE(ppdev, pjBase, jMode);
        CP_MM_ROP(ppdev, pjBase, jHwRop);
        CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

        // Next rectangle.
        prcl++;
    }
}

VOID vMmFillPat36(
PDEV*        ppdev,
LONG         c,
RECTL*       prcl,
ROP4         rop4,
RBRUSH_COLOR rbc,
POINTL*      pptlBrush)
{
    BYTE* pjBase = ppdev->pjBase;
    LONG  lDelta = ppdev->lDelta;
    BYTE  jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0x0F];

    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0) ;                           // chu01

    // Dithered brush...
    if (rbc.prb->fl == RBRUSH_DITHER)
    {
        DITHERCACHE* pdc;

        pdc = (DITHERCACHE*) ((ULONG_PTR)ppdev + rbc.prb->ulSlot);
        if (pdc->ulColor != rbc.prb->ulUniq)
        {
            // Cache entry is invalid, realize the brush again.
            bCacheDither(ppdev, rbc.prb);
        }

        while (c-- > 0)
        {
            ULONG ulDstOffset, ulSrcOffset;
            SIZEL sizlDst;
            LONG  xOffset, yOffset;
            LONG  x;

            // Calculate the brush rotation.
            xOffset     = (prcl->left - pptlBrush->x) & 7;
            yOffset     = (prcl->top  - pptlBrush->y) & 7;
            ulSrcOffset = rbc.prb->ulBrush | yOffset;

            // Calculate the destination and size.
            x            = prcl->left - xOffset;
            ulDstOffset = (prcl->top * lDelta) + x;
            sizlDst.cx  = (prcl->right - x) - 1;
            sizlDst.cy  = (prcl->bottom - prcl->top) - 1;

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Setup the bitblt registers.
            CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
            CP_MM_DST_WRITE_MASK(ppdev, pjBase, xOffset);
            CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_8x8_PATTERN_COPY);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

            // Next rectangle.
            prcl++;
        }
    }

    // Monochrome brush...
    else if (rbc.prb->fl == RBRUSH_MONOCHROME)
    {
        MONOCACHE* pmc;
        BYTE       jMode;
        ULONG       ulBgColor, ulFgColor;

        pmc = (MONOCACHE*) ((ULONG_PTR)ppdev + rbc.prb->ulSlot);
        if (pmc->ulUniq != rbc.prb->ulUniq)
        {
            // Cache entry is invalid, realize the brush again.
            bCacheMonochrome(ppdev, rbc.prb);
        }

        // Setup the common parameters.
        jMode        = ppdev->jModeColor
                     | ENABLE_8x8_PATTERN_COPY
                     | ENABLE_COLOR_EXPAND;
        ulBgColor  = rbc.prb->ulBackColor;
        ulFgColor  = rbc.prb->ulForeColor;

        // Monochrome brushes in 24-bpp are already cached expanded.
        if (ppdev->cBpp == 3)
        {
            jMode = ppdev->jModeColor
                  |    ENABLE_8x8_PATTERN_COPY;
        }

        // Walk through all rectangles.
        while (c-- > 0)
        {
            ULONG ulDstOffset, ulSrcOffset;
            SIZEL sizlDst;
            LONG  xOffset, yOffset;
            LONG  x;

            // Calculate the brush rotation.
            xOffset     = (prcl->left - pptlBrush->x) & 7;
            yOffset     = (prcl->top  - pptlBrush->y) & 7;
            ulSrcOffset = rbc.prb->ulBrush | yOffset;

            // Calculate the destination and size.
            x            = prcl->left - xOffset;
            ulDstOffset = (prcl->top * lDelta) + PELS_TO_BYTES(x);
            sizlDst.cx  = PELS_TO_BYTES(prcl->right - x) - 1;
            sizlDst.cy  = (prcl->bottom - prcl->top) - 1;
            if (ppdev->cBpp == 3)
            {
                xOffset *= 3;
            }

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Setup the bitblt registers.
            CP_MM_BG_COLOR(ppdev, pjBase, ulBgColor);
            CP_MM_FG_COLOR(ppdev, pjBase, ulFgColor);
            CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
            CP_MM_DST_WRITE_MASK(ppdev, pjBase, xOffset);
            CP_MM_BLT_MODE(ppdev, pjBase, jMode);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

            // Next rectangle.
            prcl++;
        }
    }

    // Patterned brush...
    else if    (ppdev->flStatus & STAT_PATTERN_CACHE)
    {
        PATTERNCACHE* ppc;

        BYTE jMode = ppdev->jModeColor
                   | ENABLE_8x8_PATTERN_COPY;

        ppc = (PATTERNCACHE*) ((ULONG_PTR)ppdev + rbc.prb->ulSlot);
        if (ppc->prbUniq != rbc.prb)
        {
            // Cache entry is invalid, realize the brush again.
            bCachePattern(ppdev, rbc.prb);
        }

        while (c-- > 0)
        {
            ULONG ulDstOffset, ulSrcOffset;
            SIZEL sizlDst;
            LONG  xOffset, yOffset;
            LONG  x;

            // Calculate the brush rotation.
            xOffset     = (prcl->left - pptlBrush->x) & 7;
            yOffset     = (prcl->top  - pptlBrush->y) & 7;
            ulSrcOffset = rbc.prb->ulBrush | yOffset;

            // Calculate the destination and size.
            x            = prcl->left - xOffset;
            ulDstOffset = (prcl->top * lDelta) + PELS_TO_BYTES(x);
            sizlDst.cx  = PELS_TO_BYTES(prcl->right - x) - 1;
            sizlDst.cy  = (prcl->bottom - prcl->top) - 1;
            if (ppdev->cBpp == 3)
            {
                xOffset *= 3;
            }

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Setup the bitblt registers.
            CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
            CP_MM_DST_WRITE_MASK(ppdev, pjBase, xOffset);
            CP_MM_BLT_MODE(ppdev, pjBase, jMode);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

            // Next rectangle.
            prcl++;
        }
    }

    // Old-style brush cache.
    else
    {
        vMmFillPat(ppdev, c, prcl, rop4, rbc, pptlBrush);
    }
}

VOID vMmCopyBlt36(
PDEV*   ppdev,
LONG    c,
RECTL*  prcl,
ROP4    rop4,
POINTL* pptlSrc,
RECTL*  prclDst)
{
    LONG  xy;
    LONG  cx, cy;
    ULONG ulSrc, ulDst;

    BYTE  jHwRop   = gajHwMixFromRop2[rop4 & 0x0F];
    LONG  xyOffset = ppdev->xyOffset;
    BYTE* pjBase   = ppdev->pjBase;
    LONG  lDelta   = ppdev->lDelta;

    DISPDBG((10, "vMmCopyBlt36 called"));

    // The src-dst delta will be the same for all rectangles.
    xy = ((pptlSrc->y - prclDst->top) * lDelta)
       + PELS_TO_BYTES(pptlSrc->x - prclDst->left);

    // Determine the direction of the blit.
    if ((xy >= 0) || !OVERLAP(prclDst, pptlSrc))
    {
        DISPDBG((12, "Top to Bottom - Left to Right"));

        while (c-- > 0)
        {
            // Calculate the blit size and offsets.
            cx    = PELS_TO_BYTES(prcl->right - prcl->left) - 1;
            cy    = (prcl->bottom - prcl->top) - 1;
            ulDst = xyOffset + (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
            ulSrc = ulDst + xy;

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Perform the move.
            CP_MM_XCNT(ppdev, pjBase, cx);
            CP_MM_YCNT(ppdev, pjBase, cy);
            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrc);
            CP_MM_BLT_MODE(ppdev, pjBase, DIR_TBLR);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDst);

            // Next rectangle.
            prcl++;
        }
    }

    else
    {
        DISPDBG((12, "Bottom to Top - Right to Left"));

        while (c-- > 0)
        {
            // Calculate the blit size and offsets.
            cx    = PELS_TO_BYTES(prcl->right - prcl->left) - 1;
            cy    = (prcl->bottom - prcl->top) - 1;
            ulDst = xyOffset + ((prcl->bottom - 1) * lDelta)
                  + (PELS_TO_BYTES(prcl->right) - 1);
            ulSrc = ulDst + xy;

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Perform the move.
            CP_MM_XCNT(ppdev, pjBase, cx);
            CP_MM_YCNT(ppdev, pjBase, cy);
            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrc);
            CP_MM_BLT_MODE(ppdev, pjBase, DIR_BTRL);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDst);

            // Next rectangle.
            prcl++;
        }
    }
}

#if 1 // D5480
VOID vMmFillSolid80(
PDEV*        ppdev,
LONG         c,
RECTL*       prcl,
ROP4         rop4,
RBRUSH_COLOR rbc,
POINTL*      pptlBrush)
{
    ULONG_PTR*  ulCLStart;
    ULONG   ulWidthHeight;
    ULONG   xCLOffset;
    ULONG   ulDstOffset = 0;
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    lDelta   = ppdev->lDelta;
    DWORD   jHwRop   = gajHwPackedMixFromRop2[(rop4 >> 2) & 0x0F];
    DWORD   jExtMode = ENABLE_SOLID_FILL_PACKED
                       | ENABLE_XY_POSITION_PACKED
                       | ppdev->jModeColor  
                       | ENABLE_8x8_PATTERN_COPY
                       | ENABLE_COLOR_EXPAND;

    //
    // Make sure we can write to the video registers.
    //
    // We need to change to wait for buffer ready
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    // Setup the bitblt registers.
    CP_MM_FG_COLOR(ppdev, pjBase, rbc.iSolidColor);
    // Do we really need to set it every time?
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    // Do we need to clear Source XY?
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);
    CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);        // Disable clipping.
    
    // Setup first set registers
    xCLOffset = prcl->left;
    CP_MM_DST_Y(ppdev, pjBase, prcl->top);
    CP_MM_XCNT(ppdev, pjBase, (prcl->right - prcl->left) - 1);
    CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);

    if (--c)
    {
        // There are more than one rectangle
        prcl++;
        jExtMode |= ENABLE_COMMAND_LIST_PACKED;
        ulCLStart = ppdev->pCommandList;
        ulDstOffset |= ((ULONG)((ULONG_PTR)ulCLStart
                              - (ULONG_PTR)ppdev->pjScreen) << 14);
        CP_MM_CL_SWITCH(ppdev);
        while (TRUE)
        {
            // Command List

            // Calculate the destination address and size.
            ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left) - 1, 
                                        (prcl->bottom - prcl->top) - 1);
            ulWidthHeight |= COMMAND_NOSRC_NOTHING;
            // XY
            *(ulCLStart + 1) = PACKXY_FAST(prcl->left, prcl->top);
          
            // Source Start address
            *(ulCLStart + 2) = 0;

            if (c == 1)
            {
                ulWidthHeight |= COMMAND_LAST_PACKET;
                *ulCLStart = ulWidthHeight;
                // Last Command
                break;
            }
        
            *ulCLStart = ulWidthHeight;
            // Next rectangle.
            prcl++;
            c--;
            ulCLStart += 4;
        }
    }
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop );
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
    CP_MM_DST_X(ppdev, pjBase, xCLOffset);
}

VOID vMmFillPat80(
PDEV*        ppdev,
LONG         c,
RECTL*       prcl,
ROP4         rop4,
RBRUSH_COLOR rbc,
POINTL*      pptlBrush)
{
    ULONG   xOffset, yOffset;
    ULONG   ulSrcOffset;
    ULONG_PTR*  ulCLStart;
    ULONG   ulWidthHeight;
    ULONG   xCLOffset;
    ULONG   ulDstOffset = 0;
    BYTE*   pjBase = ppdev->pjBase;
    LONG    lDelta = ppdev->lDelta;
    DWORD   jHwRop = gajHwPackedMixFromRop2[(rop4 >> 2) & 0x0F];
    DWORD   jExtMode = ENABLE_XY_POSITION_PACKED
                       | ENABLE_8x8_PATTERN_COPY;

    // Dithered brush...
    if (rbc.prb->fl == RBRUSH_DITHER)
    {
        DITHERCACHE* pdc;

        pdc = (DITHERCACHE*) ((ULONG_PTR)ppdev + rbc.prb->ulSlot);
        if (pdc->ulColor != rbc.prb->ulUniq)
        {
            // Cache entry is invalid, realize the brush again.
            bCacheDither(ppdev, rbc.prb);
        }

        // Calculate the brush rotation.
        xOffset     = (prcl->left - pptlBrush->x) & 7;
        yOffset     = (prcl->top  - pptlBrush->y) & 7;
        ulSrcOffset = rbc.prb->ulBrush | yOffset | (xOffset << 24);

        // Calculate the destination and size.
        xCLOffset   = prcl->left - xOffset;

        //
        // Make sure we can write to the video registers.
        //
        // We need to change to wait for buffer ready
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        // Do we really need to set it every time?
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

        // Do we need to clear Source XY?
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);
    
        // Setup first set registers
        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - xCLOffset) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset |= ((ULONG)((ULONG_PTR)ulCLStart
                                  - (ULONG_PTR)ppdev->pjScreen) << 14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the brush rotation.
                xOffset     = (prcl->left - pptlBrush->x) & 7;
                yOffset     = (prcl->top  - pptlBrush->y) & 7;

                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left + xOffset ) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->left - xOffset, prcl->top);
            
                // Source Start address
                *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | (xOffset << 24);

                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
        
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop );
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }

    // Monochrome brush...
    else if (rbc.prb->fl == RBRUSH_MONOCHROME)
    {
        MONOCACHE* pmc;
        BYTE       jMode;
        ULONG       ulBgColor, ulFgColor;

        pmc = (MONOCACHE*) ((ULONG_PTR) ppdev + rbc.prb->ulSlot);
        if (pmc->ulUniq != rbc.prb->ulUniq)
        {
            // Cache entry is invalid, realize the brush again.
            bCacheMonochrome(ppdev, rbc.prb);
        }

        ulBgColor  = rbc.prb->ulBackColor;
        ulFgColor  = rbc.prb->ulForeColor;
        // Calculate the brush rotation.
        xOffset     = (prcl->left - pptlBrush->x) & 7;
        yOffset     = (prcl->top  - pptlBrush->y) & 7;
        // Monochrome brushes in 24-bpp are already cached expanded.
        if (ppdev->cBpp == 3)
        {
            jExtMode |= ppdev->jModeColor;
            ulSrcOffset = rbc.prb->ulBrush | yOffset | ((xOffset * 3) << 24);
        }
        else
        {
            jExtMode |= (ppdev->jModeColor | ENABLE_COLOR_EXPAND);
            ulSrcOffset = rbc.prb->ulBrush | yOffset | (xOffset << 24);
        }


        // Calculate the destination and size.
        xCLOffset   = prcl->left - xOffset;
        //
        // Make sure we can write to the video registers.
        //
        // We need to change to wait for buffer ready
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        // Do we really need to set it every time?
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

        // Do we need to clear Source XY?
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);
    
        // Setup first set registers
        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - xCLOffset) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);
        CP_MM_BG_COLOR(ppdev, pjBase, ulBgColor);
        CP_MM_FG_COLOR(ppdev, pjBase, ulFgColor);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset
              |= (ULONG)(((ULONG_PTR)ulCLStart - (ULONG_PTR)ppdev->pjScreen)<<14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the brush rotation.
                xOffset     = (prcl->left - pptlBrush->x) & 7;
                yOffset     = (prcl->top  - pptlBrush->y) & 7;

                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left + xOffset ) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->left - xOffset, prcl->top);
            
                // Source Start address
                if(ppdev->cBpp == 3)
                    *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | ((xOffset * 3) << 24);
                else
                    *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | (xOffset << 24);

                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
        
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop );
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }

    // Patterned brush...
    else if    (ppdev->flStatus & STAT_PATTERN_CACHE)
    {
        PATTERNCACHE* ppc;

        ppc = (PATTERNCACHE*) ((ULONG_PTR) ppdev + rbc.prb->ulSlot);
        if (ppc->prbUniq != rbc.prb)
        {
            // Cache entry is invalid, realize the brush again.
            bCachePattern(ppdev, rbc.prb);
        }

        // Calculate the brush rotation.
        xOffset     = (prcl->left - pptlBrush->x) & 7;
        yOffset     = (prcl->top  - pptlBrush->y) & 7;
        // Monochrome brushes in 24-bpp are already cached expanded.
        jExtMode |= ppdev->jModeColor;
        if (ppdev->cBpp == 3)
        {
            ulSrcOffset = rbc.prb->ulBrush | yOffset | ((xOffset * 3) << 24);
        }
        else
        {
            ulSrcOffset = rbc.prb->ulBrush | yOffset | (xOffset << 24);
        }


        // Calculate the destination and size.
        xCLOffset   = prcl->left - xOffset;
        //
        // Make sure we can write to the video registers.
        //
        // We need to change to wait for buffer ready
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        // Do we really need to set it every time?
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

        // Do we need to clear Source XY?
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);
    
        // Setup first set registers
        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - xCLOffset) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset
              |= (ULONG)(((ULONG_PTR)ulCLStart-(ULONG_PTR)ppdev->pjScreen)<<14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the brush rotation.
                xOffset     = (prcl->left - pptlBrush->x) & 7;
                yOffset     = (prcl->top  - pptlBrush->y) & 7;

                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left + xOffset ) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->left - xOffset, prcl->top);
            
                // Source Start address
                if(ppdev->cBpp == 3)
                    *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | ((xOffset * 3) << 24);
                else
                    *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | (xOffset << 24);

                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
        
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop );
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }

    // Old-style brush cache.
    else
    {
        vMmFillPat(ppdev, c, prcl, rop4, rbc, pptlBrush);
    }
}


VOID vMmCopyBlt80(
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ROP4    rop4,       // Obvious?
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source

    ULONG   jHwRop;
    ULONG_PTR*  ulCLStart;
    ULONG   ulWidthHeight;
    ULONG   xCLOffset;
    ULONG   ulDstOffset = 0;
    LONG    xyOffset = ppdev->xyOffset;
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    lDelta   = ppdev->lDelta;
    DWORD   jExtMode = ENABLE_XY_POSITION_PACKED |
                       ppdev->jModeColor;

    DISPDBG((10,"vCopyBlt called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    //
    // Make sure we can write to the video registers.
    //
    // We need to change to wait for buffer ready
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    jHwRop = gajHwPackedMixFromRop2[rop4 & 0xf];

    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDelta);
    // Do we really need to set it every time?
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    //
    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:
    //

    if (!OVERLAP(prclDst, pptlSrc) ||
        (prclDst->top < pptlSrc->y) ||
        ((prclDst->top == pptlSrc->y) && (prclDst->left <= pptlSrc->x))
        )
    {
        //
        // Top to Bottom - Left to Right
        //

        DISPDBG((12,"Top to Bottom - Left to Right"));

        // Setup first set registers
        xCLOffset = prcl->left;
        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - prcl->left) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);
        CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->top + dy) * lDelta) + PELS_TO_BYTES(prcl->left + dx)));
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset
              |= (ULONG)(((ULONG_PTR)ulCLStart - (ULONG_PTR)ppdev->pjScreen)<<14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->left, prcl->top);
                // Source Start address
                *(ulCLStart + 2) = xyOffset + (prcl->top + dy) * lDelta + PELS_TO_BYTES(prcl->left + dx);
            
                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
            
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }
    else
    {
        //
        // Bottom to Top - Right to Left
        //

        DISPDBG((12,"Bottom to Top - Right to Left"));

        // Setup first set registers
        xCLOffset = prcl->right - 1;
        CP_MM_DST_Y(ppdev, pjBase, prcl->bottom - 1);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - prcl->left) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);
        CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->bottom - 1 + dy) * lDelta) + PELS_TO_BYTES(prcl->right + dx - 1)));
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset
             |=(ULONG)(((ULONG_PTR)ulCLStart - (ULONG_PTR)ppdev->pjScreen) << 14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->right - 1, prcl->bottom - 1);
                // Source Start address
                *(ulCLStart + 2) = xyOffset + (prcl->bottom - 1 + dy) * lDelta + PELS_TO_BYTES(prcl->right + dx - 1);
            
                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
            
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop | DIR_BTRL);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }
}

/******************************Public*Routine******************************\
* VOID vMmXfer1bpp80
*
* Low-level routine used to transfer monochrome data to the screen using
* DWORD writes to the blt engine.
*
* This can handle opaque or transparent expansions.  It does opaque
* expansions by drawing the opaque rectangle first and then transparently
* expands the foreground bits.
*
\**************************************************************************/

VOID vMmXfer1bpp80(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // Actually had better be a rop3
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides color-expansion information
{
    ULONG* pulXfer;
    ULONG* pul;
    LONG   ix;
    LONG   iy;
    LONG   cxWidthInBytes;
    BYTE*  pjBits;
    POINTL ptlDst;
    POINTL ptlSrc;
    SIZEL  sizlDst;
    LONG   cxLeftMask;
    LONG   cxRightMask;
    ULONG  ulDstAddr;
    INT    nDwords;
    ULONG  ulLeftMask;
    ULONG  ulRightMask;
    LONG   dx;
    LONG   dy;

    BYTE* pjBase    = ppdev->pjBase;
    LONG  lDelta    = ppdev->lDelta;
    LONG  lDeltaSrc = psoSrc->lDelta;
    LONG  cBpp      = ppdev->cBpp;
    ULONG ulFgColor = pxlo->pulXlate[1];
    ULONG ulBgColor = pxlo->pulXlate[0];

    // Since the hardware clipping on some of the Cirrus chips is broken, we
    // do the clipping by rounding out the edges to dword boundaries and then
    // doing the blt transparently.  In the event that we want the expansion
    // to be opaque, we do the opaquing blt in advance.  One side effect of
    // this is that the destination bits are no longer valid for processing
    // the rop.  This could probably be optimized by doing the edges seperately
    // and then doing the middle section in one pass.  However, this is
    // complicated by a 5434 bug that breaks blts less than 10 pixels wide.

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) == 0xcc00), "Expected foreground rop of 0xcc");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

#if 0
    if (cBpp == 1)
    {
        ulFgColor = (ulFgColor << 8) | (ulFgColor & 0xff);
        ulBgColor = (ulBgColor << 8) | (ulBgColor & 0xff);
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }
    else if (cBpp == 2)
    {
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }
#endif

    pulXfer = ppdev->pulXfer;

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

                if (rop4 != 0xCCAA)
    {
        LONG    lCnt = c;
        RECTL*  prclTmp = prcl;
        DWORD   jHwBgRop = gajHwPackedMixFromRop2[rop4 & 0xf];

        CP_MM_FG_COLOR(ppdev, pjBase, ulBgColor);
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, ENABLE_XY_POSITION_PACKED |
                                    ENABLE_SOLID_FILL_PACKED |
                                    jHwBgRop |
                                    ppdev->jModeColor |
                                    ENABLE_COLOR_EXPAND |
                                    ENABLE_8x8_PATTERN_COPY);

        CP_MM_DST_ADDR(ppdev, pjBase, 0);
        do
        {
            // calculate the size of the blt

            ptlDst.x = prclTmp->left;
            ptlDst.y = prclTmp->top;

            //
            // Fill the background rectangle with the background color
            //

            // Set the dest addresses

            ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

            CP_MM_XCNT(ppdev, pjBase, prclTmp->right - ptlDst.x - 1);
            CP_MM_YCNT(ppdev, pjBase, prclTmp->bottom - ptlDst.y - 1);
            CP_MM_DST_Y(ppdev, pjBase, ptlDst.y);
            CP_MM_DST_X(ppdev, pjBase, ptlDst.x);
            prclTmp++;
        } while (--lCnt != 0);

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    }

    CP_MM_FG_COLOR(ppdev, pjBase, ulFgColor);
    CP_MM_BG_COLOR(ppdev, pjBase, ~ulFgColor);
    //    CP_IO_XPAR_COLOR(ppdev, pjBase, ~ulFgColor);
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, ENABLE_XY_POSITION_PACKED |
                                ENABLE_CLIP_RECT_PACKED |
                                CL_PACKED_SRC_COPY |
                                ppdev->jModeColor |
                                ENABLE_COLOR_EXPAND |
                                ENABLE_TRANSPARENCY_COMPARE |
                                SRC_CPU_DATA |
                                SOURCE_GRANULARITY_PACKED);

    CP_MM_DST_ADDR(ppdev, pjBase, 0);
    do
    {
        // calculate the size of the blt

        ptlDst.x = prcl->left;
        ptlDst.y = prcl->top;
        sizlDst.cx = prcl->right - ptlDst.x;
        sizlDst.cy = prcl->bottom - ptlDst.y;

        // calculate the number of dwords per scan line

        ptlSrc.x = prcl->left + dx;
        ptlSrc.y = prcl->top + dy;

        // Floor the source.
        // Extend the width by the amount required to floor to a dword boundary.
        // Set the size of the left mask.
        // Floor the dest, so it aligns with the floored source.

        if ((cxLeftMask = (ptlSrc.x & 31)))
        {
            sizlDst.cx += cxLeftMask;
            ptlSrc.x &= ~31;
            ptlDst.x -= cxLeftMask;
        }

        // Calculate the width in Bytes

        cxWidthInBytes  = (sizlDst.cx + 7) >> 3;

        // Calculate the address of the source bitmap
        // This is to a byte boundary.

        pjBits  = (PBYTE) psoSrc->pvScan0;
        pjBits += ptlSrc.y * lDeltaSrc;
        pjBits += ptlSrc.x >> 3;

        ASSERTDD((((ULONG_PTR)pjBits & 0x03) == 0),
                 "pjBits not DWORD aligned like it should be");

        //
        // Blt the 1 bpp bitmap
        //
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        // set clipping register
        CP_MM_CLIP_ULXY(ppdev, pjBase, prcl->left, prcl->top);
        CP_MM_CLIP_LRXY(ppdev, pjBase, prcl->right - 1, prcl->bottom - 1);

        CP_MM_DST_Y(ppdev, pjBase, ptlDst.y);
        CP_MM_XCNT(ppdev, pjBase, sizlDst.cx - 1);
        CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);
        CP_MM_DST_X(ppdev, pjBase, ptlDst.x);

        //
        // Transfer the host bitmap.
        //
        vImageTransfer(ppdev, pjBits, lDeltaSrc, cxWidthInBytes, sizlDst.cy);
        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vMmXferNative80
*
* Transfers a bitmap that is the same color depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vMmXferNative80(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*    pjSrcScan0;
    BYTE*    pjSrc;
    LONG    cjSrc;

    BYTE*    pjBase    = ppdev->pjBase;
    LONG    lDelta    = ppdev->lDelta;
    DWORD    jHwRop    = gajHwPackedMixFromRop2[rop4 & 0x0F];
    DWORD    jExtMode= ENABLE_XY_POSITION_PACKED | 
                       SRC_CPU_DATA |
                       ppdev->jModeColor;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same color depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;


    //
    // Make sure we can write to the video registers.
    //
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jHwRop | jExtMode);
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);


    while(TRUE)
    {
    
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        cjSrc = PELS_TO_BYTES(cx);
        pjSrc = pjSrcScan0 + (prcl->top  + dy) * lSrcDelta
                           + (PELS_TO_BYTES(prcl->left + dx));

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_XCNT(ppdev, pjBase, cx - 1);
        CP_MM_YCNT(ppdev, pjBase, cy - 1);

        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_DST_ADDR(ppdev, pjBase, 0);
        CP_MM_DST_X(ppdev, pjBase, prcl->left);
        vImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy);

        if (--c == 0)
            break;

        prcl++;
    }
}

#endif // endif D5480
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

VOID vDitherColorToVideoMemory(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;
    ULONG i;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex

        for (i=0; i<16; i++) {
            WRITE_REGISTER_ULONG(pulDest+i, ulColor);
        }

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+2)], jColor);
                    case 2:
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+1)], jColor);
                    case 1:
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+0)], jColor);
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        WRITE_REGISTER_UCHAR(&pjDither[*pulDitherOrder], jColor);
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+1)], jColor);
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+2)], jColor);
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+3)], jColor);

                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);


    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex

        for (i=0; i<16; i++) {
            WRITE_REGISTER_ULONG(pulDest+i, ulColor);
        }

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+2)], jColor);
            case 2:
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+1)], jColor);
            case 1:
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+0)], jColor);
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {

                WRITE_REGISTER_UCHAR(&pjDither[*pulDitherOrder], jColor);
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+1)], jColor);
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+2)], jColor);
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+3)], jColor);
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];

        for (i=0; i<16; i++) {
            WRITE_REGISTER_ULONG(pulDest+i, ulColor);
        }

    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData);// # of vertices with more
                                                //than zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convenience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\dispint.h ===
/**********************************************************
* Copyright Cirrus Logic, 1995. All rights reserved.
***********************************************************
*       File Name:  DISPINT.H
*
*       Module Abstract:
*       ----------------
*       Defines the interface for communicating between the display
*       driver and the Direct Draw driver.
*
***********************************************************
*       Author: Scott MacDonald
*       Date:   03/07/95
*
*       Revision History:
*       -----------------
*  WHO      WHEN     WHAT/WHY/HOW
*  ---      ----     ------------
*
* #mgm1   12/06/95   uncomment CHIPAUTOSTART.  This should now
*                    work when MapSL() works in DriverInit().
* #mgm2   01/02/96   Add 7548 chip ID.
*
***********************************************************/


/*
 * Flags for the StopAsync callback
 */
#define ASYNC_BLT            0x0001       // Async surface halted due to BLT

/*
 * Flags for the DISPDRVINFO structure
 */
#define DI_LCD               0x0001       // LCD panel is in use
#define DI_SOFTCURSOR        0x0002       // Software cursor is in use

/*
 * Display information passed to the Direct Draw driver from the display
 * driver using either SetInfo or GetInfo.
 */
typedef struct
{
    DWORD dwSize;
    DWORD dwResolutionX;
    DWORD dwResolutionY;
    DWORD dwBitCount;
    DWORD dwPitch;
    DWORD dwFlags;
    DWORD dwMemMapSel;
} DISPDRVINFO, FAR * LPDISPDRVINFO;

/*
 * prototypes for communication functions
 */
typedef void (WINAPI *LPGetInfo)  (LPDISPDRVINFO);


/*
 * Structure passed to the Direct Draw driver from the display driver.
 * This contains entry points that we can call for various services.
 */
typedef struct
{
    DWORD           dwSize;
#if 0
    LPMemMgrAlloc   lpfnMemMgrAlloc;
    LPMemMgrPreempt lpfnMemMgrPreempt;
    LPMemMgrLock    lpfnMemMgrLock;
    LPMemMgrUnlock  lpfnMemMgrUnlock;
    LPMemMgrFree    lpfnMemMgrFree;
    LPMemMgrQuery   lpfnMemMgrQueryFreeMem;
#endif
    FARPROC         lpfnExcludeCursor;
    FARPROC         lpfnUnexcludeCursor;
    LPGetInfo       lpfnGetInfo;
    FARPROC         lpfnEnableAsyncCallback;
} DISPDRVCALL, FAR * LPDISPDRVCALL;


/*
 * Structure passed to the display driver from the Direct Draw driver.
 * This allows the display driver to notify us changes, etc.
 */
typedef struct
{
    DWORD dwSize;
    FARPROC lpfnSetInfo;
    FARPROC lpfnStopAsync;
} DCICALL, FAR * LPDCICALL;

// Note if definition changes, cirrus.inc and 5440over.c needs
// to be changed also.
#define CHIP5420 0x0001
#define CHIP5422 0x0002
#define CHIP5424 0x0004
#define CHIP5425 0x0008

#define CHIP5426 0x0010
#define CHIP5428 0x0020
#define CHIP5429 0x0040
#define CHIP542x (CHIP5420 | CHIP5422 | CHIP5424 | CHIP5425 | CHIP5426 |\
                  CHIP5428 | CHIP5429)

#define CHIP5430 0x0100
#define CHIP5434 0x0200
#define CHIP5436 0x0400
#define CHIP5446 0x0800
#define CHIP543x (CHIP5430 | CHIP5434 | CHIP5436 | CHIP5446)

#define CHIP5440 0x1000
#define CHIPM40  0x10000
#define CHIP544x (CHIP5440 | CHIP5446 | CHIPM40)

#define CHIP7541 0x2000
#define CHIP7543 0x4000
#define CHIP7548 0x8000										//#mgm2
#define CHIP754x (CHIP7541 | CHIP7543 | CHIP7548)	//#mgm2

#define CHIPBLTER (CHIP5426 | CHIP5428 | CHIP5429 | CHIP543x | CHIP544x |\
		   CHIP754x)

#define CHIPCOLORKEYBLTER   (CHIP5426 | CHIP5428 | CHIP5436 | CHIP5446 |\
                            CHIP754x | CHIPM40)

#define CHIPCURRENTVLINE    (CHIP5436 | CHIP5446 | CHIPM40)

#define CHIPAUTOSTART  (CHIP5436 | CHIP5446)        //#mgm1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\enable.c ===
/******************************************************************************\
*
* $Workfile:   enable.c  $
*
* This module contains the functions that enable and disable the driver, the
* pdev, and the surface.
*
* Copyright (c) 1992-1997 Microsoft Corporation.
* Copyright (c) 1996-1997 Cirrus Logic, Inc.,
*
* $Log:   S:/projects/drivers/ntsrc/display/enable.c_v  $
 *
 *    Rev 1.21   Apr 03 1997 15:38:50   unknown
 *
 *
 *    Rev 1.20   28 Mar 1997 16:08:40   PLCHU
 *
 *
 *    Rev 1.12   Jan 15 1997 09:41:32   unknown
 * Change to Version 4.0.5
 *
 *    Rev 1.11   Jan 14 1997 18:00:32   unknown
 * disable command list due to performance drop.
 *
 *    Rev 1.10   Jan 14 1997 15:14:02   unknown
 * Change to version V4.0.4
 *
 *    Rev 1.8   Jan 08 1997 11:22:34   unknown
 * Change to V4.0.3
 *
 *    Rev 1.7   18 Dec 1996 13:44:08   PLCHU
 *
 *
 *    Rev 1.6   Dec 13 1996 12:15:48   unknown
 * update bandwith equation for DDraw.
 *
 *    Rev 1.6   Nov 27 1996 15:07:28   unknown
 * turn on second apertue for 5480
 *
 *    Rev 1.5   Nov 07 1996 16:48:00   unknown
 *
 *
 *    Rev 1.4   Nov 06 1996 15:55:10   unknown
 * Turn off second aperture
 *
 *    Rev 1.3   Nov 05 1996 14:49:00   unknown
 * Turn on second aperture feature for 5480
 *
 *    Rev 1.1   Oct 10 1996 15:36:38   unknown
 *
*
*    Rev 1.9   12 Aug 1996 16:52:42   frido
* Removed unaccessed local variables.
* Added NT 3.5x/4.0 auto detection.
* Renamned vMmPatternBlt into vMmFillPat36.
*
*    Rev 1.8   08 Aug 1996 16:20:54   frido
* Added vMmCopyBlt36 routine.
*
*    Rev 1.7   01 Aug 1996 00:09:28   frido
* Fixed a type causing havoc in new pitch in 24-bpp.
*
*    Rev 1.6   26 Jul 1996 17:46:30   frido
* Added new solid fill routine for 54x6 chips.
*
*    Rev 1.5   26 Jul 1996 14:16:40   frido
* Added new pattern blit routine.
*
*    Rev 1.4   20 Jul 1996 13:48:12   frido
* Hooked DrvDestroyFont.
*
*    Rev 1.3   10 Jul 1996 17:54:50   frido
* Cosmetic change in the flHooks variable.
*
*    Rev 1.2   09 Jul 1996 17:58:24   frido
* Added LineTo code.
*
*    Rev 1.1   03 Jul 1996 13:38:30   frido
* Added DirectDraw support.
*
* sge01   10-23-96   Add second aperture maping
* sge02   10-29-96   Merge port and register access
*                    for VGA relocatable and MMIO registers.
* myf0    08-19-96   added 85hz supported
* myf1    08-20-96   supported panning scrolling
* myf2    08-20-96   fixed hardware save/restore state bug for matterhorn
* myf3    09-01-96   Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4    09-01-96   patch Viking BIOS bug, PDR #4287, begin
* myf5    09-01-96   Fixed PDR #4365 keep all default refresh rate
* myf6    09-17-96   Merged Desktop SRC1001 & MINI102
* myf7    09-19-96   Fixed exclude 60Hz refresh rate selected
* myf8   *09-21-96*  May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9    09-21-96   8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809  09-25-96   fixed dstn panel icon corrupted
* ms923   09-25-96   merge MS-923 Disp.zip code
* myf10   09-26-96   Fixed DSTN reserved half-frame buffer bug.
* myf11   09-26-96   Fixed 755x CE chip HW bug, access ramdac before disable HW
*                    icons and cursor
* myf12   10-01-96   Supported Hot Key switch display
* myf13   10-05-96   Fixed /w panning scrolling, vertical expension on bug
* myf14   10-15-96   Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15   10-16-96   Fixed disable memory mapped IO for 754x, 755x
* myf16   10-22-96   Fixed PDR #6933,panel type set different demo board setting
* sge01   10-28-96   Map the ports before we use it and free it in bInitializeModeFields
* myf17   11-04-96   Added special escape code must be use 11/5/96 later NTCTRL,
*                    and added Matterhorn LF Device ID==0x4C
* myf18   11-04-96   Fixed PDR #7075,
* myf19   11-06-96   Fixed Vinking can't work problem, because DEVICEID = 0x30
*                    is different from data book (CR27=0x2C)
* myf20   11-11-96   Fixed PDR#5501 pop-up icon crash problem
* myf21   11-21-96   Change CAPS_IS_7555 to check ppdev->ulChipID
* chu01   12-16-96   Enable color correction
* chu02   02-07-97   Disable command list for 24 bpp modes
* jl01    02-11-97   Fix 542x VLB banking issue
* myf29   02-12-97   Support Gamma Correction for 755x
* pat04 :12-05-96 : Set default Panel bootup mode = 640x480x256colors if
*                   current resolution not supported.
* pat08 :         : Put in changes that didn't make in 1.11 driver
* myf33 : 03-21-97  Fixed 6x4x256 TV on, font cut bug,
*
\******************************************************************************/

#include "precomp.h"

#define DBG_LVL_CAPS    0
#define CIRRUSVERSION   21
//crus
//myf17   #define PANNING_SCROLL       //myf1

BOOL bGetChipIDandRev(BOOL bRetInfo, PPDEV ppdev);

//crus begin
#ifdef PANNING_SCROLL    //myf1
VOID
CirrusLaptopViewPoint(
PDEV* ppdev,
PVIDEO_MODE_INFORMATION  pVideoModeInfo);
#endif
//crus end

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
//  GDI_DRIVER_VERSION,         // ulVersion
    GDI_DRIVER_VERSION+CIRRUSVERSION,        // ulVersion, sge01
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE /* | TC_SCROLLBLT */,
                // flTextCaps --
                //   Setting TC_SCROLLBLT tells console to scroll
                //   by repainting the entire window.  Otherwise,
                //   scrolls are done by calling the driver to
                //   do screen to screen copies.

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh (filled in later)
#if (NT_VERSION < 0x0400)
    0,                       // ulDesktopHorzRes (filled in later)
    0,                       // ulDesktopVertRes (filled in later)
    0,                       // ulBltAlignment
#else
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes (filled in later)
    0,                       // ulPanningVertRes (filled in later)
#endif
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
               CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
               VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
               CLIP_STROKE_PRECIS,PROOF_QUALITY,\
               VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
               CLIP_STROKE_PRECIS,PROOF_QUALITY,\
               FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {

    (GCAPS_OPAQUERECT
     | GCAPS_DITHERONREALIZE
     | GCAPS_PALMANAGED
     | GCAPS_ALTERNATEFILL
     | GCAPS_WINDINGFILL
     | GCAPS_MONO_DITHER
     | GCAPS_COLOR_DITHER
#if DIRECTDRAW
     | GCAPS_DIRECTDRAW
#endif
//crus
#if (NT_VERSION >= 0x0400)
#ifdef PANNING_SCROLL           //myf1
     | GCAPS_PANNING
#endif
#endif
     // This driver can't handle GCAPS_ASYNCMOVE because some of the pointer
     // moves, where the pointer image must be rotated at the left edge,
     // require the blt hardware to download a new pointer shape.
     ),
     // NOTE: Only enable GCAPS_ASYNCMOVE if your code
     //   and hardware can handle DrvMovePointer
     //   calls at any time, even while another
     //   thread is in the middle of a drawing
     //   call such as DrvBitBlt.

                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

#if DBG

// On Checked builds, or when we have to synchronize access, thunk
// everything through Dbg calls...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
#if 1 // Font cache.
    {   INDEX_DrvDestroyFont,           (PFN) DbgDestroyFont        },
#endif
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },
    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           },
#if DIRECTDRAW
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DbgGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DbgEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DbgDisableDirectDraw  },
#endif
#if LINETO
    {   INDEX_DrvLineTo,                (PFN) DbgLineTo             },
#endif
#if !DRIVER_PUNT_ALL
    #if !DRIVER_PUNT_STRETCH
    {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt         },
    #endif
    #if !DRIVER_PUNT_PTR
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },
    #endif
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },
    #if !DRIVER_PUNT_BRUSH
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },
    #endif
#endif
};

#else

// On Free builds, directly call the appropriate functions...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
#if 1 // Font cache.
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },
#endif
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
#if DIRECTDRAW
    {   INDEX_DrvGetDirectDrawInfo,             (PFN) DrvGetDirectDrawInfo      },
    {   INDEX_DrvEnableDirectDraw,              (PFN) DrvEnableDirectDraw       },
    {   INDEX_DrvDisableDirectDraw,             (PFN) DrvDisableDirectDraw      },
#endif
#if LINETO
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },
#endif
#if !DRIVER_PUNT_ALL
    #if !DRIVER_PUNT_STRETCH
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    #endif
    #if !DRIVER_PUNT_PTR
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    #endif
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
    #if !DRIVER_PUNT_BRUSH
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    #endif
#endif
};

#endif

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

//
// Merge port and register access for
// VGA relocatable and MMIO registers.
//
// sge02 begin
#if defined(_X86_)

UCHAR   CirrusREAD_PORT_UCHAR(PVOID Port);
USHORT  CirrusREAD_PORT_USHORT(PVOID Port);
ULONG   CirrusREAD_PORT_ULONG(PVOID Port);
VOID    CirrusWRITE_PORT_UCHAR(PVOID Port,UCHAR Value);
VOID    CirrusWRITE_PORT_USHORT(PVOID  Port, USHORT Value);
VOID    CirrusWRITE_PORT_ULONG(PVOID Port, ULONG Value);

UCHAR   CirrusREAD_REGISTER_UCHAR(PVOID Register);
USHORT  CirrusREAD_REGISTER_USHORT(PVOID Register);
ULONG   CirrusREAD_REGISTER_ULONG(PVOID Register);
VOID    CirrusWRITE_REGISTER_UCHAR(PVOID Register,UCHAR Value);
VOID    CirrusWRITE_REGISTER_USHORT(PVOID  Register, USHORT Value);
VOID    CirrusWRITE_REGISTER_ULONG(PVOID Register, ULONG Value);

UCHAR   CirrusREAD_PORT_UCHAR(PVOID Port)
{
    return((UCHAR)inp(Port));
}
USHORT  CirrusREAD_PORT_USHORT(PVOID Port)
{
    return(inpw(Port));
}
ULONG   CirrusREAD_PORT_ULONG(PVOID Port)
{
    return(inpd(Port));
}
VOID    CirrusWRITE_PORT_UCHAR(PVOID Port,UCHAR Value)
{
    outp(Port, Value);
}
VOID    CirrusWRITE_PORT_USHORT(PVOID  Port, USHORT Value)
{
    outpw(Port, Value);
}
VOID    CirrusWRITE_PORT_ULONG(PVOID Port, ULONG Value)
{
    outpd(Port, Value);
}

UCHAR   CirrusREAD_REGISTER_UCHAR(PVOID Register)
{
    return(*(volatile UCHAR *)(Register));
}
USHORT  CirrusREAD_REGISTER_USHORT(PVOID Register)
{
    return(*(volatile USHORT *)(Register));
}
ULONG   CirrusREAD_REGISTER_ULONG(PVOID Register)
{
    return(*(volatile ULONG *)(Register));
}
VOID    CirrusWRITE_REGISTER_UCHAR(PVOID Register,UCHAR Value)
{
    *(volatile UCHAR *)(Register) = (Value);
}
VOID    CirrusWRITE_REGISTER_USHORT(PVOID  Register, USHORT Value)
{
    *(volatile USHORT *)(Register) = (Value);
}
VOID    CirrusWRITE_REGISTER_ULONG(PVOID Register, ULONG Value)
{
    *(volatile ULONG *)(Register) = (Value);
}
#endif
//sge02 end

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    DISPDBG((2, "---- DrvEnableDriver"));

    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
#if (NT_VERSION < 0x0400)
PWSTR       pwszDataFile,   // DataFile - not used
#else
HDEV        hdev,           // HDEV, used for callbacks
#endif
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    DISPDBG((2, "---- DrvEnablePDEV"));

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) ALLOC(sizeof(PDEV));
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information. Set up device caps and devinfo.

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));
    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    FREE(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}


/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    SIZEL   sizl;
    DSURF*  pdsurf;
    VOID*   pvTmpBuffer;
    SURFOBJ*    pso;
    ppdev = (PDEV*) dhpdev;

    DISPDBG((2, "---- DrvEnableSurface"));

    /////////////////////////////////////////////////////////////////////
    // First, enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableBanking(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    if (!bEnableBrushCache(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

#if DIRECTDRAW
    if (!bEnableDirectDraw(ppdev))
        goto ReturnFailure;
#endif

    /////////////////////////////////////////////////////////////////////
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = ALLOC(sizeof(DSURF));
    if (pdsurf == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;        // Remember it for clean-up

    pdsurf->poh     = ppdev->pohScreen;  // The screen is a surface, too
    pdsurf->dt      = DT_SCREEN;         // Not to be confused with a DIB
    pdsurf->sizl.cx = ppdev->cxScreen;
    pdsurf->sizl.cy = ppdev->cyScreen;
    pdsurf->ppdev   = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.
    //
    // If we could map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it would be
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.  When we pass a call on to GDI
    // where it can't directly read/write to the surface bits because the
    // surface is device managed, it has to create a temporary bitmap and
    // call our DrvCopyBits routine to get/set a copy of the affected bits.
    // For example, the OpenGL component prefers to be able to write on the
    // framebuffer bits directly.
    //
    // The check for CAPS_AUTOSTART rules out chipsets (like the 7543) that
    // can't be written to directly.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if ((ppdev->bLinearMode && DIRECT_ACCESS(ppdev)) && (ppdev->flCaps & CAPS_ENGINEMANAGED))
    {

        // Engine-managed surface:

        hsurf = (HSURF) EngCreateBitmap(sizl,
                        ppdev->lDelta,
                        ppdev->iBitmapFormat,
                        BMF_TOPDOWN,
                        ppdev->pjScreen);
        if (hsurf == 0)
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngCreateBitmap"));
            goto ReturnFailure;
        }

        pso = EngLockSurface(hsurf);
        if (pso == NULL)
        {
            DISPDBG((0, "DrvEnableSurface - Couldn't lock our surface"));
            goto ReturnFailure;
        }
        pso->dhsurf = (DHSURF) pdsurf;
        EngUnlockSurface(pso);
    }
    else
    {
        // Device managed surface
        hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, sizl, ppdev->iBitmapFormat);
        if (hsurf == 0)
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
            goto ReturnFailure;
        }
    }

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface 2"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    // Create our generic temporary buffer, which may be used by any
    // component.

    pvTmpBuffer = ALLOC(TMP_BUFFER_SIZE);
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    DISPDBG((5, "Passed DrvEnableSurface"));

    ppdev->hbmTmpMono = EngCreateBitmap(sizl, sizl.cx, BMF_1BPP, 0, ppdev->pvTmpBuffer);
    if (ppdev->hbmTmpMono == (HBITMAP) 0)
    {
        DISPDBG((0, "Couldn't create temporary 1bpp bitmap"));
        goto ReturnFailure;
    }

    ppdev->psoTmpMono = EngLockSurface((HSURF) ppdev->hbmTmpMono);
    if (ppdev->psoTmpMono == (SURFOBJ*) NULL)
    {
        DISPDBG((0,"Couldn't lock temporary 1bpp surface"));
        goto ReturnFailure;
    }

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

VOID
DrvSynchronize(
    IN DHPDEV dhpdev,
    IN RECTL *prcl
    )
{
    PDEV *ppdev = (PDEV *) dhpdev;

    //
    // We need to do a wait for blt complete before we
    // let the engine party on our frame buffer
    //

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjBase);
    }
    else
    {
        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjPorts);
    }
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note that this function will be called when previewing modes in th* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

#if DIRECTDRAW
    vDisableDirectDraw(ppdev);
#endif
    vDisablePalette(ppdev);
    vDisableBrushCache(ppdev);
    vDisableText(ppdev);

    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);

    vDisableBanking(ppdev);
    vDisableHardware(ppdev);

    EngUnlockSurface(ppdev->psoTmpMono);
    EngDeleteSurface((HSURF) ppdev->hbmTmpMono);
    FREE(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
    FREE(ppdev->pdsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

#if (NT_VERSION < 0x0400)
VOID
#else
BOOL
#endif
DrvAssertMode(DHPDEV dhpdev, BOOL bEnable)
{
    PDEV* ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

#if DIRECTDRAW
       vAssertModeDirectDraw(ppdev, FALSE);
#endif

        vAssertModePalette(ppdev, FALSE);

        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModeText(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            vAssertModeBanking(ppdev, FALSE);

            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

#if (NT_VERSION >= 0x0400)
                return (TRUE);
#else
                return;
#endif
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);

    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {

            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                    //   return code with TRUE

            vAssertModePointer(ppdev, TRUE);

            vAssertModeText(ppdev, TRUE);

            vAssertModeBrushCache(ppdev, TRUE);

            vAssertModePalette(ppdev, TRUE);

#if DIRECTDRAW
            vAssertModeDirectDraw(ppdev, TRUE);
#endif

//
// chu01 begin
//
#ifdef GAMMACORRECT
{
            BYTE          ajClutSpace[MAX_CLUT_SIZE];
            PVIDEO_CLUT   pScreenClut;
            PALETTEENTRY* ppalFrom;
            PALETTEENTRY* ppalTo;
            PALETTEENTRY* ppalEnd;
            BOOL          status;
            ULONG         ulReturn;

            if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
            {
                pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
                pScreenClut->NumEntries = 256;
                pScreenClut->FirstEntry = 0;

                ppalFrom = ppdev->pPal;
                ppalTo   = (PALETTEENTRY*) pScreenClut->LookupTable;
                ppalEnd  = &ppalTo[256];

                for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
                {
                   ppalTo->peRed   = ppalFrom->peRed   ;
                   ppalTo->peGreen = ppalFrom->peGreen ;
                   ppalTo->peBlue  = ppalFrom->peBlue  ;
                   ppalTo->peFlags = 0 ;
                }

//myf29 begin
                if (ppdev->ulChipID == 0xBC)
                    status = bEnableGammaCorrect(ppdev) ;
                else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID ==0x4C))
                    status = bEnableGamma755x(ppdev) ;
//myf29 end

                CalculateGamma( ppdev, pScreenClut, 256 ) ;

                // Set palette registers:

                if (!IOCONTROL(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &ulReturn))
                {
                    DISPDBG((0, "Failed bEnablePalette"));
                }

            }
}
#endif // GAMMACORRECT
//chu01

            ppdev->bEnabled = TRUE;

#if (NT_VERSION >= 0x0400)
            return(TRUE);
#endif
        }
    }

#if (NT_VERSION >= 0x0400)
    return(FALSE);
#endif
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                              pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

#if (NT_VERSION < 0x0400)
                if (pVideoTemp->AttributeFlags & VIDEO_MODE_INTERLACED)
                {
                    pdm->dmDisplayFlags |= DM_INTERLACED;
                }
#endif

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                           DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                            (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    FREE(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    LONG                    cjEndOfFrameBuffer;
    LONG                    cjPointerOffset;
    LONG                    lDelta;
    ULONG                   ulMode;
    ULONG                   pFirstCL, pSecondCL;

    if (bEnable)
    {
        // Call the miniport via an IOCTL to set the graphics mode.

        ulMode = ppdev->ulMode;

    if (ppdev->bLinearMode)
    {
        ulMode |= VIDEO_MODE_MAP_MEM_LINEAR;
    }

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_SET_CURRENT_MODE,
                   &ulMode,  // input buffer
                   sizeof(DWORD),
                   NULL,
                   0,
                   &ReturnedDataLength))
    {
        DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
        goto ReturnFalse;
    }

    //
    // This driver requires that extended write modes be enabled.
    // Normally, we would put code like this into the miniport, but
    // unfortunately the VGA drivers do not expect extended write
    // modes to be enabled, and thus we have to put the code here.
    //

    #define ENABLE_EXTENDED_WRITE_MODES 0x4

    {
        BYTE    j;

        CP_OUT_BYTE(ppdev->pjPorts, INDEX_REG, 0x0B);
        j = CP_IN_BYTE(ppdev->pjPorts, DATA_REG);
        DISPDBG((3, "Mode extensions register was (%x)", j));
        j &= 0x20;
        j |= ENABLE_EXTENDED_WRITE_MODES;
        CP_OUT_BYTE(ppdev->pjPorts, DATA_REG, j);
        DISPDBG((3, "Mode extensions register now (%x)", j));
    }

    CP_IO_XPAR_COLOR_MASK(ppdev, ppdev->pjPorts, 0);

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_QUERY_CURRENT_MODE,
                   NULL,
                   0,
                   &VideoModeInfo,
                   sizeof(VideoModeInfo),
                   &ReturnedDataLength))
    {
        DISPDBG((0, "bAssertModeHardware - failed VIDEO_QUERY_CURRENT_MODE"));
        goto ReturnFalse;
    }

//crus
//myf1, begin
#ifdef PANNING_SCROLL
    if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) ||   //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C)) //myf17
    {
         CirrusLaptopViewPoint(ppdev,  &VideoModeInfo);
    }
#endif
//myf1, end


    #if DEBUG_HEAP
        VideoModeInfo.VideoMemoryBitmapWidth  = VideoModeInfo.VisScreenWidth;
        VideoModeInfo.VideoMemoryBitmapHeight = VideoModeInfo.VisScreenHeight;
    #endif

    // The following variables are determined only after the initial
    // modeset:

    ppdev->lDelta   = VideoModeInfo.ScreenStride;
    ppdev->flCaps   = VideoModeInfo.DriverSpecificAttributeFlags;

    DISPDBG((1,"ppdev->flCaps = %x",ppdev->flCaps));    //2

#if 1 // Check for 5446 chip.
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27);
    ppdev->ulChipID    = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC;
    //
    // add chip flags for 5446BE and 5480
    //
    //sge01 begin
    if ((ppdev->ulChipID == 0xB8) || (ppdev->ulChipID == 0xBC))
    {
        ppdev->flCaps |= CAPS_VIDEO;
        if (ppdev->ulChipID == 0xBC)
        {
            ppdev->flCaps |= CAPS_SECOND_APERTURE;
        }
        else
        {
            // get revision ID
            CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x25);
            ppdev->ulChipNum = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
            if (ppdev->ulChipNum==0x45)
               ppdev->flCaps |= CAPS_SECOND_APERTURE;
        }
    }
//myf30 begin
    else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))
    {
#if (_WIN32_WINNT >= 0x0400)
        ppdev->flCaps |= CAPS_VIDEO;
#endif
    }
//myf30 end
#endif
//sge01 end


    // Set up the shift factor for the banking code.

    if (ppdev->flCaps & CAPS_IS_542x)
    {
        ppdev->ulBankShiftFactor = 12;
    }
    else
    {
        ppdev->ulBankShiftFactor = 10;
    }

    ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;
    ppdev->cyMemory = VideoModeInfo.VideoMemoryBitmapHeight;

//pat04, begin
//#if 0
#if (_WIN32_WINNT < 0x0400)
    ppdev->cxScreen = VideoModeInfo.VisScreenWidth;
    ppdev->cyScreen = VideoModeInfo.VisScreenHeight;
#endif
//#endif
//pat04, end

//crus begin
//ms0809, begin
    /********************************************************************
    *
    * If we are on a DSTN panel, then the hardware needs 128K for the
    * half frame accelerator.
    *
    ********************************************************************/

    if ((ppdev->flCaps & CAPS_DSTN_PANEL) &&
        ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) ||   //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C)) ) //myf17
    {
        // figure out how much cyMemory needs to be decremented by
        // to reserve 128K.
        // =====================================================
        // if Matterhorn 2M/4M board needs to be decremented by
        // to reserve 152K+16k(h/w icon)=168K.
        // =====================================================


        // I need to make sure that if there is a remainder that I
        // remove an additional scan.  What is the best way to do
        // this?  Is this the memory the DSTN is using?  Will it ever
        // use more?

        if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
            (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34))     //myf19
            ppdev->cyMemory -= (0x24000 / ppdev->cxMemory); //myf

        else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))//myf17
            ppdev->cyMemory -= (0x2A000 / ppdev->cxMemory); //myf

    }
//  else if (!(ppdev->flCaps & CAPS_DSTN_PANEL) &&
    else if (((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) || //myf20
         (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) ||  //myf19
         (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))) //myf17
    {
        // figure out how much cyMemory needs to be decremented by
        // to reserve 16K for H/W icon & cursor
        // =====================================================

           ppdev->cyMemory -= (0x4000 / ppdev->cxMemory); //myf
    }
//ms0809, end
//crus end

//sge01 begin
    if (!(ppdev->flCaps & CAPS_BLT_SUPPORT))
    {
        DISPDBG((1, "Cirrus chip doesn't support BLT's"));
        goto ReturnFalse;
    }
//sge01 end

    //
    // Check to see if we have a non-zero value for pjBase.  If so, we
    // can support memory mapped IO.
    //

    if (ppdev->pjBase)
    {
        CP_ENABLE_MM_IO(ppdev, ppdev->pjPorts);
        CP_MM_START_REG(ppdev, ppdev->pjBase, BLT_RESET);

        if (ppdev->flCaps & CAPS_AUTOSTART)
        {
            //
            // enable second aperture for 5480 and 5446BE
            //
            // sge01 begin
            if (ppdev->flCaps & CAPS_SECOND_APERTURE)
            {
                CP_MM_START_REG(ppdev, ppdev->pjBase, BLT_AUTO_START | BLT_SECOND_APERTURE);
            }
            else
            //sge01 end
            {
                CP_MM_START_REG(ppdev, ppdev->pjBase, BLT_AUTO_START);
            }

        }
    }
    else
    {
        CP_DISABLE_MM_IO(ppdev, ppdev->pjPorts);
        CP_IO_START_REG(ppdev, ppdev->pjPorts, BLT_RESET);

        if (ppdev->flCaps & CAPS_AUTOSTART)
        {
            //
            // enable second aperture for 5480 and 5446BE
            //
            // sge01 begin
            if (ppdev->flCaps & CAPS_SECOND_APERTURE)
            {
                CP_IO_START_REG(ppdev, ppdev->pjBase, BLT_AUTO_START | BLT_SECOND_APERTURE);
            }
            else
            //sge 01 end
            {
                CP_IO_START_REG(ppdev, ppdev->pjBase, BLT_AUTO_START);
            }

        }
    }

    /********************************************************************
    *
    * If we're using the hardware pointer, reserve the last scan of
    * the frame buffer to store the pointer shape.  The pointer MUST be
    * stored in the last 256 bytes of video memory.
    *
    ********************************************************************/

// #pat08 start
//#if 0
#if (_WIN32_WINNT < 0x0400)

 #ifdef PANNING_SCROLL
        // allocate without test
//   if ((ppdev->ulChipID != CL7541_ID) && (ppdev->ulChipID != CL7543_ID) &&
//        (ppdev->ulChipID != CL7542_ID) && (ppdev->ulChipID != CL7548_ID) &&
//        (ppdev->ulChipID != CL7555_ID) && (ppdev->ulChipID != CL7556_ID))
//          if (!(ppdev->flCaps & (CAPS_SW_POINTER)))
//   else
//        ;
 #else
     if (!(ppdev->flCaps & (CAPS_SW_POINTER)))
 #endif

#else // NT 4.0 code
    if (!(ppdev->flCaps & (CAPS_SW_POINTER)))
#endif
//#endif          //0,pat08
// #pat08  end

//pat08    if (!(ppdev->flCaps & (CAPS_SW_POINTER)))
    {
        // We'll reserve the end of off-screen memory for the hardware
        // pointer shape.

        cjPointerOffset = (ppdev->ulMemSize - SPRITE_BUFFER_SIZE);

        // Figure out the coordinate where the pointer shape starts:

        lDelta = ppdev->lDelta;

        ppdev->cjPointerOffset = cjPointerOffset;
        ppdev->yPointerShape   = (cjPointerOffset / lDelta);
        ppdev->xPointerShape   = (cjPointerOffset % lDelta) / ppdev->cBpp;

        if (ppdev->yPointerShape >= ppdev->cyScreen)
        {
            // There's enough room for the pointer shape at the
            // bottom of off-screen memory; reserve its room by
            // lying about how much off-screen memory there is:

            ppdev->cyMemory = min(ppdev->yPointerShape, ppdev->cyMemory);
        }
        else
        {
            // There's not enough room for the pointer shape in
            // off-screen memory; we'll have to simulate:

            DISPDBG((2,"Not enough room for HW pointer...\n"
                           "\tppdev->yPointerShape(%d)\n"
                           "\tppdev->cyScreen(%d)\n"
                           "\tcjPointerOffset(%d)",
                           ppdev->yPointerShape, ppdev->cyScreen,cjPointerOffset));

            ppdev->flCaps |= CAPS_SW_POINTER;
        }
    }

    // !!! No room for a transfer buffer, as in the 1280x1024 case on
    //     a 2 MB card.  This case should go away when the miniport
    //     is fixed to return non-power-of-2 screen strides.

    if ((ppdev->cyMemory == ppdev->cyScreen) ||
        (ppdev->flCaps & CAPS_NO_HOST_XFER))
    {
        //
        // disable host xfer buffer
        //
        ppdev->lXferBank = 0;
        ppdev->pulXfer = NULL;
        DISPDBG((2,"Host transfers disabled"));
    }
    else
    {
        //
        // for chips do not have second aperture
        //
        // sge01 begin
        if (!(ppdev->flCaps & CAPS_SECOND_APERTURE))
        {
            if (ppdev->flCaps & CAPS_AUTOSTART)
            {
                (BYTE*)ppdev->pulXfer = ppdev->pjScreen;
            }
            else
            {
                //
                // enable host xfer buffer
                //
                ASSERTDD(ppdev->cyMemory > ppdev->cyScreen, "No scans left for blt xfer buffer");
                ppdev->cyMemory--;
                cjEndOfFrameBuffer = ppdev->cyMemory * ppdev->lDelta;
                ppdev->lXferBank = cjEndOfFrameBuffer / ppdev->cjBank;
                (BYTE*)ppdev->pulXfer = ppdev->pjScreen + (cjEndOfFrameBuffer % ppdev->cjBank);

                DISPDBG((2, "ppdev->cyMemory = %x", ppdev->cyMemory)) ;
                DISPDBG((2, "ppdev->lDelta = %x", ppdev->lDelta))     ;
                DISPDBG((2, "cjBank: %lx", ppdev->cjBank))            ;
                DISPDBG((2, "pulXfer = %x", ppdev->pulXfer))          ;
                DISPDBG((2, "Host transfers enabled"))                ;
            }
        }
#if 0   // D5480
        //
        // allocate command list buffer
        //
        if ((ppdev->flCaps & CAPS_COMMAND_LIST) && FALSE)
        {
            ppdev->cyMemory -= (COMMAND_BUFFER_SIZE + COMMAND_BUFFER_ALIGN + ppdev->lDelta / 2 ) / ppdev->lDelta;
            cjEndOfFrameBuffer = ppdev->cyMemory * ppdev->lDelta;
            pFirstCL = (ULONG)(((ULONG_PTR)ppdev->pjScreen + cjEndOfFrameBuffer + COMMAND_BUFFER_ALIGN) & ~COMMAND_BUFFER_ALIGN);
            pSecondCL = pFirstCL + (COMMAND_BUFFER_SIZE >> 1);

            ppdev->pCLFirst = (ULONG_PTR*) pFirstCL;
            ppdev->pCLSecond = (ULONG_PTR*) pSecondCL;
            ppdev->pCommandList = ppdev->pCLFirst;
        }
#endif  // endif D5480

        //
        // Make sure we don't try to use command lists.
        //

        ppdev->pCommandList = NULL;
    }

        DISPDBG((2, "ppdev->cxMemory = %x", ppdev->cxMemory)) ;
        DISPDBG((2, "ppdev->cyMemory = %x", ppdev->cyMemory)) ;
        DISPDBG((2, "ppdev->cxScreen = %x", ppdev->cxScreen)) ;
        DISPDBG((2, "ppdev->cyScreen = %x", ppdev->cyScreen)) ;
        DISPDBG((2, "ppdev->lDelta = %x", ppdev->lDelta))     ;
        DISPDBG((2, "cjBank: %lx", ppdev->cjBank))            ;
        DISPDBG((2,"pulXfer = %x", ppdev->pulXfer))           ;

        // Do some paramater checking on the values that the miniport
        // returned to us:

        ASSERTDD(ppdev->cxMemory >= ppdev->cxScreen, "Invalid cxMemory");
        ASSERTDD(ppdev->cyMemory >= ppdev->cyScreen, "Invalid cyMemory");
    }
    else
    {
        CP_DISABLE_MM_IO(ppdev, ppdev->pjPorts);

        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_RESET_DEVICE,
                       NULL,
                       0,
                       NULL,
                       0,
                       &ulReturn))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            return FALSE;
        }
    }

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_PUBLIC_ACCESS_RANGES VideoAccessRange[2];
    VIDEO_MEMORY               VideoMemory;
//sge01  VIDEO_MEMORY_INFORMATION   VideoMemoryInfo;
    VIDEO_MEMORY_INFORMATION   VideoMemoryInfo[2];      // sge01
    DWORD                      ReturnedDataLength;
    BYTE*                      pjPorts = ppdev->pjPorts;
    ULONG                      ulMode;
    BOOL                                   bRet;

    //
    // Check the last field in the PDEV to make sure that the compiler
    // didn't generate unaligned fields following BYTE fields.
    //

    ASSERTDD(!(((ULONG_PTR)(&ppdev->ulLastField)) & 3),
                 "PDEV alignment screwed up... BYTE fields mishandled?");

    // Map the ports.

    bRet = IOCONTROL(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,                      // input buffer
                         0,
                         (PVOID) &VideoAccessRange, // output buffer
                         sizeof (VideoAccessRange),
                         &ReturnedDataLength);
    if (bRet == FALSE)
    {
        DISPDBG((0, "bEnableHardware - Error mapping ports"));
        goto ReturnFalse;
    }

    // Set a convienent pointer to the registers in the pdev.

    ppdev->pjPorts = VideoAccessRange[0].VirtualAddress;
    ppdev->pjBase  = VideoAccessRange[1].VirtualAddress;

    //
    // Merge port and register access for
    // VGA relocatable and MMIO registers.
    //
    // sge02 begin
#if defined(_X86_)
    if (VideoAccessRange[0].InIoSpace)
    {
        ppdev->pfnREAD_PORT_UCHAR    = CirrusREAD_PORT_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = CirrusREAD_PORT_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = CirrusREAD_PORT_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = CirrusWRITE_PORT_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = CirrusWRITE_PORT_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = CirrusWRITE_PORT_ULONG;
    }
    else
    {
        ppdev->pfnREAD_PORT_UCHAR    = CirrusREAD_REGISTER_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = CirrusREAD_REGISTER_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = CirrusREAD_REGISTER_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = CirrusWRITE_REGISTER_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = CirrusWRITE_REGISTER_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = CirrusWRITE_REGISTER_ULONG;
    }
#elif defined(_ALPHA_)
    if (VideoAccessRange[0].InIoSpace)
    {
        ppdev->pfnREAD_PORT_UCHAR    = READ_PORT_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = READ_PORT_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = READ_PORT_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = WRITE_PORT_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = WRITE_PORT_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = WRITE_PORT_ULONG;
    }
    else
    {
        ppdev->pfnREAD_PORT_UCHAR    = READ_REGISTER_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = READ_REGISTER_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = READ_REGISTER_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = (FnWRITE_PORT_UCHAR)WRITE_REGISTER_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = (FnWRITE_PORT_USHORT)WRITE_REGISTER_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = (FnWRITE_PORT_ULONG)WRITE_REGISTER_ULONG;
    }
#endif
//sge02 end

    //
    // Try to get the miniport to give us a mode with a linear frame buffer.
    //

    ulMode = ppdev->ulMode | VIDEO_MODE_MAP_MEM_LINEAR;

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_SET_CURRENT_MODE,
                   &ulMode,  // input buffer
                   sizeof(DWORD),
                   NULL,
                   0,
                   &ReturnedDataLength))
    {
        //
        // We could not set this mode with a linear frame buffer, so lets try
        // again banked.
        //

        ulMode &= ~VIDEO_MODE_MAP_MEM_LINEAR;

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_SET_CURRENT_MODE,
                       &ulMode,  // input buffer
                       sizeof(DWORD),
                       NULL,
                       0,
                       &ReturnedDataLength))
        {
            DISPDBG((0, "bEnableHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }
    }

    ppdev->bLinearMode = (ulMode & VIDEO_MODE_MAP_MEM_LINEAR) ? TRUE : FALSE;

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                   &VideoMemory,      // input buffer
                   sizeof(VIDEO_MEMORY),
                   &VideoMemoryInfo,  // output buffer
                   sizeof(VideoMemoryInfo),
                   &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping video buffer"));
        goto ReturnFalse;
    }

//myfr, 2
    DISPDBG((2, "FrameBufferBase(ie. pjScreen) %lx",
                VideoMemoryInfo[0].FrameBufferBase));
    DISPDBG((2, "FrameBufferLength %d",
                VideoMemoryInfo[0].FrameBufferLength));
    DISPDBG((2, "VideoRamLength(ie. ulMemSize) %d",
                VideoMemoryInfo[0].VideoRamLength));

    // Record the Frame Buffer Linear Address.

//sge01
    ppdev->pjScreen  = (BYTE*) VideoMemoryInfo[0].FrameBufferBase;
    ppdev->cjBank    = VideoMemoryInfo[0].FrameBufferLength;
    ppdev->ulMemSize = VideoMemoryInfo[0].VideoRamLength;

    // Now we can set the mode and unlock the accelerator.

    if (!bAssertModeHardware(ppdev, TRUE))
    {
        goto ReturnFalse;
    }

    //sge01 begin
    if ((ppdev->flCaps & CAPS_SECOND_APERTURE) &&
        !(ppdev->flCaps & CAPS_NO_HOST_XFER))
    {
        ppdev->pulXfer = VideoMemoryInfo[1].VideoRamBase;
    }
    //sge01 end

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        DISPDBG((1,"Memory mapped IO enabled"));
#if 1 // D5480
        if ((ppdev->flCaps & CAPS_COMMAND_LIST) &&
            (ppdev->pCommandList != NULL))
        {
             //
             // Bitmap functions
             //
             ppdev->pfnXfer1bpp      = vMmXfer1bpp80;
             ppdev->pfnXfer4bpp      = vMmXfer4bpp;
             ppdev->pfnXferNative    = vMmXferNative80;

             //
             // Pattern functions
             //
             //
             // chu02 : This is due to hardware error for 24bpp,
             //         GR2f[4..0] != 0, non-color expandsion and 8x8 pattern
             //         copy.
             //
             ppdev->pfnFillPat       = (ppdev->cBpp == 3) ?
                                           vMmFillPat36 : vMmFillPat80;
             ppdev->pfnFillSolid     = vMmFillSolid80;
             ppdev->pfnCopyBlt       = vMmCopyBlt80;

             //
             // Text functions
             //
             ppdev->pfnGlyphOut      = vMmGlyphOut80;
             ppdev->pfnGlyphOutClip  = vMmGlyphOutClip80;
        }
        else if(ppdev->flCaps & CAPS_AUTOSTART)
        {
            // bitmap functions
            ppdev->pfnXfer1bpp      = vMmXfer1bpp;
            ppdev->pfnXfer4bpp      = vMmXfer4bpp;
            ppdev->pfnXferNative    = vMmXferNative;
            // Pattern functions
            ppdev->pfnFillPat       = vMmFillPat36;
            ppdev->pfnFillSolid     = vMmFillSolid36;
            ppdev->pfnCopyBlt       = vMmCopyBlt36;
            // Text functions
            ppdev->pfnGlyphOut      = vMmGlyphOut;
            ppdev->pfnGlyphOutClip  = vMmGlyphOutClip;
        }
        else
        {
            // bitmap functions
            ppdev->pfnXfer1bpp      = vMmXfer1bpp;
            ppdev->pfnXfer4bpp      = vMmXfer4bpp;
            ppdev->pfnXferNative    = vMmXferNative;
            // Pattern functions
            ppdev->pfnFillPat       = vMmFillPat;
            ppdev->pfnFillSolid     = vMmFillSolid;
            ppdev->pfnCopyBlt       = vMmCopyBlt;
            // Text functions
            ppdev->pfnGlyphOut      = vMmGlyphOut;
            ppdev->pfnGlyphOutClip  = vMmGlyphOutClip;
        }
        ppdev->pfnFastPatRealize    = vMmFastPatRealize;
#if LINETO
        ppdev->pfnLineTo            = bMmLineTo;
#endif
#endif // endif D5480
    }
    else
    {
        DISPDBG((1,"Memory mapped IO disabled"));

        ppdev->pfnXfer1bpp          = vIoXfer1bpp;
        ppdev->pfnXfer4bpp          = vIoXfer4bpp;
        ppdev->pfnXferNative        = vIoXferNative;
        ppdev->pfnFillSolid         = vIoFillSolid;
        ppdev->pfnFillPat           = vIoFillPat;
        ppdev->pfnCopyBlt           = vIoCopyBlt;
        ppdev->pfnFastPatRealize    = vIoFastPatRealize;
#if LINETO
        ppdev->pfnLineTo            = bIoLineTo;
#endif
    }

    /////////////////////////////////////////////////////////////
    // Fill in pfns specific to linear vs banked frame buffer

    if (ppdev->bLinearMode)
    {
        ppdev->pfnGetBits = vGetBitsLinear;
        ppdev->pfnPutBits = vPutBitsLinear;
    }
    else
    {
        ppdev->pfnGetBits = vGetBits;
        ppdev->pfnPutBits = vPutBits;
    }

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    //
    // It is possible that we reached this point without
    // actually mapping memory.  (i.e. if the SET_CURRENT_MODE
    // failed which occurs before we map memory)
    //
    // If this is the case, we should not try to free the
    // memory, because it hasn't been mapped!
    //

    if (ppdev->pjScreen)
    {
        DWORD        ReturnedDataLength;
        VIDEO_MEMORY VideoMemory;

        VideoMemory.RequestedVirtualAddress = ppdev->pjScreen;

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                       &VideoMemory,
                       sizeof(VIDEO_MEMORY),
                       NULL,
                       0,
                       &ReturnedDataLength))
        {
            DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // crus
    VIDEO_PUBLIC_ACCESS_RANGES VideoAccessRange[2];
    VIDEO_MEMORY               VideoMemory;
    DWORD                      ReturnedDataLength;
    BOOL                       bRet;

    DISPDBG((2, "bInitializeModeFields"));

    // crus
    bRet = IOCONTROL(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,                      // input buffer
                         0,
                         (PVOID) &VideoAccessRange, // output buffer
                         sizeof (VideoAccessRange),
                         &ReturnedDataLength);
    if (bRet == FALSE)
    {
        DISPDBG((0, "bInitializeModeFields - Error mapping ports"));
        goto ReturnFalse;
    }

    // Set a convienent pointer to the registers in the pdev.

    ppdev->pjPorts = VideoAccessRange[0].VirtualAddress;
    ppdev->pjBase  = VideoAccessRange[1].VirtualAddress;
    //sge01 end

    //
    // Merge port and register access for
    // VGA relocatable and MMIO registers.
    //
    // crus
#if defined(_X86_)
    if (VideoAccessRange[0].InIoSpace)
    {
        ppdev->pfnREAD_PORT_UCHAR    = CirrusREAD_PORT_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = CirrusREAD_PORT_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = CirrusREAD_PORT_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = CirrusWRITE_PORT_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = CirrusWRITE_PORT_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = CirrusWRITE_PORT_ULONG;
    }
    else
    {
        ppdev->pfnREAD_PORT_UCHAR    = CirrusREAD_REGISTER_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = CirrusREAD_REGISTER_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = CirrusREAD_REGISTER_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = CirrusWRITE_REGISTER_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = CirrusWRITE_REGISTER_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = CirrusWRITE_REGISTER_ULONG;
    }
#elif defined(_ALPHA_)
    if (VideoAccessRange[0].InIoSpace)
    {
        ppdev->pfnREAD_PORT_UCHAR    = READ_PORT_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = READ_PORT_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = READ_PORT_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = WRITE_PORT_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = WRITE_PORT_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = WRITE_PORT_ULONG;
    }
    else
    {
        ppdev->pfnREAD_PORT_UCHAR    = READ_REGISTER_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = READ_REGISTER_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = READ_REGISTER_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = (FnWRITE_PORT_UCHAR)WRITE_REGISTER_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = (FnWRITE_PORT_USHORT)WRITE_REGISTER_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = (FnWRITE_PORT_ULONG)WRITE_REGISTER_ULONG;
    }
#endif

//crus
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27);
    ppdev->ulChipID = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC;

    // Call the miniport to get mode information
    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((2, "getAvailableModes returned 0"));
        goto ReturnFalse;
    }

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth == 0) &&
        (pdm->dmPelsHeight == 0) &&
        (pdm->dmBitsPerPel == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((2, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((2, "Requested mode..."));
        DISPDBG((2, "  Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((2, "  Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((2, "  Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((2, "  Frequency     -- %li", pdm->dmDisplayFrequency));
        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
//myfr, 2->0
            DISPDBG((2, "Checking against miniport mode:"));
            DISPDBG((2, "  Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "  Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "  Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                              pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "  Frequency     -- %li", pVideoTemp->Frequency));

//pat04, begin
//#if 0
#if (_WIN32_WINNT < 0x0400)
            if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
                (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
                (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
            {
                 if ((pVideoTemp->VisScreenWidth  == 640) &&
                     (pVideoTemp->VisScreenHeight == 480) &&
                     (pVideoTemp->BitsPerPlane *
                      pVideoTemp->NumberOfPlanes  == 8) &&
                     (pVideoTemp->Frequency       == 60))
                 {
                     pVideoModeSelected = pVideoTemp;
                 } // default mode = 640x480x256 !   //#pat4
            }
#endif
//#endif  //0, pat04
//pat04, end

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((2, "...Found a mode match!"));
                break;
            }
        }
        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((2, "...Couldn't find a mode match!"));
        FREE(pVideoBuffer);             //ms923
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    FREE(pVideoBuffer);

#if DEBUG_HEAP
    VideoModeInformation.VisScreenWidth  = 640;
    VideoModeInformation.VisScreenHeight = 480;
#endif

    // Set up screen information from the mini-port:

    ppdev->ulMode   = VideoModeInformation.ModeIndex;
    ppdev->cxScreen = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen = VideoModeInformation.VisScreenHeight;

    DISPDBG((2, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

//crus
#ifdef PANNING_SCROLL
    if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) || //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))   //myf17
    {
         CirrusLaptopViewPoint(ppdev, &VideoModeInformation);
    }
#endif

    // Setting the SYNCHRONIZEACCESS flag tells GDI that we
    // want all drawing to the bitmaps to be synchronized (GDI
    // is multi-threaded and by default does not synchronize
    // device bitmap drawing -- it would be a Bad Thing for us
    // to have multiple threads using the accelerator at the
    // same time):

    ppdev->flHooks = HOOK_SYNCHRONIZEACCESS
                                | HOOK_FILLPATH
                                | HOOK_BITBLT
                                | HOOK_TEXTOUT
                                | HOOK_COPYBITS
                                | HOOK_STROKEPATH
                                | HOOK_SYNCHRONIZE
#if LINETO
                                | HOOK_LINETO
#endif
#if !DRIVER_PUNT_ALL
#if !DRIVER_PUNT_STRETCH
                                | HOOK_STRETCHBLT
#endif
#endif
                                ;

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;

#if (NT_VERSION < 0x0400)
    pgdi->ulDesktopHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulDesktopVertRes  = VideoModeInformation.VisScreenHeight;
#else
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;
#endif

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    // Several MIPS machines are broken in that 64 bit accesses to the
    // framebuffer don't work.

#ifdef GCAPS_NO64BITMEMACCESS
    if (VideoModeInformation.AttributeFlags & VIDEO_MODE_NO_64_BIT_ACCESS)
    {
        DISPDBG((2, "Disable 64 bit access on this device !\n"));
        pdi->flGraphicsCaps |= GCAPS_NO64BITMEMACCESS;
    }
#endif

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->cBpp            = 1;
        ppdev->cBitsPerPixel   = 8;
        ppdev->iBitmapFormat   = BMF_8BPP;
        ppdev->jModeColor      = 0;
        ppdev->ulWhite         = 0xff;
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
         (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->cBpp            = 2;
        ppdev->cBitsPerPixel   = 16;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->jModeColor      = SET_16BPP_COLOR;
        ppdev->ulWhite         = 0xffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else if (VideoModeInformation.BitsPerPlane == 24)
    {

        ppdev->cBpp            = 3;
        ppdev->cBitsPerPixel   = 24;
        ppdev->iBitmapFormat   = BMF_24BPP;
        ppdev->jModeColor      = SET_24BPP_COLOR;
        ppdev->ulWhite         = 0xffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else
    {
        ASSERTDD(VideoModeInformation.BitsPerPlane == 32,
             "This driver supports only 8, 16, 24 and 32bpp");

        ppdev->cBpp            = 4;
        ppdev->cBitsPerPixel   = 32;
        ppdev->iBitmapFormat   = BMF_32BPP;
        ppdev->jModeColor      = SET_32BPP_COLOR;
        ppdev->ulWhite         = 0xffffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }

    DISPDBG((5, "Passed bInitializeModeFields"));
    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (!IOCONTROL(hDriver,
                   IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                   NULL,
                   0,
                   &modes,
                   sizeof(VIDEO_NUM_MODES),
                   &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                       ALLOC(modes.NumModes * modes.ModeInformationLength);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (!IOCONTROL(hDriver,
                   IOCTL_VIDEO_QUERY_AVAIL_MODES,
                   NULL,
                   0,
                   *modeInformation,
                   modes.NumModes * modes.ModeInformationLength,
                   &ulTemp))
    {

        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        FREE(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16, 24 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
//ms923 added
            !(pVideoTemp->DriverSpecificAttributeFlags & CAPS_BLT_SUPPORT)||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            pVideoTemp->Length = 0;
        }
        else
        {
            DISPDBG((2, "Accepting miniport mode:"));
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}


//crus begin
//myf1, begin
#ifdef PANNING_SCROLL
VOID
CirrusLaptopViewPoint(
PDEV* ppdev,
PVIDEO_MODE_INFORMATION  pVideoModeInfo)
{
    UCHAR   ChipID;
    UCHAR   savSEQidx, Panel_Type, LCD;

    // Panning Scrolling Supported for TI

//myf16    savSEQidx = CP_IN_BYTE(ppdev->pjPorts, SR_INDEX);
//myf16    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x09);
//myf16    Panel_Type = (CP_IN_BYTE(ppdev->pjPorts, SR_DATA) & 0x70) >> 4;
//myf16    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, savSEQidx);

    savSEQidx = CP_IN_BYTE(ppdev->pjPorts, CRTC_INDEX);
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27);
    ChipID = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC) >> 2;

    if ((ChipID == 0x0E) || (ChipID == 0x0B) || (ChipID == 0x0C))
                                                          //7548/7543/7541
    {
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x20);
        LCD = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x20;
    }
    else if ((ChipID == 0x10) || (ChipID == 0x13))      //myf17
    {
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
        LCD = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x01;
    }
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, savSEQidx);

    if ((ChipID == 0x0E) || (ChipID == 0x0B) || (ChipID == 0x0C) ||
        (ChipID == 0x10) || (ChipID == 0x13))       //myf17
    {
        if ((LCD) &&                    //myf33
            !(pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
            (pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_SVGA_PANEL))
        {
            ppdev->Hres = 800;
            ppdev->Vres = 600;
        }
        else if ((LCD) &&               //myf33
            !(pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
             (pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_VGA_PANEL))
        {
            ppdev->Hres = 640;
            ppdev->Vres = 480;
        }
        else if ((LCD) &&               //myf33
            !(pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
             (pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_XGA_PANEL))
        {
            ppdev->Hres = 1024;
            ppdev->Vres = 768;
        }
        else
        {
           ppdev->Hres = pVideoModeInfo->VisScreenWidth;
           ppdev->Vres = pVideoModeInfo->VisScreenHeight;
        }

        ppdev->min_Xscreen = 0;
        ppdev->max_Xscreen = ppdev->Hres - 1;
        ppdev->min_Yscreen = 0;
        ppdev->max_Yscreen = ppdev->Vres - 1;
        DISPDBG((2,"INIT- PANNING SCROLLING : %x\t:%x, %x, \n  %x, %x, %x, %x\n",
            ppdev->ulMode,ppdev->Hres, ppdev->Vres, ppdev->min_Xscreen, ppdev->max_Xscreen,
                 ppdev->min_Yscreen, ppdev->max_Yscreen));
     }
     ppdev->flCaps = pVideoModeInfo->DriverSpecificAttributeFlags; //myf33
}
#endif
//myf1, end
//crus end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\fastfill.c ===
/******************************************************************************\
*
* $Workfile:   fastfill.c  $
*
* Fast routine for drawing polygons that aren't complex in shape.
*
* Copyright (c) 1993-1997 Microsoft Corporation
* Copyright (c) 1996-1997 Cirrus Logic, Inc.,
*
* $Log:   S:/projects/drivers/ntsrc/display/fastfill.c_v  $
 * 
 *    Rev 1.5   28 Jan 1997 13:46:30   PLCHU
 *  
 * 
 *    Rev 1.3   10 Jan 1997 15:39:44   PLCHU
 *  
 * 
 *    Rev 1.2   Nov 07 1996 16:48:02   unknown
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:37:30   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:53:14   frido
*        Removed unaccessed local variables.
*
*    chu01  : 01-02-97  5480 BitBLT enhancement
*
\******************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1

typedef struct _TRAPEZOIDDATA TRAPEZOIDDATA;    // Handy forward declaration

typedef VOID (FNTRAPEZOID)(TRAPEZOIDDATA*, LONG, LONG);
                                                // Prototype for trapezoid
                                                //   drawing routines

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      dN;               // Signed delta-y in fixed point form (also known
                            //   as the DDA error adjustment, and used to be
                            //   called 'lErrorDown')
LONG      dM;               // Signed delta-x in fixed point form
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
LONG      bNew;             // Set to TRUE when a new DDA must be started
                            //   for the edge.
} EDGEDATA;                         /* ed, ped */

typedef struct _TRAPEZOIDDATA {
FNTRAPEZOID*    pfnTrap;    // Pointer to appropriate trapezoid drawing routine,
                            //   or trapezoid clip routine
FNTRAPEZOID*    pfnTrapClip;// Pointer to appropriate trapezoid drawing routine
                            //   if doing clipping
PDEV*           ppdev;      // Pointer to PDEV
EDGEDATA        aed[2];     // DDA information for both edges
POINTL          ptlBrush;   // Brush alignment
LONG            yClipTop;   // Top of clip rectangle
LONG            yClipBottom;// Bottom of clip rectangle
LONG            xClipLeft;  // Left edge of clip rectangle
LONG            xClipRight; // Right edge of clip rectangle
BOOL            bClip;      // Are we clipping?
} TRAPEZOIDDATA;                    /* td, ptd */

/******************************Public*Routine******************************\
* VOID vClipTrapezoid
*
* Clips a trapezoid.
*
* NOTE: This routine assumes that the polygon's dimensions are small
*       enough that its QUOTIENT_REMAINDER calculations won't overflow.
*       This means that large polygons must never make it here.
*
\**************************************************************************/

VOID vClipTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapTop,
LONG            cyTrapezoid)
{
    LONG    yTrapBottom;
    LONG    dN;
    LONG    lNum;
    LONG    xDelta;
    LONG    lError;

    DISPDBG((2, "vClipTrapezoid"));

    yTrapBottom = yTrapTop + cyTrapezoid;

    if (yTrapTop < ptd->yClipTop)
    {
        if ((ptd->aed[LEFT].bNew) &&
            (yTrapBottom + ptd->aed[LEFT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[LEFT].dN;
            lNum = ptd->aed[LEFT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[LEFT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[LEFT].x     += xDelta;
            ptd->aed[LEFT].lError = lError - dN;
        }

        if ((ptd->aed[RIGHT].bNew) &&
            (yTrapBottom + ptd->aed[RIGHT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[RIGHT].dN;
            lNum = ptd->aed[RIGHT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[RIGHT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[RIGHT].x     += xDelta;
            ptd->aed[RIGHT].lError = lError - dN;
        }
    }

    // If this trapezoid vertically intersects our clip rectangle, draw it:

    if ((yTrapBottom > ptd->yClipTop) &&
        (yTrapTop    < ptd->yClipBottom))
    {
        if (yTrapTop <= ptd->yClipTop)
        {
            yTrapTop = ptd->yClipTop;

            // Have to let trapezoid drawer know that it has to load
            // its DDAs for very first trapezoid drawn:

            ptd->aed[RIGHT].bNew = TRUE;
            ptd->aed[LEFT].bNew  = TRUE;
        }

        if (yTrapBottom >= ptd->yClipBottom)
        {
            yTrapBottom = ptd->yClipBottom;
        }

        ptd->pfnTrapClip(ptd, yTrapTop, yTrapBottom - yTrapTop);
    }
}

/******************************Public*Routine******************************\
* VOID vIoSolidTrapezoid
*
* Draws a solid trapezoid using a software DDA.
*
\**************************************************************************/

VOID vIoSolidTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;
    BYTE*       pjPorts;
    LONG        lDelta;

    DISPDBG((2, "vIoSolidTrapezoid"));

    ppdev   = ptd->ppdev;
    pjPorts = ppdev->pjPorts;
    lDelta  = ppdev->lDelta;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;
    yTrapezoid *= lDelta;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;

        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (ptd->bClip)
        {
            xLeft  = max(xLeft, ptd->xClipLeft + xOffset);
            xRight = min(xRight, ptd->xClipRight + xOffset);
        }

        if (xLeft < xRight)
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

            CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(xRight - xLeft) - 1));
            CP_IO_YCNT(ppdev, pjPorts, (cyTrapezoid - 1));
            CP_IO_DST_ADDR_ABS(ppdev, pjPorts, (yTrapezoid + PELS_TO_BYTES(xLeft)));
            CP_IO_START_BLT(ppdev, pjPorts);
        }
    }
    else
    {
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        while (TRUE)
        {
            LONG    xLeftClipped;
            LONG    xRightClipped;

            if (ptd->bClip)
            {
                xLeftClipped    = max(xLeft, ptd->xClipLeft + xOffset);
                xRightClipped   = min(xRight, ptd->xClipRight + xOffset);
            }
            else
            {
                xLeftClipped = xLeft;
                xRightClipped = xRight;
            }

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeftClipped < xRightClipped)
            {
                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

                CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(xRightClipped - xLeftClipped) - 1));
                CP_IO_YCNT(ppdev, pjPorts, 0);
                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, (yTrapezoid + PELS_TO_BYTES(xLeftClipped)));
                CP_IO_START_BLT(ppdev, pjPorts);
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
            yTrapezoid += lDelta;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vIoTrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vIoTrapezoidSetup(
PDEV*          ppdev,
ULONG          rop4,
ULONG          ulSolidColor,
RBRUSH*        prb,
POINTL*        pptlBrush,
TRAPEZOIDDATA* ptd,
RECTL*         prclClip)    // NULL if no clipping
{
    BYTE* pjPorts = ppdev->pjPorts;
    LONG  cBpp    = ppdev->cBpp;
    LONG  lDelta  = ppdev->lDelta;
    BYTE  jHwRop;

    DISPDBG((2, "vIoTrapezoidSetup"));

    ptd->ppdev = ppdev;

    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];

    /////////////////////////////////////////////////////////////////
    // Setup the hardware for solid colours

    ptd->pfnTrap = vIoSolidTrapezoid;

    // We initialize the hardware for the color, rop, start address,
    // and blt mode

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_ROP(ppdev, pjPorts, jHwRop);
    CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_BLT_MODE(ppdev, pjPorts, ENABLE_COLOR_EXPAND |
                                   ENABLE_8x8_PATTERN_COPY |
                                   ppdev->jModeColor);
    CP_IO_FG_COLOR(ppdev, pjPorts, ulSolidColor);

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;
        ptd->xClipLeft   = prclClip->left;
        ptd->xClipRight  = prclClip->right;
        ptd->bClip       = TRUE;
    }
    else
    {
        ptd->bClip       = FALSE;
    }
}

/******************************Public*Routine******************************\
* VOID vMmSolidTrapezoid
*
* Draws a solid trapezoid using a software DDA.
*
\**************************************************************************/

VOID vMmSolidTrapezoid(
TRAPEZOIDDATA* ptd,
LONG           yTrapezoid,
LONG           cyTrapezoid)
{
    PDEV*    ppdev;
    LONG     xOffset;
    LONG     lLeftError;
    LONG     xLeft;
    LONG     lRightError;
    LONG     xRight;
    LONG     lTmp;
    EDGEDATA edTmp;
    BYTE*    pjBase;
    LONG     lDelta;

    DISPDBG((2, "vMmSolidTrapezoid"));

    ppdev   = ptd->ppdev;
    pjBase  = ppdev->pjBase;
    lDelta  = ppdev->lDelta;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;
    yTrapezoid *= lDelta;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;

        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (ptd->bClip)
        {
            xLeft  = max(xLeft, ptd->xClipLeft + xOffset);
            xRight = min(xRight, ptd->xClipRight + xOffset);
        }

        if (xLeft < xRight)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

            CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(xRight - xLeft) - 1));
            CP_MM_YCNT(ppdev, pjBase, (cyTrapezoid - 1));
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, (yTrapezoid + PELS_TO_BYTES(xLeft)));
            CP_MM_START_BLT(ppdev, pjBase);
        }
    }
    else
    {
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_YCNT(ppdev, pjBase, 0);

        while (TRUE)
        {
            LONG    xLeftClipped;
            LONG    xRightClipped;

            if (ptd->bClip)
            {
                xLeftClipped    = max(xLeft, ptd->xClipLeft + xOffset);
                xRightClipped   = min(xRight, ptd->xClipRight + xOffset);
            }
            else
            {
                xLeftClipped = xLeft;
                xRightClipped = xRight;
            }

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeftClipped < xRightClipped)
            {
                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

                CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(xRightClipped - xLeftClipped) - 1));
                //CP_MM_YCNT(ppdev, pjBase, 0);
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, (yTrapezoid + PELS_TO_BYTES(xLeftClipped)));
                CP_MM_START_BLT(ppdev, pjBase);
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
            yTrapezoid += lDelta;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vMmTrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vMmTrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           ulSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
RECTL*          prclClip)       // NULL if no clipping
{
    BYTE*       pjBase  = ppdev->pjBase;
    LONG        cBpp = ppdev->cBpp;
    LONG        lDelta = ppdev->lDelta;
    BYTE        jHwRop;

    DISPDBG((2, "vMmTrapezoidSetup"));

    ptd->ppdev = ppdev;

    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];

    /////////////////////////////////////////////////////////////////
    // Setup the hardware for solid colours

    ptd->pfnTrap = vMmSolidTrapezoid;

    // We initialize the hardware for the color, rop, start address,
    // and blt mode

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_ROP(ppdev, pjBase, jHwRop);
    CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND |
                                   ENABLE_8x8_PATTERN_COPY |
                                   ppdev->jModeColor);
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;
        ptd->xClipLeft   = prclClip->left;
        ptd->xClipRight  = prclClip->right;
        ptd->bClip       = TRUE;
    }
    else
    {
        ptd->bClip       = FALSE;
    }
}

// chu01 
/******************************Public*Routine******************************\
*
*     B i t B L T   E n h a n c e m e n t   F o r   C L - G D 5 4 8 0
*
\**************************************************************************/

/******************************Public*Routine******************************\
* VOID vMmSolidTrapezoid80
*
* Draws a solid trapezoid using a software DDA. This is for CL-GD5480 with 
* enhanced BitBLT features.  
*
\**************************************************************************/

VOID vMmSolidTrapezoid80(
TRAPEZOIDDATA* ptd,
LONG           yTrapezoid,
LONG           cyTrapezoid)
{
    PDEV*    ppdev;
    LONG     xOffset;
    LONG     lLeftError;
    LONG     xLeft;
    LONG     lRightError;
    LONG     xRight;
    LONG     lTmp;
    EDGEDATA edTmp;
    BYTE*    pjBase;
    LONG     lDelta;

    DISPDBG((2, "vMmSolidTrapezoid80")) ;

    ppdev       = ptd->ppdev     ;
    pjBase      = ppdev->pjBase  ;
    lDelta      = ppdev->lDelta  ;

    xOffset     = ppdev->xOffset ;
    yTrapezoid += ppdev->yOffset ;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;

        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (ptd->bClip)
        {
            xLeft  = max(xLeft, ptd->xClipLeft + xOffset);
            xRight = min(xRight, ptd->xClipRight + xOffset);
        }

        if (xLeft < xRight)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, (xRight - xLeft) - 1) ;
            CP_MM_YCNT(ppdev, pjBase, (cyTrapezoid - 1)) ;
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, 0);
            CP_MM_DST_Y(ppdev, pjBase, yTrapezoid) ;
            CP_MM_DST_X(ppdev, pjBase, xLeft) ;
        }
    }
    else
    {
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_YCNT(ppdev, pjBase, 0);

        while (TRUE)
        {
            LONG    xLeftClipped;
            LONG    xRightClipped;

            if (ptd->bClip)
            {
                xLeftClipped    = max(xLeft, ptd->xClipLeft + xOffset);
                xRightClipped   = min(xRight, ptd->xClipRight + xOffset);
            }
            else
            {
                xLeftClipped = xLeft;
                xRightClipped = xRight;
            }

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeftClipped < xRightClipped)
            {
                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
                CP_MM_XCNT(ppdev, pjBase, (xRightClipped - xLeftClipped) - 1) ;
                // CP_MM_YCNT(ppdev, pjBase, 0) ;
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, 0) ;
                CP_MM_DST_Y(ppdev, pjBase, yTrapezoid) ;
                CP_MM_DST_X(ppdev, pjBase, xLeftClipped) ;
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
            yTrapezoid += 1 ;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }

}

/******************************Public*Routine******************************\
* VOID vMmTrapezoidSetup80
*
* Initialize the hardware and some state for doing trapezoids. This is for 
* CL-GD5480 with enhanced BitBLT features.  
*
\**************************************************************************/

VOID vMmTrapezoidSetup80(
PDEV*           ppdev,
ULONG           rop4,
ULONG           ulSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
RECTL*          prclClip)       // NULL if no clipping
{
    BYTE*       pjBase  = ppdev->pjBase ;
    LONG        cBpp    = ppdev->cBpp   ;
    LONG        lDelta  = ppdev->lDelta ;

    ULONG       jHwRop ;
    DWORD       jExtMode = 0 ; 

    DISPDBG((2, "vMmTrapezoidSetup80")) ;

    ptd->ppdev = ppdev ;

    jHwRop = gajHwPackedMixFromRop2[(rop4 >> 2) & 0xf] ;

    /////////////////////////////////////////////////////////////////
    // Setup the hardware for solid colours

    ptd->pfnTrap = vMmSolidTrapezoid80 ;

    // We initialize the hardware for the color, rop, start address,
    // and blt mode

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8  ;
        ulSolidColor |= ulSolidColor << 16 ;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16 ;
    }

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
    CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset) ;
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    jExtMode = ( ENABLE_XY_POSITION_PACKED | 
                 ENABLE_COLOR_EXPAND       | 
                 ENABLE_8x8_PATTERN_COPY   |
                 ppdev->jModeColor ) ;

    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop) ;
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor) ;

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap     ;
        ptd->pfnTrap     = vClipTrapezoid   ;
        ptd->yClipTop    = prclClip->top    ;
        ptd->yClipBottom = prclClip->bottom ;
        ptd->xClipLeft   = prclClip->left   ;
        ptd->xClipRight  = prclClip->right  ;
        ptd->bClip       = TRUE;
    }
    else
    {
        ptd->bClip       = FALSE;
    }

}

/******************************Public*Routine******************************\
* BOOL bFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or Win95.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* This routine handles patterns only when the S3 hardware patterns can be
* used.  The reason for this is that once the S3 pattern initialization is
* done, pattern fills appear to the programmer exactly the same as solid
* fills (with the slight difference that different registers and commands
* are used).  Handling 'vIoFillPatSlow' style patterns in this routine
* would be non-trivial...
*
* We take advantage of the fact that the S3 automatically advances the
* current 'y' to the following scan whenever a rectangle is output so that
* we have to write to the accelerator three times for every scan: one for
* the new 'x', one for the new 'width', and one for the drawing command.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       rop4,
ULONG       iSolidColor,
RBRUSH*     prb,
POINTL*     pptlBrush,
RECTL*      prclClip)       // NULL if no clipping
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    TRAPEZOIDDATA   td;     // Edge data and stuff
    EDGEDATA*       ped;    // Points to current edge being processed

    /////////////////////////////////////////////////////////////////
    // See if the polygon is convex

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    if (cEdges <= 2)
        goto ReturnTrue;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        goto ReturnFalse;
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        goto ReturnFalse;
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    td.aed[LEFT].pptfx  = pptfxTop;
    td.aed[RIGHT].pptfx = pptfxTop;

    yTrapezoid = (pptfxTop->y + 15) >> 4;

    // Make sure we initialize the DDAs appropriately:

    td.aed[LEFT].cy  = 0;
    td.aed[RIGHT].cy = 0;

    // Guess as to the ordering of the points:

    td.aed[LEFT].dptfx  = sizeof(POINTFIX);
    td.aed[RIGHT].dptfx = -(LONG) sizeof(POINTFIX);

    if (ppdev->flCaps & CAPS_MM_IO)
    {
// chu01
        if ((ppdev->flCaps & CAPS_COMMAND_LIST) && (ppdev->pCommandList != NULL))
        {
            vMmTrapezoidSetup80(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                                prclClip) ;
        }
        else
            vMmTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                              prclClip) ;
    }
    else
    {
        vIoTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                          prclClip);
    }

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped       = &td.aed[iEdge];
        ped->bNew = FALSE;
        if (ped->cy == 0)
        {
            // Our trapezoid drawing routine may want to be notified when
            // it will have to reset its DDA to start a new edge:

            ped->bNew = TRUE;

            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                    goto ReturnTrue;

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            ped->dM = dM;                   // Not used for software trapezoid

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->dN = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->dN;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->dN * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(td.aed[LEFT].cy, td.aed[RIGHT].cy); // # of scans in this trap
    td.aed[LEFT].cy  -= cyTrapezoid;
    td.aed[RIGHT].cy -= cyTrapezoid;

    td.pfnTrap(&td, yTrapezoid, cyTrapezoid);

    yTrapezoid += cyTrapezoid;

    goto NewTrapezoid;

ReturnTrue:

    return(TRUE);

ReturnFalse:

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\fillpath.c ===
/******************************************************************************\
*
* $Workfile:   fillpath.c  $
*
* Contains the DrvFillPath routine, which is used for drawing polygons.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/fillpath.c_v  $
 *
 *    Rev 1.1   Oct 10 1996 15:37:36   unknown
 *
*
*    Rev 1.1   12 Aug 1996 16:53:28   frido
* Removed unaccessed local variables.
*
\******************************************************************************/

#include "precomp.h"

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit LONGs to produce a 64-bit LONGLONG result.
//      I use it because it is much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        rop4;           // Hardware mix value
    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;
    DSURF       *pdsurf;
    RECTL*       prclClip;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    RECTFX       rcfxBounds;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];

    DISPDBG((1, "DrvFillPath"));

    if (ppo->fl & PO_BEZIERS)   // don't handle beziers
    {
        goto ReturnFalse;
    }

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        bRetVal = EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                           flOptions);
        goto ReturnStatus;
    }

    iSolidColor = 0;                            // Assume we won't need a pattern

    rop4 = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xff];

    if ((((rop4 & 0xff00) >> 8) != (rop4 & 0x00ff)) ||
        ((((rop4 >> 4) ^ (rop4)) & 0xf0f) != 0))  // Only do if we need a pattern
    {
        iSolidColor     = pbo->iSolidColor;
        rbc.iSolidColor = iSolidColor;
        if (iSolidColor == -1)
        {
            goto ReturnFalse;   // don't handle non solid patterns
        }
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = pdsurf->poh->x;
    ppdev->yOffset = pdsurf->poh->y;
    ppdev->xyOffset = pdsurf->poh->xy;

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        pfnFill = vMmFillSolid;
    }
    else
    {
        pfnFill = vIoFillSolid;
    }

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this
    PATHOBJ_vEnumStart(ppo);
    bMore = PATHOBJ_bEnum(ppo, &pd);

    {
        prclClip = NULL;
        if (jClipping == DC_RECT)
        {
            prclClip = &ClipRect;

            // Our FastFill routine does cross products and intersection
            // calculations assuming it can use 32 bit math and not
            // overflow.  As such, we have to ensure that the bounds of
            // the polygon fit in a 15 bit space, including the 4 bit fix
            // point fraction.  Note that we don't have to do this check
            // for trivial clipping, because we'll assume the screen
            // dimensions are 2048 x 2048 or smaller:

            PATHOBJ_vGetBounds(ppo, &rcfxBounds);

            if (((rcfxBounds.xRight - rcfxBounds.xLeft) > 0x7fff) ||
                ((rcfxBounds.yBottom - rcfxBounds.yTop) > 0x7fff))
                goto SkipFastFill;
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

        if (bFastFill(ppdev, pd.count, pd.pptfx, rop4, iSolidColor,
                       rbc.prb, pptlBrush, prclClip))
        {
            goto ReturnTrue;
        }
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) ALLOC(ppo->cCurves * sizeof(EDGE));

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, rop4,
                               rbc, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, rop4, rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        FREE(pFreeEdges);
    }

ReturnStatus:
    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else

    LONGLONG llErrorTerm;
    INT NumAdjustDowns;

    llErrorTerm = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    llErrorTerm += Int32x32To64(iErrorAdjustUp,yJump);

    // See if the error term turned over even once while skipping
    if (llErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (UInt64Div32To32(llErrorTerm,iErrorAdjustDown)) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        llErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (INT) llErrorTerm;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\debug.h ===
/******************************************************************************\
*
* $Workfile:   debug.h  $
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/debug.h_v  $
 * 
 *    Rev 1.1   Oct 10 1996 15:36:34   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:47:44   frido
* Added NT 3.5x/4.0 auto detection.
*
\******************************************************************************/

//#if DBG
#if (DBG_STRESS_FAILURE || DBG)

    VOID
    DebugPrint(
        ULONG DebugPrintLevel,
        PCHAR DebugMessage,
        ...
        );


    VOID
    PerfPrint(
        ULONG PerfPrintLevel,
        PCHAR PerfMessage,
        ...
        );

    #define DISPDBG(arg) DebugPrint arg
    #define DISPPRF(arg) PerfPrint arg
#if (NT_VERSION < 0x0400)
    #define RIP(x) { DebugPrint(0, x); DebugBreak(); }
#else
    #define RIP(x) { DebugPrint(0, x); EngDebugBreak(); }
#endif
    #define ASSERTDD(x, y) if (!(x)) RIP (y)
    #define STATEDBG(level)    0
    #define LOGDBG(arg)        0

#else

    #define DISPDBG(arg)    0
    #define DISPPRF(arg)    0
    #define RIP(x)            0
    #define ASSERTDD(x, y)    0
    #define STATEDBG(level)    0
    #define LOGDBG(arg)        0

#endif

#define DUMPVAR(x,format_str)   DISPDBG((0,#x" = "format_str,x));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\driver.h ===
/******************************************************************************\
*
* $Workfile:   driver.h  $
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
*
* $Log:   S:/projects/drivers/ntsrc/display/driver.h_v  $
 *
 *    Rev 1.7   Apr 03 1997 15:38:48   unknown
 *
 *
 *    Rev 1.6   28 Mar 1997 16:08:38   PLCHU
 *
 *
 *    Rev 1.5   18 Dec 1996 13:44:08   PLCHU
 *
 *
 *    Rev 1.4   Dec 13 1996 12:16:18   unknown
 *
 *
 *    Rev 1.3   Nov 07 1996 16:43:40   unknown
 * Clean up CAPS flags
 *
 *    Rev 1.1   Oct 10 1996 15:36:36   unknown
 *
*
*    Rev 1.13   12 Aug 1996 16:47:58   frido
* Added NT 3.5x/4.0 auto detection.
*
*    Rev 1.12   08 Aug 1996 16:20:06   frido
* Added vMmCopyBlt36.
*
*    Rev 1.11   31 Jul 1996 15:43:42   frido
* Added new brush caches.
*
*    Rev 1.10   24 Jul 1996 14:38:24   frido
* Added ulFontCacheID for font cache cleanup.
*
*    Rev 1.9   24 Jul 1996 14:30:26   frido
* Changed some structures for a new FONTCACHE chain.
*
*    Rev 1.8   22 Jul 1996 20:45:48   frido
* Added font cache.
*
*    Rev 1.7   19 Jul 1996 01:00:00   frido
* Added Dbg... declarations.
*
*    Rev 1.6   15 Jul 1996 10:58:58   frido
* Changed back to old DirectDraw structures.
*
*    Rev 1.5   12 Jul 1996 17:45:38   frido
* Change DirectDraw structures.
*
*    Rev 1.4   10 Jul 1996 13:07:34   frido
* Changed LineTo function.
*
*    Rev 1.3   09 Jul 1996 17:58:30   frido
* Added LineTo code.
*
*    Rev 1.2   03 Jul 1996 13:44:36   frido
* Fixed a typo.
*
*    Rev 1.1   03 Jul 1996 13:38:54   frido
* Added DirectDraw support.
*
*    sge01  10-23-96 Add 5446BE flag
*
*    chu01  12-16-96 Enable color correction
*
* myf0 : 08-19-96  added 85hz supported
* myf1 : 08-20-96  supported panning scrolling
* myf2 : 08-20-96 : fixed hardware save/restore state bug for matterhorn
* myf3 : 09-01-96 : Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4 : 09-01-96 : patch Viking BIOS bug, PDR #4287, begin
* myf5 : 09-01-96 : Fixed PDR #4365 keep all default refresh rate
* myf6 : 09-17-96 : Merged Desktop SRC1001 & MINI102
* myf7 : 09-19-96 : Fixed exclude 60Hz refresh rate selected
* myf8 :*09-21-96*: May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9 : 09-21-96 : 8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809:09-25-96 : fixed dstn panel icon corrupted
* ms923 :09-25-96 : merge MS-923 Disp.zip code
* myf10 :09-26-96 : Fixed DSTN reserved half-frame buffer bug.
* myf11 :09-26-96 : Fixed 755x CE chip HW bug, access ramdac before disable HW
*                   icons and cursor
* myf12 :10-01-96 : Supported Hot Key switch display
* myf13 :10-05-96 : Fixed /w panning scrolling, vertical expension on bug
* myf14 :10-15-96 : Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15 :10-16-96 : Fixed disable memory mapped IO for 754x, 755x
* myf16 :10-22-96 : Fixed PDR #6933,panel type set different demo board setting
* tao1 : 10-21-96 : added direct draw support for 7555.
* pat04: 12-20-96 : Supported NT3.51 software cursor with panning scrolling
* myf33 :03-21-97 : Support TV ON/OFF
*

\******************************************************************************/

//////////////////////////////////////////////////////////////////////
// Warning:  The following defines are for private use only.  They
//           should only be used in such a fashion that when defined as 0,
//           all code specific to punting is optimized out completely.

#define DRIVER_PUNT_ALL         0

#define DRIVER_PUNT_LINES       0
#define DRIVER_PUNT_BLT         0
#define DRIVER_PUNT_STRETCH     0
#define DRIVER_PUNT_PTR         1
#define DRIVER_PUNT_BRUSH       0

// myf1 09-01-96
//myf17   #define PANNING_SCROLL              //myf1

//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Some Mips machines have bus problems that prevent GDI from being able
// to draw on the frame buffer.  The DIRECT_ACCESS() macro is used to
// determine if we are running on one of these machines.  Also, we map
// video memory as sparse on the ALPHA, so we need to control access to
// the framebuffer through the READ/WRITE_REGISTER macros.

#if defined(_ALPHA_)
    #define DIRECT_ACCESS(ppdev)    FALSE
#else
    #define DIRECT_ACCESS(ppdev)    TRUE
#endif

#define BANKING                     TRUE        //ms923

#define HOST_XFERS_DISABLED(ppdev)  (ppdev->pulXfer == NULL)

// Useful for visualizing the 2-d heap:

#define DEBUG_HEAP              FALSE

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#if (_WIN32_WINNT < 0x0400)
        // NT 3.51
        #define DLL_NAME                                L"cirrus35"     // Name of the DLL in UNICODE
        #define NT_VERSION                              0x0351
        #define ALLOC(c)                                LocalAlloc(LPTR, c)
        #define FREE(ptr)                               LocalFree(ptr)
        #define IOCONTROL(h, ctrl, in, cin, out, cout, c)                          \
                (DeviceIoControl(h, ctrl, in, cin, out, cout, c, NULL) == TRUE)
#else
        // NT 4.0
        #define DLL_NAME                L"cirrus"   // Name of the DLL in UNICODE
        #define NT_VERSION                              0x0400
        #define ALLOC(c)                                EngAllocMem(FL_ZERO_MEMORY, c, ALLOC_TAG)
        #define FREE(ptr)                               EngFreeMem(ptr)
        #define IOCONTROL(h, ctrl, in, cin, out, cout, c)                          \
                   (EngDeviceIoControl(h, ctrl, in, cin, out, cout, c) == ERROR_SUCCESS)
#endif

// Default values if not yet defined.
#ifndef GDI_DRIVER_VERSION
    #define GDI_DRIVER_VERSION              0x3500
#endif
#ifndef VIDEO_MODE_MAP_MEM_LINEAR
    #define VIDEO_MODE_MAP_MEM_LINEAR       0x40000000
#endif

#define STANDARD_PERF_PREFIX    "Cirrus [perf]: " // All perf output is prefixed
                                                  //   by this string
#define STANDARD_DEBUG_PREFIX   "Cirrus: "  // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               ' lcD'      // Dcl
                                            // Four byte tag (characters in
                                            // reverse order) used for memory
                                            // allocations

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     8192  // Size in bytes of 'pvTmpBuffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */

////////////////////////////////////////////////////////////////////////////////
//         D R I V E R   C A P A B I L I T I E S                  //
////////////////////////////////////////////////////////////////////////////////

#if (NT_VERSION < 0x0400)
        #define DIRECTDRAW              0       // DirectDraw not supported in NT 3.5x
        #define LINETO                  0       // DrvLineTo not supported in NT 3.5x
#else
        #define DIRECTDRAW              1       // DirectDraw supported in NT 4.0
        #define LINETO                  0       // DrvLineTo not supported in NT 4.0
#endif

typedef struct _PDEV PDEV;      // Handy forward declaration

//////////////////////////////////////////////////////////////////////
// Text stuff

#if 1 // Font cache.
#define MAX_GLYPHS      256     // Maximum number of glyphs per font.
#define FONT_ALLOC_X    128     // X allocation per font block in bytes.
#define FONT_ALLOC_Y    32      // Maximum height of font.

typedef struct _OH                      OH;
typedef struct _FONTMEMORY      FONTMEMORY;
typedef struct _FONTCACHE       FONTCACHE;

typedef struct _FONTMEMORY {
OH*             poh;            // Pointer to allocated memory block.
LONG            x;              // Last x of allocation.
LONG            cx, cy;         // Size of allocation in bytes.
LONG            xy;             // Linear address of current line.
FONTMEMORY* pfmNext;            // Pointer to next allocated memory block.
} FONTMEMORY;

#define GLYPH_UNCACHEABLE       -1
#define GLYPH_EMPTY             -2

typedef struct _GLYPHCACHE {
BYTE*  pjGlyph;                 // Linear address of glyph.
        // If pjPos == NULL then glyph has not yet been cached.
POINTL ptlOrigin;               // Origin of glyph.
SIZEL  sizlBytes;               // Adjusted size of glyph.
SIZEL  sizlPixels;              // Size of glyph.
        // If sizlSize.cy == -1 then glyph if uncacheable.
        // If sizlSize.cy == -2 then glyph is empty.
LONG   lDelta;                  // Width of glyph on bytes.
} GLYPHCACHE;

typedef struct _FONTCACHE {
PDEV*           ppdev;          // Pointer to PDEV structure.
FONTMEMORY* pfm;                // Pointer to first FONTMEMORY structure.
LONG            cWidth;         // Width of allocation in pixels.
LONG            cHeight;        // Height of allocation in pixels.
ULONG           ulFontCacheID;  // Font cache ID.
FONTOBJ*        pfo;            // Pointer to FONT object for this cache.
FONTCACHE*      pfcPrev;        // Pointer to previous FONTCACHE structure.
FONTCACHE*      pfcNext;        // Pointer to next FONTCACHE structure.
GLYPHCACHE      aGlyphs[MAX_GLYPHS];    // Array of cached glyphs.
} FONTCACHE;

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                      /* xlc, pxlc */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);
VOID vClearMemDword(ULONG*, ULONG);

LONG  cGetGlyphSize(GLYPHBITS*, POINTL*, SIZEL*);
LONG  lAllocateGlyph(FONTCACHE*, GLYPHBITS*, GLYPHCACHE*);
BYTE* pjAllocateFontCache(FONTCACHE*, LONG);
BOOL  bFontCache(PDEV*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, BRUSHOBJ*,
                                 BRUSHOBJ*);
VOID  vDrawGlyph(PDEV*, GLYPHBITS*, POINTL);
VOID  vClipGlyph(PDEV*, GLYPHBITS*, POINTL, RECTL*, ULONG);
#if 1 // D5480
VOID vMmGlyphOut(PDEV*, FONTCACHE*, STROBJ*, ULONG);
VOID vMmGlyphOutClip(PDEV*, FONTCACHE*, STROBJ*, RECTL*, ULONG);
VOID vMmGlyphOut80(PDEV*, FONTCACHE*, STROBJ*, ULONG);
VOID vMmGlyphOutClip80(PDEV*, FONTCACHE*, STROBJ*, RECTL*, ULONG);
#endif // endif D5480
#endif

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);
VOID            vDitherColorToVideoMemory(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Fast' brushes are used when we have hardware pattern capability:

#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    //   cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry
                                    //   is 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    //   the dimension of each brush allocation

// Common to both implementations:

#define RBRUSH_2COLOR           1   // For RBRUSH flags
#if 1 // New brush cache.
#define RBRUSH_PATTERN                  0       // Colored brush.
#define RBRUSH_MONOCHROME               1       // Monochrome brush.
#define RBRUSH_DITHER                   2       // Dithered brush.
#define RBRUSH_XLATE                    3       // 16-color translated brush.
#endif

#define TOTAL_BRUSH_COUNT       FAST_BRUSH_COUNT
                                // This is the maximum number of brushes
                                //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

#define BRUSH_TILE_FACTOR       4   // 2x2 tiled patterns require 4x the space

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    POINTL      ptlBrushOrg;    // Brush origin of cached pattern.  Initial
                                //   value should be -1
    BRUSHENTRY* pbe;            // Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
#if 1 // New brush cache.
    ULONG       ulUniq;         // Unique value for cached brushes.
    ULONG       ulSlot;         // Offset to cache slot (PDEV relative).
    ULONG       ulBrush;        // Offset to off-screen brush.
    LONG        cjBytes;        // Number of bytes in pattern.
#endif
    ULONG       aulPattern[0];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern
    LONG        xy;             // offset of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

BOOL bEnableBrushCache(PDEV*);
VOID vDisableBrushCache(PDEV*);
VOID vAssertModeBrushCache(PDEV*, BOOL);

#if 1 // New brush cache.
#define NUM_DITHERS             8
#define NUM_PATTERNS    8
#define NUM_MONOCHROMES 20

typedef struct _DITHERCACHE {
        ULONG ulBrush;                          // Offset to off-screen brush.
        ULONG ulColor;                          // Logical color.
} DITHERCACHE;

typedef struct _PATTERNCACHE {
        ULONG   ulBrush;                        // Offset to off-screen brush.
        RBRUSH* prbUniq;                        // Pointer to realized brush.
} PATTERNCACHE;

typedef struct _MONOCACHE {
        ULONG ulBrush;                          // Offset to off-screen brush cache.
        ULONG ulUniq;                           // Unique counter for brush.
        ULONG ulBackColor;                      // Background color for 24-bpp.
        ULONG ulForeColor;                      // Foreground color for 24-bpp.
        ULONG aulPattern[2];            // Monochrome pattern.
} MONOCACHE;

BOOL bCacheDither(PDEV*, RBRUSH*);
BOOL bCachePattern(PDEV*, RBRUSH*);
BOOL bCacheMonochrome(PDEV*, RBRUSH*);
#endif

//////////////////////////////////////////////////////////////////////
// Stretch stuff

typedef struct _STR_BLT {
    PDEV*   ppdev;
    PBYTE   pjSrcScan;
    LONG    lDeltaSrc;
    LONG    XSrcStart;
    PBYTE   pjDstScan;
    LONG    lDeltaDst;
    LONG    XDstStart;
    LONG    XDstEnd;
    LONG    YDstStart;
    LONG    YDstCount;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
} STR_BLT;

typedef VOID (*PFN_DIRSTRETCH)(STR_BLT*);

VOID vDirectStretch8Narrow(STR_BLT*);
VOID vDirectStretch8(STR_BLT*);
VOID vDirectStretch16(STR_BLT*);
VOID vDirectStretch24(STR_BLT*);
VOID vDirectStretch32(STR_BLT*);

#if 1 // D5480 chu01
VOID vDirectStretch8_80(STR_BLT*)  ;
VOID vDirectStretch16_80(STR_BLT*) ;
VOID vDirectStretch24_80(STR_BLT*) ;
#endif // D5480 chu01

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef enum {
    OFL_INUSE       = 1,    // The device bitmap is no longer located in
                            //   off-screen memory; it's been converted to
                            //   a DIB
    OFL_AVAILABLE   = 2,    // Space is in-use
    OFL_PERMANENT   = 4     // Space is available
} OHFLAGS;                  // Space is permanently allocated; never free it

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHFLAGS  ofl;           // OH_ flags
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     xy;            // offset to top left corner of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    OH*      pohNext;       // When OFL_AVAILABLE, points to the next free node,
                            //   in ascending cxcy value.  This is kept as a
                            //   circular doubly-linked list with a sentinel
                            //   at the end.
                            // When OFL_INUSE, points to the next most recently
                            //   blitted allocation.  This is kept as a circular
                            //   doubly-linked list so that the list can be
                            //   quickly be updated on every blt.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Adjacent allocation when in-use or available
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
    VOID*    pvScan0;       // Points to start of first scan-line
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    OH       ohAvailable;   // Head of available list (pohNext points to
                            //   smallest available rectangle, pohPrev
                            //   points to largest available rectangle,
                            //   sorted by cxcy)
    OH       ohDfb;         // Head of the list of all DFBs currently in
                            //   offscreen memory that are eligible to be
                            //   tossed out of the heap (pohNext points to
                            //   the most recently blitted; pohPrev points
                            //   to least recently blitted)
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */

// GDI expects dword alignment for any bitmaps on which it is expected
// to draw.  Since we occasionally ask GDI to draw directly on our off-
// screen bitmaps, this means that any off-screen bitmaps must be dword
// aligned in the frame buffer.  We enforce this merely by ensuring that
// all off-screen bitmaps are four-pel aligned (we may waste a couple of
// pixels at the higher colour depths):

#define HEAP_X_ALIGNMENT    8

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x00000001,   // Don't kick stuff out of off-
                                            //   screen memory to make room
} FLOH;

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
OH*  pohAllocatePermanent(PDEV*, LONG, LONG);
BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);
OH*  pohAllocate(PDEV*, LONG, LONG, FLOH);
OH*  pohFree(PDEV*, OH*);
VOID vCalculateMaximum(PDEV*);

/////////////////////////////////////////////////////////////////////////
// Bank manager stuff

#define BANK_DATA_SIZE  80      // Number of bytes to allocate for the
                                //   miniport down-loaded bank code working
                                //   space

typedef struct _BANK
{
    // Private data:

    RECTL    rclDraw;           // Rectangle describing the remaining undrawn
                                //   portion of the drawing operation
    RECTL    rclSaveBounds;     // Saved from original CLIPOBJ for restoration
    BYTE     iSaveDComplexity;  // Saved from original CLIPOBJ for restoration
    BYTE     fjSaveOptions;     // Saved from original CLIPOBJ for restoration
    LONG     iBank;             // Current bank
    PDEV*    ppdev;             // Saved copy

    // Public data:

    SURFOBJ* pso;               // Surface wrapped around the bank.  Has to be
                                //   passed as the surface in any banked call-
                                //   back.
    CLIPOBJ* pco;               // Clip object that is the intersection of the
                                //   original clip object with the bounds of the
                                //   current bank.  Has to be passed as the clip
                                //   object in any banked call-back.

} BANK;                         /* bnk, pbnk */

typedef enum {
    BANK_OFF = 0,       // We've finished using the memory aperture
    BANK_ON,            // We're about to use the memory aperture
    BANK_DISABLE,       // We're about to enter full-screen; shut down banking
    BANK_ENABLE,        // We've exited full-screen; re-enable banking

} BANK_MODE;                    /* bankm, pbankm */

typedef VOID (FNBANKMAP)(PDEV*, LONG);
typedef VOID (FNBANKSELECTMODE)(PDEV*, BANK_MODE);
typedef VOID (FNBANKINITIALIZE)(PDEV*, BOOL);
typedef BOOL (FNBANKCOMPUTE)(PDEV*, RECTL*, RECTL*, LONG*, LONG*);

VOID vBankStart(PDEV*, RECTL*, CLIPOBJ*, BANK*);
BOOL bBankEnum(BANK*);

FNBANKCOMPUTE bBankComputeNonPower2;
FNBANKCOMPUTE bBankComputePower2;

BOOL bEnableBanking(PDEV*);
VOID vDisableBanking(PDEV*);
VOID vAssertModeBanking(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

typedef VOID (FNSHOWPOINTER)(VOID*, BOOL);
typedef VOID (FNMOVEPOINTER)(VOID*, LONG, LONG);
typedef BOOL (FNSETPOINTERSHAPE)(VOID*, LONG, LONG, LONG, LONG, LONG, LONG, BYTE*);
typedef VOID (FNENABLEPOINTER)(VOID*, BOOL);

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);
VOID vAssertHWiconcursor(PDEV*, BOOL);          //myf11

UCHAR HWcur, HWicon0, HWicon1, HWicon2, HWicon3;        //myf11

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette(PDEV*);
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

#if DIRECTDRAW
//////////////////////////////////////////////////////////////////////
// DirectDraw stuff

#define ROUND_UP_TO_64K(x)      (((ULONG)(x) + 0xFFFF) & ~0xFFFF)

typedef struct _FLIPRECORD
{
     FLATPTR    fpFlipFrom;             // Surface we last flipped from
     LONGLONG   liFlipTime;             // Time at which last flip occured
     LONGLONG   liFlipDuration;         // Precise amount of time it takes from
                                        // vblank to vblank
     BOOL       bFlipFlag;              // True if we think a flip is still
                                        // pending
     BOOL       bHaveEverCrossedVBlank; // True if we noticed that we switched
                                        // from inactive to vblank
     BOOL       bWasEverInDisplay;      // True is we ever noticed that we were
                                        // inactive
// crus
   DWORD    dwFlipScanLine;
} FLIPRECORD;

BOOL bEnableDirectDraw(PDEV*);
VOID vDisableDirectDraw(PDEV*);
VOID vAssertModeDirectDraw(PDEV*, BOOL);
#endif

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ROP4, RBRUSH_COLOR, POINTL*);
typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ROP4, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ROP4, POINTL*, RECTL*);
typedef VOID (FNFASTPATREALIZE)(PDEV*, RBRUSH*);
typedef VOID (FNBITS)(PDEV*, SURFOBJ*, RECTL*, POINTL*);
typedef BOOL (FNFASTFILL)(PDEV*, LONG, POINTFIX*, ULONG, ULONG, RBRUSH*,
                          POINTL*, RECTL*);
#if LINETO
typedef BOOL (FNLINETO)(PDEV*, LONG, LONG, LONG, LONG, ULONG, MIX, ULONG);
#endif
#if 1 // D5480
typedef VOID (FNGLYPHOUT)(PDEV*, FONTCACHE*, STROBJ*, ULONG);
typedef VOID (FNGLYPHOUTCLIP)(PDEV*, FONTCACHE*, STROBJ*, RECTL*, ULONG);
#endif // endif D5480
#if 1 // OVERLAY #sge
#if (_WIN32_WINNT >= 0x0400)    //myf33
typedef VOID (FNREGINITVIDEO)(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface);
typedef VOID (FNREGMOVEVIDEO)(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface);
typedef BOOL (FNBANDWIDTHEQ)(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags);
typedef VOID (FNDISABLEOVERLAY)(PDEV* ppdev);
typedef VOID (FNCLEARALTFIFO)(PDEV* ppdev);
#endif
#endif

FNFILL              vIoFillPat;
FNFILL              vIoFillSolid;
FNXFER              vIoXfer1bpp;
FNXFER              vIoXfer4bpp;
FNXFER              vIoXferNative;
FNCOPY              vIoCopyBlt;
FNFASTPATREALIZE    vIoFastPatRealize;
#if LINETO
FNLINETO            bIoLineTo;
#endif

FNFILL              vMmFillPat;
FNFILL              vMmFillSolid;
#if 1 // New pattern blt routines.
FNFILL              vMmFillPat36;
FNFILL              vMmFillSolid36;
FNCOPY              vMmCopyBlt36;
#endif
FNXFER              vMmXfer1bpp;
FNXFER              vMmXfer4bpp;
FNXFER              vMmXferNative;
FNCOPY              vMmCopyBlt;
FNFASTPATREALIZE    vMmFastPatRealize;
#if LINETO
FNLINETO            bMmLineTo;
#endif

FNFASTFILL          bFastFill;

FNXFER              vXferNativeSrccopy;
FNXFER              vXferScreenTo1bpp;
FNBITS              vPutBits;
FNBITS              vGetBits;
FNBITS              vPutBitsLinear;
FNBITS              vGetBitsLinear;
#if 1 // D5480
FNGLYPHOUT          vMmGlyphOut;
FNGLYPHOUT          vMmGlyphOut80;
FNGLYPHOUTCLIP      vMmGlyphOutClip;
FNGLYPHOUTCLIP      vMmGlyphOutClip80;
FNFILL              vMmFillSolid80;
FNFILL              vMmFillPat80;
FNCOPY              vMmCopyBlt80;
FNXFER              vMmXfer1bpp80;
FNXFER              vMmXferNative80;
#endif // endif D5480

VOID vPutBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBitsLinear(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vIoSlowPatRealize(PDEV*, RBRUSH*, BOOL);

////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to us from the video miniport.  They
// come from the 'DriverSpecificAttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the video miniport

#define CAPS_NO_HOST_XFER       0x00000002   // Do not use host xfers to
                                             //  the blt engine.
#define CAPS_SW_POINTER         0x00000004   // Use software pointer.
#define CAPS_TRUE_COLOR         0x00000008   // Set upper color registers.
#define CAPS_MM_IO              0x00000010   // Use memory mapped IO.
#define CAPS_BLT_SUPPORT        0x00000020   // BLTs are supported
#define CAPS_IS_542x            0x00000040   // This is a 542x
#define CAPS_AUTOSTART          0x00000080   // Autostart feature support.
#define CAPS_CURSOR_VERT_EXP    0x00000100   // Flag set if 8x6 panel,
#define CAPS_DSTN_PANEL         0x00000200   // DSTN panel in use, ms0809
#define CAPS_VIDEO              0x00000400   // Video support.
#define CAPS_SECOND_APERTURE    0x00000800   // Second aperture support.
#define CAPS_COMMAND_LIST       0x00001000   // Command List support.
#define CAPS_GAMMA_CORRECT      0x00002000   // Color correction.
#define CAPS_VGA_PANEL          0x00004000   // use 6x4 VGA PANEL.
#define CAPS_SVGA_PANEL         0x00008000   // use 8x6 SVGA PANEL.
#define CAPS_XGA_PANEL          0x00010000   // use 10x7 XGA PANEL.
#define CAPS_PANNING            0x00020000   // Panning scrolling supported.
#define CAPS_TV_ON              0x00040000   // TV turn on supported., myf33
#define CAPS_TRANSPARENCY       0x00080000   // Transparency is supported
#define CAPS_ENGINEMANAGED      0x00100000   // Engine managed surface
//myf16, end


////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    STAT_GLYPH_CACHE        = 0x0001,   // Glyph cache successfully allocated
    STAT_BRUSH_CACHE        = 0x0002,   // Brush cache successfully allocated
#if 1 // New status flags.
    STAT_DIRECTDRAW         = 0x0004,   // DirectDraw is enabled.
    STAT_FONT_CACHE         = 0x0008,   // Font cache is available.
    STAT_DITHER_CACHE       = 0x0010,   // Dither cache is available.
    STAT_PATTERN_CACHE      = 0x0020,   // Pattern cache is available.
    STAT_MONOCHROME_CACHE   = 0x0040,   // Monochrome cache is available.
// crus
   STAT_STREAMS_ENABLED    = 0x0080    // Overlay support
#endif
} STATUS;

// crus
#if 1 // OVERLAY #sge
#define MAX_STRETCH_SIZE     1024
typedef struct
{
    RECTL          rDest;
    RECTL          rSrc;
    DWORD          dwFourcc;        //overlay video format
    WORD           wBitCount;       //overlay color depth
    LONG           lAdjustSource;   //when video start address needs adjusting
} OVERLAYWINDOW;
#endif

//
// Merger port and register access
//
#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

typedef UCHAR   (*FnREAD_PORT_UCHAR)(PVOID Port);
typedef USHORT  (*FnREAD_PORT_USHORT)(PVOID Port);
typedef ULONG   (*FnREAD_PORT_ULONG)(PVOID Port);
typedef VOID    (*FnWRITE_PORT_UCHAR)(PVOID Port, UCHAR Value);
typedef VOID    (*FnWRITE_PORT_USHORT)(PVOID  Port, USHORT Value);
typedef VOID    (*FnWRITE_PORT_ULONG)(PVOID Port, ULONG Value);

#elif defined(_ALPHA_)

typedef UCHAR   (*FnREAD_PORT_UCHAR)(PVOID Port);
typedef USHORT  (*FnREAD_PORT_USHORT)(PVOID Port);
typedef ULONG   (*FnREAD_PORT_ULONG)(PVOID Port);
typedef VOID    (*FnWRITE_PORT_UCHAR)(PVOID Port, ULONG Value);
typedef VOID    (*FnWRITE_PORT_USHORT)(PVOID  Port, ULONG Value);
typedef VOID    (*FnWRITE_PORT_ULONG)(PVOID Port, ULONG Value);

#endif

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    LONG        xOffset;
    LONG        yOffset;
    LONG        xyOffset;
    BYTE*       pjBase;                 // Video coprocessor base
    BYTE*       pjPorts;                // Video port base
    BYTE*       pjScreen;               // Points to base screen address
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_24BPP
                                        //   (our current colour depth)
    ULONG       ulChipID;
    ULONG       ulChipNum;

    // -------------------------------------------------------------------
    // NOTE: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    HBITMAP     hbmTmpMono;             // Handle to temporary buffer
    SURFOBJ*    psoTmpMono;             // Temporary surface

    ULONG       flCaps;                 // Capabilities flags

//myf1, begin
    // Panning Scrolling Supported for TI
    LONG        min_Xscreen;    //Visible screen boundary.
    LONG        max_Xscreen;    //Visible screen boundary.
    LONG        min_Yscreen;    //Visible screen boundary.
   